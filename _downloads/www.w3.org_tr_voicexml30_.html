<!-- http://www.w3.org/TR/voicexml30/ -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org" />
<title>Voice Extensible Markup Language (VoiceXML) 3.0</title>
<style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

table {
        width:80%;
        border:1px solid #000;
        border-collapse:collapse;
        font-size:90%;
    }

td,th{
        border:1px solid #000;
        border-collapse:collapse;
        padding:5px;
    }   


caption{
        background:#ccc;
        font-size:140%;
        border:1px solid #000;
        border-bottom:none;
        padding:5px;
        text-align:center;
    }

img.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
p.caption {
  text-align: center
}
</style>

<link rel="stylesheet" type="text/css"
href="http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img
src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48"
width="72" /></a></p>

<h1><a name="title" id="title" />Voice Extensible Markup Language
(VoiceXML) 3.0</h1>

<h2><a name="w3c-doctype" id="w3c-doctype" />W3C Working Draft
<i>16</i> <i>December</i> <i>2010</i></h2>

<dl>
<dt>This version:</dt>

<dd><a
href="http://www.w3.org/TR/2010/WD-voicexml30-20101216/">http://www.w3.org/TR/2010/WD-voicexml30-20101216/</a></dd>

<dt>Latest version:</dt>

<dd><a
href="http://www.w3.org/TR/voicexml30/">http://www.w3.org/TR/voicexml30/</a></dd>

<dt>Previous version:</dt>

<dd><a
href="http://www.w3.org/TR/2010/WD-voicexml30-20100831/">http://www.w3.org/TR/2010/WD-voicexml30-20100831/</a></dd>

<dt>Editors:</dt>

<dd>Scott McGlashan, Hewlett-Packard (co-Editor-in-Chief)</dd>

<dd>Daniel C. Burnett, Voxeo (co-Editor-in-Chief)</dd>

<dd>Rahul Akolkar, IBM</dd>

<dd>RJ Auburn, Voxeo</dd>

<dd>Paolo Baggia, Loquendo</dd>

<dd>Jim Barnett, Genesys Telecommunications Laboratories</dd>

<dd>Michael Bodell, Microsoft</dd>

<dd>Jerry Carter, Nuance</dd>

<dd>Mangesh Deshmukh, Alcatel-Lucent</dd>

<dd>Matt Oshry, Microsoft</dd>

<dd>Kenneth Rehor, Cisco</dd>

<dd>Xu Yang, Aspect</dd>

<dd>Milan Young, Nuance</dd>

<dd>Rafah Hosn (until 2008, when at IBM)</dd>
</dl>

<p class="copyright"><a
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2010 <a href="http://www.w3.org/"><acronym
title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a
href="http://www.csail.mit.edu/"><acronym
title="Massachusetts Institute of Technology">MIT</acronym></a>, <a
href="http://www.ercim.eu/"><acronym
title="European Research Consortium for Informatics and Mathematics">
ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>),
All Rights Reserved. W3C <a
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">
liability</a>, <a
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">
trademark</a> and <a
href="http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>

<hr />
<div>
<h2><a name="abstract" id="abstract" />Abstract</h2>

<p>This document specifies VoiceXML 3.0, a modular XML language for
creating interactive media dialogs that feature synthesized speech,
recognition of spoken and DTMF key input, telephony, mixed
initiative conversations, and recording and presentation of a
variety of media formats including digitized audio, and digitized
video.</p>

<p>Its major goal is to bring the advantages of Web-based
development and content delivery to interactive voice response
applications.</p>
</div>

<div>
<h2><a name="status" id="status" />Status of this Document</h2>

<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a
href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>

<p>This is the 16 December 2010 Eighth Public Working Draft of
"Voice Extensible Markup Language (VoiceXML) 3.0". The main
differences from the previous draft are described in Appendix <a
href="#Changes"><b>F Major changes since the last Working
Draft</b></a>. A <a href="diff.html">diff-marked version</a> of
this document is also available for comparison purposes.</p>

<p>This document is very much a work in progress. Many sections are
incomplete, only stubbed out, or missing entirely. To get early
feedback, the group focused on defining enough functionality,
modules, and profiles to demonstrate the general framework. To
complete the specification, the group expects to introduce
additional functionality (for example speaker identification and
verification, external eventing) and describe the existing
functionality at the level of detail given for the Prompt and Field
modules. We explicitly request feedback on the framework,
particularly any concerns about its implementability or suitability
for expected applications. By early 2011 the group expects all key
capabilities to be present in the specification, with details
worked out by late 2011.</p>

<p>Applications written as 2.1 documents can be used under a 3.0
processor using the 2.1 profile. As an example, the Implementation
Report tests for 2.1 (which includes the IR tests for 2.0) will be
supported on a 3.0 processor. Exceptions will be clarifications and
changes needed to improve interoperability.</p>

<p>This document is a <a
href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsWD"
shape="rect">W3C Working Draft</a>. It has been produced as part of
the <a href="http://www.w3.org/Voice/Activity.html"
shape="rect">Voice Browser Activity</a>. The authors of this
document are participants in the <a href="http://www.w3.org/Voice/"
shape="rect">Voice Browser Working Group</a>. For more information
see the <a href="http://www.w3.org/Voice/#faq" shape="rect">Voice
Browser FAQ</a>. The Working Group expects to advance this Working
Draft to Recommendation status.</p>

<p>Comments are welcome on <a href="mailto:www-voice@w3.org"
shape="rect">www-voice@w3.org</a> (<a
href="http://lists.w3.org/Archives/Public/www-voice/"
shape="rect">archive</a>). See <a href="http://www.w3.org/Mail/"
shape="rect">W3C mailing list and archive usage guidelines</a>.</p>

<p>Publication as a Working Draft does not imply endorsement by the
W3C Membership. This is a draft document and may be updated,
replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in
progress.</p>

<p>This document was produced by a group operating under the <a
href="http://www.w3.org/Consortium/Patent-Policy-20040205/"
shape="rect">5 February 2004 W3C Patent Policy</a>. W3C maintains a
<a rel="disclosure"
href="http://www.w3.org/2004/01/pp-impl/34665/status"
shape="rect">public list of any patent disclosures</a> made in
connection with the deliverables of the group; that page also
includes instructions for disclosing a patent. An individual who
has actual knowledge of a patent which the individual believes
contains <a
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential"
 shape="rect">Essential Claim(s)</a> must disclose the information
in accordance with <a
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure"
 shape="rect">section 6 of the W3C Patent Policy</a>.</p>
</div>

<div class="toc">
<h2><a name="contents" id="contents" />Table of Contents</h2>

<p class="toc">1 <a href="#Terminology">Terminology</a><br />
2 <a href="#Overview">Overview</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a
href="#overview.v3structure">Structure of VoiceXML 3.0</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a
href="#overview.docstructure">Structure of this document</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#overview.howtoread">How to
read this document</a><br />
3 <a href="#DFP">Data Flow Presentation (DFP) Framework</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#Data">Data</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#DFP:Flow">Flow</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a
href="#Presentation">Presentation</a><br />
4 <a href="#Framework">Core Concepts</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#Descriptions">Syntactic and
Semantic descriptions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#Model.xml">Resources,
Resource Controllers, and Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.1 <a
href="#Framework:Controller">Top Level Controller</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="#Eventing">Event
Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1 <a
href="#InternalEvents">Internal Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.1
<a href="#d3e461">Event Interfaces</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.1.1
<a href="#d3e477">Event</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.1.2
<a href="#d3e497">EventTarget</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.1.3
<a href="#d3e508">EventListener</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.2
<a href="#d3e519">Event Flow</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.2.1
<a href="#d3e525">Event Listener Registration</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1.2.2
<a href="#d3e536">Event Listener Activation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.2 <a
href="#ExternalEvents">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a
href="#DocumentInitialization">Document Initialization and
Execution</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.1 <a
href="#d3e584">Initialization</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.1.1
<a href="#d3e591">DOM Processing</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.1.2
<a href="#d3e619">Preparation for Execution</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.2 <a
href="#d3e632">Execution</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.2.1
<a href="#d3e640">Subdialogs</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.2.2
<a href="#ApplicationRoot">Application Root</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.2.3
<a href="#d3e650">Summary of Syntax/Semantics Interaction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.3 <a
href="#d3e667">Transition Controllers</a><br />
5 <a href="#Resources">Resources</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a
href="#Resources:Datamodel">Datamodel Resource</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1 <a
href="#Resources:Datamodel:API">Data Model Resource API</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#Resources:PromptQueue">Prompt
Queue Resource</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a
href="#PromptQueue:StateChartRepresentation">State Chart
Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a
href="#PromptQueue:SCXMLRepresentation">SCXML
Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a
href="#PromptQueue:DefinedEvents">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 <a
href="#d3e939">Device Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.5 <a
href="#d3e990">Open Issue</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a
href="#Resources:Recognition">Recognition Resources</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.1 <a
href="#d3e1018">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.2 <a
href="#d3e1159">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.3 <a
href="#d3e1321">Device Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.4 <a
href="#d3e1423">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.5 <a
href="#d3e1435">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a
href="#Resources:Connection">Connection Resource</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.1 <a
href="#ConnectionResource:Definition">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 <a
href="#ConnectionResource:FinalProcessing">Final Processing
State</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3 <a
href="#d3e1455">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.4 <a
href="#d3e1530">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.5 <a
href="#d3e1536">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.5 <a href="#Resources:Timer">Timer
Resource</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.1 <a
href="#d3e1545">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.2 <a
href="#d3e1550">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.3 <a
href="#d3e1629">Device Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.4 <a
href="#d3e1668">State Chart Representation</a><br />
6 <a href="#Modules">Modules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a
href="#Grammar:GrammarModule">Grammar Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.1 <a
href="#GrammarModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.1.1
<a href="#d3e1706">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.1.2
<a href="#d3e1758">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2 <a
href="#GrammarModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2.1
<a href="#d3e1783">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2.2
<a href="#d3e1861">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2.3
<a href="#d3e1930">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2.4
<a href="#d3e1968">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2.5
<a href="#d3e1971">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.3 <a
href="#d3e1997">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.4 <a
href="#grammar:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a
href="#Grammar:InlineSRGSGrammarModule">Inline SRGS Grammar
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.1 <a
href="#InlineSRGSGrammarModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2 <a
href="#InlineSRGSGrammarModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2.1
<a href="#d3e2057">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2.2
<a href="#d3e2083">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2.3
<a href="#d3e2135">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2.4
<a href="#d3e2140">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.2.5
<a href="#d3e2144">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.3 <a
href="#InlineSRGSGrammarModule:Events">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2.4 <a
href="#InlineSRGSGrammarModule:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a
href="#Grammar:ExternalGrammarModule">External Grammar
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.1 <a
href="#Grammar:ExternalGrammarModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.1.1
<a href="#d3e2188">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.1.2
<a href="#ExternalSRGSGrammar:occurrence">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2 <a
href="#Grammar:ExternalGrammarModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2.1
<a href="#d3e2368">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2.2
<a href="#d3e2394">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2.3
<a href="#d3e2463">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2.4
<a href="#d3e2468">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2.5
<a href="#d3e2472">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.3 <a
href="#Grammar:ExternalGrammarModule:Events">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.4 <a
href="#external_grammar:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.4 <a href="#PromptModule">Prompt
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.1 <a
href="#PromptModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.1.1
<a href="#d3e2534">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.1.2
<a href="#d3e2643">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2 <a
href="#PromptModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2.1
<a href="#d3e2655">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2.2
<a href="#d3e2690">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2.3
<a href="#d3e2775">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2.4
<a href="#d3e2817">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.2.5
<a href="#d3e2823">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.3 <a
href="#PromptModule:Events">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.4 <a
href="#prompt:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.5 <a href="#BuiltinSSMLModule">Builtin
SSML Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5.1 <a
href="#SSMLModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5.2 <a
href="#SSMLModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5.3 <a
href="#SSML_prompt:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.6 <a href="#MediaModule">Media
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.1 <a
href="#MediaModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.1.1
<a href="#d3e3048">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.1.2
<a href="#d3e3275">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.1.2.1
<a href="#d3e3302">Tips (informative)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.2 <a
href="#MediaModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6.3 <a
href="#MediaModule:Examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.7 <a href="#ParseqModule">Parseq
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.7.1 <a
href="#ParseqModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.7.2 <a
href="#ParseqModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.7.3 <a
href="#ParseqModule:Examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.8 <a href="#ForeachModule">Foreach
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8.1 <a
href="#ForeachModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8.1.1
<a href="#d3e3564">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8.1.2
<a href="#d3e3616">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8.2 <a
href="#ForeachModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8.3 <a
href="#ForeachModule:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.9 <a href="#FormModule">Form
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.1 <a
href="#d3e3661">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2 <a
href="#d3e3696">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1
<a href="#RC:Form">Form RC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1.1
<a href="#d3e3715">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1.2
<a href="#d3e3768">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1.3
<a href="#d3e3852">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1.4
<a href="#d3e3952">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9.2.1.5
<a href="#d3e3964">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.10 <a href="#FieldModule">Field
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.1 <a
href="#d3e3972">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2 <a
href="#d3e4024">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1
<a href="#RC:Field">Field RC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1.1
<a href="#d3e4038">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1.2
<a href="#d3e4095">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1.3
<a href="#d3e4202">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1.4
<a href="#d3e4254">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.1.5
<a href="#d3e4260">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2
<a href="#RC:PlayAndRecognize">PlayandRecognize RC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2.1
<a href="#d3e4291">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2.2
<a href="#d3e4373">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2.3
<a href="#d3e4500">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2.4
<a href="#d3e4656">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10.2.2.5
<a href="#d3e4666">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.11 <a href="#BuiltinModule">Builtin
Grammar Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.11.1 <a
href="#d3e4674">Usage of Platform Grammars</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.11.2 <a
href="#d3e4688">Platform Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.11.3 <a
href="#d3e4701">Syntax and Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.11.4 <a
href="#d3e4794">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.12 <a href="#DAMModule">Data Access and
Manipulation Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.1 <a
href="#d1e73">Overview</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2 <a
href="#d1e82">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.1
<a href="#d1e88">The scope stack</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.2
<a href="#d1e162">Relevance of scope stack to properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.3
<a href="#d1e174">Implicit variables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.4
<a href="#d1e246">Variable resolution</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.5
<a href="#d1e344">Standard session variables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.6
<a href="#d1e402">Standard application variables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.2.7
<a href="#d1e505">Legal variable values and expressions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3 <a
href="#d1e514">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.1
<a href="#d1e520">Creating variables: the &lt;var&gt;
element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.2
<a href="#d1e742">Reading variables: "expr" and "cond" attributes
and the &lt;value&gt; element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.2.1
<a href="#d1e751">Inserting variable values in prompts: The
&lt;value&gt; element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.3
<a href="#d1e907">Updating variables: the &lt;assign&gt; and
&lt;data&gt; elements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.3.1
<a href="#d1e910">The &lt;assign&gt; element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.3.2
<a href="#d1e1108">The &lt;data&gt; element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.4
<a href="#d1e1456">Deleting variables: the &lt;clear&gt;
element</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.3.5
<a href="#d1e1703">Relevance for properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.4 <a
href="#d1e1712">Backward compatibility with VoiceXML 2.1</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12.5 <a
href="#d1e1757">Implicit functions using XPath</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.13 <a
href="#ExternalCommunicationModule">External Communication
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.1 <a
href="#ExternalCommunicationModule:Receive">Receiving external
messages within a voice application</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.1.1
<a href="#ExternalCommunicationModule:ReceiveReflect">External
Message Reflection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.1.2
<a href="#ExternalCommunicationModule:ReceiveAsync">Receiving
External Messages Asynchronously</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.1.3
<a href="#ExternalCommunicationModule:ReceiveSync">Receiving
External Messages Synchronously</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.1.3.1
<a
href="#ExternalCommunicationModule:ReceiveSyncReceive">&lt;receive&gt;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.2 <a
href="#ExternalCommunicationModule:Send">Sending messages from a
voice application</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13.2.1
<a
href="#ExternalCommunicationModule:SendTimeout">sendtimeout</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.14 <a href="#SessionRootModule">Session
Root Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.14.1 <a
href="#SessionRootModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.14.2 <a
href="#SessionRootModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.14.3 <a
href="#SessionRootModule:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.15 <a href="#RunTimeControl">Run Time
Control Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.1 <a
href="#d3e6567">&lt;rtc&gt;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.1.1
<a href="#d3e6570">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.2 <a
href="#d3e6620">&lt;cancelrtc&gt;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.2.1
<a href="#d3e6625">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.3 <a
href="#d3e6639">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15.4 <a
href="#d3e6648">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.16 <a href="#SIV">SIV Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.1 <a
href="#d3e6720">SIV Core Functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.2 <a
href="#d3e6773">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.3 <a
href="#SIVModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.3.1
<a href="#d3e7035">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.3.2
<a href="#d3e1625">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.3.3
<a href="#d3e1694">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.3.4
<a href="#d3e7305">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.4 <a
href="#d3e7310">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.16.5 <a
href="#d3e7351">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.17 <a href="#SubdialogModule">Subdialog
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.17.1 <a
href="#SubdialogModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.17.2 <a
href="#SubdialogModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.17.3 <a
href="#SubdialogModule:Examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.18 <a href="#DisconnectModule">Disconnect
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.1 <a
href="#DisconnectModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.1.1
<a href="#d3e7413">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.1.2
<a href="#d3e7446">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2 <a
href="#DisconnectModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2.1
<a href="#d3e7456">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2.2
<a href="#d3e7502">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2.3
<a href="#d3e7594">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2.4
<a href="#d3e7621">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.2.5
<a href="#d3e7627">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.18.3 <a
href="#DisconnectModule:Example">Example</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.19 <a href="#PlayModule">Play
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1 <a
href="#PlayModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1.1
<a href="#d3e7651">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1.2
<a href="#d3e7672">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1.3
<a href="#d3e7718">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1.4
<a href="#d3e7743">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.19.1.5
<a href="#d3e7749">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.20 <a href="#RecordModule">Record
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.1 <a
href="#RecordModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.1.1
<a href="#d3e7772">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.1.2
<a href="#d3e7897">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.1.3
<a href="#d3e7915">Data Model Variables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2 <a
href="#RecordModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1
<a href="#RC:RecordInputItem">RecordInputItem RC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1.1
<a href="#d3e7970">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1.2
<a href="#d3e8002">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1.3
<a href="#d3e8049">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1.4
<a href="#d3e8076">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.1.5
<a href="#d3e8082">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2
<a href="#RC:Record">Record RC</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2.1
<a href="#d3e8092">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2.2
<a href="#d3e8104">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2.3
<a href="#d3e8167">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2.4
<a href="#d3e8271">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.20.2.2.5
<a href="#d3e8277">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.21 <a href="#PropertyModule">Property
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.1 <a
href="#PropertyModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.1.1
<a href="#d3e8298">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.1.2
<a href="#d3e8352">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2 <a
href="#PropertyModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2.1
<a href="#d3e8366">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2.2
<a href="#d3e8371">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2.3
<a href="#d3e8376">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2.4
<a href="#d3e8381">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.2.5
<a href="#d3e8387">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.3 <a
href="#PropertyModule:Events">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.21.4 <a
href="#property:examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.22 <a href="#ControllerModule">Transition
Controller Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.1 <a
href="#ControllerModule:Syntax">Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.1.1
<a href="#d3e8433">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.1.2
<a href="#d3e8497">Content Model</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2 <a
href="#ControllerModule:Semantics">Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2.1
<a href="#d3e8511">Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2.2
<a href="#d3e8515">Defined Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2.3
<a href="#d3e8519">External Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2.4
<a href="#d3e8523">State Chart Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.2.5
<a href="#d3e8527">SCXML Representation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.3 <a
href="#ControllerModule:Events">Events</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.22.4 <a
href="#controller:examples">Examples</a><br />
7 <a href="#Profiles">Profiles</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.1 <a href="#Profile:Legacy">Legacy
Profile</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1 <a
href="#Legacy:Conformance">Conformance</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.1
<a href="#Legacy:RootRequirements">Vxml Root Module
Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.2
<a href="#Legacy:FormRequirements">Form Module
Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.3
<a href="#Legacy:FieldRequirements">Field Module
Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.4
<a href="#Legacy:PromptRequirements">Prompt Module
Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.5
<a href="#Legacy:GrammarRequirements">Grammar Module
Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1.6
<a href="#Legacy:DataRequirements">Data Access and Manipulation
Module Requirements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.2 <a
href="#Legacy:Convenience_Syntax">Convenience Syntax</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.3 <a
href="#Legacy:Default">Default Handlers and Transition
Controllers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.2 <a href="#Profile:Basic">Basic
Profile</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.1 <a
href="#BasicProfile:Introduction">Introduction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.2 <a
href="#BasicProfile:Contents">What the Basic Profile
includes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.2.1
<a href="#BasicProfile:SIV">SIV functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.2.2
<a href="#BasicProfile:Presentation">Presentation
functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.2.3
<a href="#BasicProfile:Capture">Capture functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.2.4
<a href="#BasicProfile:Other">Other modules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.3 <a
href="#BasicProfile:Results">Returned results</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.4 <a
href="#BasicProfile:NotIncluded">What the Basic Profile does not
include</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2.5 <a
href="#BasicProfile:Examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.3 <a href="#Profile:Maximal">Maximal
Profile</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.4 <a href="#Profile:Enhanced">Enhanced
Profile</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.5 <a
href="#Profile:ConvenienceSyntax">Convenience Syntax (Syntactic
Sugar)</a><br />
8 <a href="#Environment">Environment</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#ResourceFetching">Resource
Fetching</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.1 <a
href="#Fetching">Fetching</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.2 <a
href="#Caching">Caching</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.2.1
<a href="#Controlling_the_Caching_Policy">Controlling the Caching
Policy</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.3 <a
href="#Prefetching">Prefetching</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.4 <a
href="#Protocols">Protocols</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;8.2 <a
href="#Properties">Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.1 <a
href="#Properties:ASR">Speech Recognition Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.2 <a
href="#Properties:DTMF">DTMF Recognition Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.3 <a
href="#Properties:PromptandCollect">Prompt and Collect
Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.4 <a
href="#Properties:Media">Media Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.5 <a
href="#Properties:Fetch">Fetch Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.6 <a
href="#Properties:Misc">Miscellaneous Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;8.3 <a href="#Timing_Properties">Speech and
DTMF Input Timing Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1 <a
href="#d3e9650">DTMF Grammars</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.1
<a href="#timeout_No_Input_Provided">timeout, No Input
Provided</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.2
<a
href="#interdigittimeout_Grammar_is_Not_Ready_to_Terminate">interdigittimeout,
Grammar is Not Ready to Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.3
<a
href="#interdigittimeout_Grammar_is_Ready_to_Terminate">interdigittimeout,
Grammar is Ready to Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.4
<a
href="#termchar_and_interdigittimeout_Grammar_Can_Terminate">termchar
and interdigittimeout, Grammar Can Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.5
<a href="#termchar_Empty_When_Grammar_Must_Terminate">termchar
Empty When Grammar Must Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.6
<a href="#d3e9702">termchar Non-Empty and termtimeout When Grammar
Must Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.7
<a href="#d3e9711">termchar Non-Empty and termtimeout When Grammar
Must Terminate</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1.8
<a href="#Invalid_DTMF_Input">Invalid DTMF Input</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2 <a
href="#d3e9725">Speech Grammars</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2.1
<a href="#timeout_When_No_Speech_Provided">timeout When No Speech
Provided</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2.2
<a
href="#completetimeout_With_Speech_Grammar_Recognized">completetimeout
With Speech Grammar Recognized</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2.3
<a
href="#incompletetimeout_with_Speech_Grammar_Unrecognized">incompletetimeout
with Speech Grammar Unrecognized</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;8.4 <a href="#ValueDesignations">Value
Designations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.4.1 <a
href="#IntegerDesignation">Integers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.4.2 <a
href="#RealNumberDesignation">Real Numbers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.4.3 <a
href="#TimeDesignation">Times</a><br />
9 <a href="#Integration">Integration with Other Markup
Languages</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;9.1 <a
href="#Integration:WithinSCXML">Embedding of VoiceXML within
SCXML</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;9.2 <a
href="#Integration:InsideVoiceXML">Integrating Flow Control
Languages into VoiceXML</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.1 <a
href="#Integration:InsideVoiceXML:SCXMLForDialog">SCXML for Dialog
Management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.1.1
<a
href="#Integration:InsideVoiceXML:SCXMLForDialog:SystemDriven">System-driven
Dialog</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.1.2
<a
href="#Integration:InsideVoiceXML:SCXMLForDialog:UserDriven">User-driven
Dialog</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.2 <a
href="#Integration:InsideVoiceXML:GracefulDegradation">Graceful
Degradation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.3 <a
href="#Integration:InsideVoiceXML:RecursiveMVC">SCXML as Basis for
Recursive MVC</a><br />
</p>

<h3><a name="appendices" id="appendices" />Appendices</h3>

<p class="toc">A <a
href="#Acknowledgements">Acknowledgements</a><br />
B <a href="#References">References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.1 <a href="#d3e9925">Normative
References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.2 <a href="#d3e9988">Informative
References</a><br />
C <a href="#Glossary_of_Terms">Glossary of Terms</a><br />
D <a href="#Schema">VoiceXML 3.0 XML Schema</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.1 <a href="#Schema:Root">Schema for VXML
Root Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.2 <a href="#Schema:Form">Schema for Form
Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.3 <a href="#Schema:Field">Schema for
Field Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.4 <a href="#Schema:Prompt">Schema for
Prompt Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.5 <a href="#Schema:BuiltinSSML">Schema
for Builtin SSML Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.6 <a href="#Schema:Foreach">Schema for
Foreach Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.7 <a href="#Schema:Data">Schema for Data
Access and Manipulation Module</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;D.8 <a href="#Schema:Legacy">Schema for
Legacy Profile</a><br />
E <a href="#V2Convenience">Convenience Syntax in VoiceXML
2.x</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.1 <a
href="#V2Convenience:SimplifiedDialogs">Simplified Dialog
Structure</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.2 <a
href="#V2Convenience:Examples">Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.2.1 <a
href="#V2Convenience:MenuWithChoice">&lt;menu&gt; with
&lt;choice&gt;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.2.2 <a
href="#V2Convenience:EquivFormFieldOption">Equivalent &lt;form&gt;,
&lt;field&gt;, &lt;option&gt;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.2.3 <a
href="#V2Convenience:EquivFormFieldGrammar">Equivalent
&lt;form&gt;, &lt;field&gt;, &lt;grammar&gt;</a><br />
F <a href="#Changes">Major changes since the last Working
Draft</a><br />
</p>
</div>

<hr />
<div class="body">
<div class="div1">
<h2><a name="Terminology" id="Terminology" />1 Terminology</h2>

<p>In this document, the key words "must", "must not", "required",
"shall", "shall not", "should", "should not", "recommended", "may",
and "optional" are to be interpreted as described in <a
href="#RFC2119">[RFC2119]</a> and indicate required levels for
compliant VoiceXML 3.0 implementations.</p>

<p>Terms used in this specification are defined in Appendix <a
href="#Glossary_of_Terms"><b>C Glossary of Terms</b></a>.</p>
</div>

<div class="div1">
<h2><a name="Overview" id="Overview" />2 Overview</h2>

<p>How does one build a successor to VoiceXML 2.0/2.1? Requests for
improvements to VoiceXML fell into two main categories:
extensibility and new functionality.</p>

<p>To accommodate both, the Voice Browser Working Group</p>

<ol class="enumar">
<li>Developed the detailed semantic descriptions of VoiceXML
functionality that versions 2.0 and 2.1 lacked. The semantic
descriptions clarify the meaning of the VoiceXML 2.0 and 2.1
functionalities and how they relate to each other. The semantic
descriptions are represented in this document as English text, UML
state chart visual diagrams [<font color="red">&lt;xref&gt;UML 2
State Machine Diagrams&lt;/xref&gt;</font> and/or textual SCXML
representations [<font color="red">&lt;xref&gt;State Chart XML
(SCXML): State Machine Notation for Control
Abstraction&lt;/xref&gt;</font>]. Figure 1 illustrates the VoiceXML
3.0 framework which illustrates some abstract UML state chart
visual diagrams representing some existing VoiceXML functionality.
<img class="center" src="Images/2.0_functionality.png"
alt="Functionality from VoiceXML 2.0" />
<p class="caption">Figure 1: VoiceXML 3.0 Framework - The
red-filled cells indicates some functionality from VoiceXML 2.0
expressed as state charts</p>
</li>

<li>Described the detailed semantics for new functionality. New
functions include, for example, speaker identification and
verification, video capture and replay, and a more powerful prompt
queue. These semantic descriptions for these new functions are also
represented in this document as English text, UML state chart
visual diagrams [ref] and/or textual SCXML representations [ref].
Figure 2 contains some abstract UML state chart visual diagrams
representing new functionality. <img class="center"
src="Images/new_functionality.png" alt="New functionality" />
<p class="caption">Figure 2: VoiceXML 3.0 Framework - The
red-filled cells indicates new functionality</p>
</li>

<li>Organized the functionality into modules, with each module
implementing different functions. One reason for the introduction
of a more rigorous semantic definition is that it allows us to
assign semantics to individual modules. This makes it easier to
understand what happens when modules are combined or new ones are
defined. In contrast, VoiceXML 2.0 and 2.1 had a single global
semantic definition (the FIA), which made it difficult to
understand what would happen if certain elements were removed from
the language or if new ones were added. Figure 3 illustrates some
modules, each containing VoiceXML 3.0 functionality Vendors may
extend VoiceXML functionality by creating additional modules with
additional functionality not described in this document. For
example, a vendor might create a new GPS input module. Application
developers should be cautious about using vendor-specific modules
because the resulting application may not be portable. <img
class="center" src="Images/modules.png" alt="Modules" />
<p class="caption">Figure 3: VoiceXML 3.0 Framework - The red
bolded rectangles indicates modules</p>
</li>

<li>Restructured and revised the syntax of each module to
incorporate any new functionality. Application developers use the
syntax of each module as an API to invoke the module’s functions.
Figure 4 illustrates some simplified syntax associated with
modules. <img class="center" src="Images/syntax.png"
alt="Syntax" />
<p class="caption">Figure 4: VoiceXML 3.0 Framework - The bolded
red text indicates syntax</p>
</li>

<li>Introduced the concept of a profile (language) which
incorporates the syntax of several modules. Figure 5 illustrates
two profiles. For example, a VoiceXML 2.1 profile incorporates the
syntax of most of the modules corresponding to the VoiceXML 2.1
functionality which will support most existing VoiceXML 2.1
applications. Thus most VoiceXML 2.1 applications can be easily
ported to VoiceXML 3.0 using the VoiceXML 2.1 profile. Another
profile omits the VoiceXML 2.1 Form Interpretation Algorithm (FIA).
This profile may be used by developers who want to define their one
own flow control rather than using the FIA. Profiles enable
platform developers to select just the functionality that
application developers need for a platform or class of application.
Multiple profiles enables developers to use just the profile
(language) needed for a platform or class of applications. For
example, a lean profile for portable devices, or a full-function
profile for servers-based applications using all of the new
functionality of VoiceXML 3.0. <img class="center"
src="Images/profiles.png" alt="Profiles" />
<p class="caption">Figure 5: VoiceXML 3.0 Framework - The dotted
red area and the dashed green area indicate two profiles</p>
</li>
</ol>

<p>One of the benefits of detailed semantic descriptions is
improving portability within VoiceXML. Two vendors may implement
the same functionality differently; however, the functionality must
be consistent with the semantic meanings described in this document
so that application authors are isolated from the different
implementations. This increases portable among platforms that
support the same syntax. Note that there are many other factors
that effect to the portability that is outside the scope of this
document (e.g. speech recognition capabilities, telephony).</p>

<div class="div2">
<h3><a name="overview.v3structure" id="overview.v3structure" />2.1
Structure of VoiceXML 3.0</h3>

<p>This document covers the following:</p>

<ul>
<li>This document explains the core of VoiceXML 3.0, an extensible
framework that describes how semantics are defined, how syntax is
defined and how the two are connected together. In this document,
the "semantics" are the definitions of core functionality, such as
might be used by an implementer of VoiceXML 3.0. The definitions
are represented as English text, SCXML syntax, and/or state chart
diagrams. The term "syntax" refers to XML elements and attributes
that are an application author's programming interface to the
functionality defined by the "semantics".</li>

<li>Within this document, all the functionality of VoiceXML 3.0 is
grouped into modules of related capabilities.</li>

<li>Modules can be combined together to create complete profiles
(languages). This document describes how to define both modules and
profiles.</li>

<li>In addition to describing the general framework, this document
explicitly defines a broad range of functionality, several modules
and two profiles.</li>
</ul>
</div>

<div class="div2">
<h3><a name="overview.docstructure"
id="overview.docstructure" />2.2 Structure of this document</h3>

<p>The remainder of this document is structured as follows:</p>

<p><a href="#DFP"><b>3 Data Flow Presentation (DFP)
Framework</b></a> presents the Data-Flow-Presentation Framework,
its importance for the development of VoiceXML 3.0 and how VoiceXML
3.0 fits into the model.</p>

<p><a href="#Framework"><b>4 Core Concepts</b></a> explains the
core concepts underlying the new structure for VoiceXML, including
resources, resource controllers, the relationship between syntax
and semantics, DOM eventing, modules and profiles.</p>

<p><a href="#Resources"><b>5 Resources</b></a> presents the
resources defined for the language. These provide the key
presentation-related functionality in the language.</p>

<p><a href="#Modules"><b>6 Modules</b></a> presents the modules
defined for the language. Each module consists of a syntax piece
(with its user-visible events), a semantics piece (with its
behind-the-scenes events) and a description of how the two are
connected.</p>

<p><a href="#Profiles"><b>7 Profiles</b></a> presents two profiles.
The first, the VoiceXML 2.1 profile, shows how a language similar
to VoiceXML 2.1 can be created using the structure and
functionality of VoiceXML 3.0. The second, the Basic profile,
leaves out higher-level flow control constructs such as
&lt;form&gt; and the associated Form Interpretation Algorithm.</p>

<p>The Appendices provide useful references and a glossary of terms
used in the specification.</p>
</div>

<div class="div2">
<h3><a name="overview.howtoread" id="overview.howtoread" />2.3 How
to read this document</h3>

<p>For everyone: Please first read <a href="#DFP"><b>3 Data Flow
Presentation (DFP) Framework</b></a>. The data-flow- presentation
distinction applies not only to VoiceXML 3.0, but to many of W3C's
specifications. Understanding VoiceXML's role as a presentation
language is crucial context for understanding the rest of the
specification.</p>

<p>For application authors: we recommend that you begin with syntax
and only gradually explore details of the semantics as you need to
understand behavioral specifics.</p>

<ol class="enumar">
<li>If you are familiar with VoiceXML 2 you might want to begin
with the Legacy profile in <a href="#Profile:Legacy"><b>7.1 Legacy
Profile</b></a> to see an example of all the syntactic pieces in
the finished profile.</li>

<li>You should then review the syntax sections of each of the
modules in <a href="#Modules"><b>6 Modules</b></a>, along with the
Basic profile in <a href="#Profile:Basic"><b>7.2 Basic
Profile</b></a>. When you need to understand how a bit of syntax is
implemented, read the semantics section corresponding to that
syntax.</li>

<li>Along the way you will definitely want to review the parts of
<a href="#Framework"><b>4 Core Concepts</b></a> that are relevant
to your other reading (profiles, modules, syntax, semantics, and
DOM eventing).</li>
</ol>

<p>For VoiceXML platform developers: we recommend that you begin
with the functionality and framework and only focus on syntax
later.</p>

<ol class="enumar">
<li>If you are familiar with VoiceXML 2 you might want to begin
with the Legacy profile in <a href="#Profile:Legacy"><b>7.1 Legacy
Profile</b></a> to see the user-visible differences between the
original VoiceXML 2.1 language and the new Legacy profile. A brief
review of the Basic profile in <a href="#Profile:Basic"><b>7.2
Basic Profile</b></a> would be good as well.</li>

<li>Next you should review <a href="#Framework"><b>4 Core
Concepts</b></a> in detail, since the rest of the language is built
upon the framework described there.</li>

<li><a href="#Resources"><b>5 Resources</b></a> and <a
href="#Modules"><b>6 Modules</b></a> (the semantics part) should be
the bulk of your focus. Remember that they are semantic
descriptions only and that you can implement the functionality any
way you wish as long as the semantics remain the same.</li>

<li>One significant difference from VoiceXML 2.1 is support for DOM
<a href="#Eventing"><b>4.4 Event Model</b></a> .</li>
</ol>
</div>
</div>

<div class="div1">
<h2><a name="DFP" id="DFP" />3 Data Flow Presentation (DFP)
Framework</h2>

<p>Unlike VoiceXML 2.0/2.1, the focus in VoiceXML 3.0 is almost
exclusively on the user interface portions of the language. By
choice, very little work has gone into the development of data
storage and manipulation or control flow capabilities. In short,
VoiceXML 3.0 has been designed from the ground up as a
*presentation* language, according to the definition presented in
the Data Flow Presentation (<a href="#DFP">[DFP]</a>)
Framework.</p>

<p>Although VoiceXML 3.0 is a presentation language, it also
contains within it all 3 levels of the DFP framework ( Figure
6).</p>

<img class="center" src="Images/dfp_architecture.png"
alt="DFP Architecture" />
<p class="caption">Figure 6: DFP Architecture</p>

<p>The Data Flow Presentation (DFP) Framework is an instance of the
Model-View-Controller paradigm, where computation and control flow
are kept distinct from application data and from the way in which
the application communicates with the outside world. This
partitioning of an application allows for any one layer to be
replaced independently of the other two. In addition, it is
possible to simultaneously make use of more than one Data (Model)
language, Flow (Controller), and/or Presentation (View)
language.</p>

<div class="div2">
<h3><a name="Data" id="Data" />3.1 Data</h3>

<p>The Data layer of VoiceXML 3.0 is responsible for maintaining
all presentation-specific information in a format that is easily
accessible and easily editable. Note that the data layer of
VoiceXML 3.0 is very different from the backend data for an
application. Presentation-specific datainformation disappears when
the VoiceXML 3.0 application terminates, while data in the backend
database continues to exist after VoiceXML 3.0 terminates. Examples
of presentation-specific data might include the status of the
dialog in collecting certain information, which prompts have just
been played, and how many of various error conditions have occurred
so far, and the values entered by the user until they are
transmitted to the back-end database or file system.</p>

<p>Within VoiceXML 3.0 the Data layer is realized through a
pluggable data language and a data access or manipulation language.
Access to and use of the data is aligned with options available in
SCXML for simpler interaction with the Flow layer (see the next
section). This specification defines two specific data languages,
XML and ECMAScript, and two data access and manipulation languages,
E4X/DOM and XPath. Others may be defined by implementers.</p>
</div>

<div class="div2">
<h3><a name="DFP:Flow" id="DFP:Flow" />3.2 Flow</h3>

<p>The Flow layer of VoiceXML 3.0 is responsible for all
application control flow, including business logic, dialog
management, and anything else that is not strictly data or
presentation. VoiceXML 3.0 provides primitives that contain the
control flow needed to implement them, but all combinations between
and among the elements at the syntax level is done via calls to
external control flow processors. Two that are likely to be used
with VoiceXML are CCXML and SCXML. Note that flow control
components written outside of VoiceXML may be communicating not
only with a VoiceXML processor but with an HTML browser, a video
game controller, or any of a variety of other input and output
components.</p>
</div>

<div class="div2">
<h3><a name="Presentation" id="Presentation" />3.3
Presentation</h3>

<p>The Presentation layer of VoiceXML 3.0 is responsible for all
interaction with the outside world, i.e., human beings and external
software components. VoiceXML 3.0 *is* the Presentation layer.
Designed originally for human-computer interaction, VoiceXML
"presents" a dialog by accepting audio and dtmf input and producing
audio and video output. All [?] of the modules defined in this
document belong to the VoiceXML 3.0 presentation layer.</p>
</div>
</div>

<div class="div1">
<h2><a name="Framework" id="Framework" />4 Core Concepts</h2>

<div class="div2">
<h3><a name="Descriptions" id="Descriptions" />4.1 Syntactic and
Semantic descriptions</h3>

<p>This document specifies the VoiceXML 3.0 language as a
collection of modules. Each module is described at two levels:</p>

<ol class="enumar">
<li><em>Syntax level</em> -- The syntax is a set of XML elements,
attributes, and events used by VoiceXML 3.0 application developers
to specify applications. The VoiceXML 3.0 elements and attributes
are specified within each module and in the XML schema in appendix
<a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a>. The events
are DOM level 3 events. This document provides a textual
description of each element, attribute, and event.</li>

<li><em>Semantics level</em> -- The semantics of each module is
described in terms of resources, resource controllers, and semantic
events that the resource controllers may generate and consume.
Semantics is described by both UML state chart visual diagrams and
SCXML representations.</li>
</ol>

<p>The visual UML state chart diagrams are informative. They are
included for ease of reading and quick understanding. The more
detailed textual SCXML representations are normative.</p>

<p>It is important to note that this model places no burden or
requirements that a VoiceXML interpreter must implement behavior as
described in the model. Rather, the requirement is that the
behavior must be the same as if it were implemented as described,
but it is permitted to have optimizations or different architecture
behind the implementation of the markup interpretation.</p>

<p>The semantic descriptions are important for reasons including
the following:</p>

<ul>
<li>Enable alternative implementations of a module. The modular
description in this document describes the semantics — "what" a
module does, but not "how" a module is implemented. A module may be
implemented differently on different platforms.</li>

<li>Enable alternative syntax for the semantic description code.
For example, one platform developer might use a particular syntax
for server-based modules, while another platform developer might
use an alternative syntax for an embedded mobile platform.</li>

<li>The same semantic descriptions can be reused in multiple
modules. For example, the semantic description of the <a
href="#PromptModule"><b>6.4 Prompt Module</b></a> can be reused
(referenced) from within the <a
href="#Resources:PromptQueue"><b>5.2 Prompt Queue
Resource</b></a>.</li>
</ul>
</div>

<div class="div2">
<h3><a name="Model.xml" id="Model.xml" />4.2 Resources, Resource
Controllers, and Events</h3>

<p>The resources, resource controllers, and the events they
generate are intended only to describe the semantics of VoiceXML 3
modules. Implementations are not required to use SCXML to implement
VoiceXML 3 modules, nor must they create objects corresponding to
resources, resource controllers, and the SCXML events they
raise.</p>

<p>The logical SCXML events must be distinguished from the
author-visible DOM events that are a mandatory part of the VoiceXML
3 language. Implementations MUST raise these DOM events and process
them in the manner described in <a href="#Eventing"><b>4.4 Event
Model</b></a> . The interaction between actual DOM events and
logical SCXML events is described in <a
href="#DocumentInitialization"><b>4.5 Document Initialization and
Execution</b></a>, below.</p>

<p>Each VoiceXML 3.0 module is described using SCXML notation and
optionally a UML state chart representation of its underlying
behavior expressed in terms of resources and resource controllers.
While the resources and resource controllers are not exposed
directly in the markup, they are used to define the semantics of
VoiceXML 3.0 markup elements. Figure 7 illustrates the relationship
among resource controllers, resources, and media devices. The
arrows represent events exchanged among components. A more concrete
example is represented in Figure 8 which illustrates the Prompt
Resource controller (further defined in <a
href="#PromptModule:Semantics"><b>6.4.2 Semantics</b></a>), the
PromptQueue Resource, and the SSML Media Player.</p>

<img class="center" src="Images/ModelOverview.png"
alt="Semantic model overview" />
<p class="caption">Figure 7: Semantic model with Resources and
Resource Controllers</p>

<img class="center" src="Images/ModelDetail.png"
alt="Semantic model details" />
<p class="caption">Figure 8: Semantic model with Specific
Examples</p>

<div class="div3">
<h4><a name="Framework:Controller"
id="Framework:Controller" />4.2.1 Top Level Controller</h4>

<p>In addition to the Resource Controllers associated with elements
like &lt;form&gt;, there is a top-level controller associated with
the &lt;vxml&gt; element that is responsible for starting
processing and deciding which Resource Controller to execute next
(i.e., for &lt;form&gt; or other interaction element ). The
top-level controller also holds session level properties and is
responsible for returning results to the Flow Level when script
execution terminates.</p>
</div>
</div>

<div class="div2">
<h3><a name="Syntax" id="Syntax" />4.3 Syntax</h3>

<p>VoiceXML 3.0 elements are defined using Schema and represented
in DOM (Level 3).</p>
</div>

<div class="div2">
<h3><a name="Eventing" id="Eventing" />4.4 Event Model</h3>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: We really
need to dig in on how the traditional throw/catch from VXML 2.0
work. How does the event handler selection work (complete with
partial event name matching, generic count, best count, cond,
document order, as-if-by-copy, etc.)? All of that has to be
implemented as the default behavior of the vxmlevent event, which
means the vxmlevent needs to be targeted at the right node (the one
that is going to be where the as-if-by-copy occurs) and that the
payload of the vxmlevent needs to include the event name and the
count. We may also want to expose (in JS bindings) the creation of
the list of candidate catch handlers as the algorithm is run.</td>
</tr>
</table>

<div class="div3">
<h4><a name="InternalEvents" id="InternalEvents" />4.4.1 Internal
Events</h4>

<p>The event model for VoiceXML 3.0 builds upon the DOM Level 3
Events <a href="#DOM3Events">[DOM3Events]</a> specification. <a
href="http://www.w3.org/TR/DOM-Level-3-Events/">DOM Level 3
Events</a> offer a robust set of interfaces for managing the
listener registration, dispatching, propagation, and handling of
events, as well as a description of how events flow through an XML
tree.</p>

<p>The DOM 3.0 event model offers VoiceXML developers a rich set of
interfaces that allow them to easily add behavior to their
applications. In addition, conforming to the standard DOM event
model enables authors to integrate their Voice applications in next
generation multimodal or multi-namespaced frameworks such as <a
href="http://www.w3.org/2002/mmi/">MMI</a> and <a
href="http://www.w3.org/2004/CDF/">CDF</a> with minimal efforts.
Note that the VXML 2.0 style events are supported through a new DOM
event named 'vxmlevent', and if this vxmlevent is uncanceled then
the default action is to run the VXML 2.0 event handling.</p>

<p>Within the VoiceXML 3.0 semantic model, the DOM Level 3 Events
APIs are available to all <em>Resource Controllers</em> that have
markup elements associated with them. Indeed, this section covers
the eventing APIs as available to VoiceXML 3.0 markup elements. The
following section describes how the semantic model ties in with the
DOM eventing model.</p>

<div class="div4">
<h5><a name="d3e461" id="d3e461" />4.4.1.1 <cite>Event
Interfaces</cite></h5>

<p>All VoiceXML 3.0 markup elements implement interfaces that
support the following:</p>

<ul>
<li>Subscription to events by event listeners and, symmetrically,
the removal of event listeners.</li>

<li>Publishing of the events emitted by their resources.</li>

<li>Event handling.</li>
</ul>

<div class="div5">
<h6><a name="d3e477" id="d3e477" />4.4.1.1.1
<cite>Event</cite></h6>

<p>The VoiceXML 3.0 Event interface extends the DOM Level 3 <a
href="http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#interface-Event">
Event</a> interface to support voice specific event information. In
particular, the VoiceXML 3.0 Event interface supports a
<em>count</em> integer that stores the number of times a resources
emits a particular event type. The semantic model manages the
<em>count</em> field by incrementing its value and resetting it as
described in the section that follows.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: Because we
now are using the 'vxmlevent' DOM event, we don't need to add a
count to the generic DOM events (and thus change the generic DOM
events). Instead, we need to specify the count as one of the
properties of the vxmlevent event.</td>
</tr>
</table>
</div>

<div class="div5">
<h6><a name="d3e497" id="d3e497" />4.4.1.1.2
<cite>EventTarget</cite></h6>

<p>VoiceXML 3.0 markup elements implement the DOM Level 3 <a
href="http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#interface-EventTarget">
EventTarget</a> interface.This interface allows registration and
removal of event listeners as well as dispatching of events.</p>
</div>

<div class="div5">
<h6><a name="d3e508" id="d3e508" />4.4.1.1.3
<cite>EventListener</cite></h6>

<p>The VoiceXML 3.0 markup elements implement the DOM Level 3 <a
href="http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#interface-EventListener">
EventListener</a> interface. This interface allows the activation
of handlers associated with a particular event. When a listener is
activated, the event handler execution is done in the semantic
model as described in the section that follows.</p>
</div>
</div>

<div class="div4">
<h5><a name="d3e519" id="d3e519" />4.4.1.2 <cite>Event
Flow</cite></h5>

<div class="div5">
<h6><a name="d3e525" id="d3e525" />4.4.1.2.1 <cite>Event Listener
Registration</cite></h6>

<p>The DOM Level 3 Event specification supports the notion of
partial ordering using the <a
href="http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Event-groups">
event listener group</a>; all events within a group are ordered. As
such, in VoiceXML 3.0, event listeners are registered as they are
encountered in the document. Furthermore, all event listeners
registered on an element belong to the same default group. Both of
these provisions ensure that event handlers will execute in
document order.</p>
</div>

<div class="div5">
<h6><a name="d3e536" id="d3e536" />4.4.1.2.2 <cite>Event Listener
Activation</cite></h6>

<p>An event listener is triggered if:</p>

<ol class="enumar">
<li>The type of the event propagating through the markup element
matches the type or category of the event listener.</li>

<li>The event propagation has not been stopped for the listener's
group.</li>
</ol>

<p></p>

<p>Once an event listener is triggered, the execution is handled by
the semantic model as described in the section below. Event
propagation blocks until it is notified by the semantic model to
proceed.</p>
</div>
</div>
</div>

<div class="div3">
<h4><a name="ExternalEvents" id="ExternalEvents" />4.4.2 External
Events</h4>

<p>VoiceXML 3.0 interpreters may receive events from external
sources, for example SCXML engines. In particular, it may receive
the life cycle events specified as part of the Multimodal
Architecture and Interfaces specification <a href="#MMI">[MMI]</a>.
These life cycle events allow the flow component of the DFP
architecture to control the presentation layer by starting and
stopping the processing of markup. By handling these events, the
VoiceXML interpreter acts as a 'modality component' in the
multimodal architecture, while the flow component acts as an
'interaction manager'. As a result, VoiceXML 3 applications can be
easily extended into multimodal applications. However it is
important to note that support for the life cycle events is
required by the DFP framework in all applications, whether uni- or
multimodal.</p>

<p>The interpreter must handle the following life cycle events
automatically:</p>

<ul>
<li>PrepareRequest. This event instructs the interpreter to prepare
to run a VoiceXML script. The event contains: a) either the URI of
the markup to run or the actual markup itself, b) a context ID
which will be used in subsequent messages referring to the same
markup, and c) a specification of media channel to use. Note that
the interpreter does not actually start running the markup in
question when it receives this message. Once the interpreter has
finished its preparation, it sends a PrepareResponse event in
reply. The PrepareResponse event contains the context ID that was
sent in the PrepareRequest plus a status field containing 'success'
or 'failure'. This message with a status of 'success' thus
indicates that the interpreter is now ready to run the specified
markup.</li>

<li>StartRequest. This event instructs the interpreter to run the
specified script. It will contain the same context ID as the
preceding PrepareRequest, and may optionally contain a new
specification of the markup to run and the media channel to use,
overriding those contained in the PrepareRequest. This event may
also be sent without a preceding PrepareRequest. When the
interpreter receives this event, it must start running the
specified markup using the specified media channel. It will then
send a StartResponse event in reply.</li>

<li>CancelRequest with 'immediate' flag set to true. This event
instructs the interpreter to disconnect from the media and to stop
processing the markup. This event contains the context ID. The
interpreter may continue processing clean-up handlers etc. after it
receives this event, but it should not end any events back to the
sender other than the CancelResponse, which acknowledges the
receipt of this command. If the 'immediate' flag is set to false,
the interpreter passes the event up to be handled by author code,
as described below.</li>

<li>ClearContextRequest???</li>
</ul>

<p>All other life cycle events and all other external events are
ignored unless the External Communications Module <a
href="#ExternalCommunicationModule"><b>6.13 External Communication
Module</b></a> is included in the profile. If the External
Communications Module is present, all other external events are
passed up to the application, placed in the application event queue
and then handled as specified by the developer using the
functionality defined in that module.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: Should
ClearContextRequest be handled automatically? Should Done be sent
automatically when the document is finished? Where do these
response events get sent?</td>
</tr>
</table>
</div>
</div>

<div class="div2">
<h3><a name="DocumentInitialization"
id="DocumentInitialization" />4.5 Document Initialization and
Execution</h3>

<div class="div3">
<h4><a name="d3e584" id="d3e584" />4.5.1 Initialization</h4>

<p>VoiceXML 3.0 document initialization takes place over two
phases: "DOM Processing" and "Preparation for Execution". Both of
these phases assume the required resources have already been
created. Any errors in the initialization of the document or the
creation of these resources MUST be thrown in the calling context.
If that context was a VoiceXML document, then this MUST be an
error.badfetch.</p>

<p>Note that while these phases are ordered, and the steps within
the phases ordered, this is only a logical ordering.
Implementations are allowed to use a different ordering as long as
behave as if they were following the specified ordering.</p>

<div class="div4">
<h5><a name="d3e591" id="d3e591" />4.5.1.1 DOM Processing</h5>

<p>The first step in initializing a VoiceXML 3.0 document (root
document or child) is generating the Level-3 DOM. This task
involves both checking the document for well formed XML and full
schema and syntax validation to ensure proper tag/attribute
relationships.</p>

<p>Once complete, the interpreter invokes the semantic constructor
for the root &lt;vxml&gt; node in the DOM. In this context, the
term "semantic constructor" represents whatever mechanism is used
to create the Resource Controllers for a given node. No particular
implementation is implied or required. The root &lt;vxml&gt; node
constructor is responsible for invoking the constructors for all
nodes in the document that have them. When it does this, it will
call the semantic constructor routine passing it</p>

<ol class="enumar">
<li>a pointer to the node that has the constructor</li>

<li>a pointer to the root of the DOM</li>

<li>an arbitrary data structure</li>
</ol>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Open Issue: we must specify the operation of the root node
constructor in more detail as part of the V3 specification. Other
people can define modules, but we must specify how they are
assembled into a full semantic representation of the application.)
If there is an application root document specified, the root node
constructor will have to construct its RCs as well, by calling its
root node constructor.</p>

<p>Also, needs to happen after creation of RCs and before general
semantic initialization. After the creation of of the RCs is when
the mapping from syntax to RCs will occur, and that's when the list
would be known.</p>
</td>
</tr>
</table>

<p>Note that the initial construction process creates the RCs but
does not necessarily fully configure them. Further initialization,
including in particular the creation of variables and variable
scopes, will happen only when the RCs are activated at runtime
(e.g. by visiting a Form). However, at this point the list of
children for each element (and thus each RC) is known. For each RC
this list of children will populate into the appropriate place in
the RC data model before semantic initialization of the RC.</p>

<p>Once the RCs are constructed, they are independent of the DOM,
except for the interactions specified below. However, while they
are running the RCs often make use of what appears to be syntactic
information. For example, the concept of 'next item' relies heavily
on document order, while &lt;goto&gt; can take a specific syntactic
label as its target. We provide for this by assuming that RCs can
maintain a shadow copy of relevant syntactic information, where
"shadow copy" is intended to allow a variety of implementations. In
particular, platforms may make an actual copy of the information or
may maintain pointers back into the DOM. The construction process
may create multiple RCs for a given node. In that case, one of the
RCs will be marked as the primary RC. It is the one that will be
invoked when the flow of control reaches that (shadow) node.</p>
</div>

<div class="div4">
<h5><a name="d3e619" id="d3e619" />4.5.1.2 Preparation for
Execution</h5>

<p>If the document being initialized is a child of a root document,
then the root document of that child must fully complete its
initialization before the child can be prepared. In other words,
the root document must both process its DOM and prepare for
execution before child initialization proceeds.</p>

<p>Once in the preparation phase, static properties (ie those NOT a
function of ECMA) are available for lookup. Although this isn't an
explicit step, it is mentioned here as this is the first
opportunity for their retrieval. Note that even if
documentmaxage/stale properties were to be specified in the child
document, they would not be available for retrieval when
downloading the root document. Rather these values would be taken
from the system defaults or context. For example, consider the case
of a first call into a system which lands on a child document
called A. The default values for documentmaxage/stale would be used
when fetching both this child A and root document of the child
called A-root. Should A transition to child document B which
references root B-root, the &lt;property&gt; values of
documentmaxage/stale in A would be used to fetch B. However, the
implicit fetch of B-root would use the system defaults for
documentmaxage/stale.</p>

<p>With the ability to read &lt;property&gt; values comes the first
opportunity to act on any prefetching directives supplied by the
application. Prefetching is an optional step, and could be
postponed temporality or indefinitely. The only requirement on a
conformant processor is that prefetching cannot take place before
this step.</p>

<p>Next, document-level variables and scripts are initialized in
document order. Note that conformant processors MUST not locally
handle any semantic errors generated during this step. Such errors
MUST be thrown to the calling document or context (e.g
error.badfetch). The reason being that the present document is not
yet fully initialized and thus cannot reliably handle errors
locally.</p>

<p>The final step in preparation is for the controller to select
the first &lt;form&gt; to execute. If either the local controller
is malformed or the optional URI fragment points to a non-existent
&lt;form&gt;, an error MUST be generated in the calling document or
context (eg error.badfetch). A conformant processor MUST not handle
this locally.</p>
</div>
</div>

<div class="div3">
<h4><a name="d3e632" id="d3e632" />4.5.2 Execution</h4>

<p>After initialization, the semantic control flow does a
&lt;goto&gt; to the initial Resource Controller. Once a RC is
running, it invokes Resources and other RCs by sending them events.
The DOM is not involved in this process. At various points in the
processing, however, an RC may decide to raise an author-visible
event. It does this by creating an event targeted at a specific DOM
node and sending it back to the DOM. When the DOM receives the
event, it performs the standard bubble/capture cycle with the
target specified in the event. In the course of the bubble/capture
cycle, various event handlers may fire. Their execution is a
semantic action and occurs back in the semantic 'side' of the
environment. The DOM sends messages back to the appropriate
semantic objects to cause this to happen. Note that this means that
the DOM must store some sort of link to the appropriate RCs. The
event handlers may update the data model, execute script, or raise
other DOM events. When the handler finishes processing on the
semantic side, it sends a notification back to the DOM so that it
can resume the bubble/capture phase. (N.B. This notification is NOT
a DOM event.) When the DOM finishes the bubble/capture processing
of the event, it sends a notification back to the RC that raised
the event so that it can continue processing.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: Is this
notification a standard semantic event? Note that RC processing
must pause during the bubble/capture phase to avoid concurrency
problems.</td>
</tr>
</table>

<div class="div4">
<h5><a name="d3e640" id="d3e640" />4.5.2.1 Subdialogs</h5>

<p>A subdialog has a completely separate context from the invoking
application. Thus it has a separate DOM and a separate set of RCs.
However it shares the same set of Resources since they are global.
When a subdialog is entered, the Datamodel Resource will have to
create a new scope for the subdialog and hide the calling
document's scopes. When the subdialog is exited, the Datamodel
resource will destroy the subdialog scope(s) and restore the
calling document's scope(s).</p>
</div>

<div class="div4">
<h5><a name="ApplicationRoot" id="ApplicationRoot" />4.5.2.2
Application Root</h5>

<p>To handle event propagation from the leaf application to the
application root document, we create a Document Manager to handle
all communication between the documents. This means that the DOMs
of the two documents remain separate. When an event is not handled
in the leaf document, the Document Manager will propagate it to the
application root, where it will be targeted at the &lt;vxml&gt;
node. Requests to fetch properties or to active grammars will be
handled by the Document Manager in a similar fashion. To handle
platform- and/or language-level defaults, we will create a
"super-root" document above the application root. The Document
Manager will pass it events and requests that are not handled in
the root document. If root and superroot documents do not handle an
event, the Document Manager will ensure that the event is thrown
away.</p>
</div>

<div class="div4">
<h5><a name="d3e650" id="d3e650" />4.5.2.3 Summary of
Syntax/Semantics Interaction</h5>

<p>There seem to be four kinds of interactions between RCs and the
DOM at runtime:</p>

<ol class="enumar">
<li>RCs can inject DOM events into the DOM.</li>

<li>The DOM can invoke the RCs for specific event handlers.</li>

<li>The event handler RCs can signal the DOM when they have
finished processing.</li>

<li>The DOM can signal the emitting RC when it has finished
processing a DOM event.</li>
</ol>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: DOM
Modification. There are two possibilities: 1) we can refuse to
allow the DOM to be modified (or ignore the modifications if it is)
2) we can reconstruct the relevant resource controllers when the
DOM is modified. In the latter case, the straightforward approach
would be: a) find the least node that is an ancestor of all the
changes and that has a constructor b) call its constructor as
during initialization, using the current state of the DOM and RCs
as context.</td>
</tr>
</table>
</div>
</div>

<div class="div3">
<h4><a name="d3e667" id="d3e667" />4.5.3 Transition
Controllers</h4>

<p>Transition controllers provide the basis for managing flow in
VoiceXML applications. Resource controllers for some elements like
&lt;form&gt; have associated transition controllers which influence
how form items get selected and executed. In addition to form,
there is a transition controller for each of the following higher
VoiceXML scopes:</p>

<ul>
<li>A document-level transition controller associated with the
&lt;vxml&gt; element's resource controller that is responsible for
starting document processing and deciding which resource controller
to execute next, i.e., for a &lt;form&gt; or other interaction
element in the document.</li>

<li>An application-level transition controller that is responsible
for starting application processing and deciding which
document-level resource controller to execute next.</li>

<li>A top-level or session transition controller that manages the
flow for a VoiceXML session. This top-level transition controller
is responsible for starting session processing and also holds
session level properties.</li>

<li>The above transition controllers influence the selection of the
first form item resource controller to execute, and subsequent ones
through the session.</li>
</ul>

<p>Whenever a form item or form or document finishes execution, the
relevant transition controller is consulted for selecting the
subsequent one for execution. To find the relevant transition
controller, begin at the current resource controller and navigate
along the associated VoiceXML element's parent axis until you reach
a resource controller with an associated transition controller. For
example, for a form item, the parent form's resource controller has
the relevant transition controller.</p>

<p>When a transition controller runs to completion, control is
returned to the next higher transition controller along with any
results that need to be passed up. For example, when the last form
item in a form is filled, the transition controller associated with
the form returns control to the document level transition
controller along with the results for the filled form. Control may
be returned to the parent transition controller in case of such run
to completion semantics as well as error semantics.</p>
</div>
</div>
</div>

<div class="div1">
<h2><a name="Resources" id="Resources" />5 Resources</h2>

<p>This section describes semantic models for common VoiceXML
resources. Resources have a life cycle of creation and destruction.
Specific resources may specify detailed requirements on these
phases. All resources must be created prior to their use by a
VoiceXML interpreter.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Standard lifecycle events
are expected to be defined in later versions: create event: from
idle to created; destroy event: from created to idle.</td>
</tr>
</table>

<p>Resources are defined in terms of a state model and events which
it processes within defined states. Events may be divided into
those which are defined by the resource itself and events defined
by other conceptual entities which the resource receives or sends
within these states. These conceptual entities include resource
controllers and a 'device' which provides an implementation of the
services defined by the resource.</p>

<p>The semantic model is specified in both UML state chart diagrams
and SCXML representations. In case of ambiguity, the SCXML
representation takes precedence over UML diagrams. Note that SCXML
is used here to define the states and events for resources and this
definitional usage should not be confused with the use of SCXML to
specify application flow (see <a href="#DFP:Flow"><b>3.2
Flow</b></a>). Furthermore, these resource events are conceptual,
not DOM events: they are used to define relationship with other
conceptual entities and are not exposed at the markup level.</p>

<p>The following resources are defined: data model (<a
href="#Resources:Datamodel"><b>5.1 Datamodel Resource</b></a>),
prompt queue (<a href="#Resources:PromptQueue"><b>5.2 Prompt Queue
Resource</b></a>), recognition -- DTMF, ASR, and SIV (<a
href="#Resources:Recognition"><b>5.3 Recognition
Resources</b></a>), connection (<a
href="#Resources:Connection"><b>5.4 Connection Resource</b></a>),
and timer (<a href="#Resources:Timer"><b>5.5 Timer
Resource</b></a>).</p>

<div class="div2">
<h3><a name="Resources:Datamodel" id="Resources:Datamodel" />5.1
Datamodel Resource</h3>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Later versions of this document will clarify that different
datamodels may be instanced, such as ECMAScript, XML, etc.
Conformance requirements will be stated at a later stage.</p>
</td>
</tr>
</table>

<p>The datamodel is a repository for both user- and system-defined
data and properties. To simplify variable lookup,we define the
datamodel with a synchronous function-call API, rather than an
asynchronous one based on events. The data model API does not
assume any particular underlying representation of the data or any
specific access language, thus allowing implementations to plug in
different concrete data model languages.</p>

<p>There is a single global data model that is created when the
system is first initialized. Access to data is controlled by means
of scopes, which are stored in a stack. Data is always accessed
within a particular scope, which may be specified by name but
defaults to being the top scope in the stack. At initialization
time, a single scope named "Global" is created. Thereafter scopes
are explicitly created and destroyed by the data model's
clients.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Resource and Resource
controller description to be updated with API calls rather than
events.</td>
</tr>
</table>

<div class="div3">
<h4><a name="Resources:Datamodel:API"
id="Resources:Datamodel:API" />5.1.1 Data Model Resource API</h4>

<a name="DataModelAPI" id="DataModelAPI" />
<table>
<caption>Table 1: Data Model API</caption>

<thead>
<tr>
<td>Function</td>
<td>Arguments</td>
<td>Return Value</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>CreateScope</td>
<td>name(optional)</td>
<td>Success or Failure</td>
<td>Creates a new scope object and pushes it on top of the scope
stack. If no name is provided the scope is anonymous and may be
accessed only when it on the top of the scope stack. A Failure
status is returned if a scope already exists with the specified
name.</td>
</tr>

<tr>
<td>DeleteScope</td>
<td>name(optional)</td>
<td>Success or Failure</td>
<td>Removes a scope from the scope stack. If no name is provided,
the topmost scope is removed. Otherwise the scope with provided
name is removed. A Failure status is returned if the stack is empty
or no scope with the specified name exists.</td>
</tr>

<tr>
<td>CreateVariable</td>
<td>variableName, value(optional), scopeName(optional)</td>
<td>Success or Error</td>
<td>Creates a variable. If scopeName is not specified, the variable
is created in the top most scope on the scope stack. If no value is
provided, the variable is created with the default value specified
by the underlying datamodel. A Failure status is returned if a
variable of the same name already exists in the specified
scope.</td>
</tr>

<tr>
<td>DeleteVariable</td>
<td>variableName, scopeName(optional)</td>
<td>Success or Failure</td>
<td>Deletes the variable with the specified name from the specified
scope. If no scopeName is provided, the variable is deleted from
the topmost scope on the stack. The status Failure is returned if
no variable with the specified name exists in the scope.</td>
</tr>

<tr>
<td>UpdateVariable</td>
<td>variableName, newValue, scopeName(optional)</td>
<td>Success or Failure</td>
<td>Assigns a new value to the variable specified. If scopeName is
not specified, the variable is accessed in the topmost scope on the
stack. A Failure status is returned if the specified variable or
scope cannot be found.</td>
</tr>

<tr>
<td>ReadVariable</td>
<td>variableName, scopeName(optional)</td>
<td>value</td>
<td>Returns the value of the variable specified. If scopeName is
not specified, the variable is accessed in the topmost scope on the
stack. An error is raised if the specified variable or scope cannot
be found.</td>
</tr>

<tr>
<td>EvaluateExpression</td>
<td>expr, scopeName(optional)</td>
<td>value</td>
<td>Evaluates the specified expression and returns its value. If
scopeName is not specified, the expression is evaluated in the
topmost scope on the stack. An error is raised if the specified
scope cannot be found.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="div2">
<h3><a name="Resources:PromptQueue"
id="Resources:PromptQueue" />5.2 Prompt Queue Resource</h3>

<div class="div3">
<h4><a name="PromptQueue:StateChartRepresentation"
id="PromptQueue:StateChartRepresentation" />5.2.1 State Chart
Representation</h4>

<p>Here is a UML representation of the prompt queue. This state
machine assumes that "queue" and "play" are separate commands and
that a separate "play" will always be issued to trigger the play.
When the "play" is issued, the systems plays any queued prompts, up
to and including the first fetch audio in the queue. Then it halts,
even if there are additional prompts or fetch audio in the queue
and waits for another "play" command.</p>

<p>The prompt structure assumed here is fairly abstract. It
consists of a specification of the audio along with optional
parameters controlling playback (for example, speed or volume.) The
audio may be presented in-line, as SSML or some other markup
language, or as a pointer to a file or streaming audio source.
Logically, URLs are dereferenced at the time the prompt is queued,
but implementations are not required to fetch the actual media
until the prompt in question is sent to the player device. Note
that the player device is assumed to be able to handle both
recorded prompts and TTS, and to be able to interpret SSML.
Platforms are free to optimize their implementations as long as
they conform to the state machine specified here. In particular,
platforms may prefetch audio or begin TTS processing in the
background before the prompt is sent to the player device. For
applications that make use of VCR controls (speed up, skip forward,
etc.), actual performance may depend on whether the platform has
implemented such optimizations. For example, a request to skip
forward on a platform that does not prefetch prompts may result in
a long delay. Such performance issues are outside the scope of this
specification.</p>

<p>This diagram assumes that SSML mark information is delivered in
the Player.Done event, and that the player returns a Player.Done
event when it is sent a 'halt' event (otherwise mark information
would get lost on barge-in and hangup, etc).</p>

<p>Note that the "FetchAudio" state is shown stubbed out for
reasons of space, and is expanded in a separate diagram below the
main one.</p>

<img class="center" src="Images/PromptQueueResource.gif"
alt="Semantic model for prompt queue semantics" />
<p>Figure X: Prompt Queue Model</p>

<img class="center" src="Images/PromptQueueResource-FetchAudio.gif"
alt="Semantic model for fetch audio" />
<p>Figure Y: Fetch audio Model</p>
</div>

<div class="div3">
<h4><a name="PromptQueue:SCXMLRepresentation"
id="PromptQueue:SCXMLRepresentation" />5.2.2 SCXML
Representation</h4>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data name="queue"/&gt;
    &lt;data name="markName"/&gt;
    &lt;data name="markTime"/&gt;
    &lt;data name="bargeInType"/&gt;
  &lt;/datamodel&gt;

   &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;transition event="QueuePrompt"&gt;
     &lt;insert  pos="after" loc = "datamodel/data[@name='queue']/prompt" val="_eventData/prompt"/&gt;
    &lt;/transition&gt;

     &lt;transition event="QueueFetchAudio"&gt;
       &lt;foreach var="node" nodeset="datamodel/data[@name='queue']/prompt"&gt; 
         &lt;if cond="$node[@fetchAudio='true']"&gt;
          &lt;delete loc="$node"/&gt;
         &lt;else&gt;
          &lt;assign loc="$node[@bargeInType]" val="unbargeable"/&gt;
         &lt;/else&gt;
         &lt;/if&gt;
       &lt;/foreach&gt;
    &lt;insert pos="after" name="datamodel/data[@name='queue']/prompt" val="_eventData/audio"/&gt;
    &lt;/transition&gt;

    &lt;transition event="setParameter"&gt;
     &lt;send target="player" event="setParameter" namelist="_eventData.paramName, _eventData.newValue"/&gt;
    &lt;/transition&gt;

    &lt;transition event="Cancel" target="Idle"&gt;
     &lt;send target="player" event="halt"/&gt;
     &lt;send event="PlayDone" namelist="/datamodel/data[@name='markName'].text(), /datamodel/data[@name='markTime'].text()"/&gt;
     &lt;delete loc="datamodel/data[@name='queue']/prompt"/&gt;
    &lt;/transition&gt;

    &lt;transition event="CancelFetchAudio"&gt;
       &lt;foreach var="node" nodeset="datamodel/data[@name='queue']/prompt"&gt; 
         &lt;if cond="$node[@fetchAudio='true']"&gt;
          &lt;delete loc="$node"/&gt;
         &lt;/if&gt;
       &lt;/foreach&gt;
    &lt;/transition&gt;

    &lt;state id="Idle"&gt;
     &lt;onentry&gt;
      &lt;assign loc="/datamodel/data[@name='markName']" val=""/&gt;
      &lt;assign loc="/datamodel/data[@name='markTime']" val="-1"/&gt;
      &lt;assign loc="/datamodel/data[@name='bargeInType']" val=""/&gt;
     &lt;/onentry&gt;

     &lt;transition event="Play" cond="/datamodel/data[@name='queue']/prompt[1][@fetchAudio] eq 'false'" target="PlayingPrompt"/&gt;

     &lt;transition event="Play" cond="/datamodel/data[@name='[queue']/prompt[1][@fetchAudio] eq 'true'" target="FetchAudio"/&gt;
    &lt;/state&gt;

    &lt;state id="PlayingPrompt"&gt;
     &lt;datamodel&gt;
      &lt;data name="currentPrompt"/&gt;
     &lt;/datamodel&gt;
     &lt;onentry&gt;
      &lt;assign loc="/datamodel/data[@name='currentPrompt']/prompt" val="/datamodel/data[@name='queue']/prompt[1])"/&gt;
      &lt;delete loc="/datamodel/data[@name='queue']/prompt[1]"/&gt;
      &lt;if cond="/datamodel/data[@name='currentPrompt']/prompt[@bargeInType] != /datamodel/data[@name='bargeInType']"&gt;
       &lt;send event="BargeInChange" namelist="/datamodel/ data[@name='currentPrompt']/prompt[@bargeInType]"/&gt;
       &lt;assign loc="/datamodel/data[@name='bargeInType']" expr="/ datamodel/data[@name='currentPrompt']/prompt[@bargeInType]"/&gt;
      &lt;/if&gt;
     &lt;/onentry&gt;

     &lt;invoke targettype="player" srcexpr="/datamodel/ data[@name='currentPrompt']/prompt"/&gt;

     &lt;finalize&gt;
       &lt;if cond="_eventData/MarkTime neq '-1'"&gt;
         &lt;assign name="/datamodel/data[@name='markName']/" val="_eventData/markName.text()"/&gt;
         &lt;assign name="/datamodel/data[@name='markTime']/" val="_eventData/markTime.text()"/&gt;
       &lt;/if&gt;
     &lt;/finalize&gt;

     &lt;transition event="player.Done" cond="/datamodel/data[@name='queue']/prompt[last()] le '1'" target="Idle"&gt;
      &lt;send event="PlayDone" namelist="/datamodel/data[@name='markName'].text(), /datamodel/data[@name='markTime'].text()"/&gt;
     &lt;/transition&gt;

     &lt;transition event="player.Done" cond="/datamodel/data[@name='queue'/prompt[1][@fetchAudio] neq 'true'" target="PlayingPrompt"/&gt;

     &lt;transition event="player.Done"
         cond="/datamodel/data[@name='queue']/prompt[1][@fetchAudio] eq 'true'" target="FetchAudio"/&gt;

    &lt;/state&gt; &lt;!-- end PlayingPrompt --&gt;

    &lt;state id="FetchAudio"&gt;
      &lt;initial id="WaitFetchAudio"/&gt;

      &lt;transition event="player.Done" target="FetchAudioFinal"/&gt;

      &lt;state id="WaitFetchAudio"&gt;
        &lt;onentry&gt;
          &lt;send target="self" event="fetchAudioDelay"
          delay="/datamodel/data[@name='queue']/prompts[1][@fetchaudiodelay]"/&gt;
        &lt;/onentry&gt;

       &lt;transition event="fetchAudioDelay" next="StartFetchAudio"/&gt;
       &lt;transition event="cancelFetchAudio" next="FetchAudioFinal"/&gt;
      &lt;/state&gt;

     &lt;state id="StartFetchAudio"&gt;
      &lt;datamodel&gt;
       &lt;data name="fetchAudio"/&gt;
      &lt;/datamodel&gt;
      &lt;onentry&gt;
       &lt;assign loc="/datamodel/data[@name='fetchAudio']" expr="/datamodel/data[@name='queue']/prompts[1]"/&gt;
       &lt;delete loc="/datamodel/data[@name='queue']/prompts[1]"/&gt;
       &lt;send target="self" event="fetchAudioMin" delay="/datamodel/data[@name='fetchAudio'][@fetchaudiominimum]"/&gt;
       &lt;send target="player" event="Play" namelist="/datamodel/data[@name='fetchAudio']"/&gt;
       &lt;if cond="/datamodel/data[@name='bargeInType'].text() ne 'fetchAudio'"&gt;
         &lt;send event="BargeInChange" namelist="fetchAudio"/&gt;
       &lt;/if&gt;
      &lt;/onentry&gt;

      &lt;transition event="CancelFetchAudio" target="WaitFetchMinimum"/&gt;

      &lt;transition event="fetchAudioMin" target="WaitFetchCancel"/&gt;
     &lt;/state&gt;

     &lt;state id="WaitFetchMinimum"&gt;
       &lt;transition event="fetchAudioMin" target="FetchAudioFinal"&gt;
         &lt;send target="player" event="halt"/&gt;
       &lt;/transition&gt;
     &lt;/state&gt;

     &lt;state id="WaitFetchCancel"&gt;
       &lt;transition event="CancelFetchAudio" target="FetchAudioFinal"&gt;
         &lt;send target="player" event="halt"/&gt;
       &lt;/transition&gt;
     &lt;/state&gt;

     &lt;state id="FetchAudioFinal" final="true" /&gt;
     &lt;!-- could put cleanup handling here --&gt;

    &lt;/state&gt; &lt;!-- end FetchAudio --&gt;
   &lt;/state&gt; &lt;!-- end Created --&gt;
&lt;/scxml&gt;


</pre>
</div>
</div>

<div class="div3">
<h4><a name="PromptQueue:DefinedEvents"
id="PromptQueue:DefinedEvents" />5.2.3 Defined Events</h4>

<p>The prompt queue resource can be controlled by means of the
following events:</p>

<a name="promptResource:incoming" id="promptResource:incoming" />
<table>
<caption>Table 2: Events received by prompt queue
resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>queuePrompt</td>
<td>any</td>
<td>prompt (M), properties(O)</td>
<td>adds prompt to queue, but does not cause it to be played</td>
</tr>

<tr>
<td>queueFetchAudio</td>
<td>any</td>
<td>prompt (M)</td>
<td>adds fetch audio to queue, removing any existing fetch audio
from queue. Does not cause it to be played.</td>
</tr>

<tr>
<td>play</td>
<td>any</td>
<td />
<td>Causes any queued prompts or fetch audio to be played</td>
</tr>

<tr>
<td>changeParameter</td>
<td>any</td>
<td>paramName, newValue</td>
<td>Sets the value of paramName to newValue, which may be either an
absolute or relative value. The new setting takes effect
immediately, even if there is already a prompt playing.</td>
</tr>

<tr>
<td>cancelFetchAudio</td>
<td>any</td>
<td />
<td>Deletes any queued fetch audio. Also cancels any fetch audio
that is already playing, unless fetchAudioMin has been specified
and not yet reached.</td>
</tr>

<tr>
<td>cancel</td>
<td>any</td>
<td />
<td>Immediately cancels any prompt or fetch audio that is playing
and clears the queue.</td>
</tr>
</tbody>
</table>

<p>The prompt queue resource returns the following events to its
invoker:</p>

<a name="promptResource:outbound" id="promptResource:outbound" />
<table>
<caption>Table 3: Events sent by prompt queue resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prompt.Done</td>
<td>controller</td>
<td>markName(O), markTime(O)</td>
<td>Indicates prompt queue has played to completion and is now
empty</td>
</tr>

<tr>
<td>bargeintypeChange</td>
<td>controller</td>
<td>one of: unbargeable, hotword, energy, fetchAudio</td>
<td>sent at start of prompt play and whenever a new prompt or fetch
audio is played whose bargeinType differs from the preceding
one.</td>
</tr>
</tbody>
</table>

<div class="issue">
<p class="prefix"><b>Issue ():</b></p>

<p>Do we need 'fetchAudio' as a distinct bargein type?</p>

<p class="prefix"><b>Resolution:</b></p>

<p>None recorded.</p>
</div>
</div>

<div class="div3">
<h4><a name="d3e939" id="d3e939" />5.2.4 Device Events</h4>

<p>The prompt queue receives the following events from the
underlying player:</p>

<a name="recResource:device-incoming:player"
id="recResource:device-incoming:player" />
<table>
<caption>Table 4: Prompt Queue: Events from Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>player.Done</td>
<td />
<td>Sent whenever a single prompt or piece of fetch audio finishes
playing.</td>
</tr>
</tbody>
</table>

<p>and sends the following events to the underlying device:</p>

<a name="promptResource:device-outbound"
id="promptResource:device-outbound" />
<table>
<caption>Table 5: Prompt Queue: Events sent to Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>play</td>
<td>prompt (M)</td>
<td>sent to platform to cause a single prompt to be played.</td>
</tr>

<tr>
<td>setParameter</td>
<td>paramName (M), value(O)</td>
<td>sent to platform to change the value of a playback parameter
such as speed or volume. The new value may be absolute or relative.
The change takes effect immediately.</td>
</tr>
</tbody>
</table>

<p></p>
</div>

<div class="div3">
<h4><a name="d3e990" id="d3e990" />5.2.5 Open Issue</h4>

<div class="issue">
<p class="prefix"><b>Issue ():</b></p>

<p>Differences in PromptQueue Definition: see <a
href="http://www.w3.org/Voice/Group/2005/semmod3/Overview.html#PromptQueueResource">
<cite>Details</cite></a> (members only).</p>

<p class="prefix"><b>Resolution:</b></p>

<p>None recorded.</p>
</div>
</div>
</div>

<div class="div2">
<h3><a name="Resources:Recognition"
id="Resources:Recognition" />5.3 Recognition Resources</h3>

<p>Three types of recognition resources are defined: DTMF
recognition for recognition of DTMF input, ASR recognition for
recognition of speech input, and SIV for speaker identification and
verification. Each recognition resource is associated with a device
which implements their respective recognition services. Each device
represents one or more actual recognizer instances. In case of a
device implemented with multiple recognizers - for example two
different speech recognition engines - it is the responsibility of
the interpreter implementation to ensure that they adhere to the
semantic model defined in this section.</p>

<p>DTMF and ASR recognition resources and SIV resources are
semantically similar. They share the same state and eventing model
as well as recognition processing, timing and result handling.
However, the resources differ in the following respects:</p>

<ul>
<li>Properties: the DTMF resource uses DTMF properties (vxml20,
6.3.3), while the ASR uses speech recognition properties (vxml20,
6.3.2).</li>

<li>Mode: the DTMF resource has the mode value 'dtmf', the ASR
resource has the value 'voice', and the SIV resource has the value
'siv' (vxml20, inputmodes, 6.3.6)</li>

<li>Buffering: only DTMF resource may buffer input when the
resource is not active (e.g. in the FIA transition state, vxml20:
4.1.8).</li>

<li>SIV resources use voice models, not grammars.</li>
</ul>

<p>Otherwise, these resources share the same semantic model.</p>

<p>If a resource controller activates both DTMF and ASR recognition
resources, then that resource controller is responsible for
managing the resources so that only a single recognition result is
produced per recognition cycle. If a resource controller activates
ASR and SIV resources, it may produce multiple results timed to
provide the results within the same cycle or independently.</p>

<div class="div3">
<h4><a name="d3e1018" id="d3e1018" />5.3.1 Definition</h4>

<p>The recognition resource works as follows: in its created state,
grammars (or a voice model) are added to the resource and
subsequently prepared on the device. Recognition with these
grammars (or voice model) can be activated and suspended, and
recognition results are returned.</p>

<p>When the recognition resource is ready to recognize (at least
one active grammar and/or voice model), one or more recognition
cycles may occur in sequence.</p>

<ul>
<li>A recognition cycle is initiated when the resource sends the
device an event instructing it to listen to the input stream.</li>

<li>A recognition cycle is terminated if the device sends the
resource an error event, or the device is instructed to stop
recognition by the resource. When terminated, the device removes
partially or wholly processed input from its buffer, and resource
awaits grammars (and/or voice model) to prepare.</li>

<li>During the recognition cycle, the device may send events to the
resource indicating ongoing recognition status, and recognition
results describing one or more input sequences which match active
grammars (and/or the voice model).</li>

<li>During the recognition cycle, the device may receive
instructions to suspend recognition. When the device is suspended,
input is not buffered and the device must not send any events until
it receives instructions to re-start or terminate recognition.</li>

<li>When the resource receives recognition results from the device
during the recognition cycle, it passes them to its controller. A
recognition cycle is now complete and the resource awaits
instructions either to start another recognition cycle or to
terminate recognition.</li>
</ul>

<p>Thus a recognition resource may enter multiple recognition
cycles (as required for 'hotword' recognition), while requiring
that a device, even if it has multiple instantiations, only
produces one set of recognition results per recognition cycle.</p>

<p>The recognition resource is defined in terms of a data model and
state model.</p>

<p>The data model is composed of the following elements:</p>

<ul>
<li>activeGrammars: an ordered list of grammars with which to
recognize. Each item in the list contains the following
information: 

<ul>
<li>content: a URI or inline content to the grammar itself</li>

<li>properties: grammar-specific properties (vxml20: weight, mode,
type, maxage, maxstale, etc)</li>

<li>listener: a resource controller associated with this
grammar</li>
</ul>
</li>

<li>or activeVoiceModel: a voice model with which to perform
verification or identification. It contains the following
information: 

<ul>
<li>content: a URI to the voice model</li>

<li>properties: model-specific properties</li>

<li>listener: a resource controller associated with this voice
model</li>
</ul>
</li>

<li>properties: properties pertaining to the recognition process.
These properties differ depending on the type of the recognition
resource: for a DTMF recognition resource, the properties include
DTMF properties; for ASR recognition resource, speech recognition
properties; for SIV resource, SIV properties. The properties may
also include platform-specific properties.</li>

<li>controller: the resource controller to which recognition
status, results and error events are sent.</li>

<li>mode: the recognition resource's inputmode: 'voice' for an ASR
recognition resource, 'dtmf' for a DTMF recognition resource, and
'siv' for an SIV resource.</li>
</ul>

<p></p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>List of properties for active grammars needs to be aligned with
the list of items sent in the AddGrammar event.</p>
</td>
</tr>
</table>

<p>The state model is composed of states corresponding to
functional state: <b>idle</b>, <b>preparing grammars / preparing
voice model</b>, <b>ready to recognize</b>, <b>recognizing</b>,
<b>suspended recognition</b> and <b>waiting for results</b>.</p>

<p>In the idle state, the resource awaits events from resource
controllers to activate grammars or a voice model for recognition
on the device. The data model - activeGrammars or activeVoiceModel,
properties, controller and mode - is (re-)initialized upon entry to
this state: activeGrammars and activeVoiceModel are cleared,
properties and controllers are set to null. If the resource
receives an 'addGrammar' event, a new item is added to
activeGrammars using grammar, properties and listener data in the
event payload. If the resource receives a 'prepare' event, it
updates its data model with event data: 'properties' with the
properties event data and 'controller' is updated with the
controller event data. Subsequent event notifications and responses
are sent to the resource controller identified as the 'controller'.
The recognition resource then moves into the <b>preparing
grammars</b> (or <b>preparing voice model</b>) state.</p>

<p>In the <b>preparing grammars</b> state, the resource behavior
depends on whether activeGrammars is empty or not. If
activeGrammars is empty (i.e. no active grammars are defined for
this recognition resource), the resource sends the controller a
'notPrepared' event and returns to the <b>idle</b> state. If
activeGrammar is non-empty, the resource sends a 'prepare' event to
the device. The event payload includes 'grammars' and 'properties'
parameters. The 'grammars' value is an ordered list where each list
item is a grammar's content and its properties extracted from
activeGrammars. The order of grammars in the 'grammars' parameter
must follow the order in the activeGrammar data model. If the
device sends a 'prepared' event, the resource sends a 'prepared'
event to the controller and transitions into the <b>ready to
recognize</b> state.</p>

<p>In the <b>preparing voice models</b> state, the resource
behavior depends on whether activeVoiceModel is empty or not. If
activeVoiceModel is empty (i.e. voice model is not defined for this
resource), the resource sends the controller a 'notPrepared' event
and returns to the <b>idle</b> state. If activeVoiceModel is
non-empty, the resource sends a 'prepare' event to the device. The
event payload includes 'voicemodel' and 'properties' parameters.
The 'voicemodel' value is a URI to the voicemodel, and its
properties are extracted from activeVoiceModel. If the device sends
a 'prepared' event, the resource sends a 'prepared' event to the
controller and transitions into the <b>ready to recognize</b>
state.</p>

<p>When the recognition resource is in a ready to recognize state,
it may receive a 'stop' event. In this case, the resource sends a
'stop' event to the device, and returns to the <b>idle</b> state.
If the resource receives a 'listen' event, it sends a 'listen'
event to the device and moves into the <b>recognizing
state</b>.</p>

<p>When the resource is in a <b>recognizing state</b>, it can
toggle between this state and a <b>suspended recognizing</b> state.
If the resource receives a 'suspend' event, then it moves into the
<b>suspended recognizing</b> state and sends the device a 'suspend'
event which causes the device to suspend recognition and delete any
buffered input. No input is buffered while the device is in a
suspended state. If the resource then receives a 'listen' event, it
moves back into the <b>recognizing state</b>.</p>

<p>When in the <b>recognizing state</b>, the resource may receive
an 'inputStarted' event from the device, indicating that user input
has been detected. The resource then moves into a <b>waiting for
results</b> state. The device may send an 'error' event (for
example, if maximum time has been exceeded) causing it to return to
the <b>idle state</b> and send the controller an 'error' event.
Alternatively, the device may send a 'recoResults' event, which
contains a results parameter, a data structure representing
recognition results. In the case of DTMF or ASR, the results can be
in VoiceXML 2.0 or EMMA format. For SIV, the results must be in
EMMA format. The structure may contain zero or more recognition
results. Each result must specify the grammar (or voicemodel)
associated with the recognition (using the same grammar/voicemodel
name as used in the payload of the 'prepare' event), its
recognition confidence and its input mode. The resource sends its
controller a 'recoResults' event with event data containing the
device's results parameter together with a listener parameter whose
value is the listener associated with the grammar of the first
result with the highest confidence (if there are no results, then
the listener parameter is not defined). The resource then returns
to the ready to <b>recognize state</b>, awaiting either a 'stop'
event to terminate recognition or a 'listen' event to start another
recognition cycle using the same active grammars and recognition
properties.</p>
</div>

<div class="div3">
<h4><a name="d3e1159" id="d3e1159" />5.3.2 Defined Events</h4>

<p>A recognition resource is defined by the events it receives:</p>

<a name="recResource:incoming" id="recResource:incoming" />
<table>
<caption>Table 6: Events received by recognition resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>addGrammar</td>
<td>any</td>
<td>grammar (M), listener (M), properties (O)</td>
<td>creates a grammar item composed of the grammar, listener and
properties, and adds it to the activeGrammars</td>
</tr>

<tr>
<td>addVoiceModel</td>
<td>any</td>
<td>voicemodel (M), listener (M), properties (O)</td>
<td>creates a VoiceModel item composed of the voice model, listener
and properties, and adds it to the activeVoiceModel</td>
</tr>

<tr>
<td>prepare</td>
<td>any</td>
<td>controller (M), properties (M)</td>
<td>prepares the device for recognition using activeGrammars or
activeVoiceModel and properties</td>
</tr>

<tr>
<td>listen</td>
<td>any</td>
<td />
<td>initiates/resumes recognition</td>
</tr>

<tr>
<td>suspend</td>
<td>any</td>
<td />
<td>suspends recognition</td>
</tr>

<tr>
<td>stop</td>
<td>any</td>
<td />
<td>terminates recognition</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Need to add a prepareGrammar event (from the grammar RC).</p>
</td>
</tr>
</table>

<a name="recResource:outbound" id="recResource:outbound" />
<table>
<caption>Table 7: Events sent by recognition resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Sequencing</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prepared</td>
<td>controller</td>
<td />
<td>one-of: prepared, notPrepared</td>
<td>positive response to prepare (activeGrammars or
activeVoiceModel prepared)</td>
</tr>

<tr>
<td>notPrepared</td>
<td>controller</td>
<td />
<td>one-of: prepared, notPrepared</td>
<td>negative response to prepare (no activeGrammars or
activeVoiceModel defined)</td>
</tr>

<tr>
<td>inputStarted</td>
<td>controller</td>
<td />
<td />
<td>notification that onset of input has been detected</td>
</tr>

<tr>
<td>inputFinished</td>
<td>controller</td>
<td />
<td />
<td>notification that the end of input has been detected</td>
</tr>

<tr>
<td>partialResult</td>
<td>controller</td>
<td>results (M), listener (O)</td>
<td />
<td>notification of a partial recognition result</td>
</tr>

<tr>
<td>recoResult</td>
<td>controller</td>
<td>results (M), listener (O)</td>
<td />
<td>notification of complete recognition result, including the
results structure and a listener</td>
</tr>

<tr>
<td>error</td>
<td>controller</td>
<td>error status (M)</td>
<td />
<td>notification that an error has occurred</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="d3e1321" id="d3e1321" />5.3.3 Device Events</h4>

<p>The resource receives from the recognition device the following
events:</p>

<a name="recResource:device-incoming:recognition"
id="recResource:device-incoming:recognition" />
<table>
<caption>Table 8: Recognition: Events from Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prepared</td>
<td />
<td>response to prepare indicating that activeGrammars or
activeVoiceModel have been successfully prepared</td>
</tr>

<tr>
<td>inputStarted</td>
<td />
<td>notification that the onset of input has been detected</td>
</tr>

<tr>
<td>inputFinished</td>
<td />
<td />
<td>notification that the end of input has been detected</td>
</tr>

<tr>
<td>partialResults</td>
<td>results (M)</td>
<td>notification of a partial recognition results</td>
</tr>

<tr>
<td>recoResults</td>
<td>results (M)</td>
<td>notification of final recognition results</td>
</tr>

<tr>
<td>error</td>
<td>error status (M)</td>
<td>an error occurred</td>
</tr>
</tbody>
</table>

<p>and sends to the recognition device the following events:</p>

<a name="recResource:device-outbound"
id="recResource:device-outbound" />
<table>
<caption>Table 9: Recognition: Events sent to Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prepare</td>
<td>grammars (M) or voicemodel (M), properties (M)</td>
<td>the recognition or SIV device is prepared with grammars and
properties</td>
</tr>

<tr>
<td>clear</td>
<td />
<td>all grammars and properties in the recognition device are to be
cleared</td>
</tr>

<tr>
<td>listen</td>
<td />
<td>recognition is to be initiated</td>
</tr>

<tr>
<td>suspend</td>
<td />
<td>recognition is to be suspended</td>
</tr>

<tr>
<td>stop</td>
<td />
<td>recognition is to be stopped</td>
</tr>
</tbody>
</table>

<p></p>
</div>

<div class="div3">
<h4><a name="d3e1423" id="d3e1423" />5.3.4 State Chart
Representation</h4>

<p>The state model for an ASR recognition resource are shown in
Figure 9. The DTMF resource model only differs in that the value
for the mode data is 'dtmf' instead of 'voice'.</p>

<p>[generalize stop event returning resource to idle state ...]</p>

<img class="center" src="Images/recognizer.png"
alt="Recognition Resource States" />
<p class="caption">Figure 9: Recognition Resource States</p>
</div>

<div class="div3">
<h4><a name="d3e1435" id="d3e1435" />5.3.5 SCXML
Representation</h4>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data name="activeGrammars"/&gt;
    &lt;data name="properties"/&gt;
    &lt;data name="controller"/&gt;
    &lt;data name="mode"/&gt;
  &lt;/datamodel&gt;
  &lt;state id="Created"&gt;
    &lt;initial id="idle"/&gt;

    &lt;state id="idle"&gt;
      &lt;onentry&gt;
        &lt;foreach var="node" nodeset="datamodel/data[@name='activeGrammars']"&gt;
          &lt;delete loc="$node"/&gt;
        &lt;/foreach&gt;
        &lt;assign loc="/datamodel/data[@name='properties']" val="null"/&gt;
        &lt;assign loc="/datamodel/data[@name='controller']" val="null"/&gt;
        &lt;assign loc="/datamodel/data[@name='mode']" val="voice"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="AddGrammar"&gt;
        &lt;datamodel&gt;
          &lt;data name = "gram"/&gt;
        &lt;/datamodel&gt;
        &lt;assign name="/datamodel/data/[@name='gram']/grammar" expr="_eventData/grammar" /&gt;
        &lt;assign name="/datamodel/data/[@name='gram']/properties" expr="_eventData/properties" /&gt;
        &lt;assign name="/datamodel/data/[@name='gram']/listener" expr="_eventData/listener" /&gt;
        &lt;insert pos="after" name="datamodel/data[@name='activeGrammars']" val="gram"/&gt;
      &lt;/transition&gt;

      &lt;transition event="prepare" target="preparingGrammars"&gt;
        &lt;assign loc="/datamodel/data[@name='properties']" expr="_eventData/properties"/&gt;
        &lt;assign loc="/datamodel/data[@name='controller']" expr="_eventData/controller"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end idle --&gt;

    &lt;state id="preparingGrammars"&gt;
      &lt;onentry&gt;
        &lt;if cond="isEmpty(/datamodel/data[@name='activeGrammars']) eq 'false'"&gt;
          &lt;send target="device" event="dev:clear"/&gt;
          &lt;send target="device" event="dev:prepare" namelist="/datamodel/data[@name='activeGrammars'], /datamodel/data[@name='properties']"/&gt;
        &lt;/if&gt;
      &lt;/onentry&gt;

      &lt;transition cond="isEmpty(/datamodel/data[@name='activeGrammars']) eq 'true'" target="idle"&gt;
        &lt;send target="controller" event="notPrepared"/&gt;
      &lt;/transition&gt;

      &lt;transition event="stop" target="idle"&gt;
        &lt;send target="device" event="dev:stop"/&gt;
      &lt;/transition&gt;

      &lt;transition event="dev:prepared" target="readyToRecognize"&gt;
        &lt;send target="controller" event="Prepared"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end preparingGrammars --&gt;

    &lt;state id="readyToRecognize"&gt;
      &lt;transition event="listen" target="recognizing" /&gt;

      &lt;transition event="stop" target="idle"&gt;
        &lt;send target="device" event="dev:stop"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end readyToRecognize --&gt;

    &lt;state id="recognizing"&gt;
      &lt;onentry&gt;
        &lt;send target="device" event="dev:listen"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="suspend" target="suspendedRecognizing"/&gt;

      &lt;transition event="dev:inputStarted" target="waitingForResult"/&gt;

      &lt;transition event="stop" target="idle"&gt;
        &lt;send target="device" event="dev:stop"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end recognizing --&gt;

    &lt;state id="suspendedRecognizing"&gt;
      &lt;onentry&gt;
        &lt;send target="device" event="dev:suspend"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="listen" target="recognizing"/&gt;

      &lt;transition event="stop" target="idle"&gt;
        &lt;send target="device" event="dev:stop"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end suspendedRecognizing --&gt;

    &lt;state id="waitingForResult"&gt;
      &lt;onentry&gt;
        &lt;send target="controller" event="inputStarted"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="dev:inputFinished"&gt;
        &lt;send target="controller" event="inputFinished"/&gt;
      &lt;/transition&gt;

      &lt;transition event="dev:partialResult"&gt;
        &lt;send target="controller" event="partialResult" namelist="_eventData/results,_eventData/grammar/listener"/&gt;
      &lt;/transition&gt;

      &lt;transition event="dev:recoResults" target="readyToRecognize"&gt;
        &lt;send target="controller" event="recoResult" namelist="_eventData/results,_eventData/grammar/listener"/&gt;
      &lt;/transition&gt;

      &lt;transition event="dev:error" target="idle"&gt;
        &lt;send target="controller" event="error" namelist="_eventData/error status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="stop" target="idle"&gt;
        &lt;send target="device" event="dev:stop"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end waitForResult --&gt;

  &lt;/state&gt;  &lt;!-- end Created --&gt;

&lt;/scxml&gt;

</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="Resources:Connection" id="Resources:Connection" />5.4
Connection Resource</h3>

<div class="div3">
<h4><a name="ConnectionResource:Definition"
id="ConnectionResource:Definition" />5.4.1 Definition</h4>

<p>A connection resource is an entity that establishes/relinquishes
a connection between the VoiceXML interpreter context and the user.
It can be used by the interpreter context to establish a connection
with the user at the start of the dialog or to disconnect an
existing connection either implicitly (when there are no more
elements to execute in the VoiceXML application) or explicitly
(when the interpreter context encounters a &lt;disconnect&gt;
element or the user chooses to terminate the call).</p>
</div>

<div class="div3">
<h4><a name="ConnectionResource:FinalProcessing"
id="ConnectionResource:FinalProcessing" />5.4.2 Final Processing
State</h4>

<p>Whenever an interpreter context disconnects from the user, the
interpreter context may enter into the final processing state as is
the case while executing a &lt;disconnect&gt; element or when the
user actively disconnects. The purpose of this state is to allow
the VoiceXML application to perform any necessary final cleanup,
such as submitting information to the application server. In this
state, entering into the wait state is not allowed. However, the
application can navigate from one page to another without trying to
interact with the user. Therefore, the application should not enter
&lt;field&gt;, &lt;record&gt; or &lt;transfer&gt; during the final
processing state. The VoiceXML interpreter must exit if the
VoiceXML application attempts to enter the waiting state while in
the final processing state.</p>

<p>Aside from this restriction, execution of the VoiceXML
application continues normally while in the final processing state.
Thus for example the application may transition between documents
while in the final processing state, and the interpreter must exit
if no form item is eligible to be selected.</p>
</div>

<div class="div3">
<h4><a name="d3e1455" id="d3e1455" />5.4.3 Defined Events</h4>

<a name="ConnectionResource:Incoming"
id="ConnectionResource:Incoming" />
<table>
<caption>Table 10: Events Received by Connection Resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prepare</td>
<td />
<td />
<td>Prepare to connect the user with the interpreter context</td>
</tr>

<tr>
<td>connect</td>
<td />
<td />
<td>Connect the user to the interpreter context</td>
</tr>

<tr>
<td>disconnect</td>
<td>any</td>
<td />
<td>Disconnect the user from the interpreter context</td>
</tr>
</tbody>
</table>

<a name="ConnectionResource:outbound"
id="ConnectionResource:outbound" />
<table>
<caption>Table 11: Events Sent by Connection Resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>prepared</td>
<td />
<td />
<td>Connection prepared</td>
</tr>

<tr>
<td>connected</td>
<td />
<td />
<td>Interpreter context connected to the user</td>
</tr>

<tr>
<td>disconnected</td>
<td>Any</td>
<td />
<td>Interpreter context disconnected from the user</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="d3e1530" id="d3e1530" />5.4.4 State Chart
Representation</h4>

<p>[TBD]</p>
</div>

<div class="div3">
<h4><a name="d3e1536" id="d3e1536" />5.4.5 SCXML
Representation</h4>

<p>[TBD]</p>
</div>
</div>

<div class="div2">
<h3><a name="Resources:Timer" id="Resources:Timer" />5.5 Timer
Resource</h3>

<div class="div3">
<h4><a name="d3e1545" id="d3e1545" />5.5.1 Definition</h4>

<p>The timer resource is a resource that tracks timers for various
resource controllers. A timer can be set to send a timeout event at
some future time. Timers which have been set may also be
canceled.</p>
</div>

<div class="div3">
<h4><a name="d3e1550" id="d3e1550" />5.5.2 Defined Events</h4>

<p>A timer resource is defined by the events it receives:</p>

<a name="timerResource:incoming" id="timerResource:incoming" />
<table>
<caption>Table 12: Events received by timer resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>start</td>
<td>any</td>
<td>owner (M), timeout (M), handle (O)</td>
<td>The effect of sending a start event to the timer resource will
have a new timer started that in timeout time will fire a
timerExpired event to the owner of the event. The handle must be
used to correlate timers if the cancel is supported.</td>
</tr>

<tr>
<td>cancel</td>
<td>any</td>
<td>owner (M), handle (O)</td>
<td>The cancel event will cancel any previous timeout that has been
set with the timer resource that match the handle and owner. If
there was no previous event set (or the previous timer has fired)
then cancel still succeeds, as the semantics of cancel are once
cancel has succeed you will not receive a timerExpired event</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<a name="timerResource:outbound" id="timerResource:outbound" />
<table>
<caption>Table 13: Events sent by timer resource</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Sequencing</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>timerExpired</td>
<td>controller</td>
<td>handle (O)</td>
<td>timerExpired must precede any cancelSuccess</td>
<td>This event means the timer has fired. The controller that
receives the event is the owner of the start event. If the handle
was passed in to the start event then it will be passed back when
the timer expires</td>
</tr>

<tr>
<td>cancelSuccess</td>
<td>controller</td>
<td>handle (O)</td>
<td>timerExpired must precede any cancelSuccess</td>
<td>This event means that the timer in question is canceled and no
new timerExpired events may be received</td>
</tr>
</tbody>
</table>

<p>t is possible to receive both a timerExpired event and then a
cancelSuccess event as the events may have crossed paths.</p>
</div>

<div class="div3">
<h4><a name="d3e1629" id="d3e1629" />5.5.3 Device Events</h4>

<p>The resource receives from the timer device the following
events:</p>

<a name="timerResource:device-incoming"
id="timerResource:device-incoming" />
<table>
<caption>Table 14: Timer: Events from Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td /></tr>
</tbody>
</table>

<p>and sends to the timer device the following events:</p>

<a name="timerResource:device-outbound"
id="timerResource:device-outbound" />
<table>
<caption>Table 15: Recognition: Events sent to Device</caption>

<thead>
<tr>
<td>Event</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td /></tr>
</tbody>
</table>

<p></p>
</div>

<div class="div3">
<h4><a name="d3e1668" id="d3e1668" />5.5.4 State Chart
Representation</h4>

<p>TBD</p>
</div>
</div>
</div>

<div class="div1">
<h2><a name="Modules" id="Modules" />6 Modules</h2>

<p>In VoiceXML 3.0, the language is partitioned into independent
modules which can be combined in various ways. In addition to the
modules defined in this section, it is also possible for third
parties to define their own modules (see Section XXX).</p>

<p>Each module is assigned a schema, which defines its syntax, plus
one or more Resource Controllers (RCs), which define its semantics,
plus a "constructor" that knows how to create them from the
syntactic representation at initialization time. Only DOM nodes
that have schemas and constructors (and hence RCs) assigned to them
can be modules in VoiceXML 3.0. However, we may choose to define
constructors and RCs for nodes that are not modules. Nodes that do
not have constructors and RCs ultimately depend on some module for
their interpretation. (Those modules are usually ancestor nodes,
but we do not require this.) There can be multiple modules
associated with the same VoiceXML element. They may set properties
differently, add different child elements, etc. In many cases, some
of the modules will be extensions of the others, but we don't
require this.</p>

<p>Note there is not necessarily a one-to-one relationship between
semantic RCs and syntactic markup elements. It may take several RCs
to implement the functionality of a single markup element.</p>

<div class="div2">
<h3><a name="Grammar:GrammarModule"
id="Grammar:GrammarModule" />6.1 Grammar Module</h3>

<p>This module describes the syntactic and semantic features of a
&lt;grammar&gt; element which defines grammars used in ASR and DTMF
recognition. Grammars defined via this module are used by other
modules.</p>

<p>The attributes and content model of &lt;grammar&gt; are
specified in <a href="#GrammarModule:Syntax"><b>6.1.1
Syntax</b></a>. Its semantics are specified in <a
href="#GrammarModule:Semantics"><b>6.1.2 Semantics</b></a>.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Issue: Grammar processing will need to know the Base URI to
resolve relative references.</p>
</td>
</tr>
</table>

<div class="div3">
<h4><a name="GrammarModule:Syntax"
id="GrammarModule:Syntax" />6.1.1 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e1706" id="d3e1706" />6.1.1.1 Attributes</h5>

<p>The &lt;grammar&gt; element has the attributes specified in
Table 16, in addition to the fetchtimeout, fetchhint, maxage, and
maxstale attributes as specified in <a href="#Fetching"><b>8.1.1
Fetching</b></a>.</p>

<a name="grammar:attributes" id="grammar:attributes" />
<table>
<caption>Table 16: &lt;grammar&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>mode</th>
<td>The only allowed values are "voice" and "dtmf"</td>
<td>Defines the mode of the grammar following the modes of the W3C
Speech Recognition Grammar Specification <a
href="#SRGS">[SRGS]</a>.</td>
<td>No</td>
<td><em>The value of the document property "grammarmode"</em></td>
</tr>

<tr>
<th>weight</th>
<td>Weights are simple positive floating point values without
exponentials. Legal formats are "n", "n.", ".n" and "n.n" where "n"
is a sequence of one or many digits.</td>
<td>Specifies the weight of the grammar. See vxml2: <a
href="http://www.w3.org/TR/2004/REC-voicexml20-20040316/#dml3.1.1.3">
Section 3.1.1.3</a></td>
<td>No</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>The default value of the "grammarmode" document property (see
XXXX) is "voice".</p>
</td>
</tr>
</table>

<h5><a name="d3e1758" id="d3e1758" />6.1.1.2 Content Model</h5>

<p>The content model of &lt;grammar&gt; consists of exactly one
of:</p>

<ul>
<li>the &lt;grammar&gt; element (from the
http://www.w3.org/2001/06/grammar namespace; see <a
href="#Grammar:InlineSRGSGrammarModule"><b>6.2 Inline SRGS Grammar
Module</b></a>), or</li>

<li>the &lt;externalgrammar&gt; element (see <a
href="#Grammar:ExternalGrammarModule"><b>6.3 External Grammar
Module</b></a>)</li>
</ul>
</div>
</div>

<div class="div3">
<h4><a name="GrammarModule:Semantics"
id="GrammarModule:Semantics" />6.1.2 Semantics</h4>

<p>The grammar RC is the primary RC for the &lt;grammar&gt;
element.</p>

<div class="div4">
<h5><a name="d3e1783" id="d3e1783" />6.1.2.1 Definition</h5>

<p>The grammar RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this grammar RC</li>

<li>properties: weight attribute value, fetchtimeout, maxage,
maxstale, charset, encoding, and language</li>

<li>mode: mode</li>

<li>fetchhint: fetchhint</li>
</ul>

<p></p>

<p>The grammar RC's state model consists of the following states:
Idle, Initializing, Ready, and Executing.</p>

<p>While in the Idle state, the RC may receive an 'initialize'
event, whose 'controller' event data is used to update the data
model. The RC then transitions into the Initializing state.</p>

<p>In the Initializing state, the grammar RC first initializes its
child.</p>

<ul>
<li>The values of the fetchtimeout attribute and the
grammarfetchtimeout property (**REF**) are used to determine the
fetchtimeout property value according to section XXXX.</li>

<li>The values of the maxage attribute and the grammarmaxage
property (**REF**) are used to determine the maxage property value
according to section XXXX.</li>

<li>The values of the maxstale attribute and the grammarmaxstale
property (**REF**) are used to determine the maxstale property
value according to section XXXX.</li>

<li>The values of the fetchhint attribute and the grammarfetchhint
property (**REF**) are used to determine the fetchhint parameter
value according to section XXXX.</li>
</ul>

<p>Next, the language, charset, and encoding parameters are set to
the values in effect at this point in the document. If the
fetchhint parameter value is "Prefetch", the RC sends the Prefetch
event to the DTMF or ASR Recognizer resource, as appropriate (see
below), with the following data: the child RC, fetchtimeout,
maxage, maxstale. Finally, the RC sends the controller an
'initialized' event and transitions to the Ready state.</p>

<p>In the Ready state, when the grammar RC receives an 'execute'
event it transitions to the Executing state.</p>

<p>In the Executing state,</p>

<ul>
<li>The values of the fetchtimeout attribute and the
grammarfetchtimeout property (**REF**) are used to determine the
fetchtimeout property value according to section XXXX.</li>

<li>The values of the maxage attribute and the grammarmaxage
property (**REF**) are used to determine the maxage property value
according to section XXXX.</li>

<li>The values of the maxstale attribute and the grammarmaxstale
property (**REF**) are used to determine the maxstale property
value according to section XXXX.</li>
</ul>

<p>If the child RC is an External Grammar, the grammar RC sends an
'execute' event to the child RC and waits for it to complete.</p>

<p>Then, the grammar RC sends an AddGrammar event to the DTMF
Recognizer Resource if mode="dtmf" or to the ASR Recognizer
Resource if mode="voice", with the following as event data: the
child RC, the fetchhint, language, charset, and encoding parameter
values, and the controller RC (e.g., link, field, or form) as the
handler for recognition results.</p>

<p>Finally, the grammar RC sends the controller an executed event
and transitions to the Ready state.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>The currently-active value of fetchhint, fetchtimeout, maxage,
and maxstale properties may be different at execution than at
initialization, so the determination of these values should be done
by the RCs that initialize or execute the grammar RC rather than by
the grammar RC itself. The document text needs to be updated to
reflect this. (From Nov 2009 f2f)</p>

<p>Initializing: Validate that behavior of sending a pointer to the
child RC to the ASR resource. Is this acceptable, or do we need to
extract the grammar data from the child RC and then send that data?
The advantage of sending the RC pointer is that it makes clear what
kind of grammar info it is -- inline SRGS or external
reference.</p>

<p>Execute issues:</p>

<ul>
<li>Note that a mismatch between the "mode" attribute value and any
mode param returned in the media type cannot be detected at this
stage because the document hasn't been fetched yet.</li>

<li>Still need to add a 'cond' capability as we have for
prompts.</li>

<li>Should we allow explicit scope indication a la VoiceXML 2's
"scope" attribute? How do we handle document-scoped grammars
defined syntactically at a lower level? In this case should the
handler be the controller RC or the controller for the document?
Which RC actually executes the grammar RC?</li>

<li>How does 'as if by copy' change this for &lt;link&gt;
grammars?</li>
</ul>

<p />
<p>Editor will write new section 4.5 "Other" and subsections 4.5.1
"property/attribute resolution" and 4.5.2 "language resolution".
Depending on the text, we may need to update the semantics to refer
to section 4.5.2 when describing how xml:lang is used.</p>
</td>
</tr>
</table>
</div>

<div class="div4">
<h5><a name="d3e1861" id="d3e1861" />6.1.2.2 Defined Events</h5>

<p>The Grammar RC is defined to receive the following events:</p>

<table border="1">
<caption>Table 17: Events received by Grammar RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>causes the element and its children to be initialized</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td>Adds the grammar to the appropriate Recognition Resource</td>
<td></td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table border="1">
<caption>Table 18: Events sent by Grammar RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td />
<td>response to initialize event indicating that it has been
successfully initialized</td>
</tr>

<tr>
<td>executed</td>
<td>controller</td>
<td />
<td>response to execute event indicating that it has been
successfully executed</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e1930" id="d3e1930" />6.1.2.3 External Events</h5>

<p>The external events sent and received by the Grammar RC are
those defined in this table:</p>

<a name="grammar:external-events" id="grammar:external-events" />
<table>
<caption>Table 19: Grammar RC External Events</caption>

<tbody>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>

<tr>
<td>addGrammar</td>
<td>GrammarRC</td>
<td>DTMF Recognition Resource or ASR Recognition Resource</td>
<td>Adds grammar to list of currently active grammars</td>
</tr>

<tr>
<td>Prefetch</td>
<td>GrammarRC</td>
<td>DTMF Recognition Resource or ASR Recognition Resource</td>
<td>Requests that the grammar be fetched/compiled in advance, if
possible</td>
</tr>
</tbody>
</table>

<p>&nbsp;</p>
</div>

<div class="div4">
<h5><a name="d3e1968" id="d3e1968" />6.1.2.4 State Chart
Representation</h5>
</div>

<div class="div4">
<h5><a name="d3e1971" id="d3e1971" />6.1.2.5 SCXML
Representation</h5>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="child"/&gt;
    &lt;data id="content"/&gt; &lt;!-- not used --&gt;
    &lt;data id="properties"/&gt;
    &lt;data id="mode"/&gt;
    &lt;data id="fetchhint"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;!-- ISSUE: Is this needed? --&gt;
        &lt;assign location="$controller" expr="null"/&gt;
        &lt;assign location="$child" expr="null"/&gt;
        &lt;assign location="$content" expr="null"/&gt;
        &lt;assign location="$properties/weight" expr="1.0"/&gt;
        &lt;assign location="$properties/fetchtimeout"/&gt;
        &lt;assign location="$properties/maxage"/&gt;
        &lt;assign location="$properties/maxstale"/&gt;
        &lt;assign location="$properties/charset"/&gt;
        &lt;assign location="$properties/encoding"/&gt;
        &lt;assign location="$properties/language"/&gt;
        &lt;assign location="$mode"/&gt;
        &lt;assign location="$fetchhint"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="initialize" target="Initializing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
        &lt;assign name="$child" expr="_eventData/child"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Idle --&gt;

    &lt;state id="Initializing"&gt;

      &lt;onentry&gt;
        &lt;!-- ISSUE: complete the initialization --&gt;
        &lt;assign location="$properties/weight" expr="1.0"/&gt;
        &lt;assign location="$properties/fetchtimeout" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/maxage" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/maxstale" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/charset" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/encoding" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/language" expr="InitDefault();"/&gt;
        &lt;assign location="$mode" expr="InitDefault();"/&gt;
        &lt;assign location="$fetchhint" expr="InitDefault();"/&gt;

        &lt;send target="$child/controller" event="initialize"
          namelist="$child"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="Initializing.error" target="Idle"&gt;
        &lt;send target="controller" event="initialize.error"
           namelist="_eventData/error_status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.done" target="Ready"&gt;
        &lt;if cond="$fetchhint eq 'prefetch'"&gt;
           &lt;if cond="$mode eq 'voice'"&gt;
              &lt;send target="ASRRecognizer" event="Prefetch"
                 namelist="$child $properties/fetchtimeout 
                           $properties/maxage $properties/maxstale"/&gt;
           &lt;else/&gt;
              &lt;send target="DTMFRecognizer" event="Prefetch"
                 namelist="$child $properties/fetchtimeout 
                           $properties/maxage $properties/maxstale"/&gt;
           &lt;/if&gt;
        &lt;/if&gt;
        &lt;send target="controller" event="initialized"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Initializing --&gt;

    &lt;state id="Ready"&gt;

      &lt;transition event="execute" target="Executing"/&gt;

    &lt;/state&gt;    &lt;!-- end Ready --&gt;

    &lt;state id="Executing"&gt;

      &lt;onentry&gt;
        &lt;!-- ISSUE: Initialization function to be completed --&gt;
        &lt;assign location="$properties/fetchtimeout" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/maxage" expr="InitDefault();"/&gt;
        &lt;assign location="$properties/maxstale" expr="InitDefault();"/&gt;

    &lt;!-- ISSUE: Add condition if $child is externalgrammar element --&gt;
        &lt;if cond="???"&gt;
          &lt;send target="$child/controller" event="execute"
             namelist="$child"/&gt;
        &lt;else/&gt;
           &lt;!-- ISSUE: Missing in sendcontroller RC (e.g. link, field, etc) 
                as the handler for recognition results  --&gt;
           &lt;if cond="$mode eq 'voice'"&gt;
              &lt;send target="ASRRecognizer" event="AddGrammar"
                 namelist="$child $fetchhint $properties/language
                           $properties/charset $properties/encoding"/&gt;
           &lt;else/&gt;
              &lt;send target="DTMFRecognizer" event="AddGrammar"
                 namelist="$child $fetchhint $properties/language
                           $properties/charset $properties/encoding"/&gt;
           &lt;/if&gt;
           &lt;send target="controller" event="executed"/&gt;
        &lt;/if&gt;
      &lt;/onentry&gt;

      &lt;transition event="Executing.done"&gt;
         &lt;!-- ISSUE: Missing in send controller RC (e.g. link, field, etc) 
              as the handler for recognition results  --&gt;
         &lt;if cond="$mode eq 'voice'"&gt;
            &lt;send target="ASRRecognizer" event="AddGrammar"
               namelist="$child $fetchhint $properties/language
                         $properties/charset $properties/encoding"/&gt;
         &lt;else/&gt;
            &lt;send target="DTMFRecognizer" event="AddGrammar"
               namelist="$child $fetchhint $properties/language
                         $properties/charset $properties/encoding"/&gt;
         &lt;/if&gt;
         &lt;send target="controller" event="executed"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Executing --&gt;

  &lt;/state&gt;
  &lt;!-- end Created --&gt;

&lt;/scxml&gt;

</pre>
</div>
</div>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<ul>
<li>Is double initialization in Idle and again in Initializing
necessary?</li>

<li>Initialization function should be expanded and specialized for
different parameters</li>

<li>How to get charset, encoding and language?</li>

<li>xml:lang might become present in many elements including
grammar</li>

<li>Base URI might be known at the point of grammar processing</li>

<li>consistent syntax to refer to $child</li>

<li>How to test if $child is 'externalgrammar' element? How to
access DOM? How to access controllers for recognition results (i.e.
link, field, etc)?</li>

<li>possible optimization to avoid duplicated &lt;if&gt; code in
Executing</li>
</ul>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="d3e1997" id="d3e1997" />6.1.3 Events</h4>

<p>The events in this table may be raised during initialization and
execution of the &lt;grammar&gt; element.</p>

<a name="grammar:events" id="grammar:events" />
<table>
<caption>Table 20: &lt;grammar&gt; Events</caption>

<tbody>
<tr>
<td>Event</td>
<td>Description</td>
<td>State</td>
</tr>

<tr>
<th>error.semantic</th>
<td>indicates an error with data model expressions: undefined
reference, invalid expression resolution, etc.</td>
<td>execution</td>
</tr>
</tbody>
</table>

<p>Note that additional errors may occur when the grammar is
fetched or added by the ASR or DTMF resource. Please check there
for details.</p>
</div>

<div class="div3">
<h4><a name="grammar:examples" id="grammar:examples" />6.1.4
Examples</h4>

<p>[TBD: put all examples here.]</p>
</div>
</div>

<div class="div2">
<h3><a name="Grammar:InlineSRGSGrammarModule"
id="Grammar:InlineSRGSGrammarModule" />6.2 Inline SRGS Grammar
Module</h3>

<p>This module describes the syntactic and semantic features of
inline SRGS grammars used in ASR and DTMF recognition.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Issue: Do we need to support inline ABNF SRGS?:</p>
</td>
</tr>
</table>

<p>The attributes and content model of Inline SRGS grammars are
specified in <a href="#InlineSRGSGrammarModule:Syntax"><b>6.2.1
Syntax</b></a>. Its semantics are specified in <a
href="#InlineSRGSGrammarModule:Semantics"><b>6.2.2
Semantics</b></a>.</p>

<div class="div3">
<h4><a name="InlineSRGSGrammarModule:Syntax"
id="InlineSRGSGrammarModule:Syntax" />6.2.1 Syntax</h4>

<p>[See XXX for schema definitions].</p>

<p>The syntax of the Inline SRGS Grammar Module is precisely all of
the XML markup for a legal stand-alone XML form grammar as
described in SRGS (<a href="#SRGS">[SRGS]</a>), minus the XML
Prolog. Note that both elements and attributes must be in the SRGS
namespace (http://www.w3.org/2001/06/grammar).</p>
</div>

<div class="div3">
<h4><a name="InlineSRGSGrammarModule:Semantics"
id="InlineSRGSGrammarModule:Semantics" />6.2.2 Semantics</h4>

<div class="div4">
<h5><a name="d3e2057" id="d3e2057" />6.2.2.1 Definition</h5>

<p>The Inline SRGS grammar RC is defined in terms of a data model
and state model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the grammar RC controlling this inline grammar
RC</li>

<li>grammar: the text of the entire grammar</li>
</ul>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Should the contents of the grammar parameter be parsed rather
than the raw document text? For example, should it be the DOM
representation of the grammar, or just the XML Info set, or
what?</p>
</td>
</tr>
</table>

<p>The grammar RC's state model consists of the following states:
Idle, Initializing, and Ready. Unlike most of the other modules,
this module is primarily a data model for storing a grammar. The
module itself has no execution semantics.</p>

<p>While in the Idle state, the RC may receive an 'initialize'
event, whose 'controller' event data is used to update the data
model. The RC then transitions into the Initializing state.</p>

<p>In the Initializing state, the syntactic contents of the grammar
are saved into the grammar parameter. The RC sends the controller
an 'initialized' event and transitions to the Ready state.</p>

<p>&nbsp;</p>
</div>

<div class="div4">
<h5><a name="d3e2083" id="d3e2083" />6.2.2.2 Defined Events</h5>

<p>The Inline SRGS Grammar RC is defined to receive the following
events:</p>

<table border="1">
<caption>Table 21: Events received by Inline SRGS Grammar
RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>causes the element and its children to be initialized</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table border="1">
<caption>Table 22: Events sent by Inline SRGS Grammar RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td />
<td>response to initialize event indicating that it has been
successfully initialized</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e2135" id="d3e2135" />6.2.2.3 External Events</h5>

<p>The Inline SRGS Grammar Module does not send or receive any
external events.</p>
</div>

<div class="div4">
<h5><a name="d3e2140" id="d3e2140" />6.2.2.4 State Chart
Representation</h5>

<p /></div>

<div class="div4">
<h5><a name="d3e2144" id="d3e2144" />6.2.2.5 SCXML
Representation</h5>
</div>
</div>

<div class="div3">
<h4><a name="InlineSRGSGrammarModule:Events"
id="InlineSRGSGrammarModule:Events" />6.2.3 Events</h4>

<p>No module-specific events are raised during initialization of an
Inline SRGS Grammar. Note that validity failure of the inline SRGS
content would be detected at document parse time.</p>

<p>&nbsp;</p>
</div>

<div class="div3">
<h4><a name="InlineSRGSGrammarModule:examples"
id="InlineSRGSGrammarModule:examples" />6.2.4 Examples</h4>

<p>[TBD: put all examples here.]</p>
</div>
</div>

<div class="div2">
<h3><a name="Grammar:ExternalGrammarModule"
id="Grammar:ExternalGrammarModule" />6.3 External Grammar
Module</h3>

<p>This module describes the syntactic and semantic features of an
&lt;externalgrammar&gt; element which defines external grammars
used in ASR and DTMF recognition.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>The name of this element is still under discussion.</p>
</td>
</tr>
</table>

<p>The attributes and content model of &lt;externalgrammar&gt; are
specified in <a
href="#Grammar:ExternalGrammarModule:Syntax"><b>6.3.1
Syntax</b></a>. Its semantics are specified in <a
href="#Grammar:ExternalGrammarModule:Semantics"><b>6.3.2
Semantics</b></a>.</p>

<div class="div3">
<h4><a name="Grammar:ExternalGrammarModule:Syntax"
id="Grammar:ExternalGrammarModule:Syntax" />6.3.1 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e2188" id="d3e2188" />6.3.1.1 Attributes</h5>

<p>The &lt;externalgrammar&gt; element has the attributes specified
in Table 23.</p>

<a name="ExternalGrammarModule:attributes:external"
id="ExternalGrammarModule:attributes:external" />
<table>
<caption>Table 23: &lt;externalgrammar&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>src</th>
<td><a
href="http://www.w3.org/TR/xmlschema-2/#anyURI">anyURI</a></td>
<td>The URI specifying the location of the grammar and optionally a
rulename within that grammar, if it is external. The URI is
interpreted as a rule reference as defined in Section 2.2 of the
Speech Recognition Grammar Specification <a href="#SRGS">[SRGS]</a>
but not all forms of rule reference are permitted from within
VoiceXML. The rule reference capabilities are described in detail
below this table.</td>
<td>No</td>
<td /></tr>

<tr>
<th>srcexpr</th>
<td>A data model expression</td>
<td>Equivalent to src, except that the URI is dynamically
determined by evaluating the content as a data model
expression.</td>
<td>No</td>
<td /></tr>

<tr>
<th>type</th>
<td>A data model expression</td>
<td>
<p>The preferred media type of the grammar. A resource indicated by
the URI reference in the src attribute may be available in one or
more media types. The author may specify the preferred media-type
via the type attribute. When the content represented by a URI is
available in many data formats, a VoiceXML platform may use the
preferred media-type to influence which of the multiple formats is
used. For instance, on a server implementing HTTP content
negotiation, the processor may use the preferred media-type to
order the preferences in the negotiation.</p>

<p>The resource representation delivered by dereferencing the URI
reference may be considered in terms of two types. The declared
media-type is the asserted value for the resource and the actual
media-type is the true format of its content. The actual media-type
should be the same as the declared media-type, but this is not
always the case (e.g. a misconfigured HTTP server might return
'text/plain for an 'application/srgs+xml' document). A specific URI
scheme may require that the resource owner always, sometimes, or
never return a media-type. The declared media-type is the value
returned by the resource owner or, if none is returned, the
preferred media type. There may be no declared media-type if the
resource owner does not return a value and no preferred type is
specified. Whenever specified, the declared media-type is
authoritative.</p>

<p>Three special cases may arise. The declared media-type may not
be supported by the processor; in this case, an
error.unsupported.format is thrown by the platform. The declared
media-type may be supported but the actual media-type may not
match; an error.badfetch is thrown by the platform. Finally, there
may be no declared media-type; the behavior depends on the specific
URI scheme and the capabilities of the grammar processor. For
instance, HTTP 1.1 allows document introspection (see <a
href="#RFC2616">[RFC2616]</a>, section 7.2.1), the data scheme
falls back to a default media type, and local file access defines
no guidelines. The following table provides some informative
examples:</p>

<table border="1">
<tbody>
<tr>
<td />
<td>HTTP 1.1 request</td>
<td>Local file access</td>
</tr>

<tr>
<td>Media-type returned by the resource owner</td>
<td>text/plain</td>
<td>application/srgs+xml</td>
<td>&lt;none&gt;</td>
<td>&lt;none&gt;</td>
</tr>

<tr>
<td>Preferred media-type appearing in the grammar</td>
<td>Not applicable; the returned type takes precedence</td>
<td>application/srgs+xml</td>
<td>&lt;none&gt;</td>
</tr>

<tr>
<td>Declared media-type</td>
<td>text/plain</td>
<td>application/srgs+xml</td>
<td>application/srgs+xml</td>
<td>&lt;none&gt;</td>
</tr>

<tr>
<td>Behavior if the actual media-type is application/srgs+xml</td>
<td>error.badfetch thrown; the declared and actual types do not
match</td>
<td>The declared and actual types match; success if
application/srgs+xml is supported by the processor; otherwise an
error.unsupported.format is thrown</td>
<td>Scheme specific; the processor might introspect the document to
determine the type.</td>
</tr>
</tbody>
</table>
</td>
<td>No</td>
<td><em>None</em></td>
</tr>
</tbody>
</table>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Error messages for "type" attribute need to be updated.</p>
</td>
</tr>
</table>

<p>See <a href="#ExternalSRGSGrammar:occurrence"><b>6.3.1.2 Content
Model</b></a> for restrictions on occurrence of src and srcexpr
attributes.</p>

<p>The value of the src attribute is a URI specifying the location
of the grammar with an optional fragment for the rulename. Section
2.2 of the Speech Recognition Grammar Specification <a
href="#SRGS">[SRGS]</a> defines several forms of rule reference.
The following are the forms that are permitted on a grammar element
in VoiceXML:</p>

<ul>
<li>Reference to a named rule in an external grammar: src attribute
is an absolute or relative URI reference to a grammar which
includes a fragment with a rulename. This form of rule reference to
an external grammar follows the behavior defined in Section 2.2.2
of <a href="#SRGS">[SRGS]</a>. If the URI cannot be fetched or if
the rulename is not defined in the grammar or is not a public
(activatable) rule of that grammar then an error.badfetch is
thrown.</li>

<li>Reference to the root rule of an external grammar: src
attribute is an absolute or relative URI reference to a grammar but
does not include a fragment identifying a rulename. This form
implicitly references the root rule of the grammar as defined in
Section 2.2.2 of <a href="#SRGS">[SRGS]</a>. If the URI cannot be
fetched or if the grammar cannot be referenced by its root (see
Section 4.7 of <a href="#SRGS">[SRGS]</a>) then an error.badfetch
is thrown.</li>
</ul>

<p>The following are the forms of rule reference defined by <a
href="#SRGS">[SRGS]</a> that are not supported in VoiceXML 3.</p>

<ul>
<li>Local rule reference: a fragment-only URI is not permitted.
(See definition in Section 2.2.1 of <a href="#SRGS">[SRGS]</a>). A
fragment-only URI value for the src attribute causes an
error.semantic event.</li>

<li>Reference to special rules: there is no support for special
rule references (NULL, VOID, GARBAGE) on the &lt;grammar&gt;
element itself. In the XML form of the SRGS specification, the only
way to include NULL, VOID, and GARBAGE is via the use of the
"special" attribute on the &lt;ruleref&gt; element. Thus, it is not
possible to reference individual uses of NULL, VOID, and GARBAGE
rules in a separate SRGS document, since that would require a
fragment identifier to place on the end of the URI referencing the
document, which in turn would require an id within that document
for the given use of NULL, VOID, or GARBAGE. Note that the external
grammar referenced from the &lt;grammar&gt; element may itself be
an SRGS grammar that contains a &lt;ruleref&gt; element with a
special attribute to reference NULL, VOID, or GARBAGE.</li>
</ul>
</div>

<div class="div4">
<h5><a name="ExternalSRGSGrammar:occurrence"
id="ExternalSRGSGrammar:occurrence" />6.3.1.2 Content Model</h5>

<p>The &lt;externalgrammar&gt; element is empty.</p>
</div>

<p>The &lt;externalgrammar&gt; element has the following
co-occurrence constraints:</p>

<ul>
<li>Exactly one of the "src" or "srcexpr" attributes must be
specified; otherwise, an error.badfetch event is thrown.</li>
</ul>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Editor: please remove the "otherwise, an error.badfetch ..."
from the above and all other co-occurrence text and write general
text somewhere describing what happens when a co-occurrence
constraint is violated.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="Grammar:ExternalGrammarModule:Semantics"
id="Grammar:ExternalGrammarModule:Semantics" />6.3.2 Semantics</h4>

<div class="div4">
<h5><a name="d3e2368" id="d3e2368" />6.3.2.1 Definition</h5>

<p>The External Grammar RC is defined in terms of a data model and
state model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>properties: src, type attribute values</li>

<li>controller: the controller RC of this
&lt;externalgrammar&gt;</li>

<li>srcexpr: srcexpr attribute value</li>
</ul>

<p>The External Grammar RC's state model consists of the following
states: Idle, Initializing, Ready, and Executing.</p>

<p>While in the Idle state, the RC may receive an 'initialize'
event, whose 'controller' event data is used to update the data
model. The RC then transitions into the Initializing state.</p>

<p>In the Initializing state, the RC sends the controller an
'initialized' event and transitions to the Ready state.</p>

<p>In the Ready state, when the External Grammar RC receives an
'execute' event it transitions to the Executing state.</p>

<p>In the Executing state, if the srcexpr variable is set it is
evaluated against the data model as a data model expression, and
the value is placed into the src variable; if srcexpr cannot be
evaluated, an error.semantic event is thrown. Otherwise, the RC
sends an 'executed' event to the controller RC and transitions into
the Ready state.</p>

<p>&nbsp;</p>
</div>

<div class="div4">
<h5><a name="d3e2394" id="d3e2394" />6.3.2.2 Defined Events</h5>

<p>The External Grammar RC is defined to receive the following
events:</p>

<table border="1">
<caption>Table 25: Events received by External Grammar RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>causes the element and its children to be initialized</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td></td>
<td>Evaluates srcexpr and populates src variable</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table border="1">
<caption>Table 26: Events sent by External Grammar RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td />
<td>response to initialize event indicating that it has been
successfully initialized</td>
</tr>

<tr>
<td>executed</td>
<td>controller</td>
<td />
<td>response to execute event indicating that it has been
successfully executed</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e2463" id="d3e2463" />6.3.2.3 External Events</h5>

<p>The External Grammar Module does not send or receive any
external events.</p>
</div>

<div class="div4">
<h5><a name="d3e2468" id="d3e2468" />6.3.2.4 State Chart
Representation</h5>

<p /></div>

<div class="div4">
<h5><a name="d3e2472" id="d3e2472" />6.3.2.5 SCXML
Representation</h5>
</div>
</div>

<div class="div3">
<h4><a name="Grammar:ExternalGrammarModule:Events"
id="Grammar:ExternalGrammarModule:Events" />6.3.3 Events</h4>

<p>The events that may be raised during initialization and
execution of the &lt;externalgrammar&gt; element are those defined
in Table 27 below.</p>

<a name="ExternalGrammarModule:events"
id="ExternalGrammarModule:events" />
<table>
<caption>Table 27: &lt;externalgrammar&gt; Events</caption>

<tbody>
<tr>
<td>Event</td>
<td>Description</td>
<td>State</td>
</tr>

<tr>
<th>error.semantic</th>
<td>indicates that there was an error in the evaluation of the
srcexpr attribute.</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="external_grammar:examples"
id="external_grammar:examples" />6.3.4 Examples</h4>

<p>[TBD: put all examples here.]</p>
</div>
</div>

<div class="div2">
<h3><a name="PromptModule" id="PromptModule" />6.4 Prompt
Module</h3>

<p>This module defines the syntactic and semantic features of a
&lt;prompt&gt; element which controls media output. The content
model of this element is empty: content is defined in other modules
which extend this element's content model (for example <a
href="#BuiltinSSMLModule"><b>6.5 Builtin SSML Module</b></a>, <a
href="#MediaModule"><b>6.6 Media Module</b></a> and <a
href="#ParseqModule"><b>6.7 Parseq Module</b></a>).</p>

<p>The attributes and content model of &lt;prompt&gt; are specified
in <a href="#PromptModule:Syntax"><b>6.4.1 Syntax</b></a>. Its
semantics are specified in <a
href="#PromptModule:Semantics"><b>6.4.2 Semantics</b></a>,
including how the final prompt content is determined and how the
prompt is queued for playback using the PromptQueue Resource (<a
href="#Resources:PromptQueue"><b>5.2 Prompt Queue
Resource</b></a>).</p>

<div class="div3">
<h4><a name="PromptModule:Syntax" id="PromptModule:Syntax" />6.4.1
Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e2534" id="d3e2534" />6.4.1.1 Attributes</h5>

<p>The &lt;prompt&gt; element has the attributes specified in Table
28.</p>

<a name="prompt:attributes" id="prompt:attributes" />
<table>
<caption>Table 28: &lt;prompt&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>bargein</th>
<td>boolean</td>
<td>Controls whether the prompt can be interrupted.</td>
<td>No</td>
<td><a title="" href="#Property:bargein">bargein</a> property</td>
</tr>

<tr>
<th>bargeintype</th>
<td>string</td>
<td>On prompts that can be interrupted, determines the type of
bargein, either 'speech', or 'hotword'.</td>
<td>No</td>
<td><a title="" href="#Property:bargeintype">bargeintype</a>
property</td>
</tr>

<tr>
<th>cond</th>
<td>data model expression</td>
<td>A data model expression that must evaluate to true after
conversion to boolean in order for the prompt to be played.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>count</th>
<td>positive integer</td>
<td>A number indicating the repetition count, allowing a prompt to
be activated or not depending on the current repetition count.</td>
<td>No</td>
<td>1</td>
</tr>

<tr>
<th>timeout</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>The time to wait for user input.</td>
<td>No</td>
<td><a title="" href="#Property:timeout">timeout</a> property</td>
</tr>

<tr>
<th>xml:lang</th>
<td>string</td>
<td>The <a href="#term-language">language identifier</a> for the
prompt.</td>
<td>No</td>
<td>document's "xml:lang" attribute</td>
</tr>

<tr>
<th>xml:base</th>
<td>string</td>
<td>Declares the base URI from which relative URIs in the prompt
are resolved.</td>
<td>No</td>
<td>document's "xml:base" attribute</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e2643" id="d3e2643" />6.4.1.2 Content Model</h5>

<p>The content model of the &lt;prompt&gt; element is empty.</p>

<p>Other modules can extend the content model. These modules must
define how the content is evaluated and processed before being
added to the prompt queue.</p>
</div>
</div>

<div class="div3">
<h4><a name="PromptModule:Semantics"
id="PromptModule:Semantics" />6.4.2 Semantics</h4>

<p>The prompt RC is the primary RC for the &lt;prompt&gt;
element.</p>

<div class="div4">
<h5><a name="d3e2655" id="d3e2655" />6.4.2.1 Definition</h5>

<p>The prompt RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this prompt RC</li>

<li>children: array of children's (primary) RC</li>

<li>count: count attribute value</li>

<li>cond: cond attribute expression</li>

<li>properties: bargein, bargeintype and timeout attribute
values</li>

<li>xml:lang: xml:lang attribute value</li>

<li>xml:base: xml:base attribute value</li>
</ul>

<p>The prompt RC's state model consists of the following states:
Idle, Initializing, Ready, FormReady, and Executing. The initial
state is the Idle state.</p>

<p>While in the Idle state, the prompt RC may receive an
'initialize' event, whose controller event data is used to update
the data model. The prompt RC then transitions into Initializing
state.</p>

<p>In the Initializing state, the prompt RC initializes its
children: this is modeled as a separate RC (see XXX). The children
may return an error for initialization. If a child sends an error,
then the prompt RC returns an error. When all children are
initialized, the prompt RC sends the controller an 'initialized'
event and transitions to the Ready state.</p>

<p>In the Ready state, the prompt RC can receive a 'checkStatus'
event to check whether this prompt is eligible for execution or
not. The value of the cond parameter in its data model is checked
against the data model resource: the status is true if the value of
the cond parameter evaluates to true. The status, together with its
count data, is sent in a 'checkedStatus' event to the controller
RC. The controller RC then determines if the prompt is selected for
execution ([vxml20: 4.1.6], see PromptSelectionRC, Section XXX).
The prompt RC will then transition to the FormReady state. If the
prompt RC receives an 'execute' event and the cond parameter
evaluates to true, it transitions to the Executing state; if the
cond parameter evaluates to false, it will send the controller the
executed event and stay in the Ready state.</p>

<p>In the FormReady State, if the prompt RC receives a
'checkStatus' event, it will again check the cond parameter and
send the 'checkedStatus' event to the controller RC as in the Ready
State. In this state, if the RC receives an 'execute' event it
transitions to the Executing state.</p>

<p>In the Executing state, the prompt RC sends an evaluate event to
its children. Each child returns either an error, or content (which
may include parameters) for playback. If a child sends an error,
then the prompt RC returns an error. Once evaluation is complete,
the RC sends a queuePrompt event to the Prompt Queue Resource with
the &lt;prompt&gt; parameters (bargein, bargeintype, timeout) with
event data consisting of the list of content returned by its
children. The prompt RC then sends the controller an executed event
and transitions to the Ready state.</p>
</div>

<div class="div4">
<h5><a name="d3e2690" id="d3e2690" />6.4.2.2 Defined Events</h5>

<p>The Prompt RC is defined to receive the following events:</p>

<table>
<caption>Table 29: Events received by Prompt RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Source</th>
<th>Payload</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>causes the element and its children to be initialized</td>
</tr>

<tr>
<td>checkStatus</td>
<td>controller</td>
<td />
<td>causes evaluation of the cond parameter against the data
model</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td />
<td>causes the evaluation of its content and conversion to a format
suitable for queueing on the PromptQueue Resource</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table>
<caption>Table 30: Events sent by Prompt RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Target</th>
<th>Payload</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td>response to initialize event indicating that it has been
successfully initialized</td>
<td /></tr>

<tr>
<td>checkedStatus</td>
<td>controller</td>
<td>status (M), count (M)</td>
<td>response to checkStatus event with count parameter and status
indicating evaluation of cond parameter</td>
</tr>

<tr>
<td>executed</td>
<td>controller</td>
<td />
<td>response to execute event indicating that it has been
successfully executed</td>
</tr>
</tbody>
</table>

<p></p>
</div>

<div class="div4">
<h5><a name="d3e2775" id="d3e2775" />6.4.2.3 External Events</h5>

<p>Table 31 shows the events sent and received by the prompts RC to
resources and other RCs which define the events.</p>

<a name="prompt:external-events" id="prompt:external-events" />
<table>
<caption>Table 31: Prompt RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>evaluate</td>
<td>PromptRC</td>
<td>DataModel</td>
<td>used to evaluate the cond parameter (see Table 28)</td>
</tr>

<tr>
<td>queuePrompt</td>
<td>PromptRC</td>
<td>PromptQueue</td>
<td>adds prompt content and properties to the Prompt Queue (see <a
href="#Resources:PromptQueue"><b>5.2 Prompt Queue
Resource</b></a>)</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e2817" id="d3e2817" />6.4.2.4 State Chart
Representation</h5>

<img class="center" src="Images/PromptRC.png"
alt="Prompt RC in UML State Chart" />
<p class="caption">Figure 10: Prompt RC States</p>
</div>

<div class="div4">
<h5><a name="d3e2823" id="d3e2823" />6.4.2.5 SCXML
Representation</h5>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="properties"/&gt;
    &lt;data id="children"/&gt;
    &lt;data id="content"/&gt;
    &lt;data id="properties"/&gt;
    &lt;data id="count"/&gt;
    &lt;data id="cond"/&gt;
    &lt;data id="xml:lang"/&gt;
    &lt;data id="xml:base"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign location="$controller" expr="null"/&gt;
        &lt;assign location="$children" expr="null"/&gt;
        &lt;assign location="$content" expr="null"/&gt;
        &lt;assign location="$properties/bargein" expr="true"/&gt;
        &lt;assign location="$properties/bargeintype" expr="speech"/&gt;
        &lt;assign location="$properties/timeout" expr="5s"/&gt;
        &lt;assign location="$count" expr="1"/&gt;
        &lt;assign location="$cond" expr="true"/&gt;
        &lt;assign location="$xml:lang" expr=""/&gt;
        &lt;assign location="$xml:base" expr=""/&gt;
      &lt;/onentry&gt;

      &lt;transition event="initialize" target="Initializing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
        &lt;assign name="$children" expr="_eventData/children"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Idle --&gt;

    &lt;state id="Initializing"&gt;

      &lt;datamodel&gt;
        &lt;data id="childcounter"/&gt;
      &lt;/datamodel&gt;

      &lt;onentry&gt;
        &lt;assign location="$childcounter" expr="0"/&gt;
        &lt;foreach var="child" array="$children"&gt;
          &lt;send target="$child/controller" event="initialize"
          namelist="$child/child"/&gt;
        &lt;/foreach&gt;
      &lt;/onentry&gt;

      &lt;transition event="Initializing.done"&gt;
        &lt;assign location="$childcounter" expr="$childcounter + 1"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.error" target="Idle"&gt;
        &lt;assign location="$childcounter" expr="$childcounter + 1"/&gt;
        &lt;send target="controller" event="initialize.error"
        namelist="_eventData/error_status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.done" cond="$childcounter eq
      $children.size()-1" target="Ready"&gt;
        &lt;send target="controller" event="initialized"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Initializing --&gt;

    &lt;state id="Ready"&gt;
      &lt;datamodel&gt;
        &lt;data id="status"/&gt;
      &lt;/datamodel&gt;

      &lt;transition event="checkStatus" target="FormReady"&gt;
        &lt;assign location="$status" expr="checkStatus()"/&gt;
        &lt;send target="controller" event="checkStatus"
        namelist="$status, $count"/&gt;
      &lt;/transition&gt;

      &lt;transition event="execute" cond="checkStatus() eq 'true'"
      target="Executing"/&gt;

      &lt;transition event="execute" cond="checkStatus() eq 'false'"&gt;
        &lt;send target="controller" event="executed"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end Ready --&gt;

    &lt;state id="FormReady"&gt;
      &lt;datamodel&gt;
        &lt;data id="status"/&gt;
      &lt;/datamodel&gt;

      &lt;transition event="checkStatus"&gt;
        &lt;assign location="$status" expr="checkStatus()"/&gt;
        &lt;send target="controller" event="checkStatus"
        namelist="$status, $count"/&gt;
      &lt;/transition&gt;

      &lt;transition event="execute" target="Executing"/&gt;
    &lt;/state&gt;    &lt;!-- end FormReady --&gt;

    &lt;state id="Executing"&gt;

      &lt;datamodel&gt;
        &lt;data id = "prompt"/&gt;
      &lt;/datamodel&gt;
      &lt;onentry&gt;
        &lt;assign location="$counter" expr="0"/&gt;
        &lt;assign location="$child_return" expr="null"/&gt;

        &lt;foreach var="child" array="$children"&gt;
          &lt;send target="$child/controller" event="evaluateChild"/&gt;
        &lt;/foreach&gt;
      &lt;/onentry&gt;

      &lt;transition event="Executing.done"&gt;
        &lt;assign location="$counter" expr="$counter + 1"/&gt;
        &lt;insert pos="after" name="$prompt" expr="_eventData/prompts"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Executing.error" target="Idle"&gt;
        &lt;send target="controller" event="Executing.error"
        namelist="_eventData/error_status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Executing.done" cond="$counter eq
      $children.size()-1" target="Ready"&gt;
        &lt;insert pos="after" name="$prompt" expr="_eventData/prompts"/&gt;
        &lt;send target="PromptQueue" event="/queuePrompt"
        namelist="$prompt, $properties"/&gt;
        &lt;send target="controller" event="executed"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Executing --&gt;

  &lt;/state&gt;
  &lt;!-- end Created --&gt;

&lt;/scxml&gt;

</pre>
</div>
</div>
</div>

<div class="div3">
<h4><a name="PromptModule:Events" id="PromptModule:Events" />6.4.3
Events</h4>

<p>The events in Table 32 may be raised during initialization and
execution of the &lt;prompt&gt; element.</p>

<a name="prompt:events" id="prompt:events" />
<table>
<caption>Table 32: &lt;prompt&gt; Events</caption>

<tbody>
<tr>
<td>Event</td>
<td>Description</td>
<td>State</td>
</tr>

<tr>
<th>error.unsupported.language</th>
<td>indicates that an unsupported language was encountered. The
unsupported language is indicated in the event message
variable.</td>
<td>execution</td>
</tr>

<tr>
<th>error.unsupported.<em>element</em></th>
<td>indicates that the <em>element</em> within the &lt;prompt&gt;
element is not supported</td>
<td>initialization</td>
</tr>

<tr>
<th>error.badfetch</th>
<td>indicates that the prompt content is malformed ...</td>
<td>initialization, execution</td>
</tr>

<tr>
<th>error.noresource</th>
<td>indicates that a Prompt Queue resource is not available for
rendering the prompt content.</td>
<td>execution</td>
</tr>

<tr>
<th>error.semantic</th>
<td>indicates an error with data model expressions: undefined
datamodel reference, invalid expression resolution, etc.</td>
<td>execution</td>
</tr>
</tbody>
</table>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Can we really determine whether errors are raised in
initialization (syntax) or execution (evaluation) states? How does
this fit in with errors returned when prompts are played in
PromptQueue player implementation? ACTION: Clarify which specific
cases are affected by 'error.badfetch' ambiguity re. initialization
versus execution states.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="prompt:examples" id="prompt:examples" />6.4.4
Examples</h4>

<p>[TBD: put all examples here.]</p>
</div>
</div>

<div class="div2">
<h3><a name="BuiltinSSMLModule" id="BuiltinSSMLModule" />6.5
Builtin SSML Module</h3>

<p>This module describes the syntactic and semantic features of
SSML elements built into VoiceXML.</p>

<p>This module is designed to extend the content model of the
&lt;prompt&gt; element defined in <a href="#PromptModule"><b>6.4
Prompt Module</b></a>.</p>

<p>The attributes and content model of SSML elements are specified
in <a href="#SSMLModule:Syntax"><b>6.5.1 Syntax</b></a>. Its
semantics are specified in <a href="#SSMLModule:Semantics"><b>6.5.2
Semantics</b></a>, including how elements are evaluated to yield
final content for playback.</p>

<div class="div3">
<h4><a name="SSMLModule:Syntax" id="SSMLModule:Syntax" />6.5.1
Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<p>This module defines an SSML (<a href="#SSML">[SSML]</a>) <a
href="http://www.w3.org/TR/speech-synthesis/#S2.2.1">Conforming
Speech Synthesis Markup Language Fragment</a> where:</p>

<ul>
<li>there is no explicit &lt;speak&gt; element.</li>

<li>these elements are part of the VoiceXML namespace rather than
the SSML namespace</li>

<li>the &lt;foreach&gt; element may appear inside these elements
prior to evaluation</li>

<li>the &lt;value&gt; element may appear inside these elements
prior to evaluation</li>

<li>The &lt;audio&gt; element is extended with the attributes
specified in Table 33, in addition to the fetchtimeout, fetchhint,
maxage, and maxstale attributes as specified in <a
href="#Fetching"><b>8.1.1 Fetching</b></a>.</li>
</ul>

<p></p>

<a name="audio:vxmlattributes" id="audio:vxmlattributes" />
<table>
<caption>Table 33: &lt;audio&gt; Attributes defined in
VoiceXML</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>expr</th>
<td />
<td>A data model expression which determines the source of the
audio to be played. The expression may be either a reference to
audio previously recorded (see Record Module) or evaluate to the
URI of an audio resource to fetch.</td>
<td>No</td>
<td>undefined</td>
</tr>
</tbody>
</table>

<p>Exactly one of "src" or "expr" attributes must be specified;
otherwise, an error.badfetch event is thrown.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>SSML 1.1 required for fetching attributes like fetchtimeout? Or
profile dependent?</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="SSMLModule:Semantics"
id="SSMLModule:Semantics" />6.5.2 Semantics</h4>

<p>When the RC receives an evaluate event, its children are
evaluated in order to return a document which can be processed by a
<a href="http://www.w3.org/TR/speech-synthesis/#S2.2.4">Conforming
Speech Synthesis Markup Language Processor</a>.</p>

<p>Evaluation consits of the following:</p>

<ul>
<li>data model expressions are evaluated against the data
model.</li>

<li>If a &lt;foreach&gt; element is present, it is evaluated so as
to yield content for each defined item in the array.</li>

<li>If an &lt;audio&gt; element has a specified expr attribute,
then the attribute value is evaluated to provide a URI value for
the src attribute. If the expr evaluation results in anything other
than a valid URI string, then the expr attribute and its content
are removed. ignored.</li>

<li>If a &lt;value&gt; element is present, its expr attribute is
evaluated to return a CDATA value.</li>

<li>construction of a &lt;speak&gt; element with appropriate
version, namespace, and xml:lang attributes. The xml:lang attribute
value is inherited from the &lt;prompt&gt; element (see <a
href="#PromptModule"><b>6.4 Prompt Module</b></a>).</li>

<li>if an unsupported language is encountered, the platform throws
an error.unsupported.language event which specifies the language in
its message variable</li>
</ul>

<p></p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Need to specify further error cases</p>

<p>Need to clarify unsupported languages and external (e.g. MRCP)
SSML processors.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="SSML_prompt:examples"
id="SSML_prompt:examples" />6.5.3 Examples</h4>

<p>In this example</p>

<div class="exampleInner">
<pre>
&lt;prompt&gt;

 &lt;foreach item="item" array="array"&gt;
    &lt;audio expr="item.audio"&gt;&lt;value expr="item.tts"/&gt;&lt;/audio&gt;
    &lt;break time="300ms"/&gt;
 &lt;/foreach&gt;

&lt;/prompt&gt;
</pre>
</div>

<p>evaluation returns a sequence of content for each item in
&lt;foreach&gt; with &lt;audio&gt; and &lt;value&gt; elements.</p>

<p>Assume that the array consists of 2 items where each item.audio
evaluates to 'one.wav' and 'two.wav' respectively, and each
item.tts evaluates to 'one' and 'two' respectively. Evaluation of
&lt;foreach&gt; is equivalent to the following</p>

<div class="exampleInner">
<pre>
&lt;prompt&gt;

    &lt;audio expr="'one.wav'"&gt;&lt;value expr="'one'"/&gt;&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

    &lt;audio expr="'two.wav'"&gt;&lt;value expr="'two'"/&gt;&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

&lt;/prompt&gt;
</pre>
</div>

<p>further evaluation of the &lt;audio&gt; and &lt;value&gt;
elements result in</p>

<div class="exampleInner">
<pre>
&lt;prompt&gt;

    &lt;audio src="one.wav"&gt;one&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

    &lt;audio src="two.wav"&gt;two&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

&lt;/prompt&gt;
</pre>
</div>

<p>and finally the prompt content is converted into a stand-alone
SSML document (assuming the &lt;prompt&gt;'s xml:lang attribute
evaluates to 'en'):</p>

<div class="exampleInner">
<pre>
&lt;speak version="1.0" xml:lang="en" 
 xmlns="http://www.w3.org/2001/10/synthesis"&gt;

    &lt;audio src="one.wav"&gt;one&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

    &lt;audio src="two.wav"&gt;two&lt;/audio&gt;
    &lt;break time="300ms"/&gt;

&lt;/speak&gt;
</pre>
</div>

<p>This content is queued and played using the PromptQueue: each
audio URI, or fallback content, is played, followed by a 300
millisecond break.</p>
</div>
</div>

<div class="div2">
<h3><a name="MediaModule" id="MediaModule" />6.6 Media Module</h3>

<p>The media module defines the syntax and semantics of the
&lt;media&gt; element.</p>

<p>The module is designed to extend the content model of
&lt;prompt&gt; in the prompt module (<a href="#PromptModule"><b>6.4
Prompt Module</b></a>).</p>

<p>The &lt;media&gt; element can be seen as an enhanced and
generalized version of the VoiceXML &lt;audio&gt; element. It is
enhanced in that it provides additional attributes describing the
type of media, conditional selection, as well as control over
playback . It is a generalization of the &lt;audio&gt; element in
that it permits media other than audio to be played; for example,
media formats which contains audio and video tracks.</p>

<div class="div3">
<h4><a name="MediaModule:Syntax" id="MediaModule:Syntax" />6.6.1
Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e3048" id="d3e3048" />6.6.1.1 Attributes</h5>

<p>The &lt;media&gt; element has the attributes specified in Table
34, in addition to the fetchtimeout, fetchhint, maxage, and
maxstale attributes as specified in <a href="#Fetching"><b>8.1.1
Fetching</b></a>.</p>

<a name="media:attributes" id="media:attributes" />
<table>
<caption>Table 34: &lt;media&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>src</th>
<td />
<td>The URI specifying the location of the media source.</td>
<td>No</td>
<td>None</td>
</tr>

<tr>
<th>srcexpr</th>
<td />
<td>A data model expression which evaluates to a URI indicating the
location of the media resource.</td>
<td>No</td>
<td>undefined</td>
</tr>

<tr>
<th>cond</th>
<td />
<td>A data model expression that must evaluate to true after
conversion to boolean in order for the media to be played.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>type</th>
<td />
<td>
<p>The preferred media type of the output resource. A resource
indicated by the URI reference in the <code>src</code> or
<code>expr</code> attributes may be available in one or more media
types. The author may specify the preferred media type via the
<code>type</code> attribute. When the content represented by a URI
is available in many data formats, a VoiceXML platform may use the
preferred media-type to influence which of the multiple formats is
used. For instance, on a server implementing HTTP content
negotiation, the processor may use the preferred media-type to
order the preferences in the negotiation.</p>

<p>The resource representation delivered by dereferencing the URI
reference may be considered in terms of two types. The <em>declared
media-type</em> is the asserted value for the resource and the
<em>actual media-type</em> is the true format of its content. The
actual media-type should be the same as the declared media-type,
but this is not always the case (e.g. a misconfigured HTTP server
might return 'text/plain' for a 'audio/x-wav' or video/3gpp'
resource). A specific URI scheme may require that the resource
owner always, sometimes, or never return a media-type. The declared
media-type is the value returned by the resource owner or, if none
is returned, the preferred media type. There may be no declared
media-type if the resource owner does not return a value and no
preferred type is specified. Whenever specified, the declared
media-type is authoritative.</p>

<p>Three special cases may arise.</p>

<ol class="enumar">
<li>The declared media-type may not be supported by the processor.
No error is thrown by the platform and the content of the
<code>media</code> element is played instead.</li>

<li>The declared media-type may be supported but the actual
media-type may not match. No error is thrown by the platform and
the content of the <code>media</code> element is played
instead.</li>

<li>Finally, there may be no declared media-type; the behavior
depends on the specific URI scheme and the media capabilities of
the VoiceXML processor. For instance, HTTP 1.1 allows document
introspection (see <a href="#RFC2616">[RFC2616]</a>, section
7.2.1), the data scheme falls back to a default media type, and
local file access defines no guidelines.</li>
</ol>
</td>
<td>No</td>
<td>undefined</td>
</tr>

<tr>
<th>clipBegin</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>offset from start of media to begin rendering. This offset is
measured in normal media playback time from the beginning of the
media.</td>
<td>No</td>
<td>0s</td>
</tr>

<tr>
<th>clipEnd</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>offset from start of media to end rendering. This offset is
measured in normal media playback time from the beginning of the
media.</td>
<td>No</td>
<td><em>None</em></td>
</tr>

<tr>
<th>repeatDur</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>total duration for repeatedly rendering media. This duration is
measured in normal media playback time from the beginning of the
media.</td>
<td>No</td>
<td><em>None</em></td>
</tr>

<tr>
<th>repeatCount</th>
<td>positive <a title="" href="#">Real number</a> </td>
<td>number of iterations of media to render. A fractional value
describes a portion of the rendered media.</td>
<td>No</td>
<td>1</td>
</tr>

<tr>
<th>soundLevel</th>
<td>signed ("+" or "-") CSS2 numbers immediately followed by
"dB"</td>
<td>Decibel values are interpreted as a ratio of the squares of the
new signal amplitude (a1) and the current amplitude (a0) and are
defined in terms of dB: soundLevel(dB) = 20 log10 (a1 / a0) A
setting of a large negative value effectively plays the media
silently. A value of '-6.0dB' will play the media at approximately
half the amplitude of its current signal amplitude. Similarly, a
value of '+6.0dB' will play the media at approximately twice the
amplitude of its current signal amplitude (subject to hardware
limitations). The absolute sound level of media perceived is
further subject to system volume settings, which cannot be
controlled with this attribute.</td>
<td>No</td>
<td>+0.0dB</td>
</tr>

<tr>
<th>speed</th>
<td>x% (where x is a positive real value)</td>
<td>the speed at which to play the referenced media, relative to
the original speed. The speed is set to the requested percentage of
the speed of the original media. For audio, a change in the speed
will change the rate at which recorded samples are played back and
this will affect the pitch.</td>
<td>No</td>
<td>100%</td>
</tr>

<tr>
<th>outputmodes</th>
<td>space separated list of media types</td>
<td>Determines the modes used for media output. See <a
href="#Properties:Media"><b>8.2.4 Media Properties</b></a> for
further details.</td>
<td>No</td>
<td><a title="" href="#Property:outputmodes">outputmodes</a>
property</td>
</tr>
</tbody>
</table>

<p>See <a href="#mediaOccurenceConstraint">occurrence
constraints</a> for restrictions on occurrence of src and srcexpr
attributes.</p>

<p>Calculations of rendered durations and interaction with other
timing properties follow SMIL 2.1 <a
href="http://www.w3.org/TR/SMIL/smil-timing.html#Timing-ComputingActiveDur"
 shape="rect">Computing the active duration</a> where</p>

<ul>
<li>&lt;media&gt; is a time container</li>

<li><a title="" href="#TimeDesignation">Time Designation</a> values
for clipBegin, clipEnd, and repeatDur are a subset of SMIL
Clock-value</li>

<li>If the length of an media clip is not known in advance then it
is treated as indefinite. Consequently repeatCount will have no
effect.</li>

<li>If clipEnd is after the end of the media, then rendering ends
at the media end.</li>

<li>If clipBegin is after clipEnd, no audio will be produced.</li>

<li>If clipBegin equals clipEnd, the behavior depends upon the kind
of media. For media with a concept of frames, such as video, the
single frame at the beginning of clipBegin is rendered for
repeatDur.</li>

<li>repeatDur takes precedence over repeatCount in determining the
maximum duration of the media.</li>
</ul>

<p>Note that not all SMIL 2.1 Timing features are supported.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Use SMIL 3.0 or SMIL 2.1 reference?</p>
</td>
</tr>
</table>
</div>

<div class="div4">
<h5><a name="d3e3275" id="d3e3275" />6.6.1.2 Content Model</h5>

<p>The &lt;media&gt; element content model consists of:</p>

<ul>
<li>Inline content: SSML &lt;speak&gt; (0 or 1). Note that this
content may include &lt;value&gt; and &lt;foreach&gt; elements from
the VoiceXML namespace.</li>

<li>&lt;desc&gt; element (0 or more)</li>

<li>&lt;media&gt;: for fallback in the case where the resource
referenced by the mother &lt;media&gt; element is unavailable (0 or
more)</li>
</ul>

<p></p>

<div id="mediaOccurenceConstraint">
<p>The &lt;media&gt; has the following co-occurrence
constraints:</p>

<ul>
<li>One of the src attribute or the srcexpr attribute or inline
content must be specified; otherwise, an error.badfetch event is
thrown.</li>
</ul>
</div>

<p>Note that the type attribute does not affect inline content. The
handling of inline XML content is in accordance to the namespace of
the root element (such as SSML &lt;speak&gt;, SMIL &lt;smil&gt;,
and so forth). CDATA, or mixed content with VoiceXML
&lt;foreach&gt; or &lt;value&gt; elements <strong>must</strong> be
treated as an SSML Fragment and evaluated as described in <a
href="#MediaModule:Semantics"><b>6.6.2 Semantics</b></a>.</p>

<div class="div5">
<h6><a name="d3e3302" id="d3e3302" />6.6.1.2.1 Tips
(informative)</h6>

<p>Developers should be aware that there may be performance
implications when using &lt;media&gt; depending on which attributes
are specified, the media itself, its transport and processing.</p>

<p>Since operations like trimming, soundLevel and speed
modifications are applied to media, this requires that the SSML
processor begins generating output audio before these operations
are applied. If the clipBegin attribute is specified, this may
required SSML generation of audio prior to clipBegin, depending on
the implementation. This may lead to a gap between execution of the
&lt;media&gt; element and start of playback.</p>

<p>If the media is fetched with HTTP protocol and the clipBegin
attribute is specified, then, unless the the resource is cached
locally, the part of the media resource before the clipBegin, will
still be fetched from the origin server. This may result in a gap
between the execution of the &lt;media&gt; element and playback
actually beginning.</p>

<p>Note also if &lt;media&gt; uses the RTSP protocol, and the
VoiceXML platform supports this protocol, then the clipBegin
attribute value may be mapped to the RTSP <code>Range</code> header
field, thereby reducing the gap between element execution and the
onset of playback.</p>
</div>
</div>
</div>

<div class="div3">
<h4><a name="MediaModule:Semantics"
id="MediaModule:Semantics" />6.6.2 Semantics</h4>

<p>When an media RC receives an evaluate event, the following
operations are performed:</p>

<ul>
<li>attributes with data model expressions are evaluated against
the data model</li>

<li>if inline SSML content is specified (i.e. &lt;speak&gt; root),
then its RC is sent an evaluate event (where any &lt;foreach&gt;
and &lt;value&gt; elements are evaluated).</li>

<li>if inline CDATA content (i.e. CDATA root), or &lt;foreach&gt;
and &lt;value&gt; root elements which evaluate to CDATA content,
then it is treated as SSML &lt;speak&gt; content.</li>

<li>if the media resource has not yet been fetched, the resource is
fetched. If SSML content is specified, then the evaluated content
is processed by the SSML processor and a media resource
returned.</li>
</ul>

<p>The resulting media resource is returned together with resolved
media operation properties (clipBegin, clipEnd, soundLevel, speed,
outputmodes).</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Semantics needs to address a mixed content model; e.g. CDATA and
XML elements as children of the root.</p>

<p>Do we require 'application/ssml+xml' type with SSML and CDATA
content?</p>

<p>Need to clarify where resource fetching takes place in the
semantic model. Eg. in prompt initializing or executing state? or
in prompt queue?</p>

<p>This approach assumes the prompt queue applies media processing
operations. Intended to fit with the VCR/RTC approach.</p>

<p>What about streaming cases? Allow streams to be returned?</p>

<p>Specify how errors are addressed.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="MediaModule:Examples"
id="MediaModule:Examples" />6.6.3 Examples</h4>

<p>Playback of external audio media resource.</p>

<div class="exampleInner">
<pre>
&lt;media type="audio/x-wav" src="http://www.example.com/resource.wav"/&gt;
</pre>
</div>

<p>Application of media operations to audio resource. The
soundLevel increases the volume by approximately 50% and the speed
is reduced to 50%.</p>

<div class="exampleInner">
<pre>
&lt;media type="audio/x-wav" soundLevel="+6.0dB" speed="50%" 
       src="http://www.example.com/resource.wav"/&gt;
</pre>
</div>

<p>Playback of 3GPP media resource.</p>

<div class="exampleInner">
<pre>
&lt;media type="video/3gpp" src="http://www.example.com/resource.3gp"/&gt;
</pre>
</div>

<p>Playback of 3GPP media resource with the speed doubled and
playback ending after 5 seconds.</p>

<div class="exampleInner">
<pre>
&lt;media type="video/3gpp" clipEnd="5s" speed="200%" 
       src="http://www.example.com/resource.3gp"/&gt;
</pre>
</div>

<p>Playback of external SSML document.</p>

<div class="exampleInner">
<pre>
&lt;media type="application/ssml+xml" 
       src="http://www.example.com/resource.ssml"/&gt;
</pre>
</div>

<p>Inline CDATA content with a &lt;value&gt; element</p>

<div class="exampleInner">
<pre>
&lt;media&gt;
    Ich bin ein Berliner, said &lt;value expr="speaker"/&gt;
&lt;/media&gt;
</pre>
</div>

<p>which is syntactically equivalent to</p>

<div class="exampleInner">
<pre>
&lt;media&gt;
   &lt;speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"&gt;
    Ich bin ein Berliner, said &lt;value expr="speaker"/&gt;
    &lt;/speak&gt;
&lt;/media&gt;
</pre>
</div>

<p>Inline SSML content to which gain and clipping operations are
applied.</p>

<div class="exampleInner">
<pre>

&lt;media soundLevel="+4.0dB" clipBegin="4s"&gt;
   &lt;speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"&gt;
    Ich bin ein Berliner.
    &lt;/speak&gt;
&lt;/media&gt;


</pre>
</div>

<p>Inline SSML with audio media fallback.</p>

<div class="exampleInner">
<pre>
&lt;media volume="+4.0dB" clipBegin="4s"&gt;
   &lt;speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"&gt;
    Ich bin ein Berliner.
    &lt;/speak&gt;
    &lt;media type="audio/x-wav" src="ichbineinberliner.wav"&gt;
&lt;/media&gt;

</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="ParseqModule" id="ParseqModule" />6.7 Parseq
Module</h3>

<p>This module defines the syntax and semantics of &lt;par&gt; and
&lt;seq&gt; elements. The &lt;par&gt; element specifies playback of
media in parallel, while &lt;seq&gt; specifies playback in
sequence.</p>

<p>The module is designed to extend the content model of the
&lt;prompt&gt; element (<a href="#PromptModule"><b>6.4 Prompt
Module</b></a>).</p>

<p>This module is dependent upon the media module (<a
href="#MediaModule"><b>6.6 Media Module</b></a>).</p>

<p>With connections which support multiple media streams, it is
possible to simultaneously playback multiple media types. For media
container formats like 3GPP, audio and video media can be generated
simultaneously from the same media resource.</p>

<p>There are established use cases for simultaneous playback of
multiple media which are specified in separate resources:</p>

<ul>
<li>Video mail: an audio message has been left using a conventional
audio only system. For playback on a system with video support, a
video resource can be played simultaneously with an image of the
person, or an avatar.</li>

<li>Enterprise: a video stream resource from a security camera with
TTS voiceover providing additional information.</li>

<li>Education: a video resource showing medical procedure with
commentary provided by lecturer in student's language.</li>

<li>Talking heads: an animated avatar together with audio or TTS
voiceover.</li>
</ul>

<p>The intention is provide support for basic use cases where audio
or TTS output from one resource can be complemented with output
from another resource as permitted by the connection and platform
capabilities.</p>

<div class="div3">
<h4><a name="ParseqModule:Syntax" id="ParseqModule:Syntax" />6.7.1
Syntax</h4>

<p>The &lt;par&gt; element is derived from SMIL &lt;par&gt;
element, a time container for parallel output of media resources.
Media elements (or containers) within a &lt;par&gt; element are
played back in parallel.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">SMIL reference should be
added in <a href="#References"><b>B References</b></a>. SMIL is
Synchronized Multimedia Integration Language (SMIL). Reference to
<a href="http://www.w3.org/TR/REC-smil/">SMIL 1.0</a> (or later)
Specification.</td>
</tr>
</table>

<p>The &lt;par&gt; element has the attributes specified in Table
35.</p>

<a name="parseq:parattributes" id="parseq:parattributes" />
<table>
<caption>Table 35: &lt;par&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>endsync</th>
<td />
<td>Indicates when element is considered complete. 'first'
indicates that the element is complete when any media (or
container) child reports that it is complete; 'last' indicates it
is complete when all media children are complete.</td>
<td>No</td>
<td>last</td>
</tr>
</tbody>
</table>

<p>The content model of &lt;par&gt; consists of:</p>

<ul>
<li>&lt;media&gt; elements (0 or more)</li>

<li>&lt;seq&gt; elements (0 or more)</li>
</ul>

<p></p>

<p>The &lt;par&gt; element is derived from SMIL &lt;seq&gt;
element, a time container for sequential output of media resources.
Media elements within a &lt;seq&gt; element are played back in
parallel.</p>

<p>No attributes are defined for &lt;seq&gt;.</p>

<p>The content model of &lt;seq&gt; consists of:</p>

<ul>
<li>&lt;media&gt; elements (0 or more)</li>
</ul>

<p></p>
</div>

<div class="div3">
<h4><a name="ParseqModule:Semantics"
id="ParseqModule:Semantics" />6.7.2 Semantics</h4>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Issue: how should parallel playback interact with the
PromptQueue resource? The simplest assumption would be that if this
module is supported, then prompt queue needs to be able to handle
parallel playback.</p>

<p>For example when bargein event happens during the parallel
execution, the synchronization between both prompt and for example
video play should be handled. This information should be explained
in the prompt queue resource section.</p>
</td>
</tr>
</table>

<p>This module requires a PromptQueue resource which support
playback of parallel and sequential media. The following defines
its playback completion, termination and error handling.</p>

<p>Completion of playback of the &lt;par&gt; element is determined
according to the value of its endsync attribute. For instance,
assume a &lt;par&gt; element containing &lt;media&gt; (or
&lt;seq&gt;) elements A and B, and that B finishes before A. If
endsync has the value first, then completion is reported upon B's
completion. If endsync has the value last, then completion is
reported upon A's completion.</p>

<p>Completion of playback of the &lt;seq&gt; element occurs when
the last &lt;media&gt; is complete.</p>

<p>If the &lt;par&gt; element playback is terminated, then playback
of its &lt;media&gt; and &lt;seq&gt; children is terminated.
Likewise, if the &lt;seq&gt; element playback is terminated, then
playback of its (active) &lt;media&gt; elements is terminated.</p>

<p>If mark information is provided by &lt;media&gt; elements (for
example with SSML), then, the mark information associated with last
element played in sequence or parallel is exposed as described in
XXX.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Open issue: Clarify interaction with VCR media control
model(s).</p>

<p>&lt;reposition&gt; approach would require that &lt;par&gt; and
&lt;seq&gt; need to be able to restart from a specific position
indicated by the markname/time of a &lt;media&gt; element contained
within them.</p>

<p>RTC approach would require that for &lt;par&gt;, media
operations are applied in parallel.</p>
</td>
</tr>
</table>

<p>Error handling policy is inherited from the element in which
&lt;par&gt; and &lt;seq&gt; element are children.</p>

<p>For instance if the policy is to ignore errors, then the
following applies:</p>

<ul>
<li>If an error occurs when playing a &lt;media&gt; element in
&lt;par&gt;, then the error is ignored.</li>

<li>Likewise, if there is an error playing back a &lt;media&gt;
element in &lt;seq&gt;, the error is ignored and the next
&lt;media&gt; element in the sequence, if there is one, is
played.</li>

<li>If the &lt;media&gt; element in which the error occurs is the
final one in the &lt;par&gt; element, then completion of
&lt;par&gt; playback is signaled when the error is detected.</li>
</ul>

<p></p>

<p>If the policy is to terminate playback and report the error,
then the any error causes immediate termination of any playback and
the error is reported.</p>

<p>If execution of the &lt;par&gt; and &lt;seq&gt; elements
requires media capabilities which are not supported by the platform
or the connection, or there is an error fetching or playing any
&lt;media&gt; element within &lt;par&gt; or &lt;seq&gt;, then error
handling follows the defined policy.</p>
</div>

<div class="div3">
<h4><a name="ParseqModule:Examples"
id="ParseqModule:Examples" />6.7.3 Examples</h4>

<p>video avatar with audio commentary. Note the use of the
outputmodes attributes of &lt;media&gt; to ensure that only video
is played.</p>

<div class="exampleInner">
<pre>
 &lt;par&gt;
   &lt;media type="audio/x-wav" src="commentary.wav"/&gt;
   &lt;media type="video/3gpp" src="avatar.3gp" outputmodes="video"/&gt;
 &lt;/par&gt;
</pre>
</div>

<p>video avatar with a sequence of audio and TTS commentary.</p>

<div class="exampleInner">
<pre>
 &lt;par&gt;
   &lt;seq&gt;
     &lt;media type="audio/x-wav" src="intro.wav"/&gt;
     &lt;media type="application/ssml+xml" src="commentary.ssml"/&gt;
   &lt;/seq&gt;
   &lt;media type="video/3gpp" src="avatar.3gp" outputmodes="video"/&gt;
 &lt;/par&gt;
</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="ForeachModule" id="ForeachModule" />6.8 Foreach
Module</h3>

<p>This module describes the syntactic and semantic features of the
&lt;foreach&gt; element.</p>

<p>This module is designed to extend the content model of an
element in another module. For example, SSML elements in the <a
href="#BuiltinSSMLModule"><b>6.5 Builtin SSML Module</b></a>, the
&lt;prompt&gt; element defined in <a href="#PromptModule"><b>6.4
Prompt Module</b></a>, etc.</p>

<p>The attributes and content model of the element are specified in
<a href="#ForeachModule:Syntax"><b>6.8.1 Syntax</b></a>. Its
semantics are specified in <a
href="#ForeachModule:Semantics"><b>6.8.2 Semantics</b></a>.</p>

<div class="div3">
<h4><a name="ForeachModule:Syntax"
id="ForeachModule:Syntax" />6.8.1 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e3564" id="d3e3564" />6.8.1.1 Attributes</h5>

<p>The &lt;foreach&gt; element has the attributes specified in
Table 36.</p>

<a name="foreach:attributes" id="foreach:attributes" />
<table>
<caption>Table 36: &lt;foreach&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>array</th>
<td />
<td>A data model expression that must evaluate to an array;
otherwise, an error.semantic event is thrown. Note that the
&lt;foreach&gt; element operates on a shallow copy of the array
specified by the array attribute.</td>
<td>Yes</td>
<td /></tr>

<tr>
<th>item</th>
<td />
<td>A data model variable that stores each array item upon each
iteration of the loop. A new variable will be declared if it is not
already defined within the parent's scope.</td>
<td>Yes</td>
<td /></tr>
</tbody>
</table>

<p>Both "array" and "item" must be specified; otherwise, an
error.badfetch event is thrown.</p>

<p>The iteration process starts from an index of 0 and increments
by one to an index of array_name.length - 1, where array_name is
the name of the shallow copied array operated on by the
&lt;foreach&gt; element. For each index, a shallow copy or
reference to the corresponding array element is assigned to the
item variable (i.e. &lt;foreach&gt; assignment is equivalent to
item = array_name[index] in ECMAScript); the assigned value could
be undefined for a sparse array. Undefined array items are
ignored.</p>

<p>VoiceXML 3.0 does not provide break functionality to interrupt a
&lt;foreach&gt;.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Clarify that array items which evaluate to ECMAScript undefined
are ignored?</p>
</td>
</tr>
</table>
</div>

<div class="div4">
<h5><a name="d3e3616" id="d3e3616" />6.8.1.2 Content Model</h5>

<p>The content model of the &lt;foreach&gt; element is dependent
upon the element in which it is a child. The profile in which this
element is used must specify the content model(s) of this
element.</p>
</div>
</div>

<div class="div3">
<h4><a name="ForeachModule:Semantics"
id="ForeachModule:Semantics" />6.8.2 Semantics</h4>

<p>When the RC receives an evaluate event, the RC loops through the
array to produce an evaluated content for each item in the
array.</p>
</div>

<div class="div3">
<h4><a name="ForeachModule:examples"
id="ForeachModule:examples" />6.8.3 Examples</h4>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>These examples may be moved to the respective profile section
later.</p>
</td>
</tr>
</table>

<p>The vxml21 profile defines the content model for the
&lt;foreach&gt; element so that it may appear in executable content
and within &lt;prompt&gt; elements.</p>

<p>Within executable content, except within a &lt;prompt&gt;, the
&lt;foreach&gt; element may contain any elements of executable
content; this introduces basic looping functionality by which
executable content may be repeated for each element of an
array.</p>

<p>When &lt;foreach&gt; appears within a &lt;prompt&gt; element as
part Builtin SSML content, it may contain only those elements valid
within &lt;enumerate&gt; (i.e. the same elements allowed within
&lt;prompt&gt; less &lt;meta&gt;, &lt;metadata&gt;, and
&lt;lexicon&gt;); this allows for sophisticated concatenation of
prompts.</p>

<p>In this example using Builtin SSML, each item in the array has
an audio property with a URI value, and a tts property with SSML
content. The element loops through the array, playing the audio URI
or the SSML content as fallback, with a 300 millisecond break
between each iteration.</p>

<div class="exampleInner">
<pre>
&lt;prompt&gt;

 &lt;foreach item="item" array="array"&gt;
    &lt;audio expr="item.audio"&gt;&lt;value expr="item.tts"/&gt;&lt;/audio&gt;
    &lt;break time="300ms"/&gt;
 &lt;/foreach&gt;

&lt;/prompt&gt;
</pre>
</div>

<p></p>

<p>In the mediaserver profile, &lt;foreach&gt; may occurs within
&lt;prompt&gt; elements and has the content model of 0 or more
&lt;media&gt; elements.</p>

<p>Play each media resource in the array.</p>

<div class="exampleInner">
<pre>
  &lt;foreach item="item" array="array"&gt;
   &lt;media type="audio/x-wav" src="item.audio"/&gt;
  &lt;/foreach&gt;
</pre>
</div>

<p>Play each media resource in the array.</p>

<div class="exampleInner">
<pre>
&lt;foreach item="item" array="array"&gt;
   &lt;media type="audio/x-wav" src="item.wav"&gt;
   &lt;media type="application/ssml+xml"&gt;
    &lt;speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis"&gt;     
     &lt;value expr="item.tts"/&gt;
     &lt;break time=300ms"/&gt;
     &lt;/speak&gt;
   &lt;/media&gt;
 &lt;/media&gt; 
&lt;/foreach&gt;
</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="FormModule" id="FormModule" />6.9 Form Module</h3>

<div class="div3">
<h4><a name="d3e3661" id="d3e3661" />6.9.1 Syntax</h4>

<p>Forms are the key component of VoiceXML documents. A form
contains:</p>

<ul>
<li>A set of form items, elements that are visited in the main loop
of the form interpretation algorithm. Form items are subdivided
into input items that can be 'filled' by user input and control
items that cannot.</li>

<li>Declarations of non-form item variables.</li>

<li>Event handlers.</li>

<li>"Filled" actions, blocks of procedural logic that execute when
certain combinations of input item variables are assigned.</li>
</ul>

<p></p>

<a name="form:attributes" id="form:attributes" />
<table>
<caption>Table 37: Table: &lt;form&gt; Attributes</caption>

<tbody>
<tr>
<th>id</th>
<td>The name of the form. If specified, the form can be referenced
within the document or from another document. For instance &lt;form
id="weather"&gt;, &lt;goto next="#weather"&gt;.</td>
</tr>

<tr>
<th>scope</th>
<td>The default scope of the form's grammars. If it is dialog then
the form grammars are active only in the form. If the scope is
document, then the form grammars are active during any dialog in
the same document. If the scope is document and the document is an
application root document, then the form grammars are active during
any dialog in any document of this application. Note that the scope
of individual form grammars takes precedence over the default
scope; for example, in non-root documents a form with the default
scope "dialog", and a form grammar with the scope "document", then
that grammar is active</td>
</tr>
</tbody>
</table>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>This section needs to be updated to reflect the new V3 Form
behavior, perhaps removing all references to the FIA. Essentially
the whole module needs to be reworked.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="d3e3696" id="d3e3696" />6.9.2 Semantics</h4>

<div class="div4">
<h5><a name="RC:Form" id="RC:Form" />6.9.2.1 Form RC</h5>

<p>The Form RC is the primary RC for the &lt;form&gt; element.</p>

<p>The Form RC interacts with resource controllers of other modules
so as to provide the behavior of VoiceXML 2.1/2.0 &lt;form&gt; tag.
Input and control form items are modeled as resource controllers:
for the example, the &lt;field&gt; RC (<a
href="#RC:Field"><b>6.10.2.1 Field RC</b></a>) of the Field
Module.</p>

<p>The behavior of the Form RC follows the VoiceXML FIA, although
some aspects of this are not modeled directly in this RC: external
transition handling is not part of the form RC; input items used
separate RCs to manage coordination between media resources, while
recognition results can be received directly by form, field or
other RCs.</p>

<p>[This initial version does not address all aspects of FIA
behavior; for example, event handling, error handling and external
transitions are not covered.]</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">This description of the
form needs to be updated with all the new functionality we have
given the form via our new eventing approach.</td>
</tr>
</table>

<div class="div5">
<h6><a name="d3e3715" id="d3e3715" />6.9.2.1.1 Definition</h6>

<p>The form RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this form RC</li>

<li>children: array of children's (primary) RC</li>

<li>activeItem: current form item being executed</li>

<li>active: Boolean indicating whether this form is active.
Default: false.</li>

<li>justFilled: array of child RC which have just been filled</li>

<li>recoResult: The recognition result of the previously executed
form item.</li>

<li>previousItem: The previous form item already executed.</li>

<li>nextItem: The next form item which is presently scheduled for
executed.</li>

<li>modal: The modality of the current form item being
executed.</li>

<li>id: The form identifier.</li>
</ul>

<p></p>

<p>The form RC's state model consists of the following states:
Idle, Initializing, Ready, SelectingItem, PreparingItem,
PreparingFormGrammars, PreparingOtherGrammars, Executing, Active,
ProcessingFormResult, Evaluating and Exit.</p>

<p>In the Idle state, the form RC can receive an 'initialize' event
whose 'controller' event data is used to update the data model. The
RC then transitions into Initiating state.</p>

<p>In the Initializing state, the RC creates a dialog scope in the
Datamodel Resource and then initializes its children: this is
modeled as a separate RC. When all children are initialized, the RC
sends an 'initialized' event to its controller and transitions to
the Ready state.</p>

<p>In the Ready state, the form RC sets its active status to false.
It can receive one of two events: 'prepareGrammars' or ‘execute’.
‘prepareGrammars’ indicates that another form is active, but this
form's form-level grammars may be activated; an 'execute' event
indicates that this form is active. If the RC receives a
'prepareGrammars' event, it transitions to the
PreparingFormGrammars state. If the RC receives an 'execute' event,
it sets its active data to true and transitions to the
'SelectingItem' state.</p>

<p>In the SelectingItem state, the RC determines which form item to
select as the active item. This is defined by a FormItemSelection
RC which iterates over the children sending each a 'checkStatus'
event. If a child returns a true status (indicating that it ready
for execution)), the activeItem is set to this child RC and the RC
transitions to the PreparingItem state. If no child returns this
status, then the RC is complete and transitions the Exit State.</p>

<p>In the PreparingItem state, the activeItem is sent a 'prepare'
event causing it to prepare itself; for example, the field RC
prepares its prompts and grammars for execution. When the
activeItem returns a 'prepared' event, the event data indicates
whether the item is modal or not. If the item is modal, then the
form RC transitions to the Executing state. If the item is not
modal (other grammars can be activated), then the form RC
transitions to the PreparingFormGrammars state.</p>

<p>In the PreparingFormGrammars state, the RC prepares form-level
grammars. This is defined by a separate RC which iterates through
and executes grammar children. When this is complete, the RC
transitions to the Active state if the form is not active (active
data), and transitions to the PreparingOtherGrammars if the form is
active.</p>

<p>In the PreparingOtherGrammars states, the RC sends a
'prepareGrammars' event to its controller RC (which in turn sends
the event to appropriate form, document and application level RCs
with grammars). When its receives a 'prepared' from its controller,
the RC transitions to the Executing state.</p>

<p>In the Executing state, the form RC sends an 'execute' event to
the active form item. If the form item is a field, then this will
causes prompts to be played and recognition to take place. The RC
then transitions to the Active state awaiting a result.</p>

<p>In the Active state, the RC re-initializes the justFilled data
to a new array and waits for a recognition results (as active or
non-active form), or for a signal from its selected form item that
it has received the recognition result. Recognition results are
divided into two types: form item level results, received and
processed by the form item; and form level results which are
received by the form RC which caused the grammar to be added. If a
'recoResult' event is received by the form RC, the RC transitions
into the ProcessingFormResult state. If the active form item
receives the recognition result (and locally updated itself), then
the form RC receives a 'formItemResult' event, adds the active item
to the justFilled array, and transitions into the Evaluating
state.</p>

<p>In the ProcessingFormResult state, the recognition result is
processed by iterating through the form item children, obtaining
their name and slotname, and then attempting to match the slotname
to the results. If the match is successful, the name variable in
the data model result is updated with the value from the
recognition result and the child is added to the justFilled data
array. When this process is complete, the form RC transitions to
the Evaluating state.</p>

<p>In the Evaluating state, the form RC then iterates through its
children and if a child is a member of the 'JustFilled' array, it
sends a 'evaluate' event to the form item RC causing the
appropriate filled RCs to be executed. If the child is a filled RC,
then it is executed if appropriate. When evaluation is complete,
the form RC transitions to the 'selectformitem' state so that the
next form item can be selected for execution.</p>
</div>

<div class="div5">
<h6><a name="d3e3768" id="d3e3768" />6.9.2.1.2 Defined Events</h6>

<p>The Form RC is defined to receive the following events:</p>

<a name="formRC:eventsRecieved" id="formRC:eventsRecieved" />
<table>
<caption>Table 38: Table: Events received by &lt;form&gt;
RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>Update the data model</td>
</tr>

<tr>
<td>prepareGrammars</td>
<td>controller</td>
<td />
<td>Another form is active, but the current form's form-level
grammars may be activated.</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td />
<td>Current form is active</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<a name="formRC:eventsSent" id="formRC:eventsSent" />
<table>
<caption>Table 39: Table: Events sent by &lt;form&gt; RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>controller</td>
<td />
<td>Notification that initialization is complete</td>
</tr>

<tr>
<td>prepareGrammars</td>
<td>controller</td>
<td />
<td>Sent to prepare grammars to appropriate form, document and
application level RCs.</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td />
<td>Notification of complete recognition result from the field
RC.</td>
</tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e3852" id="d3e3852" />6.9.2.1.3 External Events</h6>

<p>The following table shows the events sent and received by the
form RC to resources and other RCs which define the events.</p>

<a name="formRC:externalEvents" id="formRC:externalEvents" />
<table>
<caption>Table 40: Table: &lt;form&gt; RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>checkStatus</td>
<td>FormRC</td>
<td>FormItem RC</td>
<td>Check if ready for execution</td>
</tr>

<tr>
<td>createScope</td>
<td>FormRC</td>
<td>DataModel</td>
<td>Creates a scope.</td>
</tr>

<tr>
<td>destroyScope</td>
<td>FormRC</td>
<td>DataModel</td>
<td>Delete a scope.</td>
</tr>

<tr>
<td>evaluate</td>
<td>FormRC</td>
<td>FormItem RC</td>
<td>Process form item being filled.</td>
</tr>

<tr>
<td>execute</td>
<td>FormRC</td>
<td>FormItem RCs</td>
<td>Start execution.</td>
</tr>

<tr>
<td>prepare</td>
<td>FormRC</td>
<td>FormItem RC</td>
<td>Initiates preparation needed before execution.</td>
</tr>

<tr>
<td>formItemResult</td>
<td>FormItemRC</td>
<td>FormRC</td>
<td>Results received by the form item.</td>
</tr>

<tr>
<td>prepared</td>
<td>FormItemRC</td>
<td>FormRC</td>
<td>Indicates that preparation is complete.</td>
</tr>

<tr>
<td>recoResult</td>
<td>PlayAndRecognize RC</td>
<td>FormRC</td>
<td>Results filled at the form level and not form item level.</td>
</tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e3952" id="d3e3952" />6.9.2.1.4 State Chart
Representation</h6>

<img class="center" src="Images/FormRC.png"
alt="Form RC in UML State Chart" />
<p class="caption">Figure 11: Form RC States</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Note that the chart for SelectingItem:FormItemSelection is
missing. It will be defined later.</p>
</td>
</tr>
</table>
</div>

<div class="div5">
<h6><a name="d3e3964" id="d3e3964" />6.9.2.1.5 SCXML
Representation</h6>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="children"/&gt;
    &lt;data id="activeItem"/&gt;
    &lt;data id="active"/&gt;
    &lt;data id="previousItem"/&gt;
    &lt;data id="nextItem"/&gt;
&lt;data id="recoResult"/&gt;
    &lt;data id="name"/&gt;
    &lt;data id="JustFilled"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign loc="$controller" val="null"/&gt;
        &lt;assign loc="$children" val="null"/&gt;
        &lt;assign loc="$activeItem" val="null"/&gt;
        &lt;assign loc="$active" val="false"/&gt;
        &lt;assign loc="$previousItem" val="null"/&gt;
        &lt;assign loc="$nextItem" val="null"/&gt;
        &lt;assign loc="$recoResult" val="null"/&gt;
        &lt;assign loc="$name" val="null"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="initialize" target="Initializing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Idle --&gt;

    &lt;state id="Initializing"&gt;
      &lt;datamodel&gt;
        &lt;data id="childcounter"/&gt;
      &lt;/datamodel&gt;

      &lt;onentry&gt;
        &lt;assign loc="$childcounter" val="0"/&gt;
        &lt;send target="datamodel" event="createScope" namelist="dialog"/&gt;
        &lt;foreach var="child" array="$children"&gt;
          &lt;send target="$child/controller" event="initialize" namelist="$child/child"/&gt;
        &lt;/foreach&gt;
      &lt;/onentry&gt;


      &lt;transition event="Initializing.done"&gt;
        &lt;assign loc="$childcounter" expr="$childcounter + 1"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.error"&gt;
        &lt;assign loc="$childcounter" expr="$childcounter + 1"/&gt;
        &lt;send target="controller" event="initialize.error" namelist="_eventData/error_status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.done" cond="$childcounter eq $children.size()-1" target="Ready"&gt;
        &lt;send target="controller" event="initialized"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Initializing --&gt;

    &lt;state id="Ready"&gt;
      &lt;onentry&gt;
        &lt;assign loc="$active" val="false"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="execute" target="SelectingItem:FormItemSelection"&gt;
        &lt;assign loc="$active" value="true"/&gt;
      &lt;/transition&gt;

      &lt;transition event="prepareGrammars" target="PreparingFormGrammars"/&gt;
    &lt;/state&gt;    &lt;!-- end Ready --&gt;

    &lt;state id="SelectingItem:FormItemSelection"&gt;

      &lt;onentry&gt;
        &lt;send target="FormItemSelection" event="checkStatus" namelist="$children"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="SelectedFormItem.done" cond="activeItem eq 'null'" target="Exit"/&gt;

      &lt;transition event="SelectedFormItem.done" cond="activeItem neq 'null'" target="PreparingItem"/&gt;
    &lt;/state&gt;    &lt;!-- end SelectingItem:FormItemSelection --&gt;

    &lt;state id="PreparingItem"&gt;
      &lt;onentry&gt;
        &lt;send target="activeitem" event="prepare" /&gt;
      &lt;/onentry&gt;

      &lt;transition event="prepared" cond="_eventData/modal eq 'true'" target="Executing"/&gt;

      &lt;transition event="prepared" cond="_eventData/modal eq 'false'" target="PreparingFormGrammars"/&gt;
    &lt;/state&gt;    &lt;!-- end PreparingItem--&gt;

    &lt;state id="Exit"&gt;
      &lt;onentry&gt;
        &lt;send target="datamodel" event="destroyScope" namelist="dialog"/&gt;
        &lt;send target="parent" event="done"/&gt;
      &lt;/onentry&gt;
    &lt;/state&gt;    &lt;!-- end Exit--&gt;

    &lt;state id="PreparingFormGrammars"&gt;
      &lt;transition event="PrepareFormGrammars.done" cond="active eq 'true'" target="PreparingOtherGrammars"/&gt;

      &lt;transition event="PrepareFormGrammars.done" cond="active eq 'false'" target="PreparingOtherGrammars"&gt;
        &lt;send target="controller" event="prepared"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;    &lt;!-- end PreparingFormGrammars --&gt;

    &lt;state id="PreparingOtherGrammars"&gt;
      &lt;onentry&gt;
        &lt;send target="controller" event="prepareGrammars"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="PrepareOtherGrammars.done" target="Executing"/&gt;
    &lt;/state&gt;    &lt;!-- end PreparingOtherGrammars --&gt;

    &lt;state id="Executing"&gt;
      &lt;onentry&gt;
        &lt;send target="activeItem" event="execute"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="Executing.done" target="Active"/&gt;
    &lt;/state&gt;    &lt;!-- end Executing --&gt;

    &lt;state id="Active"&gt;
      &lt;onentry&gt;
        &lt;assign loc="$JustFilled" expr="new Array()"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="fieldResult" target="Evaluating"&gt;
        &lt;insert pos="after" name="$JustFilled" val="currentitem"/&gt;
      &lt;/transition&gt;

      &lt;transition event="PlayAndRecognize:RecogResult" target="ProcessingFormResult"&gt;
        &lt;insert pos="after" name="$JustFilled" val="currentitem"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;    &lt;!-- end Active --&gt;

    &lt;state id="ProcessingFormResult"&gt;

      &lt;onentry&gt;
          &lt;foreach var="child" array="$children"&gt;
           &lt;if cond="$child.slotname eq _eventData/RecogResult/slotname"&gt;
                       &lt;assign loc="$name" value="_eventData/RecogResult/name"/&gt;
                       &lt;insert pos="after" name="$JustFilled" val="$child"/&gt;
                       &lt;transition target="Evaluating"/&gt;
           &lt;/if&gt;
        &lt;/foreach&gt;

      &lt;/onentry&gt;

      &lt;transition event="ProcessingFormResult.done" target="Evaluating"/&gt;
    &lt;/state&gt;    &lt;!-- end ProcessingFormResult --&gt;

    &lt;state id="Evaluating"&gt;
      &lt;onentry&gt;
        &lt;send target="activeItem" event="evaluate"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="Evaluating.done" target="SelectingItem:FormItemSelection"/&gt;
    &lt;/state&gt;    &lt;!-- end Executing --&gt;

  &lt;/state&gt;  &lt;!-- end Created --&gt;

&lt;/scxml&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

<div class="div2">
<h3><a name="FieldModule" id="FieldModule" />6.10 Field Module</h3>

<div class="div3">
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">There are several issues
still to be addressed in the Field module: 

<ul>
<li>In the attribute table there's a Todo about naming
conventions.</li>

<li>The definition of the RC itself needs elaboration.</li>

<li>The play and recognize RC is incomplete.</li>

<li>The data model is not completely described.</li>
</ul>
</td>
</tr>
</table>

<h4><a name="d3e3972" id="d3e3972" />6.10.1 Syntax</h4>

<a name="field:attributes" id="field:attributes" />
<table>
<caption>Table 41: Table: &lt;field&gt; Attributes</caption>

<tbody>
<tr>
<th>name</th>
<td>The form item variable in the dialog scope that will hold the
result. The name must be unique among form items in the form. If
the name is not unique, then a badfetch error is thrown when the
document is fetched. The name must conform to the variable naming
conventions in (TODO).</td>
</tr>

<tr>
<th>expr</th>
<td>The initial value of the form item variable; default is
ECMAScript undefined. If initialized to a value, then the form item
will not be visited unless the form item variable is cleared.</td>
</tr>

<tr>
<th>cond</th>
<td>An expression that must evaluate to true after conversion to
boolean in order for the form item to be visited. The form item can
also be visited if the attribute is not specified.</td>
</tr>

<tr>
<th>type</th>
<td>The type of field, i.e., the name of a builtin grammar type (<a
href="#BuiltinModule"><b>6.11 Builtin Grammar Module</b></a>). Note
that platform support for builtin grammar types is optional. If the
specified builtin type is not supported by the platform, an
error.unsupported.builtin event is thrown.</td>
</tr>

<tr>
<th>slot</th>
<td>The name of the grammar slot used to populate the variable (if
it is absent, it defaults to the variable name). This attribute is
useful in the case where the grammar format being used has a
mechanism for returning sets of slot/value pairs and the slot names
differ from the form item variable names.</td>
</tr>

<tr>
<th>modal</th>
<td>If this is false (the default) all active grammars are turned
on while collecting this field. If this is true, then only the
field's grammars are enabled: all others are temporarily
disabled.</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="d3e4024" id="d3e4024" />6.10.2 Semantics</h4>

<p>The semantics of field elements are defined using the following
resource controllers: Field (<a href="#RC:Field"><b>6.10.2.1 Field
RC</b></a>), PlayandRecognize (<a
href="#RC:PlayAndRecognize"><b>6.10.2.2 PlayandRecognize
RC</b></a>), ...</p>

<div class="div4">
<h5><a name="RC:Field" id="RC:Field" />6.10.2.1 Field RC</h5>

<p>The Field Resource Controller is the primary RC for the field
element.</p>

<div class="div5">
<h6><a name="d3e4038" id="d3e4038" />6.10.2.1.1 Definition</h6>

<p>The field RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this field RC</li>

<li>children: array of children's (primary) RC</li>

<li>includePrompts: boolean indicating whether prompts are to be
played. Default: true.</li>

<li>counter: prompt counter. Default: 1.</li>

<li>recoResult: ??</li>

<li>name:</li>

<li>expr:</li>

<li>cond:</li>

<li>modal:</li>

<li>slot:</li>
</ul>

<p></p>

<p>The field RC's state model consists of the following states:
Idle, Initializing, Ready, Preparing, Prepared, Executing and
Evaluating.</p>

<p>While in the Idle state, the RC may receive an 'initialize'
event, whose 'controller' event data is used to update the data
model. The RC then transitions into Initiating state.</p>

<p>In the Initializing state, the RC creates a variable in the
Datamodel Resource: the variable name corresponds to the name in
the RC's data model, and the variable value is set to the value of
the RC's data model expr, if this is defined. The field RC then
initializes its children: this is modeled as a separate RC (see
XXX). When all children are initialized, the RC transitions to the
Ready state.</p>

<p>In the Ready state, the field RC can receive an 'checkStatus'
event to check whether it can be executed or not. The value of name
and cond in its data model are checked: the status is true if the
name is undefined and the value of cond evaluates to true. The
status is returned in a 'checkedStatus' event sent back to the
controller RC. If the RC receives a 'prepare' event, it updates
includePrompts in its data model using the event data, and
transitions to the Preparing state.</p>

<p>In the Preparing state, the field prepares its prompts and
grammars. Prompts are prepared only if the includePrompts data is
true; otherwise, prompts within the field are not prepared (e.g.
field prompts aren't queued following a &lt;reprompt&gt;).
Preparation of prompts is modeled as a separate RC (see XXX), as is
preparation of grammars (see YYY). These RCs are summarized
below.</p>

<p>Prompts are prepared by iterating through the children array. In
the iteration, each prompt RC child is sent a 'checkStatus' event.
If the prompt child returns true (its cond parameter evaluates to
true), then it is added to a 'correct count' list together with its
count. Once the iteration is complete, the RC determines the
highest count on the 'correct count' list: the highest count among
those on the list less than or equal to the current count value.
All child on the 'correct count' list whose count is not the
highest count are removed. The RC then iterates through the
'correct count' list and sends an 'execute' event to each prompt
RC, causing it to be queued on the PromptQueue Resource.</p>

<p>Grammars are prepared by recursing through the children array
and sending each grammar RC child an 'execute' event. The grammar
RC then, if appropriate, sends an 'addGrammar' event to the DTMF or
ASR Recognizer Resource where the grammar itself, its properties
and the field RC is sent as the handler for recognition
results.</p>

<p>When prompts and grammars have been prepared, the prompt counter
is incremented and the field RC sends a 'prepared' event to its
controller with event data indicating its modal status and then
transition into the Prepared state.</p>

<p>In the Prepared state, the field RC may receive an 'execute'
event from its controller. The RC sends an 'execute' event to the
PlayAndRecognize RC (<a href="#RC:PlayAndRecognize"><b>6.10.2.2
PlayandRecognize RC</b></a>), causing any queued prompts to be
played and recognition to be initiated. In the event data, the
controller is set to this RC, and other data is derived from data
model properties. The RC transitions to the Executing state.</p>

<p>In the Executing state, the PlayAndRecognize RC must send
recoResults (or error events: noinput, nomatch, error.semantic) to
the field RC.</p>

<p>If the field RC receives the recoResults, then it updates its
name variable in the Datamodel Resource. The field RC then sends a
'fieldResult' event to its controller indicating that a field
result has been received and processed.</p>

<p>If the recoResult is received by the field RC's controller, then
the field receives an 'evaluate' event which causes it to
transition to the Evaluating state.</p>

<p>In the Evaluating state, the field RC iterates through its
children executing each filled RC: this is modeled by a separate RC
(see XXX). When evaluation is complete, the RC sends a 'evaluated'
event to its controller and transitions to the Ready state.</p>
</div>

<div class="div5">
<h6><a name="d3e4095" id="d3e4095" />6.10.2.1.2 Defined Events</h6>

<p>The Field RC is defined to receive the following events:</p>

<table>
<caption>Table 42: Events received by Field RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td /></tr>

<tr>
<td>checkStatus</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>prepare</td>
<td>controller</td>
<td>includePrompts (M)</td>
<td /></tr>

<tr>
<td>execute</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>evaluate</td>
<td>controller</td>
<td />
<td /></tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table>
<caption>Table 43: Events sent by Field RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>checkedStatus</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>prepared</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>fieldResult</td>
<td>controller</td>
<td />
<td /></tr>

<tr>
<td>evaluated</td>
<td>controller</td>
<td />
<td /></tr>
</tbody>
</table>

<p></p>
</div>

<div class="div5">
<h6><a name="d3e4202" id="d3e4202" />6.10.2.1.3 External
Events</h6>

<p>Table 44 shows the events sent and received by the field RC to
resources and other RCs which define the events.</p>

<a name="field:external-events" id="field:external-events" />
<table>
<caption>Table 44: Field RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>create</td>
<td>FieldRC</td>
<td>DataModel</td>
<td /></tr>

<tr>
<td>assign</td>
<td>FieldRC</td>
<td>DataModel</td>
<td /></tr>

<tr>
<td>execute</td>
<td>FieldRC</td>
<td>PlayandRecognizeRC</td>
<td /></tr>

<tr>
<td>recoResult</td>
<td>PlayandRecognizeRC</td>
<td>FieldRC</td>
<td /></tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e4254" id="d3e4254" />6.10.2.1.4 State Chart
Representation</h6>

<img class="center" src="Images/field.png"
alt="Field RC in UML State Chart" />
<p class="caption">Figure 12: Field RC States</p>
</div>

<div class="div5">
<h6><a name="d3e4260" id="d3e4260" />6.10.2.1.5 SCXML
Representation</h6>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="children"/&gt;
    &lt;data id="counter"/&gt;
    &lt;data id="recoResult"/&gt;
    &lt;data id="cond"/&gt;
    &lt;data id="name"/&gt;
    &lt;data id="expr"/&gt;
    &lt;data id="modal"/&gt;
    &lt;data id="includePrompts"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign location="$controller" val="null"/&gt;
        &lt;assign location="$children" expr="new Array()"/&gt;
        &lt;assign location="$counter" val="1"/&gt;
        &lt;assign location="$recoResult" val="null"/&gt;
        &lt;assign location="$cond" val="null"/&gt;
        &lt;assign location="$expr" val="null"/&gt;
        &lt;assign location="$modal" val="false"/&gt;
        &lt;assign location="$includePrompts" val="true"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="initialize" target="Initializing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end Idle --&gt;

    &lt;state id="Initializing"&gt;
      &lt;datamodel&gt;
        &lt;data id="childcounter"/&gt;
      &lt;/datamodel&gt;

      &lt;onentry&gt;
        &lt;if cond="expr neq 'null'"&gt;
          &lt;send target="datamodel" event="assign" namelist="$name, $expr"/&gt;
          &lt;else&gt;
            &lt;send target="datamodel" event="create" namelist="$name"/&gt;
          &lt;/else&gt;
        &lt;/if&gt;

        &lt;assign location="$childcounter" val="0"/&gt;
        &lt;foreach var="child" array="$children"&gt;
          &lt;send target="$child/controller" event="initialize"/&gt;
        &lt;/foreach&gt;
      &lt;/onentry&gt;


      &lt;transition event="Initializing.done"&gt;
        &lt;assign location="$childcounter" expr="$childcounter + 1"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.error"&gt;
        &lt;assign location="$childcounter" expr="$childcounter + 1"/&gt;
        &lt;send target="controller" event="initialize.error" namelist="_eventData/error_status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="Initializing.done" cond="$childcounter eq $children.size()-1" target="Ready"&gt;
        &lt;send target="controller" event="initialized"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end Initializing --&gt;

    &lt;state id="Ready"&gt;

      &lt;transition event="checkStatus" &gt;
        &lt;assign location="$status" expr="checkStatus()"/&gt;
        &lt;send target="controller" event="checkedStatus" namelist="_eventData/status"/&gt;
      &lt;/transition&gt;

      &lt;transition event="prepare" target="Preparing"&gt;
        &lt;assign location="$includePrompts" expr="_eventData/includePrompts"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Ready --&gt;

    &lt;state id="Preparing"&gt;
      &lt;onentry&gt;
        &lt;if cond="$includePrompts eq 'true'"&gt;
          &lt;send target="Prompts RC" event="initialize"/&gt;
        &lt;/if&gt;
        &lt;send target="Grammars RC" event="initialize"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="preparing.done" target="Prepared"&gt;
        &lt;send target="controller" event="prepared" namelist="modal"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end Preparing --&gt;

    &lt;state id="Prepared"&gt;
      &lt;transition event="execute" target="Executing"&gt;
        &lt;send target="PlayAndRecognize" event="execute" namlist="self, inputmodes"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Prepared--&gt;

    &lt;state id="Executing"&gt;
      &lt;datamodel&gt;
        &lt;data id="value"/&gt;
      &lt;/datamodel&gt;
      &lt;transition event="playAndReco:recoResult"&gt;
        &lt;assign location="$value" expr="processResults($name, slot, _eventdata/result)"/&gt;
        &lt;send target="datamodel" event="assign" namelist="$name, $value"/&gt;
        &lt;send target="parent" event="fieldResult"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Executing--&gt;

    &lt;state id="Evaluating"&gt;
      &lt;onentry&gt;
        &lt;send target="filled RC" event="executeFilleds"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="evaluating.done" target="Ready"&gt;
        &lt;send target="controller" event="evaluated"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Evaluating--&gt;

  &lt;/state&gt;
  &lt;!-- end Created --&gt;

&lt;/scxml&gt;
</pre>
</div>
</div>
</div>

<div class="div4">
<h5><a name="RC:PlayAndRecognize"
id="RC:PlayAndRecognize" />6.10.2.2 PlayandRecognize RC</h5>

<p>The PlayandRecognize RC coordinates media input with Recognizer
resources and media output with the PromptQueue Resource.</p>

<p>The following use cases are covered:</p>

<ol class="enumar">
<li>Bargein is not active and bargeintype is speech. Prompts are
played to completion and the user provides positive input, negative
input or no input.</li>

<li>Bargein is active and bargeintype is speech. Prompts are played
to completion and the user provides positive input, negative input
or no input.</li>

<li>Bargein is active and bargeintype is speech. User interrupts
prompts and the user provides positive input, negative input or no
input.</li>

<li>Bargein is not active and bargeintype is hotword. Prompts are
played to completion and the user provides positive input, negative
input or no input. User may provide a positive input after one or
more negative inputs. The 'nomatch' event is never generated.</li>

<li>Bargein is active and bargeintype is hotword. User interrupts
prompts and the user provides positive input, negative input or no
input. User may provide a positive input after one or more negative
inputs. The 'nomatch' event is never generated.</li>

<li>Prompt sequences alternating between bargein and no
bargein.</li>

<li>Prompt sequences alternating between speech and hotword
bargeintype.</li>
</ol>

<p></p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open issue: should we
remove the possibility for alternating speech and hotword bargein
modes within the recognition cycle?</td>
</tr>
</table>

<div class="div5">
<h6><a name="d3e4291" id="d3e4291" />6.10.2.2.1 Definition</h6>

<p>The PlayandRecognize RC coordinates media input with recognition
resources and media output with the PromptQueue Resource on behalf
of a form item.</p>

<p>This RC activates prompt queue playback, activates recognition
resources, manages bargein behavior and handles results from
recognition resources.</p>

<p>The RC is defined in terms of a data model and a state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this RC</li>

<li>bargein: Boolean indicates whether bargein is active or not.
Default: true.</li>

<li>bargeintype: indicates the type of bargein, if active. Default:
speech.</li>

<li>inputmodes: active recognition input modes. Default: voice and
dtmf.</li>

<li>inputtimeout: timeout to wait for input. Default: 0s. (Required
since the prompt queue may be empty).</li>

<li>dtmfProps: DTMF properties</li>

<li>asrProps: Speech recognition properties</li>

<li>maxnbest: maximum number of nbest results. Default: 1.</li>

<li>recoActive: boolean indicating whether recognition is active.
Default: false.</li>

<li>markname: string indicating current markname. Default:
null</li>

<li>marktime: time designator indicating current marktime. Default:
0s.</li>

<li>recoResult:</li>

<li>recoListener:</li>

<li>activeGrammars: Boolean indicating whether grammars are active.
Default: false.</li>
</ul>

<p></p>

<p>The RC model consists of the following states: idle, prepare
recognition resources, start playing, playing prompts with bargein,
playing prompts without bargein, recognizing with a timer, waiting
for input, waiting for speech result and update results. The
complexity of this model is partially a consequence of supporting
the relationship between hotword bargein and recognition result
processing.</p>

<p>While in the idle state, the RC may receive an 'execute' event,
whose event data is used to update the data model. The event
information includes: controller, inputmodes, inputtimeout,
dtmfProps, asrProps and maxnbest. The RC transition to the prepare
recognition resources state.</p>

<p>In the prepare recognition resources, the RC sends 'prepare'
events to the ASR and DTMF recognition resource. Both events
specify this RC as the controller parameter, while the properties
parameter differs. In this state, the RC can received 'prepared' or
'notPrepared' events from either recognition resources. If neither
resource returns a 'prepared' event, then activeGrammars is false
(i.e. no active DTMF or speech grammar) and the RC sends an
'error.semantic' event to the controller and exits. If at least one
resource returns a 'prepared' event, then the RC moves into the
start playing state.</p>

<p>The start playing state begins by sending the PromptQueue
resource a 'play' event. The PromptQueue responds with a 'playDone'
event if there are no prompt in the prompt queue; as a result, this
RC moves into the start recognizing with timer state. If there is
at least one prompts in the queue, the PromptQueue sends this RC a
'playStarted' event whose data contains the bargein and bargeintype
values for the first prompt, and the input timeout value for the
last prompt in the queue. The data model is updated with this
information.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open issue: PromptQueue
Resource doesn't currently have playStarted event. If we don't add
playStarted event, then is there a better way to get the bargein,
bargeintype, and timeout information from the prompts in the
PromptQueue?</td>
</tr>
</table>

<p>Interaction with the recognizer during prompt playback is
determined by the data model's bargein value. If bargein is true,
then this RC transitions to the playing with bargein state. If
bargein is false, the RC transitions to the playing without bargein
state.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Open Issue: The event
"bargeinChange" as a one way notification could pose a problem, as
it takes finite time for recognizer to suspend or resume. This
might work better if PromptQueue Resource waited for an event
"bargeinChangeAck" (or similar) from PlayandRecognize RC before
starting the next play. PlayandRecognize RC will send the event
"bargeinChangeAck" after it completed suspend or resume action on
the recognizer.</td>
</tr>
</table>

<p>In the playing without bargein state, recognition is suspended
if it has been previously activated (recoActive parameter of the
data model tracks this). Suspending recognition is conditional on
the value of 'inputmodes' data parameter; if 'dtmf' is in
inputmodes, then DTMF recognition is suspended; if 'voice' is in
inputmodes, the ASR recognition is suspended. In this state, the
PromptQueue can report to this RC changes in bargein and
bargeintype as prompts are played: a 'bargeintypeChange' event with
the values 'hotword' or 'speech' cause the data model parameter
'bargein' to the set to 'true' and the 'bargeintype' parameter to
be updated with event data value. If the PromptQueue resource sends
a 'playDone' event, then the data model markname and marktime
parameters are updated and the RC transitions to the start
recognizing with timer state.</p>

<p>In the playing with bargein state, recognition is activated if
it has not been previously activated (determined by recoActive
parameter in the data model). Activating recognition is conditional
on the value of 'inputmodes' data parameter; if 'dtmf' is in
inputmodes, then DTMF recognition is activated; if 'voice' is in
inputmodes, then ASR recognition is activated. In this state, the
PromptQueue can report changes in bargein and bargeintype as
prompts are played: a 'bargeintypeChange' event where the event
data value is not 'unbargeable' causes the data model 'bargeintype'
parameter to be updated with the event data ('hotword' or
'speech'); while a 'bargeintypeChange' where the event data value
is 'unbargeable' causes the data model 'bargein' parameter to set
to false and the RC transitions to the playing without bargein
state. If the PromptQueue resources sends a 'playDone' event, then
the data model markname and marktime parameters are updated and the
RC transitions to the start recognizing with timer state.</p>

<p>Recognition handling in this state depends upon the bargeintype
data parameter. If the bargeintype is 'speech' and a recognizer
sends a 'inputStarted' event, then the RC transition to the waiting
for speech result state. If the bargeintype is 'hotword', then
recognition results are processed within this state. In particular,
if a recognition resource sends a 'recoResults' event, then its
event data is processed to determine if the recognition result is
positive or negative.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">Further details on
recognition processing to be added in later versions. recoResults
data parameter is updated with the recognition results (truncated
to maxnbest). A speech result is positive iff there is at least one
result whose confidence level is equal to or greater than the
recognition confidence level; otherwise the result is negative.
DTMF results are always positive. The recoListener data parameter
is defined as the listener associated with the best result if the
result is positive.</td>
</tr>
</table>

<p>If positive, the RC sends the PromptQueue a 'halt' event, and
transitions to the update results state. If negative, the RC sends
a 'listen' event to the recognition resource which sent the
'recoResults' event.</p>

<p>In the start recognizing with timer state, an input timer is
activated for the value of the inputtimeout data parameter and, if
the recognition is not already active (determined by the recoActive
data parameter). Recognition activation is conditional on the value
of 'inputmodes' data parameter; if 'dtmf' is in inputmodes, then
DTMF recognition is activated; if 'voice' is in inputmodes, the ASR
recognition is activated. The RC then transitions into the waiting
for input state.</p>

<p>In the waiting for input state, the RC waits for user input. If
it receives a 'timerExpired' event, then the RC sends a 'stop'
event to all recognition resources, sends a 'noinput' event to its
controller and exits. Recognition handling in this state depends
upon the bargeintype data parameter. If the bargeintype is 'speech'
and a recognizer sends a 'inputStarted' event, then the RC
transition to the waiting for speech result state. If the
bargeintype is 'hotword', then recognition results are processed
within this state. In particular, if a recognition resource sends a
'recoResults' event, then its event data is processed to determine
if the recognition result is positive or negative. If positive, the
RC cancels the timer, and transitions to the update results state.
If negative, the RC sends a 'listen' event to the recognition
resource which sent the 'recoResults' event.</p>

<p>In the waiting for speech result state, the RC waits for a
'recoResult' event whose data is used to update the recoResult data
parameter and to set the recoListener data parameter if the
recognition result is positive. The RC then transitions to the
update results state.</p>

<p>In the update results state, the RC sends 'assign' events to the
data model resource, so that the lastresult object in application
scope is updated with recognition results as well as markname and
marktime information. If the recoListener data parameter is
defined, then the RC sends a 'recoResult' event to the recognition
listener RC; otherwise, it sends 'nomatch' event to its controller.
The RC then exits.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Open issue: Behavior if one reco resource sends 'inputStarted'
but other sends 'recoResults'? Race conditions between recognizers
returning results? (This problem is inherent to the presence of two
recognizers. For the sake of clear semantics, we could restrict
only one recognizer to respond with 'inputStarted' and
'recoResults'. The other recognizer is always 'stopped'. But a
better choice might be to have only one recognizer that handles
both DTMF and speech, since semantically both recognizers are very
similar.)</p>
</td>
</tr>
</table>
</div>

<div class="div5">
<h6><a name="d3e4373" id="d3e4373" />6.10.2.2.2 Defined Events</h6>

<p>The PlayandRecognize RC is defined to receive the following
events:</p>

<a name="playandrecognize:incoming"
id="playandrecognize:incoming" />
<table>
<caption>Table 45: Events received by PlayandRecognize RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>execute</td>
<td>any</td>
<td>controller(M), inputmodes (O), inputtimeout (O), dtmfProps (M),
recoProps (M), maxnbest (O)</td>
<td /></tr>
</tbody>
</table>

<p>and the events it sends:</p>

<a name="playandrecognize:outbound"
id="playandrecognize:outbound" />
<table>
<caption>Table 46: Events sent by PlayandRecognize RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Sequencing</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>recoResult</td>
<td>any</td>
<td>results (M)</td>
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>nomatch</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>noinput</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.semantic</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.badfetch.grammar</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.noresource</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.unsupported.builtin</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.unsupported.format</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>

<tr>
<td>error.unsupported.language</td>
<td>controller</td>
<td />
<td>one-of: nomatch, noinput, error.*, recoResult</td>
<td /></tr>
</tbody>
</table>

<p></p>
</div>

<div class="div5">
<h6><a name="d3e4500" id="d3e4500" />6.10.2.2.3 External
Events</h6>

<p>The events in Table 47 are sent by the PlayandRecognize RC to
resources which define the events.</p>

<a name="playandrecognize:ext-outbound"
id="playandrecognize:ext-outbound" />
<table>
<caption>Table 47: External Events sent by PlayandRecognize
RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>play</td>
<td>PromptQueue</td>
<td />
<td /></tr>

<tr>
<td>halt</td>
<td>PromptQueue</td>
<td />
<td /></tr>

<tr>
<td>prepare</td>
<td>Recognizer</td>
<td />
<td /></tr>

<tr>
<td>listen</td>
<td>Recognizer</td>
<td />
<td /></tr>

<tr>
<td>suspend</td>
<td>Recognizer</td>
<td />
<td /></tr>

<tr>
<td>stop</td>
<td>Recognizer</td>
<td />
<td /></tr>
</tbody>
</table>

<p>The events in Table 48 are received by this RC. Their definition
is provided by the sending component.</p>

<a name="playandrecognize:ext-incoming"
id="playandrecognize:ext-incoming" />
<table>
<caption>Table 48: External Events received by PlayandRecognize
RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Sequencing</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>playStarted</td>
<td>PromptQueue</td>
<td>bargein (O), bargeintype (O), inputtimeout (O)</td>
<td>pq:play notification</td>
<td /></tr>

<tr>
<td>playDone</td>
<td>PromptQueue</td>
<td>markname (O), marktime (O)</td>
<td>pq:play response</td>
<td /></tr>

<tr>
<td>bargeinChange</td>
<td>PromptQueue</td>
<td>bargein (M)</td>
<td />
<td /></tr>

<tr>
<td>bargeintypeChange</td>
<td>PromptQueue</td>
<td>bargeintype (M)</td>
<td />
<td /></tr>

<tr>
<td>prepared</td>
<td>Recognizer</td>
<td />
<td>prepare positive response</td>
<td /></tr>

<tr>
<td>notPrepared</td>
<td>Recognizer</td>
<td />
<td>prepare negative response</td>
<td /></tr>

<tr>
<td>inputStarted</td>
<td>Recognizer</td>
<td />
<td />
<td /></tr>

<tr>
<td>recoResult</td>
<td>Recognizer</td>
<td>results (M), listener (O)</td>
<td />
<td /></tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e4656" id="d3e4656" />6.10.2.2.4 State Chart
Representation</h6>

<p>The main states for the PlayandRecognize RC are shown in Figure
13.</p>

<img class="center" src="Images/PlayAndRecognizeRC.png"
alt="Play and Recognize RC States" />
<p class="caption">Figure 13: PlayandRecognize RC States</p>
</div>

<div class="div5">
<h6><a name="d3e4666" id="d3e4666" />6.10.2.2.5 SCXML
Representation</h6>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="bargein"/&gt;
    &lt;data id="bargeintype"/&gt;
    &lt;data id="inputmodes"/&gt;
    &lt;data id="inputtimeout"/&gt;
    &lt;data id="dtmfProps"/&gt;
    &lt;data id="asrProps"/&gt;
    &lt;data id="maxnbest"/&gt;
    &lt;data id="recoActive"/&gt;
    &lt;data id="markname"/&gt;
    &lt;data id="marktime"/&gt;
    &lt;data id="recoResult"/&gt;
    &lt;data id="recoListener"/&gt;
    &lt;data id="activeGrammars"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;

    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign location="$controller" val="null"/&gt;
        &lt;assign location="$bargein" expr="true"/&gt;
        &lt;assign location="$bargeintype" val="speech"/&gt;
        &lt;assign location="$inputmodes" val="voice"/&gt;
        &lt;assign location="$inputtimeout" val="0s"/&gt;
        &lt;assign location="$dtmfProps" val="null"/&gt;
        &lt;assign location="$asrProps" val="null"/&gt;
        &lt;assign location="$maxbest" val="1"/&gt;
        &lt;assign location="$recoActive" val="false"/&gt;
        &lt;assign location="$markname" val="null"/&gt;
        &lt;assign location="$marktime" val="0"/&gt;
        &lt;assign location="$recoResult" val="null"/&gt;
        &lt;assign location="$recoListener" val="null"/&gt;
        &lt;assign location="$activeGrammars" val="false"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="execute" target="PrepareRecognitionResources"&gt;
        &lt;assign name="/datamodel/data/[@name='controller']" expr="_eventData/controller"/&gt;
        &lt;assign name="/datamodel/data/[@name='inputmodes']" expr="_eventData/modes"/&gt;
        &lt;assign name="/datamodel/data/[@name='inputtimeout']" expr="_eventData/timeout"/&gt;
        &lt;assign name="/datamodel/data/[@name='dtmfProps']" expr="_eventData/dtmfProps"/&gt;
        &lt;assign name="/datamodel/data/[@name='asrProps']" expr="_eventData/asrProps"/&gt;
        &lt;assign name="/datamodel/data/[@name='maxnbest']" expr="_eventData/maxnbest"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end Idle --&gt;

    &lt;state id="PrepareRecognitionResources"&gt;

      &lt;transition target="StartPlaying" cond="$activeGrammars eq 'true'"/&gt;

      &lt;transition target="Exit" cond="$activeGrammars eq 'false'"&gt;
        &lt;send target="controller" event="error.semantic"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end PrepareRecognitionResources --&gt;

    &lt;state id="StartPlaying"&gt;
      &lt;onentry&gt;
        &lt;send target="PromptQueue" event="pq:play"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="pq:playStarted" cond="$bargein eq 'true'" target="PlayingWithBargein"&gt;
        &lt;assign location="$bargein" expr="_eventdata/bargein"/&gt;
      &lt;/transition&gt;

      &lt;transition event="pq:playStarted" cond="$bargein eq 'false'" target="PlayingWithoutBargein"&gt;
        &lt;assign location="$bargein" expr="_eventdata/bargein"/&gt;
      &lt;/transition&gt;

      &lt;transition event="pq:playDone" target="StartRecognizingWithTimer"/&gt;
    &lt;/state&gt;
    &lt;!-- end StartPlaying --&gt;

    &lt;state id="PlayingWithoutBargein"&gt;
      &lt;onentry&gt;
        &lt;if cond="$recoActive eq 'true'"&gt;
          &lt;if cond="in('dtmf',$inputmodes) "&gt;
            &lt;send target="DTMFRecognizer" event="rec:suspend"/&gt;
          &lt;/if&gt;
          &lt;if cond="in('voice',$inputmodes) "&gt;
            &lt;send target="DTMFRecognizer" event="rec:suspend"/&gt;
          &lt;/if&gt;
        &lt;/if&gt;

      &lt;/onentry&gt;

      &lt;transition event="bargeintypeChange" cond="_eventdata/value neq 'unbargeable'" target="PlayWithBargein"&gt;
        &lt;assign location="$bargein" val="true"/&gt;
        &lt;assign location="$bargeintype" expr="_eventdata/value"/&gt;
      &lt;/transition&gt;

      &lt;transition event="pq:playDone" target="StartRecognizingWithTimer"&gt;
        &lt;assign location="$markname" expr="_eventdata/markname"/&gt;
        &lt;assign location="$marktime" expr="_eventdata/marktime"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end PlayingWithoutBargein --&gt;

    &lt;state id="PlayingWithBargein"&gt;
      &lt;datamodel&gt;
        &lt;data id="negorpos"/&gt;
      &lt;/datamodel&gt;
      &lt;onentry&gt;
        &lt;if cond="in('dtmf',$inputmodes) "&gt;
          &lt;send target="DTMFRecognizer" event="rec:listen"/&gt;
        &lt;/if&gt;
        &lt;if cond="in('voice',$inputmodes)"&gt;
          &lt;send target="DTMFRecognizer" event="rec:listen"/&gt;
        &lt;/if&gt;
        &lt;assign location="$recoActive" val="true"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="bargeintypeChange" cond="_eventdata/value neq 'unbargeable'"&gt;
        &lt;assign location="$bargeintype" expr="_eventdata/value"/&gt;
      &lt;/transition&gt;

      &lt;transition event="rec:recoResult"&gt;
        &lt;assign location="$negorpos" expr="processRecoResult()"/&gt;
        &lt;send target="parent" event="negorpos"/&gt;
      &lt;/transition&gt;

      &lt;transition event="negativeRecoResult"&gt;
        &lt;send target="rec_source" event="listen"/&gt;
      &lt;/transition&gt;

      &lt;transition event="pq:playDone" target="StartRecognizingWithTimer"&gt;
        &lt;assign location="$markname" expr="_eventdata/markname"/&gt;
        &lt;assign location="$marktime" expr="_eventdata/marktime"/&gt;
      &lt;/transition&gt;

      &lt;transition event="positiveRecoResult"&gt;
        &lt;send target="PromptQueue" event="pq:halt"/&gt;
      &lt;/transition&gt;

      &lt;transition event="rec:inputStarted" cond="$bargeintype eq 'speech'"&gt;
        &lt;send target="PromptQueue" event="pq:halt"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end PlayingWithBargein --&gt;

    &lt;state id="StartRecognizingWithTimer"&gt;
      &lt;onentry&gt;
        &lt;send target="Timer" event="start" namelist="$inputtimeout"/&gt;
        &lt;if cond="$recoActive eq 'false'"&gt;
          &lt;if cond="in('dtmf',$inputmodes) "&gt;
            &lt;send target="DTMFRecognizer" event="rec:listen"/&gt;
          &lt;/if&gt;
          &lt;if cond="in('voice',$inputmodes)"&gt;
            &lt;send target="DTMFRecognizer" event="rec:listen"/&gt;
          &lt;/if&gt;
          &lt;assign location="$recoActive" val="true"/&gt;
        &lt;/if&gt;
      &lt;/onentry&gt;
      &lt;transition event="execute" target="Executing"&gt;
        &lt;send target="PlayAndRecognize" event="execute" namlist="self, inputmodes"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end StartRecognizingWithTimer--&gt;

    &lt;state id="WaitingForInput"&gt;
      &lt;datamodel&gt;
        &lt;data id="negorpos"/&gt;
      &lt;/datamodel&gt;

      &lt;transition event="rec:recoResult"&gt;
        &lt;assign location="$negorpos" expr="processResults()"/&gt;
        &lt;send target="parent" event="negorpos"/&gt;
      &lt;/transition&gt;

      &lt;transition event="negativeRecoResult"&gt;
        &lt;send target="rec_source" event="listen"/&gt;
      &lt;/transition&gt;

      &lt;transition event="timerExpired"&gt;
        &lt;send target="Recognizer" event="rec:stop"/&gt;
        &lt;send target="controller" event="noinput"/&gt;
      &lt;/transition&gt;

      &lt;transition event="rec:inputStarted" cond="$bargeintype eq 'speech'" target="WaitingForSpeechResult"&gt;
        &lt;send target="Timer" event="cancel"/&gt;
      &lt;/transition&gt;

    &lt;/state&gt;
    &lt;!-- end WaitingForInput--&gt;

    &lt;state id="WaitingForSpeechResult"&gt;
      &lt;datamodel&gt;
        &lt;data id="negorpos"/&gt;
      &lt;/datamodel&gt;

      &lt;!--TBD: the original diagram seems put the event at the wrong place--&gt;
      &lt;transition event="rec:recoResult" target="UpdateResults"&gt;
        &lt;assign location="$negorpos" expr="processResults()"/&gt;
        &lt;send target="parent" event="negorpos"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end WaitingForSpeechResult--&gt;

    &lt;state id="UpdateResults"&gt;
      &lt;onentry&gt;
        &lt;send target="datamodel" namelist="application, lastresult$, recoResults"/&gt;
        &lt;if cond="$negorpos neq 'null'"&gt;
          &lt;send target="recoListener" event="recoResult" namelist="recoResults"/&gt;
          &lt;else/&gt;
          &lt;send target="controller" event="nomatch"/&gt;
        &lt;/if&gt;
      &lt;/onentry&gt;

      &lt;transition target="Exit"/&gt;
    &lt;/state&gt;
    &lt;!-- end UpdateResults--&gt;
  &lt;/state&gt;
  &lt;!-- end Created --&gt;

&lt;/scxml&gt;

</pre>
</div>
</div>
</div>
</div>
</div>

<div class="div2">
<h3><a name="BuiltinModule" id="BuiltinModule" />6.11 Builtin
Grammar Module</h3>

<div class="div3">
<h4><a name="d3e4674" id="d3e4674" />6.11.1 Usage of Platform
Grammars</h4>

<p>VoiceXML developers are commonly required to sketch out an
application for the purpose of a demo or other proof of concept. In
such cases, it is convenient to use placeholder grammars for
frequent dialogs like collecting a date, asking a yes/no question,
etc. Builtin grammars (provided by the platform) are designed to
serve this purpose.</p>

<p>Once the prototyping phase is complete, however, it is good
practice to replace the builtin grammar references with developer
written grammars. There are several reasons behind this
suggestion:</p>

<ul>
<li>There is little consistency of the builtin implementations
across platforms. Relying on builtins complicates portability.</li>

<li>Application developers typically have no control over the
coverage in the builtin grammar. This means that any modification
to the accepted phrase(s) would require a completely new grammar.
Discovering a limitation like this post-deployment could be
disruptive.</li>

<li>Similar to the above, builtins are limited in their ability to
handle underspecified spoken input. For instance, "20 peso" cannot
be resolved to a specific [ISO4217] currency code because the
"peso" is the name of the currency of numerous nations. In such
cases the platform may return a specific currency code according to
the language or may omit the currency code. Edge cases like this
are not likely to be handled by platform builtins.</li>
</ul>
</div>

<div class="div3">
<h4><a name="d3e4688" id="d3e4688" />6.11.2 Platform
Requirements</h4>

Support for builtin grammars is not required for conformance. But
if a platform does support builtin types, then it MUST follow the
description given in this module as closely as possible. This
includes: 

<ul>
<li>Supporting all builtin types for a given language. In other
words, if a platform supports one builtin in a language, then it
ought to support the others as well.</li>

<li>Following the type descriptions listed in the "Syntax and
Semantics" section below. This requirement is primarily designed to
ensure at least some amount of consistency on how the NL from the
grammar is accessed.</li>

<li>Supporting both voice and DTMF modes for each type.</li>

<li>Supporting the corresponding &lt;say-as&gt; class for the
grammar type.</li>
</ul>
</div>

<div class="div3">
<h4><a name="d3e4701" id="d3e4701" />6.11.3 Syntax and
Semantics</h4>

<p>Builtin grammars may be specified in one of two ways:</p>

<ul>
<li>Through the "type" attribute on the &lt;field&gt; tag (see
Table 41). For example &lt;field type="boolean"&gt;. Note that when
a builtin is specified in this way, it is in addition to any
&lt;grammar&gt; under the &lt;field&gt;</li>

<li>Using the "builtin" protocol for the grammar URI. For example:
&lt;grammar src="builtin:boolean"/&gt;</li>
</ul>

<p></p>

<p>Each builtin type has a convention for the format of the value
returned. These are independent of language and of the
implementation. The return type for builtin fields is a string
except for the boolean field type. To access the actual recognition
result, the author can reference the &lt;field&gt; shadow variable
"name$.utterance". Alternatively, the developer can access
application.lastresult$, where
application.lastresult$.interpretation has the same string value as
application.lastresult$.utterance.</p>

<p />
<table>
<caption>Table 49: Builtin Grammar Types</caption>

<thead>
<tr>
<td>Type</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>boolean</td>
<td>Inputs include affirmative and negative phrases appropriate to
the current language. DTMF 1 is affirmative and 2 is negative. The
result is ECMAScript true for affirmative or false for negative.
The value will be submitted as the string "true" or the string
"false". If the field value is subsequently used in &lt;say-as&gt;
with the interpret-as value "vxml:boolean", it will be spoken as an
affirmative or negative phrase appropriate to the current
language.</td>
</tr>

<tr>
<td>date</td>
<td>Valid spoken inputs include phrases that specify a date,
including a month day and year. DTMF inputs are: four digits for
the year, followed by two digits for the month, and two digits for
the day. The result is a fixed-length date string with format
yyyymmdd, e.g. "20000704". If the year is not specified, yyyy is
returned as "????"; if the month is not specified mm is returned as
"??"; and if the day is not specified dd is returned as "??". If
the value is subsequently used in &lt;say-as&gt; with the
interpret-as value "vxml:date", it will be spoken as date phrase
appropriate to the current language.</td>
</tr>

<tr>
<td>digits</td>
<td>Valid spoken or DTMF inputs include one or more digits, 0
through 9. The result is a string of digits. If the result is
subsequently used in &lt;say-as&gt; with the interpret-as value
"vxml:digits", it will be spoken as a sequence of digits
appropriate to the current language. A user can say for example
"two one two seven", but not "twenty one hundred and twenty-seven".
A platform may support constructs such as "two double-five
eight".</td>
</tr>

<tr>
<td>currency</td>
<td>Valid spoken inputs include phrases that specify a currency
amount. For DTMF input, the "*" key will act as the decimal point.
The result is a string with the format UUUmm.nn, where UUU is the
three character currency indicator according to ISO standard 4217
[ISO4217], or mm.nn if the currency is not spoken by the user or if
the currency cannot be reliably determined (e.g. "dollar" and
"peso" are ambiguous). If the field is subsequently used in
&lt;say-as&gt; with the interpret-as value "vxml:currency", it will
be spoken as a currency amount appropriate to the current
language.</td>
</tr>

<tr>
<td>number</td>
<td>Valid spoken inputs include phrases that specify numbers, such
as "one hundred twenty-three", or "five point three". Valid DTMF
input includes positive numbers entered using digits and "*" to
represent a decimal point. The result is a string of digits from 0
to 9 and may optionally include a decimal point (".") and/or a plus
or minus sign. ECMAScript automatically converts result strings to
numerical values when used in numerical expressions. The result
must not use a leading zero (which would cause ECMAScript to
interpret as an octal number). If the field is subsequently used in
&lt;say-as&gt; with the interpret-as value "vxml:number", it will
be spoken as a number appropriate to the current language.</td>
</tr>

<tr>
<td>phone</td>
<td>Valid spoken inputs include phrases that specify a phone
number. DTMF asterisk "*" represents "x". The result is a string
containing a telephone number consisting of a string of digits and
optionally containing the character "x" to indicate a phone number
with an extension. For North America, a result could be
"8005551234x789". If the field is subsequently used in
&lt;say-as&gt; with the interpret-as value "vxml:phone", it will be
spoken as a phone number appropriate to the current language.</td>
</tr>

<tr>
<td>time</td>
<td>Valid spoken inputs include phrases that specify a time,
including hours and minutes. The result is a five character string
in the format hhmmx, where x is one of "a" for AM, "p" for PM, "h"
to indicate a time specified using 24 hour clock, or "?" to
indicate an ambiguous time. Input can be via DTMF. Because there is
no DTMF convention for specifying AM/PM, in the case of DTMF input,
the result will always end with "h" or "?". If the field is
subsequently used in &lt;say-as&gt; with the interpret-as value
"vxml:time", it will be spoken as a time appropriate to the current
language.</td>
</tr>
</tbody>
</table>

<p />
<p>Both the "boolean" and "digits" types can be parameterized as
follows:</p>

<table>
<caption>Table 50: Digit and Boolean Grammar
Parameterization</caption>

<tbody>
<tr>
<td>digits?minlength=n</td>
<td>A string of at least n digits. Applicable to speech and DTMF
grammars. If minlength conflicts with either the length or
maxlength attributes then a error.badfetch event is thrown.</td>
</tr>

<tr>
<td>digits?maxlength=n</td>
<td>A string of at most n digits. Applicable to speech and DTMF
grammars. If maxlength conflicts with either the length or
minlength attributes then a error.badfetch event is thrown.</td>
</tr>

<tr>
<td>digits?length=n</td>
<td>A string of exactly n digits. Applicable to speech and DTMF
grammars. If length conflicts with either the minlength or
maxlength attributes then a error.badfetch event is thrown.</td>
</tr>

<tr>
<td>boolean?y=d</td>
<td>A grammar that treats the keypress d as an affirmative answer.
Applicable only to the DTMF grammar.</td>
</tr>

<tr>
<td>boolean?n=d</td>
<td>A grammar that treats the keypress d as a negative answer.
Applicable only to the DTMF grammar.</td>
</tr>
</tbody>
</table>

<p>Note that more than one parameter may be specified separated by
the ";" character. This is illustrated in the last example
below.</p>
</div>

<div class="div3">
<h4><a name="d3e4794" id="d3e4794" />6.11.4 Examples</h4>

<p>A &lt;field&gt; element with a builtin grammar type. In this
example, the boolean type indicates that inputs are various forms
of true and false. The value actually put into the field is either
true or false. The field would be read out using the appropriate
affirmative or negative response in prompts.</p>

<div class="exampleInner">
<pre>
            &lt;field name="lo_fat_meal" type="boolean"&gt;
                
                &lt;prompt&gt;
                    Do you want a low fat meal on this flight?
                &lt;/prompt&gt;
                &lt;help&gt;
                    Low fat means less than 10 grams of fat, and under
                    250 calories.
                &lt;/help&gt;
                &lt;filled&gt;
                    &lt;prompt&gt;
                        I heard &lt;emphasis&gt;&lt;say-as interpret-as="vxml:boolean"&gt;
                            &lt;value expr="lo_fat_meal"/&gt;&lt;/say-as&gt;&lt;/emphasis&gt;.
                    &lt;/prompt&gt;
                &lt;/filled&gt;
            &lt;/field&gt;            
           
</pre>
</div>

<p></p>

<p>In the next example, digits indicates that input will be spoken
or keyed digits. The result is stored as a string, and rendered as
digits using the &lt;say-as&gt; with "vxml:digits" as the value for
the interpret-as attribute, i.e., "one-two-three", not "one hundred
twenty-three". The &lt;filled&gt; action tests the field to see if
it has 12 digits. If not, the user hears the error message.</p>

<div class="exampleInner">
<pre>
                &lt;field name="ticket_num" type="digits"&gt;
                    &lt;prompt&gt;
                        Read the 12 digit number from your ticket.
                    &lt;/prompt&gt;
                    &lt;help&gt;The 12 digit number is to the lower left.&lt;/help&gt;
                    &lt;filled&gt;
                        &lt;if cond="ticket_num.length != 12"&gt;
                            &lt;prompt&gt;
                                Sorry, I didn't hear exactly 12 digits.
                            &lt;/prompt&gt;
                            &lt;assign name="ticket_num" expr="undefined"/&gt;
                            &lt;else/&gt;
                            &lt;prompt&gt;I heard &lt;say-as interpret-as="vxml:digits"&gt; 
                                &lt;value expr="ticket_num"/&gt;&lt;/say-as&gt;
                            &lt;/prompt&gt;
                        &lt;/if&gt;
                    &lt;/filled&gt;
                &lt;/field&gt;            
           
</pre>
</div>

<p></p>

<p>The builtin boolean grammar and builtin digits grammar can be
parameterized. This is done by explicitly referring to builtin
grammars using a platform-specific builtin URI scheme and using a
URI-style query syntax of the form type?param=value in the src
attribute of a &lt;grammar&gt; element, or in the type attribute of
a &lt;field&gt;. In this example, the &lt;grammar&gt; parameterizes
the builtin DTMF grammar, the first &lt;field&gt; parameterizes the
builtin DTMF grammar (the speech grammar will be activated as
normal) and the second &lt;field&gt; parameterizes both builtin
DTMF and speech grammars. Parameters which are undefined for a
given grammar type will be ignored; for example,
"builtin:grammar/boolean?y=7".</p>

<div class="exampleInner">
<pre>
            &lt;grammar src="builtin:dtmf/boolean?y=7;n=9"/&gt;
            
            &lt;field type="boolean?y=7;n=9"&gt;
                &lt;prompt&gt;
                    If this is correct say yes or press seven, if not, say no or press nine.
                &lt;/prompt&gt;
            &lt;/field&gt;
            
            &lt;field type="digits?minlength=3;maxlength=5"&gt;
                &lt;prompt&gt;Please enter your passcode&lt;/prompt&gt;
            &lt;/field&gt;            
       
</pre>
</div>

<p></p>
</div>
</div>

<div class="div2">
<h3><a name="DAMModule" id="DAMModule" />6.12 Data Access and
Manipulation Module</h3>

<div class="div3">
<h4><a name="d1e73" id="d1e73" />6.12.1 Overview</h4>

<p>Information in the Data layer must be easily accessible and
easily editable throughout the VoiceXML 3.0 document. The Data
Access and Manipulation Module describes the necessary mechanics by
which application developers can express such interactions with the
Data layer. Implementers must augment the data access and
manipulation languages supported to provide the capabilities
described in this section.</p>

<p>The remainder of this Section covers the semantics of the Data
Access and Manipulation Module in Section 2.2 and the corresponding
syntax in Section 2.3. Backward compatibility with VoiceXML 2.1 is
discussed in Section 2.4.</p>
</div>

<div class="div3">
<h4><a name="d1e82" id="d1e82" />6.12.2 Semantics</h4>

<p>The semantics of Data Access and Manipulation can be described
in terms of the various scopes in VoiceXML 3.0, the relevance to
platform properties, the corresponding implicit variables that
platforms must support, the variable resolution mechanism, standard
session and application variables and the set of legal data values
and expressions.</p>

<div class="div4">
<h5><a name="d1e88" id="d1e88" />6.12.2.1 The scope stack</h5>

<p>Access to data is controlled by means of scopes, which are
conceptually stored in a stack. Data is always accessed within a
particular scope, which may be specified by name but defaults to
being the top scope in the stack. At initialization time, a single
scope named "session" is created. Thereafter scopes are explicitly
created and destroyed by the data model resource's clients as
necessary. Likewise, during the lifetime of each scope, data is
added, read, updated and deleted by the data model resource's
clients as necessary.</p>

<p><em>Implementation note: The API is defined in <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>At any given point in time, based on the VoiceXML document
structure and the execution state, the stack may contain the
following scopes whose semantics are described in VoiceXML 3.0 as
follows (bottom to top):</p>

<a name="variable_scope" id="variable_scope" />
<table>
<caption>Table 51: Variable Scopes</caption>

<tbody>
<tr>
<th>session</th>
<td>These are read-only variables that pertain to an entire user
session. They are declared and set by the interpreter context. New
session variables cannot be declared by VoiceXML documents.</td>
</tr>

<tr>
<th>application</th>
<td>These are declared with &lt;var&gt; and &lt;script&gt; elements
that are children of the application root document's &lt;vxml&gt;
element. They are initialized when the application root document is
loaded. They exist while the application root document is loaded,
and are visible to the root document and any other loaded
application leaf document. Note that while executing inside the
application root document document.x is equivalent to
application.x.</td>
</tr>

<tr>
<th>document</th>
<td>These variables are declared with &lt;var&gt; and
&lt;script&gt; elements that are children of the document's
&lt;vxml&gt; element. They are initialized when the document is
loaded. They exist while the document is loaded. They are visible
only within that document, unless the document is an application
root, in which case the variables are visible by leaf documents
through the application scope only.</td>
</tr>

<tr>
<th>dialog</th>
<td>Each dialog (&lt;form&gt; or &lt;menu&gt;) has a dialog scope
that exists while the user is visiting that dialog, and which is
visible to the elements of that dialog. Dialog scope contains the
following variables: variables declared by &lt;var&gt; and
&lt;script&gt; child elements of &lt;form&gt;, form item variables,
and form item shadow variables. The child &lt;var&gt; and
&lt;script&gt; elements of &lt;form&gt; are initialized when the
form is first visited, as opposed to &lt;var&gt; elements inside
executable content which are initialized when the executable
content is executed.</td>
</tr>

<tr>
<th><em>(anonymous)</em> </th>
<td>Each &lt;block&gt;, &lt;filled&gt;, and &lt;catch&gt; element
defines a new anonymous scope to contain variables declared in that
element.</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d1e162" id="d1e162" />6.12.2.2 Relevance of scope
stack to properties</h5>

<p>Properties are discussed in detail in <a
href="#Properties"><b>8.2 Properties</b></a>. Properties may be
defined for the whole application, for the whole document at the
&lt;vxml&gt; level, for a particular dialog at the &lt;form&gt; or
&lt;menu&gt; level, or for a particular form item. Thus, access to
properties is also controlled by means of the same scope stack that
is used by named variables.</p>

<p>VoiceXML 3.0 provides a consistent mechanism to unambiguously
read these properties in any scope using the data access and
manipulation language in a manner similar to accessing and
manipulating named variables. This is described in the two sections
below.</p>
</div>

<div class="div4">
<h5><a name="d1e174" id="d1e174" />6.12.2.3 Implicit variables</h5>

<p>VoiceXML 3.0 provides several implicit variables in the data
access and manipulation language to unambiguously identify the
various scopes in the scope stack. Whenever the corresponding
scopes are available, they can be referenced under specific names,
which are always the same regardless of the location in the
VoiceXML document. Additionally, an implicit variable "properties$"
is available in each scope which points to the defined properties
for that scope.</p>

<a name="implicit_variables" id="implicit_variables" />
<table>
<caption>Table 52: Implicit Variables</caption>

<tbody>
<tr>
<th>session</th>
<td>This implicit variable refers to the session scope.</td>
</tr>

<tr>
<th>application</th>
<td>This implicit variable refers to the application scope.</td>
</tr>

<tr>
<th>document</th>
<td>This implicit variable refers to the document scope.</td>
</tr>

<tr>
<th>dialog</th>
<td>This implicit variable refers to the dialog scope.</td>
</tr>

<tr>
<th>properties$</th>
<td>This read-only implicit variable refers to the defined
properties which affect platform behavior in a given scope. The
value is an ECMAScript object with multiple ECMAScript properties
as necessary where each ECMAScript property has the name of an
existing platform property in that scope and value corresponding to
the value of the platform property.</td>
</tr>
</tbody>
</table>

<p>Note that in some data access expression languages (such as
XPath), it may be necessary to expose the semantics of implicit
variables as expression language functions instead of
variables.</p>

<p>Also note that there is no implicit variable corresponding to
the anonymous scope since it is not necessary given the variable
resolution mechanism described in the next section. Where scope
qualifiers are functions, a function to identify the anonymous
scope may be necessary.</p>

<p>Finally, the use of the "properties$" implicit variable in
VoiceXML 3.0 means that the variable "properties$" is now reserved
in all scopes with the semantics described above.</p>
</div>

<div class="div4">
<h5><a name="d1e246" id="d1e246" />6.12.2.4 Variable
resolution</h5>

<p>This section describes how named variables are resolved in
VoiceXML 3.0. Named variables in expressions may be scope-qualified
(using implicit variables) or scope-unqualified.</p>

<p>Some examples of scope-qualified variables that may occur in
expressions are listed in the table below.</p>

<a name="resolution_examples_ecmascript"
id="resolution_examples_ecmascript" />
<table>
<caption>Table 53: Resolution examples (ECMAScript)</caption>

<thead>
<tr>
<td>Expression</td>
<td>Result</td>
</tr>
</thead>

<tbody>
<tr>
<td><em>application.hello</em></td>
<td>The value of the "hello" named variable in the application
scope.</td>
</tr>

<tr>
<td><em>dialog.retries</em></td>
<td>The value of the "retries" named variable in the dialog
scope.</td>
</tr>

<tr>
<td><em>dialog.properties$.bargein</em></td>
<td>The value of the "bargein" platform property defined at the
current "dialog" scope.</td>
</tr>
</tbody>
</table>

<p>The above table assumes that all the named variables used in the
expressions exist. If any of the named variables do not exist, an
<em>error.semantic</em> will result.</p>

<p>In cases where the named variables are unqualified i.e. there is
no implicit variable indicating the scope in use, the following
variable resolution mechanism is used:</p>

<ul>
<li>The anonymous scope is checked for the named variable, and its
value is returned if the variable is found</li>

<li>Otherwise, the dialog scope is checked for the named variable,
and its value is returned if the variable is found</li>

<li>Otherwise, the document scope is checked for the named
variable, and its value is returned if the variable is found</li>

<li>Otherwise, the application scope is checked for the named
variable, and its value is returned if the variable is found</li>

<li>Otherwise, the session scope is checked for the named variable,
and its value is returned if the variable is found</li>

<li>Otherwise, an <em>error.semantic</em> is thrown</li>
</ul>

<p>The steps corresponding to any scopes that do not exist at the
time of expression evaluation are ignored. The resolution mechanism
begins with the closest enclosing scope in the given document
structure.</p>
</div>

<div class="div4">
<h5><a name="d1e344" id="d1e344" />6.12.2.5 Standard session
variables</h5>

<p>The following standard variables are available in the session
scope:</p>

<dl>
<dt class="label"><var>session.connection.local.uri</var></dt>

<dd>This variable is a URI which addresses the local interpreter
context device.</dd>

<dt class="label"><var>session.connection.remote.uri</var></dt>

<dd>This variable is a URI which addresses the remote caller
device.</dd>

<dt class="label"><var>session.connection.protocol.name</var></dt>

<dd>This variable is the name of the connection protocol. The name
also represents the subobject name for protocol specific
information. For instance, if session.connection.protocol.name is
'q931', session.connection.protocol.q931.uui might specify the
user-to-user information property of the connection.</dd>

<dt class="label">
<var>session.connection.protocol.version</var></dt>

<dd>This variable is the version of the connection protocol.</dd>

<dt class="label"><var>session.connection.redirect</var></dt>

<dd>This variable is an array representing the connection
redirection paths. The first element is the original called number,
the last element is the last redirected number. Each element of the
array contains a uri, pi (presentation information), si (screening
information), and reason property. The reason property can be
either "unknown", "user busy", "no reply", "deflection during
alerting", "deflection immediate response", "mobile subscriber not
reachable".</dd>

<dt class="label"><var>session.connection.aai</var></dt>

<dd>This variable is application-to-application information passed
during connection setup.</dd>

<dt class="label"><var>session.connection.originator</var></dt>

<dd>This variable directly references either the local or remote
property (For instance, the following ECMAScript would return true
if the remote party initiated the connection: var caller_initiate =
connection.originator == connection.remote).</dd>
</dl>
</div>

<div class="div4">
<h5><a name="d1e402" id="d1e402" />6.12.2.6 Standard application
variables</h5>

<p>The following standard variables are available in the
application scope:</p>

<dl>
<dt class="label"><var>application.lastresult$</var></dt>

<dd>This variable holds information about the last recognition to
occur within this application. It is an array of elements where
each element, application.lastresult$[i], represents a possible
result through the following variables: 

<dl>
<dt class="label">
<var>application.lastresult$.confidence</var></dt>

<dd>The whole utterance confidence level for this interpretation
from 0.0-1.0. A value of 0.0 indicates minimum confidence, and a
value of 1.0 indicates maximum confidence. More specific
interpretation of a confidence value is platform-dependent.</dd>

<dt class="label"><var>application.lastresult$.utterance</var></dt>

<dd>The raw string of words that were recognized for this
interpretation. The exact tokenization and spelling is
platform-specific (e.g. "five hundred thirty" or "5 hundred 30" or
even "530"). In the case of a DTMF grammar, this variable will
contain the matched digit string.</dd>

<dt class="label"><var>application.lastresult$.inputmode</var></dt>

<dd>For this interpretation,the mode in which user input was
provided: dtmf or voice.</dd>

<dt class="label">
<var>application.lastresult$.interpretation</var></dt>

<dd>An ECMAScript variable containing the interpretation as
described in the Semantic Interpretation for Speech Recognition
specification [SISR].</dd>

<dt class="label"><var>application.lastresult$.markname</var></dt>

<dd>The name of the mark last executed by the SSML processor before
barge-in occurred or the end of audio playback occurred. If no mark
was executed, this variable is undefined.</dd>

<dt class="label"><var>application.lastresult$.marktime</var></dt>

<dd>The number of milliseconds that elapsed since the last mark was
executed by the SSML processor until barge-in occurred or the end
of audio playback occurred. If no mark was executed, this variable
is undefined.</dd>

<dt class="label"><var>application.lastresult$.recording</var></dt>

<dd>The variable that stores a reference to the recording, or
undefined if no audio is collected. Like the input item variable
associated with a &lt;record&gt; element as described in section
2.3.6 of [VXML2], the implementation of this variable may vary
between platforms.</dd>

<dt class="label">
<var>application.lastresult$.recordingsize</var></dt>

<dd>The size of the recording in bytes, or undefined if no audio is
collected.</dd>

<dt class="label">
<var>application.lastresult$.recordingduration</var></dt>

<dd>The duration of the recording in milliseconds, or undefined if
no audio is collected.</dd>
</dl>
</dd>
</dl>

<p>Interpretations are sorted by confidence score, from highest to
lowest. Interpretations with the same confidence score are further
sorted according to the precedence relationship among the grammars
producing the interpretations. Different elements in
application.lastresult$ will always differ in their utterance,
interpretation, or both.</p>

<p>The number of application.lastresult$ elements is guaranteed to
be greater than or equal to one and less than or equal to the
system property "maxnbest". If no results have been generated by
the system, then "application.lastresult$" shall be ECMAScript
undefined.</p>

<p>Additionally, application.lastresult$ itself contains the
properties confidence, utterance, inputmode, and interpretation
corresponding to those of the 0th element in the ECMAScript
array.</p>

<p>All of the shadow variables described above are set immediately
after any recognition. In this context, a &lt;nomatch&gt; event
counts as a recognition, and causes the value of
"application.lastresult$" to be set, though the values stored in
application.lastresult$ are platform dependent. In addition, the
existing values of field variables are not affected by a
&lt;nomatch&gt;. In contrast, a &lt;noinput&gt; event does not
change the value of "application.lastresult$". After the value of
"application.lastresult$" is set, the value persists (unless it is
modified by the application) until the browser enters the next
waiting state, when it is set to <em>undefined.</em> Similarly,
when an application root document is loaded, this variable is set
to the value <em>undefined</em>. The variable
application.lastresult$ and all of its components are writable and
can be modified by the application.</p>
</div>

<div class="div4">
<h5><a name="d1e505" id="d1e505" />6.12.2.7 Legal variable values
and expressions</h5>

<p>Any data language available on a VoiceXML 3.0 platform must
specify the structure of the underlying data model. For example,
with XPath, the variable values (and hence, the constituents of the
data model) are XML trees. Such a specification of the data model
implicitly defines a set of "legal variable values", namely the
objects that can be part of such a data model.</p>

<p>Similarly, any data access and manipulation language available
on a VoiceXML 3.0 platform must specify the complete set of valid
value expressions via the expression language syntax.</p>
</div>
</div>

<div class="div3">
<h4><a name="d1e514" id="d1e514" />6.12.3 Syntax</h4>

<p>The syntax of the Data Access and Manipulation Module is
described in terms of full support for CRUD operations (Create,
Read, Update, Delete) on the Data layer in sections 2.3.1 through
2.3.4. The relevance of this syntax for properties is described in
section 2.3.5.</p>

<div class="div4">
<h5><a name="d1e520" id="d1e520" />6.12.3.1 Creating variables: the
&lt;var&gt; element</h5>

<p>The declaration of named variables is done using the &lt;var&gt;
element. It can occur in executable content or as a child of
&lt;form&gt; or &lt;vxml&gt;.</p>

<p>If it occurs in executable content, it declares a variable in
the anonymous scope associated with the enclosing &lt;block&gt;,
&lt;filled&gt;, or catch element. This declaration is made only
when the &lt;var&gt; element is executed. If the variable is
already declared in this scope, subsequent declarations act as
assignments, as in ECMAScript.</p>

<p>If a &lt;var&gt; is a child of a &lt;form&gt; element, it
declares a variable in the dialog scope of the &lt;form&gt;. This
declaration is made during the form's initialization phase.</p>

<p>If a &lt;var&gt; is a child of a &lt;vxml&gt; element, it
declares a variable in the document scope; and if it is the child
of a &lt;vxml&gt; element in a root document then it also declares
the variable in the application scope. This declaration is made
when the document is initialized; initializations happen in
document order.</p>

<p><em>Attributes of &lt;var&gt;</em></p>

<a name="var_attributes" id="var_attributes" />
<table>
<caption>Table 54: &lt;var&gt; Attributes</caption>

<tbody>
<tr>
<th>name</th>
<td>The name of the variable that will hold the result. This
attribute must not specify a scope-qualified variable (if a
variable is specified with a scope prefix, then an error.semantic
event is thrown). The default scope in which the variable is
defined is determined from the position in the document at which
the element is declared.</td>
</tr>

<tr>
<th>expr</th>
<td>The initial value of the variable (optional). If there is no
expr attribute, the variable retains its current value, if any.
Variables start out with the default value determined by the data
access expression language in use if they are not given initial
values (for example, with ECMAScript the initial value is
<em>undefined</em>).</td>
</tr>

<tr>
<th>scope</th>
<td>The scope within which the named variable must be created
(optional). Must be one of <em>session</em>, <em>application</em>,
<em>document</em> or <em>dialog</em>. If the specified scope does
not exist, then an <em>error.semantic</em> event is thrown.</td>
</tr>
</tbody>
</table>

<p>The addition of the "scope" attribute in VoiceXML 3.0 adds more
flexibility for the creation of variables, and allows creation to
be decoupled from document location of the &lt;var&gt; element, if
desired by the application.</p>

<p><em>Children of &lt;var&gt;</em></p>

<p>The children of the &lt;var&gt; element represent an in-line
specification of the value of the variable.</p>

<p>If "expr" attribute is present, then the element must not have
any children. Thus "expr" and children are mutually exclusive for
the &lt;var&gt; element.</p>

<p><em>&lt;var&gt; examples</em></p>

<p><em>This section is informative.</em></p>

<div class="exampleInner">
<pre>
    &lt;var name="phone" expr="'6305551212'"/&gt;

    &lt;var name="y" expr="document.z+1"/&gt;

    &lt;var name="foo" scope="application" expr="dialog.bar * 2"/&gt;

    &lt;var name="itinerary"&gt;
      &lt;root xmlns=""&gt;
        &lt;flight&gt;SW123&lt;/flight&gt;
        &lt;origin&gt;JFK&lt;/origin&gt;
        &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
        &lt;destination&gt;SFO&lt;/destination&gt;
        &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
      &lt;/root&gt;
    &lt;/var&gt;
   
</pre>
</div>

<p>The above examples have the following result, in order:</p>

<ol class="enumar">
<li>Creates a variable with name "phone" and String value
"6305551212" in the closest enclosing scope as determined by the
position of this &lt;var&gt; element in the document. If a variable
named "phone" is already present in the mentioned scope, its value
is updated to the String value "6305551212" (since this is always
true, the rest of this section will not repeat this for each
example).</li>

<li>Creates a variable with name "y" in the closest enclosing scope
as determined by the position of this &lt;var&gt; element in the
document and value corresponding to the result of the expression
"document.z+1", evaluated when this &lt;var&gt; element is
executed.</li>

<li>Creates a variable with name "foo" in the application scope and
value corresponding to the result of the expression "dialog.bar *
2", evaluated when this &lt;var&gt; element is executed.</li>

<li>Creates a variable with name "itinerary" in the closest
enclosing scope as determined by the position of this &lt;var&gt;
element in the document and value specified by the following
in-line XML tree (the internal representation may be the
corresponding DOM node, for example):

<div class="exampleInner">
<pre>
    &lt;root xmlns=""&gt;
      &lt;flight&gt;SW123&lt;/flight&gt;
      &lt;origin&gt;JFK&lt;/origin&gt;
      &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
      &lt;destination&gt;SFO&lt;/destination&gt;
      &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
    &lt;/root&gt;
         
</pre>
</div>
</li>
</ol>

<p><em>Translating to the Data Model Resource API</em></p>

<p><em>Implementation Notes: This section illustrates how the above
examples translate to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>The above examples result in the following Data Model Resource
API calls, in order:</p>

<ol class="enumar">
<li>At the time of &lt;var&gt; execution, first the value is
obtained for the new variable with name "phone" by evaluating the
expression "'6305551212'", and subsequently the variable is created
in the scope on top of the stack:

<ol class="enumla">
<li>Obtain variable value by calling
<em>EvaluateExpression("'6305551212'")</em></li>

<li>Create variable by calling <em>CreateVariable("name",
value)</em> where <em>value</em> is the result obtained in a.
above. The optional scope parameter is not specified since the
scope on the top of the stack is chosen by default.</li>
</ol>
</li>

<li>At the time of &lt;var&gt; execution, first the value is
obtained for the new variable with name "y" by evaluating the
expression "document.z+1", and subsequently the variable is created
in the scope on top of the stack:

<ol class="enumla">
<li>Obtain variable value by calling
<em>EvaluateExpression("document.z+1")</em></li>

<li>Create variable by calling <em>CreateVariable("y", value)</em>
where <em>value</em> is the result obtained in a. above.</li>
</ol>
</li>

<li>At the time of &lt;var&gt; execution, first the value is
obtained for the new variable with name "foo" by evaluating the
expression "dialog.bar * 2", and subsequently the variable is
created in application scope:

<ol class="enumla">
<li>Obtain variable value by calling
<em>EvaluateExpression("dialog.bar * 2")</em></li>

<li>Create variable by calling <em>CreateVariable("foo", value,
"application")</em> where <em>value</em> is the result obtained in
a. above.</li>
</ol>
</li>

<li>At the time of &lt;var&gt; execution, the new variable with
name "itinerary" is created in the scope on top of the stack using
the in-line specification for the value in the body of the
&lt;var&gt; element:

<ol class="enumla">
<li>Process the in-line specification below into an internal
representation for the data model. For example, the assumed XML
data model in this example may choose to internally represent this
in-line specification as a DOM node.

<div class="exampleInner">
<pre>
    &lt;root xmlns=""&gt;
      &lt;flight&gt;SW123&lt;/flight&gt;
      &lt;origin&gt;JFK&lt;/origin&gt;
      &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
      &lt;destination&gt;SFO&lt;/destination&gt;
      &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
    &lt;/root&gt;
           
</pre>
</div>
</li>

<li>Create variable by calling <em>CreateVariable("itinerary",
node)</em> where <em>node</em> is the DOM node from a. above.</li>
</ol>
</li>
</ol>
</div>

<div class="div4">
<h5><a name="d1e742" id="d1e742" />6.12.3.2 Reading variables:
"expr" and "cond" attributes and the &lt;value&gt; element</h5>

<p>The values of the named variables in the existing scopes in the
scope stack are available for introspection and for further
computation. These values can be read wherever expressions can be
specified in the VoiceXML 3.0 document. Important examples include
the "expr" and "cond" attributes on various syntactic elements. The
"expr" attribute values are legal expressions as defined by the
syntax of the data access and manipulation language (see Section
2.2.7 for details). The "cond" attribute values function as
predicates, and in addition to being expressions, must evaluate to
a <em>boolean</em> value.</p>

<div class="div5">
<h6><a name="d1e751" id="d1e751" />6.12.3.2.1 Inserting variable
values in prompts: The &lt;value&gt; element</h6>

<p>The &lt;value&gt; element is used to insert the value of an
expression into a prompt. <a href="#PromptModule"><b>6.4 Prompt
Module</b></a> specifies prompts in detail.</p>

<p><em>Attributes of &lt;value&gt;</em></p>

<a name="value_attributes" id="value_attributes" />
<table>
<caption>Table 55: &lt;value&gt; attributes</caption>

<tbody>
<tr>
<th>expr</th>
<td>The expression to render. See Section 2.2.7 for legal values of
expressions.</td>
</tr>

<tr>
<th>scope</th>
<td>The scope within which the named variables in the expression
are resolved (optional). Must be one of <em>session</em>,
<em>application</em>, <em>document</em> or <em>dialog</em>. If the
specified scope does not exist, then an <em>error.semantic</em>
event is thrown.</td>
</tr>
</tbody>
</table>

<p><em>&lt;value&gt; examples</em></p>

<div class="exampleInner">
<pre>
    &lt;value expr="application.duration + dialog.duration"/&gt;

    &lt;value expr="foo * bar"/&gt;

    &lt;value expr="foo + bar + application.baz" scope="document"/&gt;
   
</pre>
</div>

<p>The above examples render the following, in order:</p>

<ol class="enumar">
<li>The value corresponding to the sum (or concatenation, as the
case may be) of the "duration" named variable in the application
scope and the "duration" named variable in the dialog scope.</li>

<li>The value corresponding to the product of the "foo" and "bar"
named variables in the closest enclosing scope (the top of the
scope stack).</li>

<li>The value corresponding to the sum (or concatenation, as the
case may be) of the "foo" and "bar" named variables in the document
scope, and the "baz" named variable in the application scope.</li>
</ol>

<p><em>Translating to the Data Model Resource API</em></p>

<p><em>Implementation Notes: This section illustrates how the above
examples translate to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>The above examples result in the following Data Model Resource
API calls:</p>

<ol class="enumar">
<li>
<ol class="enumla">
<li>Evaluate the expression "application.duration +
dialog.duration" in the closest enclosing scope by calling
<em>EvaluateExpression("application.duration +
dialog.duration")</em></li>

<li>The expression evaluator in turn resolves the scope-qualified
variables in the expression by calling <em>ReadVariable("duration",
"application")</em> <em>ReadVariable("duration",
"dialog")</em></li>
</ol>
</li>

<li>
<ol class="enumla">
<li>Evaluate the expression "foo * bar" in the closest enclosing
scope by calling <em>EvaluateExpression("foo * bar")</em></li>

<li>The expression evaluator in turn resolves the scope-unqualified
variables in the expression by calling <em>ReadVariable("foo")</em>
<em>ReadVariable("bar")</em></li>
</ol>
</li>

<li>
<ol class="enumla">
<li>Evaluate the expression "foo + bar + application.baz" in the
document scope in the expression by calling
<em>EvaluateExpression("foo + bar + application.baz",
"document")</em></li>

<li>The expression evaluator in turn resolves the variables by
calling <em>ReadVariable("foo", "document")</em>
<em>ReadVariable("bar", "document")</em> <em>ReadVariable("baz",
"application")</em></li>
</ol>
</li>
</ol>
</div>
</div>

<div class="div4">
<h5><a name="d1e907" id="d1e907" />6.12.3.3 Updating variables: the
&lt;assign&gt; and &lt;data&gt; elements</h5>

<div class="div5">
<h6><a name="d1e910" id="d1e910" />6.12.3.3.1 The &lt;assign&gt;
element</h6>

<p>The &lt;assign&gt; element assigns a value to a variable.</p>

<p>It is illegal to make an assignment to a variable that has not
been explicitly declared using a &lt;var&gt; element or a var
statement within a &lt;script&gt;. Attempting to assign to an
undeclared variable causes an <em>error.semantic</em> event to be
thrown.</p>

<p>Note that when an ECMAScript object, say "obj", has been
properly initialized then its properties, for instance "obj.prop1",
can be assigned without explicit declaration (in fact, an attempt
to declare ECMAScript object properties such as "obj.prop1" would
result in an <em>error.semantic</em> event being thrown).</p>

<p><em>Attributes of &lt;assign&gt;</em></p>

<a name="assign_attributes" id="assign_attributes" />
<table>
<caption>Table 56: &lt;assign&gt; attributes</caption>

<tbody>
<tr>
<th>name</th>
<td>The name of the variable being assigned to. The corresponding
variable must have been previously declared otherwise an
<em>error.semantic</em> event is thrown. By default, the scope in
which the variable is resolved is the closest enclosing scope of
the currently active element. To remove ambiguity, the variable
name may be prefixed with a scope name.</td>
</tr>

<tr>
<th>expr</th>
<td>The expression evaluating to the new value of the variable
(optional).</td>
</tr>
</tbody>
</table>

<p><em>Children of &lt;assign&gt;</em></p>

<p>The children of the &lt;assign&gt; element represent an in-line
specification of the new value of the variable.</p>

<p>If "expr" attribute is present, then the element must not have
any children. Thus "expr" and children are mutually exclusive for
the &lt;assign&gt; element.</p>

<p><em>&lt;assign&gt; examples</em></p>

<p><em>This section is informative.</em></p>

<div class="exampleInner">
<pre>
    &lt;assign name="phone" expr="'6305551212'"/&gt;

    &lt;assign name="y" expr="document.z+1"/&gt;

    &lt;assign name="application.foo" expr="dialog.bar * 2"/&gt;

    &lt;assign name="itinerary"&gt;
      &lt;root xmlns=""&gt;
        &lt;flight&gt;SW123&lt;/flight&gt;
        &lt;origin&gt;JFK&lt;/origin&gt;
        &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
        &lt;destination&gt;SFO&lt;/destination&gt;
        &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
      &lt;/root&gt;
    &lt;/var&gt;
   
</pre>
</div>

<p>The above examples have the following result, in order:</p>

<ol class="enumar">
<li>Updates the variable with name "phone" to a new String value
"6305551212" in the closest enclosing scope as determined by the
position of this &lt;assign&gt; element in the document. If a
variable named "phone" is not already defined in the mentioned
scope, an <em>error.semantic</em> is thrown (since this is always
true if variables that are not already defined are attempted to be
updated using &lt;assign&gt;, the rest of this section will not
repeat this for each example).</li>

<li>Updates the variable with name "y" in the closest enclosing
scope as determined by the position of this &lt;assign&gt; element
in the document to the value corresponding to the result of the
expression "document.z+1", evaluated when this &lt;assign&gt;
element is executed.</li>

<li>Updates the variable with name "foo" in the application scope
to the value corresponding to the result of the expression
"dialog.bar * 2", evaluated when this &lt;assign&gt; element is
executed.</li>

<li>Updates the variable with name "itinerary" in the closest
enclosing scope as determined by the position of this
&lt;assign&gt; element in the document to the value specified by
the following in-line XML tree (the internal representation may be
the corresponding DOM node, for example):

<div class="exampleInner">
<pre>
    &lt;root xmlns=""&gt;
      &lt;flight&gt;SW123&lt;/flight&gt;
      &lt;origin&gt;JFK&lt;/origin&gt;
      &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
      &lt;destination&gt;SFO&lt;/destination&gt;
      &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
    &lt;/root&gt;
       
</pre>
</div>
</li>
</ol>

<p><em>Translating to the Data Model Resource API</em></p>

<p><em>Implementation Notes: This section illustrates how the above
examples translate to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>The above examples result in the following Data Model Resource
API calls, in order:</p>

<ol class="enumar">
<li>At the time of &lt;assign&gt; execution, first the new value is
obtained for the variable with name "phone" by evaluating the
expression "'6305551212'", and subsequently the variable is updated
in the scope on top of the stack:

<ol class="enumla">
<li>Obtain new variable value by calling
<em>EvaluateExpression("'6305551212'")</em></li>

<li>Update variable value by calling <em>UpdateVariable("name",
value)</em> where <em>value</em> is the result obtained in a.
above. The optional scope parameter is not specified since the
scope on the top of the stack is chosen by default.</li>
</ol>
</li>

<li>At the time of &lt;assign&gt; execution, first the new value is
obtained for the variable with name "y" by evaluating the
expression "document.z+1", and subsequently the variable is updated
in the scope on top of the stack:

<ol class="enumla">
<li>Obtain new variable value by calling
<em>EvaluateExpression("document.z+1")</em></li>

<li>Update variable value by calling <em>UpdateVariable("y",
value)</em> where <em>value</em> is the result obtained in a.
above.</li>
</ol>
</li>

<li>At the time of &lt;assign&gt; execution, first the new value is
obtained for the variable with name "foo" by evaluating the
expression "dialog.bar * 2", and subsequently the variable is
updated in application scope:

<ol class="enumla">
<li>Obtain new variable value by calling
<em>EvaluateExpression("dialog.bar * 2")</em></li>

<li>Update variable value by calling <em>UpdateVariable("foo",
value, "application")</em> where <em>value</em> is the result
obtained in a. above.</li>
</ol>
</li>

<li>At the time of &lt;assign&gt; execution, the variable with name
"itinerary" is updated in the scope on top of the stack using the
in-line specification for the new value specified in the body of
the &lt;assign&gt; element:

<ol class="enumla">
<li>Process the in-line specification below into an internal
representation for the data model. For example, the assumed XML
data model in this example may choose to internally represent this
in-line specification as a DOM node.

<div class="exampleInner">
<pre>
    &lt;root xmlns=""&gt;
      &lt;flight&gt;SW123&lt;/flight&gt;
      &lt;origin&gt;JFK&lt;/origin&gt;
      &lt;depart&gt;2009-01-01T14:32:00&lt;/depart&gt;
      &lt;destination&gt;SFO&lt;/destination&gt;
      &lt;arrive&gt;2009-01-01T18:14:00&lt;/arrive&gt;
    &lt;/root&gt;
           
</pre>
</div>
</li>

<li>Update variable value by calling
<em>UpdateVariable("itinerary", node)</em> where <em>node</em> is
the DOM node from a. above.</li>
</ol>
</li>
</ol>
</div>

<div class="div5">
<h6><a name="d1e1108" id="d1e1108" />6.12.3.3.2 The &lt;data&gt;
element</h6>

<p>The &lt;data&gt; element allows a VoiceXML application to fetch
an in-line specification of a new value for a named variable from a
document server without transitioning to a new VoiceXML document.
The data fetched is bound to the named variable.</p>

<p><em>Attributes of &lt;data&gt;</em></p>

<p>The &lt;data&gt; element has the attributes specified in Table
57, in addition to the fetchtimeout, fetchhint, maxage, and
maxstale attributes as specified in <a href="#Fetching"><b>8.1.1
Fetching</b></a>.</p>

<a name="data_attributes" id="data_attributes" />
<table>
<caption>Table 57: &lt;data&gt; Attributes</caption>

<tbody>
<tr>
<th>src</th>
<td>The URI specifying the location of the in-line data
specification to retrieve (optional). This specification depends on
the data language in use for the VoiceXML document (XML,
JSON).</td>
</tr>

<tr>
<th>name</th>
<td>The name of the variable that the data fetched will be bound
to.</td>
</tr>

<tr>
<th>scope</th>
<td>The scope within which the named variable to bind the data is
found (optional). Must be one of <em>session</em>,
<em>application</em>, <em>document</em> or <em>dialog</em>. If the
specified scope does not exist, then an <em>error.semantic</em>
event is thrown.</td>
</tr>

<tr>
<th>srcexpr</th>
<td>Like src, except that the URI is dynamically determined by
evaluating the given expression when the data needs to be fetched
(optional). If srcexpr cannot be evaluated, an
<em>error.semantic</em> event is thrown.</td>
</tr>

<tr>
<th>method</th>
<td>The request method: get (the default) or post (optional).</td>
</tr>

<tr>
<th>namelist</th>
<td>The list of variables to submit (optional). By default, no
variables are submitted. If a namelist is supplied, it may contain
individual variable references which are submitted with the same
qualification used in the namelist. Declared VoiceXML variables can
be referenced.</td>
</tr>

<tr>
<th>enctype</th>
<td>The media encoding type of the submitted document (optional).
The default is application/x-www-form-urlencoded. Interpreters must
also support multipart/form-data [RFC2388] and may support
additional encoding types.</td>
</tr>

<tr>
<th>fetchaudio</th>
<td>See <a
href="http://www.w3.org/TR/2004/REC-voicexml20-20040316/#dml6.1">Section
6.1</a> of [VXML2] (optional). This defaults to the fetchaudio
property described in <a
href="http://www.w3.org/TR/2004/REC-voicexml20-20040316/#dml6.3.5">Section
6.3.5</a> of [VXML2].</td>
</tr>
</tbody>
</table>

<p>Exactly one of "src" or "srcexpr" must be specified; otherwise,
an error.badfetch event is thrown. If the content cannot be
retrieved, the interpreter throws an error as specified for fetch
failures in Section 5.2.6 of [VXML2].</p>

<p>If the value of the src or srcexpr attribute includes a fragment
identifier, the processing of that fragment identifier is
platform-specific.</p>

<p>Platforms should support parsing XML data into a DOM. If an
implementation does not support DOM, the name attribute must not be
set, and any retrieved content must be ignored by the interpreter.
If the name attribute is present, these implementations will throw
error.unsupported.data.name.</p>

<p>If the name attribute is present, and the returned document is
XML as identified by [RFC3023], the VoiceXML interpreter must
expose the retrieved content via a read-only subset of the DOM as
specified in Appendix D of [VXML2.1]. An interpreter may support
additional data formats by recognizing additional media types. If
an interpreter receives a document in a data format that it does
not understand, or the data is not well-formed as defined by the
specification of that format, the interpreter throws
error.badfetch. If the media type of the retrieved content is one
of those defined in [RFC3023] but the content is not well-formed
XML, the interpreter throws error.badfetch.</p>

<p>If use of the DOM causes an uncaught DOMException to be thrown,
the VoiceXML interpreter throws error.semantic.</p>

<p>Before exposing the data in an XML document referenced by the
&lt;data&gt; element via the DOM, the interpreter should check that
the referring document is allowed to access the data. If access is
denied the interpreter must throw error.noauthorization.</p>

<p>Note: One strategy commonly implemented in voice browsers to
control access to data is the "access-control" processing
instruction described in the WG Note: <em>Authorizing Read Access
to XML Content Using the &lt;?access-control?&gt; Processing
Instruction 1.0</em> [DATA_AUTH].</p>

<p>Like the &lt;var&gt; element, the &lt;data&gt; element can occur
in executable content or as a child of &lt;form&gt; or
&lt;vxml&gt;. In addition, it shares the same default scoping rules
as the &lt;var&gt; element. If a &lt;data&gt; element has the same
name as a variable already declared in the same scope, the variable
is assigned a reference to the new value exposed by the
&lt;data&gt; element.</p>

<p>Like the &lt;submit&gt; element, when variable data is submitted
to the server its value is first converted into a string before
being submitted. If the variable is a DOM Object, its serialized as
the corresponding XML. If the variable is an ECMAScript Object, the
mechanism by which it is submitted is not currently defined. If a
&lt;data&gt; element's namelist contains a variable which
references recorded audio but does not contain an enctype of
multipart/form-data [RFC2388], the behavior is not specified. It is
discouraged to attempt to URL-encode large quantities of data.</p>

<p><em>&lt;data&gt; example</em></p>

<p>The example discussed in this section uses XML as the data
language and fetches the following XML document using the
&lt;data&gt; element:</p>

<div class="exampleInner">
<pre>
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;quote xmlns="http://www.example.org"&gt;
      &lt;ticker&gt;F&lt;/ticker&gt;
      &lt;name&gt;Ford Motor Company&lt;/name&gt;
      &lt;change&gt;0.10&lt;/change&gt;
      &lt;last&gt;3.00&lt;/last&gt;
    &lt;/quote&gt;
   
</pre>
</div>

<p>The above stock quote is retrieved in one dialog, the document
element is cached in a variable at document scope and used to
playback the quote in another dialog. The data access and
manipulation language in the example is XPath 2.0 [XPATH20].</p>

<div class="exampleInner">
<pre>
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;vxml xmlns="http://www.w3.org/2001/vxml" 
      version="2.1"
      xmlns:ex="http://www.example.org"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xsi:schemaLocation="http://www.w3.org/2001/vxml 
      http://www.w3.org/TR/2007/REC-voicexml21-20070619/vxml.xsd"&gt;

      &lt;var name="quote"/&gt;
      &lt;var name="tickers"&gt;
        &lt;tickers xmlns=""&gt;
          &lt;ford&gt;f&lt;/ford&gt;
          &lt;!-- etc., the dialog below hardcodes ford --&gt;
        &lt;/tickers&gt;
      &lt;/var&gt;

      &lt;form id="get_quote"&gt;
        &lt;block&gt;
          &lt;data name="quote" scope="document"
            srcexpr="'http://www.example.org/getquote?ticker=' + document('tickers')/ford"/&gt;
          &lt;goto next="#play_quote"/&gt;         
        &lt;/block&gt;
      &lt;/form&gt;

      &lt;form id="play_quote"&gt;
        &lt;block&gt;
          &lt;var name="name" expr="document('quote')/ex:name"/&gt;
          &lt;var name="change" expr="document('quote')/ex:change"/&gt;
          &lt;var name="last" expr="document('quote')/ex:last"/&gt;
          &lt;var name="dollars" expr="fn:floor(last)"/&gt;
          &lt;var name="cents" expr="fn:substring(last,fn:string-length(last)-1)"/&gt;

          &lt;!--play the company name --&gt;
          &lt;audio expr="document('tickers')/ford + '.wav'"&gt;&lt;value expr="name"/&gt;&lt;/audio&gt;
          &lt;!-- play 'unchanged, 'up', or 'down' based on zero, positive, or negative change --&gt;
          &lt;if cond="change = 0"&gt;
            &lt;audio src="unchanged_at.wav"/&gt;
          &lt;else/&gt;
            &lt;if cond="change &amp;gt; 0"&gt;
              &lt;audio src="up.wav"/&gt;
            &lt;else/&gt; &lt;!-- negative --&gt;
              &lt;audio src="down.wav"/&gt;
            &lt;/if&gt;
            &lt;audio src="by.wav"/&gt;
            &lt;!-- play change in value as positive number --&gt;
            &lt;audio expr="fn:abs(change) + '.wav'"&gt;&lt;value expr="fn:abs(change)"/&gt;&lt;/audio&gt;
            &lt;audio src="to.wav"/&gt;
          &lt;/if&gt;
          &lt;!-- play the current price per share --&gt;
          &lt;audio expr="dollars + '.wav'"&gt;&lt;value expr="dollars"/&gt;&lt;/audio&gt;
          &lt;if cond="cents &amp;gt; 0"&gt;
            &lt;audio src="point.wav"/&gt;
            &lt;audio expr="cents + '.wav'"&gt;&lt;value expr="cents"/&gt;&lt;/audio&gt;
          &lt;/if&gt;
        &lt;/block&gt;
      &lt;/form&gt;
    &lt;/vxml&gt;
   
</pre>
</div>

<p><em>Translating to the Data Model Resource API</em></p>

<p><em>Implementation Notes: This section illustrates how the above
examples translate to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>The single &lt;data&gt; usage in the above example results in
the following behavior and Data Model Resource API calls:</p>

<p>At the time of &lt;data&gt; execution, the variable with name
"quote" is updated in the document scope using the in-line
specification for the new value retrieved from the URI expression
<em>'http://www.example.org/getquote?ticker=' +
document('tickers')/ford</em> which evaluates to
<em>http://www.example.org/getquote?ticker=f</em></p>

<ol class="enumar">
<li>Obtain the URI to request the in-line specification of the new
value from, by evaluating the "srcexpr" attribute value
<em>EvaluateExpression("'http://www.example.org/getquote?ticker=' +
document('tickers')/ford")</em></li>

<li>Request the in-line specification from the URI resulting from
a. which happens to be
<em>http://www.example.org/getquote?ticker=f</em> in this
example.</li>

<li>Process the response received (the in-line data specification
below) into an internal representation for the data model. The XML
data model internally represents this in-line specification as a
DOM node (the document element).

<div class="exampleInner">
<pre>
    &lt;quote xmlns="http://www.example.org"&gt;
      &lt;ticker&gt;F&lt;/ticker&gt;
      &lt;name&gt;Ford Motor Company&lt;/name&gt;
      &lt;change&gt;0.10&lt;/change&gt;
      &lt;last&gt;3.00&lt;/last&gt;
    &lt;/quote&gt;
       
</pre>
</div>
</li>

<li>Update the "quote" variable value in document scope by calling
<em>UpdateVariable("quote", node, "document")</em> where
<em>node</em> is the DOM node in c. above.</li>
</ol>

<p><em>&lt;data&gt; Fetching Properties</em></p>

<p>These properties pertain to documents fetched by the
&lt;data&gt; element.</p>

<a name="data_fetching_properties" id="data_fetching_properties" />
<table>
<caption>Table 58: &lt;data&gt; Fetching Properties</caption>

<tbody>
<tr>
<th>datafetchhint</th>
<td>Tells the platform whether or not data documents may be
pre-fetched. The value is either prefetch (the default), or
safe.</td>
</tr>

<tr>
<th>datamaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached documents. The default is platform-specific.</td>
</tr>

<tr>
<th>datamaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached data documents. The default is
platform-specific.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="div4">
<h5><a name="d1e1456" id="d1e1456" />6.12.3.4 Deleting variables:
the &lt;clear&gt; element</h5>

<p>The &lt;clear&gt; element resets one or more variables,
including form items.</p>

<p>For each specified variable name, the variable is resolved
relative to the current scope by default (to remove ambiguity, each
variable name in the namelist may be prefixed with a scope name).
Once a declared variable has been identified, its value is assigned
the default initial value defined by the data access expression
language in use (for example, when using ECMAScript, the variables
are reset to the <em>undefined</em> value). In addition, if the
variable name corresponds to a form item, then the form item's
prompt counter and event counter are reset.</p>

<p><em>Attributes of &lt;clear&gt;</em></p>

<a name="clear_attributes" id="clear_attributes" />
<table>
<caption>Table 59: &lt;clear&gt; attributes</caption>

<tbody>
<tr>
<th>namelist</th>
<td>The list of variables to be reset; this can include variable
names other than form items. If an undeclared variable is
referenced in the namelist, then an <em>error.semantic</em> is
thrown. When not specified, all form items in the current form are
cleared.</td>
</tr>

<tr>
<th>scope</th>
<td>The scope within which the named variables must be resolved
(optional). Must be one of <em>session</em>, <em>application</em>,
<em>document</em> or <em>dialog</em>. If the specified scope does
not exist, then an <em>error.semantic</em> event is thrown.</td>
</tr>
</tbody>
</table>

<p><em>&lt;clear&gt; examples</em></p>

<p><em>This section is informative.</em></p>

<p />
<div class="exampleInner">
<pre>
  &lt;clear namelist="city state zip"/&gt;

  &lt;clear namelist="application.foo dialog.bar baz"/&gt;

  &lt;clear namelist="alpha beta application.gamma" scope="document"/&gt;

  &lt;clear/&gt;

  &lt;clear scope="dialog"/&gt;
   
</pre>
</div>

<p />
<p>The above examples have the following result, in order:</p>

<ol class="enumar">
<li>The variables "city", "state" and "zip" in the closest
enclosing scope are reset. If any of these are form items, the
associated prompt and event counters are also reset (since this is
always true if variables are form items, the rest of this section
will not repeat this for each example).</li>

<li>The variable "foo" is reset in application scope, the variable
"bar" is reset in the dialog scope and the variable "baz" is reset
in the closest enclosing scope.</li>

<li>The scope-unqualified "alpha" and "beta" variables are reset in
the specified document scope default, and the "gamma" variable is
reset in the application scope.</li>

<li>All variables in the closest enclosing scope are reset.</li>

<li>All variables in the dialog scope are reset.</li>
</ol>

<p><em>Translating to the Data Model Resource API</em></p>

<p><em>Implementation Notes: This section illustrates how the above
examples translate to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>.</em></p>

<p>The above examples result in the following Data Model Resource
API calls, in order:</p>

<ol class="enumar">
<li>The namelist "city state zip" is tokenized into variable names
and each variable is reset in the scope on top of the stack (the
optional scope parameter is not specified in the calls since the
scope on the top of the stack is chosen by default):

<ol class="enumla">
<li>Tokenize namelist "city state zip" into tokens "city", "state"
and "zip"</li>

<li>Reset variable "city" by calling
<em>DeleteVariable("city")</em></li>

<li>Reset variable "state" by calling
<em>DeleteVariable("state")</em></li>

<li>Reset variable "zip" by calling
<em>DeleteVariable("zip")</em></li>
</ol>
</li>

<li>The namelist "application.foo dialog.bar baz" is tokenized into
variable names and each scope-qualified variable is reset in the
mentioned scope and scope-unqualified variables are reset in the
scope on top of the stack:

<ol class="enumla">
<li>Tokenize namelist "application.foo dialog.bar baz" into tokens
"application.foo", "dialog.bar" and "baz"</li>

<li>Reset variable "foo" in application scope by calling
<em>DeleteVariable("foo", "application")</em></li>

<li>Reset variable "bar" in dialog scope by calling
<em>DeleteVariable("bar", "dialog")</em></li>

<li>Reset variable "baz" in current scope by calling
<em>DeleteVariable("baz")</em></li>
</ol>
</li>

<li>The namelist "alpha beta application.gamma" is tokenized into
variable names and each scope-qualified variable is reset in the
mentioned scope and scope-unqualified variables are reset in the
document scope:

<ol class="enumla">
<li>Tokenize namelist "alpha beta application.gamma" into tokens
"alpha", "beta" and "application.gamma"</li>

<li>Reset variable "alpha" by calling <em>DeleteVariable("alpha",
"document")</em></li>

<li>Reset variable "beta" by calling <em>DeleteVariable("beta",
"document")</em></li>

<li>Reset variable "gamma" by calling <em>DeleteVariable("gamma",
"application")</em></li>
</ol>
</li>

<li>In the absence of a namelist, each variable in the scope on top
of the stack is reset. For each variable <em>var</em> in the
closest enclosing scope:

<ol class="enumla">
<li>Reset variable <em>DeleteVariable(var)</em></li>

<li>If <em>var</em> is a form item, reset prompt and event
counters</li>
</ol>
</li>

<li>In the absence of a namelist, each variable in the dialog scope
is reset. For each variable <em>var</em> in dialog scope:

<ol class="enumla">
<li>Reset variable <em>DeleteVariable(var, "dialog")</em></li>

<li>If <em>var</em> is a form item, reset prompt and event
counters</li>
</ol>
</li>
</ol>

<div class="issue">
<p class="prefix"><a name="ResetVar" id="ResetVar" /><b>Issue
(ResetVar):</b></p>

<p class="prefix"><b>ResetVariable()?</b></p>

<p>While this section uses the DeleteVariable() method, a
ResetVariable() method that better aligns with &lt;clear&gt;
semantics should be considered for addition to the <a
href="#Resources:Datamodel:API"><b>5.1.1 Data Model Resource
API</b></a>. This will allow resetting variable values to the
initial in-line specification when such is present, for
instance.</p>

<p class="prefix"><b>Resolution:</b></p>

<p>None recorded.</p>
</div>
</div>

<div class="div4">
<h5><a name="d1e1703" id="d1e1703" />6.12.3.5 Relevance for
properties</h5>

<p>Platform properties are discussed in detail in <a
href="#Properties"><b>8.2 Properties</b></a>. VoiceXML 3.0 provides
a consistent mechanism to unambiguously read these properties in
any scope using the data access and manipulation language in a
manner similar to accessing and manipulating named variables as
illustrated in section 2.3.2. However, properties cannot be
created, updated or deleted using any of the syntax described in
this module. The &lt;property&gt; element syntax must be used for
such operations.</p>
</div>
</div>

<div class="div3">
<h4><a name="d1e1712" id="d1e1712" />6.12.4 Backward compatibility
with VoiceXML 2.1</h4>

<p>VoiceXML 3.0 adds some new features to data access and
manipulation but does not change any existing behavior. Thus, this
module is backwards compatible with Voice XML 2.1.</p>

<p>Likewise, the VoiceXML 2.1 profile in VoiceXML 3.0 is not
required to support any of the new features added in this module.
In particular, the following features may be excluded by
implementors supporting the VoiceXML 2.1 profile.</p>

<a name="voicexml21_profile_exclusions"
id="voicexml21_profile_exclusions" />
<table>
<caption>Table 60: VoiceXML 2.1 profile exclusions</caption>

<tbody>
<tr>
<th>properties$ implicit variable</th>
<td>The VoiceXML 2.1 profile does not require the properties$
implicit variable to be supported in any scopes.</td>
</tr>

<tr>
<th>"scope" attribute</th>
<td>The optional "scope" attribute is not required to be supported
in the VoiceXML 2.1 profile for the &lt;var&gt;, &lt;value&gt;,
&lt;assign&gt;, &lt;data&gt; and &lt;clear&gt; elements.</td>
</tr>

<tr>
<th>&lt;var&gt; and &lt;assign&gt; children</th>
<td>The VoiceXML 2.1 profile does not require in-line
specifications for the initial value using the children of the
&lt;var&gt; element or in-line specifications for the new value
using the children of the &lt;assign&gt; element to be
supported.</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="d1e1757" id="d1e1757" />6.12.5 Implicit functions
using XPath</h4>

<p>Implicit variables described in section 2.2.3 to qualify scope
are amenable to certain data access and manipulation languages
(such as ECMAScript) but are not as elegant while incorporating in
the syntax of others, such as XPath. VoiceXML 3.0 permits the use
of functions rather than variables to address this. The following
table illustrates how scope qualifiers are exposed as XPath
functions.</p>

<table border="1">
<caption>Table 61: Implicit XPath functions and variables</caption>

<tbody>
<tr>
<th>session()</th>
<td>This single String argument function retrieves the value of the
variable named in the argument from the session scope.</td>
</tr>

<tr>
<th>application()</th>
<td>This single String argument function retrieves the value of the
variable named in the argument from the application scope.</td>
</tr>

<tr>
<th>document()</th>
<td>This single String argument function retrieves the value of the
variable named in the argument from the document scope.</td>
</tr>

<tr>
<th>dialog()</th>
<td>This single String argument function retrieves the value of the
variable named in the argument from the dialog scope.</td>
</tr>

<tr>
<th>anonymous()</th>
<td>This single String argument function retrieves the value of the
variable named in the argument from the anonymous scope.</td>
</tr>

<tr>
<th>properties$</th>
<td>This read-only implicit variable refers to the defined
properties which affect platform behavior in a given scope. The
value is an XML tree with a &lt;properties&gt; root element and
multiple children as necessary where each child element has the
name of an existing platform property in that scope and body
content corresponding to the value of the platform property. CDATA
sections are used if necessary.</td>
</tr>
</tbody>
</table>

<p>The following table shows how these qualifier functions are
used, and the examples are XPath variants of the examples
illustrated in Table 53.</p>

<table>
<caption>Table 62: Resolution examples (XPath)</caption>

<thead>
<tr>
<td>Usage</td>
<td>Result</td>
</tr>
</thead>

<tbody>
<tr>
<td><em>application('hello')</em></td>
<td>The value of the "hello" named variable in the application
scope.</td>
</tr>

<tr>
<td><em>dialog('retries')</em></td>
<td>The value of the "retries" named variable in the dialog
scope.</td>
</tr>

<tr>
<td><em>dialog('properties$')/bargein</em></td>
<td>The value of the "bargein" platform property defined at the
current "dialog" scope.</td>
</tr>
</tbody>
</table>

<div class="issue">
<p class="prefix"><a name="DataProfiles"
id="DataProfiles" /><b>Issue (DataProfiles):</b></p>

<p class="prefix"><b>Data profiles?</b></p>

<p>Consider moving contents into a profile that includes an XML
Data Model and XPath Data Access and Manipulation. Generically,
consider profiles for various data access and manipulation
languages, including an ECMA profile.</p>

<p class="prefix"><b>Resolution:</b></p>

<p>None recorded.</p>
</div>
</div>
</div>

<div class="div2">
<h3><a name="ExternalCommunicationModule"
id="ExternalCommunicationModule" />6.13 External Communication
Module</h3>

<p>This module supports the sending and receiving of external
messages by a voice application by introducing the &lt;send&gt; and
&lt;receive&gt; elements into VoiceXML. The application developer
chooses to send and receive external messages synchronously or
asynchronously. When sending a message, the developer chooses
whether or not it should represent a named event. The developer
also chooses whether or not to include a payload. These choices can
be made statically or dynamically at run-time.</p>

<p>Note that this section only covers receiving messages that the
interpreter does not handle. In other words, at application level
events. Some events, like lifecycle events targeted at creating or
destroying sessions are not targetted at the application author but
instead are handled by the browser itself. The complete list of all
these interpreter level events is TBD but might include events such
as "create session", "pause", "resume", or "disconnect".</p>

<p>Although this section handles many of the easy and moderately
difficult cases, for certain very complicated cases it may be
appropriate to put a gatekeeper filter between the VXML interpreter
and the external events to filter and only allow certain events to
interrupt the processing of the VXML document. For example if
someone wanted a "operator" event to only be allowed to interrupt
the VXML document if its data variable held a certain value, or if
they wanted the "operator" event but not the "caller" event, then a
filter might be appropriate. SCXML is one method that is suitable
for providing these type of more advanced filters.</p>

<div class="div3">
<h4><a name="ExternalCommunicationModule:Receive"
id="ExternalCommunicationModule:Receive" />6.13.1 Receiving
external messages within a voice application</h4>

<p>Because external messages can arrive at any time, they can be
disruptive to a voice application. A voice application developer
decides whether these messages are delivered to the application
synchronously or asynchronously using the "externalevents.enable"
property. The property can be set to one of the following
values:</p>

<a name="receive:externalevents.enable"
id="receive:externalevents.enable" />
<table>
<caption>Table 63: externalevents.enable values</caption>

<tbody>
<tr>
<th>true</th>
<td>External messages are delivered asynchronously as VoiceXML
events.</td>
</tr>

<tr>
<th>false</th>
<td>External messages are delivered synchronously. This is the
default.</td>
</tr>
</tbody>
</table>

<p>When external messages are delivered synchronously, an
application developer decides whether these messages are preserved
or discarded by setting the "externalevents.queue" property. The
property can be set to one of the following values:</p>

<table>
<caption>Table 64: externalevents.queue values</caption>

<tbody>
<tr>
<th>true</th>
<td>External messages are queued.</td>
</tr>

<tr>
<th>false</th>
<td>An external messages that is not delivered as a VoiceXML event
is discarded. This is the default.</td>
</tr>
</tbody>
</table>

<div class="div4">
<h5><a name="ExternalCommunicationModule:ReceiveReflect"
id="ExternalCommunicationModule:ReceiveReflect" />6.13.1.1 External
Message Reflection</h5>

<p>If "externalevents.enable" is set to true and an external
message arrives, the external message is reflected to the
application in the application.lastmessage$ variable.
application.lastmessage$ is an ECMAScript object with the following
properties:</p>

<table>
<caption>Table 65: application.lastmessage$ properties</caption>

<tbody>
<tr>
<th>contenttype</th>
<td>The media type of the external message.</td>
</tr>

<tr>
<th>event</th>
<td>The event name, if any, or ECMAScript undefined if no event
name was included in the external message.</td>
</tr>

<tr>
<th>content</th>
<td>The content of the message, if any, or ECMAScript undefined. If
the Content-Type of the message is one of the media types described
in [RFC 3023], the VoiceXML interpreter must expose the retrieved
content via a read-only subset of the DOM as described in [VXML21].
An interpreter may support additional data formats by recognizing
additional media types. If an interpreter receives an external
message with a payload in a data format that it does not
understand, or the payload is not well-formed as defined by the
specification of that format, the interpreter throws
"error.badfetch".</td>
</tr>
</tbody>
</table>

<p>If no external messages have been received,
application.lastmessage$ is ECMAScript undefined. Only the last
received message is available. To preserve a message for future
reference during the lifetime of the application, the application
developer can copy the data to an application-scoped variable.</p>
</div>

<div class="div4">
<h5><a name="ExternalCommunicationModule:ReceiveAsync"
id="ExternalCommunicationModule:ReceiveAsync" />6.13.1.2 Receiving
External Messages Asynchronously</h5>

<p>To receive an external message asynchronously, an application
defines an "externalmessage" event handler. The event handler must
be declared within the appropriate scope since the user-defined
&lt;catch&gt; handler is selected using the algorithm described in
section 5.2.4 of [VXML2].</p>

<p>If the payload of an external message includes an event name,
the name is appended to the name of the event that is thrown to the
application separated by a dot (e.g. "externalmessage.ready"). This
allows applications to handle external messages using different
event handlers.</p>

<p>Asynchronous external messages are processed in the same manner
that a disconnect event is handled in <a
href="http://www.w3.org/TR/2004/REC-voicexml20-20040316/">VXML2</a>.</p>

<p>Events are dispatched to the application serially. Since the
interpreter only reflects the data associated with a single
external message at a time, it is the application's responsibility
to manage the data associated with each external message once that
message has been delivered.</p>

<p>The following example demonstrates asynchronous receipt of an
external message. The catch handler copies the reflected external
message into an array at application scope.</p>

<div class="exampleInner">
<pre>
&lt;vxml version="2.1"
  xmlns="http://www.w3.org/2001/vxml"&gt;
  &lt;property name="externalevents.enable" value="true"/&gt;
  &lt;var name="myMessages" expr="new Array()"/&gt;

  &lt;catch event="externalmessage"&gt;
    &lt;var name="lm" expr="application.lastmessage$"/&gt;
    &lt;if cond="lm.contenttype == 'text/xml' || lm.contenttype == 'application/xml'"&gt;
      &lt;log&gt;received XML with root document element
        &lt;value expr="lm.content.documentElement.nodeName"/&gt;
      &lt;/log&gt;
    &lt;elseif cond="typeof lm.content == 'string'"/&gt;
      &lt;log&gt;received &lt;value expr="lm.content"/&gt;&lt;/log&gt;
    &lt;else/&gt;
      &lt;log&gt;received unknown external message type
        &lt;value expr="typeof lm.content"/&gt;
      &lt;/log&gt;
    &lt;/if&gt;
    &lt;script&gt;
      myMessages.push({'content' : lm.content, 'ctype' : lm.contenttype});
    &lt;/script&gt;
  &lt;/catch&gt;

  &lt;form&gt;
  &lt;field name="num" type="digits"&gt;
    &lt;prompt&gt;pick a number any number&lt;/prompt&gt;
    &lt;catch event="noinput nomatch"&gt;
      sorry. didn't get that.
      &lt;reprompt/&gt;      
    &lt;/catch&gt;
    &lt;filled&gt;
      you said &lt;value expr="num"/&gt;
      &lt;clear/&gt;
    &lt;/filled&gt;
  &lt;/field&gt;
  &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>

<div class="div4">
<h5><a name="ExternalCommunicationModule:ReceiveSync"
id="ExternalCommunicationModule:ReceiveSync" />6.13.1.3 Receiving
External Messages Synchronously</h5>

<p>To receive an external message synchronously set the
"externalevents.enable" property to false and the
"externalevents.queue" property to true, and use the
&lt;receive&gt; element to pull messages off the queue.
&lt;receive&gt; blocks until an external message is received or the
timeout specified by the maxtime attribute is exceeded.</p>

<div class="div5">
<h6><a name="ExternalCommunicationModule:ReceiveSyncReceive"
id="ExternalCommunicationModule:ReceiveSyncReceive" />6.13.1.3.1
&lt;receive&gt;</h6>

<p>To support receipt of external messages within a voice
application, use the &lt;receive&gt; element. &lt;receive&gt; is
allowed wherever <em>executable content</em> is allowed in
[VXML21], for example a &lt;block&gt; element.</p>

<p>&lt;receive&gt; supports the following attributes:</p>

<table>
<caption>Table 66: &lt;receive&gt; properties</caption>

<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Required</th>
<th>Default</th>
</tr>
</thead>

<tbody>
<tr>
<th>fetchaudio</th>
<td>See Section 6.1 of [VXML2]. This defaults to the fetchaudio
property described in Section 6.3.5 of [VXML2].</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>fetchaudioexpr</th>
<td>An ECMAScript expression evaluating to the fetchaudio URI. If
evaluation of the expression fails, the interpreter throws
"error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>maxtime</th>
<td>A W3C time specifier indicating the maximum amount of time the
interpreter waits to receive an external message. If the timeout is
exceeded, the interpreter throws "error.badfetch." A value of
"none" indicates the interpreter blocks indefinitely.</td>
<td>No</td>
<td>0s</td>
</tr>

<tr>
<th>maxtimeexpr</th>
<td>An ECMAScript expression evaluating to the maxtime value. If
evaluation of the expression fails, the interpreter throws
"error.semantic".</td>
<td>No</td>
<td>0s</td>
</tr>
</tbody>
</table>

<p>Only one of fetchaudio and fetchaudioexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of maxtime and maxtimeexpr can be specified or
"error.badfetch" is thrown.</p>

<p>When present, the attributes fetchaudioexpr and maxtimeexpr are
evaluated when the &lt;receive&gt; is executed.</p>

<p>The following example demonstrates synchronously receiving an
external message. In this example, the interpreter blocks for up to
15 seconds waiting for an external message to arrive. If no
external message is received during that interval, the interpreter
throws "error.badfetch". If a message is received, the interpreter
proceeds by executing the &lt;log&gt; element.</p>

<div class="exampleInner">
<pre>
&lt;vxml version="2.1"
  xmlns="http://www.w3.org/2001/vxml"&gt;

  &lt;property name="externalevents.queue" value="true"/&gt;
  &lt;form&gt;
    &lt;catch event="error.badfetch"&gt;
      &lt;log&gt;timed out waiting for external message&lt;/log&gt;
    &lt;/catch&gt;
  
    &lt;block&gt;
      Hold on ...
      &lt;receive maxtime="15s" 
        fetchaudio="http://www.example.com/audio/fetching.wav"/&gt;
      &lt;log&gt;got &lt;value expr="application.lastmessage$.content"/&gt;&lt;/log&gt;
    &lt;/block&gt;  
  &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>
</div>
</div>

<div class="div3">
<h4><a name="ExternalCommunicationModule:Send"
id="ExternalCommunicationModule:Send" />6.13.2 Sending messages
from a voice application</h4>

<p>To send a message from a VoiceXML application to a remote
endpoint, use the &lt;send&gt; element. &lt;send&gt; is allowed
within <em>executable content</em>. Implementations must support
the following attributes:</p>

<table>
<caption>Table 67: &lt;send&gt; Attributes</caption>

<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Required</th>
<th>Default</th>
</tr>
</thead>

<tbody>
<tr>
<th>async</th>
<td>A boolean indicating whether or not to block until the final
response to the transaction created by sending the external event
is received, or a timeout.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>asyncexpr</th>
<td>An ECMAScript expression evaluating to the value of the async
attribute. If evaluation of the expression fails, the interpreter
throws "error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>body</th>
<td>A string representing the data to be sent in the body of the
message.</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>bodyexpr</th>
<td>An ECMAScript expression evaluating to the body of the message
to be sent. If evaluation of the expression fails, the interpreter
throws "error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>contenttype</th>
<td>A string indicating the media type of the body being sent, if
any. The set of content types may be limited by the underlying
platform. If an unsupported media type is specified, the
interpreter throws "error.badfetch.&lt;protocol&gt;.400." The
interpreter is not required to inspect the data specified in the
body to validate that it conforms to the specified media type.</td>
<td>No</td>
<td>text/plain</td>
</tr>

<tr>
<th>contenttypeexpr</th>
<td>An ECMAScript expression evaluating to the media type of the
body. If evaluation of the expression fails, the interpreter throws
"error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>event</th>
<td>The name of the event to send. The value is a string which only
includes alphanumeric characters and the "." (dot) character. The
first character must be a letter. If the value is invalid, then an
"error.badfetch" event is thrown.</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>eventexpr</th>
<td>An ECMAScript expression evaluating to the name of the event to
be sent. If evaluation of the expression fails, the interpreter
throws "error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>fetchaudio</th>
<td>See Section 6.1 of [VXML2]. This defaults to the fetchaudio
property described in Section 6.3.5 of [VXML2].</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>fetchaudioexpr</th>
<td>An ECMAScript expression evaluating to the fetchaudio URI. If
evaluation of the expression fails, the interpreter throws
"error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>namelist</th>
<td>A list of zero or more whitespace-separated variable names to
send. By default, no variables are submitted. Values for these
variables are evaluated when the &lt;send&gt; element is executed.
Only declared variables can be referenced; otherwise,
"error.semantic" is thrown. Variables must be submitted to the
server with the same qualification used in the namelist. When an
ECMAScript variable is submitted to the server, its value must be
converted first into a string before being sent. If the variable is
an ECMAScript object, the mechanism by which it is submitted is
platform-specific. Instead of submitting an ECMAScript object
directly, the application developer can explicitly submit the
individual properties of the object (e.g. "date.month
date.year").</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>target</th>
<td>Specifies the URI to which the event is sent. If the attribute
is not specified, the event is sent to the component which invoked
the VoiceXML session.</td>
<td>No</td>
<td>Invoking component</td>
</tr>

<tr>
<th>targetexpr</th>
<td>An ECMAScript expression evaluating to the target URI. If
evaluation of the expression fails, the interpreter throws
"error.semantic".</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>timeout</th>
<td>See <a
href="#ExternalCommunicationModule:SendTimeout"><b>6.13.2.1
sendtimeout</b></a>. This defaults to the sendtimeout
property.</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<th>timeoutexpr</th>
<td>An ECMAScript expression evaluating to the timeout interval for
a synchronous &lt;send&gt;. If evaluation of the expression fails,
the interpreter throws "error.semantic"</td>
<td>No</td>
<td>N/A</td>
</tr>
</tbody>
</table>

<p>Only one of async and asyncexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of event or eventexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of body, bodyexpr, namelist, event, or eventexpr must
be specified or "error.badfetch" is thrown.</p>

<p>Only one of contenttype and contenttypeexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of fetchaudio and fetchaudioexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of target and targetexpr can be specified or
"error.badfetch" is thrown.</p>

<p>Only one of timeout and timeoutexpr can be specified or
"error.badfetch" is thrown.</p>

<p>When present, the attributes asyncexpr, bodyexpr,
contenttypeexpr, eventexpr, fetchaudioexpr, targetexpr, and
timeoutexpr are evaluated when the &lt;send&gt; is executed.</p>

<p>If a synchronous &lt;send&gt; succeeds, execution proceeds
according to the Form Interpretation Algorithm. If the &lt;send&gt;
times out, the interpreter throws "error.badfetch" to the
application. If the interpreter encounters an error upon sending
the external message, the interpreter throws
"error.badfetch.&lt;protocol&gt;.&lt;status_code&gt;" to the
application. If no status code is available, the interpreter throws
"error.badfetch.&lt;protocol&gt;".</p>

<p>The following example demonstrates the use of &lt;send&gt;
synchronously:</p>

<div class="exampleInner">
<pre>
&lt;vxml version="2.1"
  xmlns="http://www.w3.org/2001/vxml"&gt;

  &lt;form&gt;
  &lt;field name="user_id" type="digits"&gt;
    &lt;prompt&gt;please type your five digit i d&lt;/prompt&gt;
    &lt;filled&gt;
      &lt;send async="false" 
            bodyexpr="'&amp;lt;userinfo&amp;gt;&amp;lt;id&amp;gt;' + user_id + '&amp;lt;/id&amp;gt;&amp;lt;/userinfo&amp;gt;'" 
            contenttype="text/xml"/&gt;
      &lt;goto next="mainmenu.vxml"/&gt;
    &lt;/filled&gt;
  &lt;/field&gt;
  &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>

<p>Upon executing an asynchronous &lt;send&gt;, the interpreter
continues execution of the voice application immediately and
disregards the disposition of the message that was sent.</p>

<p>The following example demonstrates the use of &lt;send&gt;
asynchronously:</p>

<div class="exampleInner">
<pre>
&lt;vxml version="2.1"
  xmlns="http://www.w3.org/2001/vxml"&gt;

  &lt;form&gt;
    &lt;var name="tasktarget" expr="'http://www.example.com/taskman.pl'"/&gt;
    &lt;var name="taskname" expr="'cc'"/&gt;
    &lt;var name="taskstate"/&gt;
    &lt;block&gt;
      &lt;assign name="taskstate" expr="'start'"/&gt;     
      &lt;send async="true" 
            targetexpr="tasktarget" 
            namelist="taskname taskstate"/&gt;
    &lt;/block&gt;
    &lt;field name="ccnum"/&gt;
    &lt;field name="expdate"/&gt;
    &lt;block&gt;
      &lt;assign name="taskstate" expr="'end'"/&gt;     
      &lt;send async="true" 
            targetexpr="tasktarget" 
            namelist="taskname taskstate"/&gt;
    &lt;/block&gt;
  &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>

<div class="div4">
<h5><a name="ExternalCommunicationModule:SendTimeout"
id="ExternalCommunicationModule:SendTimeout" />6.13.2.1
sendtimeout</h5>

<p>The sendtimeout property controls the interval to wait for a
synchronous &lt;send&gt; to return before an "error.badfetch" event
is thrown. The value is a Time Designation as specified in <a
href="http://www.w3.org/TR/2004/REC-voicexml20-20040316/#dml6.5">Section
6.5</a> of [VXML2]. If not specified, the value is derived from the
innermost sendtimeout property.</p>
</div>
</div>
</div>

<div class="div2">
<h3><a name="SessionRootModule" id="SessionRootModule" />6.14
Session Root Module</h3>

<p>The session root module allows for a VXML document to exist
across a VXML session (I.e., transition from one application to
another) similar to the way an application root document allows for
a VXML document to exist across VXML document transitions.</p>

<div class="div3">
<h4><a name="SessionRootModule:Syntax"
id="SessionRootModule:Syntax" />6.14.1 Syntax</h4>

<p>The syntax of the session root module defines the addition of
two attributes on the root &lt;vxml&gt; element. These two new
attributes are summarized below.</p>

<a name="sessionroot:attributes" id="sessionroot:attributes" />
<table>
<caption>Table 68: Table: Two new &lt;vxml&gt; Attributes for
Session Root Module</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>session</th>
<td>URI</td>
<td>URI location of document to be loaded as session root</td>
<td>No</td>
<td>N/A</td>
</tr>

<tr>
<td>requiresession</td>
<td>Boolean</td>
<td>if the error of a duplicated new session root should fail the
document</td>
<td>No</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="SessionRootModule:Semantics"
id="SessionRootModule:Semantics" />6.14.2 Semantics</h4>

<p>The session attribute is an optional attribute on vxml tag. It
is a URI reference just like the application attribute is (same URI
resolution). If a VXML session has not yet encountered a document
with a session root then upon encountering the first vxml document
that has a session root, the session root document is loaded and
parsed just like how a normal vxml document would load and parse an
application root document. If a VXML session has already loaded a
different session root then the behavior when a future session
attributes is encountered is controlled by the requiresession
attribute. If the requiresession attribute is true then
encountering a session root attribute with a different URL then the
already loaded session root is an error and an error.badfetch is
generated. If the requiresession attribute is false then the new
session attribute is ignored and the old one is used. The
requiresession attribute defaults to false if not present. The
behavior of the session root is completely the same as the behavior
of the application root, except that while executing in the session
root the vxml browser is allowed to write to the javascript session
scope, and variables declared as child of the vxml tag thus become
session scope variables. In particular, in <a
href="http://www.w3.org/TR/voicexml20/#dml5.1.2">VXML 2.0 section
5.1.2</a> when talking about the variable scopes the text for
application in table 40 is also appropriate for session (new text
"These are declared with &lt;var&gt; and &lt;script&gt; elements
that are children of the session root document's &lt;vxml&gt;
element. They are initialized when the session root document is
loaded. They exist while the session document is loaded, and are
visible to the session root document, the application root
document, and any other loaded application leaf document.").</p>

<p>This session document then is loaded and active in the hierarchy
of documents that follows the javascript scope chaining (that is a
document is below an application root is below a session root).
This means that if a variable is declared in the session root and
then in some local form in the leaf document the variable would be
shadowed (just like how the shadowing from the application
root).</p>

<p>This also implies that the catch selection algorithm as
described in <a
href="http://www.w3.org/TR/voicexml20/#dml5.2.4">VXML 2.0 section
5.2.4</a> would have to change to include the session root document
as a potential source of catch handlers (new text "Form an ordered
list of catches consisting of all catches in the current scope and
all enclosing scopes (form item, form, document, application root
document, session root document, interpreter context), ordered
first by scope (starting with the current scope), and then within
each scope by document order."). Then all catch handling would
remain the same, in particular the as-if-by copy semantics are
retained so if an event from a leaf document was handled by a catch
handler from the session root the catch handler wouldn't execute
within the context of the session root document but would instead
execute as if by copy into the local leaf document context.</p>

<p>This also implies that property lookup from <a
href="http://www.w3.org/TR/voicexml20/#dml6.3">section 6.3 of VXML
2.0</a> would have to change to say that property value lookup can
also go to the session root, if a more local value for the property
isn't found (new text "Properties may be defined for the whole
session, for the whole application, for the whole document at the
&lt;vxml&gt; level, for a particular dialog at the &lt;form&gt; or
&lt;menu&gt; level, or for a particular form item.). This doesn't
change the usual way properties work where a property at a lower
level override one at a higher level.</p>

<p>This also implies that the behavior for link's that are
document-level link of session roots are active which would be a
change to <a href="http://www.w3.org/TR/voicexml20/#dml2.5">section
2.5 of VXML 2.0</a> (new text "If an application root document has
a document-level link, its grammars are active no matter what
document of the application is being executed. If an session root
document has a document-level link, its grammars are active no
matter what document of the session is being executed. If execution
is in a modal form item, then link grammars at the form, document,
application or session level are not active.").</p>

<p>Similar to for links, the scope of grammars from <a
href="http://www.w3.org/TR/voicexml20/#dml3.1.3">section 3.1.3 of
VXML 2.0</a> would be changed to specify what happens when a
grammar from a session root has document scope (new text "Form
grammars are by default given dialog scope, so that they are active
only when the user is in the form. If they are given scope
document, they are active whenever the user is in the document. If
they are given scope document and the document is the application
root document, then they are also active whenever the user is in
another loaded document in the same application. If they are given
scope document and the document is the session root document, then
they are also active throughout the session.". Note that this
active throughout the session can still be trumped by modal listen
states (just like the application root can). <a
href="http://www.w3.org/TR/voicexml20/#dml3.1.4">Section 3.1.4 of
VXML 2.0</a> also changes the activation of grammars bulleted list
to include the session root (new text: "grammars contained in links
in its application root document or session root document, and
grammars for menus and forms in its application root document or
session root document which are given document scope.").</p>
</div>

<div class="div3">
<h4><a name="SessionRootModule:examples"
id="SessionRootModule:examples" />6.14.3 Examples</h4>

<p>For the sake of compactness assume throughout this example that
the single letters used are actually fully qualified URIs. A VXML
document "A" transitions to VXML document "B" which is partially
represented below:</p>

<div class="exampleInner">
<pre>
&lt;vxml session="C" application="D" … &gt;
</pre>
</div>

<p>Before "B" can finish initialization of "B" it loads, parses,
and initializes the VXML documents at both "C" and "D". While
executing in "B" any grammars, properties, links, and variables
included from either "C" or "D" influence execution. Document "B"
then transitions to document "E", with no session attribute,
partially represented below:</p>

<div class="exampleInner">
<pre>
&lt;vxml application="D" … &gt;
</pre>
</div>

<p>While executing in "E" having come from "B", everything from
both "C" and "D" are still active. "D" is still active as we
haven't left the application yet. "C" is still active as we are
part of the same session. Document "E" now transitions to document
"F" partially represented below:</p>

<div class="exampleInner">
<pre>
&lt;vxml application="G" … &gt;
</pre>
</div>

<p>Now, since we have changed applications, the application root
document form "D" is unloaded and grammars, variables, properties,
etc. from "D" are no longer influencing our execution. Document "G"
defines our application root and it, along with "C" which is still
active since we are in the same session, now influence our
execution. Document "F" now transitions to "H" partially
represented below:</p>

<div class="exampleInner">
<pre>
&lt;vxml session="I" … &gt;
</pre>
</div>

<p>Now, since there is already "C" as our session root document
defined we cannot load document "I" and treat this as our session
root. In the absence of requiresession "I" is ignored and "H" is
executed using "C" as our session document. If instead "H" looked
as below:</p>

<div class="exampleInner">
<pre>
&lt;vxml session="I" requiresession="true" … &gt;
</pre>
</div>

<p>Now "H" would fail to load and execution would revert to
document "F" where the appropriate error.badfetch for "H" would be
thrown.</p>
</div>
</div>

<div class="div2">
<h3><a name="RunTimeControl" id="RunTimeControl" />6.15 Run Time
Control Module</h3>

<p>Run time controls are represented by voice or dtmf grammars that
are always active, even when the interpreter is not waiting for
user input (e.g., when transitioning between documents.) When the
grammar representing the rtc is matched, the action specified by
the rtc is taken. When an rtc grammar completes recognition, it is
immediately restarted whether it matched the input or not. Other
grammars, including standard recognition grammars, may be active at
the same time as an rtc.</p>

<div class="div3">
<h4><a name="d3e6567" id="d3e6567" />6.15.1 &lt;rtc&gt;</h4>

<div class="div4">
<h5><a name="d3e6570" id="d3e6570" />6.15.1.1 Syntax</h5>

<a name="rtc:attributes" id="rtc:attributes" />
<table>
<caption>Table 69: Table: &lt;rtc&gt; Attributes</caption>

<tbody>
<tr>
<th>grammar</th>
<td>The uri of the grammar defining the rtc.</td>
</tr>

<tr>
<th>priority</th>
<td>The priority of the rtc relative to other rtc grammars.</td>
</tr>

<tr>
<th>action</th>
<td>The action to take when the grammar matches.</td>
</tr>

<tr>
<th>params</th>
<td>One or more parameters that modify the action.</td>
</tr>

<tr>
<th>leadingsilence</th>
<td>Indicates the amount of silence that must precede the
utterance.</td>
</tr>

<tr>
<th>trailingsilence</th>
<td>Indicates the amount of silence that must follow the
utterance.</td>
</tr>
</tbody>
</table>

<p>Possible values for 'action' and 'params' are as follows:</p>

<ul>
<li>volume. Adjusts the volume of prompts. params is a signed
integer indicating number of DBs.</li>

<li>speed. Adjusts the speed of prompts. params is a signed integer
indicating the number of words per minute.</li>

<li>skip. Moves forward or back in the current prompt. params is a
signed integer indicating the number of milliseconds.</li>

<li>cancel. Cancels the execution of the current control item.
Values of params are ignored.</li>

<li>goto. Cancels the execution of the current control item and
jumps to another location. params is a string giving the url of
that location.</li>
</ul>
</div>
</div>

<div class="div3">
<h4><a name="d3e6620" id="d3e6620" />6.15.2 &lt;cancelrtc&gt;</h4>

<p>&lt;cancelrtc&gt; can be used to cancel an rtc defined by the
&lt;rtc&gt; element. Note that rtcs are identified by their
grammars.</p>

<div class="div4">
<h5><a name="d3e6625" id="d3e6625" />6.15.2.1 Syntax</h5>

<a name="cancelrtc:attributes" id="cancelrtc:attributes" />
<table>
<caption>Table 70: Table: &lt;cancelrtc&gt; Attributes</caption>

<tbody>
<tr>
<th>grammar</th>
<td>The name of the rtc to cancel. '*' cancels all rtcs.</td>
</tr>
</tbody>
</table>
</div>
</div>

<p>Both &lt;rtc&gt; and &lt;cancelrtc&gt;are scoped to the nearest
enclosing control element (&lt;item&gt;,&lt;form&gt;, ...). If not
within a control element, they are scoped to the document they are
in. A given rtc may be defined multiple times within an
application. At any point during execution, the most narrowly
scoped &lt;rtc&gt; or &lt;cancelrtc&gt; element will be in effect.
If an active rtc is turned off by a &lt;cancelrtc&gt; tag, it will
be reactivated when the interpreter leaves the scope of the
&lt;cancelrtc&gt; tag (unless it comes within the scope of another
&lt;cancelrtc&gt; tag). For example, if an &lt;rtc&gt; tag is
scoped to a &lt;form&gt; and a &lt;cancelrtc&gt; tag is scoped to a
field within the &lt;form&gt;, the rtc will be active while the
form is executing, except when it is the field in question.
Application authors may thus use the &lt;rtc&gt; and
&lt;cancelrtc&gt; tags along with the scoping rules to exercize
fine grained control over the activity of rtcs.</p>

<div class="div3">
<h4><a name="d3e6639" id="d3e6639" />6.15.3 Semantics</h4>

<p>Logically rtc grammars behave as a prefilter on the speech
stream, replacing any input they match with silence. Since rtc
grammars operate upstream of normal recognition grammars, the
recognition grammars never see input that matched an rtc grammar.
Thus input that matches an rtc grammar will not trigger barge in,
since barge-in is triggered only by input matching a normal
recognition grammar. Since rtc grammars apply upstream of
recognition grammars, all rtc grammars have, in effect, a higher
priority than any recognition grammar. Thus the priority attribute
on an rtc grammar affects its priority only relative to other rtc
grammars.</p>

<p>When processing speech or type-ahead input, rtcs again apply
upstream of normal speech grammars. Remember also that rtcs may be
active even when the system is not in the wait state, so they may
match the input while it is being entered and other grammars are
not active.</p>

<p>The platform executes the 'volume', 'speed' and 'skip' actions
immediately, as soon as the rtc grammar matches. The platform also
executes the 'cancel' and 'goto' actions automatically, but only
once the interpreter is in an event-processing state. Thus the
platform may complete the processing of non-interruptable tasks
before it processes the 'cancel' or 'goto' actions.</p>
</div>

<div class="div3">
<h4><a name="d3e6648" id="d3e6648" />6.15.4 Examples</h4>

<p>T.B.D.</p>
</div>
</div>

<div class="div2">
<h3><a name="SIV" id="SIV" />6.16 SIV Module</h3>

<p>Speaker biometric resources supported in VoiceXML 3.0 provide
three types of functions:</p>

<ul>
<li>Speaker Verification</li>

<li>Speaker Identification</li>

<li>Speaker Enrollment</li>
</ul>

<p>The following figure shows an overview of the flow of
information in SIV processing:</p>

<p><img class="center" src="Images/overview.png"
alt="Overview of SIV processing information flow" /></p>

<p>The SIV engine computes a match based on one or more utterances
from the user, a voicemodel or reference voice model, thresholds
and other configuration parameters. The results are presented to
VoiceXML in EMMA 1.0 format.</p>

<p>Verification is the process by which a user's utterances are
matched against a pre-computed reference voice model. The next
figure details this process.</p>

<p><img class="center" src="Images/verify.png"
alt="Verification process" /></p>

<p>Verification decisions are based upon a wide variety of
criteria, and applications must choose how to evaluate trade-offs
between application-specific factors:</p>

<a name="SIV:decision" id="SIV:decision" />
<table border="1" cellpadding="2" cellspacing="2"
summary="summary">
<caption>Table 71: Decision/Match Evaluation</caption>

<tbody>
<tr>
<td>Good Enough</td>
<td>
<ul>
<li>Individual and cumulative matches are in the range above the
specified threshold</li>
</ul>
</td>
</tr>

<tr>
<td>More Data Needed</td>
<td>
<ul>
<li>Individual utterance or match was low quality</li>

<li>Below threshold, above abort criteria</li>

<li>Reprompt to collect more data:</li>

<li>
<ul>
<li>discard utterance, collect replacement</li>

<li>keep utterance, add additional</li>
</ul>
</li>
</ul>
</td>
</tr>

<tr>
<td>Abort</td>
<td>
<ul>
<li>Below lower specified threshold</li>

<li>Too many attempts or bad matches</li>
</ul>
</td>
</tr>
</tbody>
</table>

<div class="div3">
<h4><a name="d3e6720" id="d3e6720" />6.16.1 SIV Core Functions</h4>

<p>The core functions of SIV processing are divided into creating a
voice model and enrolling a user in the system (Enrollment) and
using a pre-existing voice model (either Verification or
Identification). Additionally, some engines support adaptation of
an existing voice model based on new user utterances. An SIV dialog
may consist of a sequence of one or more SIV dialog turns.</p>

<p>The SIV resource is defined in terms of a data model and state
model. The data model is composed of the following elements:</p>

<ul>
<li>activeVoiceModel: 

<ul>
<li>content: a URI reference to the voice model (or the voice model
itself) with which to perform verification or identification.</li>

<li>properties: type, vendor, etc.</li>

<li>listener: a resource controller associated with this SIV
resource</li>
</ul>
</li>

<li>properties: properties pertaining to the SIV process. These
properties differ depending on the type of the SIV resource type
and function 

<ul>
<li>Resource type 

<ul>
<li>text-dependent</li>

<li>text-independent</li>

<li>other types</li>
</ul>
</li>

<li>Function 

<ul>
<li>Enrollment</li>

<li>Verification</li>

<li>Identification</li>
</ul>
</li>

<li>Platform-specific</li>
</ul>
</li>

<li>controller: the resource controller to which status, results
and error events are sent.</li>
</ul>

<p>An SIV Resource manages SIV devices during a processing
cycle:</p>

<ul>
<li>An SIV cycle is initiated when the resource sends the device an
event instructing it to listen to the input stream.</li>

<li>An SIV cycle is terminated if the device is instructed to stop
by the resource, if the device sends the resource an error event,
or the device ends processing early. When terminated, the device
removes partially or wholly processed input from its buffer and
discards the voicemodel.</li>

<li>During an SIV cycle, the device may send events to the resource
indicating ongoing status.</li>

<li>When the resource receives results from the device during the
SIV cycle, it passes them to its controller. At this point the SIV
cycle is complete and the resource awaits instructions either to
start another SIV cycle or to terminate.</li>
</ul>
</div>

<div class="div3">
<h4><a name="d3e6773" id="d3e6773" />6.16.2 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<p>The &lt;voicemodel&gt; element has the attributes specified in
Table 72, in addition to the fetchtimeout, fetchhint, maxage, and
maxstale attributes as specified in <a href="#Fetching"><b>8.1.1
Fetching</b></a>.</p>

<a name="SIV:attributes" id="SIV:attributes" />
<table border="1" cellpadding="0" width="99%" summary="summary">
<caption>Table 72: &lt;voicemodel&gt; Attributes</caption>

<tbody>
<tr>
<th>
<p>Name</p>
</th>
<th>
<p>Type</p>
</th>
<th>
<p>Description</p>
</th>
<th>
<p>Required</p>
</th>
<th>
<p>Default Value</p>
</th>
</tr>

<tr>
<th>
<p>mode</p>
</th>
<td>
<p>enroll</p>

<p>verify</p>

<p>identify</p>
</td>
<td>
<p>Defines the mode of SIV function</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p><em>None</em></p>

<p><em>If no mode is provided, throw error.badfetch</em></p>
</td>
</tr>

<tr>
<th>
<p>type</p>
</th>
<td>
<p>Text-independent</p>

<p>Text-dependent</p>

<p>[other]</p>
</td>
<td>
<p>Type of speech technology used by the SIV engine</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p><em>None</em></p>

<p>[Should V3 support "other" types?]</p>
</td>
</tr>

<tr>
<th>
<p>identity</p>
</th>
<td>
<p>URI</p>
</td>
<td>
<p>Claim of identity passed to SIV engine to select a voice
model.</p>
</td>
<td>
<p>Yes when mode="verify";</p>

<p>Must not be supplied for mode="identify"</p>

<p>If mode="enroll" and identity URI is provided, a voice model
will be created at the URI specified. Else, the form item variable
will contain the URI of the created voice model.</p>
</td>
<td>
<p>If mode="verify" and no identity is supplied, throw
error.badfetch.</p>
</td>
</tr>

<tr>
<th>
<p>fetchhint</p>
</th>
<td>
<p>One of the values "safe" or "prefetch"</p>
</td>
<td>
<p>Defines when the interpreter context should retrieve content
from the server. prefetch indicates a file may be downloaded when
the page is loaded, whereas safe indicates a file that should only
be downloaded when actually needed.</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p><em>None</em></p>
</td>
</tr>

<tr>
<th>
<p>fetchtimeout</p>
</th>
<td>
<p><a href="#TimeDesignation">Time Designation</a></p>
</td>
<td>
<p>The interval to wait for the content to be returned before
throwing an error.badfetch event.</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p><em>None</em></p>
</td>
</tr>

<tr>
<th>
<p>maxage</p>
</th>
<td>
<p>An unsigned integer</p>
</td>
<td>
<p>Indicates that the document is willing to use content whose age
is no greater than the specified time in seconds (cf. 'max-age' in
HTTP 1.1 [RFC2616]). The document is not willing to use stale
content, unless maxstale is also provided.</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p><em>None</em></p>
</td>
</tr>

<tr>
<th>
<p>maxstale</p>
</th>
<td>
<p>An unsigned integer</p>
</td>
<td>
<p>Indicates that the document is willing to use content that has
exceeded its expiration time (cf. 'max-stale' in HTTP 1.1
[RFC2616]). If maxstale is assigned a value, then the document is
willing to accept content that has exceeded its expiration time by
no more than the specified number of seconds.</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p><em>None</em></p>
</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="SIVModule:Semantics" id="SIVModule:Semantics" />6.16.3
Semantics</h4>

<p>The voicemodel RC is the primary RC for the &lt;voicemodel&gt;
element.</p>

<div class="div4">
<h5><a name="d3e7035" id="d3e7035" />6.16.3.1 Definition</h5>

<p>The voicemodel RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this voicemodel RC</li>

<li>properties: fetchtimeout, maxage, maxstale, fetchhint</li>

<li>mode: SIV mode</li>

<li>type: type of speech technology</li>

<li>identity: claim of identity for enroll and verify modes</li>
</ul>

<p>The voicemodel RC's state model consists of the following
states: Idle, Initializing, Ready, and Executing.</p>

<p>[NB: The execution model will follow the process defined for the
grammar RC.]</p>
</div>

<div class="div4">
<h5><a name="d3e1625" id="d3e1625" />6.16.3.2 Defined Events</h5>

<p>The voicemodel RC is defined to receive the following
events:</p>

<a name="SIV:receivedevents" id="SIV:receivedevents" />
<table border="1" cellpadding="0" summary="summary">
<caption>Table 73: Events received by voicemodel RC</caption>

<thead>
<tr>
<td>
<p>Event</p>
</td>
<td>
<p>Source</p>
</td>
<td>
<p>Payload</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
</thead>

<tbody>
<tr>
<td>
<p>initialize</p>
</td>
<td>
<p>any</p>
</td>
<td>
<p>controller(M)</p>
</td>
<td>
<p>causes the element and its children to be initialized</p>
</td>
</tr>

<tr>
<td>
<p>execute</p>
</td>
<td>
<p>controller</p>
</td>
<td>
<p>Adds the grammar to the appropriate Recognition Resource</p>
</td>
<td></td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<a name="SIV:sentevents" id="SIV:sentevents" />
<table border="1" cellpadding="0" summary="summary">
<caption>Table 74: Events sent by voicemodel RC</caption>

<thead>
<tr>
<td>
<p>Event</p>
</td>
<td>
<p>Target</p>
</td>
<td>
<p>Payload</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
</thead>

<tbody>
<tr>
<td>
<p>initialized</p>
</td>
<td>
<p>controller</p>
</td>
<td></td>
<td>
<p>response to initialize event indicating that it has been
successfully initialized</p>
</td>
</tr>

<tr>
<td>
<p>executed</p>
</td>
<td>
<p>controller</p>
</td>
<td></td>
<td>
<p>response to execute event indicating that it has been
successfully executed</p>
</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e1694" id="d3e1694" />6.16.3.3 External Events</h5>

<p>The external events sent and received by the voicemodel RC are
those defined in this table:</p>

<a name="SIV:externalevents" id="SIV:externalevents" />
<table border="1" cellpadding="0" summary="summary">
<caption>Table 75: voicemodel RC External Events</caption>

<tbody>
<tr>
<td>
<p>Event</p>
</td>
<td>
<p>Source</p>
</td>
<td>
<p>Target</p>
</td>
<td>
<p>Description</p>
</td>
</tr>

<tr>
<td>
<p>addVoiceModel</p>
</td>
<td>
<p>voicemodelRC</p>
</td>
<td>
<p>SIV Resource</p>
</td>
<td>
<p>Activates voicemodel</p>
</td>
</tr>

<tr>
<td>
<p>createVoiceModel</p>
</td>
<td>
<p>voicemodelRC</p>
</td>
<td>
<p>SIV Resource</p>
</td>
<td>
<p>Creates a new voicemodel</p>
</td>
</tr>

<tr>
<td>
<p>adaptVoiceModel</p>
</td>
<td>
<p>voicemodelRC</p>
</td>
<td>
<p>SIV Resource</p>
</td>
<td>
<p>Adapts the reference voice model based on the current dialog</p>
</td>
</tr>

<tr>
<td>
<p>Prefetch</p>
</td>
<td>
<p>voicemodelRC</p>
</td>
<td>
<p>SIV Resource</p>
</td>
<td>
<p>Requests that the voicemodel be fetched in advance, if
possible</p>
</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7305" id="d3e7305" />6.16.3.4 State Chart
Representation</h5>

<p>[State Chart representation TBD]</p>
</div>
</div>

<div class="div3">
<h4><a name="d3e7310" id="d3e7310" />6.16.4 Events</h4>

<p>The events in this table may be raised during initialization and
execution of the &lt;voicemodel&gt; element.</p>

<a name="SIV:voicemodelevents" id="SIV:voicemodelevents" />
<table border="1" cellpadding="0" summary="summary">
<caption>Table 76: &lt;voicemodel&gt; Events</caption>

<tbody>
<tr>
<td>
<p>Event</p>
</td>
<td>
<p>Description</p>
</td>
<td>
<p>State</p>
</td>
</tr>

<tr>
<td>
<p>error.semantic</p>
</td>
<td>
<p>indicates an error with data model expressions: undefined
reference, invalid expression resolution, etc.</p>
</td>
<td>
<p>execution</p>
</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="d3e7351" id="d3e7351" />6.16.5 Examples</h4>

<p>[Examples TBD]</p>
</div>
</div>

<div class="div2">
<h3><a name="SubdialogModule" id="SubdialogModule" />6.17 Subdialog
Module</h3>

<p>TBD</p>

<div class="div3">
<h4><a name="SubdialogModule:Syntax"
id="SubdialogModule:Syntax" />6.17.1 Syntax</h4>

<p>TBD.</p>

<a name="subdialog:attributes" id="subdialog:attributes" />
<table>
<caption>Table 77: Table: Attributes for Subdialog
Element</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="SubdialogModule:Semantics"
id="SubdialogModule:Semantics" />6.17.2 Semantics</h4>

<p>TBD</p>
</div>

<div class="div3">
<h4><a name="SubdialogModule:Examples"
id="SubdialogModule:Examples" />6.17.3 Examples</h4>

<p>TBD</p>
</div>
</div>

<div class="div2">
<h3><a name="DisconnectModule" id="DisconnectModule" />6.18
Disconnect Module</h3>

<p>This module defines the syntactic and semantic features of a
&lt;disconnect&gt; element. The &lt;disconnect&gt; element causes
the interpreter context to disconnect from the user. It provides
the interpreter context a way to enter into final processing state
by throwing the "connection.disconnect.hangup" event. [See ].</p>

<p>Processing the &lt;disconnect&gt; element also causes the
interpreter context to flush the prompt queue before disconnecting
the interpreter context from the user and subsequently throwing
"connection.disconnect.hangup" event.</p>

<p>The attributes and content model of &lt;disconnect&gt; are
specified in <a href="#DisconnectModule:Syntax"><b>6.18.1
Syntax</b></a>. Its semantics are specified in <a
href="#DisconnectModule:Semantics"><b>6.18.2 Semantics</b></a>.</p>

<div class="div3">
<h4><a name="DisconnectModule:Syntax"
id="DisconnectModule:Syntax" />6.18.1 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e7413" id="d3e7413" />6.18.1.1 Attributes</h5>

<p>The &lt;disconnect&gt; element has the attributes specified in
Table 78.</p>

<a name="disconnect:attributes" id="disconnect:attributes" />
<table>
<caption>Table 78: &lt;Disconnect&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>namelist</th>
<td>List of variable names</td>
<td>Variable names to be returned to the interpreter context. The
precise mechanism by which these variables are made available to
the interpreter context is platform specific. If an undeclared
variable is referenced in the namelist, then an error.semantic is
thrown.</td>
<td>No</td>
<td>The default is to return no variables; this means that the
interpreter context will receive an empty ECMAScript object.</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7446" id="d3e7446" />6.18.1.2 Content Model</h5>

<p>The content model of the &lt;disconnect&gt; element is
empty.</p>
</div>
</div>

<div class="div3">
<h4><a name="DisconnectModule:Semantics"
id="DisconnectModule:Semantics" />6.18.2 Semantics</h4>

<p>The disconnect RC is the primary RC for the &lt;disconnect&gt;
element.</p>

<div class="div4">
<h5><a name="d3e7456" id="d3e7456" />6.18.2.1 Definition</h5>

<p>The disconnect RC is defined in terms of a data model and state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this disconnect RC</li>

<li>namelist: list of ECMAScript variables</li>
</ul>

<p>The disconnect RC's state model consists of the following
states: Idle, Initializing, Ready, Executing, and Disconnecting.
The initial state is the Idle state.</p>

<p>While in the Idle state, the RC may receive an 'initialize'
event, whose 'controller' event data is used to update the data
model. The RC then transitions into the Initializing state.</p>

<p>In the Initializing state, the disconnect RC essentially does
nothing. The RC sends the controller an 'initialized' event and
transitions to the Ready state.</p>

<p>In the Ready state, when the disconnect RC receives an 'execute'
event it sends an 'execute' event to the Play RC (<a
href="#PlayModule"><b>6.19 Play Module</b></a>), causing any queued
prompts to be played. Note that the event data passed to Play RC
must have:</p>

<ul>
<li>the controller set to this RC</li>

<li>bargein = false</li>
</ul>

<p>This RC transitions to the Executing state after sending the
event request to the Play RC.</p>

<p>In the Executing state, when the disconnect RC receives the
"playDone" event, it instructs the connection resource to
disconnect the interpreter context from the user and enters into
the "Disconnecting" state.</p>

<p>In the "Disconnecting" state, when the disconnect RC receives
"userDisconnected" event,</p>

<ul>
<li>The namelist variables are tokenized into individual variable
names and their values are obtained using ReadVariable. The way,
values of these individual variables is made available to
interpreter context is platform specific</li>

<li>It throws the "connection.disconnect.hangup" event to the
parent element</li>

<li>It transitions to the Ready state</li>
</ul>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Play RC is not yet defined.</p>
</td>
</tr>
</table>
</div>

<div class="div4">
<h5><a name="d3e7502" id="d3e7502" />6.18.2.2 Defined Events</h5>

<p>The Disconnect RC is defined to receive the following
events:</p>

<table>
<caption>Table 79: Events received by Disconnect RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialize</td>
<td>any</td>
<td>controller(M)</td>
<td>Causes the element to be initialized</td>
</tr>

<tr>
<td>execute</td>
<td>controller</td>
<td />
<td>Causes prompts in the prompt queue to be played</td>
</tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table>
<caption>Table 80: Events sent by Disconnect RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>initialized</td>
<td>controller</td>
<td />
<td>response to initialize event indicating that it has been
successfully initialized</td>
</tr>

<tr>
<td>executed</td>
<td>controller</td>
<td />
<td>Response to execute event indicating that it has been
successfully executed</td>
</tr>

<tr>
<td>error.semantic</td>
<td>controller</td>
<td />
<td>Response to an undeclared variable in namelist</td>
</tr>

<tr>
<td>disconnectUser</td>
<td>Connection Resource</td>
<td />
<td>Instructs interpreter context to disconnect the user</td>
</tr>

<tr>
<td>connection.disconnect.hangup</td>
<td>parent</td>
<td />
<td>Throw this event to the parent element</td>
</tr>
</tbody>
</table>

<p></p>
</div>

<div class="div4">
<h5><a name="d3e7594" id="d3e7594" />6.18.2.3 External Events</h5>

<p>The following table shows the events sent and received by the
Disconnect RC to Resources and other RCs which define the
events.</p>

<a name="disconnect:external-events"
id="disconnect:external-events" />
<table>
<caption>Table 81: Disconnect RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td>execute</td>
<td>Disconnect RC</td>
<td>Play RC</td>
<td /></tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7621" id="d3e7621" />6.18.2.4 State Chart
Representation</h5>

<p>TBD</p>
</div>

<div class="div4">
<h5><a name="d3e7627" id="d3e7627" />6.18.2.5 SCXML
Representation</h5>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="namelist"/&gt;
    &lt;data id="bargein"/&gt;
    &lt;data id="activeGrammars"/&gt;
  &lt;/datamodel&gt;
 
  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;
 
    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign location="$controller" val="null"/&gt;
        &lt;assign location="$bargein" val="false"/&gt;
        &lt;assign location="$activeGrammars" val="false"/&gt;
      &lt;/onentry&gt;
 
      &lt;transition event="initialize" target="Initializing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
        &lt;send target="controller" event="initializing.done" /&gt;   
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Idle --&gt;
 
    &lt;state id="Initializing"&gt;
      &lt;transition event="initializing.done" target="Ready"&gt;
        &lt;send target="controller" event="initialized"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Initializing --&gt;
 
    &lt;state id="Ready"&gt;
      &lt;transition event="execute" target="Executing"&gt;
        &lt;send target="Play" event="execute"/&gt;   
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Ready --&gt;
 
    &lt;state id="Executing"&gt;
      &lt;transition event="playDone" target="Disconnecting"&gt;    // Currently no such event as "Play.done"
        &lt;send target="controller" event="disconnectUser" /&gt;
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Executing --&gt;
 
    &lt;state id="Disconnecting"&gt;
      &lt;transition event="userDisconnected" target="Ready"&gt;                        
        &lt;!-- A call to disconnect the interpreter context from the user --&gt;        
        &lt;send target="parent" event="connection.disconnect.hangup" /&gt;   
        &lt;send target="controller" event="executed" /&gt;   
      &lt;/transition&gt;
    &lt;/state&gt;
    &lt;!-- end Disconnecting --&gt;
&lt;/scxml&gt;

</pre>
</div>
</div>
</div>

<div class="div3">
<h4><a name="DisconnectModule:Example"
id="DisconnectModule:Example" />6.18.3 Example</h4>

<div class="exampleInner">
<pre>
&lt;vxml version="2.1"  xmlns="http://www.w3.org/2001/vxml"&gt;
  &lt;catch event="connection.disconnect.hangup"&gt;
    &lt;goto next="finalprocessing.jsp" /&gt;
  &lt;/catch&gt;
  &lt;form&gt;
  &lt;field name="phoneNum" type="digits"&gt;
    &lt;prompt&gt;Due to some technical difficulties, we cannot process your request now. Please enter your phone number so that we can get back to you later.&lt;/prompt&gt;
    &lt;catch event="noinput"&gt;
      Disconnecting.
      &lt;disconnect/&gt;
    &lt;/catch&gt;
    &lt;filled&gt;
      &lt;disconnect namelist="phoneNum"/&gt;
    &lt;/filled&gt;
  &lt;/field&gt;
  &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="PlayModule" id="PlayModule" />6.19 Play Module</h3>

<p>This module defines the semantic features of a Play capability.
Note that there is no XML syntax associated with this RC. It is
only used by the Disconnect module (<a
href="#DisconnectModule"><b>6.18 Disconnect Module</b></a>).</p>

<div class="div3">
<h4><a name="PlayModule:Semantics"
id="PlayModule:Semantics" />6.19.1 Semantics</h4>

<p>The Play RC coordinates media output with the PromptQueue
Resource (<a href="#Resources:PromptQueue"><b>5.2 Prompt Queue
Resource</b></a>).</p>

<div class="div4">
<h5><a name="d3e7651" id="d3e7651" />6.19.1.1 Definition</h5>

<p>The PlayRC coordinates media output with the PromptQueue
Resource for scenarios when only prompts need to be played to
completion without doing any recognition.</p>

<p>This RC activates prompt queue playback. The prompt RC is
defined in terms of a data model and state model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this RC</li>

<li>bargein: always set to "false"</li>
</ul>

<p>The Play RC's state model consists of the following states:
Idle, StartPlaying. The initial state is the Idle state.</p>

<p>While in the Idle state, the prompt RC may receive an 'execute'
event, whose event data is used to update the data model. The event
information includes: controller. The RC then transitions to the
StartPlaying state.</p>

<p>In the StartPlaying state, the RC sends a "play" event to the
PromptQueue resource. The PromptQueue returns with a "play.done"
event when all the propmts in the queue are done playing. The Play
RC then sends the "play.done" event to its controller and exits the
RC.</p>
</div>

<div class="div4">
<h5><a name="d3e7672" id="d3e7672" />6.19.1.2 Defined Events</h5>

[Event table contents TBD]. 

<p>The Play RC is defined to receive the following events:</p>

<table>
<caption>Table 82: Events received by Play RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>

<p>and the events it sends:</p>

<table>
<caption>Table 83: Events sent by Play RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7718" id="d3e7718" />6.19.1.3 External Events</h5>

<p>Table 84 shows the events sent and received by the Play RC to
resources and other RCs which define the events. [Table contents
TBD]</p>

<a name="play:external-events" id="play:external-events" />
<table>
<caption>Table 84: Play RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7743" id="d3e7743" />6.19.1.4 State Chart
Representation</h5>

<img class="center" src="Images/PlayRC.png"
alt="Play RC in UML State Chart" />
<p class="caption">Figure 14: Play RC States</p>
</div>

<div class="div4">
<h5><a name="d3e7749" id="d3e7749" />6.19.1.5 SCXML
Representation</h5>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
&lt;scxml initialstate="Created"&gt;
  &lt;datamodel&gt;
    &lt;data id="controller"/&gt;
    &lt;data id="bargein"/&gt;
  &lt;/datamodel&gt;
  
  &lt;state id="Created"&gt;
    &lt;initial id="Idle"/&gt;
 
    &lt;state id="Idle"&gt;
      &lt;onentry&gt;
        &lt;assign location="$controller" val="null"/&gt;
        &lt;assign location="$bargein" val="false"/&gt;
      &lt;/onentry&gt;
 
      &lt;transition event="execute" target="Playing"&gt;
        &lt;assign name="$controller" expr="_eventData/controller"/&gt;
        &lt;send target="PromptQueue" event="play" namelist="/datamodel/data[@name='bargein']"/&gt;    
      &lt;/transition&gt;
    &lt;/state&gt; &lt;!-- end Idle --&gt;
 
    &lt;state id="Playing"&gt;
      &lt;transition event="prompt.done" target="Idle"&gt;
        &lt;send target="controller" event="playDone"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt; &lt;!-- end StartPlaying --&gt;
    
  &lt;/state&gt; &lt;!-- end Created --&gt;
 
&lt;/scxml&gt;

</pre>
</div>
</div>
</div>
</div>

<div class="div2">
<h3><a name="RecordModule" id="RecordModule" />6.20 Record
Module</h3>

<p>This module defines the syntactic and semantic features of a
&lt;record&gt; element which collects and stores a recording from
the user.</p>

<p>The attributes and content model of &lt;record&gt; are specified
in <a href="#RecordModule:Syntax"><b>6.20.1 Syntax</b></a>. Its
semantics are specified in <a
href="#RecordModule:Semantics"><b>6.20.2 Semantics</b></a>.</p>

<div class="div3">
<h4><a name="RecordModule:Syntax" id="RecordModule:Syntax" />6.20.1
Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e7772" id="d3e7772" />6.20.1.1 Attributes</h5>

<p>The &lt;record&gt; element has the attributes specified in Table
85.</p>

<a name="record:attributes" id="record:attributes" />
<table>
<caption>Table 85: &lt;record&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>name</th>
<td>The name must conform to the variable naming conventions in
(TODO).</td>
<td>The form item variable in the dialog scope that will hold the
recording. The name must be unique among form items in the form. If
the name is not unique, then a badfetch error is thrown when the
document is fetched. Note that how this variable is implemented may
vary between platforms (although all platforms must support its
behavior in &lt;audio&gt; and &lt;submit&gt; as described in this
specification).</td>
<td>Yes</td>
<td /></tr>

<tr>
<th>expr</th>
<td>TBD</td>
<td>The initial value of the form item variable. If initialized to
a value, then the form item will not be visited unless the form
item variable is cleared.</td>
<td>No</td>
<td>ECMAScript undefined</td>
</tr>

<tr>
<th>cond</th>
<td>data model expression</td>
<td>A data model expression that must evaluate to true after
conversion to boolean in order for the form item to be
visited.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>modal</th>
<td>boolean</td>
<td>If this is true, all non-local speech and DTMF grammars are not
active while making the recording. If this is false, non-local
speech and DTMF grammars are active.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>beep</th>
<td>boolean</td>
<td>If true, a tone is emitted just prior to recording.</td>
<td>No</td>
<td>false</td>
</tr>

<tr>
<th>maxtime</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>The maximum duration to record.</td>
<td>No</td>
<td>Platform-specific value</td>
</tr>

<tr>
<th>finalsilence</th>
<td><a title="" href="#TimeDesignation">Time Designation</a></td>
<td>The interval of silence that indicates end of speech.</td>
<td>No</td>
<td>Platform-specific value</td>
</tr>

<tr>
<th>dtmfterm</th>
<td>boolean</td>
<td>If true, any DTMF keypress will be treated as a match of an
active (anonymous) local DTMF grammar.</td>
<td>No</td>
<td>true</td>
</tr>

<tr>
<th>type</th>
<td>Required audio file formats specified in <font
color="red">&lt;xref&gt;Appendix E of VoiceXML
2&lt;/xref&gt;</font> (Other formats may also be supported)</td>
<td>The media format of the resulting recording.</td>
<td>No</td>
<td>Platform-specific (one of the required formats)</td>
</tr>
</tbody>
</table>
</div>

<div class="div4">
<h5><a name="d3e7897" id="d3e7897" />6.20.1.2 Content Model</h5>

<p>The &lt;record&gt; element content model is the same as any
other form input item and consists of:</p>

<ul>
<li>&lt;prompt&gt; elements (0 or more)</li>

<li>&lt;catch&gt; handlers (0 or more, and may include shorthand
handlers such as noinput, nomatch, etc.)</li>

<li>&lt;grammar&gt; elements (0 or more)</li>

<li>&lt;link&gt; elements (0 or more)</li>

<li>&lt;filled&gt; elements (0 or 1)</li>

<li>&lt;property&gt; elements (0 or more)</li>
</ul>
</div>

<div class="div4">
<h5><a name="d3e7915" id="d3e7915" />6.20.1.3 Data Model
Variables</h5>

<p>The &lt;record&gt; module also sets the shadow variables covered
in Table 86 in the data module after the recording has been
made.</p>

<a name="record:shadowvars" id="record:shadowvars" />
<table>
<caption>Table 86: &lt;record&gt; shadow variables</caption>

<tbody>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>

<tr>
<th>name$.duration</th>
<td>The duration of the recording in milliseconds.</td>
</tr>

<tr>
<th>name$.size</th>
<td>The size of the recording in bytes.</td>
</tr>

<tr>
<th>name$.termchar</th>
<td>If the dtmfterm attribute is true, and the user terminates the
recording by pressing a DTMF key, then this shadow variable is the
key pressed (e.g. "#"). Otherwise it is undefined.</td>
</tr>

<tr>
<th>name$.maxtime</th>
<td>Boolean, true if the recording was terminated because the
maxtime duration was reached.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="div3">
<h4><a name="RecordModule:Semantics"
id="RecordModule:Semantics" />6.20.2 Semantics</h4>

<p>The semantics of the record module are defined using the
following resource controllers: RecordInputItem (<a
href="#RC:RecordInputItem"><b>6.20.2.1 RecordInputItem RC</b></a>),
PlayandRecognize (<a href="#RC:PlayAndRecognize"><b>6.10.2.2
PlayandRecognize RC</b></a>), Record (<a
href="#RC:Record"><b>6.20.2.2 Record RC</b></a>).</p>

<div class="div4">
<h5><a name="RC:RecordInputItem" id="RC:RecordInputItem" />6.20.2.1
RecordInputItem RC</h5>

<p>The Record Input Item Resource Controller is the primary RC for
the record element.</p>

<div class="div5">
<h6><a name="d3e7970" id="d3e7970" />6.20.2.1.1 Definition</h6>

<p>The record input item RC is defined in terms of a data model and
a state model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this record input item RC</li>

<li>children: array of children's (primary) RC</li>

<li>includePrompts: boolean indicating whether prompts are to be
collected and queued. Default: true.</li>

<li>promptCounter: prompt counter. Default: 1</li>

<li>eventCounterStructure: A hashtable like structure that stores
the current event count for any given complete named event. If an
event isn't present then it gets a count of 1.</li>

<li>recordResult: this stores a reference to the recorded file (it
is platform specific if this is the data, a URI to the data, a
filename, or what not).</li>

<li>expr: expression for the initial value of the form item</li>

<li>cond: condition if we should be selected</li>

<li>modal: condition if we should have non-local grammars
active</li>

<li>dtmfterm: Boolean if we should terminate on dtmf or not</li>

<li>beep: Boolean if we should play a beep or not</li>

<li>finalsilence: number indicating the length of time we should
wait for record to be done</li>
</ul>
</div>

<div class="div5">
<h6><a name="d3e8002" id="d3e8002" />6.20.2.1.2 Defined Events</h6>

<p>The RecordInputItem RC is defined to receive the following
events:</p>

<p>[Table contents TBD]</p>

<table>
<caption>Table 87: Events received by RecordInputItem RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>

and the events it sends: 

<table>
<caption>Table 88: Events sent by RecordInputItem RC</caption>

<thead>
<tr>
<td>Event</td>
<td>Target</td>
<td>Payload</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e8049" id="d3e8049" />6.20.2.1.3 External
Events</h6>

<p>Table 89 shows the events sent and received by the record input
item RC to resources and other RCs which define the events.</p>

<p>[Table contents TBD]</p>

<a name="recordinputitem:external-events"
id="recordinputitem:external-events" />
<table>
<caption>Table 89: RecordInputItem RC External Events</caption>

<thead>
<tr>
<td>Event</td>
<td>Source</td>
<td>Target</td>
<td>Description</td>
</tr>
</thead>

<tbody>
<tr>
<td />
<td />
<td />
<td /></tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e8076" id="d3e8076" />6.20.2.1.4 State Chart
Representation</h6>

<img class="center" src="Images/record_input_item_rc.png"
alt="RecordInputItem RC in UML State Chart" />
<p class="caption">Figure 15: RecordInputItem RC States</p>
</div>

<div class="div5">
<h6><a name="d3e8082" id="d3e8082" />6.20.2.1.5 SCXML
Representation</h6>
</div>
</div>

<div class="div4">
<h5><a name="RC:Record" id="RC:Record" />6.20.2.2 Record RC</h5>

<p>The Record RC coordinates media with the Record resource and a
form item. It is expected that other functionality that may be
related or simultaneous such as prompt playing or recognition will
be handled by the form item's rc. The record RC only handles the
recording.</p>

<div class="div5">
<h6><a name="d3e8092" id="d3e8092" />6.20.2.2.1 Definition</h6>

<p>The record RC is defined in terms of a data model and a state
model.</p>

<p>The data model is composed of the following parameters:</p>

<ul>
<li>controller: the RC controlling this record RC</li>

<li>recordParams: the collection of parameters needed for
recording. This will eventually be broken up but currently the only
ones that effect the RC are timeout and maxtime. Others such as
final silence may be passed directly to the Recording
resource.</li>
</ul>
</div>

<div class="div5">
<h6><a name="d3e8104" id="d3e8104" />6.20.2.2.2 Defined Events</h6>

<p>The Record RC is defined to receive the following events:</p>

<table>
<caption>Table 90: Events received by Record RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Source</th>
<th>Payload</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<th>execute</th>
<td>any</td>
<td>controller (M), recordParams (O)</td>
<td /></tr>
</tbody>
</table>

and the events it sends: 

<table>
<caption>Table 91: Events sent by Record RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Target</th>
<th>Payload</th>
<th>Sequencing</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<th>recordDone</th>
<td>controller</td>
<td>RecordResults (M)</td>
<td>One-of: recordDone, noinput</td>
<td /></tr>

<tr>
<th>noinput</th>
<td>controller</td>
<td />
<td>One-of: recordDone, noinput</td>
<td /></tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e8167" id="d3e8167" />6.20.2.2.3 External
Events</h6>

<p>Table 92 shows the events sent by the record RC to various
resources.</p>

<a name="record:sentexternal-events"
id="record:sentexternal-events" />
<table>
<caption>Table 92: External Events sent by Record RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Target</th>
<th>Payload</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<th>start</th>
<td>Timer</td>
<td>timeout (M)</td>
<td /></tr>

<tr>
<th>cancel</th>
<td>Timer</td>
<td />
<td /></tr>

<tr>
<th>start</th>
<td>Record Resource</td>
<td>recoParams (M)</td>
<td /></tr>

<tr>
<th>stop</th>
<td>Record Resource</td>
<td>maxtime (M)</td>
<td>This causes the recording to stop and return the recording
information, setting a Boolean about if the recording was stopped
because of maxtime</td>
</tr>

<tr>
<th>kill</th>
<td>Record Resource</td>
<td />
<td>This immediately stops the record resource, throwing away any
recording</td>
</tr>

<tr>
<th>assign</th>
<td>Datamodel Resource</td>
<td>name (M), value (M)</td>
<td /></tr>
</tbody>
</table>

<p>Table 93 shows the events received by the record RC. Their
definition is provided by the sending component.</p>

<a name="record:receivedexternal-events"
id="record:receivedexternal-events" />
<table>
<caption>Table 93: External Events received by Record RC</caption>

<thead>
<tr>
<th>Event</th>
<th>Source</th>
<th>Payload</th>
<th>Sequencing</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<th>TimerExpired</th>
<td>Timer</td>
<td />
<td />
<td /></tr>

<tr>
<th>Started</th>
<td>Record Resource</td>
<td />
<td />
<td>This event means a recording has begun. This may be automatic
as soon as start was sent to the resource, or there may be an
optimization where this doesn't get sent until after the record
resource detects speech.</td>
</tr>
</tbody>
</table>
</div>

<div class="div5">
<h6><a name="d3e8271" id="d3e8271" />6.20.2.2.4 State Chart
Representation</h6>

<img class="center" src="Images/record_rc.png"
alt="Record RC in UML State Chart" />
<p class="caption">Figure 16: Record RC States</p>
</div>

<div class="div5">
<h6><a name="d3e8277" id="d3e8277" />6.20.2.2.5 SCXML
Representation</h6>
</div>
</div>
</div>
</div>

<div class="div2">
<h3><a name="PropertyModule" id="PropertyModule" />6.21 Property
Module</h3>

<p>The &lt;property&gt; element sets a property value. Properties
are used to set values that affect platform behavior, such as the
recognition process, timeouts, caching policy, etc. For a more
complete list of individual property values see <a
href="#Properties"><b>8.2 Properties</b></a>.</p>

<p>Properties may be defined for the session, for the whole
application, for the whole document at the &lt;vxml&gt; level, for
a particular dialog at the &lt;form&gt; or &lt;menu&gt; level, or
for a particular form item. Properties apply to their parent
element and all the descendants of the parent. A property at a
lower level overrides a property at a higher level. When different
values for a property are specified at the same level, the last one
in document order applies. Properties specified in the session root
document provide default values for properties throughout the
session; properties specified in the application root document
provide default values for properties in every document in the
application; properties specified in an individual document
override property values specified in the application root
document.</p>

<div class="div3">
<h4><a name="PropertyModule:Syntax"
id="PropertyModule:Syntax" />6.21.1 Syntax</h4>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e8298" id="d3e8298" />6.21.1.1 Attributes</h5>

<p>The &lt;property&gt; element has the attributes specified in
Table 94.</p>

<a name="property:attributes" id="property:attributes" />
<table>
<caption>Table 94: &lt;property&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>name</th>
<td />
<td>The name of the property</td>
<td>Yes</td>
<td /></tr>

<tr>
<th>value</th>
<td />
<td>A static value of the property</td>
<td>No</td>
<td>(Required if "expr" not present)</td>
</tr>

<tr>
<th>expr</th>
<td>data model expression</td>
<td>A data model expression to be evaluated when the property in
question is used.</td>
<td>No</td>
<td>(Required if "value" not present)</td>
</tr>
</tbody>
</table>

<p>The value and expr attributes are mutually exclusive. A
&lt;property&gt; element may have only one of value and expr
defined.</p>
</div>

<div class="div4">
<h5><a name="d3e8352" id="d3e8352" />6.21.1.2 Content Model</h5>

<p>The content model of the &lt;property&gt; element is empty.</p>
</div>
</div>

<div class="div3">
<h4><a name="PropertyModule:Semantics"
id="PropertyModule:Semantics" />6.21.2 Semantics</h4>

<p>Whenever a particular property needs to be used, its value must
be looked up. The mechanism to lookup the value of a property is
dependent on both the syntactic structure of the authored document
and the current location in execution. The timing of whenever a
property needs to be used is dependent on the property in question.
For instance, the speedvsaccuracy recognizer property needs to have
its value be looked up whenever a recognition is to take place
(like in a &lt;field&gt; tag) but it doesn't need to be looked up
at other times like when a generic prompt is queued in a block or
when a script file is fetched. In contrast, a property like bargein
needs to be looked up whenever a prompt is queued in a block and
the scripttimeout property needs to be looked up whenever a script
file is loaded. For a more complete list of individual properties
and when they are evaluated see section 8 on environment that lists
the various properties and details about them.</p>

<p>When a property is looked up first it must be determined if this
property is defined at the current execution level. If it is then
the last instance of the property element is the one that is
evaluated and used. If no property elements for this property exist
at the current document level then the next higher level XML
container is checked, including going to application root documents
and session root documents. This parent chain is halted whenever
the property is found. The chain of parents to follow for a look up
can span a number of different document elements. For instance it
may have had to be looked up at the current level (I.e., is there a
property defined in the field), the dialog level (I.e., what about
in the form), the document level (I.e., what about in the vxml
element), the application level (I.e., what about the application
root), the session level (I.e., what about the session root). If
the property isn't found at any of these levels then either a
specification specified default or a platform default may need to
be used (see the platform root). For instance the speedvsaccuracy
default value is defined to be 0.5 by the VXML specification. The
completetimeout property however has no specification default and
instead must use a platform default if it is not present.</p>

<p>If the platform has trouble evaluating the value of a property
(I.e., an expr failure) or the value of a property is invalid
(I.e., a completetimeout of "orange") then the platform should
throw error.semantic.</p>

<div class="div4">
<h5><a name="d3e8366" id="d3e8366" />6.21.2.1 Definition</h5>

<p>[Formal definition of data model and state model TBD.]</p>
</div>

<div class="div4">
<h5><a name="d3e8371" id="d3e8371" />6.21.2.2 Defined Events</h5>

<p>[Formal definition of events sent and received TBD.]</p>
</div>

<div class="div4">
<h5><a name="d3e8376" id="d3e8376" />6.21.2.3 External Events</h5>

<p>[Formal definition of external events sent and received
TBD.]</p>
</div>

<div class="div4">
<h5><a name="d3e8381" id="d3e8381" />6.21.2.4 State Chart
Representation</h5>

<p>[State chart TBD.]</p>
</div>

<div class="div4">
<h5><a name="d3e8387" id="d3e8387" />6.21.2.5 SCXML
Representation</h5>

<p>[SCXML representation TBD.]</p>
</div>
</div>

<div class="div3">
<h4><a name="PropertyModule:Events"
id="PropertyModule:Events" />6.21.3 Events</h4>

<p>[Events raised during initialization and execution TBD.]</p>
</div>

<div class="div3">
<h4><a name="property:examples" id="property:examples" />6.21.4
Examples</h4>

<p>[TBD: put all examples here.]</p>
</div>
</div>

<div class="div2">
<h3><a name="ControllerModule" id="ControllerModule" />6.22
Transition Controller Module</h3>

<p>This module defines the syntactic and semantic features of a
&lt;controller&gt; element. Transition controllers provide the
basis for managing flow in VoiceXML applications. Resource
controllers for some elements like &lt;form&gt; have associated
transition controllers which influence how form items get selected
and executed. In addition to form, there is a transition controller
for each of the following higher VoiceXML scopes:</p>

<ul>
<li>A document-level transition controller associated with the
&lt;vxml&gt; element's resource controller that is responsible for
starting document processing and deciding which resource controller
to execute next, i.e., for a &lt;form&gt; or other interaction
element in the document.</li>

<li>An application-level transition controller that is responsible
for starting application processing and deciding which
document-level resource controller to execute next.</li>

<li>A top-level or session transition controller that manages the
flow for a VoiceXML session. This top-level transition controller
is responsible for starting session processing and also holds
session level properties.</li>
</ul>

<p>The above transition controllers influence the selection of the
first form item resource controller to execute, and subsequent ones
through the session.</p>

<p>The attributes and content model of &lt;controller&gt; are
specified in <a href="#ControllerModule:Syntax"><b>6.22.1
Syntax</b></a>. Its semantics are specified in <a
href="#ControllerModule:Semantics"><b>6.22.2 Semantics</b></a>.</p>

<div class="div3">
<h4><a name="ControllerModule:Syntax"
id="ControllerModule:Syntax" />6.22.1 Syntax</h4>

<p>Transition controllers serve as dialog managers for VoiceXML
forms and documents and are described syntactically using the
&lt;controller&gt; element. A VoiceXML 3.0 &lt;form&gt; element or
&lt;vxml&gt; element may have at most one &lt;controller&gt; child,
which allows mixed content.</p>

<p>[See <a href="#Schema"><b>D VoiceXML 3.0 XML Schema</b></a> for
schema definitions].</p>

<div class="div4">
<h5><a name="d3e8433" id="d3e8433" />6.22.1.1 Attributes</h5>

<p>The &lt;controller&gt; element has the attributes specified in
Table 95.</p>

<a name="controller:attributes" id="controller:attributes" />
<table>
<caption>Table 95: &lt;controller&gt; Attributes</caption>

<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
<th>Default Value</th>
</tr>

<tr>
<th>id</th>
<td>xml:id</td>
<td>This is a document-unique identifier for the &lt;controller&gt;
element. This may be used to register listeners against or dispatch
events to transition controllers in the future.</td>
<td>No</td>
<td /></tr>

<tr>
<th>type</th>
<td>MIME type</td>
<td>This is the MIME type of the transition controller description.
The default transition controller description type is SCXML. The
types supported depend on the VoiceXML 3.0 profile in use.</td>
<td>No</td>
<td>application/xml+scxml</td>
</tr>

<tr>
<th>src</th>
<td>URI</td>
<td>The URI specifying the location of the controller document, if
it is external.</td>
<td>No</td>
<td /></tr>

<tr>
<th>srcexpr</th>
<td>data model expression</td>
<td>Equivalent to src, except that the URI is dynamically
determined by evaluating the content as a data model
expression.</td>
<td>No</td>
<td /></tr>
</tbody>
</table>

At most one of src or srcexpr may be specified</div>

<div class="div4">
<h5><a name="d3e8497" id="d3e8497" />6.22.1.2 Content Model</h5>

<p>The content model is mixed, allowing for both XML and non-XML
content. The type of the content is specified by the "type"
attribute.</p>
</div>
</div>

<div class="div3">
<h4><a name="ControllerModule:Semantics"
id="ControllerModule:Semantics" />6.22.2 Semantics</h4>

<p>The controller RC is the primary RC for the &lt;controller&gt;
element.</p>

<p>Whenever a form item or form or document finishes execution, the
relevant transition controller is consulted for selecting the
subsequent one for execution. To find the relevant transition
controller, begin at the current resource controller and navigate
along the associated VoiceXML element's parent axis until you reach
a resource controller with an associated transition controller. For
example, for a form item, the parent form's resource controller has
the relevant transition controller.</p>

<p>When a transition controller runs to completion, control is
returned to the next higher transition controller along with any
results that need to be passed up. For example, when the last form
item in a form is filled, the transition controller associated with
the form returns control to the document level transition
controller along with the results for the filled form. Control may
be returned to the parent transition controller in case of such run
to completion semantics as well as error semantics.</p>

<div class="div4">
<h5><a name="d3e8511" id="d3e8511" />6.22.2.1 Definition</h5>

TBD</div>

<div class="div4">
<h5><a name="d3e8515" id="d3e8515" />6.22.2.2 Defined Events</h5>

TBD</div>

<div class="div4">
<h5><a name="d3e8519" id="d3e8519" />6.22.2.3 External Events</h5>

TBD</div>

<div class="div4">
<h5><a name="d3e8523" id="d3e8523" />6.22.2.4 State Chart
Representation</h5>

TBD</div>

<div class="div4">
<h5><a name="d3e8527" id="d3e8527" />6.22.2.5 SCXML
Representation</h5>

TBD</div>
</div>

<div class="div3">
<h4><a name="ControllerModule:Events"
id="ControllerModule:Events" />6.22.3 Events</h4>

TBD</div>

<div class="div3">
<h4><a name="controller:examples" id="controller:examples" />6.22.4
Examples</h4>

<p>EXAMPLE 1: If the transition controller is described using an
XML type or vocabulary, the description is a direct child of the
&lt;controller&gt; element.</p>

<div class="exampleInner">
<pre>
&lt;v3:vxml version="3.0" ...&gt;

  &lt;!-- document level transition controller, type defaults to SCXML --&gt;
  &lt;v3:controller id="controller" type="application/xml+scxml"&gt;

    &lt;scxml:scxml version="1.0" ...&gt;

      &lt;!-- Transition controller as a state chart --&gt;

    &lt;/scxml:scxml&gt;

  &lt;/v3:controller&gt;

  &lt;!-- Remainder of VoiceXML 3.0 document --&gt;

&lt;/v3:vxml&gt;
</pre>
</div>

<p>EXAMPLE 2: If the transition controller is described using a
non-XML type or vocabulary, the description is the text content of
the &lt;controller&gt; element. A CDATA section may be used if
needed.</p>

<div class="exampleInner">
<pre>
&lt;v3:vxml version="3.0" ...&gt;

  &lt;!-- document level transition controller --&gt;
  &lt;v3:controller id="controller" type="text/some-controller-notation"&gt;

    &lt;![CDATA[

      // Some text-based transition controller description

    ]]&gt;

  &lt;/v3:controller&gt;

  &lt;!-- Remainder of VoiceXML 3.0 document --&gt;

&lt;/v3:vxml&gt;
</pre>
</div>

<p>EXAMPLE 3: [Support for this convenience syntax not yet decided
-- here's the tentative text: If the transition controller is
described using SCXML, then a convenience syntax of placing the
&lt;scxml&gt; root element as a direct child of the &lt;vxml&gt; or
&lt;form&gt; element is supported without the need of a
&lt;controller&gt; wrapper. Thereby, the following two variants are
equivalent:]</p>

<div class="exampleInner">
<pre>
&lt;v3:vxml version="3.0" ...&gt;

  &lt;v3:controller&gt;
    &lt;scxml:scxml version="1.0" ...&gt;
      &lt;!-- Transition controller as a state chart --&gt;
    &lt;/scxml:scxml&gt;
  &lt;/v3:controller&gt;

  &lt;!-- Remainder of VoiceXML 3.0 document --&gt;

&lt;/v3:vxml&gt;

Variant 2:

&lt;v3:vxml version="3.0" ...&gt;

  &lt;scxml:scxml version="1.0" ...&gt;
    &lt;!-- Transition controller as a state chart --&gt;
  &lt;/scxml:scxml&gt;

  &lt;!-- Remainder of VoiceXML 3.0 document --&gt;

&lt;/v3:vxml&gt;
</pre>
</div>

For further examples on using SCXML to describe transition
controllers, see <a href="#Integration:InsideVoiceXML"><b>9.2
Integrating Flow Control Languages into VoiceXML</b></a>.</div>
</div>
</div>

<div class="div1">
<h2><a name="Profiles" id="Profiles" />7 Profiles</h2>

<p>VoiceXML 3.0, like SMIL, is a specification that contains a
variety of functional modules. Not all implementers of VoiceXML
will be interested in implementing all of the functionality defined
in the document. For example, an implementer may have no interest
in speech or DTMF recognition but still be interested in speech
output. An example might be an implementer of book reading products
for the visually impaired. Also, the syntax defined for each of the
VoiceXML 3.0 modules is fairly low-level, and authors familiar with
a more declarative language may wish to have higher-level syntax
that is easier to program in.</p>

<p>To address these interests while maintaining sufficiently
precise behavior definition to enhance portability, we encourage
the use of profiles.</p>

<p>A profile is an implementation of VoiceXML 3 that</p>

<ul>
<li>implements a specified set of VoiceXML 3.0 modules</li>

<li>precisely defines any necessary interaction between the
modules</li>

<li>has its own schema that defines the complete syntax of the
profile</li>

<li>defines conformance requirements for the profile</li>

<li>optionally introduces new elements whose behavior is completely
defined in terms of the core elements defined in the specified set
of modules. These new elements can provide the higher-level
"syntactic sugar" needed to simplify authoring in this language
profile.</li>
</ul>

<p>This specification defines the following profiles:</p>

<ul>
<li>VoiceXML21: supports VoiceXML 2.1 functionality</li>

<li>Media Server: supports advanced media functions (including
DTMF, speech recognition, media playback and control, speech
synthesis and SIV) where results are returned to the control
layer.</li>

<li>Maximal profile: includes all VoiceXML 3.0 modules.</li>
</ul>

<p>It should be possible for other profiles to be created, perhaps
by modifying an existing profile, combining different modules, or
even adding new module functionality and syntax.</p>

<p>Implementers may differ in their choice of which profiles they
implement. Implementers must support a designated set of modules in
order to claim support for VoiceXML 3. That designated set is
TBD.</p>

<p>[ISSUES:</p>

<ul>
<li>who can create profiles? More discussion is needed on whether
profiles should only be created within the Voice Browser Working
Group or by which classes of authors/programmers/implementers
outside of the VBWG.</li>

<li>different dimensions for creation of profiles, e.g. subsets of
core functionality, addition of syntactic sugar/macros,
modification of underlying modules or creation of new ones.</li>

<li>How much modification of module behavior is needed just to
piece together existing modules?</li>

<li>]</li>
</ul>

<div class="div2">
<h3><a name="Profile:Legacy" id="Profile:Legacy" />7.1 Legacy
Profile</h3>

<p>The Legacy profile is included demonstrating how profiles are
defined in VoiceXML 3.0. Using existing elements from the <a
href="#VOICEXML21">[VOICEXML21]</a> specification is helpful as the
semantics of these elements are already well defined and well
understood. Thus changes in how they are presented are a result of
the module and profile style of VoiceXML 3.0 and of making more
explicit and formal the precise detailed semantics.</p>

<p>The Legacy profile also plays a transitional role as VoiceXML
3.0 as a whole is built on top of VoiceXML 2.1. VoiceXML 3.0 is a
superset of VoiceXML 2.1 and includes the traditional 2.1
functionality plus some new modules. The Legacy profile is the set
of modules that were always present in VoiceXML 2.1 but that
weren't expressed in the specification as individual modules. This
also allows a clear path for the VoiceXML application developer as
the application developer will not need to learn substantial new
syntax or semantics when they develop in the Legacy profile of
VoiceXML 3.0.</p>

<p>The Legacy profile also represents a proof of concept to ensure
that the new modular profile method of describing the specification
is in no way limited. VoiceXML 3.0 in its entirety will be in no
way limited or constrained because of the use of profiles and
modules and formalized semantic models. Anything that was
standardized in VoiceXML 2.1 can be standardized in this new format
and the Legacy profile reveals that.</p>

<p>This profile can be best described in the following 3
sections:</p>

<ul>
<li>Module Conformance</li>

<li>Convenience Syntax</li>

<li>Default Handlers and Transition Controllers</li>
</ul>

<div class="div3">
<h4><a name="Legacy:Conformance" id="Legacy:Conformance" />7.1.1
Conformance</h4>

<p>This section defines semantics of how different modules coexist
with each other to simulate the behavior of VoiceXML 2.1. It
outlines all the required modules and any additions/deletions from
each of these modules to make it conform to this profile. It also
talks about the interaction amongst various modules so that
behavior similar to that in VoiceXML 2.1 is achieved.</p>

<p>To conform with this profile, processors must implement the
following modules:</p>

<ul>
<li>Vxml Root Module</li>

<li>Script Module</li>

<li><a href="#FormModule"><b>6.9 Form Module</b></a></li>

<li><a href="#FieldModule"><b>6.10 Field Module</b></a></li>

<li><a href="#PromptModule"><b>6.4 Prompt Module</b></a>: this
includes implementation of <a href="#BuiltinSSMLModule"><b>6.5
Builtin SSML Module</b></a> and <a href="#ForeachModule"><b>6.8
Foreach Module</b></a>.</li>

<li><a href="#Grammar:GrammarModule"><b>6.1 Grammar Module</b></a>:
this includes implementation of <a
href="#Grammar:InlineSRGSGrammarModule"><b>6.2 Inline SRGS Grammar
Module</b></a> and <a href="#Grammar:ExternalGrammarModule"><b>6.3
External Grammar Module</b></a>.</li>

<li><a href="#DAMModule"><b>6.12 Data Access and Manipulation
Module</b></a></li>

<li>Executable Content</li>

<li>Link</li>

<li>Record</li>

<li>Object</li>

<li>Event Throwing/Handling</li>

<li>Transfers</li>

<li>Menu</li>
</ul>

The schema for the Legacy Profile is given in <a
href="#Schema:Legacy"><b>D.8 Schema for Legacy Profile</b></a>. 

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>The following content is missing from the Vxml 3.0 specification
and needs to be defined:</p>

<ul>
<li>Vxml Root Module</li>

<li>Event Handling and throwing (event handlers like &lt;catch&gt;,
&lt;noinput&gt;,&lt;nomatch&gt;, etc.)</li>

<li>FIA? (although talked about in the Form module, it is not
addressed completely)</li>

<li>Executable Content</li>

<li>&lt;reprompt&gt;</li>

<li>&lt;disconnect&gt;</li>

<li>&lt;exit&gt;</li>

<li>&lt;if&gt; &lt;elseif&gt; &lt;else&gt;</li>

<li>&lt;goto&gt;</li>

<li>&lt;submit&gt;</li>

<li>&lt;log&gt;</li>

<li>&lt;return&gt;</li>

<li>&lt;script&gt;</li>

<li>&lt;throw&gt;</li>

<li>All of the VoiceXML 2.0/2.1 properties (Should go in 6.12)</li>

<li>&lt;script&gt; Script Module</li>

<li>&lt;transfer&gt;</li>

<li>&lt;initial&gt;</li>

<li>&lt;link&gt;</li>

<li>&lt;record&gt;</li>

<li>&lt;object&gt;</li>

<li>Transitions: &lt;goto&gt;, &lt;submit&gt;,
&lt;subdialog&gt;</li>

<li>Specify transitions amongst inter-module clearly</li>

<li>author controlled transitions within form</li>

<li>author controlled transitions outside form</li>

<li>automatic transition behavior outside form</li>

<li>&lt;filled&gt;</li>
</ul>

<p>Supported media types must be defined.</p>
</td>
</tr>
</table>

<div class="div4">
<h5><a name="Legacy:RootRequirements"
id="Legacy:RootRequirements" />7.1.1.1 Vxml Root Module
Requirements</h5>

<p>Eliminate the need to specify Session Root and Platform
Root.</p>
</div>

<div class="div4">
<h5><a name="Legacy:FormRequirements"
id="Legacy:FormRequirements" />7.1.1.2 Form Module
Requirements</h5>

<p>Eliminate Capture phase of DOM Level 3 eventing to support
Legacy Profile.</p>
</div>

<div class="div4">
<h5><a name="Legacy:FieldRequirements"
id="Legacy:FieldRequirements" />7.1.1.3 Field Module
Requirements</h5>

<p>Eliminate Capture phase of DOM Level 3 eventing to support
Legacy Profile.</p>
</div>

<div class="div4">
<h5><a name="Legacy:PromptRequirements"
id="Legacy:PromptRequirements" />7.1.1.4 Prompt Module
Requirements</h5>

<p>Eliminate Capture phase of DOM Level 3 eventing to support
Legacy Profile.</p>
</div>

<div class="div4">
<h5><a name="Legacy:GrammarRequirements"
id="Legacy:GrammarRequirements" />7.1.1.5 Grammar Module
Requirements</h5>

<p>Eliminate Capture phase of DOM Level 3 eventing to support
Legacy Profile.</p>
</div>

<div class="div4">
<h5><a name="Legacy:DataRequirements"
id="Legacy:DataRequirements" />7.1.1.6 Data Access and Manipulation
Module Requirements</h5>

<p>Eliminate Capture phase of DOM Level 3 eventing to support
Legacy Profile.</p>
</div>
</div>

<div class="div3">
<h4><a name="Legacy:Convenience_Syntax"
id="Legacy:Convenience_Syntax" />7.1.2 Convenience Syntax</h4>

<p>This section describes the convenience syntax that can be used
to define some of the functionality of VoiceXML 2.1.</p>
</div>

<div class="div3">
<h4><a name="Legacy:Default" id="Legacy:Default" />7.1.3 Default
Handlers and Transition Controllers</h4>

<p>This section describes what we refer to as the Form
Interpretation Algorithm (FIA) in VoiceXML 2.1 using Transition
Controllers defined in VoiceXML 3.0.</p>
</div>
</div>

<div class="div2">
<h3><a name="Profile:Basic" id="Profile:Basic" />7.2 Basic
Profile</h3>

<div class="div3">
<h4><a name="BasicProfile:Introduction"
id="BasicProfile:Introduction" />7.2.1 Introduction</h4>

<p>The basic profile provides basic media capabilities including
the capture and presentation of temporal media such as audio and
video. The basic profile serves two different purposes:</p>

<ul>
<li>To provide core temporal media services in high-volume
applications, particularly in telecom networks and NGN, IMS,
etc.</li>

<li>To support mobile devices with embedded temporal media
capabilities, especially speech technology.</li>
</ul>

<p>The basic profile is a "lean and mean" collection of media
functions which the application can invoke, but does not duplicate
functions from the scripting or programming languages.</p>

<p>The basic profile is intended for single-turn prompt and collect
applications.</p>
</div>

<div class="div3">
<h4><a name="BasicProfile:Contents"
id="BasicProfile:Contents" />7.2.2 What the Basic Profile
includes</h4>

<p>The following enumerates the modules included in the Basic
Profile.</p>

<div class="div4">
<h5><a name="BasicProfile:SIV" id="BasicProfile:SIV" />7.2.2.1 SIV
functions</h5>

<p>The SIV Module (See <a href="#SIV"><b>6.16 SIV Module</b></a>)
includes verification, identification, and enrollment
functions.</p>
</div>

<div class="div4">
<h5><a name="BasicProfile:Presentation"
id="BasicProfile:Presentation" />7.2.2.2 Presentation
functions</h5>

<p>The Builtin-SSML Module (<a href="#BuiltinSSMLModule"><b>6.5
Builtin SSML Module</b></a>), the Media Module (<a
href="#MediaModule"><b>6.6 Media Module</b></a>), and the Parseq
Module (<a href="#ParseqModule"><b>6.7 Parseq Module</b></a>)
provide functions for presenting information to the user.</p>
</div>

<div class="div4">
<h5><a name="BasicProfile:Capture"
id="BasicProfile:Capture" />7.2.2.3 Capture functions</h5>

<p>Capture functions include</p>

<ul>
<li>The Record module, which captures audio</li>

<li>The Field module (<a href="#FieldModule"><b>6.10 Field
Module</b></a>), which includes the PlayAndRecognize RC</li>

<li>The Grammar module (<a href="#Grammar:GrammarModule"><b>6.1
Grammar Module</b></a>), which includes the Inline SRGS Grammar
module (<a href="#Grammar:InlineSRGSGrammarModule"><b>6.2 Inline
SRGS Grammar Module</b></a>) and the External Grammar Module (<a
href="#Grammar:ExternalGrammarModule"><b>6.3 External Grammar
Module</b></a>)</li>
</ul>
</div>

<div class="div4">
<h5><a name="BasicProfile:Other" id="BasicProfile:Other" />7.2.2.4
Other modules</h5>

<p>The Basic Profile also includes the Data Access and Manipulation
module (<a href="#DAMModule"><b>6.12 Data Access and Manipulation
Module</b></a>) for accessing local variables, parameters, returned
values, etc. This module is not intended to access external
databases.</p>
</div>
</div>

<div class="div3">
<h4><a name="BasicProfile:Results"
id="BasicProfile:Results" />7.2.3 Returned results</h4>

<p>Results are returned using EMMA notation, which may include
includes confidence scores and multiple results represented in a
lattice.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>How does the host scripting or programming language access
returned results?</p>

<p>TBD: define the amount of ECMAScript and data access
capability.</p>

<p>Supported media types must be defined.</p>
</td>
</tr>
</table>
</div>

<div class="div3">
<h4><a name="BasicProfile:NotIncluded"
id="BasicProfile:NotIncluded" />7.2.4 What the Basic Profile does
not include</h4>

<p>The basic profile does NOT support the capture of key strokes,
mouse movements, or joystick movements and does not present static
information such as text and bit map graphics on a display. Other
languages such as HTML, SVG, and XHTML can be used to perform these
functions.</p>

<p>The basic profile does NOT support higher-level flow control
constructs such as the VoiceXML 2.0 &lt;form&gt; element and the
associated Form Interpretation Algorithm. The Basic Profile assumes
that application developers specify flow control using a scripting
or programming language, which controls all application-specific
procedural flow and interaction with non-VoiceXML functions such as
databases, application functions, and Web services.</p>

<p>The following VoiceXML 2.0/2.1 control elements are NOT included
in the Basic Profile:</p>

<ul>
<li>&lt;foreach&gt;</li>

<li>&lt;form&gt; and the associated Form Interpretation Algorithm
(FIA)</li>

<li>&lt;goto&gt;</li>

<li>&lt;submit&gt;</li>

<li>&lt;exit&gt;</li>

<li>&lt;return&gt;</li>

<li>&lt;disconnect&gt;</li>

<li>&lt;if&gt;</li>

<li>&lt;else&gt;</li>

<li>&lt;elseif&gt;</li>

<li>&lt;reprompt&gt;</li>

<li>&lt;log&gt;</li>

<li>&lt;help&gt;</li>

<li>&lt;link&gt;</li>

<li>&lt;noinput&gt;</li>

<li>&lt;nomatch&gt;</li>

<li>&lt;object&gt;</li>

<li>&lt;param&gt;</li>

<li>&lt;subdialog&gt;</li>
</ul>
</div>

<div class="div3">
<h4><a name="BasicProfile:Examples"
id="BasicProfile:Examples" />7.2.5 Examples</h4>

<p>Example of an application using SCXML and modules of the basic
profile [tbd]</p>

<p>Example of a programming or scripting language and modules of
the basic profile [tbd]</p>
</div>
</div>

<div class="div2">
<h3><a name="Profile:Maximal" id="Profile:Maximal" />7.3 Maximal
Profile</h3>

<p>The maximal server profile represents the closure over the
VoiceXML 3.0 platform feature set and is intended for applications
providing feature-rich voice user interfaces. This profile provides
data access and manipulation capabilities, full media capabilities,
higher-level flow control constructs such as &lt;form&gt; and
&lt;field&gt;, and full support for environment properties. We
believe that control flow capabilities such as those provided by
SCXML and CCXML are necessary to take full advantage of the
features in the maximal server profile.</p>

<p>Specifically, the maximal server profile provides support for
[... enumerate all modules in Section 6 of WD2 draft ...]</p>

<p>[Issue: Should support for SCXML be required when implementing
the profile? Should support for CCXML be required when implementing
the profile? What are the interoperability ramifications of
requiring one, multiple, or no flow control languages for support
of this profile?]</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Supported media types must be defined.</p>
</td>
</tr>
</table>
</div>

<div class="div2">
<h3><a name="Profile:Enhanced" id="Profile:Enhanced" />7.4 Enhanced
Profile</h3>

<p>At a minimum, the enhanced profile should include the modules
not included in the basic and legacy profiles, specifically SIV and
receive. The enhanced profile may include modules which are
included in the basic and legacy profiles. The enhanced profile
should demonstrate the new capabilities of VoiceXML 3.0, including
prompt control and alternative flow control strategies.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Supported media types must be defined.</p>
</td>
</tr>
</table>
</div>

<div class="div2">
<h3><a name="Profile:ConvenienceSyntax"
id="Profile:ConvenienceSyntax" />7.5 Convenience Syntax (Syntactic
Sugar)</h3>

<p>Profiles can provide convenience syntax to simplify authoring
for that profile without decreasing portability. Convenience
Syntax, as we define it here, can be implemented via a
straightforward text mapping from the convenience syntax to profile
code that uses only the syntax defined by the modules in the
profile. Convenience syntax cannot add functionality. It only makes
existing functionality easier to code.</p>

<p>A Convenience syntax definition must include</p>

<ul>
<li>one or more new XML attributes and/or elements</li>

<li>for each possible use of the new attributes and elements, a
non- cyclical mapping from the code containing the element(s) or
attribute(s) to code containing other convenience syntax or module
syntax, such that the behavior of the original code can be
completely described in terms of module syntax.</li>

<li>(optional) "initial" code to be executed before each
application begins that sets up variables, etc. needed by the
mapped code.</li>
</ul>

<p>The existence and definition of the mapping above means that an
author can write VoiceXML applications using the (presumably
simpler) convenience syntax, while being assured that the code will
execute *as if* the code had been replaced by the (presumably more
complex but well-defined) module syntax. This allows authors to
code simple cases in the convenience syntax, and make use of other
VoiceXML syntax elements and attributes only as needed.</p>

<p><a href="#V2Convenience"><b>E Convenience Syntax in VoiceXML
2.x</b></a> shows how the VoiceXML 2.1 &lt;menu&gt; and pre-defined
catch handlers could be coded using other V2 notation (i.e., as
convenience syntax).</p>

<p>[Examples TBD.]</p>
</div>
</div>

<div class="div1">
<h2><a name="Environment" id="Environment" />8 Environment</h2>

<div class="div2">
<h3><a name="ResourceFetching" id="ResourceFetching" />8.1 Resource
Fetching</h3>

<div class="div3">
<h4><a name="Fetching" id="Fetching" />8.1.1 Fetching</h4>

<p>A VoiceXML interpreter context needs to fetch VoiceXML
documents, and other resources, such as media files, grammars,
scripts, and XML data. Each fetch of the content associated with a
URI is governed by the following attributes:</p>

<table border="1">
<caption>Table 96: Fetch Attributes</caption>

<tbody>
<tr id="Fetching:fetchtimeout">
<th>fetchtimeout</th>
<td>The interval to wait for the content to be returned before
throwing an error.badfetch event. The value is a <a title=""
href="#TimeDesignation">Time Designation</a>. If not specified, a
value derived from the innermost fetchtimeout property is
used.</td>
</tr>

<tr id="Fetching:fetchhint">
<th>fetchhint</th>
<td>Defines when the interpreter context should retrieve content
from the server. prefetch indicates a file may be downloaded when
the page is loaded, whereas safe indicates a file that should only
be downloaded when actually needed. If not specified, a value
derived from the innermost relevant fetchhint property is
used.</td>
</tr>

<tr id="Fetching:maxage">
<th>maxage</th>
<td>Indicates that the document is willing to use content whose age
is no greater than the specified time in seconds (cf. 'max-age' in
HTTP 1.1 <a href="#RFC2616">[RFC2616]</a>). The document is not
willing to use stale content, unless maxstale is also provided. If
not specified, a value derived from the innermost relevant maxage
property, if present, is used.</td>
</tr>

<tr id="Fetching:maxstale">
<th>maxstale</th>
<td>Indicates that the document is willing to use content that has
exceeded its expiration time (cf. 'max-stale' in HTTP 1.1 <a
href="#RFC2616">[RFC2616]</a>). If maxstale is assigned a value,
then the document is willing to accept content that has exceeded
its expiration time by no more than the specified number of
seconds. If not specified, a value derived from the innermost
relevant maxstale property, if present, is used.</td>
</tr>
</tbody>
</table>

<p>When content is fetched from a URI, the fetchtimeout attribute
determines how long to wait for the content (starting from the time
when the resource is needed), and the fetchhint attribute
determines when the content is fetched. The caching policy for a
VoiceXML interpreter context utilizes the maxage and maxstale
attributes and is explained in more detail below.</p>

<p>The fetchhint attribute, in combination with the various
fetchhint properties, is merely a hint to the interpreter context
about when it may schedule the fetch of a resource. Telling the
interpreter context that it may prefetch a resource does not
require that the resource be prefetched; it only suggests that the
resource <em>may</em> be prefetched. However, the interpreter
context is always required to honor the safe fetchhint.</p>

<p>When transitioning from one dialog to another, through either a
&lt;subdialog&gt;, &lt;goto&gt;, &lt;submit&gt;, &lt;link&gt;, or
&lt;choice&gt; element, there are additional rules that affect
interpreter behavior. If the referenced URI names a document (e.g.
"doc#dialog"), or if query data is provided (through POST or GET),
then a new document is obtained (either from a local cache,
intermediate cache, or from a origin Web server). When it is
obtained, the document goes through its initialization phase (i.e.,
obtaining and initializing a new application root document if
needed, initializing document variables, and executing document
scripts). The requested dialog (or first dialog if none is
specified) is then initialized and execution of the dialog
begins.</p>

<p>Generally, if a URI reference contains only a fragment (e.g.,
"#my_dialog"), then no document is fetched, and no initialization
of that document is performed. However, &lt;submit&gt; always
results in a fetch, and if a fragment is accompanied by a namelist
attribute there will also be a fetch.</p>

<p>Another exception is when a URI reference in a leaf document
references the application root document. In this case, the root
document is transitioned to without fetching and without
initialization even if the URI reference contains an absolute or
relative URI (see <a href="#ApplicationRoot"><b>4.5.2.2 Application
Root</b></a> and <a href="#RFC2396">[RFC2396]</a>). However, if the
URI reference to the root document contains a query string or a
namelist attribute, the root document is fetched.</p>

<p>Elements that fetch VoiceXML documents also support the
following additional attribute:</p>

<table border="1">
<caption>Table 97: Additional Fetch Attribute</caption>

<tbody>
<tr>
<th>fetchaudio</th>
<td>The URI of the audio clip to play while the fetch is being
done. If not specified, the fetchaudio property is used, and if
that property is not set, no audio is played during the fetch. The
fetching of the audio clip is governed by the audiofetchhint,
audiomaxage, audiomaxstale, and fetchtimeout properties in effect
at the time of the fetch. The playing of the audio clip is governed
by the fetchaudiodelay, and fetchaudiominimum properties in effect
at the time of the fetch.</td>
</tr>
</tbody>
</table>

<p>The fetchaudio attribute is useful for enhancing a user
experience when there may be noticeable delays while the next
document is retrieved. This can be used to play background music,
or a series of announcements. When the document is retrieved, the
audio file is interrupted if it is still playing. If an error
occurs retrieving fetchaudio from its URI, no badfetch event is
thrown and no audio is played during the fetch.</p>
</div>

<div class="div3">
<h4><a name="Caching" id="Caching" />8.1.2 Caching</h4>

<p>The VoiceXML interpreter context, like <a href="#">[HTML]</a>
visual browsers, can use caching to improve performance in fetching
documents and other resources; audio recordings (which can be quite
large) are as common to VoiceXML documents as images are to HTML
pages. In a visual browser it is common to include end user
controls to update or refresh content that is perceived to be
stale. This is not the case for the VoiceXML interpreter context,
since it lacks equivalent end user controls. Thus enforcement of
cache refresh is at the discretion of the document through
appropriate use of the maxage, and maxstale attributes.</p>

<p>The caching policy used by the VoiceXML interpreter context must
adhere to the cache correctness rules of HTTP 1.1 (<a
href="#RFC2616">[RFC2616]</a>). In particular, the Expires and
Cache-Control headers must be honored. The following algorithm
summarizes these rules and represents the interpreter context
behavior when requesting a resource:</p>

<ul>
<li>If the resource is not present in the cache, fetch it from the
server using get.</li>

<li>If the resource is in the cache,

<ul>
<li>If a maxage value is provided, 

<ul>
<li>If age of the cached resource &lt;= maxage, 

<ul>
<li>If the resource has expired, 

<ul>
<li>Perform maxstale check.</li>
</ul>
</li>

<li>Otherwise, use the cached copy.</li>
</ul>
</li>

<li>Otherwise, fetch it from the server using get.</li>
</ul>
</li>

<li>Otherwise, 

<ul>
<li>If the resource has expired, 

<ul>
<li>Perform maxstale check.</li>
</ul>
</li>

<li>Otherwise, use the cached copy.</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>The "maxstale check" is:</p>

<ul>
<li>If maxstale is provided, 

<ul>
<li>If cached copy has exceeded its expiration time by no more than
maxstale seconds, then use the cached copy.</li>

<li>Otherwise, fetch it from the server using get.</li>
</ul>
</li>

<li>Otherwise, fetch it from the server using get.</li>
</ul>

<p>Note: it is an optimization to perform a "get if modified" on a
document still present in the cache when the policy requires a
fetch from the server.</p>

<p>The maxage and maxstale properties are allowed to have no
default value whatsoever. If the value is not provided by the
document author, and the platform does not provide a default value,
then the value is undefined and the 'Otherwise' clause of the
algorithm applies. All other properties must provide a default
value (either as given by the specification or by the
platform).</p>

<p>While the maxage and maxstale attributes are drawn from and
directly supported by HTTP 1.1, some resources may be addressed by
URIs that name protocols other than HTTP. If the protocol does not
support the notion of resource age, the interpreter context shall
compute a resource's age from the time it was received. If the
protocol does not support the notion of resource staleness, the
interpreter context shall consider the resource to have expired
immediately upon receipt.</p>

<div class="div4">
<h5><a name="Controlling_the_Caching_Policy"
id="Controlling_the_Caching_Policy" />8.1.2.1 Controlling the
Caching Policy</h5>

<p>VoiceXML allows the author to override the default caching
behavior for each use of each resource (except for any document
referenced by the &lt;vxml&gt; element's application attribute:
there is no markup mechanism to control the caching policy for an
application root document).</p>

<p>Each resource-related element may specify maxage and maxstale
attributes. Setting maxage to a non-zero value can be used to get a
fresh copy of a resource that may not have yet expired in the
cache. A fresh copy can be unconditionally requested by setting
maxage to zero.</p>

<p>Using maxstale enables the author to state that an expired copy
of a resource, that is not too stale (according to the rules of
HTTP 1.1), may be used. This can improve performance by eliminating
a fetch that would otherwise be required to get a fresh copy. It is
especially useful for authors who may not have direct server-side
control of the expiration dates of large static files.</p>
</div>
</div>

<div class="div3">
<h4><a name="Prefetching" id="Prefetching" />8.1.3 Prefetching</h4>

<p>Prefetching is an optional feature that an interpreter context
may implement to obtain a resource before it is needed. A resource
that may be prefetched is identified by an element whose fetchhint
attribute equals "prefetch". When an interpreter context does
prefetch a resource, it must ensure that the resource fetched is
precisely the one needed. In particular, if the URI is computed
with an expr attribute, the interpreter context must not move the
fetch up before any assignments to the expression's variables.
Likewise, the fetch for a &lt;submit&gt; must not be moved prior to
any assignments of the namelist variables.</p>

<p>The expiration status of a resource must be checked on each use
of the resource, and, if its fetchhint attribute is "prefetch",
then it is prefetched. The check must follow the caching policy
specified in Section 6.1.2.</p>
</div>

<div class="div3">
<h4><a name="Protocols" id="Protocols" />8.1.4 Protocols</h4>

<p>The "http" URI scheme must be supported by VoiceXML platforms,
the "https" protocol should be supported and other URI protocols
may be supported.</p>
</div>
</div>

<div class="div2">
<h3><a name="Properties" id="Properties" />8.2 Properties</h3>

<p>Properties are used to set values that affect platform behavior,
such as the recognition process, timeouts, caching policy, etc.</p>

<p>The following types of properties are defined: speech
recognition (<a href="#Properties:ASR"><b>8.2.1 Speech Recognition
Properties</b></a>), DTMF recognition (<a
href="#Properties:DTMF"><b>8.2.2 DTMF Recognition
Properties</b></a>), prompt and collect (<a
href="#Properties:PromptandCollect"><b>8.2.3 Prompt and Collect
Properties</b></a>), media (<a href="#Properties:Media"><b>8.2.4
Media Properties</b></a>), fetching (<a
href="#Properties:Fetch"><b>8.2.5 Fetch Properties</b></a>) and
miscellaneous (<a href="#Properties:Misc"><b>8.2.6 Miscellaneous
Properties</b></a>) properties.</p>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">
<p>Open issue: should the specification provide specific default
values rather than platform-specific?</p>

<p>Open issue: Should we add a 'type' column for all
properties?</p>
</td>
</tr>
</table>

<div class="div3">
<h4><a name="Properties:ASR" id="Properties:ASR" />8.2.1 Speech
Recognition Properties</h4>

<p>The following generic speech recognition properties are
defined.</p>

<table border="1">
<caption>Table 98: Speech Recognition Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr>
<th>confidencelevel</th>
<td>The speech recognition confidence level, a float value in the
range of 0.0 to 1.0. Results are rejected (a nomatch event is
thrown) when application.lastresult$.confidence is below this
threshold. A value of 0.0 means minimum confidence is needed for a
recognition, and a value of 1.0 requires maximum confidence. The
value is a Real Number Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>).</td>
<td>0.5</td>
</tr>

<tr>
<th>sensitivity</th>
<td>Set the sensitivity level. A value of 1.0 means that it is
highly sensitive to quiet input. A value of 0.0 means it is least
sensitive to noise. The value is a Real Number Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>).</td>
<td>0.5</td>
</tr>

<tr>
<th>speedvsaccuracy</th>
<td>A hint specifying the desired balance between speed vs.
accuracy. A value of 0.0 means fastest recognition. A value of 1.0
means best accuracy. The value is a Real Number Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>).</td>
<td>0.5</td>
</tr>

<tr>
<th>completetimeout</th>
<td>The length of silence required following user speech before the
speech recognizer finalizes a result (either accepting it or
throwing a nomatch event). The complete timeout is used when the
speech is a complete match of an active grammar. By contrast, the
incomplete timeout is used when the speech is an incomplete match
to an active grammar. A long complete timeout value delays the
result completion and therefore makes the computer's response slow.
A short complete timeout may lead to an utterance being broken up
inappropriately. Reasonable complete timeout values are typically
in the range of 0.3 seconds to 1.0 seconds. The value is a Time
Designation (see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>). See <a href="#Timing_Properties"><b>8.3
Speech and DTMF Input Timing Properties</b></a>. Although platforms
must parse the completetimeout property, platforms are not required
to support the behavior of completetimeout. Platforms choosing not
to support the behavior of completetimeout must so document and
adjust the behavior of the <em>incompletetimeout</em> property as
described below.</td>
<td>platform-dependent</td>
</tr>

<tr>
<th>incompletetimeout</th>
<td>The required length of silence following user speech after
which a recognizer finalizes a result. The incomplete timeout
applies when the speech prior to the silence is an incomplete match
of all active grammars.&nbsp; In this case, once the timeout is
triggered, the partial result is rejected (with a nomatch event).
The incomplete timeout also applies when the speech prior to the
silence is a complete match of an active grammar, but where it is
possible to speak further and still match the grammar. By contrast,
the complete timeout is used when the speech is a complete match to
an active grammar and no further words can be spoken. A long
incomplete timeout value delays the result completion and therefore
makes the computer's response slow. A short incomplete timeout may
lead to an utterance being broken up inappropriately. The
incomplete timeout is usually longer than the complete timeout to
allow users to pause mid-utterance (for example, to breathe). See
<a href="#Timing_Properties"><b>8.3 Speech and DTMF Input Timing
Properties</b></a> Platforms choosing not to support the
<em>completetimeout</em> property (described above) must use the
maximum of the completetimeout and incompletetimeout values as the
value for the incompletetimeout. The value is a Time Designation
(see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>undefined?</td>
</tr>

<tr>
<th>maxspeechtimeout</th>
<td>The maximum duration of user speech. If this time elapsed
before the user stops speaking, the event "maxspeechtimeout" is
thrown. The value is a Time Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>).</td>
<td>platform-dependent</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="Properties:DTMF" id="Properties:DTMF" />8.2.2 DTMF
Recognition Properties</h4>

<p>The following generic DTMF recognition properties are
defined.</p>

<table border="1">
<caption>Table 99: DTMF Recognition Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr>
<th>interdigittimeout</th>
<td>The inter-digit timeout value to use when recognizing DTMF
input. The value is a Time Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>). See
<a href="#Timing_Properties"><b>8.3 Speech and DTMF Input Timing
Properties</b></a>.</td>
<td>platform-dependent</td>
</tr>

<tr>
<th>termtimeout</th>
<td>The terminating timeout to use when recognizing DTMF input. The
value is a Time Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>). <a
href="#Timing_Properties"><b>8.3 Speech and DTMF Input Timing
Properties</b></a>.</td>
<td>0s</td>
</tr>

<tr>
<th>termchar</th>
<td>The terminating DTMF character for DTMF input recognition. See
<a href="#Timing_Properties"><b>8.3 Speech and DTMF Input Timing
Properties</b></a>.</td>
<td>#</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="Properties:PromptandCollect"
id="Properties:PromptandCollect" />8.2.3 Prompt and Collect
Properties</h4>

<p>The following properties are defined to apply to the fundamental
platform prompt and collect cycle.</p>

<table border="1">
<caption>Table 100: Prompt and Collect Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr id="Property:bargein">
<th>bargein</th>
<td>The bargein attribute to use for prompts. Setting this to true
allows bargein by default. Setting it to false disallows
bargein.</td>
<td>true</td>
</tr>

<tr id="Property:bargeintype">
<th>bargeintype</th>
<td>Sets the type of bargein to be speech or hotword. See "Bargein
type" (link TBD).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:timeout">
<th>timeout</th>
<td>The time after which a noinput event is thrown by the platform.
The value is a Time Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>). See
<a href="#Timing_Properties"><b>8.3 Speech and DTMF Input Timing
Properties</b></a>.</td>
<td>platform-dependent</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="Properties:Media" id="Properties:Media" />8.2.4 Media
Properties</h4>

<p>The following properties are defined to apply to output
media.</p>

<table border="1">
<caption>Table 101: Media Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr id="Property:outputmodes">
<th>outputmodes</th>
<td>
<p>Determines which modes may be used for media output. The value
is a space separated list of media types (see media 'type' in
TBD).</p>

<p>This property is typically used with container file formats,
such as "video/3gpp", which support storage of multiple media
types. For example, to play both audio and video to the remote
connection, the property would be set to "audio video". To play
only the video, the property is set to "video".</p>

<p>If the value contains a media type which is not supported by the
platform, the connection or the value of the &lt;media&gt; element
<code>type</code> property, then that media type is ignored.</p>
</td>
<td>The default value depends on the negotiated media between the
local and remote devices. It is the space separated list of media
types specified in the <code>session.connection.media</code> array
elements' <code>type</code> property where the associated
<code>direction</code> property is <code>sendrecv</code> or
<code>recvonly</code>.</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="Properties:Fetch" id="Properties:Fetch" />8.2.5 Fetch
Properties</h4>

<p>The following properties pertain to the fetching of new
documents and resources.</p>

<p>Note that maxage and maxstale properties may have no default
value - see <a href="#Caching"><b>8.1.2 Caching</b></a>.</p>

<table border="1">
<caption>Table 102: Fetch Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr id="Property:audiofetchhint">
<th>audiofetchhint</th>
<td>This tells the platform whether or not it can attempt to
optimize dialog interpretation by pre-fetching audio. The value is
either safe to say that audio is only fetched when it is needed,
never before; or prefetch to permit, but not require the platform
to pre-fetch the audio.</td>
<td>prefetch</td>
</tr>

<tr id="Property:audiofetchtimeout">
<th>audiofetchtimeout</th>
<td>The timeout for audio fetches. The value is a Time Designation
(see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:audiomaxage">
<th>audiomaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached audio resources.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:audiomaxstale">
<th>audiomaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached audio resources.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:documentfetchhint">
<th>documentfetchhint</th>
<td>Tells the platform whether or not documents may be pre-fetched.
The value is either safe (the default), or prefetch.</td>
<td>safe</td>
</tr>

<tr id="Property:documentfetchtimeout">
<th>documentfetchtimeout</th>
<td>The timeout for document fetches. The value is a Time
Designation (see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:documentmaxage">
<th>documentmaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached documents.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:documentmaxstale">
<th>documentmaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached documents.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:grammarfetchhint">
<th>grammarfetchhint</th>
<td>Tells the platform whether or not grammars may be pre-fetched.
The value is either prefetch (the default), or safe.</td>
<td>prefetch</td>
</tr>

<tr id="Property:grammarfetchtimeout">
<th>grammarfetchtimeout</th>
<td>The timeout for grammar fetches. The value is a Time
Designation (see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:grammarmaxage">
<th>grammarmaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached grammars.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:grammarmaxstale">
<th>grammarmaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached grammars.</td>
<td>platform-specific.</td>
</tr>

<tr id="Property:mediafetchhint">
<th>mediafetchhint</th>
<td>Tells the platform whether or not media files may be
pre-fetched. The value is either prefetch (the default), or
safe.</td>
<td>prefetch</td>
</tr>

<tr id="Property:mediafetchtimeout">
<th>mediafetchtimeout</th>
<td>The timeout for media fetches. The value is a Time Designation
(see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:mediamaxage">
<th>mediamaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached media.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:mediamaxstale">
<th>mediamaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached media.</td>
<td>platform-specific.</td>
</tr>

<tr id="Property:objectfetchhint">
<th>objectfetchhint</th>
<td>Tells the platform whether the URI contents for &lt;object&gt;
may be pre-fetched or not. The values are prefetch, or safe.</td>
<td>prefetch</td>
</tr>

<tr id="Property:objectfetchtimeout">
<th>objectfetchtimeout</th>
<td>The timeout for objectfetches. The value is a Time Designation
(see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:objectmaxage">
<th>objectmaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached objects.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:objectmaxstale">
<th>objectmaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached objects.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:scriptfetchhint">
<th>scriptfetchhint</th>
<td>Tells whether scripts may be pre-fetched or not. The values are
prefetch (the default), or safe.</td>
<td>prefetch</td>
</tr>

<tr id="Property:scriptfetchtimeout">
<th>scriptfetchtimeout</th>
<td>The timeout for script fetches. The value is a Time Designation
(see <a href="#ValueDesignations"><b>8.4 Value
Designations</b></a>).</td>
<td>platform-specific</td>
</tr>

<tr id="Property:scriptmaxage">
<th>scriptmaxage</th>
<td>Tells the platform the maximum acceptable age, in seconds, of
cached scripts.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:scriptmaxstale">
<th>scriptmaxstale</th>
<td>Tells the platform the maximum acceptable staleness, in
seconds, of expired cached scripts.</td>
<td>platform-specific.</td>
</tr>

<tr id="Property:fetchaudio">
<th>fetchaudio</th>
<td>The URI of the audio to play while waiting for a document to be
fetched. The default is not to play any audio during fetch delays.
There are no fetchaudio properties for audio, grammars, objects,
and scripts. The fetching of the audio clip is governed by the
audiofetchhint, audiomaxage, audiomaxstale, and fetchtimeout
properties in effect at the time of the fetch. The playing of the
audio clip is governed by the fetchaudiodelay, and
fetchaudiominimum properties in effect at the time of the
fetch.</td>
<td>undefined</td>
</tr>

<tr id="Property:fetchaudiodelay">
<th>fetchaudiodelay</th>
<td>The time interval to wait at the start of a fetch delay before
playing the fetchaudio source. The value is a Time Designation (see
<a href="#ValueDesignations"><b>8.4 Value Designations</b></a>).
The default interval is platform-dependent, e.g. "2s".&nbsp; The
idea is that when a fetch delay is short, it may be better to have
a few seconds of silence instead of a bit of fetchaudio that is
immediately cut off.</td>
<td>platform-specific</td>
</tr>

<tr id="Property:fetchaudiominimum">
<th>fetchaudiominimum</th>
<td>The minimum time interval to play a fetchaudio source, once
started, even if the fetch result arrives in the meantime. The
value is a Time Designation (see <a
href="#ValueDesignations"><b>8.4 Value Designations</b></a>). The
default is platform-dependent, e.g., "5s".&nbsp; The idea is that
once the user does begin to hear fetchaudio, it should not be
stopped too quickly.</td>
<td>platform-specific</td>
</tr>
</tbody>
</table>
</div>

<div class="div3">
<h4><a name="Properties:Misc" id="Properties:Misc" />8.2.6
Miscellaneous Properties</h4>

<p>The following miscellaneous properties are defined.</p>

<table border="1">
<caption>Table 103: Miscellaneous Properties</caption>

<tbody>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>

<tr>
<th>inputmodes</th>
<td>This property determines which input modality to use. The input
modes to enable: dtmf and voice. On platforms that support both
modes, inputmodes defaults to "dtmf voice". To disable speech
recognition, set inputmodes to "dtmf". To disable DTMF, set it to
"voice". One use for this would be to turn off speech recognition
in noisy environments. Another would be to conserve speech
recognition resources by turning them off where the input is always
expected to be DTMF. This property does not control the activation
of grammars. For instance, voice-only grammars may be active when
the inputmode is restricted to DTMF. Those grammars would not be
matched, however, because the voice input modality is not
active.</td>
<td>???</td>
</tr>

<tr>
<th>universals</th>
<td>Platforms may optionally provide platform-specific universal
command grammars, such as "help", "cancel", or "exit" grammars,
that are always active (except in the case of modal input items -
see "Activation of Grammars" (link TBD)) and which generate
specific events. Note that relying on platform-provided grammars is
not good practice for production-grade applications (see <a
href="#BuiltinModule"><b>6.11 Builtin Grammar Module</b></a>).
Applications choosing to migrate from universals grammars to a more
the robust developer-specified grammars should replace the
universals &lt;property&gt; with one or more &lt;link&gt; (TODO,
hyperlink) element(s). Because &lt;link&gt;s can also generate the
same events as universal grammars, and because the &lt;catch&gt;
handlers for the universal grammars persist outside the universals
&lt;property&gt;, the migration should be seamless. The value
"none" is the default, and means that all platform default
universal command grammars are disabled. The value "all" turns them
all on. Individual grammars are enabled by listing their names
separated by spaces; for example, "cancel exit help".</td>
<td>none</td>
</tr>

<tr>
<th>maxnbest</th>
<td>This property controls the maximum size of the
"application.lastresult$" array; the array is constrained to be no
larger than the value specified by 'maxnbest'. This property has a
minimum value of 1.</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="div2">
<h3><a name="Timing_Properties" id="Timing_Properties" />8.3 Speech
and DTMF Input Timing Properties</h3>

<p>The various timing properties for speech and DTMF recognition
work together to define the user experience. The ways in which
these different timing parameters function are outlined in the
timing diagrams below. In these diagrams, the start for wait of
DTMF input, or user speech both occur at the time that the last
prompt has finished playing.</p>

<div class="div3">
<h4><a name="d3e9650" id="d3e9650" />8.3.1 DTMF Grammars</h4>

<p>DTMF grammars use timeout, interdigittimeout, termtimeout and
termchar as described in <a href="#Properties:DTMF"><b>8.2.2 DTMF
Recognition Properties</b></a> to tailor the user experience. The
effects of these are shown in the following timing diagrams.</p>

<div class="div4">
<h5><a name="timeout_No_Input_Provided"
id="timeout_No_Input_Provided" />8.3.1.1 timeout, No Input
Provided</h5>

<p>The timeout parameter determines when the &lt;noinput&gt; event
is thrown because the user has failed to enter any DTMF. Once the
first DTMF has been entered, this parameter has no further
effect.</p>

<p><img class="center" src="Images/dtmfTimeoutNoinput.gif"
alt="Timing diagram for timeout when no input provided" /></p>

<p class="caption">Figure 17: Timing diagram for timeout when no
input provided.</p>
</div>

<div class="div4">
<h5><a name="interdigittimeout_Grammar_is_Not_Ready_to_Terminate"
id="interdigittimeout_Grammar_is_Not_Ready_to_Terminate" />8.3.1.2
interdigittimeout, Grammar is Not Ready to Terminate</h5>

<p>In the following diagram, the interdigittimeout determines when
the nomatch event is thrown because a DTMF grammar is not yet
recognized, and the user has failed to enter additional DTMF.</p>

<p><img class="center" src="Images/dtmfIDTNotReady.gif"
alt="Timing diagram for interdigittimeout, grammar is not ready to terminate" /></p>

<p class="caption">Figure 18: Timing diagram for interdigittimeout,
grammar is not ready to terminate.</p>
</div>

<div class="div4">
<h5><a name="interdigittimeout_Grammar_is_Ready_to_Terminate"
id="interdigittimeout_Grammar_is_Ready_to_Terminate" />8.3.1.3
interdigittimeout, Grammar is Ready to Terminate</h5>

<p>The example below shows the situation when a DTMF grammar could
terminate, or extend by the addition of more DTMF input, and the
user has elected not to provide any further input.</p>

<p><img class="center" src="Images/dtmfIDTReady.gif"
alt="Timing diagram for interdigittimeout, grammar is ready to terminate" /></p>

<p class="caption">Figure 19: Timing diagram for interdigittimeout,
grammar is ready to terminate.</p>
</div>

<div class="div4">
<h5><a name="termchar_and_interdigittimeout_Grammar_Can_Terminate"
id="termchar_and_interdigittimeout_Grammar_Can_Terminate" />8.3.1.4
termchar and interdigittimeout, Grammar Can Terminate</h5>

<p>In the example below, a termchar is non-empty, and is entered by
the user before an interdigittimeout expires, to signify that the
users DTMF input is complete; the termchar is not included as part
of the recognized value.</p>

<p><img class="center" src="Images/dtmfIDTTermchar.gif"
alt="Timing diagram for termchar and interdigittimeout, grammar can terminate" /></p>

<p class="caption">Figure 20: Timing diagram for interdigittimeout,
Timing diagram for termchar and interdigittimeout, grammar can
terminate.</p>
</div>

<div class="div4">
<h5><a name="termchar_Empty_When_Grammar_Must_Terminate"
id="termchar_Empty_When_Grammar_Must_Terminate" />8.3.1.5 termchar
Empty When Grammar Must Terminate</h5>

<p>In the example below, the entry of the last DTMF has brought the
grammar to a termination point at which no additional DTMF is
expected. Since termchar is empty, there is no optional terminating
character permitted, thus the recognition ends and the recognized
value is returned.</p>

<p><img class="center" src="Images/dtmfMustTerminate1.gif"
alt="Timing diagram for termchar empty when grammar must terminate" /></p>

<p class="caption">Figure 21: Timing diagram for termchar empty
when grammar must terminate.</p>
</div>

<div class="div4">
<h5><a name="d3e9702" id="d3e9702" />8.3.1.6 termchar Non-Empty and
termtimeout When Grammar Must Terminate</h5>

<p>In the example below, the entry of the last DTMF has brought the
grammar to a termination point at which no additional DTMF is
allowed by the grammar. If the termchar is non-empty, then the user
can enter an optional termchar DTMF. If the user fails to enter
this optional DTMF within termtimeout, the recognition ends and the
recognized value is returned. If the termtimeout is 0s (the
default), then the recognized value is returned immediately after
the last DTMF allowed by the grammar, without waiting for the
optional termchar. Note: the termtimeout applies only when no
additional input is allowed by the grammar; otherwise, the
interdigittimeout applies.</p>

<p><img class="center" src="Images/dtmfMustTerminate2.gif"
alt="Timing diagram for termchar non-empty and termtimeout when grammar must terminate" /></p>

<p class="caption">Figure 22: Timing diagram for termchar non-empty
and termtimeout when grammar must terminate.</p>
</div>

<div class="div4">
<h5><a name="d3e9711" id="d3e9711" />8.3.1.7 termchar Non-Empty and
termtimeout When Grammar Must Terminate</h5>

<p>In this example, the entry of the last DTMF has brought the
grammar to a termination point at which no additional DTMF is
allowed by the grammar. Since the termchar is non-empty, the user
enters the optional termchar within termtimeout causing the
recognized value to be returned (excluding the termchar).</p>

<p><img class="center" src="Images/dtmfMustTerminate3.gif"
alt="Timing diagram for termchar non-empty when grammar must terminate" /></p>

<p class="caption">Figure 23: Timing diagram for termchar non-empty
when grammar must terminate.</p>
</div>

<div class="div4">
<h5><a name="Invalid_DTMF_Input" id="Invalid_DTMF_Input" />8.3.1.8
Invalid DTMF Input</h5>

<p>While waiting for the first or additional DTMF, three different
timeouts may determine when the user's input is considered
complete. If no DTMF has been entered, the timeout applies; if some
DTMF has been entered but additional DTMF is valid, then the
interdigittimeout applies; and if no additional DTMF is legal, then
the termtimeout applies. At each point, the user may enter DTMF
which is not permitted by the active grammar(s). This causes the
collected DTMF string to be invalid. Additional digits will be
collected until either the termchar is pressed or the
interdigittimeout has elapsed. A nomatch event is then
generated.</p>
</div>
</div>

<div class="div3">
<h4><a name="d3e9725" id="d3e9725" />8.3.2 Speech Grammars</h4>

<p>Speech grammars use timeout, completetimeout, and
incompletetimeout as described in <a
href="#Properties:PromptandCollect"><b>8.2.3 Prompt and Collect
Properties</b></a> and <a href="#Properties:ASR"><b>8.2.1 Speech
Recognition Properties</b></a> to tailor the user experience. The
effects of these are shown in the following timing diagrams.</p>

<div class="div4">
<h5><a name="timeout_When_No_Speech_Provided"
id="timeout_When_No_Speech_Provided" />8.3.2.1 timeout When No
Speech Provided</h5>

<p>In the example below, the timeout parameter determines when the
noinput event is thrown because the user has failed to speak.</p>

<p><img class="center" src="Images/speechNoinput.gif"
alt="Timing diagram for timeout when no speech provided" /></p>

<p class="caption">Figure 24: Timing diagram for timeout when no
speech provided.</p>
</div>

<div class="div4">
<h5><a name="completetimeout_With_Speech_Grammar_Recognized"
id="completetimeout_With_Speech_Grammar_Recognized" />8.3.2.2
completetimeout With Speech Grammar Recognized</h5>

<p>In the example above, the user provided a utterance that was
recognized by the speech grammar. After a silence period of
completetimeout has elapsed, the recognized value is returned.</p>

<p><img class="center" src="Images/speechRecognized.gif"
alt="Timing diagram for completetimeout with speech grammar recognized" /></p>

<p class="caption">Figure 25: Timing diagram for completetimeout
with speech grammar recognized.</p>
</div>

<div class="div4">
<h5><a name="incompletetimeout_with_Speech_Grammar_Unrecognized"
id="incompletetimeout_with_Speech_Grammar_Unrecognized" />8.3.2.3
incompletetimeout with Speech Grammar Unrecognized</h5>

<p>In the example above, the user provided a utterance that is not
as yet recognized by the speech grammar but is the prefix of a
legal utterance. After a silence period of incompletetimeout has
elapsed, a nomatch event is thrown.</p>

<p><img class="center" src="Images/speechUnrecognized.gif"
alt="Timing diagram for incompletetimeout with speech grammar unrecognized" /></p>

<p class="caption">Figure 26: Timing diagram for incompletetimeout
with speech grammar unrecognized.</p>
</div>
</div>
</div>

<div class="div2">
<h3><a name="ValueDesignations" id="ValueDesignations" />8.4 Value
Designations</h3>

<p>Several VoiceXML parameter values follow the conventions used in
the W3C's Cascading Style Sheet Recommendation <a
href="#">[CSS2]</a>.</p>

<div class="div3">
<h4><a name="IntegerDesignation" id="IntegerDesignation" />8.4.1
Integers</h4>

<p>Integers are specified in decimal notation only. Integers may be
preceded by a "-" or "+" to indicate the sign.</p>

<p>An integer consists of one or more digits "0" to "9".</p>
</div>

<div class="div3">
<h4><a name="RealNumberDesignation"
id="RealNumberDesignation" />8.4.2 Real Numbers</h4>

<p>Real numbers are specified in decimal notation only. Real
numbers may be preceded by a "-" or "+" to indicate the sign.</p>

<p>A real number may be an integer, or it may be zero or more
digits followed by a dot (.) followed by one or more digits.</p>
</div>

<div class="div3">
<h4><a name="TimeDesignation" id="TimeDesignation" />8.4.3
Times</h4>

<p>Time designations consist of a non-negative real number followed
by a time unit identifier. The time unit identifiers are:</p>

<ul>
<li>ms: milliseconds</li>

<li>s: seconds</li>
</ul>

<p>Examples include: "3s", "850ms", "0.7s", ".5s" and "+1.5s".</p>
</div>
</div>
</div>

<div class="div1">
<h2><a name="Integration" id="Integration" />9 Integration with
Other Markup Languages</h2>

<p>This section presents some initial thoughts on how VoiceXML
might be embedded within SCXML and how flow control languages such
as SCXML and CCXML might be integrated into VoiceXML.</p>

<div class="div2">
<h3><a name="Integration:WithinSCXML"
id="Integration:WithinSCXML" />9.1 Embedding of VoiceXML within
SCXML</h3>

<p>The following bank application example demonstrates how external
vxml application could be invoked by a scxml script and vice versa.
The state machine and flow control was implemented in the
BankApp.scxml. The call is started from the BankApp.scxml, it will
first call BankApp.vxml's form "getAccountNum" to collect the
account number, then query database for checking and saving
balance. The BankApp.scxml will then invoke the form "playBalance".
If this form finds the accountType is not defined, it will invoke
the AccountType.scxml, which will call BankApp.vxml form
"getAccountType" to get the accountType. The "playBalance" will
then play the balance on the corresponding account and return the
call back to the BankApp.scxml.</p>

<p>BankApp.scxml</p>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml" xmlns:my="http://scxml.example.org/" version="1.0" initial="getAccountNum" profile="ecmascript" &gt;
 
  &lt;state id="getAccountNum"&gt;
      &lt;invoke targettype="vxml3" src="BankApp.vxml#getAccountNum" /&gt;
      &lt;transition event="vxml3.gotAccountNum" target="getBalance"/&gt;
  &lt;/state&gt;
 
  &lt;state id="getBalance"&gt;
      &lt;datamodel&gt;
           &lt;data name="method" expr="'getBalance'"/&gt;
           &lt;data name="accountNum" expr="_data.accountNum"/&gt;
      &lt;/datamodel&gt;
      &lt;send targettype="basichttp" target="BankDB.do" namelist="method accountNum" /&gt;
      &lt;transition event="basichttp.gotBalance" target="playingBalance"/&gt;
  &lt;/state&gt;
 
  &lt;state id="playBalance"&gt;
      &lt;datamodel&gt;
           &lt;data name="checking_balance" expr="_data.checking.balance" /&gt;
           &lt;data name="saving_balance" expr="_data.saving.balance" /&gt;
      &lt;/datamodel&gt;
      &lt;invoke targettype="vxml3" target="BankApp.vxml#playBalance" namelist="checking_balance saving_balance" /&gt;
      &lt;transition event="vxml3.playedBalance" target="exit" /&gt;
  &lt;/state&gt;
 
  &lt;final id="exit"/&gt;
&lt;/scxml&gt;
</pre>
</div>

<p>AccountType.scxml</p>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml" xmlns:my="http://scxml.example.org/" version="1.0" initial="getAccountType" profile="ecmascript" &gt;
 
  &lt;state id="getAccountType"&gt;
      &lt;invoke targettype="vxml3" src="BankApp.vxml#getAccountType" /&gt;
  &lt;transition event="vxml3.gotAccountType" target="exit"/&gt;
  &lt;/state&gt;
 
  &lt;final id="exit"/&gt;
&lt;/scxml&gt;
</pre>
</div>

<p>BankApp.vxml</p>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
&lt;!-- TODO: need to add final namespace, schema, etc. for vxml element. --&gt;
&lt;vxml version="3.0"&gt;
 
      &lt;form id="getAccountNum"&gt;
            &lt;field name="accountNum"&gt;
                  &lt;grammar src=“accountNum.grxml" type="application/grammar+xml"/&gt;
                  &lt;prompt&gt;
                        Please tell me your account number.
                  &lt;/prompt&gt;
                  &lt;filled&gt;
                        &lt;exit namelist="accountNum"/&gt;
                  &lt;/filled&gt;
            &lt;/field&gt;
      &lt;/form&gt;
 
      &lt;form id="getAccountType"&gt;
            &lt;field name="accountType"&gt;
                  &lt;grammar src=“accountType.grxml" type="application/grammar+xml"/&gt;
                  &lt;prompt&gt;
                        Do you want the balance on checking or saving account?
                  &lt;/prompt&gt;
                  &lt;filled&gt;
                        &lt;exit namelist="accountType"/&gt;
                  &lt;/filled&gt;
            &lt;/field&gt;
      &lt;/form&gt;
     
      &lt;form id="playBalance"&gt;
            &lt;var name="checking_balance"/&gt;
            &lt;var name="saving_balance"/&gt;
            &lt;block&gt;
            &lt;if cond="accountType == undefined"&gt;
 
&lt;!--Here we are trying to invoke the external scxml script. At the time this example is written,
    the syntax to do this has not yet been decided. --&gt;
                  &lt;goto next="AccountType.scxml#getAccountType"/&gt;
            &lt;/if&gt;
                 
            &lt;if cond="accountType == 'checking'"&gt;
                  &lt;prompt&gt;
                    The checking account balance is &lt;value expr="checking_balance"/&gt;.
                  &lt;/prompt&gt;
            &lt;else&gt;
                  &lt;prompt&gt;
                    The saving account balance is &lt;value expr="saving_balance"/&gt;.
                  &lt;/prompt&gt;
            &lt;/if&gt;
                 
            &lt;/block&gt;
      &lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="Integration:InsideVoiceXML"
id="Integration:InsideVoiceXML" />9.2 Integrating Flow Control
Languages into VoiceXML</h3>

<p>State Chart XML (SCXML) could be used as the controller for
managing the dialog in VoiceXML 3.0 applications. A recursive MVC
technique allows SCXML controllers to be placed at session,
document and form levels. Examples of resulting compound documents
(containing V3 and SCXML namespaced elements) appear below for
illustration. A graceful degradation / fallback approach could be
used to ensure backwards compatibility with V2 applications. Note
that the examples below use a new v3:scxmlform element.</p>

<p>[ISSUE: It has been suggested that using the existing v3:form
element instead of a new v3:scxmlform element would be simpler and
more elegant. Although the working group currently knows of no
particular reason why the existing v3:form couldn't be used instead
of a new v3:scxmlform element, the group has not yet discussed this
in detail or agreed that using v3:form in this way is desirable.
The group plans to discuss this and is interested in receiving
public feedback on this possibility.]</p>

<div class="div3">
<h4><a name="Integration:InsideVoiceXML:SCXMLForDialog"
id="Integration:InsideVoiceXML:SCXMLForDialog" />9.2.1 SCXML for
Dialog Management</h4>

<p>Example application scenario:</p>

<ul>
<li>This is an airline travel itinerary modification
application</li>

<li>First order of business is to retrieve an itinerary to be
modified</li>

<li>Itinerary may be identified using either a record locator or
traveler's lastname and other information</li>
</ul>

<p>Below are two flavors of this application using SCXML as the
form-level controller, a system-driven and a user-driven approach.
These use similar set of fields in the form but different dialog
management styles. In the simpler example here, the VUI might
appear similar though there is a system vs. user driven flavor.</p>

<div class="div4">
<h5><a
name="Integration:InsideVoiceXML:SCXMLForDialog:SystemDriven"
id="Integration:InsideVoiceXML:SCXMLForDialog:SystemDriven" />9.2.1.1
System-driven Dialog</h5>

<ul>
<li>Starts off by asking if the record locator is available</li>

<li>If the locator is available, it's requested</li>

<li>If the locator isn't available, the last name and some other
pieces of information are requested to uniquely identify the
itinerary</li>

<li>Once the itinerary is identified, we proceed with application
functions</li>
</ul>

<p>Consider the following sketch of a V3 form for this purpose:</p>

<div class="exampleInner">
<pre>
&lt;v3:scxmlform&gt;

  &lt;scxml:scxml initial="choice"&gt;

    &lt;scxml:state id="choice"&gt;
      &lt;scxml:invoke type="vxml3field" src="#choicefield"/&gt;
      &lt;scxml:transition event="filled.choice" cond="choicefield"
                    target="locator"/&gt;
      &lt;scxml:transition event="filled.choice" cond="!choicefield"
                    target="lastname"/&gt;
    &lt;/scxml:state&gt;

    &lt;scxml:state id="locator"&gt;
      &lt;scxml:invoke type="vxml3field" src="#locatorfield"/&gt;
      &lt;!-- Retrieve record, transition to app menu --&gt;
    &lt;/scxml:state&gt;

    &lt;scxml:state id="lastname"&gt;
      &lt;scxml:invoke type="vxml3field" src="#lastnamefield"/&gt;
      &lt;!-- Collect other information needed to retrieve record,
           then retrieve record and go to app menu --&gt;
    &lt;/scxml:state&gt;

    &lt;!-- Remaining dialog control flow logic omitted --&gt;

  &lt;/scxml:scxml&gt;

  &lt;v3:field name="choicefield"&gt;
    &lt;v3:grammar src="boolean.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      Welcome. Do you have the record locator for your itinerary?
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.choice"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;v3:field name="locatorfield"&gt;
    &lt;v3:grammar src="locator.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      What is the record locator for the itinerary?
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.locator"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;v3:field name="lastnamefield"&gt;
    &lt;v3:grammar src="lastname.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      Please say or spell your last name.
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.lastname"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;!-- Other form items, such as the subsequent application menu omitted
--&gt;

&lt;/v3:scxmlform&gt;
</pre>
</div>
</div>

<div class="div4">
<h5><a name="Integration:InsideVoiceXML:SCXMLForDialog:UserDriven"
id="Integration:InsideVoiceXML:SCXMLForDialog:UserDriven" />9.2.1.2
User-driven Dialog</h5>

<ul>
<li>Starts off by asking what information the user would like to
supply to identify the itinerary</li>

<li>If the user indicates the record locator will be provided, it's
retrieved</li>

<li>If the user indicates the last name will be provided, it's
retrieved (some other pieces of information may be retrieved to
uniquely identify the itinerary)</li>

<li>Once the itinerary is identified, we proceed with application
functions</li>
</ul>

<p>Consider the following sketch of a V3 form for this purpose:</p>

<div class="exampleInner">
<pre>
&lt;v3:scxmlform&gt;

  &lt;scxml:scxml initial="choice"&gt;

    &lt;scxml:state id="choice"&gt;
      &lt;scxml:invoke type="vxml3field" src="#choicefield"/&gt;
      &lt;scxml:transition event="filled.choice" cond="choicefield == 'locator'"
                    target="locator"/&gt;
      &lt;scxml:transition event="filled.choice" cond="choicefield == 'lastname'"
                    target="lastname"/&gt;
    &lt;/scxml:state&gt;

    &lt;scxml:state id="locator"&gt;
      &lt;scxml:invoke type="vxml3field" src="#locatorfield"/&gt;
      &lt;!-- Retrieve record, transition to app menu --&gt;
    &lt;/scxml:state&gt;

    &lt;scxml:state id="lastname"&gt;
      &lt;scxml:invoke type="vxml3field" src="#lastnamefield"/&gt;
      &lt;!-- Collect other information needed to retrieve record,
           then retrieve record and go to app menu --&gt;
    &lt;/scxml:state&gt;

    &lt;!-- Remaining dialog control flow logic omitted --&gt;

  &lt;/scxml:scxml&gt;

  &lt;v3:field name="choicefield"&gt;
    &lt;v3:grammar src="choice.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      Welcome. How would you like to look up your itinerary?
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.choice"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;v3:field name="locatorfield"&gt;
    &lt;v3:grammar src="locator.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      What is the record locator for the itinerary?
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.locator"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;v3:field name="lastnamefield"&gt;
    &lt;v3:grammar src="lastname.grxml" type="application/srgs+xml"/&gt;
    &lt;v3:prompt&gt;
      Please say or spell your last name.
    &lt;v3:prompt&gt;
    &lt;v3:filled&gt;
      &lt;v3:throw event="filled.lastname"/&gt;
    &lt;/v3:filled&gt;
  &lt;/v3:field&gt;

  &lt;!-- Other form items, such as the subsequent application menu omitted
--&gt;

&lt;/v3:scxmlform&gt;
</pre>
</div>
</div>
</div>

<div class="div3">
<h4><a name="Integration:InsideVoiceXML:GracefulDegradation"
id="Integration:InsideVoiceXML:GracefulDegradation" />9.2.2
Graceful Degradation</h4>

<p>One possibility with this approach is that the absence of an
&lt;scxml:scxml&gt; child element in a &lt;v3:scxmlform&gt; could
revert behavior to be identical to a &lt;v2:form&gt; element where
the V2 Form Interpretation Algorithm would be in charge. In the
presence of a &lt;scxml:scxml&gt; child, the FIA would be
suppressed and the more expressive SCXML controller used, which
would allow application developers to design the form VUI in a very
flexible manner. In other words, the following &lt;v3:scxmlform&gt;
below:</p>

<div class="exampleInner">
<pre>
&lt;v3:scxmlform&gt;

  &lt;!-- No SCXML child --&gt;

  &lt;!-- Various form items etc. --&gt;

&lt;/v3:scxmlform&gt;
</pre>
</div>

<p>behaves as would:</p>

<div class="exampleInner">
<pre>
&lt;v2:form&gt;

  &lt;!-- Various form items etc. --&gt;

&lt;/v2:form&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="Integration:InsideVoiceXML:RecursiveMVC"
id="Integration:InsideVoiceXML:RecursiveMVC" />9.2.3 SCXML as Basis
for Recursive MVC</h4>

<p>The above example illustrated a form-level SCXML controller.
SCXML could perhaps also be used as a document level controller,
where it would be managing the interaction across v3:forms, rather
than v3:fields. To illustrate:</p>

<div class="exampleInner">
<pre>
&lt;v3:vxml&gt;

  &lt;scxml:scxml ...&gt;
    &lt;!-- document level controller managing interaction
         across form1, form2 and form3 --&gt;
  &lt;/scxml:scxml&gt;

  &lt;v3:form id="form1"&gt;
    &lt;!-- form1 content, might also have a form level SCXML controller --&gt;
  &lt;/v3:form&gt;

  &lt;v3:form id="form2"&gt;
    &lt;!-- form2 content, might also have a form level SCXML controller --&gt;
  &lt;/v3:form&gt;

  &lt;v3:form id="form3"&gt;
    &lt;!-- form3 content, might also have a form level SCXML controller --&gt;
  &lt;/v3:form&gt;

&lt;/v3:vxml&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

<div class="back">
<div class="div1">
<h2><a name="Acknowledgements" id="Acknowledgements" />A
Acknowledgements</h2>

<p>This version of VoiceXML was written with the participation of
members of the W3C Voice Browser Working Group. The work of the
following members has significantly facilitated the development of
this specification:</p>

<ul>
<li>Emily Bateman, Comverse</li>

<li>Skip Cave, Intervoice</li>

<li>Andrew Fuller, VoxPilot</li>

<li>Jeff Hoepfinger, Sandcherry</li>

<li>Jim Larson, Intervoice</li>

<li>Lakshmi Krishnamurthy, Genesys</li>

<li>Satya Palivela, Intervoice</li>

<li>Joseph Wong, Genesys</li>
</ul>

<p>The W3C Voice Browser Working Group would like to thank the W3C
team, especially Kazuyuki Ashimura and Matt Womer, for their
invaluable administrative and technical support.</p>
</div>

<div class="div1">
<h2><a name="References" id="References" />B References</h2>

<div class="div2">
<h3><a name="d3e9925" id="d3e9925" />B.1 Normative References</h3>

<dl>
<dt class="label"><a name="DFP_Framework"
id="DFP_Framework" />DFP</dt>

<dd><a href="http://www.w3.org/Voice/2006/DFP"><cite>The Voice
Browser DFP Framework</cite></a> W3C Informative Note, February
2006. (See http://www.w3.org/Voice/2006/DFP.)</dd>

<dt class="label"><a name="MMI" id="MMI" />MMI</dt>

<dd><a
href="http://www.w3.org/TR/2009/WD-mmi-arch-20091201/"><cite>Multimodal
Architecture and Interfaces</cite></a> W3C Working Draft, December
2009. (See http://www.w3.org/TR/2009/WD-mmi-arch-20091201/.)</dd>

<dt class="label"><a name="DOM3Events"
id="DOM3Events" />DOM3Events</dt>

<dd><a
href="http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/"><cite>
Document Object Model (DOM) Level 3 Events Specification</cite></a>
Schepers, Höhrmann, Le Hégaret and Pixley. W3C Working Draft,
September 2009. (See
http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/.)</dd>

<dt class="label"><a name="RFC2119" id="RFC2119" />RFC2119</dt>

<dd><a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>Key words
for use in RFCs to Indicate Requirement Levels</cite></a> IETF RFC
2119, 1997. (See http://www.ietf.org/rfc/rfc2119.txt.)</dd>

<dt class="label"><a name="ECMASCRIPT"
id="ECMASCRIPT" />ECMASCRIPT</dt>

<dd><a
href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">
<cite>Standard ECMA-262 ECMAScript Language
Specification</cite></a>, Standard ECMA-262, December 1999. (See
http://www.ecma-international.org/publications/standards/Ecma-262.htm.)</dd>

<dt class="label"><a name="VOICEXML20"
id="VOICEXML20" />VOICEXML20</dt>

<dd><a href="http://www.w3.org/TR/voicexml20/"><cite>Voice
Extensible Markup Language (VoiceXML) Version 2.0</cite></a>
McGlashan et al. W3C Recommendation, March 2004. (See
http://www.w3.org/TR/voicexml20/.)</dd>

<dt class="label"><a name="VOICEXML21"
id="VOICEXML21" />VOICEXML21</dt>

<dd><a href="http://www.w3.org/TR/voicexml21/"><cite>Voice
Extensible Markup Language (VoiceXML) Version 2.1</cite></a> Oshry
et al. W3C Recommendation, May 2007. (See
http://www.w3.org/TR/voicexml21/.)</dd>

<dt class="label"><a name="SSML" id="SSML" />SSML</dt>

<dd><a href="http://www.w3.org/TR/speech-synthesis11/"><cite>Speech
Synthesis Markup Language Version 1.1</cite></a> Burnett and
Shuang. W3C Recommendation, September 2010. (See
http://www.w3.org/TR/speech-synthesis11/.)</dd>

<dt class="label"><a name="SRGS" id="SRGS" />SRGS</dt>

<dd><a href="http://www.w3.org/TR/speech-grammar/"><cite>Speech
Recognition Grammar Specification Version 1.0</cite></a> Hunt and
McGlashan. W3C Recommendation, March 2004. (See
http://www.w3.org/TR/speech-grammar/.)</dd>

<dt class="label"><a name="RFC2616" id="RFC2616" />RFC2616</dt>

<dd><a href="http://www.ietf.org/rfc/rfc2616.txt"><cite>Hypertext
Transfer Protocol -- HTTP/1.1</cite></a> IETF RFC 2616, 1999. (See
http://www.ietf.org/rfc/rfc2616.txt.)</dd>

<dt class="label"><a name="RFC2396" id="RFC2396" />RFC2396</dt>

<dd><a href="http://www.ietf.org/rfc/rfc2396.txt"><cite>Uniform
Resource Identifiers (URI): Generic Syntax</cite></a> IETF RFC
2396, 1998. (See http://www.ietf.org/rfc/rfc2396.txt.)</dd>

<dt class="label"><a name="BCP47" id="BCP47" />BCP47</dt>

<dd><a href="http://www.rfc-editor.org/bcp/bcp47.txt"><cite>Tags
for Identifying Languages and Matching of Language Tags</cite></a>
A. Phillips and M. Davis, Editors. IETF, September 2009. (See
http://www.rfc-editor.org/bcp/bcp47.txt.)</dd>
</dl>
</div>

<div class="div2">
<h3><a name="d3e9988" id="d3e9988" />B.2 Informative
References</h3>
</div>
</div>

<div class="div1">
<h2><a name="Glossary_of_Terms" id="Glossary_of_Terms" />C Glossary
of Terms</h2>

<dl>
<dt class="label">active grammar</dt>

<dd>A speech or DTMF grammar that is currently active. This is
based on the currently executing element, and the scope elements of
the currently defined grammars.</dd>

<dt class="label">application</dt>

<dd>A collection of <em>VoiceXML documents</em> that are tagged
with the same application name attribute.</dd>

<dt class="label">ASR</dt>

<dd>Automatic speech recognition.</dd>

<dt class="label">author</dt>

<dd>The creator of a <em>VoiceXML document.</em></dd>

<dt class="label">catch element</dt>

<dd>A &lt;catch&gt; block or one of its abbreviated forms. Certain
default catch elements are defined by the <em>VoiceXML
interpreter</em>.</dd>

<dt class="label">control item</dt>

<dd>A <em>form item</em> whose purpose is either to contain a block
of procedural logics (&lt;block&gt;) or to allow initial prompts
for a mixed initiative dialog (&lt;initial&gt;).</dd>

<dt class="label">CSS W3C Cascading Style Sheet specification.</dt>

<dd>See <a href="#">[CSS2]</a></dd>

<dt class="label">dialog</dt>

<dd>An interaction with the user specified in a <em>VoiceXML
document</em>. Types of dialogs include <em>forms</em> and
<em>menus</em>.</dd>

<dt class="label">DTMF (Dual Tone Multi-Frequency)</dt>

<dd>Touch-tone or push-button dialing. Pushing a button on a
telephone keypad generates a sound that is a combination of two
tones, one high frequency and the other low frequency.</dd>

<dt class="label">ECMAScript</dt>

<dd>A standard version of JavaScript backed by the European
Computer Manufacturer's Association. See <a
href="#ECMASCRIPT">[ECMASCRIPT]</a></dd>

<dt class="label">event</dt>

<dd>A notification "thrown" by the <em>implementation
platform</em>, <em>VoiceXML interpreter context</em>, <em>VoiceXML
interpreter</em>, or VoiceXML code. Events include exceptional
conditions (semantic errors), normal errors (user did not say
something recognizable), normal events (user wants to exit), and
user defined events.</dd>

<dt class="label">executable content</dt>

<dd>Procedural logic that occurs in &lt;block&gt;, &lt;filled&gt;,
and <em>event handlers</em>.</dd>

<dt class="label">form</dt>

<dd>A <em>dialog</em> that interacts with the <em>user</em> in a
highly flexible fashion with the computer and the <em>user</em>
sharing the initiative.</dd>

<dt class="label">FIA (Form Interpretation Algorithm)</dt>

<dd>An algorithm implemented in a <em>VoiceXML interpreter</em>
which drives the interaction between the user and a VoiceXML form
or menu. See vxml2: Section 2.1.6, vxml2: Appendix C.</dd>

<dt class="label">form item</dt>

<dd>An element of &lt;form&gt; that can be visited during form
execution: &lt;initial&gt;, &lt;block&gt;, &lt;field&gt;,
&lt;record&gt;, &lt;object&gt;, &lt;subdialog&gt;, and
&lt;transfer&gt;.</dd>

<dt class="label">form item variable</dt>

<dd>A variable, either implicitly or explicitly defined, associated
with each <em>form item</em> in a <em>form</em>. If the form item
variable is undefined, the form interpretation algorithm will visit
the form item and use it to interact with the user.</dd>

<dt class="label">implementation platform</dt>

<dd>A computer with the requisite software and/or hardware to
support the types of interaction defined by VoiceXML.</dd>

<dt class="label">input item</dt>

<dd>A <em>form item</em> whose purpose is to input a input item
variable. Input items include &lt;field&gt;, &lt;record&gt;,
&lt;object&gt;, &lt;subdialog&gt;, and &lt;transfer&gt;.</dd>

<dt class="label">[<a name="term-language" id="term-language"
title="language identifier">Definition</a>: language
identifier]</dt>

<dd>A language identifier labels information content as being of a
particular human language variant. Following the XML specification
for language identification <a href="#">[XML]</a>, a legal language
identifier is identified by BCP 47 <a
href="#BCP47">[BCP47]</a>.</dd>

<dt class="label">link</dt>

<dd>A set of grammars that when matched by something the
<em>user</em> says or keys in, either transitions to a new dialog
or document or throws an event in the current form item.</dd>

<dt class="label">menu</dt>

<dd>A <em>dialog</em> presenting the <em>user</em> with a set of
choices and takes action on the selected one.</dd>

<dt class="label">mixed initiative</dt>

<dd>A computer-human interaction in which either the computer or
the human can take initiative and decide what to do next.</dd>

<dt class="label">JSGF</dt>

<dd>Java API Speech Grammar Format. A proposed standard for
representing speech grammars. See <a href="#">[JSGF]</a></dd>

<dt class="label">object</dt>

<dd>A platform-specific capability with an interface available via
VoiceXML.</dd>

<dt class="label">request</dt>

<dd>A collection of data including: a URI specifying a document
server for the data, a set of name-value pairs of data to be
processed (optional), and a method of submission for processing
(optional).</dd>

<dt class="label">script</dt>

<dd>A fragment of logic written in a client-side scripting
language, especially <em>ECMAScript</em>, which is a scripting
language that must be supported by any <em>VoiceXML
interpreter</em>.</dd>

<dt class="label">session</dt>

<dd>A connection between a <em>user</em> and an <em>implementation
platform</em>, e.g. a telephone call to a voice response system.
One session may involve the interpretation of more than one
<em>VoiceXML document</em>.</dd>

<dt class="label">SRGS (Speech Recognition Grammar
Specification)</dt>

<dd>A standard format for context-free speech recognition grammars
being developed by the W3C Voice Browser group. Both ABNF and XML
formats are defined <a href="#SRGS">[SRGS]</a>.</dd>

<dt class="label">SSML (Speech Synthesis Markup Language)</dt>

<dd>A standard format for speech synthesis being developed by the
W3C Voice Browser group <a href="#SSML">[SSML]</a>.</dd>

<dt class="label">subdialog</dt>

<dd>A VoiceXML dialog (or document) invoked from the current
<em>dialog</em> in a manner analogous to function calls.</dd>

<dt class="label">tapered prompts</dt>

<dd>A set of prompts used to vary a message given to the human.
Prompts may be tapered to be more terse with use (field prompting),
or more explicit (help prompts).</dd>

<dt class="label">throw</dt>

<dd>An element that fires an <em>event</em>.</dd>

<dt class="label">TTS</dt>

<dd>text-to-speech; speech synthesis.</dd>

<dt class="label">user</dt>

<dd>A person whose interaction with an <em>implementation
platform</em> is controlled by a <em>VoiceXML
interpreter</em>.</dd>

<dt class="label">URI</dt>

<dd>Uniform Resource Indicator.</dd>

<dt class="label">URL</dt>

<dd>Uniform Resource Locator.</dd>

<dt class="label">VoiceXML document</dt>

<dd>An XML document conforming to the VoiceXML specification.</dd>

<dt class="label">VoiceXML interpreter</dt>

<dd>A computer program that interprets a <em>VoiceXML document</em>
to control an <em>implementation platform</em> for the purpose of
conducting an interaction with a <em>user.</em></dd>

<dt class="label">VoiceXML interpreter context</dt>

<dd>A computer program that uses a <em>VoiceXML interpreter</em> to
interpret a <em>VoiceXML Document</em> and that may also interact
with the <em>implementation platform</em> independently of the
<em>VoiceXML interpreter</em>.</dd>

<dt class="label">W3C</dt>

<dd>World Wide Web Consortium <a
href="http://www.w3.org/">http://www.w3.org/</a></dd>
</dl>
</div>

<div class="div1">
<h2><a name="Schema" id="Schema" />D VoiceXML 3.0 XML Schema</h2>

<div class="div2">
<h3><a name="Schema:Root" id="Schema:Root" />D.1 Schema for VXML
Root Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Form" id="Schema:Form" />D.2 Schema for Form
Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Field" id="Schema:Field" />D.3 Schema for Field
Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Prompt" id="Schema:Prompt" />D.4 Schema for
Prompt Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:BuiltinSSML" id="Schema:BuiltinSSML" />D.5
Schema for Builtin SSML Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Foreach" id="Schema:Foreach" />D.6 Schema for
Foreach Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Data" id="Schema:Data" />D.7 Schema for Data
Access and Manipulation Module</h3>
</div>

<div class="div2">
<h3><a name="Schema:Legacy" id="Schema:Legacy" />D.8 Schema for
Legacy Profile</h3>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="TBD"
                   targetNamespace="TBD" blockDefault="#all"&gt;

    &lt;xsd:annotation&gt;

        &lt;xsd:documentation&gt;

              This is the XML Schema driver for Legacy Profile of Vxml 3.0 specification.

              Please use this namespace for the Legacy Profile:

              "TBD:URL to schema"

        &lt;/xsd:documentation&gt;

        &lt;xsd:documentation source="vxml3-copyright.xsd"/&gt;

    &lt;/xsd:annotation&gt;
 

    &lt;xsd:annotation&gt;

        &lt;xsd:documentation&gt;

            This is the Schema Driver file for Legacy Profile of Vxml 3.0 Specification

            This schema

                + sets the namespace for Legacy Profile of Vxml 3.0 Specification

                + imports external schemas (xml.xsd)

                + imports schema modules 

 
                  Legacy Profile includes the following Modules
 

                   * Vxml Root module 

                   * Form module 

                   * Field module 

                   * Prompt module 

                   * Grammar module 

                   * Data Access and Manipulation Module

          &lt;/xsd:documentation&gt;

    &lt;/xsd:annotation&gt;

    &lt;xsd:import namespace="http://www.w3.org/XML/1998/namespace"
        schemaLocation="http://www.w3.org/2001/xml.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This import brings in the XML namespace attributes

                The XML attributes are used by various modules.

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:import&gt;

 
    &lt;xsd:include schemaLocation="vxml-datatypes.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                    This imports brings in the common datatypes for Vxml.

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml-attribs.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports brings in the common attributes for Vxml.

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-vxmlroot.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Vxml Root module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-form.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Form module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-field.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Field module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-prompt.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Prompt module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-grammar.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Grammar module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

    &lt;xsd:include schemaLocation="vxml3-module-dataacces.xsd"&gt;

        &lt;xsd:annotation&gt;

            &lt;xsd:documentation&gt;

                This imports the Data Access and Manipulation module for Vxml 3.0

            &lt;/xsd:documentation&gt;

        &lt;/xsd:annotation&gt;

    &lt;/xsd:include&gt;

&lt;/xsd:schema&gt;
</pre>
</div>

<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&nbsp;</td>
</tr>

<tr>
<td colspan="2" align="left" valign="top">The schema is incomplete.
It merely imports the schemas for various modules, but doesn't
contain parent/child relationships between modules or constraints
on them. These all need to be specified in the future.</td>
</tr>
</table>
</div>
</div>

<div class="div1">
<h2><a name="V2Convenience" id="V2Convenience" />E Convenience
Syntax in VoiceXML 2.x</h2>

<p>VoiceXML 2 defines shorthand notation for several fundamental
capabilities. For example, some &lt;catch&gt; elements can be
represented in a shortened form:</p>

<div class="exampleInner">
<pre>
&lt;noinput&gt;I didn’t hear anything. &lt;/noinput&gt;
</pre>
</div>

<p>is equivalent to:</p>

<div class="exampleInner">
<pre>
&lt;catch event="noinput"&gt; I didn’t hear anything. &lt;/catch&gt;
</pre>
</div>

<p>This notation could be transformed via standard text
substitution tools.</p>

<div class="div2">
<h3><a name="V2Convenience:SimplifiedDialogs"
id="V2Convenience:SimplifiedDialogs" />E.1 Simplified Dialog
Structure</h3>

<p>In addition to the fundamental &lt;form&gt; / &lt;field&gt; /
&lt;grammar&gt; structure, VoiceXML 2 defines several simplified
dialog specification mechanisms. These "syntactic shorthand"
representations make it easier to build some types of dialogs.</p>

<p>For example, &lt;menu&gt; provides a means of allowing a user to
select from a short list of items. The syntactic notation provides
several shortcuts:</p>

<ul>
<li>a &lt;choice&gt; element that combines input definition (ASR
and/or DTMF) with route selection (where to go next)</li>

<li>automatic speech grammar generation from an individual word or
phrase per individual choice</li>

<li>DTMF specification per individual choice</li>

<li>automated prompt generation (via &lt;enumerate&gt;)</li>
</ul>

<p>Another shorthand notation uses the standard &lt;form&gt; and
&lt;field&gt; but simplifies the specification of a speech grammar
through the &lt;option&gt; element. It isn’t necessary for a
developer to understand SRGS in order to specify a phrase and
associated semantic return value.</p>
</div>

<div class="div2">
<h3><a name="V2Convenience:Examples"
id="V2Convenience:Examples" />E.2 Examples</h3>

<p>The following examples demonstrate the different V2 syntactic
mechanisms that provide identical functionality.</p>

<div class="div3">
<h4><a name="V2Convenience:MenuWithChoice"
id="V2Convenience:MenuWithChoice" />E.2.1 &lt;menu&gt; with
&lt;choice&gt;</h4>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;vxml version="2.0" …&gt;

&lt;menu dtmf="true"&gt;

  &lt;prompt&gt;
    Say one of: &lt;enumerate/&gt; 
  &lt;/prompt&gt;

  &lt;!-- DTMF choices are automatically generated since dtmf="true" is --
    -- set,
       except where explicitly specified.
  --&gt;
  &lt;choice dtmf="0" next="#operator"&gt; operator &lt;/choice&gt;
  &lt;choice next="http://sports.example.com/start.vxml"&gt;
    sports &lt;/choice&gt;
  &lt;choice next="http://weather.example.com/intro.vxml"&gt;
    weather &lt;/choice&gt;
  &lt;choice next="http://news.example.com/news.vxml"&gt; news &lt;/choice&gt;

&lt;/menu&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="V2Convenience:EquivFormFieldOption"
id="V2Convenience:EquivFormFieldOption" />E.2.2 Equivalent
&lt;form&gt;, &lt;field&gt;, &lt;option&gt;</h4>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;vxml version="2.0" …&gt;

&lt;form id="get_choice"&gt;

&lt;!-- Link emulates ‘operator’ choice in menu --&gt;
&lt;link next="#operator"/&gt;
  &lt;grammar mode="voice" version="1.0" root="root"&gt;
     &lt;rule id="root" scope="public"&gt; operator &lt;/rule&gt;
  &lt;/grammar&gt;
  &lt;grammar mode="dtmf" version="1.0" root="root2"&gt;
     &lt;rule id="root2" scope="public"&gt; 0 &lt;/rule&gt;
  &lt;/grammar&gt;
&lt;/link&gt;

&lt;field name="choice"&gt;
  &lt;prompt&gt;
      Say one of: &lt;enumerate/&gt;
  &lt;/prompt&gt;

  &lt;option dtmf="1" value="sports"&gt; sports &lt;/option&gt;
  &lt;option dtmf="2" value="weather"&gt; weather &lt;/option&gt;
  &lt;option dtmf="3" value="news"&gt; news &lt;/option&gt;

  &lt;filled&gt;

   &lt;if cond="choice == 'sports'"&gt; 
     &lt;goto next="http://sports.example.com/start.vxml"/&gt;
   &lt;elseif cond="choice == 'weather'"/&gt; 
     &lt;goto next="http://weather.example.com/intro.vxml"/&gt;
   &lt;elseif cond="choice == 'news'"/&gt; 
     &lt;goto next="http://news.example.com/news.vxml"/&gt;
   &lt;else/&gt; 
   &lt;/if&gt;

  &lt;/filled&gt;

&lt;/field&gt;
&lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="V2Convenience:EquivFormFieldGrammar"
id="V2Convenience:EquivFormFieldGrammar" />E.2.3 Equivalent
&lt;form&gt;, &lt;field&gt;, &lt;grammar&gt;</h4>

<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;vxml version="2.0" …&gt;

&lt;form id="get_choice"&gt;

&lt;!-- Link emulates ‘operator’ choice in menu --&gt;
&lt;link next="#operator"/&gt;
  &lt;grammar mode="voice" version="1.0" root="root"&gt;
     &lt;rule id="root" scope="public"&gt; operator &lt;/rule&gt;
  &lt;/grammar&gt;
  &lt;grammar mode="dtmf" version="1.0" root="root2"&gt;
     &lt;rule id="root2" scope="public"&gt; 0 &lt;/rule&gt;
  &lt;/grammar&gt;
&lt;/link&gt;

&lt;field name="choice"&gt;
  &lt;prompt&gt; 
    Say one of sports, weather, news.  
  &lt;/prompt&gt;

  &lt;grammar mode="voice" version="1.0" root="root"&gt;
    &lt;rule id="root" scope="public"&gt;
      &lt;one-of&gt;
        &lt;item&gt; sports &lt;/item&gt;
        &lt;item&gt; weather &lt;/item&gt;
        &lt;item&gt; news &lt;/item&gt;
     &lt;/one-of&gt;
    &lt;/rule&gt;
   &lt;/grammar&gt;

   &lt;grammar mode="dtmf" version="1.0" root="root2"&gt;
     &lt;rule id="root2" scope="public"&gt;
       &lt;one-of&gt;
         &lt;item&gt; 1 &lt;/item&gt;
         &lt;item&gt; 2 &lt;/item&gt;
         &lt;item&gt; 3 &lt;/item&gt;
       &lt;/one-of&gt;
     &lt;/rule&gt;
   &lt;/grammar&gt;


  &lt;filled&gt;

   &lt;if cond="choice == '1' || 'sports'"&gt; 
     &lt;goto next="http://sports.example.com/start.vxml"/&gt;
   &lt;elseif cond="choice == '2' || 'weather'"/&gt; 
     &lt;goto next="http://weather.example.com/intro.vxml"/&gt;
   &lt;elseif cond="choice == '3' || 'news'"/&gt; 
     &lt;goto next="http://news.example.com/news.vxml"/&gt;
   &lt;else/&gt; 
   &lt;/if&gt;

  &lt;/filled&gt;

&lt;/field&gt;
&lt;/form&gt;
&lt;/vxml&gt;
</pre>
</div>
</div>
</div>
</div>

<div class="div1">
<h2><a name="Changes" id="Changes" />F Major changes since the last
Working Draft</h2>

<ul>
<li>In Section 8.2.5 replaced fetchtimeout with {audio, document,
grammar, object, script}fetchtimeout.</li>

<li>Many, many editorial changes, including the removal of many
out-of-date editorial notes</li>

<li>In section 6.5.2 adjusted text to allow for SSML documents
containing extensions.</li>

<li>In section 6.6.1.1 added fetching attributes by reference to
section 8.1. Also updated all other uses of these attributes to
point to section 8.1.</li>

<li>Added media fetch properties into section 8.2.5.</li>

<li>Removed &lt;media&gt; as a child of &lt;property&gt; in section
6.6.1.</li>
</ul>
</div>
</div>
</body>
</html>

