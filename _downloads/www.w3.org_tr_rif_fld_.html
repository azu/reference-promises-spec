<!-- http://www.w3.org/TR/rif-fld/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF Framework for Logic Dialects (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF Framework for Logic Dialects (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/" id="this-version-url">http://www.w3.org/TR/2013/REC-rif-fld-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-fld/">http://www.w3.org/TR/rif-fld/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-rif-fld-20121211/">http://www.w3.org/TR/2012/PER-rif-fld-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Harold Boley, National Research Council Canada</dd>
<dd>Michael Kifer, State University of New York at Stony Brook, USA</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2010/rif/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/REC-rif-fld-20130205.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2010/rif/translation/rif-fld">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p></p> <p></p> <p></p> <p>This document, developed by the <a href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group" title="RIF Working Group">Rule Interchange Format (RIF) Working Group</a>, defines a general RIF Framework for Logic Dialects (RIF-FLD). The framework describes mechanisms for specifying the syntax and semantics of logic RIF dialects through a number of generic concepts such as signatures, symbol spaces, semantic structures, and so on. The actual dialects should specialize this framework to produce their syntaxes and semantics. </p> <p></p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a>  (this document)</li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a></li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/PER-rif-fld-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<p><span class="anchor" id="sec-overview"></span>
</p>
<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Overview_of_RIF-FLD"><span class="tocnumber">1</span> <span class="toctext">Overview of RIF-FLD</span></a></li>
<li class="toclevel-1"><a href="#Syntactic_Framework"><span class="tocnumber">2</span> <span class="toctext">Syntactic Framework</span></a>
<ul>
<li class="toclevel-2"><a href="#Syntax_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">2.1</span> <span class="toctext">Syntax of a RIF Dialect as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#Alphabet"><span class="tocnumber">2.2</span> <span class="toctext">Alphabet</span></a></li>
<li class="toclevel-2"><a href="#Symbol_Spaces"><span class="tocnumber">2.3</span> <span class="toctext">Symbol Spaces</span></a></li>
<li class="toclevel-2"><a href="#Terms"><span class="tocnumber">2.4</span> <span class="toctext">Terms</span></a></li>
<li class="toclevel-2"><a href="#Schemas_for_Externally_Defined_Terms"><span class="tocnumber">2.5</span> <span class="toctext">Schemas for Externally Defined Terms</span></a></li>
<li class="toclevel-2"><a href="#Signatures"><span class="tocnumber">2.6</span> <span class="toctext">Signatures</span></a></li>
<li class="toclevel-2"><a href="#Presentation_Syntax_of_a_RIF_Dialect"><span class="tocnumber">2.7</span> <span class="toctext">Presentation Syntax of a RIF Dialect</span></a></li>
<li class="toclevel-2"><a href="#Well-formed_Terms_and_Formulas"><span class="tocnumber">2.8</span> <span class="toctext">Well-formed Terms and Formulas</span></a></li>
<li class="toclevel-2"><a href="#Annotations_in_the_Presentation_Syntax"><span class="tocnumber">2.9</span> <span class="toctext">Annotations in the Presentation Syntax</span></a></li>
<li class="toclevel-2"><a href="#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-FLD"><span class="tocnumber">2.10</span> <span class="toctext">EBNF Grammar for the Presentation Syntax of RIF-FLD</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Semantic_Framework"><span class="tocnumber">3</span> <span class="toctext">Semantic Framework</span></a>
<ul>
<li class="toclevel-2"><a href="#Semantics_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">3.1</span> <span class="toctext">Semantics of a RIF Dialect as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#Truth_Values"><span class="tocnumber">3.2</span> <span class="toctext">Truth Values</span></a></li>
<li class="toclevel-2"><a href="#Datatypes"><span class="tocnumber">3.3</span> <span class="toctext">Datatypes</span></a></li>
<li class="toclevel-2"><a href="#Semantic_Structures"><span class="tocnumber">3.4</span> <span class="toctext">Semantic Structures</span></a></li>
<li class="toclevel-2"><a href="#Annotations_and_the_Formal_Semantics"><span class="tocnumber">3.5</span> <span class="toctext">Annotations and the Formal Semantics</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Non-document_Formulas"><span class="tocnumber">3.6</span> <span class="toctext">Interpretation of Non-document Formulas</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Documents"><span class="tocnumber">3.7</span> <span class="toctext">Interpretation of Documents</span></a></li>
<li class="toclevel-2"><a href="#Intended_Semantic_Structures"><span class="tocnumber">3.8</span> <span class="toctext">Intended Semantic Structures</span></a></li>
<li class="toclevel-2"><a href="#Logical_Entailment"><span class="tocnumber">3.9</span> <span class="toctext">Logical Entailment</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#XML_Serialization_Framework"><span class="tocnumber">4</span> <span class="toctext">XML Serialization Framework</span></a>
<ul>
<li class="toclevel-2"><a href="#XML_for_the_RIF-FLD_Language"><span class="tocnumber">4.1</span> <span class="toctext">XML for the RIF-FLD Language</span></a></li>
<li class="toclevel-2"><a href="#Mapping_from_the_RIF-FLD_Presentation_Syntax_to_the_XML_Syntax"><span class="tocnumber">4.2</span> <span class="toctext">Mapping from the RIF-FLD Presentation Syntax to the XML Syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Mapping_of_the_Non-annotated_RIF-FLD_Language"><span class="tocnumber">4.2.1</span> <span class="toctext">Mapping of the Non-annotated RIF-FLD Language</span></a></li>
<li class="toclevel-3"><a href="#Mapping_of_RIF-FLD_Annotations"><span class="tocnumber">4.2.2</span> <span class="toctext">Mapping of RIF-FLD Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_of_RIF_Processors_with_RIF_Dialects"><span class="tocnumber">5</span> <span class="toctext">Conformance of RIF Processors with RIF Dialects</span></a></li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">6</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">7.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Informational_References"><span class="tocnumber">7.2</span> <span class="toctext">Informational References</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_XML_Schema_for_RIF-FLD"><span class="tocnumber">8</span> <span class="toctext">Appendix: XML Schema for RIF-FLD</span></a>
<ul>
<li class="toclevel-2"><a href="#Baseline_Schema_Module"><span class="tocnumber">8.1</span> <span class="toctext">Baseline Schema Module</span></a></li>
<li class="toclevel-2"><a href="#Skyline_Schema_Module"><span class="tocnumber">8.2</span> <span class="toctext">Skyline Schema Module</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_A_Subframework_for_Herbrand_Semantic_Structures"><span class="tocnumber">9</span> <span class="toctext">Appendix: A Subframework for Herbrand Semantic Structures</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">10</span> <span class="toctext">Appendix: Change Log (Informative)</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Overview_of_RIF-FLD" name="Overview_of_RIF-FLD"></a><h2> <span class="mw-headline">1  Overview of RIF-FLD </span></h2>
<p>The RIF Framework for Logic Dialects (RIF-FLD) is a formalism for specifying all logic dialects of RIF, including the RIF Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>] and [<a href="#ref-rif-core" title="">RIF-Core</a>] (albeit not [<a href="#ref-rif-prd" title="">RIF-PRD</a>], as the latter is not a logic-based RIF dialect). RIF-FLD is a formalism in which both syntax and semantics are described through a number of mechanisms that are commonly used for various logic languages, but are rarely brought all together. Amalgamation of several different mechanisms is required because the framework must be broad enough to accommodate several different types of logic languages and because various advanced mechanisms are needed to facilitate translation into a common framework. RIF-FLD gives precise definitions to these mechanisms, but allows well-defined aspects to vary. The design of RIF envisions that future standard logic dialects will be based on RIF-FLD. Therefore, for any RIF dialect to become a standard, its development should start as a specialization of FLD and extensions to (or, deviations from) FLD should be justified.
</p><p>The framework described in this document is very general and captures most of the popular logic rule languages found in Databases, Logic Programming, and on the Semantic Web. However, it is anticipated that the needs of future dialects might stimulate further evolution of RIF-FLD. In particular, future extensions might include a logic rendering of actions as found in production and reactive rule languages.
This would support Semantic Web services languages such as [<a href="#ref-swsl-rules" title="">SWSL-Rules</a>] and [<a href="#ref-wsml-rules" title="">WSML-Rules</a>].
</p><p>This document is mostly intended for the <i>designers</i> of future RIF dialects. All logic RIF dialects should be <i>derived</i> from RIF-FLD <i>by specialization</i>, as explained in Sections <a href="#sec-dialect-syntax" title="">Syntax of a RIF Dialect as a Specialization of RIF-FLD</a> and <a href="#sec-rif-dialect-semantics" title="">Semantics of a RIF Dialect as a Specialization of RIF-FLD</a>. In addition to specialization, to lower the barrier of entry for their intended audiences, a dialect designer may choose to also specify the syntax and semantics in a direct, but equivalent, way, which does not require familiarity with RIF-FLD. For instance, the RIF Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>] is specified by specialization from RIF-FLD and also directly, without relying on the framework. Thus, the reader who is only interested in RIF-BLD can proceed directly to that document.
</p><p>RIF-FLD has the following main components: 
</p>
<ul><li> <i>Syntactic framework.</i> This framework defines the mechanisms for specifying the formal <b>presentation syntax</b> of RIF logic dialects by specializing the presentation syntax of the framework. The presentation syntax is used in RIF to define the semantics of the dialects and to illustrate the main ideas with examples. This syntax is not intended to be a concrete syntax for the dialects; it leaves out details such as the delimiters of the various syntactic components, parenthesizing, precedence of operators, and the like. Since RIF is an interchange format, it uses <b>XML as its only concrete syntax</b>. 
</li><li> <i>Semantic framework.</i> The semantic framework describes the mechanisms that are used for specifying the models of RIF logic dialects. 
</li><li> <i>XML serialization framework.</i> This framework defines the general principles that logic dialects are to use in specifying their concrete XML-based syntaxes. For each dialect, its concrete XML syntax is a derivative of the dialect's presentation syntax. It can be seen as a serialization of that syntax. 
</li></ul>
<p><b>Syntactic framework.</b> The syntactic framework defines eleven types of RIF terms: 
</p>
<ul>
  <li> <i>Constants and variables</i>. These terms are common to most logic languages.
  </li>
  <li> <i>Positional terms.</i> These terms are commonly used in first-order logic. RIF-FLD defines positional terms in a slightly more general way in order to enable dialects with higher-order syntax, such as HiLog [<a href="#ref-hilog-93" title="">CKW93</a>] and Relfun [<a href="#ref-relfun-99" title="">RF99</a>]. 
  </li>
  <li> <i>Terms with named arguments</i>. These are like positional terms except that each argument of a term is named and the order of the arguments is immaterial. Terms with named arguments generalize the notion of rows in relational tables, where column headings correspond to argument names. 
  </li>
  <li>  
     <i>Lists</i>. These terms correspond to lists in logic programming, and are used in the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/" title="BLD">Basic Logic Dialect</a>. Restricted versions of these terms are used in the <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/" title="Core">Core Dialect</a> and the <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/" title="PRD">Production Rules Dialect</a>.
  </li>
  <li> <i>Frames</i>. A frame term represents an assertion about an object and its properties. These terms correspond to molecules of F-logic [<a href="#ref-flogic-95" title="">KLW95</a>]. There is syntactic similarity between terms with named arguments and frames, since properties (or attributes) of an object resemble named arguments. However, the semantics of these terms are different (see Section <a href="#sec-model-theory" title="">Semantic Structures</a>).
  </li>
  <li> <i>Classification</i>. These terms are used to define the subclass and class membership relationships. There are two kinds of classification terms: <em>membership terms</em> and <em>subclass terms</em>.  Like frames, these terms were borrowed from F-logic [<a href="#ref-flogic-95" title="">KLW95</a>].
  </li>
  <li> <i>Equality</i>. These terms are used to equate other terms.
  <p>
  It should be noted that [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] introduces a number of built-in equality predicates for the various data types (for instance, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#pred-numeric-equal" title="DTB"><tt>pred:numeric-equal</tt></a> or <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#pred-boolean-equal" title="DTB"><tt>pred:boolean-equal</tt></a>). Those predicates have fixed interpretations, which coincide with the interpretation of the equality terms defined in this document when the latter are evaluated over data types. However, outside of the data types, the interpretation of the equality terms may vary and is determined by the contents of RIF documents.
  General use of equality terms is supported in systems such as FLORA-2 [<a href="#ref-flora2" title="">FL2</a>], and special cases are also allowed in Relfun [<a href="#ref-relfun-99" title="">RF99</a>].
  </p>
  </li>
  <li>  
     <i>Formula terms</i>. These terms are the ones for which truth values are defined by the RIF semantic framework. Most dialects would treat such terms in a special way and will impose various restrictions on the contexts in which such terms will be allowed to occur. Some advanced dialects, however, will have fewer such restrictions, which will make it possible to <i>reify</i> formulas and manipulate them as objects.
</li>
  <li>  
     <i>External</i>. These terms are used to represent built-ins and external data sources that are treated as "black boxes."
  </li>
  <li>
     <i>Aggregation</i>. These are the terms that are used to represent aggregation functions over sets.
  </li>
  <li>
     <i>Remote</i>. These terms are used to represent queries to RIF documents that are not part of the RIF document that contains these terms.
  </li>
</ul>
<p>
  Terms are then used to define several types of RIF-FLD <i>formulas</i>. RIF dialects can choose to permit all or some of the aforesaid categories of terms.
  In addition, RIF-FLD introduces <i>extension points</i>, one of which allows the introduction of new kinds of terms. An
  <span class="anchor" id="ref-extension-point">
    <i><b>extension point</b></i>
  </span>
  is a keyword that is not a syntactic construct per se, but a placeholder that is supposed to be replaced by specific syntactic constructs of an appropriate kind. RIF-FLD defines several types of extension points: symbols (<a href="#ref-newsymbol" title=""><tt>NEWSYMBOL</tt></a>), connectives (<a href="#ref-newconective" title=""><tt>NEWCONNECTIVE</tt></a>), quantifiers (<a href="#ref-newquantifier" title=""><tt>NEWQUANTIFIER</tt></a>), aggregate functions (<a href="#ref-newaggrfunc" title=""><tt>NEWAGGRFUNC</tt></a>), and terms (<a href="#ref-newterm" title=""><tt>NEWTERM</tt></a>).
</p>
<p>
  The syntactic framework also defines the following specialization mechanisms: 
</p>
<ul>
  <li> <i>Symbol spaces.</i> 
    <p>
      Symbol spaces partition the set of non-logical symbols that correspond to individual constants, predicates, and functions, and each partition is then given its own semantics. A symbol space has an identifier and a <i>lexical space</i>, which defines the "shape" of the symbols in that symbol space. Some symbol spaces in RIF are used to identify Web entities and their lexical space consists of strings that syntactically look like <i>internationalized resource identifiers</i> [<a href="#ref-rfc-3987" title="">RFC-3987</a>], or IRIs (e.g., <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-iri-space" title="DTB">http://www.w3.org/2007/rif#iri</a>). Other symbol spaces are used to represent the datatypes required by RIF (for example, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#xs-integer-space" title="DTB">http://www.w3.org/2001/XMLSchema#integer</a>). 
    </p>
  </li>
  <li> <i>Signatures.</i> 
    <p>
      Signatures determine which terms and formulas are <i>well-formed</i>. They constitute a generalization of the notion of <i>sorts</i> in classical first-order logic [<a href="#ref-enderton01" title="">Enderton01</a>]. Each nonlogical symbol (and some logical symbols, like <tt>=</tt>) has an associated signature. A signature defines, in a precise way, the syntactic contexts in which the symbol is allowed to occur. 
    </p>
    <p>
      For instance, the signature associated with a symbol <tt>p</tt> might allow <tt>p</tt> to appear in a term of the form <tt>f(p)</tt>, but disallow it to occur in a term like <tt>p(a,b)</tt>. The signature for <tt>f</tt>, on the other hand, might allow that symbol to appear in <tt>f(p)</tt> and <tt>f(p,q)</tt>, but disallow <tt>f(p,q,r)</tt> and <tt>f(f)</tt>. In this way, it is possible to control which symbols are used for predicates and which for functions, where variables can occur, and so on. 
    </p>
    <p>
       Depending on their needs, dialects can decide which symbols have which signatures.
    </p>
  </li>
  <li> <i>Restriction.</i>
     <p>
       A dialect might impose further restrictions on the form of a particular kind of term or formula. For example, variables or aggregate terms might not be allowed in certain places.
     </p>
  </li>
  <li>  
     <i>Extension points.</i>
     RIF dialects are required to replace <a href="#ref-extension-point" title="">extension points</a> with zero or more specific syntactic constructs of an appropriate kind. Note that in this way extension becomes part of specialization.
  </li>
</ul>
<p><b>Semantic framework.</b> This framework defines the notion of a <i>semantic structure</i> (also known as <i>interpretation</i> in the literature [<a href="#ref-enderton01" title="">Enderton01</a>, <a href="#ref-mendelson97" title="">Mendelson97</a>]). Semantic structures are used to interpret formulas and to define <i>logical entailment</i>. As with the syntax, this framework includes a number of mechanisms that RIF logic dialects can specialize to suit their needs. These mechanisms include: 
</p>
<ul>
  <li> <i>Set of truth values.</i> RIF-FLD is designed to accommodate dialects that support reasoning with inconsistent and uncertain information. Most of the logics that are designed to deal with these situations are multi-valued. Consequently, RIF-FLD postulates that there is a set of truth values, <i><b>TV</b></i>, which includes the values <i><b>t</b></i> (true) and <i><b>f</b></i> (false) and possibly others. For example, the RIF Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>] is two-valued, but other dialects can have additional truth values.
  </li>
  <li>  
     <i>Semantic structures</i>. Semantic structures determine how the different symbols in the alphabet of a dialect are interpreted and how truth values are assigned to formulas.
  </li>
  <li> <i>Datatypes.</i> Some symbol spaces that are part of the RIF syntactic framework have fixed interpretations. For instance, symbols in the symbol space <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#xs-string-space" title="DTB">http://www.w3.org/2001/XMLSchema#string</a> are always interpreted as sequences of Unicode characters, and <tt>a</tt> &ne; <tt>b</tt> for any pair of distinct symbols. A symbol space whose symbols have a fixed interpretation in any semantic structure is called a <a href="#def-fld-datatype" title="">datatype</a>. 
  </li>
  <li> <i>Entailment.</i> This notion is fundamental to logic-based dialects. Given a set of formulas (e.g., facts and rules) <tt>G</tt>, entailment determines which other formulas necessarily follow from <tt>G</tt>. Entailment is the main mechanism underlying query answering in Databases, Logic Programming, and the various reasoning tasks in Description Logics. 
    <p>
      A set of formulas <tt>G</tt> logically entails another formula <tt>g</tt> if for every semantic structure <i><b>I</b></i> in some set <b>S</b>, if <tt>G</tt> is true in <i><b>I</b></i> then <tt>g</tt> is also true in <i><b>I</b></i>. Almost all logics define entailment this way. The difference lies in which set <b>S</b> they use. For instance, logics that are based on the classical first-order predicate calculus, such as most Description Logics, assume that <b>S</b> is the set of <i>all</i> semantic structures. In contrast, most Logic Programming languages use <i>default negation</i>. Accordingly, the set <b>S</b> contains only the so-called minimal Herbrand models [<a href="#ref-lloyd-87" title="">Lloyd87</a>] of <tt>G</tt> and, furthermore, only the minimal models of a special kind. See [<a href="#ref-shoham-87" title="">Shoham87</a>] for a more detailed exposition of this subject. 
    </p>
  </li>
</ul>
<p><b>XML serialization framework.</b> This framework defines the general principles for mapping the presentation syntax of RIF-FLD to the concrete XML interchange format.  This includes:
</p>
<ul><li> A specification of the XML syntax for RIF-FLD, including the associated XML Schema document.
</li><li> A specification of a one-to-one mapping from the presentation syntax of RIF-FLD to its XML syntax. This mapping must map any well-formed formula of RIF-FLD to an XML instance document that is valid with respect to the aforesaid XML Schema document.
</li></ul>
<p>This specification is the latest draft of the RIF-FLD definition. Each RIF
dialect that is derived from RIF-FLD will be described in its own document.
The first such dialect, the RIF Basic Logic Dialect, is described in
[<a href="#ref-rif-bld" title="">RIF-BLD</a>]. A core dialect, which is defined by further specializing RIF-BLD, is specified in [<a href="#ref-rif-core" title="">RIF-Core</a>].
</p><p><span id="sec-syntactic-framework"></span>
</p>
<a id="Syntactic_Framework" name="Syntactic_Framework"></a><h2> <span class="mw-headline">2  Syntactic Framework </span></h2>
<p>The next subsection explains how to derive the presentation syntax of a RIF dialect from the presentation syntax of the RIF framework. The actual syntax of the RIF framework is given in subsequent subsections.
</p><p>In the (normative) subsections 2 to 9, the presentation syntax is
defined using "mathematical English," a special form of English for communicating mathematical definitions, examples, etc.
In the non-normative final subsection <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-FLD</a>, a grammar for a superset of the presentation syntax is given using Extended Backus&ndash;Naur Form (EBNF).
</p><p><br />
<span class="anchor" id="sec-dialect-syntax"></span>
</p>
<a id="Syntax_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD" name="Syntax_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">2.1  Syntax of a RIF Dialect as a Specialization of RIF-FLD </span></h4>
<p>The <i><b>presentation syntax for a RIF dialect</b></i> can be obtained from the general syntactic framework of RIF by specializing the following parameters, which are defined later in this document: 
</p>
<ol>
    <li>The alphabet of RIF-FLD can be restricted by omitting symbols; it can also be expanded by <i>actualizing</i> the extension points <tt>NEWSYMBOL</tt>, <tt>NEWCONNECTIVE</tt>, <tt>NEWQUANTIFIER</tt>, and <tt>NEWAGGRFUNC</tt>, i.e., by replacing them with zero or more actual symbols of the appropriate kind.</li>
    <li>An <i>assignment of signatures</i> to each constant and variable
    symbol.
      <p>
	Signatures determine which terms in the dialect are well-formed and which are not.
      </p>
      <p>
	The exact way signatures are assigned depends on the dialect. An assignment can be explicit or implicit (for instance, derived from the context in which each symbol is used). 
      </p>
    </li>
    <li>The <i>choice of the types of terms</i> supported by the dialect.
      <p>
	The RIF logic framework introduces the following types of terms: 
      </p>
      <ul>
	<li>constant </li>
	<li>variable </li>
	<li>positional </li>
	<li>with named arguments </li>
	<li>lists </li>
	<li>equality </li>
	<li>frame </li>
	<li>class membership </li>
	<li>subclass</li>
	<li>aggregates</li>
        <li>remote term reference</li>
	<li>external</li>
	<li>formulas</li>
      </ul>
      <p>
	A dialect might support all of these terms or just a subset. For instance, some dialects might not support terms with named arguments or frame terms or certain forms of external terms (e.g., external frames).
	A dialect might even support <em>additional</em> kinds of terms that are not listed above (for instance, typing terms of F-logic [<a href="#ref-flogic-95" title="">KLW95</a>]). This is done by actualizing the extension point <a href="#ref-newterm" title=""><tt>NEWTERM</tt></a>, i.e., by replacing it with zero or more new kinds of terms.
      </p>
    </li>
    <li>The <i>choice of symbol spaces</i> supported by the dialect.
      <p>
	Symbol spaces determine the syntax of the constant symbols that are allowed in the dialect. All RIF dialects are expected to support certain symbols spaces (see the section <a href="#sec-symbol-spaces" title="">Symbol Spaces</a>). Dialects can also introduce additional symbol spaces, such as a symbol space to represent Skolem constants and functions.
      </p>
    </li>
    <li>The <i>choice of the formulas</i> supported by the dialect.
      <p>RIF-FLD offers the following kinds of formula terms "out of the box": </p>
      <ul>
	<li>Atomic </li>
	<li>Conjunction </li>
	<li>Disjunction </li>
	<li>Symmetric negation (classical, explicit, or strong)</li>
	<li>Default negation (as in logic programming)</li>
	<li>Rule (as in logic programming as opposed to the classical material implication)
	</li>
	<li>Quantification (universal and existential)
	</li>
	<li>	
	   Remote (for querying remote RIF documents)
	</li>
	<li>	
	   External (built-in predicates and external black-box sources of information)
	</li>
      </ul>
      <p>
	A dialect might support all of these formulas or it might impose various restrictions. For instance, the formulas allowed in the conclusion and/or premises of implications might be restricted (e.g., [<a href="#ref-rif-bld" title="">RIF-BLD</a>] essentially allows Horn rules only), certain types of quantification might be prohibited (e.g., [<a href="#ref-rif-bld" title="">RIF-BLD</a>] disallows existential quantification in the rule head), symmetric or default negation (or both) might not be allowed (as in RIF-BLD), etc. The Core subdialect of RIF-BLD disallows equality formulas in the conclusions of rules.
      </p>
      <p>
	 More interestingly, dialects can introduce <i>additional</i> types of formulas by adding new connectives (e.g., classical implication or bi-implication) and quantifiers through actualizing the extension points <a href="#ref-newconective" title=""><tt>NEWCONNECTIVE</tt></a> and <a href="#ref-newquantifier" title=""><tt>NEWQUANTIFIER</tt></a>. 
      </p>
    </li>
</ol>
<p>Note that although the presentation syntax of a RIF logic dialect is normative, since semantics is defined in terms of that syntax, the presentation syntax is not intended as a concrete syntax, and <a href="#sec-conformance" title="">conformant systems</a> are not required to implement it.
</p><p><br />
<span class="anchor" id="sec-alphabet"></span>
</p>
<a id="Alphabet" name="Alphabet"></a><h4> <span class="mw-headline">2.2  Alphabet </span></h4>
<p><span class="anchor" id="def-fld-alphabet"></span> 
<b>Definition (Alphabet).</b>
The <i><b>alphabet</b></i> of the presentation syntax of RIF-FLD consists of 
the following <i>disjoint</i> subsets of symbols:
</p>
<ul>
  <li>
    A countably infinite set of <i><b>constant symbols</b></i> <tt>Const</tt>.
    <p>
      Constants are written as <tt>"literal"^^symspace</tt>,  where <tt>literal</tt>  is a sequence of Unicode characters and <tt>symspace</tt>  is an identifier for a symbol space.
      This syntax is explained in Section <a href="#sec-symbol-spaces" title="">Symbol Spaces</a>.
    </p>
  </li>
  <li>  
    A countably infinite set of <i><b>variable symbols</b></i> <tt>Var</tt>.
    <p>
       Variables are written as Unicode strings preceded by the symbol <tt>?</tt> (e.g., <tt>?x</tt>, <tt>?ABC</tt>).
       This makes the sets <tt>Var</tt> and <tt>Const</tt> disjoint.  
    </p>
  </li>
  <li>  
    A countably infinite set of <i><b>argument names</b></i> <tt>ArgNames</tt>.
    The set <tt>ArgNames</tt> is disjoint from both <tt>Const</tt> and <tt>Var</tt>.  
    <p>
       Argument names in <tt>ArgNames</tt> are written as Unicode strings that do not start with a <tt>?</tt> (e.g., <tt>Name</tt>, <tt>age</tt>). They are used in predicates and functions that have named arguments.
    </p>
  </li>
  <li>  
    A finite set of <i><b>connective symbols</b></i>, which includes <tt>And</tt>, <tt>Or</tt>, <tt>Naf</tt>, <tt>Neg</tt>, <tt>:-</tt>, and <tt>NEWCONNECTIVE</tt>.
    <p>
      <span class="anchor" id="ref-newconective">
      <tt>NEWCONNECTIVE</tt>
      </span>
      is not an actual symbol in the alphabet, but rather a RIF-FLD <a href="#ref-extension-point" title="">extension point</a>, which must be actualized. Dialects are expected to specialize the set of connectives by
    </p>
    <ul>    
      <li>
	Replacing <tt>NEWCONNECTIVE</tt> with zero or more new connective symbols. Dialects cannot keep the extension point.
      </li>
      <li>      
	 Dropping zero or more of the predefined connective symbols listed above. Dialects cannot redefine the semantics of the predefined connectives, however.
      </li>
    </ul>
  </li>
  <li>  
    A countably infinite set of <i><b>quantifiers</b></i>, which consists of the symbols <tt>Exists<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> and <tt>Forall<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt>, where <tt>?X<sub>1</sub>, ...,&nbsp;?X<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are distinct variable symbols; plus the <a href="#ref-extension-point" title="">extension point</a>,
    <span class="anchor" id="ref-newquantifier">
      <tt>NEWQUANTIFIER</tt>, which must be actualized.
    </span>
    Dialects are supposed to specialize this repertoire of quantifier symbols by
     <ul>    
      <li>
	 Replacing <tt>NEWQUANTIFIER</tt> with zero or more new quantifier symbols. Dialects cannot keep the extension point.
      </li>
      <li>      
	 Dropping zero or more of the predefined quantifier symbols listed above. However, dialects cannot redefine the semantics of the predefined quantifiers.
      </li>
    </ul>
    <p>
       In the actual presentation syntax, we will be linearizing the predefined quantifier symbols and write them as
       <tt>Exists&nbsp;?X<sub>1</sub>,...,?X<sub>n</sub></tt> and <tt>Forall&nbsp;?X<sub>1</sub>,...,?X<sub>n</sub></tt> instead of <tt>Exists<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> and <tt>Forall<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt>.
    </p>
    <p>
       Every quantifier symbol has an
       <span class="anchor" id="ref-quantified-variables">
        <i><b>associated list of variables</b></i>
       </span>
       that are <i><b>bound</b></i> by that quantifier.
       For the standard quantifiers <tt>Exists<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> and <tt>Forall<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt>, the associated list of variables is <tt>?X<sub>1</sub>,...,?X<sub>n</sub></tt>.
    </p>
  </li>
  <li>  
    The symbols <tt>=</tt>, <tt>#</tt>, <tt>##</tt>, <tt>-&gt;</tt>, <tt>External</tt>, <tt>Dialect</tt>, <tt>Base</tt>, <tt>Prefix</tt>, <tt>Import</tt>, and <tt>Module</tt>.
  </li>
  <li>  
     The symbols for representing lists: <tt>List</tt> and <tt>OpenList</tt>.
  </li>
  <li>  
    The symbols <tt>Group</tt> and <tt>Document</tt>.
  </li>
  <li>  
    A countable set of <i><b>aggregate symbols</b></i> of the form <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub></tt>, where <tt>n &ge; 0</tt>, <tt><em>sym</em></tt> is a symbol that denotes an aggregate function, and <tt>?V</tt>, <tt>?X<sub>1</sub>, ...,&nbsp;?X<sub>n</sub></tt> are variable symbols. The symbol <tt>?V</tt> is called the <i><b>comprehension variable</b></i> of the aggregate symbol and  <tt>?X<sub>1</sub>, ...,&nbsp;?X<sub>n</sub></tt> are <i><b>grouping variables</b></i>.
    <p>
      RIF-FLD reserves the following symbols for standard aggregate functions: <tt>Min</tt>, <tt>Max</tt>, <tt>Count</tt>,  <tt>Avg</tt>, <tt>Sum</tt>, <tt>Prod</tt>, <tt>Set</tt>, and <tt>Bag</tt>. Aggregate functions also have an <a href="#ref-extension-point" title="">extension point</a>,
      <span class="anchor" id="ref-newaggrfunc">
      <tt>NEWAGGRFUNC</tt>, which must be actualized.
      </span>
      Dialects can specialize the aforesaid set of aggregate functions by
      </p>
       <ul>    
      <li>
	 Replacing <tt>NEWAGGRFUNC</tt> with zero or more new symbols for aggregate functions. Dialects cannot keep the extension point.
      </li>
      <li>      
	 Dropping zero or more of the predefined aggregate functions listed above. However, dialects cannot redefine the semantics of the predefined aggregate functions.
      </li>
    </ul>
  </li>
  <li>  
    Auxiliary symbols <tt>(</tt>, <tt>)</tt>, <tt>[</tt>, <tt>]</tt>, <tt>{</tt>, <tt>}</tt>,   <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>|</tt>, <tt>?</tt>, <tt>@</tt>,  and <tt>^^</tt>. 
  </li>
  <li>  
     An <a href="#ref-extension-point" title="">extension point</a>
     <span class="anchor" id="ref-newsymbol">
     <tt>NEWSYMBOL</tt>. 
     </span>
     <p>
        As with other extension points, this is not an actual symbol in the alphabet, but a placeholder that dialects are supposed to replace with zero or more actual new alphabet symbols.
     </p>
  </li>
</ul>
<p>The symbol <tt>Naf</tt> represents <i>default negation</i>, which is used in rule languages with logic programming and deductive database semantics.
Examples of default negation include Clark's negation-as-failure [<a href="#ref-negation-as-failure" title="">Clark87</a>], the well-founded negation [<a href="#ref-wf-model" title="">GRS91</a>], and stable-model negation [<a href="#ref-stable-model" title="">GL88</a>].
The name of the symbol <tt>Naf</tt> used here comes from negation-as-failure but in RIF-FLD this can refer to any kind of default negation.
</p><p>The symbol <tt>Neg</tt>  represents <i>symmetric negation</i> (as opposed to default negation, which is asymmetric because completely different inference rules are used to derive <tt>p</tt> and <tt>Naf p</tt>). Examples of symmetric negation include classical first-order negation, <i>explicit negation</i>, and <i>strong negation</i> [<a href="#ref-strong-explicit-negation" title="">APP96</a>].
</p><p>The symbols <tt>=</tt>,  <tt>#</tt>,  and <tt>##</tt>  are used in formulas that define equality, class membership, and subclass relationships, respectively. The symbol <tt>-&gt;</tt>  is used in terms that have named arguments and in frame terms. The symbol <tt>External</tt>  indicates that an atomic formula or a function term is defined externally (e.g., a built-in), <tt>Dialect</tt> is a directive used to indicate the dialect of a RIF document (for those dialects that require this), the symbols <tt>Base</tt> and <tt>Prefix</tt> enable abridged representations of IRIs, and the symbol <tt>Import</tt> is an import directive. The <tt>Module</tt> directive is used to connect remote terms with the actual remote RIF documents.
</p><p>Finally, the symbol <tt>Document</tt> is used for specifying RIF-FLD documents and the symbol <tt>Group</tt> is used to organize RIF-FLD formulas into collections. &nbsp;&nbsp;☐
</p><p><br />
</p><p><br />
<span class="anchor" id="sec-symbol-spaces"></span>
</p>
<a id="Symbol_Spaces" name="Symbol_Spaces"></a><h4> <span class="mw-headline">2.3  Symbol Spaces </span></h4>
<p>Throughout this document, we will be using the following abbreviations:
</p>
<ul><li> <tt>xs:</tt> stands for the XML Schema URI <tt>http://www.w3.org/2001/XMLSchema#</tt>
</li><li> <tt>rdf:</tt> stands for <tt>http://www.w3.org/1999/02/22-rdf-syntax-ns#</tt>
</li><li> <tt>pred:</tt> stands for <tt>http://www.w3.org/2007/rif-builtin-predicates#</tt>
</li><li> <tt>rif:</tt> stands for the URI of RIF, <tt>http://www.w3.org/2007/rif#</tt>
</li></ul>
<p>These and other abbreviations will be used as prefixes in the <i>compact URI</i>-like notation [<a href="#ref-curie" title="">CURIE</a>], a notation for succinct representation of IRIs [<a href="#ref-rfc-3987" title="">RFC-3987</a>]. The precise meaning of this notation in RIF is defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>The set of all constant symbols in a RIF dialect is partitioned into a number of subsets, called <i>symbol spaces</i>, which are used to represent XML Schema datatypes, datatypes defined in other W3C specifications, such as <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-xmlliteral-space" title="DTB">rdf:XMLLiteral</a></tt>, and to distinguish other sets of constants. All constant symbols have a syntax (and sometimes also semantics) imposed by the symbol space to which they belong.
</p><p><span class="anchor" id="def-fld-symspace"></span> 
<b>Definition (Symbol space).</b>
A <i><b>symbol space</b></i> is a named subset of the set of all constants, <tt>Const</tt>. The semantic aspects of symbol spaces will be described in Section <a href="#sec-fld-semantic-framework" title="">Semantic Framework</a>. Each symbol in <tt>Const</tt> belongs to exactly one symbol space. 
</p><p>Each symbol space has an associated lexical space and a unique identifier.
More precisely,
</p>
<ul><li> The <i><b>lexical space</b></i> of a symbol space is a non-empty set of Unicode character strings. 
</li><li> The <i><b>identifier</b></i> of a symbol space is a sequence of Unicode characters that form an absolute IRI [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</li><li> Different symbol spaces cannot share the same identifier.
</li></ul>
<p>The identifiers for symbol spaces are <b>not</b> themselves constant symbols in RIF.  &nbsp;&nbsp;☐
</p><p>To simplify the language, we will often use symbol space identifiers to refer to the actual symbol spaces (for instance, we may use "symbol space <tt>xs:string</tt>" instead of "symbol space <i>identified by</i> <tt>xs:string</tt>"). 
</p><p>To refer to a constant in a particular RIF symbol space, we use the following presentation syntax: 
</p>
<pre>     "literal"^^symspace
</pre>
<p>where <tt>literal</tt> is called the <i><b>lexical part</b></i> of the symbol, and <tt>symspace</tt> is the identifier of the symbol space. Here <tt>literal</tt> is a sequence of Unicode characters that <i>must</i> be an element in the lexical space of the symbol space <tt>symspace</tt>. For instance, <tt>"1.2"^^xs:decimal</tt> and <tt>"1"^^xs:decimal</tt> are syntactically valid constants because 1.2 and 1 are members of the lexical space of the XML Schema datatype <tt>xs:decimal</tt>. On the other hand, <tt>"a+2"^^xs:decimal</tt> is not a syntactically valid symbol, since <tt>a+2</tt> is not part of the lexical space of <tt>xs:decimal</tt>. 
</p><p>The set of all symbol spaces that partition <tt>Const</tt> is considered to
be part of the logic language of RIF-FLD.
</p><p>RIF requires that all dialects include the symbol spaces listed and described in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-symbol-spaces" title="DTB">Constants and Symbol Spaces</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] as part of their language. These symbol spaces include constants that belong to several important XML Schema datatypes, certain RDF datatypes, and constant symbols specific to RIF. The latter include the symbol spaces <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-iri-space" title="DTB">rif:iri</a></tt> and <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt>, which are used to represent internationalized resource identifiers (IRIs [<a href="#ref-rfc-3987" title="">RFC-3987</a>]) and constant symbols that are not visible outside of the RIF document in which they occur, respectively. Documents that are exchanged through RIF can use additional symbol spaces (for instance, a symbol space to represent Skolem constants and functions).
</p><p>We will often refer to constant symbols that come
from a particular symbol space, <tt>X</tt>, as <tt>X</tt> constants. For
instance, the constants in the symbol space <tt>rif:iri</tt> will be referred to
as <i><b>IRI constants</b></i> or <tt>rif:iri</tt> <i><b>constants</b></i> and the constants
found in the symbol space <tt>rif:local</tt> as <i><b>local constants</b></i>
or <tt>rif:local</tt> <i><b>constants</b></i>.  
</p><p><br />
</p><p><span class="anchor" id="sec-terms"></span>
</p>
<a id="Terms" name="Terms"></a><h4> <span class="mw-headline">2.4  Terms </span></h4>
<p>The most basic construct of a logic language is a <i>term</i>. RIF-FLD supports many kinds of terms: constants, variables, the regular <i>positional</i> terms, plus terms with <i>named arguments</i>, equality, <i>classification</i> terms, <i>frames</i>, and more. The word "<i>term</i>" will be used to refer to any kind of term.
</p><p><span class="anchor" id="def-fld-term"></span> 
<b>Definition (Term).</b>
A <i><b>term</b></i> can have one of the following forms:
</p>
<ol>
  <li><i>Constants and variables</i>. If <tt>t</tt> &isin; <tt>Const</tt> or <tt>t</tt> &isin; <tt>Var</tt> then <tt>t</tt> is a <i><b>simple term</b></i>. </li>
  <li><i>Positional terms</i>. If <tt>t</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt> are terms then <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>positional term</b></i>.
    <p>
      Positional terms in RIF-FLD generalize the regular notion of a term used in first-order logic. For instance, the above definition allows variables everywhere, as in <tt>?X(?Y&nbsp;?Z(?V "12"^^xs:integer))</tt>, where <tt>?X</tt>, <tt>?Y</tt>, <tt>?Z</tt>, and <tt>?V</tt> are variables. Even <tt>?X("abc"^^xs:string&nbsp;?W)(?Y&nbsp;?Z(?V "33"^^xs:integer))</tt> is a positional term (as in HiLog [<a href="#ref-hilog-93" title="">CKW93</a>]).
    </p>
  </li>
  <li><i>Terms with named arguments</i>. A <i><b>term with named arguments</b></i> is of the form <tt>t(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>, where <tt>t</tt>, <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> are terms, and <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> are (not necessarily distinct) symbols from the set <tt>ArgNames</tt>.
    <p>
      The term <tt>t</tt> here represents a predicate or a function; <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> represent argument names; and <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> represent argument values. Terms with named arguments are like regular positional terms except that the arguments are named and their order is immaterial. Note that a term with no arguments, like f(), is, trivially, both a positional term and a term with named arguments. 
    </p>
    <p>
      For instance, <tt>"person"^^xs:string("http://example.com/name"^^rif:iri-&gt;?Y "http://example.com/address"^^rif:iri-&gt;?Z)</tt>, <tt>?X("123"^^xs:integer&nbsp;?W)(arg-&gt;?Y arg2-&gt;?Z(?V))</tt>, and <tt>"Closure"^^rif:local("http://example.com/relation"^^rif:iri-&gt;"http://example.com/Flight"^^rif:iri)("from"^^rif:local-&gt;?X "to"^^rif:local-&gt;?Y)</tt> are terms with named arguments. The second of these named-argument terms uses a positional term, <tt>?X("123"^^xs:integer&nbsp;?W)</tt>, in the role of the function, and the third term's function is itself represented by a named-argument term.
    </p>
  </li>
  <li>  
     <span class="anchor" id="def-list-term">
       <i>List terms</i>.
     </span> 
     There are two kinds of list terms: <em>open</em> and <em>closed</em>.  
     <ul>     
       <li>
	 A <i><b>closed list</b></i> has the form <tt>List(t<sub>1</sub> ... t<sub>m</sub>)</tt>, where <tt>m&ge;0</tt> and <tt>t<sub>1</sub>, ..., t<sub>m</sub></tt> are terms.  
       </li>
       <li>       
	  An <i><b>open list</b></i> (or a list with a tail) has the form
	  <tt>OpenList(t<sub>1</sub> ... t<sub>m</sub> t)</tt>, where <tt>m&gt;0</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>m</sub></tt>, <tt>t</tt> are terms. Open lists are written in the presentation syntax as follows: <tt>List(t<sub>1</sub> ... t<sub>m</sub> | t)</tt>.
	  <p>
	     The last argument, <tt>t</tt>, represents the tail of the list and so it is normally a list as well. However, the syntax does not restrict <tt>t</tt> in any way: it could be an integer, a variable, another list, or, in fact, any term. An example is <tt>List(1 2 | 3)</tt>. This is not an ordinary list, where the last argument, <tt>3</tt>, would represent the tail of a list (and thus would also be a list, which <tt>3</tt> is not). Such general open lists correspond to Lisp's dotted lists [<a href="#ref-steele90" title="">Steele90</a>]. Note that they can be the result of instantiating an open list with a variable in the tail, hence are hard to avoid. For instance, <tt>List(1 2 | 3)</tt> is <tt>List(1 2 |&nbsp;?X)</tt>, where the variable <tt>?X</tt> is replaced with <tt>3</tt>. 
	  </p>
       </li>
     </ul>
     <p>
        A closed list of the form <tt>List()</tt> (i.e., a list in which <tt>m=0</tt>) is called the <i><b>empty list</b></i>. 
     </p>
     <p>
     </p>
  </li>
  <li><i>Equality terms</i>. An <i><b>equality term</b></i> has the form <tt>t&nbsp;=&nbsp;s</tt>, where <tt>t</tt> and <tt>s</tt> are terms. </li>
  <li><i>Classification terms</i>. There are two kinds of classification terms: <i>class membership terms</i> (or just <i>membership terms</i>) and <i>subclass terms</i>.
    <ul>
      <li><tt>t#s</tt> is a <i><b>membership term</b></i> if <tt>t</tt> and <tt>s</tt> are terms. </li>
      <li><tt>t##s</tt> is a <i><b>subclass term</b></i> if <tt>t</tt> and <tt>s</tt> are terms. </li>
    </ul>
    <p>
       Classification terms are used to describe class hierarchies.
    </p>
  </li>
  <li><i>Frame terms</i>. <tt>t[p<sub>1</sub>-&gt;v<sub>1</sub> ... p<sub>n</sub>-&gt;v<sub>n</sub>]</tt> is a <i><b>frame term</b></i> (or simply a <i><b>frame</b></i>) if <tt>t</tt>, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are terms.
    <p>
      Frame terms are used to describe properties of objects. As in the case of the terms with named arguments, the order of the properties <tt>p<sub>i</sub>-&gt;v<sub>i</sub></tt> in a frame is immaterial.
    </p>
  </li>
  <li>  
    <i>Externally defined terms.</i> If <tt>t</tt> is a constant, positional term, a term with named arguments, an equality, a classification, or a frame term then <tt>External(t loc)</tt> is an <i><b>externally defined term</b></i>.
    <p>
      Such terms are used for representing built-in functions and predicates as well as "procedurally attached" terms or predicates, which might exist in various rule-based systems, but are not specified by RIF.
      The <tt>loc</tt> part in an external term is intended to play the role of a <span class="anchor" id="ref-ext-locator"><i><b>locator</b></i></span> of the source that defines the external term <tt>t</tt>.  It must uniquely identify the external source. The exact form of the locator <tt>loc</tt>, the protocol that associates locators with external sources, and the type of the imported documents is left to dialects to specify. However, all dialects must support the form <tt>&lt;IRI&gt;</tt>,  where <tt>IRI</tt>  is a sequence of Unicode characters that forms an IRI. 
    </p>
    <p>
      This syntax enables very flexible representations for externally defined information sources: not only predicates and functions, but also frames, classification, and equality terms can be used. In this way, external sources can be modeled in an object-oriented way. For instance, <tt>External("http://example.com/acme"^^rif:iri["http://example.com/mycompany/president"^^rif:iri(?Year) -&gt;&nbsp;?Pres] &nbsp; &lt;http://example.com/acme&gt;)</tt> could be a representation for an external method <tt>"http://example.com/mycompany/president"^^rif:iri</tt> in an external object identified by the IRI <tt>http://example.com/acme</tt>.
    </p>
    <p>
      Since, in most cases, external terms are expected to be based on predicates, RIF-FLD also permits a <span class="anchor" id="ref-external-shorthand"> shorthand notation:</span>   If <tt>t</tt> is a positional or a named-argument term of the form <tt>p(...)</tt>, then <tt>External(t)</tt> is considered to be a shorthand for <tt>External(t &lt;p*&gt;)</tt>, where <tt>p*</tt> is the IRI corresponding to <tt>p</tt> (for instance, if <tt>p</tt> is <tt>"http://example.com/foobar"^^rif:iri</tt> then <tt>p*</tt> is <tt>http://example.com/foobar</tt>).
    </p>
  </li>
  <li>
     <span class="anchor" id="ref-fld-formula-term">
     <i>Formula term.</i></span>
     If <tt>S</tt> is a connective or a quantifier symbol and  <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt> are terms then <tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>formula term</b></i>.
     <p>
        Formula terms correspond to <i>compound formulas</i> in logic, i.e., formulas that are constructed from atomic formulas by combining them with connectives and quantifiers. For better visual appeal, some connectives (e.g., rule implication, <tt>:-</tt>, and default negation, <tt>Naf</tt>) may be written in infix or prefix form (e.g., <tt>a&nbsp;:- b</tt> and <tt>Naf a</tt>), but the above function application form is considered to be <i>canonical</i>.
     </p>
     <p>
        Let <tt>&phi;</tt> be a formula term of the form  <tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt>, where <tt>S</tt> is a quantifier, and let <tt>?X<sub>1</sub>,...,?X<sub>n</sub></tt> be a list of variables bound by <tt>S</tt>. We say that all occurrences of these variables are <i><b>bound</b></i> in the formula term <tt>&phi;</tt>. 
	In general, if <tt>&tau;</tt> is a term and <tt>&psi;</tt> a formula term that occurs in <tt>&tau;</tt> then all occurrences of the variables that are bound in <tt>&phi;</tt> are also said to be bound in <tt>&tau;</tt>. The occurrences of variables in a term that are not bound are said to be <i><b>free</b></i>. A term that has no free occurrences of variables is <i><b>closed</b></i>. 
     </p>
  </li>
  <li>
     <span class="anchor" id="ref-aggregate-term">
     <i>Aggregate term.</i></span>
     An <i><b>aggregate term</b></i> has the form <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub>(&tau;)</tt>, where <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub></tt> is an aggregate symbol, <tt>n&ge;0</tt>, and <tt>&tau;</tt> is a term. For readability, we will usually write aggregate terms as <tt><em>sym</em>{?V [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>. If <tt>n=0</tt>, we will omit the <tt>[...]</tt> part.  
     Note that aggregates can be nested, i.e., <tt>&tau;</tt> can contain aggregate terms.
     <p>
       In addition, it is required that the variables <tt>?V</tt>, <tt>?X<sub>1</sub></tt>, ..., <tt>?X<sub>n</sub></tt>  have free occurrences in <tt>&tau;</tt>, and all occurrences of other variables in <tt>&tau;</tt> are bound.
     </p>
     <p>
       The comprehension variable <tt>?V</tt> and the grouping variables <tt>?X<sub>1</sub></tt>, ..., <tt>?X<sub>n</sub></tt> of the symbol <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub></tt>  are also said to be the comprehension and grouping variables of the above aggregate term.
       The <em>comprehension variable</em> <tt>?V</tt> <em>is considered bound</em> by the aggregation term, but the <em>grouping variables</em> <tt>?X<sub>1</sub></tt>, ..., <tt>?X<sub>n</sub></tt> <em>remain free</em>.
     </p>
     <p>
        As a practical convenience, dialects may allow more general terms in place of the comprehension variable, similarly to Prolog's <tt>findall/3</tt> built-in. In this case, <tt><em>sym</em>{Term [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt> is treated as a shorthand for <tt><em>sym</em>{?V [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | And(&tau;&nbsp;?V=Term)}</tt>.
     </p>
  </li>
  <li>  
     <span class="anchor" id="ref-module-term">
       <i>Remote term reference.</i>
     </span>
     A remote term reference (also called remote term) is a term of the form <tt>&phi;@r</tt> where <tt>&phi;</tt> is a term; <tt>r</tt> can be a constant, variable, a positional, or a named-argument term.
     <p>
        Remote terms are used to query remote RIF documents, called <i>remote modules</i>. Here <tt>&phi;</tt> is the actual query and <tt>r</tt> is a reference used to identify the remote module.  
	Remote terms should be contrasted with external terms, which are used to query external sources that are not RIF documents. Since remote terms refer to remote RIF documents, their semantics is defined by RIF-FLD. In contrast, external terms are used to query external opaque sources, which are not RIF documents. So, their semantics is opaque in RIF.
     </p>
  </li>
  <li>  
     <span class="anchor" id="ref-newterm">
       <i><tt>NEWTERM</tt>.</i>
     </span>
     This is not a specific kind of term, but an <a href="#ref-extension-point" title="">extension point</a>; dialects are supposed to replace it with zero or more new types of terms.
    &nbsp;&nbsp;☐
  </li>
</ol>
<p>The above definitions are very general. They make no distinction between constant symbols that represent individuals, predicates, and function symbols. The same symbol can occur in multiple contexts at the same time. For instance, if <tt>p</tt>, <tt>a</tt>, and <tt>b</tt> are symbols then <tt>p(p(a)&nbsp;p(a&nbsp;p&nbsp;c))</tt> is a term. Even variables and general terms are allowed to occur in the position of predicates and function symbols, so <tt>p(a)(?v(a&nbsp;c)&nbsp;p)</tt> is also a term.
</p><p>Furthermore, the extensible set of quantifiers and connectives allows dialects to introduce additional features, which could include modal operators, bounded quantification, rule labels, and so on. For instance, to add  labels to formulas, as required by some rule languages, a dialect could introduce a new connective, <tt>Label</tt>, and formulas of the form <tt>Label(t &phi;)</tt>, where <tt>t</tt> could be a positional term and <tt>&phi;</tt> a formula term.  (Note that RIF-FLD also supports a very general form of <a href="#sec-formal-syntax-metadata" title="">annotations</a>, which can be used to assign identifiers to rules. However, <a href="#sec-semantics-metadata" title="">annotations do not affect the semantics</a> of RIF dialects, so they cannot be used to label rules in dialects where rule labels do affect the semantics. It is in those cases that RIF dialect designers might choose to introduce a special connective, like <tt>Label</tt> above.) 
</p><p>Frame, classification, and other terms can be freely nested, as exemplified by <tt>p(?X&nbsp;&nbsp;q#r[p(1,2)-&gt;s](d-&gt;e&nbsp;f-&gt;g))</tt>. Some language environments, like FLORA-2 [<a href="#ref-flora2" title="">FL2</a>], OO jDREW [<a href="#ref-oojdrew" title="">OOjD</a>], NxBRE [<a href="#ref-nxbre" title="">NxBRE</a>], and CycL [<a href="#ref-cycl" title="">CycL</a>] support fairly large (partially overlapping) subsets of RIF-FLD terms, but most languages support much smaller subsets. RIF dialects are expected to carve out the appropriate subsets of RIF-FLD terms, and the general form of the RIF logic framework allows a considerable degree of freedom. 
</p><p>Observe that the argument names of frame terms, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, are terms and, as a special case, can be variables. In contrast, terms with named arguments can use only the symbols from <tt>ArgNames</tt> to represent their argument names. They cannot be constants from <tt>Const</tt> or variables from <tt>Var</tt>. The reason for this restriction  has to do with the complexity of unification, which is integral part of many inference rules underlying first-order logic. We are not aware of any rule language where terms with named arguments use anything more general than what is defined here.
</p><p>Dialects can restrict the contexts in which the various terms are allowed by using the mechanism of <a href="#sec-signature" title="">signatures</a>. The RIF-FLD language associates a signature with each symbol (both constant and variable symbols) and uses signatures to define <i>well-formed terms</i>. Each RIF dialect is expected to select appropriate signatures for the symbols in its alphabet, and only the terms that are well-formed according to the selected signatures are allowed in that particular dialect. 
</p><p><br />
<b>Example 1</b> (Terms)
</p>
<ul>
  <li>  
    Positional term:  <tt>"http://example.com/ex1"^^rif:iri(1 "http://example.com/ex2"^^rif:iri(?X 5) "abc")</tt>  
  </li>
  <li>  
    Term with named arguments:  <tt>"http://example.com/Person"^^rif:iri(id-&gt;"http://example.com/John"^^rif:iri "http://example.com/age"^^rif:iri-&gt;?X "http://example.com/spouse"^^rif:iri-&gt;?Y)</tt>
  </li>
  <li>  
    Frame term:  <tt>"http://example.com/John"^^rif:iri[age-&gt;?X spouse-&gt;?Y]</tt>
  </li>
  <li>  
    Lists 
    <ul>    
      <li>
	Empty list:  <tt>List()</tt> 
      </li>
      <li>      
	Closed list with variable inside:  <tt>List("a"^^rif:local&nbsp;?Y "c"^^rif:local)</tt>
      </li>
      <li>      
	Open list with variables:  <tt>List("a"^^rif:local&nbsp;?Y "c"^^xs:string |&nbsp;?Z)</tt>   
      </li>
      <li>      
	Equality term with lists inside:  <tt>List(?Head |&nbsp;?Tail) = List("a"^^rif:local&nbsp;?Y "c"^^xs:string)</tt> 
      </li>
      <li>      
	Nested list:  <tt>List("a"^^rif:local List(?X "b"^^rif:local) "c"^^xs:string)</tt>
      </li>
    </ul>
  </li>
  <li>  
    Classification terms 
    <ul>    
      <li>
	Membership: <tt>?X #&nbsp;?Y</tt>
      </li>
      <li>      
	Subclass:   <tt>?X ## "http://example.com/ex1"^^rif:iri(?Y)</tt>
      </li>
      <li>      
	Membership: <tt>"http://example.com/John"^^rif:iri # "http://example.com/Person"^^rif:iri</tt> 
      </li>
      <li>      
	Subclass:   <tt>"http://example.com/Student"^^rif:iri ## "http://example.com/Person"^^rif:iri</tt> 
      </li>
    </ul>
  </li>
  <li>  
    External term:  <tt>External(pred:numeric-greater-than(?diffdays 10)))</tt> 
  </li>
  <li>  
    Formula terms  
    <ul>    
      <li>
	<tt>:-("p"^^rif:local(?X)&nbsp;?X("q"^^xs:string))</tt>         (usually written as <tt>"p"^^rif:local(?X)&nbsp;:-&nbsp;?X("q"^^xs:string)</tt>)
      </li>
      <li>      
	<tt>Forall<sub>?X,?Y</sub>(Exists<sub>?Z</sub>("p"^^rif:local(?X&nbsp;?Y&nbsp;?Z)))</tt>    (usually written as <tt>Forall&nbsp;?X&nbsp;?Y (Exists&nbsp;?Z ("p"^^rif:local(?X&nbsp;?Y&nbsp;?Z)))</tt>
      </li>
      <li>      
	<tt>Or("http://example.com/to-be"^^rif:iri(?X)  Neg("http://example.com/to-be"^^rif:iri(?X)))</tt>
      </li>
    </ul>
  </li>
  <li>  
    Aggregate term:  <tt>avg{?Sal [?Dept]|Exists&nbsp;?Empl "http://example.com/salary"^^rif:local(?Empl&nbsp;?Dept&nbsp;?Sal)}</tt>
  </li>
  <li>  
    Remote term:  <tt>?O[?N -&gt; "John"^^rif:string "http://example.com/salary"^^rif:iri -&gt;&nbsp;?S]@"http://acme.foo"^^xs:anyURI</tt>
  </li>
</ul>
<p><br />
</p><p><span class="anchor" id="sec-formal-external-schema"></span>
</p>
<a id="Schemas_for_Externally_Defined_Terms" name="Schemas_for_Externally_Defined_Terms"></a><h4> <span class="mw-headline">2.5  Schemas for Externally Defined Terms </span></h4>
<p>This section introduces the notion of <i>external schemas</i>, which serve as templates for externally defined terms. These schemas determine which externally defined terms are acceptable in a RIF dialect. Externally defined terms include RIF built-ins, which are specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], but are more general. They are designed to accommodate the ideas of procedural attachments and querying of external data sources. Because of the need to accommodate many different possibilities, the RIF logical framework supports a very general notion of an externally defined term. Such a term is not necessarily a function or a predicate -- it can be a frame, a classification term, and so on.
</p><p><span class="anchor" id="def-fld-external-schema"></span> 
<b>Definition (Schema for external term).</b>
An <i><b>external schema</b></i> has the form <tt>(?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;; &nbsp;loc)</tt> where
</p>
<ul>
  <li>  
    <tt>loc</tt> is the <a href="#ref-ext-locator" title="">locator</a> for an external source.
  </li>
 <li>
   <tt>&tau;</tt>  is a <a href="#def-fld-term" title="">term</a> of one of these kinds: constant, positional, named-argument, equality, classification, frame.
 </li>
 <li>
     <tt>?X<sub>1</sub> ...&nbsp;?X<sub>n</sub></tt> is a list of all distinct variables that occur in <tt>&tau;</tt> 
  </li>
</ul>
<p>The names of the variables in an external schema are immaterial, but their order is important. For instance, <tt>(?X&nbsp;?Y;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt> and <tt>(?V&nbsp;?W;&nbsp;&nbsp;?V["foo"^^xs:string-&gt;?W]; loc)</tt> are considered to be indistinguishable, but <tt>(?X&nbsp;?Y;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt> and <tt>(?Y&nbsp;?X;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt> are viewed as different schemas.
</p><p>An external term <tt>External(t loc1)</tt> is an <i><b>instantiation</b></i> of an external schema <tt>(?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;; loc)</tt> iff <tt>loc1=loc</tt> and  <tt>t</tt> can be obtained from <tt>&tau;</tt>  by a simultaneous substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>n</sub></tt> of the variables <tt>?X<sub>1</sub> ...&nbsp;?X<sub>n</sub></tt> with terms <tt>s<sub>1</sub> ... s<sub>n</sub></tt>, respectively. Some of the terms <tt>s<sub>i</sub></tt> can be variables themselves. For example, <tt>External(?Z["foo"^^xs:string-&gt;f("a"^^rif:local&nbsp;?P)] loc)</tt> is an instantiation of <tt>(?X&nbsp;?Y;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt> by the substitution <tt>?X/?Z&nbsp;&nbsp;?Y/f("a"^^rif:local&nbsp;?P)</tt>. &nbsp;&nbsp; ☐
</p><p>Observe that a variable cannot be an instantiation of an external schema, since <tt>&tau;</tt> in the above definition cannot be a variable. It will be seen later that this implies that a term of the form <tt>External(?X loc)</tt> is not well-formed in RIF. 
</p><p>The intuition behind the notion of an external schema, such as <tt>(?X&nbsp;?Y;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y] &nbsp;&lt;http://example.com/acme&gt;)</tt> and <tt>(?V;&nbsp; pred:isTime(?V) &nbsp;&lt;pred:isTime&gt;)</tt>, is that <tt>?X["foo"^^xs:string-&gt;?Y]</tt> or <tt>pred:isTime(?V)</tt> are invocation patterns for querying external sources, and instantiations of those schemas correspond to concrete invocations. Thus, <tt>External("http://foo.bar.com"^^rif:iri["foo"^^xs:string-&gt;"123"^^xs:integer]" &nbsp; &lt;http://example.com/acme&gt;)</tt> and <tt>External(pred:isTime("22:33:44"^^xs:time)" &nbsp; &lt;pred:isTime&gt;)</tt> are examples of invocations of external terms -- one querying the external source identified by the IRI <tt>http://example.com/acme</tt> and the other invoking the built-in identified by the IRI <tt>pred:isTime</tt>. 
</p><p>Recall that one-argument externals, such as <tt>External(t)</tt> are <a href="#ref-external-shorthand" title="">shortcuts for two-argument externals.</a> So, we define a one-argument external term to be an instantiation of an external schema iff its corresponding two-argument form is an instantiation of that schema.
</p><p><span class="anchor" id="def-fld-external-schema-set"></span> 
<b>Definition (Coherent set of external schemas).</b>
A set &Epsilon; of external schemas is <i><b>coherent</b></i> if there is no term, <tt>t</tt>, that is an instantiation of two distinct schemas in &Epsilon;. &nbsp;&nbsp; ☐
</p><p>The intuition behind this notion is to ensure that any use of an external term is associated with at most one external schema. This assumption is relied upon in the definition of the semantics of externally defined terms. Note that the coherence condition is easy to verify syntactically and that it implies that schemas like <tt>(?X&nbsp;?Y;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt> and <tt>(?Y&nbsp;?X;&nbsp;&nbsp;?X["foo"^^xs:string-&gt;?Y]; loc)</tt>, which differ only in the order of their variables, cannot be in the same coherent set.
</p><p>It is important to keep in mind that external schemas are <i>not</i> part of the language in RIF, since they do not appear anywhere in RIF expressions. Instead, like signatures, which are defined below, they are best thought of as part of the grammar of the language. In particular, they will be used to determine which external terms, i.e., the terms of the form <tt>External(t loc)</tt> are <a href="#def-fld-well-formed-term" title="">well-formed</a>.
</p><p><br />
<span class="anchor" id="sec-signature"></span>
</p>
<a id="Signatures" name="Signatures"></a><h4> <span class="mw-headline">2.6  Signatures </span></h4>
<p>In this section we introduce the concept of a <i>signature</i>, which is a key mechanism that allows RIF-FLD to control the context in which the various symbols are allowed to occur. For instance, a symbol <tt>f</tt> with signature <tt>{(term term) =&gt; term, (term) =&gt; term}</tt> can occur in terms like 
<tt>f(a b)</tt>, <tt>f(f(a b) a)</tt>, <tt>f(f(a))</tt>, etc., <i>if</i> <tt>a</tt> and <tt>b</tt> have signature <tt>term</tt>. But <tt>f</tt> is not allowed to appear in the context <tt>f(a b a)</tt> because there is no <tt>=&gt;</tt>-expression in the signature of <tt>f</tt> to support such a context.
</p><p>The above example provides intuition behind the use of signatures in RIF-FLD.
Much of the development, below, is inspired by [<a href="#ref-sorted-hilog-93" title="">CK95</a>]. It should be kept in mind that signatures are <i>not</i> part of the logic language in RIF, since they do not appear anywhere in RIF-FLD formulas. Instead they are part of the grammar: they are used to determine which sequences of tokens are in the language and which are not. The actual way by which signatures are assigned to the symbols of the language may vary from dialect to dialect. In some dialects (for example [<a href="#ref-rif-bld" title="">RIF-BLD</a>]), this assignment is derived from the context in which each symbol occurs and no separate language for signatures is used. Other dialects may choose to assign signatures explicitly. In that case, they would require a concrete language for signatures (which would be separate from the language for specifying the logic formulas of the dialect).
</p><p><span class="anchor" id="def-fld-signame"></span> 
<b>Definition (Signature name).</b>
Let <tt>SigNames</tt> be a non-empty, partially-ordered finite or countably infinite set of symbols, called <i><b>signature names</b></i>. Since signatures are not part of the logic language, their names do not have to be disjoint from <tt>Const</tt>, <tt>Var</tt>, and <tt>ArgNames</tt>. We require that this set includes at least the following <i>reserved</i> signature names: 
</p>
<ul><li> <tt>atomic</tt> -- used to represent the syntactic context where atomic formulas are allowed to appear. 
</li><li> <tt>formula</tt> -- represents the context where formulas (atomic or composite) may appear. 
</li><li>  <tt>&infin;-connective</tt>-- the signature for the connectives, such as <tt>And</tt> and <tt>Or</tt>, that can take any number of arguments.
</li><li>  <tt>2-connective</tt> -- the signature for the connectives, such as the rule implication connective <tt>:-</tt>, that take exactly two arguments.
</li><li> <tt>1-connective</tt>  -- the signature for the connectives that take exactly one argument. In our case, this signature will be used for the negation connectives and the quantifiers <tt>Forall</tt> and <tt>Exists</tt>.   
</li><li> <tt>=</tt> -- used for representing contexts where equality terms can appear. 
</li><li> <tt>#</tt> -- a signature name reserved for membership terms. 
</li><li> <tt>##</tt> -- a signature reserved for subclass terms. 
</li><li> <tt>-&gt;</tt> -- a signature reserved for frame terms.
</li><li> <tt>aggregate</tt> -- a signature reserved for aggregate functions.
</li><li> <tt>remote</tt> -- a signature reserved for the symbol <tt>@</tt> that is used to build remote terms.
</li><li> <tt>list</tt> -- a signature reserved for the symbol <tt>List</tt> that is used to represent <a href="#def-list-term" title="">closed lists</a>.
</li><li> <tt>openlist</tt> -- a signature reserved for the symbol <tt>OpenList</tt> that is used to represent <a href="#def-list-term" title="">open lists</a>. &nbsp;&nbsp;☐
</li></ul>
<p>Dialects may introduce additional signature names. For instance, RIF Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>] introduces the signature name <tt>individual</tt>. The partial order on <tt>SigNames</tt> is dialect-specific; it is used in the definition of well-formed terms below. 
</p><p>We use the symbol <tt>&lt;</tt>  to represent the partial order on <tt>SigNames</tt>. Informally, <tt>&alpha; &lt; &beta;</tt> means that terms with signature <tt>&alpha;</tt> can be used wherever terms with signature <tt>&beta;</tt> are allowed. We will write <tt>&alpha; &le; &beta;</tt> if either <tt>&alpha; = &beta;</tt> or <tt>&alpha; &lt; &beta;</tt>. 
</p><p><span class="anchor" id="def-fld-signature"></span> 
<b>Definition (Signature).</b>
A <i><b>signature</b></i> has the form <tt>&eta;{e<sub>1</sub>, ..., e<sub>n</sub>, ...}</tt> where <tt>&eta;</tt> &isin; <tt>SigNames</tt> is the name of the signature and <tt>{e<sub>1</sub>, ..., e<sub>n</sub>, ...}</tt> is a countable set of <i>arrow expressions</i>. Such a set can thus be infinite, finite, or even empty. In RIF-BLD, signatures can have at most one arrow expression. Other dialects (such as one for HiLog [<a href="#ref-hilog-93" title="">CKW93</a>] and Relfun [<a href="#ref-relfun-99" title="">RF99</a>], for example) may require polymorphic symbols and thus allow signatures with more than one arrow expression in them. 
</p><p>An <i><b>arrow expression</b></i> is defined as follows: 
</p>
<ul>
  <li>If <tt>&kappa;</tt>, <tt>&kappa;<sub>1</sub></tt>, ..., <tt>&kappa;<sub>n</sub></tt> &isin; <tt>SigNames</tt>, <tt>n&ge;0</tt>,  are signature names then <tt>(&kappa;<sub>1</sub> ... &kappa;<sub>n</sub>) &rArr; &kappa;</tt> is a <i><b>positional arrow expression</b></i>.
    <p>
      For instance, <tt>() &rArr; individual</tt> and <tt>(individual) &rArr; individual</tt> are positional arrow expressions, if <tt>individual</tt> is a signature name.
    </p>
  </li>
  <li>If <tt>&kappa;</tt>, <tt>&kappa;<sub>1</sub></tt>, ..., <tt>&kappa;<sub>n</sub></tt> &isin; <tt>SigNames</tt>, <tt>n&ge;0</tt>,  are signature names and <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt> &isin; <tt>ArgNames</tt> are argument names then <tt>(p<sub>1</sub>-&gt;&kappa;<sub>1</sub> ... p<sub>n</sub>-&gt;&kappa;<sub>n</sub>) =&gt; &kappa;</tt> is an <i><b>arrow expression with named arguments</b></i>.
    <p>
      For instance, <tt>(arg1-&gt;individual arg2-&gt;individual) =&gt; individual</tt> is an arrow signature expression with named arguments. The order of the arguments in arrow expressions with named arguments is immaterial, so any permutation of arguments yields the same expression.   &nbsp;&nbsp;☐
    </p>
  </li>
</ul>
<p>RIF dialects are always associated with sets of coherent signatures, defined next. The overall idea is that  a coherent set of signatures must include all the predefined signatures (such as signatures for equality and classification terms) and the signatures included in a coherent set must not conflict with each other. For instance, two different signatures should not have identical names and if one signature is said to extend another then the arrow expressions of the supersignature should be included among the arrow expressions of the subsignature (a kind of an arrow expression "inheritance").
</p><p><span class="anchor" id="def-fld-coherent-signature"></span> 
<b>Definition (Coherent signature set).</b>
A set <b>&Sigma;</b> of signatures is <i><b>coherent</b></i> iff 
</p>
<ol>
  <li><b>&Sigma;</b> contains the special signatures <tt>atomic{&nbsp;}</tt> and <tt>formula{&nbsp;}</tt>, which represent the context of atomic formulas and more generally, composite formulas, respectively. Furthermore, it is required that <tt>atomic &lt; formula</tt>.
  </li>
  <li>  
     <b>&Sigma;</b> contains the special signature <tt>&infin;-connective{e<sub>1</sub>, ..., e<sub>n</sub>, ...}</tt>, where each <tt>e<sub>n</sub></tt> has the form
       <tt>(formula ... formula) &rArr; formula</tt> (the left-hand side of this signature is a sequence of <tt>n</tt> symbols <tt>formula</tt>). 
       This signature is assigned to the connectives <tt>And</tt> and <tt>Or</tt>.
  </li>
  <li>  
     <b>&Sigma;</b> contains the special signature <tt>2-connective{(formula formula) &rArr; formula}</tt>. This signature is assigned to the rule implication connective.
  </li>
  <li>  
     <b>&Sigma;</b> contains the signature <tt>1-connective{(formula) &rArr; formula}</tt>. This signature is assigned to the negation connectives <tt>Naf</tt>  and <tt>Neg</tt>,  and to the reserved quantifiers of RIF-FLD, <tt>Exists<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> and <tt>Forall<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt>, for all variable sequences <tt>?X<sub>1</sub>,...,?X<sub>n</sub></tt> and <tt>n &ge; 0</tt>.
  </li>
  <li><b>&Sigma;</b> contains the signature <tt>={e<sub>1</sub>, ..., e<sub>n</sub>, ...}</tt> for the equality symbol.
    <p>
      All arrow expressions <tt>e<sub>i</sub></tt> here have the form <tt>(&kappa; &kappa;) &rArr; &gamma;</tt> (the arguments in an equation must be compatible) and at least one of these expressions must have the form <tt>(&kappa; &kappa;) &rArr; atomic</tt> (i.e., equation terms are also atomic formulas). Dialects may further specialize this signature.
    </p>
  </li>
  <li>
    <b>&Sigma;</b> contains the signature <tt>#{e<sub>1</sub>, ..., e<sub>n</sub>...}</tt> for membership terms.
    <p>
      Here all arrow expressions <tt>e<sub>i</sub></tt> are binary (have two arguments) and at least one has the form <tt>(&kappa; &gamma;) &rArr; atomic</tt>. Dialects may further specialize this signature. 
    </p>
  </li>
  <li><b>&Sigma;</b> contains the signature <tt>##{e<sub>1</sub>, ..., e<sub>n</sub>...}</tt> for subclass terms.
    <p>
      Here all arrow expressions <tt>e<sub>i</sub></tt> have the form <tt>(&kappa; &kappa;) &rArr; &gamma;</tt> (the arguments must be compatible) and at least one of these arrow expressions has the form <tt>(&kappa; &kappa;) &rArr; atomic</tt>. Dialects may further specialize this signature.
    </p>
  </li>
  <li><b>&Sigma;</b> contains the signature <tt>-&gt;{e<sub>1</sub>, ..., e<sub>n</sub>...}</tt> for frames.
    <ul>
      <li>
	Here all arrow expressions <tt>e<sub>i</sub></tt> are ternary (have three arguments) and at least one of them is of the form <tt>(&kappa;<sub>1</sub> &kappa;<sub>2</sub> &kappa;<sub>3</sub>) &rArr; atomic</tt>. Dialects may further specialize this signature.
      </li>
    </ul>
  </li>
  <li>      
    <b>&Sigma;</b> contains the signatures <tt>list</tt> and <tt>openlist</tt> for representing list terms.
    <ul>	 
      <li>
	The signature <tt>list</tt>, for closed lists, has arrow expressions of the form <tt>() &rArr; &kappa;</tt>, <tt>(&kappa;) &rArr; &kappa;</tt>, <tt>(&kappa; &kappa;) &rArr; &kappa;</tt>, and so on, where <tt>&kappa;</tt> is a signature. 
      </li>
      <li>	   
	The signature <tt>openlist</tt>, for open lists, has arrow expressions of the form <tt>(&kappa; &kappa;) &rArr; &kappa;</tt>, <tt>(&kappa; &kappa; &kappa;) &rArr; &kappa;</tt>, and so on, where <tt>&kappa;</tt> is a signature.
      </li>
    </ul>
  </li>
  <li>  
     <b>&Sigma;</b> contains the signature <tt>aggregate{e<sub>1</sub>, e<sub>2</sub>, ...}</tt> for aggregate terms.
     <p>
       Here each arrow expression <tt>e<sub>i</sub></tt>  has the form <tt>(formula) &rArr; &kappa;<sub>i</sub></tt>, for some signatures <tt>&kappa;<sub>1</sub></tt>, <tt>&kappa;<sub>2</sub></tt>, ....
     </p>
  </li>
  <li>  
     <b>&Sigma;</b> contains the signature <tt>remote{e<sub>1</sub>, e<sub>2</sub>, ...}</tt>, where at least one of the <tt>e<sub>i</sub></tt> is an arrow expression of the form <tt>(formula &kappa;) &rArr; formula</tt> for some signature <tt>&kappa;</tt>. This signature is assigned to the remote term symbol <tt>@</tt>.
  </li>
  <li>
    <b>&Sigma;</b> has at most one signature for any given signature name.
  </li>
  <li>
    Whenever <b>&Sigma;</b> contains a pair of signatures, <tt>&eta;A</tt> and <tt>&kappa;B</tt>, such that <tt>&eta;&lt;&kappa;</tt>  then <tt>B</tt>&sube;<tt>A</tt>.
    <p>
      Here <tt>&eta;A</tt> denotes a signature with the name <tt>&eta;</tt>  and the associated set of arrow expressions <tt>A</tt>; similarly <tt>&kappa;B</tt> is a signature named <tt>&kappa;</tt>  with the set of expressions <tt>B</tt>. The requirement that <tt>B</tt>&sube;<tt>A</tt> ensures that symbols that have signature <tt>&eta;</tt>  can be used wherever the symbols with signature <tt>&kappa;</tt>  are allowed.  &nbsp;&nbsp;☐
    </p>
  </li>
</ol>
<p><br />
The requirement that coherent sets of signatures must include the signatures for <tt>=</tt>, <tt>#</tt>, <tt>-&gt;</tt>, and so on is just a technicality that simplifies definitions. Some of these signatures may go "unused" in a dialect even though, technically speaking, they must be present in the signature set associated with that dialect. If a dialect disallows equality, classification terms, or frames in its syntax then the corresponding signatures will remain unused. Such restrictions can be imposed by specializing RIF-FLD -- see Section <a href="#sec-dialect-syntax" title="">Syntax of a RIF Dialect as a Specialization of RIF-FLD</a>.
</p><p>An <i>incoherent</i> set of signatures would be exemplified by one that includes signatures <tt>mysig{() &rArr; atomic}</tt> and <tt>mysig{(atomic) &rArr; atomic}</tt> because it has two different signatures with the same name. Likewise, if a set contains <tt>mysig<sub>1</sub>{() &rArr; atomic}</tt> and <tt>mysig<sub>2</sub>{(atomic) &rArr; atomic}</tt> and <tt>mysig<sub>1</sub> &lt; mysig<sub>1</sub></tt> then it is incoherent because the set of  arrow expressions of <tt>mysig<sub>1</sub></tt> does not contain the set of arrow expressions of <tt>mysig<sub>2</sub></tt>.
</p><p><br />
<span class="anchor" id="sec-fld-language"></span>
</p>
<a id="Presentation_Syntax_of_a_RIF_Dialect" name="Presentation_Syntax_of_a_RIF_Dialect"></a><h4> <span class="mw-headline">2.7  Presentation Syntax of a RIF Dialect </span></h4>
<p>The <i><b>presentation syntax of a RIF dialect</b></i> is a set of <a href="#sec-fld-wff" title="">well-formed formulas</a>, as defined in the next section. The language of the dialect is determined by the following parameters (see <a href="#sec-dialect-syntax" title="">Syntax of a RIF Dialect as a Specialization of RIF-FLD</a>):
</p>
<ul>
  <li> An <a href="#def-fld-alphabet" title="">alphabet</a>.</li>
  <li> A set of <a href="#def-fld-symspace" title="">symbol spaces</a>.</li>
  <li> An assignment of signatures from a <a href="#def-fld-coherent-signature" title="">coherent set of signatures</a> to the symbols in <tt>Var</tt>, <tt>Const</tt>, connectives, and quantifiers:
    <p>
      Each variable symbol is associated with <i>exactly one</i> signature from a coherent set of signatures. A constant symbol can have <i>one or more</i> signatures, and different symbols can be associated with the same signature. (Variables are not allowed to have multiple signatures because then well-formed terms would not be closed under substitutions. For instance, a term like <tt>f(?X,?X)</tt> could be well-formed, but <tt>f(a,a)</tt> could be ill-formed.)  
    </p>
  </li>
  <li>
     Restrictions on the classes of terms allowed in the language of the dialect.
  </li>
  <li>
     Restrictions on the classes of formulas allowed in the language of the dialect.
  </li>
  <li>A <a href="#def-fld-external-schema-set" title="">coherent set of external schemas</a>.</li>
</ul>
<p>We have already seen how the alphabet and the symbol spaces are used to define <a href="#def-fld-term" title="">RIF terms</a>. The next section shows how signatures and external schemas are used to further specialize this notion to define <i>well-formed</i> RIF-FLD terms.
</p><p>Note that the signatures for RIF-FLD connectives are fixed. Therefore, when defining a dialect, there is no need to repeat the definitions of <tt>1-connective</tt>, <tt>2-connective</tt>, etc. However, since the same symbol can be given several signatures, the syntactic context of connectives can be expanded by assigning more signatures to them. For instance, if a dialect allows rules to be <em>reified</em> and treated as objects, one could add another signature to <tt>:-</tt> with the arrow expression <tt>(formula formula) &rArr; individual</tt>, assuming that <tt>individual</tt> is a suitably chosen signature (e.g., one that is assigned to variables or a subsignature of the variable's signature).
</p><p>In contrast, the signatures for equality, frames, etc., are not completely fixed and have to be explicitly specialized by the dialects. For instance, in the arrow expression <tt>(&kappa; &kappa;) &rArr; atomic</tt> for the equality symbol, one has to tell what <tt>&kappa;</tt> exactly is. Since this kind of signatures must be explicitly defined by the dialects anyway, the dialect designer is allowed to add additional arrow expressions to them. If, for instance,  a dialect designer would like to allow reification of the equality statements, the signature for <tt>=</tt> could be defined as <tt>={(individual individual) &rArr; atomic, (individual individual) &rArr; individual}</tt>.
</p><p><br />
<span class="anchor" id="sec-fld-wff"></span>
</p>
<a id="Well-formed_Terms_and_Formulas" name="Well-formed_Terms_and_Formulas"></a><h4> <span class="mw-headline">2.8  Well-formed Terms and Formulas </span></h4>
<p>Since signature names uniquely identify signatures in coherent signature sets, we will often refer to signatures simply by their names. For instance, if one of <tt>f</tt>'s signatures is <tt>atomic{&nbsp;}</tt>, we may simply say that symbol <tt>f</tt> <i>has</i> signature <tt>atomic</tt>. 
</p><p><br />
<span class="anchor" id="def-fld-well-formed-term"></span> 
<b>Definition (Well-formed term).</b>
</p>
<ol>
  <li>A <i>constant</i> or <i>variable</i> symbol with signature <tt>&eta;</tt>  is a well-formed term with signature <tt>&eta;</tt>.
  </li>
  <li>A <i>positional term</i> <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt>, <tt>0&le;n</tt>, is well-formed and has a signature <tt>&sigma;</tt>  iff
    <ul>
      <li><tt>t</tt> is a well-formed term that has a signature that contains an arrow expression of the form <tt>(&sigma;<sub>1</sub> ... &sigma;<sub>n</sub>) &rArr; &sigma;</tt>; and
      </li>
      <li>Each <tt>t<sub>i</sub></tt> is a well-formed term whose signature is <tt>&gamma;<sub>i</sub></tt> such that <tt>&gamma;<sub>i</sub>, &le; &sigma;<sub>i</sub></tt>.
      </li>
    </ul>
      <p>
      As a special case, when <tt>n=0</tt> we obtain that <tt>t()</tt> is a well-formed term with signature <tt>&sigma;</tt>, if <tt>t</tt>'s signature contains the arrow expression <tt>() &rArr; &sigma;</tt>.
      </p>
  </li>
  <li>A <i>term with named arguments</i> <tt>t(p<sub>1</sub>-&gt;t<sub>1</sub> ... p<sub>n</sub>-&gt;t<sub>n</sub>)</tt>, <tt>0&le;n</tt>, is well-formed and has a signature <tt>&sigma;</tt>  iff
    <ul>
      <li><tt>t</tt> is a well-formed term that has a signature that contains an arrow expression with named arguments of the form <tt>(p<sub>1</sub>-&gt;&sigma;<sub>1</sub> ... p<sub>n</sub>-&gt;&sigma;<sub>n</sub>) &rArr; &sigma;</tt>; and 
      </li>
      <li>
        Each <tt>t<sub>i</sub></tt> is a well-formed term whose signature is <tt>&gamma;<sub>i</sub></tt>, such that <tt>&gamma;<sub>i</sub> &le; &sigma;<sub>i</sub></tt>.
      </li>
    </ul>
     <p>
      As a special case, when <tt>n=0</tt> we obtain that <tt>t()</tt> is a well-formed term with signature <tt>&sigma;</tt>,  if <tt>t</tt>'s signature contains the arrow expression <tt>() &rArr; &sigma;</tt>. 
     </p>
  </li>
  <li>
    An <i>equality term</i> of the form <tt>t<sub>1</sub>=t<sub>2</sub></tt> is well-formed and has a signature <tt>&kappa;</tt>  iff
    <ul>
      <li>
        The signature <tt>=</tt> has an arrow expression <tt>(&sigma; &sigma;) &rArr; &kappa;</tt>
      </li>
      <li>
        <tt>t<sub>i</sub></tt> and <tt>t<sub>2</sub></tt> are well-formed terms with signatures <tt>&gamma;<sub>1</sub></tt> and <tt>&gamma;<sub>2</sub></tt>, respectively, such that <tt>&gamma;<sub>i</sub> &le; &sigma;</tt>, <tt>i=1,2</tt>.
      </li>
    </ul>
  </li>
  <li>A <i>membership term</i> of the form <tt>t<sub>1</sub>#t<sub>2</sub></tt> is well-formed and has a signature <tt>&kappa;</tt>  iff
    <ul>
      <li>The signature <tt>#</tt> has an arrow expression <tt>(&sigma;<sub>1</sub> &sigma;<sub>2</sub>) &rArr; &kappa;</tt>
      </li>
      <li>
        <tt>t<sub>1</sub></tt> and <tt>t<sub>2</sub></tt> are well-formed terms with signatures <tt>&gamma;<sub>1</sub></tt> and <tt>&gamma;<sub>2</sub></tt>, respectively, such that <tt>&gamma;<sub>i</sub> &le; &sigma;<sub>i</sub></tt>, <tt>i=1,2</tt>.
      </li>
    </ul>
  </li>
  <li>A <i>subclass term</i> of the form <tt>t<sub>1</sub>##t<sub>2</sub></tt> is well-formed and has a signature <tt>&kappa;</tt>  iff
    <ul>
      <li>The signature <tt>##</tt> has an arrow expression <tt>(&sigma; &sigma;) &rArr; &kappa;</tt>
      </li>
      <li><tt>t<sub>1</sub></tt> and <tt>t<sub>2</sub></tt> are well-formed terms with signatures <tt>&gamma;<sub>1</sub></tt> and <tt>&gamma;<sub>2</sub></tt>, respectively, such that <tt>&gamma;<sub>i</sub> &le; &sigma;</tt>, <tt>i=1,2</tt>.
      </li>
    </ul>
  </li>
  <li>A <i>frame term</i> of the form <tt>t[s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>]</tt> is well-formed and has a signature <tt>&kappa;</tt>  iff
    <ul>
      <li>The signature <tt>-&gt;</tt> has arrow expressions <tt>(&sigma; &sigma;<sub>11</sub> &sigma;<sub>12</sub>) &rArr; &kappa;, ..., (&sigma; &sigma;<sub>n1</sub> &sigma;<sub>n2</sub>) &rArr; &kappa;</tt> (these <tt>n</tt> expressions need not be distinct).
      </li>
      <li>
        <tt>t</tt>, <tt>s<sub>j</sub></tt>, and <tt>v<sub>j</sub></tt> are well-formed terms with signatures <tt>&gamma;</tt>, <tt>&gamma;<sub>j1</sub></tt>, and <tt>&gamma;<sub>j2</sub></tt>, respectively, such that <tt>&gamma; &le; &sigma;</tt> and <tt>&gamma;<sub>ji</sub> &le; &sigma;<sub>ji</sub></tt>, where <tt>j=1,...,n</tt> and <tt>i=1,2</tt>.
      </li>
    </ul>
  </li>
  <li>  
    An <i>externally defined term</i>, <tt>External(t loc)</tt>, is well-formed and has signature <tt>&kappa;</tt>  iff
    <ul>
      <li>
        <tt>t</tt> is well-formed and has signature <tt>&kappa;</tt>. 
      </li>
      <li>      
        <tt>External(t loc)</tt> is an <a href="#def-fld-external-schema" title="">instantiation of an external schema</a> that belongs to a <a href="#def-fld-external-schema-set" title="">coherent set of external schemas</a> of the <a href="#sec-fld-language" title="">language</a>.
        <p>
           Note that, according to the definition of coherent sets of schemas, a term can be an instantiation of at most one external schema. &nbsp;&nbsp; ☐
        </p>
      </li>
    </ul>
  </li>
  <li>  
     A <i>formula term</i> of the form <tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt>, <tt>0&le;n</tt> is well-formed if <tt>S</tt> is a connective or a quantifier whose signature has an arrow expression  <tt>(&sigma;<sub>1</sub> ... &sigma;<sub>n</sub>) &rArr; formula</tt> and each <tt>t<sub>i</sub></tt> is a well-formed term whose signature is <tt>&le; &sigma;<sub>i</sub></tt>.
     <p>
        In the special case of our reserved connectives and quantifiers, <tt>t<sub>1</sub>, ..., t<sub>n</sub></tt> must have signatures that are below <tt>formula</tt> (i.e., <tt>&le; formula</tt>). Also, if <tt>S</tt> is <tt>:-</tt> then <tt>n</tt> must be equal <tt>2</tt> and if <tt>S</tt> is <tt>Neg</tt>, <tt>Naf</tt>, <tt>Forall</tt>, or <tt>Exists</tt> then <tt>n=1</tt>.
     </p>
  </li>
  <li>  
     An <i>aggregate term</i> of the form <tt><em>sym</em>{?V [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt> is well formed if the aggregate symbol <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub></tt> is assigned signature <tt>aggregate</tt> and the term <tt><em>sym</em><sub>&nbsp;?V[?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>]</sub>(&tau;)</tt> is well-formed (as a positional term). 
     <p>
       This implies that <tt>&tau;</tt> must have the signature <tt>formula</tt> or <tt>&lt; formula</tt>. Unless a dialect introduces additional signatures, this also means that <tt>&tau;</tt> must be a formula term (i.e., a compound formula) or an atomic formula (see below). 
     </p>
  </li>
  <li>  
     A <i>remote term</i> of the form <tt>&phi;@r</tt> is well-formed if the positional term <tt>@(&phi; r)</tt> is well-formed. This implies that <tt>&phi;</tt> must be well-formed and have the signature <tt>formula</tt>, that <tt>r</tt> must a well-formed term, and that the term <tt>&phi;@r</tt> itself has the signature <tt>formula</tt> (and, possibly, others). 
  </li>
</ol>
<p>Note that, like the constant symbols, well-formed terms can have more than one signature. Also note that, according to the above definition, <tt>f()</tt> and <tt>f</tt> are distinct terms.
</p><p><br />
<span class="anchor" id="def-fld-well-formed-formula"></span> 
<b>Definition (Well-formed formula).</b>
A <i><b>well-formed atomic formula</b></i> is a well-formed term one of whose signatures is <tt>atomic</tt> or <tt>&lt;&nbsp;atomic</tt> (less than <tt>atomic</tt> in the order <tt>&lt;</tt>). 
Note that equality, membership, subclass, and frame terms are atomic formulas, since <tt>atomic</tt> is one of their signatures. 
A <i><b>well-formed formula</b></i> is
</p>
<ul><li> A well-formed term whose signature is <tt>formula</tt> or <tt>&lt; formula</tt>; or
</li><li> A <i>group</i> formula; or
</li><li> A <i>document</i> formula.
</li></ul>
<p>Group and document formulas are defined below. For clarity, we will also give explicit definitions of conjunctive, disjunctive, rule, and other formulas even though they were already defined as special cases of the definition of well-formed formula terms (the first of the above bullets). Recall that all terms have a canonical function application form, but some are also written in a more familiar infix or prefix forms. For instance, rule implication, <tt>a&nbsp;:- b</tt>, has the canonical form <tt>:-(a b)</tt> and the canonical form for negation, <tt>Naf p</tt> and <tt>Neg p</tt>, is <tt>Naf(p)</tt> and <tt>Neg(p)</tt>.
</p>
<ol>
  <li>
    <i>Atomic</i>: If <tt>&phi;</tt> is a well-formed atomic formula then it is also a well-formed formula.
  </li>
  <li>  
     <i>Remote</i>: A well-formed remote term <tt>&phi;@r</tt> is also a well-formed formula.
  </li>
  <li><i>Conjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are well-formed formula terms then so is <tt>And(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>.
    <p>
      As a special case, <tt>And()</tt> is allowed and is treated as a tautology, i.e., a formula that is always true. 
    </p>
  </li>
  <li><i>Disjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are well-formed formula terms then so is <tt>Or(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>.
    <p>
      As a special case, <tt>Or()</tt> is treated as a contradiction, i.e., a formula that is always false. 
    </p>
  </li>
  <li><i>Symmetric negation</i>: If <tt>&phi;</tt>  is a well-formed formula term then so is <tt>Neg &phi;</tt>.
  </li>
  <li><i>Default negation</i>: If <tt>&phi;</tt>  is a well-formed formula term then so is <tt>Naf &phi;</tt>.
  </li>
  <li><i>Rule implication</i>: If <tt>&phi;</tt>  and <tt>&psi;</tt>  are well-formed formula terms then so is <tt>&phi;&nbsp;:- &psi;</tt>.
  </li>
  <li>
    <i>Constraint</i>: If <tt>&psi;</tt>  is a well-formed formula term then so is <tt>&nbsp;:- &psi;</tt>.
    <p>
    This type of formulas is also known as an <i>error-producing constraint</i>. The intent is that the constraint formula is satisfied if the premise <tt>&psi;</tt> is false. Constraints can also be viewed as rule implications whose conclusion is false.
    </p>
  </li>
  <li><i>Universal and existential quantification</i>: If <tt>&phi;</tt>  is a well-formed formula term then
    <ul>
      <li><tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> </li>
      <li><tt>Exists&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt></li>
    </ul>
    <p>
     are well-formed formula terms. Recall that <tt>Forall<sub>?V<sub>1</sub>,...,?V<sub>n</sub></sub></tt> and <tt>Exists<sub>?V<sub>1</sub>,...,?V<sub>n</sub></sub></tt> are the reserved universal and existential quantifiers, respectively. The notation  <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> is an alternative for <tt>Forall<sub>?V<sub>1</sub>,...,?V<sub>n</sub></sub>(&phi;)</tt>, and similarly for <tt>Exists</tt>.
    </p>
  </li>
  <li>
    <i>Group</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt> are well-formed formula terms or <tt>Group</tt>-formulas then <tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt> is a well-formed <i>group formula</i>. As a special case, the empty group formula, <tt>Group()</tt>, is well-formed and is treated as a tautology, i.e., a well-formed formula that is always true.
    <p>
       Non-empty group formulas are intended to represent sets of formulas. Note that some of the <tt>&phi;<sub>i</sub></tt>'s can themselves be group formulas, which means that groups can be nested.
    </p>
  </li>
  <li>  
    <i>Document</i>: An expression of the form <tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> &Gamma;)</tt> is a well-formed <i>document formula</i>, if
    <ul>    
      <li>      
        <tt>&Gamma;</tt> is an optional well-formed group formula; it is called the group formula <span id="def-associated-group"><i>associated</i></span> with the document.
      </li>
      <li>      
        <em>directive<sub>1</sub></em>, ..., <em>directive<sub>n</sub></em> is an optional sequence of <i>directives</i>. A directive can be a <i>dialect directive</i>, a <i>base directive</i>, a <i>prefix directive</i>, an <i>import directive</i>, or a <i>remote module directive</i>.
	<ul>
	  <li>	  
	    A <i><b>dialect directive</b></i> has the form <tt>Dialect(<i>D</i>)</tt>, where <i>D</i> is a Unicode string that specifies the name of a dialect.  This directive specifies the dialect of a RIF document. Some dialects may require this directive in all of its documents, while others (notably, RIF-BLD) may not allow it and instead may entirely rely on other syntax. (Purely syntactic identification may not always be possible for dialects that are syntactically identical but semantically different, such as deductive databases with stable model semantics [<a href="#ref-stable-model" title="">GL88</a>] and with well-founded semantics [<a href="#ref-wf-model" title="">GRS91</a>]. These two dialects are examples where the <tt>Dialect</tt> directive might be necessary.)
	  </li>
	  <li>	
	    A <i><b>base directive</b></i> has the form <tt>Base(&lt;iri&gt;)</tt>, where <tt>iri</tt> is a Unicode string in the form of an absolute IRI.
	    <p>
	      The <tt>Base</tt> directive defines a syntactic shortcut for expanding relative IRIs into full IRIs, as described in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-symbol-spaces" title="DTB">Constants and Symbol Spaces</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].   This applies to relative IRIs that appear anywhere, including as constants, symbol spaces, location, and profile.
	    </p>
	  </li>
	  <li>	
	    A <i><b>prefix directive</b></i> has the form <tt>Prefix(p &lt;v&gt;)</tt>, where <tt>p</tt> is an alphanumeric string that serves as the prefix name and <tt>v</tt> is an expansion for <tt>p</tt> -- a string that forms an IRI.
	   (An alphanumeric string is a sequence of ASCII characters, where each character is a letter, a digit, or an underscore "_", and the first character is a letter.)
	    <p>
	      Like the <tt>Base</tt> directive, the <tt>Prefix</tt> directives define shorthands to allow more concise representation of <tt>rif:iri</tt> constants. This mechanism is explained in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-symbol-spaces" title="DTB">Constants and Symbol Spaces</a>.
	    </p>
	  </li>
	  <li>      
	    <span class="anchor" id="ref-import-directive">An <i><b>import directive</b></i></span> can have one of these two forms: <tt>Import(loc)</tt> or <tt>Import(loc p)</tt>.
	    <p>
	      Here <tt>loc</tt> is a <span class="anchor" id="ref-locator"><i><b>locator</b></i></span> that uniquely identifies some other document, which is to be imported. The exact form of the locator <tt>loc</tt>, the protocol that associates locators with documents, and the type of the imported documents is left to dialects to specify. However, all dialects must support the form <tt>&lt;IRI&gt;</tt>,  where <tt>IRI</tt>  is a sequence of Unicode characters that forms an IRI.
	    The second argument to <tt>Import</tt>, <tt>p</tt>, is a sequence of Unicode characters called the <i>profile of import</i>.
	    </p>
	    <p>
	      RIF-FLD gives a semantics only to the one-argument directive <tt>Import(loc)</tt>. The two-argument directive <tt>Import(loc p)</tt> is reserved for RIF dialects, which can use it to import non-RIF logical entities, such as RDF data and OWL ontologies [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>]. The profile can specify what kind of entity is being imported and under what semantics. For instance, the various RDF entailment regimes are specified in [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] as profiles that have the form of Unicode strings that form IRIs.
	    </p>
	  </li>
	  <li>	  
	     A <i><b>remote module directive</b></i> has the form <tt>Module(n loc)</tt>.  Here <tt>n</tt> is a variable-free term that represents the internal name of the remote module linked to the document -- it is the name under which the module is referenced in the document. The second argument, <tt>loc</tt>, is a <a href="#ref-locator" title="">locator</a> for the document that contains the rules and the data of the module.
	     <p>
	       As with <tt>Import</tt>, RIF-FLD does not restrict <tt>n</tt> and <tt>loc</tt> syntactically any further. However, we shall see that it does impose semantic restrictions on <tt>n</tt>, and <tt>loc</tt> is required to uniquely identify an existing RIF document. The exact protocol that is used to associate <tt>loc</tt> with documents and the type of those documents is left to dialects.
	     </p>
	  </li>
	</ul>
	<p>
	   Note that although <tt>Base</tt>, <tt>Prefix</tt>, and <tt>Import</tt> all make use of symbols of the form <tt>&lt;iri&gt;</tt>  to indicate the connection of these symbols to IRIs, these symbols are <em>not</em> <tt>rif:iri</tt>  constants, as semantically they are interpreted in a way that is quite different from constants. 
	</p>
	<p>
          A document formula can contain at most one <tt>Dialect</tt> and at most one <tt>Base</tt> directive. The <tt>Dialect</tt> directive, if present, must be first, followed by an optional <tt>Base</tt> directive, followed by any number of <tt>Prefix</tt> directives, followed by any number of <tt>Import</tt> directives, followed by any number of <tt>Module</tt> directives.
	</p>
      </li>
    </ul>
  </li>
</ol>
<p>
  In the definition of a formula, the component formulas <tt>&phi;</tt>, <tt>&phi;<sub>i</sub></tt>, <tt>&psi;<sub>i</sub></tt>, and <tt>&Gamma;</tt>  are said to be <span class="anchor" id="def-subformula"><i><b>subformulas</b></i></span> of the respective formulas (conjunction, disjunction, negation, implication, group, etc.) that are built using these components. &nbsp;&nbsp;☐
</p>
<p>Observe that the restrictions in (1) -- (8) above imply that groups and documents cannot be nested inside formula terms and documents cannot be nested inside groups.
</p><p><br />
</p>
<p>
<b>Example 2</b> (Signatures, well-formed terms and formulas).
</p>
<p>We illustrate the above definitions with the following examples. In addition to <tt>atomic</tt>, let there be another signature, <tt>term{&nbsp;}</tt>, which is intended here to represent the context of the arguments to positional function or atomic formulas.
</p><p>Consider the term <tt>p(p(a)&nbsp;p(a&nbsp;b&nbsp;c))</tt>. If <tt>p</tt> has the (polymorphic) signature <tt>mysig</tt>{(<tt>individual</tt>)&rArr;<tt>individual</tt>, (<tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>, (<tt>individual</tt> <tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>} and <tt>a</tt>, <tt>b</tt>, <tt>c</tt> each has the signature <tt>individual{&nbsp;}</tt> then <tt>p(p(a)&nbsp;p(a&nbsp;b&nbsp;c))</tt> is a well-formed term with signature <tt>individual{&nbsp;}</tt>. If instead <tt>p</tt> had the signature <tt>mysig2</tt>{(<tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>, (<tt>individual</tt> <tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>} then <tt>p(p(a)&nbsp;p(a&nbsp;b&nbsp;c))</tt> would not be a well-formed term since then <tt>p(a)</tt> would not be well-formed (in this case, <tt>p</tt> would have no arrow expression which allows <tt>p</tt> to take just one argument). 
</p><p>For a more complex example, let <tt>r</tt> have the signature <tt>mysig3</tt>{(<tt>individual</tt>)&rArr;<tt>atomic</tt>, (<tt>atomic</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>, (<tt>individual</tt> <tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>}. Then <tt>r(r(a)&nbsp;r(a&nbsp;b&nbsp;c))</tt> is well-formed. The interesting twist here is that <tt>r(a)</tt> is an atomic formula that occurs as an argument to a function symbol. However, this is allowed by the arrow expression (<tt>atomic</tt> <tt>individual</tt>)&rArr; <tt>individual</tt>, which is part of <tt>r</tt>'s signature. If <tt>r</tt>'s signature were <tt>mysig4</tt>{(<tt>individual</tt>)&rArr;<tt>atomic</tt>, (<tt>atomic</tt> <tt>individual</tt>)&rArr;<tt>atomic</tt>, (<tt>individual</tt> <tt>individual</tt> <tt>individual</tt>)&rArr;<tt>individual</tt>} instead, then <tt>r(r(a)&nbsp;r(a&nbsp;b&nbsp;c))</tt> would be not only a well-formed term, but also a well-formed atomic formula. 
</p><p>An even more interesting example arises when the right-hand side of an arrow expression is something other than <tt>individual</tt> or <tt>atomic</tt>. For instance, let <tt>John</tt>, <tt>Mary</tt>, <tt>NewYork</tt>, and <tt>Boston</tt> have signatures <tt>individual{&nbsp;}</tt>; <tt>flight</tt> and <tt>parent</tt> have signature <tt>h<sub>2</sub>{(individual individual)&rArr;atomic}</tt>; and <tt>closure</tt> has signature <tt>hh<sub>1</sub>{(h<sub>2</sub>)&rArr;p<sub>2</sub>}</tt>, where <tt>p<sub>2</sub></tt> is the name of the signature <tt>p<sub>2</sub>{(individual individual)&rArr;atomic}</tt>. Then <tt>flight(NewYork&nbsp;Boston)</tt>, <tt>closure(flight)(NewYork&nbsp;Boston)</tt>, <tt>parent(John&nbsp;Mary)</tt>, and <tt>closure(parent)(John&nbsp;Mary)</tt> would be well-formed formulas. Such formulas are allowed in languages like HiLog [<a href="#ref-hilog-93" title="">CKW93</a>], which support predicate constructors like <tt>closure</tt> in the above example.  &nbsp;&nbsp;☐
</p><p><br />
<span class="anchor" id="sec-formal-syntax-metadata"></span>
</p>
<a id="Annotations_in_the_Presentation_Syntax" name="Annotations_in_the_Presentation_Syntax"></a><h4> <span class="mw-headline">2.9  Annotations in the Presentation Syntax </span></h4>
<p>RIF-FLD allows every term and formula (including terms and formulas that occur inside other terms and formulas) to be optionally preceded by <i>one</i> <i><b>annotation</b></i> of the form <tt>(* id &phi; *)</tt> where <tt>id</tt> is a constant and <tt>&phi;</tt> is a RIF formula that is not a document-formula. Both items inside the annotation are optional. The <tt>id</tt> part represents the identifier of the term (or formula) to which the annotation is attached and <tt>&phi;</tt> is the rest of the annotation. RIF-FLD does not impose any restrictions on <tt>&phi;</tt> apart from what is stated above. This means that <tt>&phi;</tt> may include variables, function symbols, <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> constants, and so on.   
</p><p>Document formulas with and without annotations will be referred to as <i><b>RIF-FLD documents</b></i>.
</p><p>A convention is used to avoid a syntactic ambiguity in the above definition. For instance, in <tt>(* id &phi; *) t[w -&gt; v]</tt> the annotation can be attributed to the term <tt>t</tt> or to the entire frame <tt>t[w -&gt; v]</tt>. Similarly, for an annotated HiLog-like term of the form <tt>(* id &phi; *) f(a)(b,c)</tt>, the annotation can be attributed to the entire term <tt>f(a)(b,c)</tt> or to just <tt>f(a)</tt>. The convention adopted in RIF-FLD is that any annotation is syntactically associated with the largest RIF-FLD term or formula that appears to the right of that annotation. Therefore, in our examples the annotation <tt>(* id &phi; *)</tt> is considered to be attached to the entire frame <tt>t[w -&gt; v]</tt> and to the entire term <tt>f(a)(b,c)</tt>.
Yet, since <tt>&phi;</tt> can be a conjunction, some conjuncts can be used to provide metadata targeted to the object part, <tt>t</tt>, of the frame. For instance, <tt>(* And(_foo[meta_for_frame-&gt;"this is an annotation for the entire frame"] _bar[meta_for_object-&gt;"this is an annotation for t" meta_for_property-&gt;"this is an annotation for w"] *) t[w -&gt; v]</tt>.  Generally, the convention associates each annotation to the largest term or formula it precedes.
</p><p>We suggest to use Dublin Core, RDFS, and OWL properties for metadata, along the lines of <a class="external text" href="http://www.w3.org/TR/owl-ref/#Annotations" rel="nofollow" title="http://www.w3.org/TR/owl-ref/#Annotations">Section 7.1</a> of [<a href="#ref-owl-reference" title="">OWL-Reference</a>]-- specifically <tt>owl:versionInfo</tt>, <tt>rdfs:label</tt>, <tt>rdfs:comment</tt>, <tt>rdfs:seeAlso</tt>, <tt>rdfs:isDefinedBy</tt>, <tt>dc:creator</tt>, <tt>dc:description</tt>, <tt>dc:date</tt>, and <tt>foaf:maker</tt>.
</p><p><br />
</p>
<p>
<b>Example 3</b> (A RIF-FLD document with nested groups and annotations).
</p>
<p>We illustrate formulas, including documents and groups, with the following complete example (with apologies to Shakespeare for the imperfect rendering of the intended meaning in logic). For better readability, we use the notation defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], which provides shortcuts for writing IRIs. The first shortcut notation lets one write long <tt>rif:iri</tt> constants in the form <tt>prefix:name</tt>, where <tt>prefix</tt> is a short name that expands into an IRI according to a suitable <tt>Prefix</tt> directive. For instance, <tt>ex:man</tt> would expand into the <tt>rif:iri</tt> constant <tt>"http://example.org/ontology#man"^^rif:iri</tt>, if <tt>ex</tt> is defined as in the <tt>Prefix(ex ...)</tt> directive  below. The second shortcut notation uses angle brackets as a way to shorten the <tt>"..."^^rif:iri</tt> idiom. For instance, the prevous <tt>rif:iri</tt> constant can be alternatively represented as <tt>&lt;http://example.org/ontology#man&gt;</tt>. The last shortcut notation lets one write <tt>rif:iri</tt> constants using IRIs relative to a base, where the base IRI is specified in a <tt>Base</tt> directive. For instance, with the <tt>Base</tt> directive, below, both <tt>&lt;Yorick&gt;</tt>  and <tt>"Yorick"^^rif:iri</tt> expand into the <tt>rif:iri</tt> constant <tt>"http://www.shakespeare-literature.com/Hamlet/Yorick"^^rif:iri</tt>.  The example also illustrates attachment of annotations.
</p>
<pre> Document(
   Base(&lt;http://www.shakespeare-literature.com/Hamlet/&gt;)
   Prefix(dc     &lt;http://<a class="external free" href="http://purl.org/dc/terms/" rel="nofollow" title="http://purl.org/dc/terms/">http://purl.org/dc/terms/</a>&gt;)
   Prefix(ex     &lt;http://example.org/ontology#&gt;)
   
   (* &lt;assertions&gt; &lt;assertions&gt;[dc:title-&gt;"Hamlet" dc:creator-&gt;"Shakespeare"] *)
   Group(
      Exists&nbsp;?X (And(?X # ex:RottenThing
                     ex:partof(?X &lt;http://www.denmark.dk&gt;)))
      Forall&nbsp;?X (Or(&lt;tobe&gt;(?X)  Naf &lt;tobe&gt;(?X)))
      Forall&nbsp;?X (And(Exists&nbsp;?B (And(ex:has(?X&nbsp;?B)&nbsp;?B # ex:business))
                     Exists&nbsp;?D (And(ex:has(?X&nbsp;?D)&nbsp;?D # ex:desire)))
                  &nbsp;:-&nbsp;?X # ex:man)
      (* &lt;facts&gt; *)
      Group(
         &lt;Yorick&gt; # ex:poor
         &lt;Hamlet&gt; # ex:prince
      )
   )
 )
</pre>
<p>The above RIF formulas are (admittedly awkward) logical renderings of the following statements from Shakespeare's Hamlet: "Something is rotten in the state of Denmark," "To be, or not to be," and "Every man has business and desire."
</p><p>Observe that the above set of formulas has a nested subset with its own
annotation, <tt>&lt;facts&gt;</tt>, which contains only a global IRI.   &nbsp;&nbsp;☐
</p><p>The following example illustrates the use of imported RIF documents and of remote terms.
</p>
<p>
<b>Example 4</b> (A RIF-FLD document with imports, remote module references, and aggregation).
</p>
<p>
  The first document, below, imports the second document, which is assumed to be located at the IRI <tt>http://example.org/universityontology</tt>. In addition, the first document has references to two remote modules, which are located at <tt>http://example.org/university#1</tt> and <tt>http://example.org/university#2</tt>, respectively.  These modules are assumed to be knowledge bases that provide the usual information about university enrollment, courses offered in different semesters, and so on.
The rules corresponding to the remote modules are not shown, as they do not illustrate new features. In the simplest case, these knowledge bases can simply be sets of facts for the predicates/frames that supply the requisite information.
</p>
<pre> Document(
   Prefix(u    &lt;http://example.org/universityontology#&gt;)
   Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)
   Import(&lt;http://example.org/universityontology&gt;)
   Module(_univ(1) &lt;http://example.org/university#1&gt;)
   Module(_univ(2) &lt;http://example.org/university#2&gt;)
 
   Group(
     Forall&nbsp;?Stud&nbsp;?Crs&nbsp;?Semester&nbsp;?U (u:takes(?Stud&nbsp;?Crs&nbsp;?Semester)&nbsp;:-
                                       &nbsp;?Stud[u:takes(?Semester)-&gt;?Crs]@ _univ(?U))
     Forall&nbsp;?Prof&nbsp;?Crs&nbsp;?Semester&nbsp;?U (u:teaches(?Prof&nbsp;?Crs&nbsp;?Semester)&nbsp;:-
                                        u:teaches(?Prof&nbsp;?Crs&nbsp;?Semester)@ _univ(?U))
     Forall&nbsp;?Crs (u:popular_course(?Crs)&nbsp;:-
                      And(?Crs#u:Course
                          pred:numeric-less-than(500
                                                 count{?Stud[?Crs]|Exists&nbsp;?Semester (u:takes(?Stud&nbsp;?Crs&nbsp;?Semester))})))
   )
 )
</pre>
<p><br />
The imported document, located at <tt>http://example.org/universityontology</tt>, has the following form:
</p>
<pre> Document(
   Group(
     Forall&nbsp;?Stud&nbsp;?Prof&nbsp;?Sem
               (u:studentOf(?Stud&nbsp;?Prof)&nbsp;:-
                       And(u:takes(?Stud&nbsp;?Crs&nbsp;?Sem) u:teaches(?Prof&nbsp;?Crs&nbsp;?Sem)))
   )
 )
</pre>
<p>In this example, the main document contains three rules, which define the predicates <tt>u:takes</tt>, <tt>u:teaches</tt> and <tt>u:popular_course</tt>. The information for the first two predicates is obtained by querying the remote modules corresponding to Universities 1 and 2. The rule that defines the first predicate says that if the remote university knowledge base says that a student <tt>s</tt> takes a course <tt>c</tt> in a certain semester <tt>s</tt> then <tt>takes(s c s)</tt> is true in the main document. The second rule makes a similar statement about professors teaching courses in various semesters. Inside the main document, the external modules are referred to via the terms <tt>_univ(1)</tt> and <tt>_univ(2)</tt>. The <tt>Module</tt> directives tie these references to the actual locations. The underscore in front of <tt>univ</tt> signifies that this is a <tt>rif:local</tt> symbol and is a shortcut for <tt>"univ"^^rif:local</tt>, as defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-symbol-spaces" title="DTB">Constants and Symbol Spaces</a>. Note that the remote modules use frames to represent the enrollment information and predicates to represent course offerings. The rules in the main document convert both of these representations to predicates. The third rule illustrates a use of aggregation. The comprehension variable here is <tt>?Stud</tt> and <tt>?Crs</tt> is a grouping variable. Note that these are the only free variables in the formula over which aggregation is computed. For each course, the aggregate counts the number of students in that course over all semesters, and if the number exceeds 500 then the course is declared popular. Note also that the comprehension variable <tt>?Stud</tt> is bound by the aggregate, so it is not quantified in the <tt>Forall</tt>-prefix of the rule.
</p><p>The imported document has only one rule, which defines a new concept, <tt>u:studentOf</tt> (a student is a <tt>studentOf</tt> of a certain professor if that student takes a course from that professor). Since the main document imports the second document, it can answer queries about <tt>u:studentOf</tt> as if this concept were defined directly within the main document. &nbsp;&nbsp;☐
</p><p><br />
<span class="anchor" id="sec-concrete-syntax"></span>
</p>
<a id="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-FLD" name="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-FLD"></a><h4> <span class="mw-headline">2.10  EBNF Grammar for the Presentation Syntax of RIF-FLD </span></h4>
<p>Until now, to specify the syntax of RIF-FLD we relied on "mathematical English," a special form of English for communicating mathematical definitions, examples, etc. We will now specify the syntax using the familiar EBNF notation. The following points about the EBNF notation should be kept in mind: 
</p>
<ul><li> The syntax of RIF-FLD relies on the signature mechanism and is not context-free, so EBNF does not capture this syntax precisely. As a result, the EBNF grammar defines a strict <i>superset</i> of RIF-FLD (not all formulas that are derivable using the EBNF grammar are well-formed). 
</li><li> The EBNF syntax is <i>not a concrete</i> syntax: it does not address the details of how constants (defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) and variables are represented, and it is not sufficiently precise about the delimiters and escape symbols. White space is informally used as a delimiter, and is implied in productions that use Kleene star. For instance, <tt>TERM*</tt> is to be understood as <tt>TERM&nbsp;TERM&nbsp;...&nbsp;TERM</tt>, where each ' ' abstracts from one or more blanks, tabs, newlines, etc. This is done intentionally since RIF's presentation syntax is used as a tool for specifying the semantics and for illustration of the main RIF concepts through examples.
</li><li> RIF defines a concrete syntax only for exchanging rules, and that syntax is XML-based, obtained as a refinement and serialization of the EBNF syntax via the <a href="#sec-translate-fld-to-xml" title="">presentation-syntax-to-XML mapping for RIF-FLD</a>.
</li></ul>
<p>Keeping the above in mind, the EBNF grammar can be seen as just an intermediary between the mathematical English and the XML. However, it also gives a succinct view of the syntax of RIF-FLD and as such can be useful for dialect designers and users alike.
</p><p><br />
</p>
<pre>  Document      &nbsp;::= IRIMETA? 'Document' '(' Dialect? Base? Prefix* Import* Module* Group? ')'
  Dialect       &nbsp;::= 'Dialect' '(' Name ')'
  Base          &nbsp;::= 'Base' '(' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'  
  Prefix        &nbsp;::= 'Prefix' '(' <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Module        &nbsp;::= IRIMETA? 'Module' '(' (Const | Expr) LOCATOR ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (FORMULA | Group)* ')'
  Implies       &nbsp;::= IRIMETA? FORMULA ':-' FORMULA
  FORMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' FORMULA* ')' |
                     IRIMETA? QUANTIFIER '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA?  FORMULA '@' MODULEREF |
                     FORM
  PROFILE       &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a>
  FORM          &nbsp;::= IRIMETA? (Var | ATOMIC |
                               'External' '(' ATOMIC LOCATOR? ')')
  ATOMIC        &nbsp;::= Const | Atom | Equal | Member | Subclass | Frame
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= TERMULA '(' (TERMULA* | (Name '-&gt;' TERMULA)*) ')'
  Equal         &nbsp;::= TERMULA '=' TERMULA
  Member        &nbsp;::= TERMULA '#' TERMULA
  Subclass      &nbsp;::= TERMULA '##' TERMULA
  Frame         &nbsp;::= TERMULA '[' (TERMULA '-&gt;' TERMULA)* ']'
  TERMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' TERMULA* ')' |
                     IRIMETA? QUANTIFIER '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? TERMULA '@' MODULEREF |
                     TERM
  TERM          &nbsp;::= IRIMETA? (Var | EXPRIC | List |
                               'External' '(' EXPRIC LOCATOR? ')' |
                               AGGREGATE | NEWTERM)
  EXPRIC        &nbsp;::= Const | Expr | Equal | Member | Subclass | Frame
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  AGGREGATE     &nbsp;::= AGGRFUNC '{' Var ('[' Var+ ']')? '|' FORMULA '}'
  Const         &nbsp;::= '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"^^' SYMSPACE | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CONSTSHORT</a>
  MODULEREF     &nbsp;::= Var | Const | Expr
  CONNECTIVE    &nbsp;::= 'And' | 'Or' | NEWCONNECTIVE
  QUANTIFIER    &nbsp;::= ('Exists' | 'Forall' | NEWQUANTIFIER) Var*
  AGGRFUNC      &nbsp;::= 'Min' | 'Max' | 'Sum' | 'Prod' | 'Avg' | 'Count' |
                     'Set' | 'Bag' | NEWAGGRFUNC
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> | '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"'
  SYMSPACE      &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CURIE</a>
  
  IRIMETA       &nbsp;::= '(*' Const? (Frame | 'And' '(' Frame* ')')? '*)'
</pre>
<p>The RIF-FLD presentation syntax does not commit to any particular vocabulary and permits arbitrary sequences of Unicode characters in constant symbols, argument names, and variables. Such sequences are denoted with <tt>UNICODESTRING</tt> in the above syntax. Constant symbols have this form: <tt>"UNICODESTRING"^^SYMSPACE</tt>, where <tt>SYMSPACE</tt> is a <tt>ANGLEBRACKIRI</tt> or <tt>CURIE</tt> that represents the identifier of the symbol space of the constant. <tt>UNICODESTRING</tt>, <tt>ANGLEBRACKIRI</tt>, and <tt>CURIE</tt> are defined in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">Shortcuts for Constants in RIF's Presentation Syntax</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Constant symbols can also have several shortcut forms, which are represented by the non-terminal <tt>CONSTSHORT</tt>. These shortcuts are also defined in the same section of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. One of them is the <tt>CURIE</tt> shortcut, which is used in the examples in this document.
Names are Unicode character sequences that form valid XML <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCNames</a> [<a href="#ref-xml-names" title="">XML-Names</a>]. Variables are composed of Names prefixed with a <tt>?</tt>-sign.
</p><p><tt>LOCATOR</tt>, which is used in several places in the grammar, is a non-terminal whose definition is left to the dialects. It is intended to specify the protocol by which external sources, remote modules, and imported RIF documents are located. This must include the basic form <tt>&lt;IRI&gt;</tt>, where <tt>IRI</tt> is a Unicode string in the form of an absolute IRI.
</p><p>The symbols <a href="#ref-newconective" title=""><tt>NEWCONNECTIVE</tt></a>, <a href="#ref-newquantifier" title=""><tt>NEWQUANTIFIER</tt></a>, <a href="#ref-newaggrfunc" title=""><tt>NEWAGGRFUNC</tt></a>, and <a href="#ref-newterm" title=""><tt>NEWTERM</tt></a>  are RIF-FLD <a href="#ref-extension-point" title="">extension points</a>. They are not actual symbols in the alphabet. Instead, dialects are supposed to replace <tt>NEWCONNECTIVE</tt>, <tt>NEWQUANTIFIER</tt>, and <tt>NEWAGGRFUNC</tt>, by zero or more actual new symbols, while <tt>NEWTERM</tt> is to be replaced by zero or more new kinds of terms.
Note that the extension point <a href="#ref-newsymbol" title=""><tt>NEWSYMBOL</tt></a> is not shown in the EBNF grammar, since the grammar completely avoids mentioning the alphabet of the language (which is infinite).
</p><p><br />
Each RIF-FLD formula and term can be prefixed with one optional annotation, <tt>IRIMETA</tt>, for identification and metadata. <tt>IRIMETA</tt> is represented using <tt>(*...*)</tt>-brackets that contain an optional <tt>rif:iri</tt> constant as identifier followed by an optional <tt>Frame</tt> or conjunction of <tt>Frame</tt>s as metadata. One such specialization is <tt>'"' IRI '"^^' 'rif:iri'</tt> from the <tt>Const</tt> production, where <tt>IRI</tt> is a sequence of Unicode characters that forms an internationalized resource identifier as defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</p><p>Note that the RIF-FLD presentation syntax (as reflected in the above EBNF grammar) strives to have a more familiar look by avoiding some of the formal parts of the syntax defined in Sections <a href="#sec-alphabet" title="">Alphabet</a> and <a href="#sec-terms" title="">Terms</a>. For instance, as mentioned in those sections, the quantifier symbols <tt>Exists<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> and <tt>Forall<sub>?X<sub>1</sub>,...,?X<sub>n</sub></sub></tt> are linearized as <tt>Exists&nbsp;?X<sub>1</sub>,...,?X<sub>n</sub></tt> and <tt>Forall&nbsp;?X<sub>1</sub>,...,?X<sub>n</sub></tt>. Likewise, the symbol <tt>OpenList</tt> is not used. Instead, open lists are written using the more familiar form <tt>LIST(Head|Tail)</tt>. Also, some connectives, such as <tt>:-</tt>, are written in infix form. Other connectives, such as <tt>Neg</tt> and <tt> Naf</tt>, are written in prefix form without parentheses.
</p><p><br />
<span class="anchor" id="sec-fld-semantic-framework"></span>
</p>
<a id="Semantic_Framework" name="Semantic_Framework"></a><h2> <span class="mw-headline">3  Semantic Framework </span></h2>
<p>Recall that the presentation syntax of RIF-FLD allows the use of shorthand notation, which is specified via the <tt>Prefix</tt>  and <tt>Base</tt>  directives, and various shortcuts for integers, strings, and <tt>rif:local</tt> symbols.
The semantics, below, is described using the full syntax, i.e., we
assume that all shortcuts have already been expanded, as defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-symbol-spaces" title="DTB">Constants and Symbol Spaces</a>.
</p><p><span class="anchor" id="sec-rif-dialect-semantics"></span> 
</p>
<a id="Semantics_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD" name="Semantics_of_a_RIF_Dialect_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">3.1  Semantics of a RIF Dialect as a Specialization of RIF-FLD </span></h4>
<p>The RIF-FLD semantic framework defines the notions of <i>semantic structures</i> and of <i>models</i> for RIF-FLD formulas. The <i><b>semantics of a dialect</b></i> is derived from these notions by specializing the following parameters. 
</p>
<ol>
  <li>The <i>effect of the syntax</i>.
    <ul>
      <li>
	The syntax of a dialect may limit the kinds of terms that are allowed.
	<p>
	  For instance, if a dialect's syntax excludes frames or terms with named arguments then the parts of the <a href="#sec-model-theory" title="">semantic structures</a> whose purpose is to interpret those types of terms (<tt><i><b>I</b></i><sub>frame</sub></tt> and <tt><i><b>I</b></i><sub>NF</sub></tt> in this case) become redundant. 
        </p>
      </li>
      <li>
	The dialect might introduce additional terms and their interpretation by semantic structures.
      </li>
      <li>      
	The dialect might introduce additional connectives and quantifiers with their interpretation.
      </li>
    </ul>
  </li>
  <li><i>Truth values</i>.
  <p>
    The RIF-FLD semantic framework allows formulas to have truth values from an arbitrary partially ordered set of truth values, <i><b>TV</b></i>. A concrete dialect must select a concrete partially or totally ordered set of truth values. 
    </p>
  </li>
  <li><i>Datatypes</i>.
    <p>A datatype is a symbol space whose symbols have a fixed interpretation in any semantic structure. RIF-FLD defines a set of core datatypes that each dialect is required to include as part of its syntax and semantics. However, RIF-FLD does not limit dialects to just the core types: they can introduce additional datatypes, and each dialect must define the exact set of datatypes that it includes.
    </p>
  </li>
  <li>  <i>Directives, connectives, extension points</i>.
    <p>
     Specialization of the definitions of RIF-BLD directives and logical connectives. Semantics of the syntactic components corresponding to the RIF-FLD extension points.
    </p>
  </li>
  <li><i>Logical entailment</i>.
    <p>
      Logical entailment in RIF-FLD is defined with respect to an unspecified set of <i>intended</i> semantic structures (sometimes also known as <i>preferred</i> semantic structures). This notion of entailment is very general and is known to subsume most of the known logical semantics for rule-based systems.
    </p>
    <p>
      A RIF dialect must define which semantic structures should considered intended. The actual choice depends on the desired semantics and is typically done by a trained logician. Many "off-the-shelf" semantics -- each suitable for different purposes -- have been defined in the literature.
      For instance, one dialect might specify that all semantic structures are intended (which leads to classical first-order entailment), another may consider only the minimal models as intended structures, while a third dialect might only use <i>stable</i> or <i>well-founded</i> models [<a href="#ref-wf-model" title="">GRS91</a>, <a href="#ref-stable-model" title="">GL88</a>].
    </p>
  </li>
</ol>
<p>
  These notions are defined in the remainder of this specification. 
</p>
<p><br />
<span class="anchor" id="sec-truth-values"></span>
</p>
<a id="Truth_Values" name="Truth_Values"></a><h4> <span class="mw-headline">3.2  Truth Values </span></h4>
<p><span class="anchor" id="def-fld-truth-value"></span> 
<b>Definition (Set of truth values).</b>
Each RIF dialect must define the set of <i><b>truth values</b></i>, denoted by <i><b>TV</b></i>. This set must have a partial order, called the <i><b>truth order</b></i>, denoted &lt;<sub>t</sub>. In some dialects, &lt;<sub>t</sub> can be a total order. We write <i>a</i> &le;<sub>t</sub> <i>b</i> if either <i>a</i> &lt;<sub>t</sub> <i>b</i> or <i>a</i> and <i>b</i> are the same element of <i><b>TV</b></i>. In addition, 
</p>
<ul><li> <i><b>TV</b></i> must be a complete lattice with respect to &lt;<sub>t</sub>, i.e., the least upper bound (lub<sub>t</sub>) and the greatest lower bound (glb<sub>t</sub>) must exist for any subset of <i><b>TV</b></i>. 
</li><li> <i><b>TV</b></i> is required to have two distinguished elements, <b>f</b> and <b>t</b>, such that <b>f</b> &le;<sub>t</sub> <i>elt</i> and <i>elt</i> &le;<sub>t</sub> <b>t</b> for every <i>elt</i>&isin;<i><b>TV</b></i>. 
</li><li> <i><b>TV</b></i> has an <i><b>operator of negation</b></i>, &nbsp; <tt>~</tt>: <i><b>TV</b></i> &rarr; <i><b>TV</b></i>, such that 
<ul><li> <tt>~</tt> is a self-inverse function: applying <tt>~</tt> twice gives the identity mapping.
</li><li> <tt>~</tt> is anti-monotonic: <i>elt</i><sub>1</sub> &le;<sub>t</sub> <i>elt</i><sub>2</sub> implies <tt>~</tt><i>elt</i><sub>2</sub> &le;<sub>t</sub> <tt>~</tt><i>elt</i><sub>1</sub>.
</li><li> <tt>~</tt><b>t</b> = <b>f</b> &nbsp; (and thus <tt>~</tt><b>f</b> = <b>t</b>).
</li></ul>
</li></ul>
<p>The last condition follows from the earlier ones and is listed for didactic purposes only.  &nbsp;&nbsp;☐
</p><p>RIF dialects can have additional truth values. For instance, the semantics of some versions of NAF, such as <i>well-founded negation</i>, requires three truth values: <b>t</b>, <b>f</b>, and <b>u</b> (undefined), where <b>f</b> &lt;<sub>t</sub> <b>u</b> &lt;<sub>t</sub> <b>t</b>. Handling of contradictions and uncertainty usually requires at least four truth values: <b>t</b>, <b>u</b>, <b>f</b>, and <b>i</b> (inconsistent). In this case, the truth order is partial: <b>f</b> &lt;<sub>t</sub> <b>u</b> &lt;<sub>t</sub> <b>t</b> and <b>f</b> &lt;<sub>t</sub> <b>i</b> &lt;<sub>t</sub> <b>t</b>. The negation operator <tt>~</tt> is then defined to be the identity on the new truth values <b>u</b> and <b>i</b>.
</p><p><br />
<span class="anchor" id="sec-data-types"></span>
</p>
<a id="Datatypes" name="Datatypes"></a><h4> <span class="mw-headline">3.3  Datatypes </span></h4>
<p><span class="anchor" id="def-fld-datatype"></span> 
<b>Definition (Datatype).</b>
A <i><b>datatype</b></i> is a symbol space that has 
</p>
<ul><li> an associated set, called the <i><b>value space</b></i>, and 
</li><li> a mapping from the lexical space of the symbol space to the value space, called <i><b>lexical-to-value-space mapping</b></i>.  &nbsp;&nbsp;☐
</li></ul>
<p>Semantic structures are always defined with respect to a particular set of datatypes, denoted by <i><b>DTS</b></i>. In a concrete dialect, <i><b>DTS</b></i> always includes the datatypes supported by that dialect. All RIF dialects must support the datatypes that are listed in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
Their value spaces and the lexical-to-value-space mappings for these datatypes are described in the same section.
</p><p><br />
Although the lexical and the value spaces might sometimes look similar, one should not confuse them. Lexical spaces define the syntax of the constant symbols in the RIF language. Value spaces define the <i>meaning</i> of the constants. The lexical and the value spaces are often not even isomorphic. For example, <tt>1.2^^xs:decimal</tt> and <tt>1.20^^xs:decimal</tt> are two legal -- and distinct -- constants in RIF because <tt>1.2</tt> and <tt>1.20</tt> belong to the lexical space of <tt>xs:decimal</tt>. However, these two constants are interpreted by the <i>same</i> element of the value space of the <tt>xs:decimal</tt> type. Therefore, <tt>1.2^^xs:decimal&nbsp;=&nbsp;1.20^^xs:decimal</tt> is a RIF tautology. Likewise, RIF semantics for datatypes implies certain inequalities. For instance, <tt>abc^^xs:string</tt> &ne; <tt>abcd^^xs:string</tt> is a tautology, since the lexical-to-value-space mapping of the <tt>xs:string</tt> type maps these two constants into distinct elements in the value space of <tt>xs:string</tt>. 
</p><p><br />
<span class="anchor" id="sec-model-theory"></span> 
</p>
<a id="Semantic_Structures" name="Semantic_Structures"></a><h4> <span class="mw-headline">3.4  Semantic Structures </span></h4>
<p>The central step in specifying a model-theoretic semantics for a logic-based language is defining the notion of a <i>semantic structure</i>. Semantic structures are used to assign truth values to <a href="#sec-fld-wff" title="">RIF-FLD formulas</a>. 
</p><p><span class="anchor" id="def-fld-sem-struct"></span> 
<b>Definition (Semantic structure).</b>
A <i><b>semantic structure</b></i>, <i><b>I</b></i>, is a tuple of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>connective</sub>, <i><b>I</b></i><sub>truth</sub>&gt;. Here <i><b>D</b></i> is a non-empty set of elements called the <i><b>domain</b></i> of <i><b>I</b></i>. We will continue to use <tt>Const</tt> to refer to the set of all constant symbols and <tt>Var</tt> to refer to the set of all variable symbols. <i><b>TV</b></i> denotes the set of truth values that the semantic structure uses and <i><b>DTS</b></i> is a set of identifiers for datatypes.
</p><p>The other components of <i><b>I</b></i> are <i>total</i> mappings defined as follows: 
</p>
<ol>
  <li><i><b>I</b></i><sub>C</sub> maps <tt>Const</tt> to elements of <i><b>D</b></i>.
    <p>This mapping interprets constant symbols. </p>
  </li>
  <li><i><b>I</b></i><sub>V</sub> maps <tt>Var</tt> to elements of <i><b>D</b></i>.
    <p>This mapping interprets variable symbols. </p>
  </li>
  <li><i><b>I</b></i><sub>F</sub> maps <i><b>D</b></i> to total functions <i><b>D*</b></i> &rarr; <i><b>D</b></i> (here <i><b>D*</b></i> is a set of all finite sequences over the domain <i><b>D</b></i>).
    <p>This mapping interprets positional terms. </p>
  </li>
  <li><i><b>I</b></i><sub>NF</sub> interprets terms with named arguments. It is a total mapping from <i><b>D</b></i> to the set of total functions of the form <tt>SetOfFiniteBags</tt>(<tt>ArgNames</tt> &times; <i><b>D</b></i>) &rarr; <i><b>D</b></i>.
    <p>
      This is analogous to the interpretation of positional terms with two differences:
    </p>
    <ul>
      <li>Each pair &lt;<tt>s,v</tt>&gt; &isin; <tt>ArgNames</tt> &times; <i><b>D</b></i> represents an argument/value pair instead of just a value in the case of a positional term.
      </li>
      <li>The argument to a term with named arguments is a finite bag of argument/value pairs rather than a finite ordered sequence of simple elements.
      </li>
      <li>Bags are used here because the order of the argument/value pairs in a term with named arguments is immaterial and the pairs may repeat: <tt>p(a-&gt;b a-&gt;b)</tt>. (However, <tt>p(a-&gt;b a-&gt;b)</tt> is not equivalent to <tt>p(a-&gt;b)</tt>, as we shall see later.)
        <p>
          To see why such repetition can occur, note that argument names may repeat: <tt>p(a-&gt;b a-&gt;c)</tt>. This can be understood as treating <tt>a</tt> as a bag-valued argument. Identical argument/value pairs can then arise as a result of a substitution. For instance, <tt>p(a-&gt;?A a-&gt;?B)</tt> becomes <tt>p(a-&gt;b a-&gt;b)</tt> if the variables <tt>?A</tt> and <tt>?B</tt> are both instantiated with the symbol <tt>b</tt>.
        </p>
      </li>
    </ul>
  </li>
  <li>  
     <i><b>I</b></i><sub>list</sub> and <i><b>I</b></i><sub>tail</sub> are used to interpret lists. They are mappings of the following form:
     <ul>     
       <li>
	 <i><b>I</b></i><sub>list</sub>&nbsp;: <i><b>D</b></i><sup>*</sup> &rarr; <i><b>D</b></i> 
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>&nbsp;: <i><b>D</b></i><sup>+</sup>&times;<i><b>D</b></i> &rarr; <i><b>D</b></i>
       </li>
     </ul>
     <p>
        In addition, these mappings are required to satisfy the following conditions:
     </p>
     <ul>     
       <li>
	 The function <i><b>I</b></i><sub>list</sub> is injective (one-to-one).
       </li>
       <li>
	 The set <i><b>I</b></i><sub>list</sub>(<i><b>D</b></i><sup>*</sup>), henceforth denoted <span class="anchor" id="def-Dlist"><i><b>D</b></i><sub>list</sub></span>, is disjoint from the value spaces of all data types in <i><b>DTS</b></i>.
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>)) = <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>). 
       </li>
     </ul>
     <p>
       Note that the last condition above restricts <i><b>I</b></i><sub>tail</sub> only when its last argument is in <i><b>D</b></i><sub>list</sub>. If the last argument of <i><b>I</b></i><sub>tail</sub> is not in <i><b>D</b></i><sub>list</sub>, then the list is a general open one and there are no restrictions on the value of <i><b>I</b></i><sub>tail</sub> except that it must be in <i><b>D</b></i>.
     </p>
  </li>
  <li><i><b>I</b></i><sub>frame</sub> is a total mapping from <i><b>D</b></i> to total functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i> &times; <i><b>D</b></i>) &rarr; <i><b>D</b></i>.
     <p>
       This mapping interprets frame terms. An argument, <tt>d</tt> &isin; <i><b>D</b></i>, to <i><b>I</b></i><sub>frame</sub> represents an object and a finite bag {&lt;<tt>a1,v1</tt>&gt;, ..., &lt;<tt>ak,vk</tt>&gt;} represents a bag (multiset) of attribute-value pairs for <tt>d</tt>. We will see shortly how <i><b>I</b></i><sub>frame</sub> is used to determine the truth valuation of frame terms.
     </p>
     <p>
       Bags are employed here because the order of the attribute/value pairs in a frame is immaterial and the pairs may repeat. For instance, <tt>o[a-&gt;b a-&gt;b]</tt>. Such repetitions arise naturally when variables are instantiated with constants. For instance, <tt>o[?A-&gt;?B&nbsp;?C-&gt;?D]</tt> becomes <tt>o[a-&gt;b a-&gt;b]</tt> if variables <tt>?A</tt> and <tt>?C</tt> are instantiated with the symbol <tt>a</tt> and <tt>?B</tt>, <tt>?D</tt> with <tt>b</tt>. (We shall see later that <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> is equivalent to <tt>o[a-&gt;b]</tt>.)
     </p>
  </li>
  <li><i><b>I</b></i><sub>sub</sub> gives meaning to the subclass relationship. It is a total function <i><b>D</b></i> &times; <i><b>D</b></i> &rarr; <i><b>D</b></i>.
    <p>The operator <tt>##</tt> is required to be transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> must imply <tt>c1&nbsp;##&nbsp;c3</tt>. This is ensured by a restriction in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>isa</sub> gives meaning to class membership. It is a total function <i><b>D</b></i> &times; <i><b>D</b></i> &rarr; <i><b>D</b></i>.
    <p>The relationships <tt>#</tt> and <tt>##</tt> are required to have the usual property that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> must imply <tt>o&nbsp;#&nbsp;scl</tt>. This is ensured by a restriction in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>=</sub> is a total function <i><b>D</b></i> &times; <i><b>D</b></i> &rarr; <i><b>D</b></i>.
    <p>It gives meaning to the equality operator.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>truth</sub> is a total mapping <i><b>D</b></i> &rarr; <i><b>TV</b></i>.
    <p>It is used to define truth valuation for formulas.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>external</sub> is a mapping from the coherent set of schemas for externally defined terms to total functions <i><b>D</b></i>* &rarr; <i><b>D</b></i>. For each external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;; loc)</tt> in the <a href="#sec-fld-language" title="">coherent set of such schemas associated with the language</a>, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is a function of the form <i><b>D</b></i><sup>n</sup> &rarr; <i><b>D</b></i>.
    <p>
      For every external schema, <tt>&sigma;</tt>,  associated with the language, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is assumed to be specified externally in some document (hence the name <i>external schema</i>). In particular, if <tt>&sigma;</tt> is a schema of a RIF built-in predicate or function, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] so that:
    </p>
    <ul>
        <li>
	  If <tt>&sigma;</tt> is a schema of a built-in function then <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) must be the function defined in the aforesaid document.
	</li>
	<li>
	  If <tt>&sigma;</tt> is a schema of a built-in predicate then 
	  <i><b>I</b></i><sub>truth</sub><tt> &omicron; </tt>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)) (the composition of <i><b>I</b></i><sub>truth</sub> and <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>), a truth-valued function) must be as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
	</li>
     </ul>
  </li>
  <li>
    <i><b>I</b></i><sub>connective</sub> is a mapping that assigns every connective, quantifier, or aggregate symbol a function <i><b>D*</b></i> &rarr; <i><b>D</b></i>.
    <p>
      Further restrictions on the interaction of this function with <i><b>I</b></i><sub>truth</sub> will be imposed in order to ensure the intended semantics for each connective and quantifier.
      For aggregates, <i><b>I</b></i><sub>connective</sub> maps them to functions <i><b>D</b></i> &rarr; <i><b>D</b></i> and additional restrictions are imposed on the mapping <i><b>I</b></i> defined below.
    </p>
  </li>
</ol>
<p>We also define the following <span class="anchor" id="def-term-interpreting-map"><i><b>term-interpreting mapping</b></i></span> on well-formed terms, which we denote using the same symbol <i><b>I</b></i> that is used for the semantic structure itself. This overloading is convenient and does not lead to ambiguity.
</p>
<ol>
  <li>
    <i><b>I</b></i>(<tt>k</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>k</tt>), if <tt>k</tt> is a symbol in <tt>Const</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>?v</tt>) = <i><b>I</b></i><sub>V</sub>(<tt>?v</tt>), if <tt>?v</tt> is a variable in <tt>Var</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>F</sub>(<i><b>I</b></i>(<tt>f</tt>))(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>),...,<i><b>I</b></i>(<tt>t<sub>n</sub></tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>NF</sub>(<i><b>I</b></i>(<tt>f</tt>))({&lt;<tt>s<sub>1</sub></tt>,<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;,...,&lt;<tt>s<sub>n</sub></tt>,<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
    <p>Here we use {...} to denote a bag of argument/value pairs. </p>
  </li>
  <li>  
     For list terms, the mapping is defined as follows:
     <ul>     
       <li>
	 <i><b>I</b></i>(<tt>List()</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>&lt;&gt;</tt>). 
	 <p>
	   Here <tt>&lt;&gt;</tt> denotes an empty list of elements of <i><b>D</b></i>. (Note that the domain of <i><b>I</b></i><sub>list</sub> is <i><b>D</b></i><sup>*</sup>, so <i><b>D</b></i><sup>0</sup> is an empty list of elements of <i><b>D</b></i>.)
	 </p>
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>list</sub>(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>t<sub>n</sub>)</tt>), if <tt>n&gt;0</tt>. 
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t<sub>1</sub> ... t<sub>n</sub> | t</tt>)) = <i><b>I</b></i><sub>tail</sub>(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>t<sub>n</sub></tt>), <i><b>I</b></i>(<tt>t</tt>)), if <tt>n&gt;0</tt>. 
       </li>
     </ul>
  </li>
  <li>
    <i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub>&nbsp;...&nbsp;a<sub>n</sub>-&gt;v<sub>n</sub>]</tt>) = <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>))({&lt;<i><b>I</b></i>(<tt>a<sub>1</sub></tt>),<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;, ..., &lt;<i><b>I</b></i>(<tt>a<sub>n</sub></tt>),<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
    <p>Here {...} denotes a bag of attribute/value pairs.  Jumping ahead, we note that duplicate elements in such a bag do not affect the meaning of a frame formula. So, for instance, <tt>o[a-&gt;b a-&gt;b]</tt> and <tt>o[a-&gt;b]</tt> always have the same truth value.</p>
  </li>
  <li><i><b>I</b></i>(<tt>c1##c2</tt>) = <i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i>(<tt>c1</tt>), <i><b>I</b></i>(<tt>c2</tt>))
  </li>
  <li><i><b>I</b></i>(<tt>o#c</tt>) = <i><b>I</b></i><sub>isa</sub>(<i><b>I</b></i>(<tt>o</tt>), <i><b>I</b></i>(<tt>c</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>x=y</tt>) = <i><b>I</b></i><sub>=</sub>(<i><b>I</b></i>(<tt>x</tt>), <i><b>I</b></i>(<tt>y</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>External(t loc)</tt>) = <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>)), if <tt>External(t loc)</tt> is an instantiation of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>; &tau;; loc)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>n</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t loc)</tt> is well-formed only if it is an instantiation of an external schema. Furthermore, by the <a href="#def-fld-external-schema-set" title="">definition of coherent sets of external schemas</a>, it can be an instantiation of at most one such schema, so <i><b>I</b></i>(<tt>External(t loc)</tt>) is well-defined.
    </p>
  </li>
  <li>
    If <tt>S</tt> is a connective, a quantifier, or an aggregate and <tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a well-formed formula term (for an aggregate, <tt>n=1</tt>) then
    <p>
       <i><b>I</b></i>(<tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt>) =
       <i><b>I</b></i><sub>connective</sub>(<tt>S</tt>)(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>) ... <i><b>I</b></i>(<tt>t<sub>n</sub></tt>))
    </p>
  </li>
  <li>For standard aggregates, the mapping <i><b>I</b></i> is defined as follows.
    <p>
       Let <em>aggr</em>{<tt>?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;</tt>} be an aggregate and let <i>S</i> be the following set:
    </p>
    <p>
       <i>S</i> = {(<i><b>I</b></i><sub>V</sub><sup>*</sup>(<tt>?X</tt>),<i><b>I</b></i><sub>V</sub><sup>*</sup>(<tt>?X<sub>1</sub></tt>), ..., <i><b>I</b></i><sub>V</sub><sup>*</sup>(<tt>?X<sub>n</sub></tt>)) | for all semantic structures <i><b>I</b></i><sup>*</sup> such that <i><b>I</b></i><sup>*</sup>(<tt>&tau;</tt>) = <b>t</b> and <i><b>I</b></i><sup>*</sup> is exactly like <i><b>I</b></i> except that <i><b>I</b></i><sub>V</sub><sup>*</sup>(<tt>?X</tt>) can be different from <i><b>I</b></i><sub>V</sub>(<tt>?X</tt>)}.
    </p>
    <p>
      In addition, let <span style="text-decoration: overline"><i>S</i></span><sub>set</sub> denote the <em>set</em> of all elements x such that (x,x<sub>1</sub>, ..., x<sub>n</sub>) &isin; <i>S</i> and <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> denote the <em>bag</em> of all such elements x (i.e., <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> can have repeated occurrences of the same element). 
    </p>
    <ol style="list-style-type:lower-alpha">
      <li><i>Set aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>setof{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>L</tt>)
	    <p>
	       where <tt>L</tt> is a sorted list of the elements in <span style="text-decoration: overline"><i>S</i></span><sub>set</sub>. Since sorting requires an ordering, the above is well-defined only for semantic structures with totally ordered domains. If <tt>L</tt>  is infinite then the value of the aggregate in <i><b>I</b></i> is indeterminate (i.e., it can be any element of the domain <i><b>D</b></i>).
	    </p>
	    <p>
	       The requirement that the list <tt>L</tt> must be sorted comes from the fact that there can be many ways to represent <span style="text-decoration: overline"><i>S</i></span><sub>set</sub> as a list, while <i><b>I</b></i>(<tt>setof{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) must be defined as one concrete element of the domain <i><b>D</b></i>. Sorting a set is a standard way of providing the requisite unique representation.
	    </p>
	  </li>
	</ul>
      </li>
      <li><i>Bag aggregate</i>:
	<ul>
	  <li>
	    <i><b>I</b></i>(<tt>bagof{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>L</tt>)
	    <p>
	       where <tt>L</tt> is a sorted list of the elements in <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>. This is well-defined only for semantic structures with totally ordered domains. If <tt>L</tt>  is infinite then the value of the aggregate in <i><b>I</b></i> is indeterminate (i.e., it can be any element of the domain <i><b>D</b></i>).
	    </p>
	    <p>
	       The reason for sorting <tt>L</tt> is the same as in the case of the set aggregate. 
	    </p>
	  </li>
	</ul>
      </li>
      <li><i>Min aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>min{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>min</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>min</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate.
	    The bag <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> must have a well-defined total order and <tt>min</tt> must compute the minimum elements of finite totally ordered bags.
	  </li>
	</ul>
      </li>
      <li><i>Max aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>max{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>max</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>max</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate.
	    The bag <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> must have a well-defined total order and <tt>max</tt> must compute the maximum elements of finite totally ordered bags.
	  </li>
	</ul>
      </li>
      <li><i>Count aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>count{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>count</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>count</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate. The function <tt>count</tt> must compute the cardinality of finite bags. 
	  </li>
	</ul>
      </li>
      <li><i>Sum aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>sum{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>sum</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>sum</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate. The function <tt>sum</tt> must compute summations of the elements of finite bags. (For decimals, integers, floats, etc., summation must coincide with the usual notion. However, this function might also be defined for other domains in some dialects.)
	  </li>
	</ul>
      </li>
      <li><i>Prod aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>prod{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>prod</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>prod</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate. The function <tt>prod</tt> must compute products of the elements of finite bags. (For decimals, integers, floats, etc., product must coincide with the usual notion. However, this function might also be defined for other domains.)
	  </li>
	</ul>
      </li>
      <li><i>Avg aggregate</i>:
	<ul>
	  <li>	
	    <i><b>I</b></i>(<tt>avg{?X [?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>] | &tau;}</tt>) = <tt>avg</tt>(<span style="text-decoration: overline"><i>S</i></span><sub>bag</sub>), if the function <tt>avg</tt> is defined for <span style="text-decoration: overline"><i>S</i></span><sub>bag</sub> in the dialect. If not, the value of the aggregate in <i><b>I</b></i> is indeterminate. The function <tt>avg</tt> must compute averages (arithmetic means) of the elements of finite bags. (For decimals, integers, floats, etc., average must coincide with the usual notion. However, this function might also be defined for other domains.)
	  </li>
	</ul>
      </li>
    </ol>
  </li>
  <li>    
     For remote terms of the form <tt>&phi;@r</tt>, the mapping <i><b>I</b></i> is defined in Section <a href="#sec-interpretation-of-documents" title="">Interpretation of Documents</a>.
  </li>
</ol>
<p><br />
Note that the definitions of <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>frame</sub>, and of <i><b>I</b></i>(<tt>x=y</tt>) imply that the terms with named arguments that differ only in the order of their arguments are mapped by <i><b>I</b></i> to the same element in the domain. Similarly, frame terms that differ only in the order of their attribute/value pairs (or in the number of repetitions of the same attribute/value pair) are mapped to the same domain element. This implies that the equalities like <tt>t(a-&gt;1 b-&gt;2 c-&gt;3) = t(c-&gt;3 a-&gt;1 b-&gt;2)</tt> and <tt>ex:o[ex:a-&gt;1 ex:b-&gt;"abc" ex:a-&gt;1] = ex:o[ex:b-&gt;"abc" ex:a-&gt;1]</tt> are tautologies in RIF-FLD.
</p><p><span class="anchor" id="the-effect-of-signatures"></span>
<i><b>The effect of signatures.</b></i> For every signature, <tt>sg</tt>, supported by a dialect, there is a subset <i><b>D</b></i><sub>sg</sub> &sube; <i><b>D</b></i>, called the <i><b>domain of the signature</b></i>. Terms that have a given signature, <tt>sg</tt>, must be mapped by <i><b>I</b></i> to <i><b>D</b></i><sub>sg</sub>, and if a term has more than one signature it must be mapped into the intersection of the corresponding signature domains. To ensure this, the following is required: 
</p>
<ol><li> If <tt>sg&nbsp;&lt;&nbsp;sg'</tt> then <i><b>D</b></i><sub>sg</sub>&sube;<i><b>D</b></i><sub>sg'</sub>. 
</li><li> If <tt>k</tt> is a constant that has signature <tt>sg</tt> then <i><b>I</b></i><sub>C</sub>(<tt>k</tt>) &isin; <i><b>D</b></i><sub>sg</sub>. 
</li><li> If <tt>?v</tt> is a variable that has signature <tt>sg</tt> then <i><b>I</b></i><sub>V</sub>(<tt>?v</tt>) &isin; <i><b>D</b></i><sub>sg</sub>. 
</li><li> If <tt>sg</tt> has an arrow expression of the form (<tt>s1</tt> ... <tt>sn</tt>)&rArr;<tt>s</tt> then, for every <tt>d</tt>&isin;<i><b>D</b></i><sub>sg</sub>, <i><b>I</b></i><sub>F</sub>(<tt>d</tt>) must map <i><b>D</b></i><sub>s1</sub>&times; ... &times;<i><b>D</b></i><sub>sn</sub> to <i><b>D</b></i><sub>s</sub>. 
</li><li> If <tt>sg</tt> has an arrow expression of the form (<tt>p1-&gt;s1</tt> ... <tt>pn-&gt;sn</tt>)&rArr;<tt>s</tt> then, for every <tt>d</tt>&isin;<i><b>D</b></i><sub>sg</sub>, <i><b>I</b></i><sub>NF</sub>(<tt>d</tt>) must map the set {&lt;<tt>p1</tt>,<i><b>D</b></i><sub>s1</sub>&gt;, ..., &lt;<tt>pn</tt>,<i><b>D</b></i><sub>sn</sub>&gt;} to <i><b>D</b></i><sub>s</sub>. 
</li><li> If the signature <tt>-&gt;</tt> has arrow expressions <tt>(sg,s<sub>1</sub>,r<sub>1</sub>)&rArr;k</tt>, ..., <tt>(sg,s<sub>n</sub>,r<sub>n</sub>)&rArr;k</tt>, then, for every <tt>d</tt>&isin;<i><b>D</b></i><sub>sg</sub>, <i><b>I</b></i><sub>frame</sub>(<tt>d</tt>) must map {&lt;<i><b>D</b></i><sub>s1</sub>,<i><b>D</b></i><sub>r1</sub>&gt;, ..., &lt;<i><b>D</b></i><sub>sn</sub>,<i><b>D</b></i><sub>rn</sub>&gt;} to <i><b>D</b></i><sub>k</sub>. 
</li><li> If the signature <tt>#</tt> has an arrow expression <tt>(s r)&rArr;k</tt> then <i><b>I</b></i><sub>isa</sub> must map <i><b>D</b></i><sub>s</sub>&times;<i><b>D</b></i><sub>r</sub> to <i><b>D</b></i><sub>k</sub>. 
</li><li> If the signature <tt>##</tt> has an arrow expression <tt>(s s)&rArr;k</tt> then <i><b>I</b></i><sub>sub</sub> must map <i><b>D</b></i><sub>s</sub>&times;<i><b>D</b></i><sub>s</sub> to <i><b>D</b></i><sub>k</sub>. 
</li><li> If the signature <tt>=</tt> has an arrow expression <tt>(s s)&rArr;k</tt> then <i><b>I</b></i><sub>=</sub> must map <i><b>D</b></i><sub>s</sub>&times;<i><b>D</b></i><sub>s</sub> to <i><b>D</b></i><sub>k</sub>. 
</li></ol>
<p><i><b>The effect of datatypes.</b></i> The datatype identifiers in <i><b>DTS</b></i> impose the following restrictions. If <tt>dt</tt> &isin; <i><b>DTS</b></i>, let <i><b>LS</b></i><sub>dt</sub> denote the lexical space of <tt>dt</tt>, <i><b>VS</b></i><sub>dt</sub> denote its value space, and <i><b>L</b></i><sub>dt</sub>: <i><b>LS</b></i><sub>dt</sub> &rarr; <i><b>VS</b></i><sub>dt</sub> the lexical-to-value-space mapping. Then the following must hold: 
</p>
<ul><li> <i><b>VS</b></i><sub>dt</sub> &sube; <i><b>D</b></i>; and
</li><li> For each constant <tt>"lit"^^dt</tt> such that <tt>lit</tt> &isin; <i><b>LS</b></i><sub>dt</sub>, <i><b>I</b></i><sub>C</sub>(<tt>"lit"^^dt</tt>) = <i><b>L</b></i><sub>dt</sub>(<tt>lit</tt>). 
</li></ul>
<p>That is, <i><b>I</b></i><sub>C</sub> must map the constants of a datatype <tt>dt</tt> in accordance with <i><b>L</b></i><sub>dt</sub>.  &nbsp;&nbsp;☐
</p><p>RIF-FLD does not impose special requirements on <i><b>I</b></i><sub>C</sub> for constants in the symbol spaces that do not correspond to the identifiers of the datatypes in <i><b>DTS</b></i>. Dialects may have such requirements, however. An example of such a restriction could be a requirement that no constant in a particular symbol space (such as <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt>) can be mapped to <i><b>VS</b></i><sub>dt</sub> of a datatype <tt>dt</tt>. 
</p><p><br />
</p><p><span class="anchor" id="sec-semantics-metadata"></span>
</p>
<a id="Annotations_and_the_Formal_Semantics" name="Annotations_and_the_Formal_Semantics"></a><h4> <span class="mw-headline">3.5  Annotations and the Formal Semantics </span></h4>
<p>RIF-FLD annotations are stripped before the mappings that constitute RIF-FLD semantic structures are applied. Likewise, they are stripped before applying the truth valuation, <i>TVal</i><sub>I</sub>, defined in the next section. Thus, identifiers and metadata have no effect on the formal semantics.
</p><p>Note that although annotations associated with RIF-FLD formulas are ignored by the semantics, they can be extracted by XML tools. Since annotations are represented by frame terms, they can be reasoned with by the rules.
The frame terms used to represent metadata can then be fed to other formulas, thus enabling reasoning about metadata. However, RIF does not define any concrete semantics for metadata.
</p><p><br />
</p><p><span class="anchor" id="sec-interpretation-of-formulas"></span>
</p>
<a id="Interpretation_of_Non-document_Formulas" name="Interpretation_of_Non-document_Formulas"></a><h4> <span class="mw-headline">3.6  Interpretation of Non-document Formulas </span></h4>
<p>This section defines how a semantic structure, <i><b>I</b></i>, determines
the truth value <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>)  of a RIF-FLD formula, <tt>&phi;</tt>, where <tt>&phi;</tt> is any formula other than a document formula or a remote formula. Truth valuation of document formulas is defined in the next section.
</p><p>To this end, we define a mapping, <i>TVal</i><sub>I</sub>, from the set of all non-document formulas to <i><b>TV</b></i>. Note that the definition implies that <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) is defined <em>only if</em>   the set <i><b>DTS</b></i> of the datatypes of <i><b>I</b></i> includes all the datatypes mentioned in <tt>&phi;</tt>. 
</p><p><br />
</p><p><span class="anchor" id="def-fld-truth"></span> 
<b>Definition (Truth valuation).</b>
<i><b>Truth valuation</b></i> for well-formed formulas in RIF-FLD is determined using the following function, denoted <i>TVal</i><sub>I</sub>:
</p>
<ol>
  <li><i>Constants</i>: <i>TVal</i><sub>I</sub>(<tt>k</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>k</tt>)), if <tt>k</tt> &isin; <tt>Const</tt>. </li>
  <li><i>Variables</i>: <i>TVal</i><sub>I</sub>(<tt>?v</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>?v</tt>)), if <tt>?v</tt> &isin; <tt>Var</tt>. </li>
  <li><i>Positional atomic formulas</i>: <i>TVal</i><sub>I</sub>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>)).</li>
  <li><i>Atomic formulas with named arguments</i>: <i>TVal</i><sub>I</sub>(<tt>p(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>p(s<sub>1</sub>-&gt;&nbsp;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>)).</li>
  <li><i>Equality</i>: <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)).
    <p>To ensure that equality has precisely the expected properties, it is required that
    </p>
    <ul>
      <li>
	<i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>t</b> if <i><b>I</b></i>(<tt>x</tt>) = <i><b>I</b></i>(<tt>y</tt>) and  <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>f</b> otherwise.
      </li>
    </ul>
  </li>
  <li><i>Subclass</i>: <i>TVal</i><sub>I</sub>(<tt>sc&nbsp;##&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>sc&nbsp;##&nbsp;cl</tt>)).
    <p>
      To ensure that the operator <tt>##</tt> is transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>, the following is required:
    </p>
    <ul>    
      <li>
	For all well-formed terms <tt>c1</tt>, <tt>c2</tt>, <tt>c3</tt>: &nbsp; glb<sub>t</sub>(<i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c2</tt>), <i>TVal</i><sub>I</sub>(<tt>c2&nbsp;##&nbsp;c3</tt>))&nbsp; &le;<sub>t</sub>&nbsp; <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c3</tt>).
      </li>
    </ul>
    <p>
      Note that this is a restriction on <i><b>I</b></i><sub>truth</sub> and the mapping <i><b>I</b></i>, which is expressed in a more succinct form using <i>TVal</i><sub>I</sub>.
    </p> 
  </li>
  <li><i>Membership</i>: <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o&nbsp;#&nbsp;cl</tt>)).
    <p>To ensure that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> imply <tt>o&nbsp;#&nbsp;scl</tt>, the following is required:
    </p>
    <ul>
      <li>
        For all well-formed terms <tt>o</tt>, <tt>cl</tt>, <tt>scl</tt>:  &nbsp; glb<sub>t</sub>(<i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>), <i>TVal</i><sub>I</sub>(<tt>cl&nbsp;##&nbsp;scl</tt>))&nbsp; &le;<sub>t</sub>&nbsp; <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;scl</tt>).
      </li>
    </ul>
    <p>
      Note that this is a restriction on <i><b>I</b></i><sub>truth</sub> and the mapping <i><b>I</b></i>, which is expressed in a more succinct form using <i>TVal</i><sub>I</sub>.
    </p> 
  </li>
  <li><i>Frame</i>: <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>)).
    <p>
      Since the bag of attribute/value pairs represents the conjunction of all the pairs, the following is required:
    </p>
    <ul>
      <li>
        <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = glb<sub>t</sub>(<i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub>]</tt>), ..., <i>TVal</i><sub>I</sub>(<tt>o[a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>)).
      </li>
    </ul>
    <p>
      Observe that this is a restriction on <i><b>I</b></i><sub>truth</sub> and the mapping <i><b>I</b></i>. For brevity, it is expressed in a more succinct form using <i>TVal</i><sub>I</sub>.
    </p> 
  </li>
  <li>
    <i>Externally defined atomic formula</i>: <i>TVal</i><sub>I</sub>(<tt>External(t loc)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>))), if <tt>External(t loc)</tt> is an atomic formula that is an instantiation of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>; &tau;; loc)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>n</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t loc)</tt> is well-formed only if it is an instantiation of an external schema. Furthermore, by the <a href="#def-fld-external-schema-set" title="">definition of coherent sets of external schemas</a>, it can be an instantiation of at most one external schema, so <i><b>I</b></i>(<tt>External(t loc)</tt>) is well-defined.
    </p>
  </li>
  <li>
    <i>Connectives and quantifiers</i>: if <tt>S</tt> is a connective or a quantifier and <tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a well-formed formula term then <i>TVal</i><sub>I</sub>(<tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt>) =
    <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>S(t<sub>1</sub> ... t<sub>n</sub>)</tt>)).
    <p>
       To ensure the intended semantics for the RIF-FLD reserved connectives and quantifiers, the following restrictions are imposed
      (observe that all these are restrictions on <i><b>I</b></i><sub>truth</sub> and the mapping <i><b>I</b></i>, which are expressed via <i>TVal</i><sub>I</sub>, for brevity):
    </p>
    <ol style="list-style-type:lower-alpha">
      <li>
        <i>Conjunction</i>: <i>TVal</i><sub>I</sub>(<tt>And(c<sub>1</sub> ... c<sub>n</sub>)</tt>) = glb<sub>t</sub>(<i>TVal</i><sub>I</sub>(<tt>c<sub>1</sub></tt>), ..., <i>TVal</i><sub>I</sub>(<tt>c<sub>n</sub></tt>)).
        <p>
          The empty conjunction is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>And()</tt>) = <b>t</b>.
        </p>
      </li>
      <li>
        <i>Disjunction</i>: <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = lub<sub>t</sub>(<i>TVal</i><sub>I</sub>(c<sub>1</sub>), ..., <i>TVal</i><sub>I</sub>(c<sub>n</sub>)).
        <p>
          The empty disjunction is treated as a contradiction, so <i>TVal</i><sub>I</sub>(<tt>Or()</tt>) = <b>f</b>.
        </p>
      </li>
      <li><i>Negation</i>: <i>TVal</i><sub>I</sub>(<tt>Neg Neg &phi;</tt>) = <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) and <i>TVal</i><sub>I</sub>(<tt>Naf &phi;</tt>) = <tt>~</tt><i>TVal</i><sub>I</sub>(<tt>&phi;</tt>).
        <p>The symbol <tt>~</tt> here is the self-inverse operator of negation on <i><b>TV</b></i> introduced in Section <a href="#sec-truth-values" title="">Truth Values</a>.
        </p>
        <p>
          The symmetric negation, <tt>Neg</tt>, is sufficiently general to capture many different kinds of such negation. For instance, classical negation would, in addition, require <i>TVal</i><sub>I</sub>(<tt>Neg &phi;</tt>) = <tt>~</tt><i>TVal</i><sub>I</sub>(<tt>&phi;</tt>); strong negation (analogous to the one in [<a href="#ref-strong-explicit-negation" title="">APP96</a>]) can be characterized by <i>TVal</i><sub>I</sub>(<tt>Neg &phi;</tt>) &le;<sub>t</sub> <tt>~</tt><i>TVal</i><sub>I</sub>(<tt>&phi;</tt>); and explicit negation (analogous to [<a href="#ref-strong-explicit-negation" title="">APP96</a>]) would require no additional constraints.
        </p>
        <p>
          Note that both classical and default negation are interpreted the same way in any concrete semantic structure. The difference between the two kinds of negation comes into play when logical entailment is defined.
        </p>
      </li>
      <li><i>Quantification</i>:
        <ul>
          <li><i>TVal</i><sub>I</sub>(<tt>Exists&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (&phi;)</tt>) = lub<sub>t</sub>(<i>TVal</i><sub>I*</sub>(<tt>&phi;</tt>)).
          </li>
          <li><i>TVal</i><sub>I</sub>(<tt>Forall&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (&phi;)</tt>) = glb<sub>t</sub>(<i>TVal</i><sub>I*</sub>(<tt>&phi;</tt>)).
          </li>
        </ul>
        <p>
          Here lub<sub>t</sub> (respectively, glb<sub>t</sub>) is taken over all interpretations <i><b>I</b></i>* of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i>*<sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>connective</sub>, <i><b>I</b></i><sub>truth</sub>&gt;, which are exactly like <i><b>I</b></i>, except that the mapping <i><b>I</b></i>*<sub>V</sub>, is used instead of <i><b>I</b></i><sub>V</sub>. &nbsp; <i><b>I</b></i>*<sub>V</sub> is defined to coincide with <i><b>I</b></i><sub>V</sub> on all variables except, possibly, on <tt>?v<sub>1</sub></tt>,... ,<tt>?v<sub>n</sub></tt>. 
        </p>
      </li>
      <li><i>Rule implication</i>:
        <ul>
          <li><i>TVal</i><sub>I</sub>(<i>head</i>&nbsp;:- <i>body</i>) = <b>t</b>, if <i>TVal</i><sub>I</sub>(<i>head</i>) &ge;<sub>t</sub> <i>TVal</i><sub>I</sub>(<i>body</i>).
          </li>
          <li>
	    <i>TVal</i><sub>I</sub>(<i>head</i>&nbsp;:- <i>body</i>) &lt;<sub>t</sub> <b>t</b> &nbsp; otherwise.
          </li>
        </ul>
      </li>
      <li><i>Constraint</i>:
        <ul>
          <li><i>TVal</i><sub>I</sub>(:- <i>body</i>) = <b>t</b>, if  <i>TVal</i><sub>I</sub>(<i>body</i>) = <b>f</b>.
          </li>
          <li>
	    <i>TVal</i><sub>I</sub>(:- <i>body</i>) &lt;<sub>t</sub> <b>t</b> &nbsp; otherwise.
          </li>
        </ul>
      </li>
      <li>      
	 Dialects that introduce additional connectives and quantifiers should define appropriate restrictions on <i>TVal</i><sub>I</sub> to give those new elements desired semantics.
      </li>
    </ol>
  </li>
  <li><i>Groups of formulas</i>:
    <p>
       If <tt>&Gamma;</tt> is a group formula of the form  <tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt> then
    </p>
    <ul>       
      <li>
       <i>TVal</i><sub>I</sub>(<tt>&Gamma;</tt>) = glb<sub>t</sub>(<i>TVal</i><sub>I</sub>(<tt>&phi;<sub>1</sub></tt>), ..., <i>TVal</i><sub>I</sub>(<tt>&phi;<sub>n</sub></tt>)).
      </li>
    </ul>
    <p>
       This means that a group of formulas is treated as a conjunction. In particular, the empty group is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>Group()</tt>) = <b>t</b>. &nbsp;&nbsp;☐
    </p>
  </li>
</ol>
<p>
  Note that rule implications and equality formulas are always two-valued, even if <i><b>TV</b></i> has more than two values. 
</p>
<p><br />
</p><p><span class="anchor" id="sec-interpretation-of-documents"></span>
</p>
<a id="Interpretation_of_Documents" name="Interpretation_of_Documents"></a><h4> <span class="mw-headline">3.7  Interpretation of Documents </span></h4>
<p>Document formulas are interpreted using <i>semantic multi-structures</i>, which are
sets of semantic structures. Their purpose is to provide a semantics to RIF multi-documents, i.e., RIF documents that import other RIF documents and/or contain references to other RIF documents via remote module reference formulas.
</p><p><br />
<span class="anchor" id="def-fld-semantic-imported-doc"></span> 
<b>Definition (Imported document).</b>
Let <tt>&Delta;</tt> be a document formula and <tt>Import(<i>loc</i>)</tt> be one of its import directives, where <i>loc</i> is a locator of another document formula, <tt>&Delta;'</tt>.  In this case, we say that <tt>&Delta;'</tt> is <i><b>directly imported</b></i> into <tt>&Delta;</tt>.
</p><p>A document formula <tt>&Delta;'</tt> is said to be <i><b>imported</b></i> into
<tt>&Delta;</tt> if it is either directly imported into <tt>&Delta;</tt> or it is imported (directly or not) into another document, which itself is directly imported into <tt>&Delta;</tt>.
&nbsp; &nbsp; ☐
</p><p>The above definition deals only with one-argument import directives, since two-argument directives are expected to be defined on a case-by-case basis by other specifications that might be integrated with RIF. For instance, [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] defines the semantics of the 2-argument import directive for importing RDF and OWL documents into RIF-BLD.
</p><p><span class="anchor" id="def-fld-renaming-apart"></span> 
<b>Definition (Renaming apart of local constants).</b>
A <i><b>renaming mapping</b></i>, &rho;, is a function that maps document formulas to document formulas subject to the following restriction:
</p>
<ul>
  <li>
    If &rho;(<tt>&Delta;</tt>) = <tt>&Delta;'</tt> then <tt>&Delta;'</tt> is exactly like <tt>&Delta;</tt> except that all occurrences of some <tt>rif:local</tt> constants in <tt>&Delta;</tt> may be consistently renamed into other <tt>rif:local</tt> constants.
<br />
By consistent renaming here we mean that different occurrences of the same <tt>rif:local</tt> constant in <tt>&Delta;</tt> are renamed identically. 
&nbsp; &nbsp; &nbsp; &nbsp; ☐ 
  </li>
</ul>
<p><span class="anchor" id="def-fld-semantic-multistruct"></span> 
<b>Definition (Semantic multi-structure).</b>
A <i><b>semantic multi-structure</b></i>, <b>&Icirc;</b>, is a triple (<b>&Icirc;</b><sub>ren</sub>,<b>&Icirc;</b><sub>map</sub>,<b>&Icirc;</b><sub>set</sub>) where
</p>
<ul>
  <li>
     <b>&Icirc;</b><sub>ren</sub> is a renaming mapping;
  </li>
  <li>  
     <b>&Icirc;</b><sub>set</sub> is a set of <i>adorned</i> semantic structures of the form {<i><b>I</b></i><sup><tt>m<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>m<sub>2</sub></tt></sup>, ...}, where the adornments <tt>m<sub>1</sub></tt>, <tt>m<sub>2</sub></tt>, ... are elements in the interpretation domain (explained below);
  </li>
  <li>  
     <b>&Icirc;</b><sub>map</sub> is a <i><b>modularization mapping</b></i>. It is a function from the set of all documents in the language to the powerset of <b>&Icirc;</b><sub>set</sub>. 
     <br />
     That is, if <tt>&Delta;</tt> is a document then <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>) &sube; <b>&Icirc;</b><sub>set</sub> (<b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>) can be empty).
  </li>
</ul>
<p>All these mappings are subject to the following restrictions:
</p>
<ul>
  <li>  
     All semantic structures in <b>&Icirc;</b><sub>set</sub> have the same domain and the mappings <i><b>I</b></i><sup><tt>m<sub>1</sub></tt></sup><sub>C</sub>, <i><b>I</b></i><sup><tt>m<sub>2</sub></tt></sup><sub>C</sub>, ... are all the same. We will denote this mapping by <b>&Icirc;</b><sub>C</sub> and the common domain will be called <i>the domain of</i> <b>&Icirc;</b>.
     <br />
     Note that this implies that if <tt>t</tt> is a <i>ground</i> (i.e., variable-free) term then <i><b>I</b></i><sup><tt>m<sub>1</sub></tt></sup>(<tt>t</tt>) = <i><b>I</b></i><sup><tt>m<sub>2</sub></tt></sup>(<tt>t</tt>) = ..., and so we can write <b>&Icirc;</b>(<tt>t</tt>) without ambiguity.
  </li>
  <li>
     The adornments <tt>m<sub>1</sub></tt>, <tt>m<sub>2</sub></tt>, ... are elements in the domain of <b>&Icirc;</b> and <b>&Icirc;</b><sub>set</sub> can have at most one semantic structure with a given adornment.
     <br />
     Intuitively, the adornments represent module names and thus <i><b>I</b></i><sup><tt>m<sub>i</sub></tt></sup> is to be understood as the semantic structure for interpreting the documents associated with module <tt>m<sub>i</sub></tt>.
  </li>
  <li>  
    If one document, <tt>&Delta;</tt>, imports another document, <tt>&Delta;'</tt>, either directly or indirectly then <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>) &sube; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;'</tt>).
    <br />
      That is, if a super-document is associated with some module then its imported documents are also associated with that module. However, the imported document can be associated with other modules as well.
  </li>
  <li>  
     If  <tt>Module(<i>n</i> <i>loc</i>)</tt> appears in some document, where <i>loc</i> is a locator for another document, <tt>&Delta;</tt>, then
     <ul>     
       <li>       
	 <i><b>I</b></i><sup><b>&Icirc;</b>(<tt><i>n</i></tt>)</sup> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>)  (&sube; <b>&Icirc;</b><sub>set</sub>).
<br />
Thus, in this case, <b>&Icirc;</b>(<tt><i>n</i></tt>) must adorn one (and only one) semantic structure in <b>&Icirc;</b><sub>set</sub>.
       </li>
     </ul>
<p>Intuitively, these conditions say that if some document associates <tt>&Delta;</tt> with a particular module then <b>&Icirc;</b><sub>map</sub> must respect that. Note that different directives <tt>Module(<i>n</i> <i>loc</i><sub>1</sub>)</tt>, ..., <tt>Module(<i>n</i> <i>loc</i><sub>k</sub>)</tt> (with different locators but the same module name) have the effect that multiple documents become associated with the same module and the same semantic structure. This association happens through the <tt>Module</tt> directives that occur inside the same or different documents. The semantic effect is that all these associated document formulas are true in that module.
&nbsp; &nbsp; ☐
</p>
  </li>
</ul>
<p><span class="anchor" id="def-semantic-linked-doc"></span> 
<b>Definition (Remote module).</b>
Let <tt>&Delta;</tt> be a document formula and let <tt>Module(<i>n</i> <i>loc</i>)</tt> be one of its remote module directives, where <i>loc</i> is a locator for another document formula, <tt>&Delta;'</tt>.  In this case, we say that <tt>&Delta;'</tt> is a <i><b>directly linked remote module</b></i> of <tt>&Delta;</tt>.
</p><p>A document formula <tt>&Delta;'</tt> is said to be a <i><b>linked remote module</b></i> for <tt>&Delta;</tt> if it is either directly linked to <tt>&Delta;</tt> or it is linked (directly or not) to some other document that is either imported into or directly linked to <tt>&Delta;</tt>.
&nbsp; &nbsp; ☐
</p><p><br />
</p>
<p>
In <a href="#def-term-interpreting-map" title="">the definition of term-interpreting mappings</a>, we postponed defining remote term references till now. The next definitions fill in this gap. The reason why we postponed this definition was that this could not be defined solely in reference to a single semantic structure <i><b>I</b></i>: a multi-structure context is required in addition to <i><b>I</b></i>. This leads us to <i>TVal</i><sub><i><b>I</b></i>/<b>&Icirc;</b></sub>(<tt>&phi;</tt>), the notion of truth valuation in the context of a semantic multi-structure <b>&Icirc;</b>.
</p>
<p><span class="anchor" id="def-term-interp-map-module"></span> 
<b>Definition (Term-interpreting mapping for remote term references).</b>
Let <tt>&phi;</tt> be a non-document formula, <b>&Icirc;</b> a semantic multi-structure, and <i><b>I</b></i> &isin; <b>&Icirc;</b><sub>set</sub>.
</p><p>First we define <i><b>I</b></i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>), the term-interpreting function for <i><b>I</b></i> in the context of a multi-structure, <b>&Icirc;</b>. For terms that are <i>not</i> remote references, the definition is exactly as for <a href="#def-term-interpreting-map" title="">term-interpreting mappings for ordinary semantic structures</a> with the difference that <i><b>I</b></i><sub><b>&Icirc;</b></sub> is used everywhere instead of just <i><b>I</b></i>. The definition of <i>TVal</i><sub><i><b>I</b></i>/<b>&Icirc;</b></sub>(<tt>&phi;</tt>), the truth valuation in the context of  <b>&Icirc;</b>, is the same as <a href="#def-fld-truth" title="">the definition of <i>TVal</i> for ordinary semantic structures</a> in this case.
</p><p>However, if <tt>&phi;</tt>  <i>is</i> a remote reference <tt>&psi;@r</tt> then <i><b>I</b></i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) is defined as follows:
</p>
  <p>  
    Let <i><b>I</b></i>(<tt>r</tt>) = <tt>d</tt>.  If <b>&Icirc;</b><sub>set</sub> has <i>no</i> semantic structure adorned with <tt>d</tt>, the value of <i><b>I</b></i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) is indeterminate (i.e., it can be any element of the domain of <b>&Icirc;</b>). Otherwise, let <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>set</sub> be the structure adorned with <tt>d</tt> (it is then unique, by definition). In that case, we define:
  </p>
  <ul>  
    <li>    
    <i><b>I</b></i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) to be <i><b>J</b></i><sub><b>&Icirc;</b></sub>(<tt>&psi;</tt>)
    </li>
    <li>
       <i>TVal</i><sub><i><b>I</b></i>/<b>&Icirc;</b></sub>(<tt>&phi;</tt>) =
       <i><b>J</b></i><sub>truth</sub>(<i><b>I</b></i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>)) 
&nbsp; &nbsp; ☐
    </li>
  </ul>
<p><br />
We now define how truth of  document formulas is determined in semantic multi-structures.
</p><p><span class="anchor" id="def-fld-truth-documents"></span> 
<b>Definition (Truth valuation of formulas in multi-document structures).</b>
Let <tt>&Delta;</tt> be a document formula and let 
<tt>&Delta;</tt><sub>1</sub>, ..., <tt>&Delta;</tt><sub>n</sub>, ... be all the RIF-FLD document formulas that are <i>imported</i> into <tt>&Delta;</tt> or linked to it (directly or indirectly).
Let furthermore <tt>&Gamma;</tt>, <tt>&Gamma;<sub>1</sub></tt>, ..., <tt>&Gamma;<sub>n</sub></tt>, ... be the respective group formulas <a href="#def-associated-group" title="">associated</a> with these documents.
Let <b>&Icirc;</b> = (<b>&Icirc;</b><sub>ren</sub>,<b>&Icirc;</b><sub>map</sub>,<b>&Icirc;</b><sub>set</sub>) be a semantic multi-structure where <b>&Icirc;</b><sub>set</sub> = {<i><b>I</b></i><sup><tt>m<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>m<sub>2</sub></tt></sup>, ...}.
</p><p>We define the truth valuation for <tt>&Delta;</tt> as follows.
</p>
<ul>       
  <li>
    <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&Delta;</tt>)&nbsp; =&nbsp; glb<sub>t</sub>{&nbsp;glb<sub>t</sub>{<i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;</tt>)) | <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>)},&nbsp; glb<sub>t</sub>{<i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;</tt><sub>1</sub>)) | <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt><sub>1</sub>)},&nbsp; ...,&nbsp; glb<sub>t</sub>{<i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;</tt><sub>n</sub>)) | <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt><sub>n</sub>)},&nbsp; ...&nbsp;}.
  </li>
</ul>
<p>Observe that, before computing truth values, documents' <tt>rif:local</tt> constants may be renamed. 
&nbsp; &nbsp; &nbsp; &nbsp; ☐  
</p><p><br />
It is instructive to see how remote terms are interpreted by a semantic multi-structure <b>&Icirc;</b>. Suppose <tt>&psi;@r</tt> is such a term that occurs somewhere in a document, <tt>&Delta;</tt>.  If <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&Delta;</tt>) is an ordinary semantic structure assigned to <tt>&Delta;</tt> then <i><b>J</b></i>(<tt>r</tt>)  determines the semantic structure in which <tt>&psi;</tt> is to be evaluated: it is the structure in <b>&Icirc;</b><sub>set</sub> adorned with <i><b>J</b></i>(<tt>r</tt>), say <i><b>M</b></i>. This is what <i><b>J</b></i><sub><b>&Icirc;</b></sub>(<tt>&psi;@r</tt>) is all about.  Note that <tt>&psi;</tt> may also contain remote term references (as <tt>&psi;</tt> may be a compound formula). In this case, since <tt>&psi;</tt> is evaluated using <i><b>M</b></i><sub><b>&Icirc;</b></sub>, the same principle applies.
</p><p><br />
</p><p><span class="anchor" id="def-fld-model-formula"></span> 
<b>Definition (Models).</b>
Let <i><b>I</b></i> be a semantic structure or a multi-structure. We say that
<i><b>I</b></i> is a <i><b>model</b></i> of a formula, <tt>&phi;</tt>, written as <i><b>I</b></i><tt>|=&phi;</tt>, iff <i>TVal</i><sub><i><b>I</b></i></sub>(<tt>&phi;</tt>) = <b>t</b>.
Here <tt>&phi;</tt> is a document formula, if <i><b>I</b></i> is a multi-structure, and a non-document formula, if <i><b>I'</b></i> is an ordinary semantic structure.
&nbsp; &nbsp; ☐
</p><p><br />
<span class="anchor" id="sec-intended-models"></span>
</p>
<a id="Intended_Semantic_Structures" name="Intended_Semantic_Structures"></a><h4> <span class="mw-headline">3.8  Intended Semantic Structures </span></h4>
<p>The <i><b>semantics of a set of formulas</b></i>, <tt>&Gamma;</tt>,  is the set of its <i><b>intended</b></i> (or <i><b>preferred</b></i>) <i><b>semantic multi-structures</b></i>. Intended multi-structures are used to define the notion of logical entailment in RIF dialects. RIF-FLD does not fix what these intended multi-structures should be, leaving the choice to RIF dialects. Different logic dialects may use different criteria for what is to be considered an intended semantic multi-structure, and the freedom to set these criteria lets RIF-FLD cover a wide range of possible logical semantics. The actual choice of intended models for this or that logic dialect is a prerogative of the dialect designer and should be attempted only by a trained logician.
</p><p>For instance, to model the classical first-order notion of entailment, every semantic structure would be intended. For [<a href="#ref-rif-bld" title="">RIF-BLD</a>], which is based on Horn rules, intended multi-structures are defined only for sets of rules: an intended semantic multi-structure of a RIF-BLD set of formulas, <tt>&Gamma;</tt>, is the unique <a href="#def-minimal-model" title="">minimal Herbrand model</a> [<a href="#ref-lloyd-87" title="">Lloyd87</a>] of <tt>&Gamma;</tt>. For dialects in which rule bodies may contain literals negated with the default negation connective <tt>Naf</tt>, only <i>some</i> of the minimal Herbrand models of <tt>&Gamma;</tt> are intended. Each logic dialect of RIF must define the set of intended semantic multi-structures precisely. The two most common theories for default negation use the <i><b>well-founded models</b></i> [<a href="#ref-wf-model" title="">GRS91</a>] and <i><b>stable models</b></i> [<a href="#ref-stable-model" title="">GL88</a>] as their intended models. 
</p><p>The following example illustrates the notion of intended semantic structures. Suppose <tt>&Gamma;</tt> consists of a single rule formula <tt>p&nbsp;:-&nbsp;Naf&nbsp;q</tt>. If <tt>Naf</tt> were interpreted as classical negation, then this rule would be simply equivalent to <tt>Or(p q)</tt>, and so it would have two kinds of models: those where <tt>p</tt> is true and those where <tt>q</tt> is true. In contrast to first-order logic, most rule-based systems do not consider <tt>p</tt> and <tt>q</tt> symmetrically. Instead, they view the rule <tt>p&nbsp;:-&nbsp;Naf&nbsp;q</tt> as a statement that <tt>p</tt> must be true if it is not possible to establish the truth of <tt>q</tt>. Since it is, indeed, impossible to establish the truth of <tt>q</tt>, such theories would derive <tt>p</tt> even though it does not logically follow from <tt>Or(p q)</tt>. The logic underlying rule-based systems also assumes that only the <i>minimal</i> Herbrand models are intended (minimality here is with respect to the set of true facts). Furthermore, although our example has two minimal Herbrand models -- one where <tt>p</tt> is true and <tt>q</tt> is false, and the other where <tt>p</tt> is false, but <tt>q</tt> is true, only the first model is considered to be intended. 
</p><p>The above concept of intended semantic multi-structures and the corresponding notion of logical entailment, below, is due to [<a href="#ref-shoham-87" title="">Shoham87</a>] (where these structures were called <i>preferred</i>). 
</p><p><br />
<span class="anchor" id="sec-logical-entailment"></span> 
</p>
<a id="Logical_Entailment" name="Logical_Entailment"></a><h4> <span class="mw-headline">3.9  Logical Entailment </span></h4>
<p>We will now define what it means for one RIF-FLD formula to entail another. This notion is typically used for defining queries to knowledge bases and for other tasks, such as testing subsumption of concepts (e.g., in OWL). We assume that each set of formulas has an associated set of intended semantic structures (which depend on RIF dialects). 
</p><p><br />
<span class="anchor" id="def-fld-entailment"></span> 
<b>Definition (Logical entailment).</b>
Let <tt>&phi;</tt> and <tt>&psi;</tt> be RIF-FLD formulas. We say that <tt>&phi;</tt> <i><b>entails</b></i> <tt>&psi;</tt>,  written as <tt>&phi;&nbsp;|=&nbsp;&psi;</tt>, if and only if the following holds:
</p>
<ul>
  <li>
     <tt>&phi;</tt> <i>and</i> <tt>&psi;</tt> <i>are both document formulas</i>:
     <br />
     for every intended semantic multi-structure <b>&Icirc;</b> it is the case that <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) &le;<sub>t</sub> <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&psi;</tt>).
  </li>
  <li>  
    <tt>&phi;</tt> <i>and</i> <tt>&psi;</tt> <i>are both non-document formulas</i>:
    <br />
     for every intended semantic multi-structure <b>&Icirc;</b> and for every <i><b>J</b></i> &isin; <b>&Icirc;</b> it is the case that <i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<tt>&phi;</tt>) &le;<sub>t</sub> <i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<tt>&psi;</tt>).
    <br />
    Intuitively, this means that <tt>&phi;</tt> must entail <tt>&psi;</tt> in any module the two formulas might happen to be.
  </li>
  <li>  
     <tt>&phi;</tt> <i>is a document formula, but</i> <tt>&psi;</tt> <i>is not</i>:
     <br />
     for every intended semantic multi-structure <b>&Icirc;</b> and every <i><b>J</b></i> &isin; <b>&Icirc;</b><sub>map</sub>(<tt>&phi;</tt>)  it is the case that <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) &le;<sub>t</sub> <i>TVal</i><sub><i><b>J</b></i>/<b>&Icirc;</b></sub>(<tt>&psi;</tt>).
    <br />
    Intuitively, this means that <tt>&phi;</tt> must entail <tt>&psi;</tt> in any module associated with <tt>&phi;</tt>.
&nbsp;&nbsp;☐
  </li>
</ul>
<p>This general notion of entailment covers both first-order logic and the non-monotonic logics that underlie many rule-based languages; it extends the notion of entailment defined in [<a href="#ref-shoham-87" title="">Shoham87</a>] to the case of multi-valued logics.
</p><p><br />
Note that one consequence of the multi-document semantics is that local
constants specified in one document cannot be queried from another
document. For instance, if one document, <tt>&Delta;'</tt>, has the fact
<tt>"http://example.com/ppp"^^rif:iri("abc"^^rif:local)</tt>
while another document formula, <tt>&Delta;</tt>, imports <tt>&Delta;'</tt>
and has the rule <tt>"http://example.com/qqq"^^rif:iri(?X)&nbsp;:- "http://example.com/ppp"^^rif:iri(?X) </tt>, then
<tt>&Delta; |=
"http://example.com/qqq"^^rif:iri("abc"^^rif:local)</tt>
does <em>not</em> hold. This is because the symbol
<tt>"abc"^^rif:local</tt> in <tt>&Delta;'</tt> and <tt>&Delta;</tt> is
treated as different constants due to the <a href="#def-fld-renaming-apart" title="">process of renaming apart</a> that takes place prior to truth valuation.
</p><p>The behavior of local symbols should be contrasted with that of <tt>rif:iri</tt>  symbols. Suppose, in the above scenario, <tt>&Delta;'</tt> also has the fact <tt>"http://example.com/ppp"^^rif:iri("http://cde"^^rif:iri)</tt>. Then <tt>&Delta; |= "http://example.com/qqq"^^rif:iri("http:cde"^^rif:iri)</tt> <em>does</em> hold. 
</p><p><span class="anchor" id="sec-fld-specialization-framework"></span>
</p>
<a id="XML_Serialization_Framework" name="XML_Serialization_Framework"></a><h2> <span class="mw-headline">4  XML Serialization Framework </span></h2>
<p>The RIF-FLD XML serialization framework defines
</p>
<ul><li> a <i>normative</i> mapping from the RIF-FLD presentation syntax to XML (Section <a href="#sec-translate-fld-to-xml" title="">Mapping from the RIF-FLD Presentation Syntax to the XML Syntax</a>), and
</li><li> a <i>normative</i> XML Schema for the XML syntax (Appendix <a href="#sec-xsd-fld" title="">XML Schema for FLD</a>).
</li></ul>
<p>As explained in the <a href="#sec-overview" title="">overview</a> section, the design of RIF envisions that the presentation syntaxes of future logic RIF dialects will be specializations of the presentation syntax of RIF-FLD. This means that every well-formed formula in the presentation syntax of a standard logic RIF dialect must also be well-formed in a specialization of RIF-FLD, which includes actualizing the RIF-FLD <a href="#ref-extension-point" title="">extension points</a> (see <a href="#sec-overview" title="">overview</a> section). The goal of the XML serialization framework is to provide a similar yardstick for the RIF XML syntax. This amounts to the requirement that any admissible XML document for a logic RIF dialect must also be an admissible XML document for a specialized RIF-FLD (<i>admissibility</i> is defined below). In terms of the presentation-to-XML syntax mappings, this means that each mapping for a logic RIF dialect must be a restriction of the corresponding mapping for RIF-FLD. For instance, the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-translation" title="BLD">mapping from the presentation syntax of RIF-BLD to XML</a> in [<a href="#ref-rif-bld" title="">RIF-BLD</a>] is a restriction of the <a href="#sec-translate-fld-to-xml" title="">presentation-syntax-to-XML mapping for RIF-FLD</a>. In this way, RIF-FLD provides a framework for extensibility and mutual compatibility between XML syntaxes of RIF dialects.
</p><p>Recall that the syntax of RIF-FLD is not context-free and thus cannot be
fully captured by EBNF or XML Schema. Still, validity with respect to XML Schema can be a useful test. To reflect this state of affairs, we define two notions of syntactic correctness. The weaker notion checks correctness only with respect to XML Schema, while the stricter notion represents "true" syntactic correctness.
</p><p><span class="anchor" id="def-fld-specialized-schema"></span> 
<b>Definition (Specialization of RIF-FLD schema to a dialect schema).</b>
If a dialect, <i>D</i>, specializes RIF-FLD then its XML schema must be a <i><b>specialization of the XML schema</b></i> of RIF-FLD. This includes elimination of some elements and attributes, restriction of the XML types of the others, and replacement of the <a href="#ref-extension-point" title="">extension points</a> with appropriate concrete elements of the specified (possibly restricted) types. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-fld-valid-xml"></span> 
<b>Definition (Valid XML document in RIF-FLD).</b>
A <i><b>valid RIF-FLD document</b></i> in the XML syntax is an XML document that is valid with respect to the XML schema in Appendix <a href="#sec-xsd-fld" title="">XML Schema for RIF-FLD</a>, where the extension points <a href="#ref-newconective" title=""><tt>NEWCONNECTIVE</tt></a>, <a href="#ref-newquantifier" title=""><tt>NEWQUANTIFIER</tt></a>, <a href="#ref-newaggrfunc" title=""><tt>NEWAGGRFUNC</tt></a>, and <a href="#ref-newterm" title=""><tt>NEWTERM</tt></a> are specialized as concrete elements of the types prescribed by the RIF-FLD XML schema.
</p><p>If a dialect, <i>D</i>, specializes RIF-FLD then a <i><b>valid XML document in dialect</b></i> <i>D</i> is one that is valid with respect to the <a href="#def-fld-specialized-schema" title="">specialized XML schema</a> of <i>D</i>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-fld-admissible-xml"></span> 
<b>Definition (Admissible XML document in a logic dialect).</b>
An <i><b>admissible</b></i> RIF-FLD document in the XML syntax is a valid FLD document in that syntax that is the image of a well-formed RIF-FLD document in the presentation syntax (see Definition <a href="#def-fld-well-formed-formula" title="">Well-formed formula</a>) under the presentation-to-XML syntax mapping <tt>&chi;<sub>fld</sub></tt> defined in Section <a href="#sec-translate-fld-to-xml" title="">Mapping from the RIF-FLD Presentation Syntax to the XML Syntax</a>.
</p><p>If a dialect, <i>D</i>, specializes RIF-FLD then an XML document is admissible with respect to <i>D</i> if and only if it is a valid document in <i>D</i> and it is an image under <tt>&chi;<sub>D</sub></tt> of a well-formed document in the presentation syntax of <i>D</i>, where <tt>&chi;<sub>D</sub></tt> is the presentation-to-XML mapping defined by the dialect <i>D</i>. 
</p><p>Note that if <i>D</i> requires the directive <tt>Dialect(<i>D</i>)</tt> as part of its syntax then this implies that any <i>D</i>-admissible document must have this directive. &nbsp;&nbsp;☐
</p><p>A <i><b>round-tripping</b></i> of an admissible document in a dialect, <i>D</i>, is a semantics-preserving mapping to a document in any language <i>L</i> followed by a semantics-preserving mapping from the <i>L</i>-document back to an admissible <i>D</i>-document. While semantically equivalent, the original and the round-tripped <i>D</i>-documents need not be identical.
</p><p><br />
</p>
<a id="XML_for_the_RIF-FLD_Language" name="XML_for_the_RIF-FLD_Language"></a><h3> <span class="mw-headline">4.1  XML for the RIF-FLD Language </span></h3>
<p>RIF-FLD uses [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] for its XML syntax. The XML serialization for RIF-FLD is <i>alternating</i> or <i>fully striped</i>  [<a href="#ref-alternating-normal-form" title="">ANF01</a>]. A fully striped serialization views XML documents as objects and divides all XML tags into class descriptors, called <i>type tags</i>, and property descriptors, called <i>role tags</i> [<a href="#ref-type-and-role-tags" title="">TRT03</a>]. We follow the tradition of using capitalized names for type tags and lowercase names for role tags.
</p><p>The all-uppercase classes in the EBNF of the presentation syntax, such as <tt>FORMULA</tt>, become XML Schema groups in Appendix <a href="#sec-xsd-fld" title="">XML Schema for FLD</a>. They are not visible in instance markup. The other classes as well as non-terminals and symbols (such as <tt>Exists</tt> or <tt>=</tt>) become XML elements with optional attributes, as shown below.
</p><p><br />
The RIF serialization framework for the syntax of Section <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-FLD</a> uses the following XML tags.
While there is a RIF-FLD element tag for the <tt>Import</tt> directive and an attribute for the <tt>Dialect</tt> directive, there are none for the <tt>Base</tt> and <tt>Prefix</tt> directives: they are handled as discussed in Section <a href="#sec-translate-fld-to-xml" title="">Mapping from the RIF-FLD Presentation Syntax to the XML Syntax</a>.
</p>
<pre>- Document  (document, with optional 'dialect' attribute, containing optional directive and payload roles)
- directive (directive role, containing Import)
- payload   (payload role, containing Group)
- Import    (importation, containing location and optional profile)
- Module    (remote module, associating internal name with location)
- location  (location role, containing ANYURICONST)
- internal  (internal role, containing variable-free term as remote module name) 
- profile   (profile role, containing PROFILE)
- Group     (nested collection of sentences)
- sentence  (sentence role, containing FORMULA or Group)
- Forall    (quantified formula for 'Forall', containing declare and formula roles)
- Exists    (quantified formula for 'Exists', containing declare and formula roles)
- declare   (declare role, containing a Var)
- formula   (formula role, containing a FORMULA)
- termula   (termula role, containing a TERMULA)
- Implies   (implication, containing if and then roles)
- if        (antecedent role, containing FORMULA)
- then      (consequent role, containing FORMULA)
- And       (conjunction)
- Or        (disjunction)
- Neg       (strong negation, containing a formula role)
- Naf       (default negation, containing a formula role)
- Atom      (atom formula, positional or with named arguments)
- Remote    (prefix version of remote term '@', containing a formula/termula and an internal role)
- External  (external call, containing a content role)
- content   (content role, containing an Atom, for predicates, or Expr, for functions)
- Member    (member formula)
- Subclass  (subclass formula)
- Frame     (Frame formula)
- object    (Member/Frame role containing a TERM or an object description)
- op        (Atom/Expr role for predicates/functions as operations)
- args      (Atom/Expr positional arguments role, with fixed 'ordered' attribute, containing n TERMs)
- instance  (Member instance role)
- class     (Member class role)
- sub       (Subclass sub-class role)
- super     (Subclass super-class role)
- slot      (Atom/Expr or Frame slot role, with fixed 'ordered' attribute, containing a Name or TERM followed by a TERM)
- Equal     (prefix version of term equation '=')
- left      (Equal left-hand side role)
- right     (Equal right-hand side role)
- Expr      (expression formula, positional or with named arguments)
- List      (list term, closed or open)
- items     (list items role, with ordered="yes" attribute, containing n TERMs)
- rest      (list rest role, corresponding to '|')
- Min       (aggregate function)
- Max       (aggregate function)
- Sum       (aggregate function)
- Prod      (aggregate function)
- Avg       (aggregate function)
- Count     (aggregate function)
- Set       (aggregate function)
- Bag       (aggregate function)
- Const     (individual, function, or predicate symbol, with optional 'type' attribute)
- Name      (name of named argument)
- Var       (logic variable)
 
- id        (identifier role, containing CONST)
- meta      (meta role, containing metadata as a Frame or Frame conjunction)
</pre>
<p>The name of a prefix is not associated with an XML element, since it is handled via preprocessing as discussed in Section <a href="#sec-translation-non-annotated-language" title="">Mapping of the Non-annotated RIF-FLD Language</a>.
</p><p>The <tt>id</tt> and <tt>meta</tt> elements, which are expansions of the <tt>IRIMETA</tt> element, can occur optionally as the initial children of any Class element.
</p><p>The XML Schema Definition of RIF-FLD is given in Appendix <a href="#sec-xsd-fld" title="">XML Schema for FLD</a>.
</p><p>The XML syntax for symbol spaces uses the <tt>type</tt> attribute associated with the XML element <tt>Const</tt>. For instance, a literal in the <tt>xs:dateTime</tt> datatype is represented as <tt>&lt;Const&nbsp;type="&amp;xs;dateTime"&gt;2007-11-23T03:55:44-02:30&lt;/Const&gt;</tt>.
</p><p>The <tt>xml:lang</tt> attribute, as defined by <a class="external text" href="http://www.w3.org/TR/REC-xml/#sec-lang-tag" rel="nofollow" title="http://www.w3.org/TR/REC-xml/#sec-lang-tag">2.12 Language Identification</a> of <a class="external text" href="http://www.w3.org/TR/2000/REC-xml-20001006" rel="nofollow" title="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0</a> or its successor specifications in the W3C recommendation track, is optionally used to identify the language for the presentation of the <tt>Const</tt> to the user. It is allowed only in association with constants of the type <tt>rdf:plainLiteral</tt>. A compliant implementation MUST ignore the <tt>xml:lang</tt> attribute if the type of the <tt>Const</tt> is not <tt>rdf:plainLiteral</tt>.
</p><p>RIF-FLD also uses the <tt>ordered</tt> attribute to indicate that the children of
<tt>args</tt> and <tt>slot</tt> elements are ordered.
</p>
<p>
<b>Example 5</b> (Serialization of a nested RIF-FLD group with annotations).
</p>
<p>This example shows an XML serialization for the formulas in Example 3. For convenience of reference, the original formulas are included at the top. For better readability, we again use the shortcut syntax defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p>
<pre>Presentation syntax:

  Document(
   Dialect(FOL)
   Base(&lt;http://www.shakespeare-literature.com/Hamlet/&gt;)
   Prefix(dc     &lt;http://<a class="external free" href="http://purl.org/dc/terms/" rel="nofollow" title="http://purl.org/dc/terms/">http://purl.org/dc/terms/</a>&gt;)
   Prefix(ex     &lt;http://example.org/ontology#&gt;)

  (* &lt;assertions&gt; &lt;assertions&gt;[dc:title-&gt;"Hamlet" dc:creator-&gt;"Shakespeare"] *)      
   Group(
      Exists&nbsp;?X (And(?X # ex:RottenThing
                     ex:partof(?X &lt;http://www.denmark.dk&gt;)))
      Forall&nbsp;?X (Or(&lt;tobe&gt;(?X)  Naf &lt;tobe&gt;(?X)))
      Forall&nbsp;?X (And(Exists&nbsp;?B (And(ex:has(?X&nbsp;?B)&nbsp;?B # ex:business))
                     Exists&nbsp;?D (And(ex:has(?X&nbsp;?D)&nbsp;?D # ex:desire)))
                  &nbsp;:-&nbsp;?X # ex:man)
     (* &lt;facts&gt; *)
     Group(
         &lt;Yorick&gt; # ex:poor
         &lt;Hamlet&gt; # ex:prince
      )
   )
  )

</pre>
<pre>XML serialization:

&lt;!DOCTYPE Document [
  &lt;!ENTITY dc     "http://purl.org/dc/terms/"&gt;
  &lt;!ENTITY ex     "http://example.org/ontology#"&gt;
  &lt;!ENTITY rif    "http://www.w3.org/2007/rif#"&gt;
  &lt;!ENTITY xs     "http://www.w3.org/2001/XMLSchema#"&gt;
]&gt;

&lt;Document
        xml:base="http://www.shakespeare-literature.com/Hamlet/"&gt;
        dialect="FOL"&gt;
  &lt;payload&gt;
   &lt;Group&gt;
    &lt;meta&gt;
      &lt;Frame&gt;
        &lt;object&gt;
          &lt;Const type="&amp;rif;iri"&gt;assertions&lt;/Const&gt;
        &lt;/object&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;title&lt;/Const&gt;
          &lt;Const type="&amp;xs;string"&gt;Hamlet&lt;/Const&gt;
        &lt;/slot&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;creator&lt;/Const&gt;
          &lt;Const type="&amp;xs;string"&gt;Shakespeare&lt;/Const&gt;
        &lt;/slot&gt;
      &lt;/Frame&gt;
    &lt;/meta&gt;
    &lt;sentence&gt;
     &lt;Exists&gt;
       &lt;declare&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;And&gt;
           &lt;formula&gt;
             &lt;Member&gt;
               &lt;instance&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/instance&gt;
               &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:RottenThing&lt;/Const&gt;&lt;/class&gt;
             &lt;/Member&gt;
           &lt;/formula&gt;
           &lt;formula&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;ex:partof&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;
                 &lt;Var&gt;X&lt;/Var&gt;
                 &lt;Const type="&amp;rif;iri"&gt;http://www.denmark.dk&lt;/Const&gt;
               &lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/formula&gt;
         &lt;/And&gt;
       &lt;/formula&gt;
     &lt;/Exists&gt;
    &lt;/sentence&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Or&gt;
           &lt;formula&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;tobe&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/formula&gt;
           &lt;formula&gt;
             &lt;Naf&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;tobe&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
             &lt;/Naf&gt;
           &lt;/formula&gt;
         &lt;/Or&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
    &lt;/sentence&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Implies&gt;
           &lt;if&gt;
             &lt;Member&gt;
               &lt;instance&gt;&lt;Var&gt;X&lt;/Var&gt;&lt;/instance&gt;
               &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:man&lt;/Const&gt;&lt;/class&gt;
             &lt;/Member&gt;
           &lt;/if&gt;
           &lt;then&gt;
             &lt;And&gt;
               &lt;formula&gt;
                 &lt;Exists&gt;
                   &lt;declare&gt;&lt;Var&gt;B&lt;/Var&gt;&lt;/declare&gt;
                   &lt;formula&gt;
                    &lt;And&gt;
                     &lt;formula&gt;
                       &lt;Atom&gt;
                         &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;ex:has&lt;/Const&gt;&lt;/op&gt;
                         &lt;args&gt;
                           &lt;Var&gt;X&lt;/Var&gt;
                           &lt;Var&gt;B&lt;/Var&gt;
                         &lt;/args&gt;
                       &lt;/Atom&gt;
                     &lt;/formula&gt;
                     &lt;formula&gt;
                       &lt;Member&gt;
                         &lt;instance&gt;&lt;Var&gt;B&lt;/Var&gt;&lt;/instance&gt;
                         &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:business&lt;/Const&gt;&lt;/class&gt;
                       &lt;/Member&gt;
                     &lt;/formula&gt;
                   &lt;/And&gt;
                  &lt;/formula&gt;
                 &lt;/Exists&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Exists&gt;
                   &lt;declare&gt;&lt;Var&gt;D&lt;/Var&gt;&lt;/declare&gt;
                   &lt;formula&gt;
                    &lt;And&gt;
                     &lt;formula&gt;
                       &lt;Atom&gt;
                         &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;ex:has&lt;/Const&gt;&lt;/op&gt;
                         &lt;args&gt;
                           &lt;Var&gt;X&lt;/Var&gt;
                           &lt;Var&gt;D&lt;/Var&gt;
                         &lt;/args&gt;
                       &lt;/Atom&gt;
                     &lt;/formula&gt;
                     &lt;formula&gt;
                       &lt;Member&gt;
                         &lt;instance&gt;&lt;Var&gt;D&lt;/Var&gt;&lt;/instance&gt;
                         &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:desire&lt;/Const&gt;&lt;/class&gt;
                       &lt;/Member&gt;
                     &lt;/formula&gt;
                   &lt;/And&gt;
                  &lt;/formula&gt;
                 &lt;/Exists&gt;
               &lt;/formula&gt;
             &lt;/And&gt;
           &lt;/then&gt;
         &lt;/Implies&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
   &lt;/sentence&gt;
   &lt;sentence&gt;
     &lt;Group&gt;
       &lt;meta&gt;
         &lt;Frame&gt;
           &lt;object&gt;
             &lt;Const type="&amp;rif;iri"&gt;facts&lt;/Const&gt;
           &lt;/object&gt;
         &lt;/Frame&gt;
       &lt;/meta&gt;
       &lt;sentence&gt;
         &lt;Member&gt;
           &lt;instance&gt;&lt;Const type="&amp;rif;iri"&gt;Yorick&lt;/Const&gt;&lt;/instance&gt;
           &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:poor&lt;/Const&gt;&lt;/class&gt;
         &lt;/Member&gt;
       &lt;/sentence&gt;
       &lt;sentence&gt;
         &lt;Member&gt;
           &lt;instance&gt;&lt;Const type="&amp;rif;iri"&gt;Hamlet&lt;/Const&gt;&lt;/instance&gt;
           &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;ex:prince&lt;/Const&gt;&lt;/class&gt;
         &lt;/Member&gt;
       &lt;/sentence&gt;
     &lt;/Group&gt;
    &lt;/sentence&gt;
   &lt;/Group&gt;
  &lt;/payload&gt;
 &lt;/Document&gt;
</pre>
<p><br />
<span class="anchor" id="sec-translate-fld-to-xml"></span>
</p>
<a id="Mapping_from_the_RIF-FLD_Presentation_Syntax_to_the_XML_Syntax" name="Mapping_from_the_RIF-FLD_Presentation_Syntax_to_the_XML_Syntax"></a><h3> <span class="mw-headline">4.2  Mapping from the RIF-FLD Presentation Syntax to the XML Syntax </span></h3>
<p>This section defines a normative mapping, <tt>&chi;<sub>fld</sub></tt>, from the presentation syntax of Section <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-FLD</a> to the XML syntax of RIF-FLD.
The mapping is given via tables where each row specifies the mapping of a particular syntactic pattern in the presentation syntax. These patterns appear in the first column of the tables and the <i><b>bold-italic</b></i> symbols represent metavariables. The second column represents the corresponding XML patterns, which may contain applications of the mapping <tt>&chi;<sub>fld</sub></tt> to these metavariables. When an expression <tt>&chi;<sub>fld</sub></tt><tt>(<b><i>metavar</i></b>)</tt> occurs in an XML pattern in the right column of a translation table, it should be understood as a recursive application of <tt>&chi;<sub>fld</sub></tt> to the presentation syntax represented by the metavariable. The XML syntax result of such an application is substituted for the expression <tt>&chi;<sub>fld</sub></tt><tt>(<b><i>metavar</i></b>)</tt>. 
A sequence of terms containing metavariables with subscripts is indicated by an ellipsis.
A metavariable or a well-formed XML subelement is marked as optional by appending a bold-italic question mark, <i><b>?</b></i>, to its right.
</p><p><br />
<span class="anchor" id="sec-translation-non-annotated-language"></span> 
</p>
<a id="Mapping_of_the_Non-annotated_RIF-FLD_Language" name="Mapping_of_the_Non-annotated_RIF-FLD_Language"></a><h4> <span class="mw-headline">4.2.1  Mapping of the Non-annotated RIF-FLD Language </span></h4>
<p>The <tt>&chi;<sub>fld</sub></tt> mapping from the presentation syntax to the XML syntax of the non-annotated RIF-FLD Language is given by the table below.
Each row indicates a translation
<tt>&chi;<sub>fld</sub></tt>(<tt>Presentation</tt>) = <tt>XML</tt>. The function <tt><i>remove-outer-quotes</i></tt> used in the translation removes enclosing double quotes from a string and leaves unquoted strings untouched. Since the presentation syntax of RIF-FLD is context sensitive, the mapping must differentiate between the terms that occur in the position of the individuals and the terms that occur as atomic formulas. To this end, in the translation table, the positional and named-argument terms that occur in the context of atomic formulas are denoted by the expressions of the form <i><b>pred</b></i>(...) and the terms that occur as individuals are denoted by expressions of the form <i><b>func</b></i>(...).
In the table, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>name<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>. Regarding the last but first row, we assume that shortcuts for constants [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] have already been expanded to their full form (<tt>"..."^^</tt><i><b>symspace</b></i>).
The <tt><i><b>AGGRFUNC</b></i></tt> metavariable stands for any of the aggregation functions <tt>Min</tt>, <tt>Max</tt>, <tt>Count</tt>,  <tt>Avg</tt>, <tt>Sum</tt>, <tt>Prod</tt>, <tt>Set</tt>, <tt>Bag</tt>, or <tt>NEWAGGRFUNC</tt>.
</p><p>Thus, the mapping of the extension point for aggregate functions (<a href="#ref-newaggrfunc" title=""><tt>NEWAGGRFUNC</tt></a>) is handled by the <i><b>AGGRFUNC</b></i> metavariable, along with the mapping of the specific aggregate functions (<tt>Min</tt> etc.).
The mapping of the extension points for quantifiers (<a href="#ref-newquantifier" title=""><tt>NEWQUANTIFIER</tt></a>) and connectives (<a href="#ref-newconective" title=""><tt>NEWCONNECTIVE</tt></a>) generalizes the mapping for the specific quantifiers (<tt>Forall</tt>, <tt>Exists</tt>) and connectives (<tt>And</tt>, <tt>Or</tt>), respectively.
The mapping of the extension point for terms (<a href="#ref-newterm" title=""><tt>NEWTERM</tt></a>) keeps <tt>NEWTERM</tt> entirely unconstrained in the presentation syntax and uses a wildcard content model (indicated by ellipses) in the XML syntax. This is because the content of <tt>NEWTERM</tt> is left entirely up to RIF dialects.
Recall that the extension point for  symbols (<a href="#ref-newsymbol" title=""><tt>NEWSYMBOL</tt></a>) is part of the alphabet and is not dealt with in the EBNF and XML grammars.
</p><p>Also recall that <tt>OpenList(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> <tt>t)</tt>, m&ge;1, is just an alternative form for <tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> | <tt>t)</tt>, so its mapping is not represented separately.
</p><p>Note that the <tt>Import</tt> and <tt>Dialect</tt> directives are handled by the presentation-to-XML syntax mapping, using an XML attribute for <tt>dialect</tt> names (values: <tt>FOL</tt>, <tt>BLD</tt>, <tt>Core</tt>, etc.). On the other hand, the <tt>Prefix</tt> and <tt>Base</tt> directives are not handled by this mapping but by expanding the associated shortcuts (compact URIs).
Namely, a prefix name declared in a <tt>Prefix</tt> directive is expanded into the associated IRI, while relative IRIs are completed using the IRI declared in the <tt>Base</tt> directive. The mapping <tt>&chi;<sub>fld</sub></tt> applies only to such expanded documents.
RIF-FLD also allows other treatments of <tt>Prefix</tt> and <tt>Base</tt> provided that they produce equivalent XML documents. One such treatment is employed in the examples in this document, especially Example 5. It replaces prefix names with definitions of XML entities as follows.
Each <tt>Prefix</tt> declaration becomes an <tt>ENTITY</tt> declaration [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] within a <tt>DOCTYPE</tt> DTD attached to the RIF-FLD <tt>Document</tt>. The <tt>Base</tt> directive is mapped to the <tt>xml:base</tt> attribute [<a href="#ref-xml-base" title="">XML-Base</a>] in the XML <tt>Document</tt> tag.
Compact URIs of the form <tt>prefix:suffix</tt> are then mapped to <tt>&amp;prefix;suffix</tt>.
</p>
<table class="syntax-translation-table">
<tr>
<th colspan="1" rowspan="1"> Presentation Syntax
</th><th colspan="1" rowspan="1"> XML Syntax
</th></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Document(
  Dialect(<i><b>name</b></i>)<i><b>?</b></i>
  Import(<i><b>iloc<sub>1</sub></b></i> <i><b>prfl<sub>1</sub>?</b></i>)
   . . .
  Import(<i><b>iloc<sub>n</sub></b></i> <i><b>prfl<sub>n</sub>?</b></i>)
  Module(<i><b>name<sub>1</sub></b></i> <i><b>mloc<sub>1</sub></b></i>)
   . . .
  Module(<i><b>name<sub>k</sub></b></i> <i><b>mloc<sub>k</sub></b></i>)
  <i><b>group</b></i>
        )
n &ge; 0, k &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Document dialect="<i><b>name</b></i>"<i><b>?</b></i>&gt;
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>iloc<sub>1</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>prfl<sub>1</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
   . . .
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>iloc<sub>n</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>prfl<sub>n</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
  &lt;directive&gt;
    &lt;Module&gt;
      &lt;internal&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/internal&gt;
      &lt;location&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>mloc<sub>1</sub></b></i>)&lt;/location&gt;
    &lt;/Module&gt;
  &lt;/directive&gt;
   . . .
  &lt;directive&gt;
    &lt;Module&gt;
      &lt;internal&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>name<sub>k</sub></b></i>)&lt;/internal&gt;
      &lt;location&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>mloc<sub>k</sub></b></i>)&lt;/location&gt;
    &lt;/Module&gt;
  &lt;/directive&gt;
  &lt;payload&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>group</b></i>)&lt;/payload&gt;
&lt;/Document&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Group(
  <i><b>clause<sub>1</sub></b></i>
   . . .
  <i><b>clause<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Group&gt;
  &lt;sentence&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>clause<sub>1</sub></b></i>)&lt;/sentence&gt;
   . . .
  &lt;sentence&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>clause<sub>n</sub></b></i>)&lt;/sentence&gt;
&lt;/Group&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Forall
  <i><b>variable<sub>1</sub></b></i>
   . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>body</b></i>
            )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Forall&gt;
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>body</b></i>)&lt;/formula&gt;
&lt;/Forall&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Exists
  <i><b>variable<sub>1</sub></b></i>
  . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>body</b></i>
            )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Exists&gt;
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>body</b></i>)&lt;/formula&gt;
&lt;/Exists&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>NEWQUANTIFIER
  <i><b>variable<sub>1</sub></b></i>
  . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>body</b></i>
            )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;NEWQUANTIFIER&gt;
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>body</b></i>)&lt;/formula&gt;
&lt;/NEWQUANTIFIER&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>conclusion</b></i>&nbsp;:- <i><b>condition</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Implies&gt;
  &lt;if&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>condition</b></i>)&lt;/if&gt;
  &lt;then&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>conclusion</b></i>)&lt;/then&gt;
&lt;/Implies&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>And (
  <i><b>conjunct<sub>1</sub></b></i>
  . . .
  <i><b>conjunct<sub>n</sub></b></i>
    )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;And&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>conjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>conjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/And&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Or (
  <i><b>disjunct<sub>1</sub></b></i>
  . . .
  <i><b>disjunct<sub>n</sub></b></i>
   )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Or&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>disjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>disjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/Or&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>NEWCONNECTIVE (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
              )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;NEWCONNECTIVE&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/NEWCONNECTIVE&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Neg <i><b>form</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Neg&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>form</b></i>)&lt;/formula&gt;
&lt;/Neg&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Naf <i><b>form</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Naf&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>form</b></i>)&lt;/formula&gt;
&lt;/Naf&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>query</b></i> @ <i><b>modref</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Remote&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>query</b></i>)&lt;/formula&gt;
  &lt;internal&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>modref</b></i>)&lt;/internal&gt;
&lt;/Remote&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>External (
  <i><b>atomframexpr</b></i>
         )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;External&gt;
  &lt;content&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>atomframexpr</b></i>)&lt;/content&gt;
&lt;/External&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>m</sub></b></i>
     )
m &ge; 1
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>m</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>m</sub></b></i>
     )
m &ge; 1
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>m</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
    )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
  |
  <i><b>remainder</b></i>
    )
n &ge; 1
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
  &lt;rest&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>remainder</b></i>)&lt;/rest&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Frame&gt;
  &lt;object&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>

<tr>
<td colspan="1" rowspan="1">
<pre><i><b>inst</b></i> # <i><b>class</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Member&gt;
  &lt;instance&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>inst</b></i>)&lt;/instance&gt;
  &lt;class&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>class</b></i>)&lt;/class&gt;
&lt;/Member&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>sub</b></i> ## <i><b>super</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Subclass&gt;
  &lt;sub&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>sub</b></i>)&lt;/sub&gt;
  &lt;super&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>super</b></i>)&lt;/super&gt;
&lt;/Subclass&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>left</b></i> = <i><b>right</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Equal&gt;
  &lt;left&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>left</b></i>)&lt;/left&gt;
  &lt;right&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>right</b></i>)&lt;/right&gt;
&lt;/Equal&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>AGGRFUNC</b></i> {
  <i><b>variable</b></i>
  <i><b>variable<sub>1</sub></b></i>
  . . .
  <i><b>variable<sub>m</sub></b></i>
         |
     <i><b>compform</b></i>
         }
 m &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>AGGRFUNC</b></i>&gt;
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable</b></i>)&lt;/declare&gt;
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>m</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>compform</b></i>)&lt;/formula&gt;
&lt;/<i><b>AGGRFUNC</b></i>&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>"<i><b>unicodestring</b></i>"^^<i><b>space</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Const type="<i><b>space</b></i>"&gt;<i><b>unicodestring</b></i>&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>?<i><b>name<sub>1</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>NEWTERM
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;NEWTERM&gt;...&lt;/NEWTERM&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>name<sub>i</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre> <i>remove-outer-quotes</i>(<i><b>name<sub>i</sub></b></i>)
</pre>
</td></tr></table>
<a id="Mapping_of_RIF-FLD_Annotations" name="Mapping_of_RIF-FLD_Annotations"></a><h4> <span class="mw-headline">4.2.2  Mapping of RIF-FLD Annotations </span></h4>
<p>The <tt>&chi;<sub>fld</sub></tt> mapping from RIF-FLD annotations in the presentation syntax to the XML syntax is specified by the table below.
It extends the translation table of Section <a href="#sec-translation-non-annotated-language" title="">Mapping of the Non-annotated RIF-FLD Language</a>.
The metavariable <i><b>Typetag</b></i> in the presentation and XML syntaxes stands for any of the class names <tt>And</tt>, <tt>Or</tt>, <tt>External</tt>, <tt>Document</tt>, or <tt>Group</tt>, <i><b>Quantifier</b></i> for <tt>Exists</tt> or <tt>Forall</tt>, and <i><b>Negation</b></i> for <tt>Neg</tt> or <tt>Naf</tt>. The dollar sign, <b>$</b>, stands for any of the binary infix operator names <tt>#</tt>, <tt>##</tt>, <tt>=</tt>, <tt>:-</tt>, or <tt>@</tt>, while <i><b>Binop</b></i> stands for their respective class names <tt>Member</tt>, <tt>Subclass</tt>, <tt>Equal</tt>, <tt>Implies</tt>, or <tt>Remote</tt>.
The metavariable <i><b>attr?</b></i> is used with <i><b>Typetag</b></i> to capture the optional <tt>dialect</tt> attribute (with its value) of <tt>Document</tt>.
Again, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>name<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>.
</p>
<table class="syntax-translation-table">
<tr>
<th colspan="1" rowspan="1"> Presentation Syntax
</th><th colspan="1" rowspan="1"> XML Syntax
</th></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Typetag</b></i> ( <i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i> )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Typetag</b></i> <i><b>attr?</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>
&lt;/<i><b>Typetag</b></i>&gt;

<tt>where <i><b>attr</b></i>, <i><b>e<sub>1</sub>'</b></i>, . . ., <i><b>e<sub>n</sub>'</b></i> are defined by the equation</tt>
<tt>&chi;<sub>fld</sub></tt><tt>(<i><b>Typetag</b></i>(<i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i>)) = &lt;<i><b>Typetag</b></i> <i><b>attr?</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>&lt;/<i><b>Typetag</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Quantifier</b></i> <i><b>variable<sub>1</sub></b></i> . . . <i><b>variable<sub>n</sub></b></i> ( <i><b>body</b></i> )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Quantifier</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
  . . .
  &lt;declare&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>body</b></i>)&lt;/formula&gt;
&lt;/<i><b>Quantifier</b></i>&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Negation</b></i> <i><b>e</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Negation</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <tt>&chi;<sub>fld</sub></tt>(<i><b>e</b></i>)
&lt;/<i><b>Negation</b></i>&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
    )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
  |
  <i><b>remainder</b></i>
    )
n &ge; 1
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>fld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
  &lt;rest&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>remainder</b></i>)&lt;/rest&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
n &ge; 0
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Frame&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;object&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>fld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>&chi;<sub>fld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Binop</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>
&lt;/<i><b>Binop</b></i>&gt;

<tt>where <i><b>Binop</b></i>, <i><b>e<sub>1</sub>'</b></i>, <i><b>e<sub>2</sub>'</b></i> are defined by the equation</tt>
<tt>&chi;<sub>fld</sub></tt><tt>(<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>) = &lt;<i><b>Binop</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>&lt;/<i><b>Binop</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
<i><b>unicodestring</b></i>^^<i><b>symspace</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Const type="<i><b>symspace</b></i>"&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>unicodestring</b></i>
&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>const?</b></i> <i><b>frameconj?</b></i> *)
?<i><b>name<sub>1</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Var&gt;
  &lt;id&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>const</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>fld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)
&lt;/Var&gt;
</pre>
</td></tr></table>
<p><br />
<span class="anchor" id="sec-conformance"></span>
</p>
<a id="Conformance_of_RIF_Processors_with_RIF_Dialects" name="Conformance_of_RIF_Processors_with_RIF_Dialects"></a><h2> <span class="mw-headline">5  Conformance of RIF Processors with RIF Dialects </span></h2>
<p>RIF does not require or expect conformant systems to implement the
presentation syntax of a RIF dialect. Instead, conformance is described in terms of semantics-preserving transformations between the native syntax of a compliant system and the XML syntax of RIF-BLD.
</p><p>Let &Tau; be a set of datatypes and symbol spaces that includes the datatypes specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and the symbol spaces <tt>rif:iri</tt> and <tt>rif:local</tt>. Suppose also that &Epsilon; is a <a href="#def-fld-external-schema-set" title="">coherent set of external schemas</a> that includes the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Let <i>D</i> be a RIF dialect (e.g., [<a href="#ref-rif-bld" title="">RIF-BLD</a>]). We say that a formula &phi; is a <i>D</i><sub>&Tau;,&Epsilon;</sub> formula iff 
</p>
<ul>
  <li>
    it is a formula in the dialect <i>D</i>,
  </li>
  <li>
    all datatypes and symbol spaces used in &phi; are in &Tau;, and
  </li>
  <li>
    all externally defined terms used in &phi; are instantiations of some external schemas in &Epsilon;.
  </li>
</ul>
<p><span class="anchor" id="def-conformance"></span>
A RIF processor is a <i><b>conformant</b></i> <i>D</i><sub>&Tau;,&Epsilon;</sub> <i><b>consumer</b></i> iff <i>it implements</i> a semantics-preserving mapping, &mu;, from the set of all <i>D</i><sub>&Tau;,&Epsilon;</sub> formulas to the language <i>L</i> of the processor.
</p><p>Formally, this means that for any pair &phi;, &psi; of <i>D</i><sub>&Tau;,&Epsilon;</sub> formulas for which &phi; |=<sub><tt><i>D</i></tt></sub> &psi; is defined, &phi; |=<sub><tt><i>D</i></tt></sub> &psi; iff  &mu;(&phi;) |=<sub><tt><i>L</i></tt></sub> &mu;(&psi;). Here |=<sub><tt><i>D</i></tt></sub> denotes the logical entailment in the RIF dialect <i>D</i> and |=<sub><tt><i>L</i></tt></sub> is the logical entailment in the language <i>L</i> of the RIF processor.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>D</i><sub>&Tau;,&Epsilon;</sub> <i><b>producer</b></i> iff it implements a semantics-preserving mapping, &nu;, from the language <i>L</i> of the processor to the set of all <i>D</i><sub>&Tau;,&Epsilon;</sub> formulas.
</p><p>Formally, this means that for any pair &phi;, &psi; of formulas in <i>L</i> for which &phi; |=<sub><tt><i>L</i></tt></sub> &psi; is defined, &phi; |=<sub><tt><i>L</i></tt></sub> &psi; iff  &nu;(&phi;) |=<sub><tt><i>D</i></tt></sub> &nu;(&psi;).
</p><p><br />
An <i><b>admissible document</b></i> in a logic RIF dialect <i>D</i> is one which conforms to all the syntactic constraints of <i>D</i>, including the ones that cannot be checked by an XML Schema validator (see Definition <a href="#def-fld-admissible-xml" title="">Admissible XML document in a logic dialect</a>).
</p>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">6  Acknowledgements </span></h2>
<p>This revised version incorporates a number of improvements suggested in [<a href="#ref-rif-modularity" title="">DAA</a>] and fixes errors in the definition of the semantics of document formulas pointed out in that work.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">7  References </span></h2>
<a id="Normative_References" name="Normative_References"></a><h3> <span class="mw-headline">7.1  Normative References </span></h3>
<p><span id="ref-owl-reference"></span>
</p>
<dl><dt> [OWL-Reference]
</dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web Ontology Language Reference</a></i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004. Latest version available at <a class="external free" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-concepts"></span> 
</p>
<dl><dt> [RDF-CONCEPTS]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax</i>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-semantics"></span> 
</p>
<dl><dt> [RDF-SEMANTICS]
</dt><dd> <i>RDF Semantics</i>, Patrick Hayes, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">http://www.w3.org/TR/2004/REC-rdf-mt-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-mt/" rel="nofollow" title="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rdf-schema"></span> 
</p>
<dl><dt> [RDF-SCHEMA]
</dt><dd> <i>RDF Vocabulary Description Language 1.0: RDF Schema</i>, Brian McBride, Editor, W3C Recommendation 10 February 2004, <a class="external free" href="http://www.w3.org/TR/rdf-schema/" rel="nofollow" title="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rfc-3066"></span> 
</p>
<dl><dt> [RFC-3066]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3066" title="http://tools.ietf.org/html/rfc3066">RFC 3066</a> - Tags for the Identification of Languages</i>, H. Alvestrand, IETF, January 2001. This document is at <a class="external free" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">http://www.ietf.org/rfc/rfc3066</a>.
</dd></dl>
<p><span class="anchor" id="ref-rfc-3987"></span> 
</p>
<dl><dt> [RFC-3987]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3987" title="http://tools.ietf.org/html/rfc3987">RFC 3987</a> - Internationalized Resource Identifiers (IRIs)</i>, M. Duerst and M. Suignard, IETF, January 2005. This document is at <a class="external free" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-bld"></span>
</p>
<dl><dt> [RIF-BLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/"><span>RIF Basic Logic Dialect (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-core"></span>
</p>
<dl><dt> [RIF-Core]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/"><span>RIF Core Dialect (Second Edition)</span></a></cite> Harold Boley, Gary Hallmark, Michael Kifer, Adrian Paschke, Axel Polleres, Dave Reynolds, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-dtb"></span>
</p>
<dl><dt> [RIF-DTB]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-prd"></span>
</p>
<dl><dt> [RIF-PRD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/"><span>RIF Production Rule Dialect (Second Edition)</span></a></cite> Christian de Sainte Marie, Gary Hallmark, Adrian Paschke, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-swc"></span>
</p>
<dl><dt> [RIF-RDF+OWL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/"><span>RIF RDF and OWL Compatibility (Second Edition)</span></a></cite> Jos de Bruijn, Chris Welty, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-xml-1-point-0"></span> 
</p>
<dl><dt> [XML1.0]
</dt><dd> <i>Extensible Markup Language (XML) 1.0 (Fourth Edition)</i>, W3C Recommendation, World Wide Web Consortium, 16 August 2006, edited in place 29 September 2006. This version is <a class="external free" href="http://www.w3.org/TR/2006/REC-xml-20060816/" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-base"></span> 
</p>
<dl><dt> [XML-Base]
</dt><dd> <i>XML Base</i>, W3C Recommendation, World Wide Web Consortium, 27 June 2001. This version is <a class="external free" href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/" rel="nofollow" title="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">http://www.w3.org/TR/2001/REC-xmlbase-20010627/</a>. The latest version is available at <a class="external free" href="http://www.w3.org/TR/xmlbase/" rel="nofollow" title="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-names"></span> 
</p>
<dl><dt> [XML-Names]
</dt><dd> <i>Namespaces in XML 1.1 (Second Edition)</i>, W3C Recommendation, World Wide Web Consortium, 16 August 2006. This version is <a class="external free" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816">http://www.w3.org/TR/2006/REC-xml-names11-20060816</a>. The latest version is available at <a class="external free" href="http://www.w3.org/TR/xml-names11/" rel="nofollow" title="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a>.
</dd></dl>
<a id="Informational_References" name="Informational_References"></a><h3> <span class="mw-headline">7.2  Informational References </span></h3>
<p><span class="anchor" id="ref-alternating-normal-form"></span> 
</p>
<dl><dt> [ANF01]
</dt><dd> <i>Normal Form Conventions for XML Representations of Structured Data</i>, Henry S. Thompson. October 2001. Available at <a class="external free" href="http://www.ltg.ed.ac.uk/~ht/normalForms.html" rel="nofollow" title="http://www.ltg.ed.ac.uk/~ht/normalForms.html">http://www.ltg.ed.ac.uk/~ht/normalForms.html</a>.
</dd></dl>
<p><span class="anchor" id="ref-strong-explicit-negation"></span> 
</p>
<dl><dt> [APP96]
</dt><dd> <i>Strong and Explicit Negation in Non-Monotonic Reasoning and Logic Programming</i>, J.J. Alferes, L.M. Pereira, and T.C. Przymusinski. Lecture Notes In Computer Science, vol. 1126. Proceedings of the European Workshop on Logics in Artificial Intelligence, 1996.
</dd></dl>
<p><span class="anchor" id="ref-negation-as-failure"></span> 
</p>
<dl><dt> [Clark87]
</dt><dd> <i>Negation as failure</i>, K. Clark. Readings in nonmonotonic reasoning, Morgan Kaufmann Publishers, pages 311 - 325, 1987. (Originally published in 1978.)
</dd></dl>
<p><span class="anchor" id="ref-sorted-hilog-93"></span> 
</p>
<dl><dt> [CK95]
</dt><dd> <i>Sorted HiLog: Sorts in Higher-Order Logic Data Languages,</i> W. Chen, M. Kifer. Sixth Intl. Conference on Database Theory, Prague, Czech Republic, January 1995, Lecture Notes in Computer Science 893, Springer Verlag, pp. 252--265.
</dd></dl>
<p><span class="anchor" id="ref-hilog-93"></span> 
</p>
<dl><dt> [CKW93]
</dt><dd> <i>HiLog: A Foundation for higher-order logic programming,</i> W. Chen, M. Kifer, D.S. Warren. Journal of Logic Programming, vol. 15, no. 3, February 1993, pp. 187--230.
</dd></dl>
<p><span class="anchor" id="ref-chang-lee"></span> 
</p>
<dl><dt> [CL73]
</dt><dd> <i>Symbolic Logic and Mechanical Theorem Proving</i>, C.L. Chang and R.C.T. Lee. Academic Press, 1973.
</dd></dl>
<p><span class="anchor" id="ref-curie"></span> 
</p>
<dl><dt> [CURIE]
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">CURIE Syntax 1.0</a></cite>, S. McCarron, M. Birbeck,  Editors, W3C Working Group Note, 16 December 2010, <a class="external free" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">http://www.w3.org/TR/2010/NOTE-curie-20101216</a> . Latest version available at <a class="external free" href="http://www.w3.org/TR/curie" rel="nofollow" title="http://www.w3.org/TR/curie">http://www.w3.org/TR/curie</a>.
</dd></dl>
<p><span class="anchor" id="ref-cycl"></span> 
</p>
<dl><dt> [CycL]
</dt><dd> <i>The Syntax of CycL</i>, Web site. Available at <a class="external free" href="http://www.cyc.com/cycdoc/ref/cycl-syntax.html" rel="nofollow" title="http://www.cyc.com/cycdoc/ref/cycl-syntax.html">http://www.cyc.com/cycdoc/ref/cycl-syntax.html</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-modularity"></span> 
</p>
<dl><dt> [DAA]
</dt><dd> <i>Modularity in the Rule Interchange Format</i>, Carlos Viegas Dam&aacute;sio, Anastasia Analyti, and Grigoris Antoniou. 5th International Symposium on Rule-Based Reasoning, Programming, and Applications (RuleML 2011 - Europe), Nick Bassiliades, Guido Governatori, and Adrian Paschke (Eds.). Springer-Verlag, Berlin, Heidelberg, 313-328. 2011.
</dd></dl>
<p><span class="anchor" id="ref-enderton01"></span> 
</p>
<dl><dt> [Enderton01]
</dt><dd> <i>A Mathematical Introduction to Logic, Second Edition</i>, H. B. Enderton. Academic Press, 2001.
</dd></dl>
<p><span class="anchor" id="ref-fitting02"></span> 
</p>
<dl><dt> [Fit02]
</dt><dd> <i>Fixpoint semantics for logic programming a survey</i>, M. Fitting. Theoretical Computer Science, vol. 278, no. 1-2, pp. 25-51, 2002.
</dd></dl>
<p><span class="anchor" id="ref-flora2"></span> 
</p>
<dl><dt> [FL2]
</dt><dd> <i>FLORA-2: An Object-Oriented Knowledge Base Language</i>, M. Kifer. Web site. Available at <a class="external free" href="http://flora.sourceforge.net" rel="nofollow" title="http://flora.sourceforge.net">http://flora.sourceforge.net</a>.
</dd></dl>
<p><span class="anchor" id="ref-stable-model"></span> 
</p>
<dl><dt> [GL88]
</dt><dd> <i>The Stable Model Semantics for Logic Programming</i>, M. Gelfond and V. Lifschitz. Logic Programming: Proceedings of the Fifth Conference and Symposium, pages 1070-1080, 1988.
</dd></dl>
<p><span class="anchor" id="ref-ASP-91"></span> 
</p>
<dl><dt> [GL91]
</dt><dd> <i>Classical Negation in Logic Programs and Disjunctive Databases</i>, M. Gelfond and V. Lifschitz. New Generation Computing 9, pages 365-386, 1991.
</dd></dl>
<p><span class="anchor" id="ref-gelfond-leone"></span>
</p>
<dl><dt> [GLe02]
</dt><dd> <i>Logic programming and knowledge representation - The A-Prolog perspective,</i> M. Gelfond and N. Leone. Artificial Intelligence 138(1-2), pages 3-38, 2002.
</dd></dl>
<p><span class="anchor" id="ref-wf-model"></span> 
</p>
<dl><dt> [GRS91]
</dt><dd> <i>The Well-Founded Semantics for General Logic Programs</i>, A. Van Gelder, K.A. Ross, J.S. Schlipf. Journal of ACM, 38:3, pages 620-650, 1991. 
</dd></dl>
<p><span class="anchor" id="ref-flogic-95"></span> 
</p>
<dl><dt> [KLW95]
</dt><dd> <i>Logical foundations of object-oriented and frame-based languages,</i> M. Kifer, G. Lausen, J. Wu. Journal of ACM, July 1995, pp. 741--843.
</dd></dl>
<p><span class="anchor" id="ref-lloyd-87"></span> 
</p>
<dl><dt> [Lloyd87]
</dt><dd> <i>Foundations of Logic Programming (Second Edition),</i> J.W. Lloyd, Springer-Verlag, 1987.
</dd></dl>
<p><span class="anchor" id="ref-mendelson97"></span> 
</p>
<dl><dt> [Mendelson97]
</dt><dd> <i>Introduction to Mathematical Logic, Fourth Edition</i>, E. Mendelson. Chapman &amp; Hall, 1997.
</dd></dl>
<p><span class="anchor" id="ref-nxbre"></span> 
</p>
<dl><dt> [NxBRE]
</dt><dd> <i>.NET Business Rule Engine</i>, Web site. Available at <a class="external free" href="http://nxbre.wiki.sourceforge.net/" rel="nofollow" title="http://nxbre.wiki.sourceforge.net/">http://nxbre.wiki.sourceforge.net/</a>.
</dd></dl>
<p><span class="anchor" id="ref-oojdrew"></span> 
</p>
<dl><dt> [OOjD]
</dt><dd> <i>Object-Oriented jDREW</i>, Web site. Available at <a class="external free" href="http://www.jdrew.org/oojdrew/" rel="nofollow" title="http://www.jdrew.org/oojdrew/">http://www.jdrew.org/oojdrew/</a>.
</dd></dl>
<p><span class="anchor" id="ref-przymusinski-stationary"> </span>
</p>
<dl><dt> [Prz94]
</dt><dd> <i>Well-founded and stationary models of logic programs,</i> T.C. Przymusinski. Annals of Mathematics and Artificial Intelligence 12 (1994), pp. 141-187.
</dd></dl>
<p><span class="anchor" id="ref-rdf-syntax"></span> 
</p>
<dl><dt> [RDFSYN04]
</dt><dd> <i>RDF/XML Syntax Specification (Revised)</i>, Dave Beckett, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-syntax-grammar/" rel="nofollow" title="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a>.
</dd></dl>
<p><span class="anchor" id="ref-relfun-99"></span>
</p>
<dl><dt> [RF99]
</dt><dd> <i>A Tight, Practical Integration of Relations and Functions</i>, H. Boley, Springer-Verlag, 1999.
</dd></dl>
<p><span class="anchor" id="ref-shoham-87"></span> 
</p>
<dl><dt> [Shoham87]
</dt><dd> <i>Nonmonotonic logics: meaning and utility</i>, Y. Shoham. Proc. 10th International Joint Conference on Artificial Intelligence, Morgan Kaufmann, pp. 388--393, 1987.
</dd></dl>
<p><span class="anchor" id="ref-steele90"></span> 
</p>
<dl><dt> [Steele90]
</dt><dd> <i>Common LISP: The Language, Second Edition</i>, G. L. Steele Jr. Digital Press, 1990.
</dd></dl>
<p><span class="anchor" id="ref-swsl-rules"></span> 
</p>
<dl><dt> [SWSL-Rules]
</dt><dd> <i>Semantic Web Services Language (SWSL)</i>, S. Battle, A. Bernstein, H. Boley, B. Grosof, M. Gruninger, R. Hull, M. Kifer, D. Martin, S. McIlraith, D. McGuinness, J. Su, S. Tabet. W3C Member Submission, September 2005. Available at <a class="external free" href="http://www.w3.org/Submission/SWSF-SWSL/" rel="nofollow" title="http://www.w3.org/Submission/SWSF-SWSL/">http://www.w3.org/Submission/SWSF-SWSL/</a>.
</dd></dl>
<p><span class="anchor" id="ref-type-and-role-tags"></span> 
</p>
<dl><dt> [TRT03]
</dt><dd> <i>Object-Oriented RuleML: User-Level Roles, URI-Grounded Clauses, and Order-Sorted Terms</i>, H. Boley.  Springer LNCS 2876, Oct. 2003, pp. 1-16.  Available at <a class="external free" href="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf" rel="nofollow" title="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf">http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf</a>.
</dd></dl>
<p><span class="anchor" id="ref-vanemden-kowalski"></span> 
</p>
<dl><dt> [vEK76]
</dt><dd> <i>The semantics of predicate logic as a programming language</i>, M. van Emden and R. Kowalski. Journal of the ACM 23 (1976), 733-742. 
</dd></dl>
<p><span class="anchor" id="ref-wsml-rules"></span> 
</p>
<dl><dt> [WSML-Rules]
</dt><dd> <i>Web Service Modeling Language (WSML)</i>, J. de Bruijn, D. Fensel, U. Keller, M. Kifer, H. Lausen, R. Krummenacher, A. Polleres, L. Predoiu. W3C Member Submission, June 2005. Available at <a class="external free" href="http://www.w3.org/Submission/WSML/" rel="nofollow" title="http://www.w3.org/Submission/WSML/">http://www.w3.org/Submission/WSML/</a>.
</dd></dl>
<p><span class="anchor" id="sec-xsd-fld"></span>
</p>
<a id="Appendix:_XML_Schema_for_RIF-FLD" name="Appendix:_XML_Schema_for_RIF-FLD"></a><h2> <span class="mw-headline">8  Appendix: XML Schema for RIF-FLD </span></h2>
<div><div dir="ltr" lang="en"> 
<p>The <b>namespace</b> of RIF is "<a class="external free" href="http://www.w3.org/2007/rif" rel="nofollow" title="http://www.w3.org/2007/rif#">http://www.w3.org/2007/rif#</a>". 
</p><p>XML schemas for the RIF-FLD language are defined below and are also
available at <a class="external free" href="http://www.w3.org/2010/rif-schema/fld" rel="nofollow" title="http://www.w3.org/2010/rif-schema/fld">http://www.w3.org/2010/rif-schema/fld</a> with additional examples.
For modularity, we define a <i>Baseline</i> schema and a <i>Skyline</i> schema.
Baseline is the schema module that provides the foundation up to <tt>FORMULA</tt>s without <tt>Implies</tt>.
Skyline provides the full schema by augmenting Baseline with the <tt>Implies</tt> <tt>FORMULA</tt> as well as with <tt>Group</tt> and <tt>Document</tt>.
</p><p><br />
</p>
<a id="Baseline_Schema_Module" name="Baseline_Schema_Module"></a><h3> <span class="mw-headline">8.1  Baseline Schema Module </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: FLDBaseline.xsd, v. 1.5, 2010-05-08, hboley/dhirtle"&gt;

 &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
            schemaLocation='http://www.w3.org/2001/xml.xsd'/&gt; 
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;

    This is the Baseline module of FLD. It is the foundation of the full schema
    defined through the Skyline module. The Baseline XML schema is based on the
    following EBNF (compared to the full EBNF of RIF-FLD, Group and Document are
    omitted, and 'Implies' is missing from the productions for FORMULA and TERMULA).
    
    The nonterminals starting with NEW provide extensions points for FLD
    (cf. Section 4 XML Serialization Framework).
 
  FORMULA       &nbsp;::= IRIMETA? CONNECTIVE '(' FORMULA* ')' |
                     IRIMETA? QUANTIFIER '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA?  FORMULA '@' MODULEREF |
                     FORM
  FORM          &nbsp;::= IRIMETA? (Var | ATOMIC |
                               'External' '(' ATOMIC LOCATOR? ')')
  ATOMIC        &nbsp;::= Const | Atom | Equal | Member | Subclass | Frame
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= TERMULA '(' (TERMULA* | (Name '-&gt;' TERMULA)*) ')'
  Equal         &nbsp;::= TERMULA '=' TERMULA
  Member        &nbsp;::= TERMULA '#' TERMULA
  Subclass      &nbsp;::= TERMULA '##' TERMULA
  Frame         &nbsp;::= TERMULA '[' (TERMULA '-&gt;' TERMULA)* ']'
  TERMULA       &nbsp;::= IRIMETA? CONNECTIVE '(' TERMULA* ')' |
                     IRIMETA? QUANTIFIER '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? TERMULA '@' MODULEREF |
                     TERM
  TERM          &nbsp;::= IRIMETA? (Var | EXPRIC | List |
                               'External' '(' EXPRIC LOCATOR? ')' |
                               AGGREGATE | NEWTERM)
  EXPRIC        &nbsp;::= Const | Expr | Equal | Member | Subclass | Frame
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  AGGREGATE     &nbsp;::= AGGRFUNC '{' Var ('[' Var+ ']')? '|' FORMULA '}'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  MODULEREF     &nbsp;::= Var | Const | Expr
  CONNECTIVE    &nbsp;::= 'And' | 'Or' | NEWCONNECTIVE
  QUANTIFIER    &nbsp;::= ('Exists' | 'Forall' | NEWQUANTIFIER) Var*
  AGGRFUNC      &nbsp;::= 'Min' | 'Max' | 'Sum' | 'Prod' | 'Avg' | 'Count' |
                     'Set' | 'Bag' | NEWAGGRFUNC
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
  LOCATOR       &nbsp;::= ANGLEBRACKIRI
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= NCName | '"' UNICODESTRING '"'
  
  IRIMETA       &nbsp;::= '(*' Const? (Frame | 'And' '(' Frame* ')')? '*)'


    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  
  &lt;xs:group name="FORMULA"&gt;  
    &lt;!--
                              'Implies' omitted from Baseline schema, allowing its modular use 
  FORMULA       &nbsp;::= IRIMETA? CONNECTIVE '(' FORMULA* ')' |
                     IRIMETA? QUANTIFIER '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA?  FORMULA '@' MODULEREF
                     FORM
  CONNECTIVE    &nbsp;::= 'And' | 'Or' | NEWCONNECTIVE
  QUANTIFIER    &nbsp;::= ('Exists' | 'Forall' | NEWQUANTIFIER) Var* 
             rewritten as
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'NEWCONNECTIVE' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var* '(' FORMULA ')' |
                     IRIMETA? 'Forall' Var* '(' FORMULA ')' |
                     IRIMETA? 'NEWQUANTIFIER' Var* '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA? 'Remote' '(' FORMULA MODULEREF ')'
                     FORM
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element name="And" type="And-FORMULA.type"/&gt;
      &lt;xs:element name="Or" type="Or-FORMULA.type"/&gt;
      &lt;xs:element name="NEWCONNECTIVE" type="NEWCONNECTIVE-FORMULA.type"/&gt;
      &lt;xs:element name="Exists" type="Exists-FORMULA.type"/&gt;
      &lt;xs:element name="Forall" type="Forall-FORMULA.type"/&gt;
      &lt;xs:element name="NEWQUANTIFIER" type="NEWQUANTIFIER-FORMULA.type"/&gt;    
      &lt;xs:element name="Neg" type="Neg-FORMULA.type"/&gt;
      &lt;xs:element name="Naf" type="Naf-FORMULA.type"/&gt;
      &lt;xs:element name="Remote" type="Remote-FORMULA.type"/&gt;
      &lt;xs:group ref="FORM"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:complexType name="And-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Or-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="NEWCONNECTIVE-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="Exists-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="formula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Forall-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="formula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="NEWQUANTIFIER-FORMULA.type"&gt;
  &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="formula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Neg-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="formula" minOccurs="1" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Naf-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="formula" minOccurs="1" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Remote-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="formula"/&gt;
      &lt;xs:element ref="internal"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="internal"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="External-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom | Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORMULA.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom | Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="Atom"/&gt;
        &lt;xs:element ref="Frame"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="formula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="declare"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Var"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="FORM"&gt;  
    &lt;!--
  FORM          &nbsp;::= IRIMETA? (Var | ATOMIC |
                               'External' '(' ATOMIC LOCATOR? ')')
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Var"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
      &lt;xs:element name="External" type="External-FORM.type"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:complexType name="External-FORM.type"&gt;
    &lt;!-- sensitive to FORM (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORM.type"/&gt;
      &lt;xs:element ref="location" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORM.type"&gt;
    &lt;!-- sensitive to FORM (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="ATOMIC"&gt;
    &lt;!--
  ATOMIC        &nbsp;::= Const | Atom | Equal | Member | Subclass | Frame
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Const"/&gt;
      &lt;xs:element ref="Atom"/&gt;
      &lt;xs:element ref="Equal"/&gt;
      &lt;xs:element ref="Member"/&gt;
      &lt;xs:element ref="Subclass"/&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Atom"&gt;
    &lt;!--
  Atom          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  
  &lt;xs:group name="UNITERM"&gt;
    &lt;!--
  UNITERM       &nbsp;::= TERMULA '(' (TERMULA* | (Name '-&gt;' TERMULA)*) ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="args" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element name="slot" type="slot-UNITERM.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="op"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="args"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-UNITERM.type"&gt;
    &lt;!-- sensitive to UNITERM (Name) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Name"/&gt;
      &lt;xs:group ref="TERMULA"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="Equal"&gt;
    &lt;!--
  Equal         &nbsp;::= TERMULA '=' TERMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="left"/&gt;
        &lt;xs:element ref="right"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="left"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="right"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Member"&gt;
    &lt;!--
  Member        &nbsp;::= TERMULA '#' TERMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="instance"/&gt;
        &lt;xs:element ref="class"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Subclass"&gt;
    &lt;!--
  Subclass      &nbsp;::= TERMULA '##' TERMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sub"/&gt;
        &lt;xs:element ref="super"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="instance"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="class"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sub"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="super"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="Frame"&gt;
    &lt;!--
  Frame         &nbsp;::= TERMULA '[' (TERMULA '-&gt;' TERMULA)* ']'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="object"/&gt;
        &lt;xs:element name="slot" type="slot-Frame.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="object"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-Frame.type"&gt;
    &lt;!-- sensitive to Frame (TERMULA) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERMULA"/&gt;
      &lt;xs:group ref="TERMULA"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="TERMULA"&gt;  
    &lt;!--
                              'Implies' omitted from Baseline schema, allowing its modular use
  TERMULA       &nbsp;::= IRIMETA? CONNECTIVE '(' TERMULA* ')' |
                     IRIMETA? QUANTIFIER '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? TERMULA '@' MODULEREF |
                     TERM
  CONNECTIVE    &nbsp;::= 'And' | 'Or' | NEWCONNECTIVE
  QUANTIFIER    &nbsp;::= ('Exists' | 'Forall' | NEWQUANTIFIER) Var* 
             rewritten as
  TERMULA       &nbsp;::= IRIMETA? 'And' '(' TERMULA* ')' |
                     IRIMETA? 'Or' '(' TERMULA* ')' |
                     IRIMETA? 'NEWCONNECTIVE' '(' TERMULA* ')' |
                     IRIMETA? 'Exists' Var* '(' TERMULA ')' |
                     IRIMETA? 'Forall' Var* '(' TERMULA ')' |
                     IRIMETA? 'NEWQUANTIFIER' Var* '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? 'Remote' '(' TERMULA MODULEREF ')'
                     TERM
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element name="And" type="And-TERMULA.type"/&gt;
      &lt;xs:element name="Or" type="Or-TERMULA.type"/&gt;
      &lt;xs:element name="NEWCONNECTIVE" type="NEWCONNECTIVE-TERMULA.type"/&gt;
      &lt;xs:element name="Exists" type="Exists-TERMULA.type"/&gt;
      &lt;xs:element name="Forall" type="Forall-TERMULA.type"/&gt;
      &lt;xs:element name="NEWQUANTIFIER" type="NEWQUANTIFIER-TERMULA.type"/&gt;    
      &lt;xs:element name="Neg" type="Neg-TERMULA.type"/&gt;
      &lt;xs:element name="Naf" type="Naf-TERMULA.type"/&gt;
      &lt;xs:element name="Remote" type="Remote-TERMULA.type"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:complexType name="And-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="termula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Or-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="termula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="NEWCONNECTIVE-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="termula" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="Exists-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="termula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Forall-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="termula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="NEWQUANTIFIER-TERMULA.type"&gt;
  &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="termula"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Neg-TERMULA.type"&gt;
    &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="termula" minOccurs="1" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Naf-TERMULA.type"&gt;
    &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="termula" minOccurs="1" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Remote-TERMULA.type"&gt;
    &lt;!-- sensitive to TERMULA context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="termula"/&gt;
      &lt;xs:element ref="internal"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="termula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="TERM"&gt;  
    &lt;!--
  TERM          &nbsp;::= IRIMETA? (Var | EXPRIC | List |
                               'External' '(' EXPRIC LOCATOR? ')' |
                               AGGREGATE | NEWTERM)
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Var"/&gt;
      &lt;xs:group ref="EXPRIC"/&gt;
      &lt;xs:element ref="List"/&gt;
      &lt;xs:element name="External" type="External-TERM.type"/&gt;
      &lt;xs:element ref="AGGREGATE"/&gt;
      &lt;xs:element ref="NEWTERM"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="List"&gt;  
    &lt;!--
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
             rewritten as
  List          &nbsp;::= 'List' '(' LISTELEMENTS? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:group ref="LISTELEMENTS" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="LISTELEMENTS"&gt;
    &lt;!--
  LISTELEMENTS  &nbsp;::= TERM+ ('|' TERM)?
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="items"/&gt;
      &lt;xs:element ref="rest" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="items"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="rest"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="External-TERM.type"&gt;
    &lt;!-- sensitive to TERM (EXPRIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-TERM.type"/&gt;
      &lt;xs:element ref="location" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-TERM.type"&gt;
    &lt;!-- sensitive to TERM (EXPRIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="EXPRIC"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="EXPRIC"&gt;
    &lt;!--
  EXPRIC        &nbsp;::= Const | Expr | Equal | Member | Subclass | Frame
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Const"/&gt;
      &lt;xs:element ref="Expr"/&gt;
      &lt;xs:element ref="Equal"/&gt;
      &lt;xs:element ref="Member"/&gt;
      &lt;xs:element ref="Subclass"/&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="Expr"&gt;
    &lt;!--
  Expr          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="AGGREGATE" abstract="true"&gt;
    &lt;!--
  AGGREGATE     &nbsp;::= AGGRFUNC '{' Var ('[' Var+ ']')? '|' FORMULA '}'
  AGGRFUNC      &nbsp;::= 'Min' | 'Max' | 'Sum' | 'Prod' | 'Avg' | 'Count' |
                     'Set' | 'Bag' | NEWAGGRFUNC
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="2" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="formula"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="Min" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Max" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Sum" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Prod" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Avg" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Count" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Set" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="Bag" substitutionGroup="AGGREGATE"/&gt;
  &lt;xs:element name="NEWAGGRFUNC" substitutionGroup="AGGREGATE"/&gt;
 
  &lt;xs:element name="NEWTERM"&gt;
    &lt;!--
    This uses the XSD wildcard schema component, any, allowing a NEWTERM
    to have zero or more child elements (role tags).
    --&gt;
    &lt;xs:complexType&gt;
     &lt;xs:sequence&gt;
      &lt;xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/&gt;
     &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt; 
 
  &lt;xs:element name="Const"&gt;
    &lt;!--
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" type="xs:anyURI" use="required"/&gt; 
      &lt;xs:attribute ref="xml:lang"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Name" type="xs:string"&gt;
    &lt;!--
  Name&nbsp;::= NCName | '"' UNICODESTRING '"'
  ... i.e., 'Name' stands for either the NCName string or the UNICODESTRING with the outer quotes stripped off.
     --&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Var"&gt;
    &lt;!--
  Var           &nbsp;::= '?' Name
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:group name="IRIMETA"&gt;
    &lt;!--
  IRIMETA  &nbsp;::= '(*' Const? (Frame | 'And' '(' Frame* ')')? '*)'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="id" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="meta" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="id"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Const"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="meta"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="Frame"/&gt;
       &lt;xs:element name="And" type="And-meta.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="And-meta.type"&gt;
  &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-meta.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-meta.type"&gt;
    &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="IRICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/id context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2007/rif#iri"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="location" type="xs:anyURI"/&gt;
 
 &lt;/xs:schema&gt;
</pre>
<a id="Skyline_Schema_Module" name="Skyline_Schema_Module"></a><h3> <span class="mw-headline">8.2  Skyline Schema Module </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: FLDSkyline.xsd, v. 1.5, 2010-02-02, hboley/dhirtle"&gt;
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
 
    This is the Skyline schema module of FLD. It is split off from the Baseline
    schema for modularity. The Skyline XML schema is based on the following EBNF
    (which adds Group and Document, and brings 'Implies' into FORMULA and TERMULA):
 
  Document      &nbsp;::= IRIMETA? 'Document' '(' Dialect? Base? Prefix* Import* Module* Group? ')'
  Dialect       &nbsp;::= 'Dialect' '(' Name ')'
  Base          &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'  
  Prefix        &nbsp;::= 'Prefix' '(' NCName ANGLEBRACKIRI ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Module        &nbsp;::= IRIMETA? 'Module' '(' (Const | Expr) LOCATOR ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (FORMULA | Group)* ')'
  Implies       &nbsp;::= IRIMETA? FORMULA ':-' FORMULA
  FORMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' FORMULA* ')' |
                     IRIMETA? QUANTIFIER '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA?  FORMULA '@' MODULEREF |
                     FORM
  TERMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' TERMULA* ')' |
                     IRIMETA? QUANTIFIER '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? TERMULA '@' MODULEREF |
                     TERM
  PROFILE       &nbsp;::= ANGLEBRACKIRI
      
    Note that this is an extension of the syntax for the Baseline schema (FLDBaseline.xsd).
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
 
  &lt;!--
   The Skyline schema extends, with Implies, the FORMULA and TERMULA groups
   of the Baseline schema from the same directory
    --&gt;
  &lt;xs:redefine schemaLocation="FLDBaseline.xsd"&gt;
    &lt;!--
  FORMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' FORMULA* ')' |
                     IRIMETA? QUANTIFIER '(' FORMULA ')' |
                     IRIMETA? 'Neg' FORMULA |
                     IRIMETA? 'Naf' FORMULA |
                     IRIMETA?  FORMULA '@' MODULEREF |
                     FORM
  TERMULA       &nbsp;::= Implies |
                     IRIMETA? CONNECTIVE '(' TERMULA* ')' |
                     IRIMETA? QUANTIFIER '(' TERMULA ')' |
                     IRIMETA? 'Neg' TERMULA |
                     IRIMETA? 'Naf' TERMULA |
                     IRIMETA? TERMULA '@' MODULEREF |
                     TERM
    --&gt;
    &lt;xs:group name="FORMULA"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="FORMULA"/&gt;
        &lt;xs:element ref="Implies"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;
    &lt;xs:group name="TERMULA"&gt;
      &lt;xs:choice&gt;
        &lt;xs:group ref="TERMULA"/&gt;
        &lt;xs:element ref="Implies"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:group&gt;
  &lt;/xs:redefine&gt;
 
  &lt;xs:element name="Document"&gt;
    &lt;!--
  Document      &nbsp;::= IRIMETA? 'Document' '(' Dialect? Base? Prefix* Import* Module* Group? ')'
  Dialect       &nbsp;::= 'Dialect' '(' Name ')'  represented with a dialect attribute.
  Base and Prefix represented directly in XML.
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
	&lt;xs:element ref="directive" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="payload" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="dialect" type="xs:string"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="directive"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="DIRECTIVE-IMPORT"/&gt;
       &lt;xs:element ref="DIRECTIVE-MODULE"/&gt;
     &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;

 &lt;xs:element name="DIRECTIVE-IMPORT"&gt;
   &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Import"/&gt;
    &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;

 &lt;xs:element name="DIRECTIVE-MODULE"&gt;
   &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Module"/&gt;
    &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;

  &lt;xs:element name="payload"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Group"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Import"&gt;
    &lt;!--
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element ref="location"/&gt;
        &lt;xs:element ref="profile" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Module"&gt;
    &lt;!--
  Module        &nbsp;::= IRIMETA? 'Module' '(' (Const | Expr) LOCATOR ')'
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:choice&gt;
          &lt;xs:element ref="Const"/&gt;
          &lt;xs:element ref="Expr"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:element ref="location"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="profile" type="xs:anyURI"/&gt;
  
  &lt;xs:element name="Group"&gt;
    &lt;!--
  Group         &nbsp;::= IRIMETA? 'Group' '(' (FORMULA | Group)* ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sentence" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="sentence"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="FORMULA"/&gt;
       &lt;xs:element ref="Group"/&gt;
     &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;
    
 &lt;xs:element name="Implies"&gt;
    &lt;!--
  Implies       &nbsp;::= IRIMETA? FORMULA ':-' FORMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="if"/&gt;
        &lt;xs:element ref="then"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="if"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="then"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
   
 &lt;/xs:schema&gt;
</pre>
<div id="changelog">
<p><br />
</p><p><br />
<span class="anchor" id="appendix-herbrand-structures"></span>
</p>
<a id="Appendix:_A_Subframework_for_Herbrand_Semantic_Structures" name="Appendix:_A_Subframework_for_Herbrand_Semantic_Structures"></a><h2> <span class="mw-headline">9  Appendix: A Subframework for Herbrand Semantic Structures </span></h2>
<p>The semantics of most languages in Logic Programming, including the well-founded semantics [<a href="#ref-wf-model" title="">GRS91</a>,<a href="#ref-przymusinski-stationary" title="">Prz94</a>] and the answer set (or stable model) semantics [<a href="#ref-stable-model" title="">GL88</a>,<a href="#ref-ASP-91" title="">GL91</a>,<a href="#ref-gelfond-leone" title="">GLe02</a>] are defined with respect to <i>Herbrand semantic structures</i> [<a href="#ref-chang-lee" title="">CL73</a>]. This appendix introduces the concepts of Herbrand Universe, Herbrand Structures, and related notions in the context of RIF-FLD in order to facilitate specializations of the RIF logical framework to logic programming dialects.
</p><p>A RIF-FLD semantic structure, &nbsp; <i><b>I</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>connective</sub>, <i><b>I</b></i><sub>truth</sub>&gt;&nbsp;
is <i>Herbrand</i> if its domain, <i><b>D</b></i>, is Herbrand and the mappings <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>connective</sub>, <i><b>I</b></i><sub>truth</sub> satisfy certain conditions. The definitions, below, will make this statement precise.
</p><p>In what follows, we will be calling any variable-free term a <i><b>ground</b></i> term.  
</p><p><br />
<span class="anchor" id="def-herbrand-domain"></span>
<b>Definition (Herbrand Universe and Domain).</b>
Given a <a href="#sec-fld-language" title="">language of RIF-FLD</a>,
a <i><b>Herbrand RIF-FLD universe</b></i>, <i><b>HU</b></i>, is a set consisting of all the ground <a href="#def-fld-well-formed-term" title="">well-formed terms</a> defined by RIF-FLD except the aggregate terms, external terms, and remote term references.
</p><p>Given a semantic structure <i><b>I</b></i>, as above, we say that it has a <i><b>Herbrand RIF-FLD domain</b></i> if <i><b>D</b></i> (its domain) is a factor <i><b>HU</b></i>/ <i>E</i>, i.e., the set of all equivalence classes, of the elements in <i><b>HU</b></i> with respect to an equivalence relation, <i>E</i>, which is defined as the minimal relation that satisfies the following condition: 
</p>
<ul>      
  <li>
    If <i>s,t</i> <tt>&isin;</tt> <i><b>HU</b></i> and <i>TVal<sub>I</sub></i>(<tt>s=t</tt>) = <b>t</b> then (<tt>s</tt>,<tt>t</tt>) <tt>&isin;</tt>  <i>E</i>.       
  </li>
</ul>
<p>
  We will use the symbol  <i><b>HD</b></i> to denote Herbrand domains. &nbsp;&nbsp; ☐
</p>
<p>
Note that the general properties of <i>TVal<sub>I</sub></i> in semantic structures (Definition <a href="#def-fld-truth" title="">Truth valuation</a>) also imply that:
</p>
<ul>
  <li>	
    If <i>s,t</i> <tt>&isin;</tt> <i><b>HU</b></i> are terms with named arguments that differ only in the order of the arguments then (<tt>s</tt>,<tt>t</tt>) <tt>&isin;</tt> <i>E</i>.
  </li>
  <li>	
    If <i>s,t</i> <tt>&isin;</tt> <i><b>HU</b></i> are frame terms that differ only in the order of their attribute/value pairs then (<tt>s</tt>,<tt>t</tt>) <tt>&isin;</tt> <i>E</i>.
  </li>
</ul>
<p><span class="anchor" id="def-herbrand-semantic-structure"></span>
<b>Definition (Herbrand Semantic Structure).</b> A RIF-FLD semantic structure <i><b>I</b></i> of the above form is a <i><b>Herbrand RIF-FLD semantic structure</b></i> iff:
</p>
<ul>      
  <li>
    It has a Herbrand RIF-FLD domain <i><b>HD</b></i>.
  </li>
  <li>
    The <a href="#def-term-interpreting-map" title="">term-interpreting mapping</a> <i><b>I</b></i> is such that it maps every ground term in <i><b>HU</b></i> to its equivalence class in <i><b>HD</b></i>.
    <p>
       This mapping implicitly also defines the subdomains of <i><b>HD</b></i>, which correspond to the various signatures and are defined earlier -- see <a href="#the-effect-of-signatures" title="">the effect of signatures</a> on the semantics. Namely, for any signature <tt>sg</tt>, its subdomain <i><b>HD</b></i><sub><tt>sg</tt></sub> <tt>&sube;</tt> <i><b>HD</b></i> is precisely the set {<i><b>I</b></i>(<tt>t</tt>)| <tt>t</tt> is a well-formed term that has <tt>sg</tt> as one of its signatures}.
    </p>
  </li>
</ul>
<p>RIF-FLD <a href="#def-fld-semantic-multistruct" title="">semantic multi-structures</a> that are built out of Herbrand RIF-FLD semantic structures will be called <i><b>Herbrand RIF-FLD semantic multi-structures</b></i>. &nbsp;&nbsp; ☐
</p><p>Logic programming dialects often use the following notion of <i>minimal</i> Herbrand RIF-FLD models.
</p><p><span class="anchor" id="def-minimal-model"></span>
<b>Definition (Minimal Model with Respect to the Truth Order).</b> Let <b>&Gamma;</b> be a <i>ground</i> RIF-FLD document.  A Herbrand RIF-FLD semantic multi-structure <i><b>&Icirc;</b></i> that is a model of <b>&Gamma;</b> is said to be a <i><b>minimal model in the truth order</b></i> &lt;<sub>t</sub>  of <b>&Gamma;</b> if there is no other Herbrand RIF-FLD model <i><b>&Icirc;'</b></i> of <b>&Gamma;</b> such that:
</p>
<ul>      
  <li>
    <i>TVal</i><sub>&Icirc;'</sub>(<tt>&phi;</tt>) = <b>t</b>
    &nbsp; implies &nbsp;
    <i>TVal</i><sub>&Icirc;</sub>(<tt>&phi;</tt>) = <b>t</b>
    &nbsp; and 
  </li>
  <li>
    <i>TVal</i><sub>&Icirc;</sub>(<tt>&phi;</tt>) = <b>f</b> 
    &nbsp; implies &nbsp;
    <i>TVal</i><sub>&Icirc;'</sub>(<tt>&phi;</tt>) = <b>f</b>
  </li>
</ul>
<p>
  for every formula <tt>&phi;</tt> of the form <tt>L</tt> or <tt>Neg L</tt>, where <tt>L</tt> is a ground atomic formula. Dialects may further specialize this notion by imposing additional restrictions. &nbsp;&nbsp; ☐
</p>
<p>Least semantic structures, defined below, are often used in the definitions of various fixpoint operators as starting points of the iteration process that computes the least fixpoint.
</p><p><span class="anchor" id="def-least-herb-struct"></span>
<b>Definition (Least Herbrand Structure with Respect to the Truth Order).</b> A Herbrand RIF-FLD semantic structure <i><b>I</b></i> is said to be the <i><b>least</b></i> in the truth order iff <i><b>I</b></i><sub>true</sub> maps every element of the Herbrand domain to <b>f</b> except for those elements that correspond to tautological formula terms (for example, <tt>And()</tt>)  -- these are mapped to <b>t</b>. Dialects might have additional requirements. For example, some elements of the Herbrand domain might be "tautologically undefined," i.e., always mapped to <b>u</b>. &nbsp;&nbsp; ☐
</p><p>The standard definitions of the well-founded semantics typically employ so-called "empty" semantic structures -- structures where everything that <i>can</i> be undefined is undefined. The following definition adapts this concept to RIF-FLD. It applies to dialects that have a special undefinedness truth value <b>u</b> such that <b>f</b> &lt;<sub>t</sub> <b>u</b> &lt;<sub>t</sub> <b>t</b>. The usual general definition for <b>u</b> is that it is the smallest element in <i><b>TV</b></i> with respect to the  <i>knowledge order</i> &lt;<sub>k</sub> -- an order on the sets of truth values, which is sometimes used in addition to the truth order [<a href="#ref-fitting02" title="">Fit02</a>]. In many cases, however, the mention of &lt;<sub>k</sub> is omitted as, for example, in the case of the well-founded semantics (where it is implicitly assumed that <b>u</b> &lt;<sub>k</sub> <b>f</b> and <b>u</b> &lt;<sub>k</sub> <b>t</b>) and in the case of stable models (where &lt;<sub>k</sub> is an empty relation).
</p><p><span class="anchor" id="def-empty-herb-struct"></span>
<b>Definition (Empty Herbrand Structure).</b> Let <i><b>I</b></i> be a Herbrand RIF-FLD semantic structure with the set of truth values <i><b>TV</b></i> that has a special undefinedness truth value <b>u</b> such that <b>f</b> &lt;<sub>t</sub> <b>u</b> &lt;<sub>t</sub> <b>t</b>. Then <i><b>I</b></i> is said to be <i><b>empty</b></i> iff <i><b>I</b></i><sub>true</sub> maps everything to <b>u</b> except for the elements of the Herbrand domain that correspond to tautological formula terms (for example, <tt>And()</tt>), which are mapped to <b>t</b>; and elements of the domain that correspond to unsatisfiable formulas (e.g., <tt>Or()</tt>), which are mapped to <b>f</b>. Dialects may have additional requirements. For example, some elements of the Herbrand domain might always have some other truth values specific to the particular dialects.  &nbsp;&nbsp; ☐
</p><p><br />
The above concepts were defined exclusively of ground RIF-FLD documents, but practically interesting RIF documents are usually non-ground. A typical mechanism by which non-ground documents are reduced to the ground ones is called <i>ground instantiation</i>. It applies only to <i>universal</i> RIF-FLD documents.
</p><p><span class="anchor" id="def-universal-document"></span>
<b>Definition (Universal RIF-FLD Document).</b>
A RIF-FLD document is <i><b>universal</b></i> if it has the form  <tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> &Gamma;)</tt> or  <tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em>)</tt>. In the former case, when the group formula <tt>&Gamma;</tt> is present, <tt>&Gamma;</tt> must be a <i>universal formula</i>.
</p><p>A non-group, non-document formula is <i><b>universal</b></i> if it has the form <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&eta;)</tt>, where <tt>&eta;</tt> has no quantifiers and all of its variables are among <tt>?V<sub>1</sub> ...&nbsp;?V<sub>n</sub></tt>. A group formula <tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt> is <i><b>universal</b></i> if either <tt>n=0</tt> (i.e., it is an empty group formula) or each <tt>&phi;<sub>i</sub></tt> is universal.
&nbsp;&nbsp; ☐
</p><p>Ground instantiations are now defined as follows.
</p><p><span class="anchor" id="def-ground-instantiation"></span>
<b>Definition (Ground Instantiations).</b> Let <b>&Gamma;</b> be a <a href="#def-universal-document" title="">universal RIF-FLD document</a>. Its <i><b>ground instantiation</b></i> is a set of RIF-FLD documents obtained from <b>&Gamma;</b> by replacing every RIF-FLD non-group formula in <b>&Gamma;</b> that is a direct subformula of a group formula with the set of all their <i>ground instances</i>.  
</p><p>A universal formula <tt>&phi;</tt> is said to be a <i><b>ground instance</b></i> of another formula, <tt>&psi;</tt>, if and only if <tt>&phi;</tt> is obtained from <tt>&psi;</tt> by a <i>coherent</i> replacement of variables with ground terms in <i><b>HU</b></i>. Coherence here means that, while constructing <tt>&phi;</tt> from <tt>&psi;</tt>, the same variables are always substituted with the same terms. (Note: <i><b>I</b></i><sub>V</sub>(<tt>&psi;</tt>) is a ground instance of <tt>&psi;</tt>, but there can be many others, since variables can be mapped to arbitrary ground terms in <i><b>HU</b></i>.)  &nbsp;&nbsp; ☐
</p><p><br />
Note that according to the definition of the <a href="#def-fld-truth" title="">truth valuation</a>, <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) =  ~<i>TVal</i><sub>I</sub>(<tt>Naf &phi;</tt>),  i.e., when <tt>&phi;</tt> is true then <tt>Naf &phi;</tt> is false, and vice versa (and, for example, when one is undefined in three-valued semantics then so is the other). However, RIF-FLD imposes no constraints on <tt>Neg &phi;</tt>. Many logic programming theories require <i>consistency</i> of the Herbrand models, and the following definition is provided for the use by the corresponding dialects. However, the definitions in this section do not rely on this consistency assumption.
</p><p><span class="anchor" id="def-consistent-semantic-structure"></span>
<b>Definition (Consistent Semantic Structure).</b> A Herbrand RIF-FLD semantic structure <i><b>I</b></i> is said to be <i><b>consistent</b></i> if <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>)  and <i>TVal</i><sub>I</sub>(<tt>Neg &phi;</tt>) are not both <b>t</b> (which is equivalent to saying that <i><b>I</b></i><sub>true</sub>(<i><b>I</b></i>(<tt>&phi;</tt>)) and <i><b>I</b></i><sub>true</sub>(<i><b>I</b></i>(<tt>Neg &phi;</tt>)) are not both <b>t</b>). However, they can both be <b>f</b> (or, for example, <b>u</b>, in three-valued dialects). A semantic multi-structure is consistent if all its component semantic structures are consistent. &nbsp;&nbsp; ☐
</p>
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">10  Appendix: Change Log (Informative) </span></h2>
<p>This appendix summarizes the main changes to this document.
</p><p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/WD-rif-fld-20090703/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-rif-fld-20090703/">draft of July 3, 2009</a>.
</p>
<ul><li> "All RIF dialects are expected to support certain symbols spaces" was added.
</li><li> "instance" of an external schema was replaced with "instantiation" of an external schema.
</li><li> More examples were added; some examples were better explained.
</li><li> IRICONST was replaced with ANYURICONST in FLDSkyline.xsd, v. 1.3.
</li><li> The xs:include was dropped and the two xs:redefine's merged in FLDSkyline.xsd, v. 1.4.
</li><li> A number of typos were found and fixed.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/CR-rif-fld-20091001/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-rif-fld-20091001/">Candidate Recommendation of October 1, 2009</a>.
</p>
<ul><li> Import's anyURIs were moved directly into location and profile.
</li><li> Appendix on <a href="#appendix-herbrand-structures" title="">Herbrand Semantic Structures</a> was added.
</li><li> Several typos fixed and clarifications added.
</li><li> Fixed List by permitting IRIMETA and aligning syntax to Expr and Atom.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/rif-fld" rel="nofollow" title="http://www.w3.org/TR/rif-fld">Recommendation of June 22 2010</a>.
</p>
<ul><li> Added anti-monotonicity requerement for <tt>~</tt> in <a href="#def-fld-truth-value" title="">Definition (set of truth values)</a>.
</li><li> Changed <a href="#def-fld-truth-documents" title="">Definition (truth valuation of document formulas)</a> to define truth valuation of not only document formulas but other formulas as well.
</li><li> Acknowledgements added.
</li><li> The old notion of semantic multi-structures has been changed to fix the problems with the semantics of document formulas found in <a class="external text" href="http://www.w3.org/TR/rif-fld" rel="nofollow" title="http://www.w3.org/TR/rif-fld">Recommendation of June 22 2010</a>. These problems were pointed out in [<a href="#ref-rif-modularity" title="">DAA</a>]. As a result, sections <a href="#sec-interpretation-of-documents" title="">Interpretation of Documents</a> and <a href="#sec-logical-entailment" title="">Logical Entailment</a> have largely been rewritten.
</li><li> Two new rows added in the table of Section <a href="#Mapping_of_the_Non-annotated_RIF-FLD_Language" title="">Mapping of the Non-annotated RIF-FLD Language</a> for empty args in Atom and Expr; restriction of earlier Atom and Expr rows to non-empty args (replaced n with m).
</li><li> Other minor corrections (see <a class="external text" href="http://www.w3.org/2005/rules/wiki/index.php?title=FLD&amp;diff=14355&amp;oldid=12719" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/index.php?title=FLD&amp;diff=14355&amp;oldid=12719">here</a> and <a class="external text" href="http://www.w3.org/2005/rules/wiki/index.php?title=FLD&amp;diff=14584&amp;oldid=14451" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/index.php?title=FLD&amp;diff=14584&amp;oldid=14451">here</a>).
</li></ul>
</div>
</div></div>


</body>
</html>