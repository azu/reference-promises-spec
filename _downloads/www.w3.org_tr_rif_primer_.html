<!-- http://www.w3.org/TR/rif-primer/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF Primer (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-WG-NOTE" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF Primer (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Working Group Note 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/" id="this-version-url">http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-primer/">http://www.w3.org/TR/rif-primer/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/NOTE-rif-primer-20121211/">http://www.w3.org/TR/2012/NOTE-rif-primer-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Leora Morgenstern, SAIC</dd>
<dd>Chris Welty, IBM Research</dd>
<dd>Harold Boley, National Research Council Canada</dd>
<dd>Gary Hallmark, Oracle</dd>
</dl>



<p>A <a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/NOTE-rif-primer-20130205.pdf">PDF version</a>.</p>



<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>This document is a primer on the Rule Interchange Format (RIF). The primer provides a practical introduction to specifying declarative rules and production rules in RIF, in particular for the RIF BLD and PRD dialects. Examples of RIF specifications are developed in a stepwise manner.</p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a>  (this document)</li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/NOTE-rif-primer-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="no-endorsement">No Endorsement</h4>
    
<p><em>Publication as a Working Group Note does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure"> section 6 of the W3C Patent Policy</a>.</em></p>

<hr title="Separator After Status Section" />


<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2"><a href="#What_is_a_rule.3F"><span class="tocnumber">1.1</span> <span class="toctext">What is a rule?</span></a></li>
<li class="toclevel-2"><a href="#What_is_RIF.3F"><span class="tocnumber">1.2</span> <span class="toctext">What is RIF?</span></a></li>
<li class="toclevel-2"><a href="#What_this_document_does_and_doesn.27t_cover"><span class="tocnumber">1.3</span> <span class="toctext">What this document does and doesn't cover</span></a></li>
<li class="toclevel-2"><a href="#A_note_on_syntax"><span class="tocnumber">1.4</span> <span class="toctext">A note on syntax</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#A_Simple_Example_in_RIF"><span class="tocnumber">2</span> <span class="toctext">A Simple Example in RIF</span></a>
<ul>
<li class="toclevel-2"><a href="#Example_Background"><span class="tocnumber">2.1</span> <span class="toctext">Example Background</span></a></li>
<li class="toclevel-2"><a href="#Developing_the_Example"><span class="tocnumber">2.2</span> <span class="toctext">Developing the Example</span></a>
<ul>
<li class="toclevel-3"><a href="#Atomic_Formulas:_Basic_Facts"><span class="tocnumber">2.2.1</span> <span class="toctext">Atomic Formulas: Basic Facts</span></a></li>
<li class="toclevel-3"><a href="#Constants_and_Variables"><span class="tocnumber">2.2.2</span> <span class="toctext">Constants and Variables</span></a></li>
<li class="toclevel-3"><a href="#Conjunctions_and_Implications"><span class="tocnumber">2.2.3</span> <span class="toctext">Conjunctions and Implications</span></a></li>
<li class="toclevel-3"><a href="#Quantifiers"><span class="tocnumber">2.2.4</span> <span class="toctext">Quantifiers</span></a></li>
<li class="toclevel-3"><a href="#IRIs_.28Internationalized_Resource_Identifiers.29"><span class="tocnumber">2.2.5</span> <span class="toctext">IRIs (Internationalized Resource Identifiers)</span></a></li>
<li class="toclevel-3"><a href="#Structuring_Operators"><span class="tocnumber">2.2.6</span> <span class="toctext">Structuring Operators</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Putting_the_pieces_together:_example_rule_in_RIF"><span class="tocnumber">2.3</span> <span class="toctext">Putting the pieces together: example rule in RIF</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Two_Additional_Examples"><span class="tocnumber">3</span> <span class="toctext">Two Additional Examples</span></a>
<ul>
<li class="toclevel-2"><a href="#Second_Example:_Disjunctions.2C_Existentials.2C_Overloading_Predicate_Names"><span class="tocnumber">3.1</span> <span class="toctext">Second Example: Disjunctions, Existentials, Overloading Predicate Names</span></a></li>
<li class="toclevel-2"><a href="#Third_Example:_Using_Guards"><span class="tocnumber">3.2</span> <span class="toctext">Third Example: Using Guards</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Reasoning_in_RIF"><span class="tocnumber">4</span> <span class="toctext">Reasoning in RIF</span></a>
<ul>
<li class="toclevel-2"><a href="#Using_RIF_Rulesets"><span class="tocnumber">4.1</span> <span class="toctext">Using RIF Rulesets</span></a></li>
<li class="toclevel-2"><a href="#Reasoning_in_Declarative_Rule_Languages"><span class="tocnumber">4.2</span> <span class="toctext">Reasoning in Declarative Rule Languages</span></a></li>
<li class="toclevel-2"><a href="#Production_Rule_Languages:_Operational_Semantics"><span class="tocnumber">4.3</span> <span class="toctext">Production Rule Languages: Operational Semantics</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Datatypes_and_Built-ins"><span class="tocnumber">5</span> <span class="toctext">Datatypes and Built-ins</span></a>
<ul>
<li class="toclevel-2"><a href="#Datatypes_and_Built-ins_in_RIF"><span class="tocnumber">5.1</span> <span class="toctext">Datatypes and Built-ins in RIF</span></a></li>
<li class="toclevel-2"><a href="#Fourth_RIF_Example:_Using_datatypes_and_built-ins"><span class="tocnumber">5.2</span> <span class="toctext">Fourth RIF Example: Using datatypes and built-ins</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Extensions_to_RIF_Core:_Constructs_for_BLD_and_PRD"><span class="tocnumber">6</span> <span class="toctext">Extensions to RIF Core: Constructs for BLD and PRD</span></a>
<ul>
<li class="toclevel-2"><a href="#BLD_extensions_to_Core:_Functions.2C_Equality"><span class="tocnumber">6.1</span> <span class="toctext">BLD extensions to Core: Functions, Equality</span></a></li>
<li class="toclevel-2"><a href="#PRD_Extensions_to_RIF_Core:_Priorities.2C_Negation.2C_and_Knowledge_Base_Modification"><span class="tocnumber">6.2</span> <span class="toctext">PRD Extensions to RIF Core: Priorities, Negation, and Knowledge Base Modification</span></a>
<ul>
<li class="toclevel-3"><a href="#Priorities"><span class="tocnumber">6.2.1</span> <span class="toctext">Priorities</span></a></li>
<li class="toclevel-3"><a href="#Negation"><span class="tocnumber">6.2.2</span> <span class="toctext">Negation</span></a></li>
<li class="toclevel-3"><a href="#Knowledge_Base_Modification"><span class="tocnumber">6.2.3</span> <span class="toctext">Knowledge Base Modification</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Using_Frames_in_RIF"><span class="tocnumber">7</span> <span class="toctext">Using Frames in RIF</span></a>
<ul>
<li class="toclevel-2"><a href="#Example_Using_Frames"><span class="tocnumber">7.1</span> <span class="toctext">Example Using Frames</span></a></li>
<li class="toclevel-2"><a href="#Distinguishing_Slots_in_Object-Oriented_Languages_and_RIF"><span class="tocnumber">7.2</span> <span class="toctext">Distinguishing Slots in Object-Oriented Languages and RIF</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Compatibility_with_Other_Standards"><span class="tocnumber">8</span> <span class="toctext">Compatibility with Other Standards</span></a>
<ul>
<li class="toclevel-2"><a href="#Intercompatibility_of_RIF_and_RDF"><span class="tocnumber">8.1</span> <span class="toctext">Intercompatibility of RIF and RDF</span></a></li>
<li class="toclevel-2"><a href="#Intercompatibility_of_RIF_and_OWL"><span class="tocnumber">8.2</span> <span class="toctext">Intercompatibility of RIF and OWL</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#The_Test_Suite"><span class="tocnumber">9</span> <span class="toctext">The Test Suite</span></a></li>
<li class="toclevel-1"><a href="#Learning_More_about_RIF:_Next_Steps"><span class="tocnumber">10</span> <span class="toctext">Learning More about RIF: Next Steps</span></a></li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">11</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">13</span> <span class="toctext">Appendix: Change Log (Informative)</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Introduction" name="Introduction"></a><h2> <span class="mw-headline">1  Introduction </span></h2>
<a id="What_is_a_rule.3F" name="What_is_a_rule.3F"></a><h3> <span class="mw-headline">1.1  What is a rule? </span></h3>
<p>This document is meant to introduce computer professionals to basic techniques for writing declarative rules and production rules in the W3C Rule Interchange Format.
</p><p>The dictionary defines a rule as a prescribed guide for conduct or a regulation governing behavior such as "Keep off the grass" or "A driver receiving a traffic ticket must appear in traffic court on the assigned date."  In the computer science and logic programming communities, though, there are two different, but closely related ways to understand rules.  One is closely related to the idea of an instruction in a computer program: If a certain condition holds, then some action is carried out. Such rules are often referred to as <i>production rules</i>. An example of a production rule is "If a customer has flown more than 100,000 miles, then upgrade him to Gold Member status."
</p><p>Alternately, one can think of a rule as stating a fact about the world. These rules, often referred to as <i>declarative rules</i>, are understood to be sentences of the form "If P, then Q." An example of a declarative rule is "If a person is currently president of the United States of America, then his or her current residence is the White House."
</p><p>Declarative rules do not specify  an action  that is to be carried out. For example, the rule above makes a statement about the  relation between the U.S. president and the White House, but doesn't specify any action (say, to move the president into the White House).  In other words, a declarative rule describes how the world is, rather than prescribing how things ought to be.
</p><p>Production rules are frequently used for business applications. They typically incorporate an explicit notion of control to specify which rules are applied first. Declarative rules, on the other hand, are useful for writing down large amounts of information about a particular domain, or area of knowledge, independent of knowing, 'a priori', how these rules will eventually be used.
</p><p>For example, one could write down rules in the medical domain:
</p>
<ul>
<li><em>If John's rapid-strep test is positive, then he is infected with strep.</em>
</li>
<li><em>If John is infected with strep, then he needs to take antibiotics.</em>
</li>
</ul>
<p><br />
Rules (whether declarative or production rules) can also be used to reason with other information that we have. In the example above, we can infer another rule:
</p>
<ul>
<li>
<em>If John's rapid-strep test is positive, then he needs to take antibiotics.</em>
</li>
</ul>
<p>It is particularly useful to reason with rules and facts, pieces of concrete information that do not make use of the if-then construct. Examples of facts are:
</p>
<ul>
<li>
<em>
Elizabeth II became Queen of England in 1952.
</em>
</li>
<li> <em> The Bronx is a borough of New York City.</em> </li>
<li>
<em>John's rapid-strep test is positive.</em>
</li>
</ul>
<p>To continue the example above, the fact
</p>
<ul>
<li>
<em>John's rapid-strep test is positive</em>
</li>
</ul>
<p>can be combined with the rules above to yield the conclusion:
</p>
<ul>
<li>
<em>John needs to take antibiotics.</em>
</li>
</ul>
<p>Rules and facts must be written in some sort of formal language in order for computer programs to reason with and draw conclusions from them. Such a computer program is often called a <em>rule engine</em>.
</p>
<a id="What_is_RIF.3F" name="What_is_RIF.3F"></a><h3> <span class="mw-headline">1.2  What is RIF? </span></h3>
<p>There are many rule languages including SILK [<a href="#ref-grosof-2009" title="">GR09</a>], OntoBroker [<a href="#ref-deckeretal-1999" title="">DEFS99</a>], Eye [<a href="#ref-eulersharp-2010" title="">EULERSHARP10</a>], VampirePrime [<a href="#ref-riazanov-2009" title="">RZ09</a>], N3-Logic [<a href="#ref-bernersleeetal-2008" title="">BCKSH08</a>], and SWRL [<a href="#ref-swrl-2004" title="">SWRL-Ref</a>] (declarative rule languages); and Jess [<a href="#ref-friedmanhill-2003" title="">FH03</a>], Drools [<a href="#ref-bali-2009" title="">BA09</a>], IBM ILog [<a href="#ref-ilog-2010" title="">ILOG10</a>], and Oracle Business Rules [<a href="#ref-oracle-2010" title="">ORACLE10</a>] (production rule languages). Many languages incorporate features of both declarative and production rule language. For example,  Prolog [<a href="#ref-clocksin-mellish-2003a" title="">CM03</a>], which is generally considered to be a declarative rule language, provides a cut operator for controlling the application of rules. Moreover, all production rule languages have a core subset that is declarative.
</p><p>The abundance of rule sets in different languages can create difficulties if one wants to integrate rule sets, or import information from one rule set to another. How can a rule engine work with rule sets of different languages?
</p><p>The W3C Rule Interchange Format (RIF) [<a href="#ref-rif-overview" title="">RIF-Overview</a>] is a standard that was developed to facilitate ruleset integration and synthesis. It comprises a set of interconnected dialects representing rule languages with various features. This document focus on the most basic RIF language, RIF-Core [<a href="#ref-rif-core" title="">RIF-Core</a>], augmented by a set of datatypes and built-in functions and predicates that can be used when writing rules [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. All RIF dialects are an extension of RIF-Core plus DTB; we focus on two dialects, BLD and PRD.
</p>
<a id="What_this_document_does_and_doesn.27t_cover" name="What_this_document_does_and_doesn.27t_cover"></a><h3> <span class="mw-headline">1.3 What this document does and doesn't cover</span></h3>
<p>This document focuses on the Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>], and the Production Rule dialect [<a href="#ref-rif-prd" title="">PRD</a>], both of which are extensions of RIF-Core plus DTB.  [<a href="#ref-rif-fld" title="">RIF-FLD</a>] is not discussed in this document. 
</p><p>This document does not include a detailed discussion of  the semantics of any RIF dialect In particular, it does not discuss the model-theoretic semantics of BLD or the operational semantics of PRD. However, the document discusses the notions of assumption, consequence,
and pattern matching. An intuitive understanding of these notions should  enable a computer professional to
understand the Primer and to write rules in RIF. Reading the BLD document [<a href="#ref-rif-bld" title="">BLD</a>] and the PRD document [<a href="#ref-rif-prd" title="">PRD</a>]  is recommended for those who wish to learn more about, respectively, the model-theoretic and operational semantics used in RIF.
</p><p>While this Primer is targeted at getting computer professionals to quickly learn how to write rules in RIF, it does not provide a complete specification of syntax. There are some details of RIF syntax, specifically those that are not necessary for writing most rules in RIF, which are not covered in this document.  All syntactic details of RIF's logic dialects are covered in BLD, PRD, DTB, and FLD.
</p>
<a id="A_note_on_syntax" name="A_note_on_syntax"></a><h3> <span class="mw-headline">1.4 A note on syntax</span></h3>
<p>The standard syntax for RIF is a verbose XML syntax, designed so that programs can easily generate and parse it. For human readers and writers, we generally use terser syntaxes that have a simple 1-1 correspondence with the XML. Different dialects have introduced different compact syntaxes: for example, BLD uses a compact syntax called Presentation Syntax,  while PRD uses a compact syntax called Abstract Syntax. 
</p><p>One of the major stylistic differences between Presentation Syntax and Abstract Syntax is the way in which implications are written. In Presentation Syntax, an implication  <i>If A then B</i> is written as
</p>
<pre> B&nbsp;:- A
</pre>
<p>while in Abstract Syntax, this implication is written as 
</p>
<pre> If A Then B 
</pre>
<p>We will use this syntax style, referred to as Mixed Presentation Syntax (MPS) whether presenting examples of BLD or PRD.
</p>
<a id="A_Simple_Example_in_RIF" name="A_Simple_Example_in_RIF"></a><h2> <span class="mw-headline">2  A Simple Example in RIF </span></h2>
<a id="Example_Background" name="Example_Background"></a><h3> <span class="mw-headline">2.1  Example Background </span></h3>
<p>The RIF examples in this document concern the integration of data about films and plays across the Semantic Web. Suppose, for example, that one wants to combine data about films from IMDb, the Internet Movie Data Base (at <a class="external free" href="http://imdb.com" rel="nofollow" title="http://imdb.com">http://imdb.com</a> ) with DBpedia (at <a class="external free" href="http://dbpedia.org" rel="nofollow" title="http://dbpedia.org">http://dbpedia.org</a> ).  Both resources contain facts about actors being in the cast of films, but DBpedia expresses these facts as a binary relation (aka predicate or RDF property).
</p><p>In DBpedia, for example, one can express the fact that an actor is in the cast of a film: 
</p>
<ul>
<li>
<tt>starring(?Film&nbsp;?Actor)</tt>
</li></ul>
<p>where we use '?'-prefixed variables as placeholders.  The names of the variables used in this example are meaningful to human readers, but not to a machine.  These variable names are intended to convey to readers that the first argument of the DBpedia <tt>starring</tt> relation is a film, and the second an actor who stars in the film. (Variables are discussed in more detail in Section 2.2.2.)
</p><p>In IMDb, however, one does not have an analogous relation. Rather, one can state facts of the following form about actors playing roles:
</p>
<ul><li><tt>playsRole(?Actor&nbsp;?Role)</tt></li></ul>
<p>and one can state facts of the following form about roles (characters) being in films:
</p>
<ul><li><tt>roleInFilm(?Role&nbsp;?Film)</tt></li></ul>
<p>Thus, for example,  in DBpedia, one represents the information that Vivien Leigh was in the cast of <em>A Streetcar Named Desire</em>, as a fact
</p>
<ul><li><tt>starring(Streetcar VivienLeigh)</tt></li></ul>
<p>In IMDb, however, one represents two pieces of factual information, that Vivien Leigh played the role of Blanche DuBois:
</p>
<ul><li><tt>playsRole(VivienLeigh BlancheDubois)</tt></li></ul>
<p>and that Blanche DuBois was a character in <em>A Streetcar Named Desire</em>:
</p>
<ul><li><tt>roleInFilm(BlancheDubois Streetcar)</tt></li></ul>
<a id="Developing_the_Example" name="Developing_the_Example"></a><h3> <span class="mw-headline">2.2  Developing the Example </span></h3>
<p>The challenge in combining this data should be obvious: not only do the two data sources (IMDb and DBpedia) use different <i>vocabulary</i> (the relation names <i>starring, playsRole, roleInFilm</i>), but the <i>structure</i> is different.  To combine this data, we essentially want to say something like the following:
</p><p><i>If there are two facts in the IMDb database, saying that an actor plays a role/character, and that the character is in a film, then there is a single fact in the DBpedia database, saying that the actor is in the film.</i>
</p><p>This will be referred to as the <i>Basic Combination Rule</i>. We develop the Basic Combination Rule as a RIF rule in a stepwise manner in sections 2.2.1 through 2.3.
</p><p>In this document, we incrementally introduce elements of RIF syntax and semantics, eventually building up to an example of valid RIF syntax.  Often --- as is the case in the text boxes below, in sections 2.2.1 through 2.2.6 --- a single element or set of elements, that by itself is not a valid RIF rule set, is introduced.  The red-tinted background in which these preliminary examples are displayed indicates that they are not fully valid RIF.
</p>
<a id="Atomic_Formulas:_Basic_Facts" name="Atomic_Formulas:_Basic_Facts"></a><h4> <span class="mw-headline">2.2.1  Atomic Formulas: Basic Facts </span></h4>
<p>To prepare the Basic Combination Rule example, we first show how to write atomic formulas (atoms) in RIF.
</p><p><i>Atoms</i> can be formed from predicates applied to zero, one, two, or more arguments. Atoms can be used to state facts. For example:
</p>
<ul><li> the nullary (0-argument) predicate application <tt>itRains()</tt> could stand for the proposition <i>it rains</i>.
</li><li> the unary (1-argument) predicate application <tt>rapidStrepPos(John)</tt> could stand for the proposition <i>John's rapid-strep test is positive</i>.
</li><li> the binary (2-argument) predicate application <tt>playsRole(VivienLeigh BlancheDubois)</tt> could stand for the proposition <i>Vivien Leigh played the role of Blanche DuBois</i>.
</li></ul>
<a id="Constants_and_Variables" name="Constants_and_Variables"></a><h4> <span class="mw-headline">2.2.2  Constants and Variables </span></h4>
<p>Like the atoms that make up molecules in the material world, logical atoms are not truly indivisible entities: they are, rather, composed of parts.  The basic parts of an atom are <i>predicates</i> and <i>constants</i> (which are closely related, as discussed below), as well as <i>variables</i> and some other syntax, such as parentheses.  
</p><p>A constant is a term, or a symbol, used to refer to some specific (real or imagined) individual in the world (e.g. the constant <tt>BlancheDubois</tt> may refer to the character Blanche Dubois), or to some specific set of individuals (e.g. the constant <tt>Actors</tt> may refer to the set of all actors) or to some specific set of related individuals (e.g. the constant <tt>starring</tt> can refer to the set of all pairs of &lt;x,y&gt; where <tt>x</tt> stands for an actor, <tt>y</tt> stands for a film, and the starring relation holds between the individuals in each pair; the constant <tt>producedFilm</tt> can refer to the set of all triples  &lt;x,y,x&gt; where <tt>x</tt> stands for a film producer, <tt>y</tt> stands for the film, and <tt>z</tt> stands for the year in which the film was produced).  A set of related individuals, more commonly known as a set of ordered tuples, is known as a <i>predicate</i>.  
</p><p>Constant symbols mean nothing to machines; it is up to the humans who write and implement rules to interpret them in ways that make sense.  As discussed below, one can write rules to help ensure the machine doesn't use the symbols in ways that violate their intended meaning.
</p><p>A variable is a symbol, prefixed by a&nbsp;?, that does not refer to anything specific in itself, but rather serves as a placeholder for writing general rules that range over larger sets of individuals.  Variables in rules are similar, in this sense, to variables in computer programs.  For example, the variable&nbsp;?Actor could stand for any actor or actress. 
</p><p>As is the case with constants, the names of variables mean nothing to the machine, except to distinguish one variable from another. One may name the variable&nbsp;?Actor in order to convey to human readers that the variable is intended to be a placeholder for Actors, but this does not yet convey that information to the machine.
</p>
<a id="Conjunctions_and_Implications" name="Conjunctions_and_Implications"></a><h4> <span class="mw-headline">2.2.3  Conjunctions and Implications </span></h4>
<p>The general structure of the Basic Combination Rule is:
</p>
<ul><li> <i>If firstatom and secondatom, then thirdatom</i>.
</li></ul>
<p>The rule contains a <i>conjunction</i>, a formula of the form <i>A and B</i> or, generally,
<i>A1 and A2 and .... and An</i>.
</p><p>In RIF, a conjunction is rewritten in prefix notation, e.g.
</p>
<ul><li> the binary <i>A and B</i> is written as <tt>And(A B)</tt>.
</li></ul>
<p>Generally,
</p>
<ul><li> the n-ary <i>A1 and A2 and ... and An</i> is written as <tt>And(A1 A2 .... An)</tt>.
</li></ul>
<p>The Basic Combination Rule also contains an <i>implication</i>, a statement of the form
<i>if A then B</i>. 
</p><p>This implication is written almost unchanged in our notation, Mixed Presentation Syntax, as
</p>
<ul><li> <tt>If A Then B</tt>.
</li></ul>
<p><br />
Thus, one would write an implication of the form <i>If firstatom and secondatom, Then thirdatom</i>
as
</p>
<div class="notvalid">
<pre>If And(firstatom secondatom) Then thirdatom
</pre>
</div>
<p>or in a pretty-print format with indentation indicating levels of a formula:
</p>
<div class="notvalid">
<pre>If   And(firstatom secondatom)
Then thirdatom
</pre>
</div>
<p>Note that in contrast, in RIF Presentation Syntax (PS) --- used, e.g., in [<a href="#ref-rif-bld" title="">RIF-BLD</a>] --- this is written in infix notation as <tt>B&nbsp;:- A</tt>, where the antecedent A and consequent B are reversed. The implication expresses the exact same meaning.
</p>
<a id="Quantifiers" name="Quantifiers"></a><h4> <span class="mw-headline">2.2.4  Quantifiers </span></h4>
<p>The syntax that we have introduced so far allows us to write a rule that says:
</p><p><i>If IMDb contains the facts that <b>Vivien Leigh</b> played the role of <b>Blanche Dubois</b>, and that <b>Blanche Dubois</b> is a character role in <b>A Streetcar Named Desire</b>, then conclude the DBpedia fact that <b>Vivien Leigh</b> acted in <b>A Streetcar Named Desire</b> .</i>
</p><p>This rule could be represented as
</p>
<div class="notvalid">
<pre>If   And(playsRole(<b>VivienLeigh</b> <b>BlancheDubois</b>)
         roleInFilm(<b>BlancheDubois</b> <b>Streetcar</b>)) 
Then starring(<b>Streetcar</b> <b>VivienLeigh</b>)
</pre>
</div>
<p>(Note how indentation is used to facilitate reading. <b>Bold-facing</b> is only used in this example to emphasize the correspondence between individual constants in the English and RIF versions of the rule.)
</p><p>But this doesn't, of course, represent the Basic Combination Rule. The Basic Combination Rule says something about <i>all</i> actors, <i>all</i> roles, and <i>all</i> films.
</p><p>To express this, we need to use variables with <i>quantifiers</i>. There are two sorts of quantifiers, <i>Forall</i>, known as the <i>universal quantifier</i>, and <i>Exists</i>, known as the <i>existential quantifier</i>.  The universal and existential quantifiers can be used to form facts and rules.
</p><p>For example, to say that all people like the film Casablanca, one can say:
</p>
<div class="notvalid"> 
<pre>Forall&nbsp;?Person (likesFilm (?Person Casablanca) )
</pre>
</div>
<p>Note that while this is technically a rule, it is not a valid RIF rule yet.
</p><p>To say that at least one person likes the film Casablanca, one can say (this, too, is not a valid RIF rule):
</p>
<div class="notvalid">
<pre>Exists&nbsp;?Person (likesFilm (?Person Casablanca) )
</pre>
</div>
<p>Now it is possible to write a version of the Basic Combination Rule:
</p>
<div class="notvalid">
<pre> Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
  If And(playsRole(?Actor&nbsp;?Role) roleInfilm(?Role&nbsp;?Film)) 
  Then starring(?Film&nbsp;?Actor)
)
</pre>
</div>
<p>There are still a few more steps needed to make this a valid RIF rule, as will be  discussed in the next section.
</p><p>Note also that in Presentation Syntax, this would read as:
</p>
<div class="notvalid">
<pre>Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
  starring(?Film&nbsp;?Actor)&nbsp;:-  
    And(playsRole(?Actor&nbsp;?Role) roleInFilm(?Role&nbsp;?Film))
)
</pre>
</div>
<a id="IRIs_.28Internationalized_Resource_Identifiers.29" name="IRIs_.28Internationalized_Resource_Identifiers.29"></a><h4> <span class="mw-headline">2.2.5  IRIs (Internationalized Resource Identifiers) </span></h4>
<p>The formula shown in BCR-v0.1 is still not a correct formula in RIF. Individual constants like <i>VivienLeigh</i> and predicate constants like <i>playsRole</i> cannot be just used 'as is' but need to be disambiguated. This disambiguation addresses the issue that the constants used in this rule come from more than one database and may have different meanings --- that is, refer to different entities --- in each.
</p><p>In RIF, disambiguation is effected using IRIs, Internationalized Resource Identifiers. (IRIs are a generalization of the concept of URIs; the primary distinction between the two is that IRIs allow characters from more alphabets than do URIs.)  As with URIs, an IRI is a web address that typically includes some information about where the constant comes from (e.g. http://www.imdb.com/constants or http://dbpedia.org/resource).
</p><p>Since using the full IRI notation can be cumbersome for every constant, RIF Mixed Presentation Syntax and other compact syntaxes of RIF allow an abbreviated form through namespace declarations. The specification of abbreviated form is explained in full in [<a href="#ref-rif-bld" title="">RIF-BLD</a>]. The general form of a prefix declaration can be quite complex. The basic idea is taht one can declare a namespace <i>ns</i> stands for the concept or entity described by the IRI <i>thisIRI</i> by writing the prefix declaration <i>Prefix(ns&lt;ThisIRI&gt;)</i>. Then the constant <i>name</i> can be disambiguated in rules using the string <i>ns:name</i>.
</p><p>Consider the following example, in which, as is standard, http://example.com is an IRI reserved to demonstrate examples. Assume we are given the following declarations:
</p>
<div class="notvalid">
<pre>Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)
</pre>
</div>
<p>The constant <tt>imdbrel:playsRole</tt> would be interpreted by RIF as the entity referred to by <tt>http://example.com/imdbrelations#playsRole</tt>, and the constant <tt>dbpedia:starring</tt> would be interpreted as the entity referred to by <tt>http://dbpedia.org/ontology/starring</tt>.
</p><p>Using these prefixes, we can write our BCR with URIs for constants as follows:
</p>
<div class="notvalid">
<pre>Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
  If   And(imdbrel:playsRole(?Actor&nbsp;?Role) imdbrel:roleInFilm(?Role&nbsp;?Film)) 
  Then dbpedia:starring(?Film&nbsp;?Actor)
)
</pre>
</div>
<p>(Note that in Presentation Syntax, this would read as:)
</p>
<div class="notvalid">
<pre>Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
  dbpedia:starring(?Film&nbsp;?Actor)&nbsp;:-  
    And(imdbrel:playsRole(?Actor&nbsp;?Role) imdbrel:roleInFilm(?Role&nbsp;?Film))
)
</pre>
</div>
<p>Namespace prefixes are not strictly required; however, they can greatly improve the readability of rules. Consider, for example, how the rule above would look like without them:
</p>
<div class="notvalid">
<pre>Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
  If   And(&lt;http://example.com/imdbrelations#playsRole&gt;(?Actor&nbsp;?Role)
           &lt;http://example.com/imdbrelations#roleInFilm&gt;(?Role&nbsp;?Film)) 
  Then &lt;<a class="external free" href="http://dbpedia.org/ontology/starring" rel="nofollow" title="http://dbpedia.org/ontology/starring">http://dbpedia.org/ontology/starring</a>&gt;(?Film&nbsp;?Actor)
)
</pre>
</div>
<p>Note that our examples v0.2 and v0.2.1 are now valid RIF syntax. However, they are not yet complete RIF documents, and are therefore still shown in red.
</p>
<a id="Structuring_Operators" name="Structuring_Operators"></a><h4> <span class="mw-headline">2.2.6  Structuring Operators </span></h4>
<p>Two more operators, <i>Group</i> and <i>Document</i>, are needed to write rules in RIF. <i>Group</i>  is used to delimit, or group together, a set of rules within a RIF document. It is semantically equivalent to the operation of conjunction (the <i>And</i> operator). That is, a set of rules <i>Rule1</i> and <i>Rule2</i> can be written as
</p>
<div class="notvalid">
<pre>Group(
  Rule1
  Rule2
)
</pre>
</div>
<p>This is semantically equivalent to writing <i>And(Rule1 Rule2)</i>.
</p><p>A document may contain many groups or just one group.  Similarly, a group can consist of a single rule, although they are generally intended to group multiple rules together.  For example, if there were multiple rules that concluded the same predicate, they might be put in the same group to help keep them organized. This organization is more for the sake of the humans who write, read, and use these rules than for the software systems that process them. A software system that processes RIF does not care whether every group has only one rule, or if all rules are in one group.
</p><p>It is necessary to have an explicit <i>Document</i> operator because a RIF document can import other documents and can thus itself be a multi-document object. For practical purposes, it is sufficient to know that the <i>Document</i> operator is generally used at the beginning of a document, followed by a prefix declaration and one or more groups of rules.
</p>
<a id="Putting_the_pieces_together:_example_rule_in_RIF" name="Putting_the_pieces_together:_example_rule_in_RIF"></a><h3> <span class="mw-headline">2.3  Putting the pieces together: example rule in RIF </span></h3>
<p>Using the elements introduced in Sections 2.2.1 --- 2.2.6, it is now possible to write the complete Basic Combination Rule in RIF Core:
</p><p><br />
</p>
<pre>Document(
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
  Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)
 
  Group(
    Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
      If   And(imdbrel:playsRole(?Actor&nbsp;?Role) imdbrel:roleInFilm(?Role&nbsp;?Film)) 
      Then dbpedia:starring(?Film&nbsp;?Actor)
    )
  )
)
</pre>
<p><br />
</p><p>As has been demonstrated in these sections, it is natural to develop RIF rule documents from the inside out, focusing first on the logical structure of the rules; next, grounding all terms using IRIs; and finally, using structuring operators to create a RIF document.
</p><p>In this document, text boxes with a gray background, like those in the above example, are fully valid RIF documents in RIF Mixed Presentation Syntax.
</p>
<a id="Two_Additional_Examples" name="Two_Additional_Examples"></a><h2> <span class="mw-headline">3  Two Additional Examples </span></h2>
<a id="Second_Example:_Disjunctions.2C_Existentials.2C_Overloading_Predicate_Names" name="Second_Example:_Disjunctions.2C_Existentials.2C_Overloading_Predicate_Names"></a><h3> <span class="mw-headline">3.1  Second Example: Disjunctions, Existentials, Overloading Predicate Names </span></h3>
<p>Much of the previous discussion is relevant to the second example in the DBpedia domain. Suppose one wants to say that an actor can be described as an award-winner in 
DBpedia if he has won an award either for acting in a major film or a Broadway play. Such a rule could
make reference to the data in IBDB, the Internet Broadway Database. 
</p><p>Using the syntax developed in the previous section, plus a few additions that will be
explained below, the rule could be written as:
</p><p><br />  
</p>
<pre> Document(
   Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
   Prefix(imdbrelf &lt;http://example.com/fauximdbrelations#&gt;)
   Prefix(dbpediaf &lt;http://example.com/fauxdbpediarelations&gt;)
   Prefix(ibdbrelf &lt;http://example.com/fauxibdbrelations#&gt;)

   Group(
     Forall&nbsp;?Actor (
       If   Or(Exists&nbsp;?Film (imdbrelf:winAward(?Actor&nbsp;?Film))
               Exists&nbsp;?Play (ibdbrelf:winAward(?Actor&nbsp;?Play)) )
       Then dbpediaf:awardWinner(?Actor)
     )
   )
 )
</pre>
<p>Most of the syntax used in this rule --- e.g., the <i>Document</i> and <i>Group</i> operators, the conditionals --- has been introduced in the previous section. This example introduces the disjunction operator <i>Or</i>. 
</p><p>A disjunction is a formula of the form <i>A or B</i> or more generally, <i>A1 or A2 or ... or </i>
An<i>.</i>
</p><p>In RIF MPS, 
</p>
<ul><li> A disjunction <i>A or B</i> is written as <tt>Or(A B)</tt>.
</li></ul>
<p>More generally
</p>
<ul><li> a disjunction <i>A1 or A2 or ... or An</i> can be written as <tt>Or(A1 A2 .... An)</tt>.
</li></ul>
<p>Note that two different instances of the <i>winAward</i> predicate are used in this rule: the <i>winAward</i> predicate that would be used by IMDb and the <i>winAward</i> predicate that would be used by IBDB. While these are both binary predicates in this example, it could also be the case that one of these predicates has greater arity (that is, has more arguments,
or variables) than another.
</p><p>Note also that this is a fabricated example, in these sense that there is no relation <i>awardWinner</i> used by DBpedia. For that reason, we use the domain http://example.com which is used for hypothetical examples, rather than the actual DBpedia website, <a class="external free" href="http://dbpedia.org" rel="nofollow" title="http://dbpedia.org">http://dbpedia.org</a>, and make clear from the prefix declarations that these relations are fabricated.
</p>
<a id="Third_Example:_Using_Guards" name="Third_Example:_Using_Guards"></a><h3> <span class="mw-headline">3.2  Third Example: Using Guards </span></h3>
<p>As discussed above, the use of <tt>?Actor</tt> as the name of a variable means nothing to the rule engine. Rather, such meaningful names --- that is, meaningful to a human --- are used to make rules more readable.  However, there are various strategies, used by many linked data sources, to convey information about meaning to a rule engine.
</p><p>For example, in RDF, a special property <tt>rdf:type</tt> is reserved to represent the relation between an individual and a class: a string of the general form
<tt>rdf:type (a B)</tt> states that individual <tt>a</tt> is an instance of class <tt>B</tt>.  For example <tt>rdf:type(VivienLeigh Actor)</tt> states that the individual <tt>VivenLeigh</tt> is an instance of the class <tt>Actor</tt>.
</p><p>By convention, names of individuals and properties in linked data sources usually start with a lowercase letter; while names of classes start with an uppercase letter.  If a data source has such information, we can make use of it in rules to enforce that, for example, the <tt>?Actor</tt> variable only has values that are instances of the class <i>Actor</i>.  These kinds of restrictions on the values of variables are called <i>guards</i>. 
</p><p>For this example, we will extend the Basic Combination Rule example with guards on the values of the variables.
</p>
<pre>Document(
  Prefix(rdf &lt;<a class="external free" href="http://www.w3.org/1999/02/22-rdf-syntax-ns" rel="nofollow" title="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>&gt;)
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
  Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology" rel="nofollow" title="http://dbpedia.org/ontology">http://dbpedia.org/ontology</a>&gt;)
 
  Group(
    Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
      If   And(rdf:type(?Actor imdbrel:Actor) 
               rdf:type(?Film imdbrel:Film) 
               rdf:type(?Role imdbrel:Character)
               imdbrel:playsRole(?Actor&nbsp;?Role) 
               imdbrel:roleInilm(?Role&nbsp;?Film)) 
      Then dbpedia:starring(?Film&nbsp;?Actor)
    )
  )
)
</pre>
<p>Guards are so common that RIF introduces a special syntax for the rdf:type predicate, denoted in the Mixed Presentation Syntax by the binary operator <tt>#</tt>.  With this, the rule becomes slightly more concise:
</p>
<pre>Document(
  Prefix(rdf &lt;<a class="external free" href="http://www.w3.org/1999/02/22-rdf-syntax-ns" rel="nofollow" title="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>&gt;)
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
  Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)
 
  Group(
    Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
      If   And(?Actor # imdbrel:Actor 
              &nbsp;?Film # imdbrel:Film
              &nbsp;?Role # imdbrel:Character
               imdbrel:playsRole(?Actor&nbsp;?Role) 
               imdbrel:roleInFilm(?Role&nbsp;?Film)) 
      Then dbpedia:starring(?Film&nbsp;?Actor)
    )
  )
)
</pre>
<a id="Reasoning_in_RIF" name="Reasoning_in_RIF"></a><h2> <span class="mw-headline">4  Reasoning in RIF </span></h2>
<a id="Using_RIF_Rulesets" name="Using_RIF_Rulesets"></a><h3> <span class="mw-headline">4.1 Using RIF Rulesets</span></h3>
<p>The examples thus far demonstrate how to write certain types of rules in RIF. So far, however, we have not demonstrated how and in what circumstances these rules can be used. Intuitively, we know that rules are used in combination, and that combinations of if-then rules and facts are especially important for reeasoning. The following discussion makes this intuition more precise.
</p><p>Using a rule, or set of rules, can mean different things depending on the rule engine that processes the rule set. In general, in a declarative rule engine, one is primarily concerned with using a set of if-then rules, combined with a set of facts, to infer new conclusions about what is true. In a production rule engine, one is primarily concerned with using a set of  if-then rules, combined with a set of facts, to <i>fire</i> some rules and to make certain types of changes, perhaps to a system knowledge base.
</p><p>For example, assume one is given, in a declarative rule language, the Basic Combination Rule introduced in Section 2.3 and the following <i>Document</i> with <i>Prefix</i> declarations for IMDb and DBpedia database concepts and names (of actors, roles, films), as well as a <i>Group</i> of facts (interpreted as a conjunction):
</p>
<pre>Document(
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
  Prefix(imdbname &lt;http://example.com/imdbnames#&gt;)
  Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)

   Group(
     imdbrel:playsRole(imdbname:VivienLeigh imdbname:BlancheDubois)
     imdbrel:roleInFilm(imdbname:BlancheDubois imdbname:Streetcar)
   )
 )
</pre>
<p>One should then be able to conclude that <tt>dbpedia:starring(imdbname:Streetcar imdbname:VivienLeigh)</tt>.
</p><p>The precise conditions that allow one to draw a conclusion from a set of rules and facts
in RIF is discussed in detail in [<a href="#ref-rif-bld" title="">RIF-BLD</a>], which
gives a model-theoretic semantics for inference in RIF. The precise conditions that allow rules to be fired and an action to be performed
is discussed in [<a href="#ref-rif-prd" title="">RIF-PRD</a>], which gives an operational semantics for performing actions in production rule languages of RIF. 
</p><p>We do not discuss these semantics in detail: instead, we give an overview in sections 4.2 and 4.3, and discuss some basic reasoning principles that should suffice to enable a computer professional to understand the consequences of the rules that (s)he writes.
</p>
<a id="Reasoning_in_Declarative_Rule_Languages" name="Reasoning_in_Declarative_Rule_Languages"></a><h3> <span class="mw-headline">4.2 Reasoning in Declarative Rule Languages</span></h3>
<p>The model-theoretic semantics for a declarative rule language seeks to answer the question: Given a world where a certain set of if-then rules and facts is true, what else is true in that world?  The crux of the answer is that what is true in that world follows from certain rules that specify how one can combine simple if-then rules, facts, and  logical operators.
</p><p>It generally suffices to think about reasoning in RIF as being a combination of 
</p>
<ol>
<li><i>instantiation</i> --- especially <i>universal instantiation</i></li> 
<li><i>Modus Ponens</i> --- enabling simple deduction</li>
<li> basic principles for evaluating conjunctions and disjunctions</li>
</ol>
<p>These principles are explained below:
</p><p><b>1.</b> <i>Universal instantiation</i> is the process whereby one can take a universally quantified rule, such as <i>All humans are mortal</i>
</p><p><br /> 
</p>
<pre>Document(
  Prefix(bio &lt;http://example.com/biology#&gt;)

  Group(
    Forall&nbsp;?X (
      If   bio:human(?X)
      Then bio:mortal(?X)
    )
  )
)
</pre>
<p>and instantiate it for any individual constant in the language. Since the rule is true of anyone, it is certainly true, for example, of an individual named Socrates. Thus, the rule above entails that
</p>
<pre>Document(
  Prefix(bio &lt;http://example.com/biology#&gt;)
  Prefix(phil &lt;http://example.com/philosophers#&gt;)

  Group(
    If   bio:human(phil:Socrates)
    Then bio:mortal(phil:Socrates)
  )
)
</pre>
<p>Note in particular that this universally instantiated rule <i>does not say Socrates is human</i>, nor that Socrates is mortal.  It says that IF Socrates is human THEN Socrates is mortal.  All we have done is to <i>instantiate</i> the predicates by replacing the variables in the previous example with constants.
</p><p><b>2.</b> <i>Modus Ponens</i> is the principle that allows concluding the consequent of a rule if one knows that the antecedent is true. That is, if one has a rule of the form
</p>
<div class="notvalid">
<pre> If P Then Q
</pre>
</div>
<p>and one also knows that <tt>P</tt>, it is obviously also the case that <tt>Q</tt>.
</p><p>Thus, if one knows Aristotle's famous rule and also knows  that <tt>bio:human(phil:Socrates)</tt>,
one also ought to know that <tt>bio:mortal(phil:Socrates)</tt>.  E.g. we would expect a RIF rule engine, when given the following input document, to be able to conclude that bio:mortal(phil:Socrates).
</p><p><br />
</p>
<pre>Document(
  Prefix(bio &lt;http://example.com/biology#&gt;)
  Prefix(phil &lt;http://example.com/philosophers#&gt;)

  Group(
    If   bio:human(?x)
    Then bio:mortal(?x)
  )
  Group(
    bio:human(phil:Socrates)
  )
)
</pre>
<p><br />
<b>3.</b> The <i>basic principles of evaluating conjunctions and disjunctions</i> are simply these: 
</p>
<ul><li> A conjunction <i>A1 and A2 and ... and An</i> is true if each of its conjuncts is true.
</li><li> A disjunction <i>A1 or A2 or ... or An</i> is true if at least one of its disjuncts is true.
</li></ul>
<p>That is, assuming declarations for bio, ppl (people), soc (society), and ct (cities),
</p>
<div class="notvalid">
<pre>And(bio:fatherOf(ppl:John ppl:Bill) bio:fatherOf(ppl:John ppl:Mary))
</pre>
</div>
<p>is true if John is the father of both Bill and Mary;
</p>
<div class="notvalid">
<pre> Or(soc:livesIn(ppl:John ct:London) soc:livesIn(ppl:John ct:Paris))
</pre>
</div>
<p>is true if John lives in London or in Paris.
</p>
<a id="Production_Rule_Languages:_Operational_Semantics" name="Production_Rule_Languages:_Operational_Semantics"></a><h3> <span class="mw-headline">4.3 Production Rule Languages: Operational Semantics</span></h3>
<p>The operational semantics for a production rule language is primarily concerned with the question: Given a working memory consisting of a set of if-then rules of the form <i>if condition then action</i> and a set of facts, what rules will fire, and what actions will take place? The crux of the answer is that an action <i>A</i> will take effect if there is a rule of the form <i>if C then A</i> that fires. 
</p><p>The somewhat more substantive answer is that the operational semantics specifies the following steps for determining the firing of rules and the triggering of actions. Note that these steps comprise a cycle which may repeat arbitrarily many times. 
</p>
<ul><li> <b>1.</b> A rule <i>potentially fires</i> if one can match a fact with the rule's condition; moreover, the rule has not previously fired due to a match with that specific fact.
</li><li> <b>2.</b> If several rules <i>potentially fire</i>, they are all in a conflict set.
</li><li> <b>3.</b>  If several rules are in a conflict set, a rule is chosen to fire based on a predefined conflict strategy. The conflict strategy may mandate choosing a rule that has a higher priority, or that has been used more recently, for example. Section 6.2 gives some examples of how priorities may be used.
</li><li> <b>4.</b> If a rule of the form <i>if C then A</i> fires, the action <i>A</i> is carried out, causing a change in the working memory.
</li><li> <b>5.</b>  This cycle repeats until there are no more changes in the working memory; that is, a fixpoint is reached. 
</li></ul>
<p>For example, consider a rule set in PRD consisting of the following if-then rule and fact:
</p>
<pre> Document(
   Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
   Prefix(imdbrelf &lt;http://example.com/fauximdbrelations#&gt;)
   Prefix(dbpediaf &lt;http://example.com/fauxibdbrelations&gt;)
   Prefix(ibdbrelf &lt;http://example.com/fauxibdbrelations#&gt;)

   Group(
     Forall&nbsp;?Actor (
       If   Or(Exists&nbsp;?Film (imdbrelf:winAward(?Actor&nbsp;?Film))
               Exists&nbsp;?Play (ibdbrelf:winAward(?Actor&nbsp;?Play)) )
       Then assert(dbpediaf:awardWinner(?Actor))
     )
   imdbrelf:winAward(RobertoBenigni LifeIsBeautiful)
   )
 )
</pre>
<p>As this example demonstrates, churning through this step effects a kind of inference.
The pattern matching mechanism incorporates the basic principles for evaluating connectives such as conjunctions and disjunctions; thus, the fact <i>imdbrelf:winAward(RobertoBenigni LifeIsBeautiful)</i> matches the condition in the if-then rule. Since there is only one rule and one fact, there is no conflict set; thus, the action <i> assert(dbpediaf:awardWinner(RobertoBenigni))</i> is carried out.
</p>
<a id="Datatypes_and_Built-ins" name="Datatypes_and_Built-ins"></a><h2> <span class="mw-headline">5  Datatypes and Built-ins </span></h2>
<a id="Datatypes_and_Built-ins_in_RIF" name="Datatypes_and_Built-ins_in_RIF"></a><h3> <span class="mw-headline">5.1  Datatypes and Built-ins in RIF </span></h3>
<p>It is expected that all RIF dialects will support a set of commonly used datatypes, predicates,
and functions. This list, specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], includes such datatypes as 
<tt>integer</tt>, <tt>boolean</tt>, <tt>string</tt>, <tt>date</tt>, and <tt>datetime</tt>; as well as built-in predicates and functions that range over these datatypes. Examples follow:
</p>
<ul><li> Examples of built-in numeric functions are arithmetic operators like:
<ul><li> <tt>numeric-add</tt> 
</li><li> <tt>numeric-integer-divide</tt>
</li></ul>
</li></ul>
<ul><li> Examples of built-in numeric predicates:
<ul><li>  <tt>numeric-less-than</tt> 
</li><li>  <tt>numeric-not-equal</tt>
</li></ul>
</li></ul>
<ul><li> Examples of built-in string functions:
<ul><li> <tt>lower-case</tt>
</li><li> <tt>concat</tt>
</li><li> <tt>replace</tt>
</li></ul>
</li></ul>
<ul><li> Examples of built-in string predicates:
<ul><li> <tt>starts-with</tt>
</li><li> <tt>matches</tt>
</li></ul>
</li></ul>
<ul><li> Examples of built-in date/time functions:
<ul><li> <tt>hours-from-dateTime</tt>
</li><li> <tt>hours-from-time</tt>
</li></ul>
</li></ul>
<ul><li> Examples of built-in date/time predicates:
<ul><li> <tt>dateTime-less-than</tt>
</li><li> <tt>date-less-than</tt>
</li><li> <tt>time-less-than</tt>
</li></ul>
</li></ul>
<a id="Fourth_RIF_Example:_Using_datatypes_and_built-ins" name="Fourth_RIF_Example:_Using_datatypes_and_built-ins"></a><h3> <span class="mw-headline">5.2  Fourth RIF Example: Using datatypes and built-ins </span></h3>
<p>As an example of a RIF rule in which datatypes and built-ins are used, again in the DBpedia movies domain, consider how one might characterize a movie star. A movie star will be someone who has starred in more than three successful films, made over a span of at least 5 years (this is to avoid including flash-in-the-pan stars from consideration as movie stars).  A successful film will be characterized as one that received critical acclaim (for the purposes of this example, this will mean a critics' rating higher than 8) or was financially successful (for the purposes of this example, this will mean that the film grossed more than $100 million in ticket sales).
</p><p>The following RIF document implements these rules. Note the use of built-ins such as <tt>numeric-greater-than</tt>, <tt>numeric-subtract</tt>, and <tt>literal-not-identical</tt>:
</p><p><br /> 
</p>
<pre>Document(
    Prefix(func &lt;<a class="external free" href="http://www.w3.org/2007/rif-builtin-function" rel="nofollow" title="http://www.w3.org/2007/rif-builtin-function#">http://www.w3.org/2007/rif-builtin-function#</a>&gt; )
    Prefix(pred &lt;<a class="external free" href="http://www.w3.org/2007/rif-builtin-predicate" rel="nofollow" title="http://www.w3.org/2007/rif-builtin-predicate#">http://www.w3.org/2007/rif-builtin-predicate#</a>&gt; )
    Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
    Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
    Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)
    Prefix(ibdbrel &lt;http://example.com/ibdbrelations#&gt;)
  Group(
    Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Year (
      If  And( dbpedia:starring(?Film&nbsp;?Actor)
               dbpedia:dateOfFilm(?Film&nbsp;?Year))
      Then  dbpedia:starredInYear(?Film&nbsp;?Actor&nbsp;?Year)
    )
    Forall&nbsp;?Actor ( 
      If  ( Exists &nbsp;?Film1&nbsp;?Film2&nbsp;?Film3 &nbsp;?Year1&nbsp;?Year2&nbsp;?Year3 
               And( dbpedia:starredInYear(?Film1&nbsp;?Actor&nbsp;?Year1)
                    dbpedia:starredInYear(?Film2&nbsp;?Actor&nbsp;?Year2)
                    dbpedia:starredInYear(?Film3&nbsp;?Actor&nbsp;?Year3) 
                    (External( pred:numeric-greater-than( 
                                   External( func:numeric-subtract&nbsp;?Year1&nbsp;?Year3)
                                   5)))
                    dbpedia:successful(?Film1)
                    dbpedia:successful(?Film2)
                    dbpedia:successful(?Film3)
                    External( pred:literal-not-identical(?Film1&nbsp;?Film2))
                    External( pred:literal-not-identical(?Film1&nbsp;?Film3))
                    External( pred:literal-not-identical(?Film3&nbsp;?Film2))
                  )
      Then dbpedia:movieStar(?Actor)
    )
    Forall&nbsp;?Film (
      If Or( External(pred:numeric-greater-than(dbpedia:criticalRating(?Film) 8))
             External(pred:numeric-greater-than(dpbedia:boxOfficeGross(?Film) 100000000)))
      Then dpbedia:successful(?Film)
    )
  )
)
</pre>
<a id="Extensions_to_RIF_Core:_Constructs_for_BLD_and_PRD" name="Extensions_to_RIF_Core:_Constructs_for_BLD_and_PRD"></a><h2> <span class="mw-headline">6  Extensions to RIF Core: Constructs for BLD and PRD </span></h2>
<p>We discuss below examples of rules in dialects that are extensions of RIF Core. The RIF dialect BLD extends RIF-Core by allowing logically-defined functions.  The RIF dialect PRD extends RIF-Core by allowing prioritization of rules, negation, and explicit statement of knowledge-base modification. 
</p>
<a id="BLD_extensions_to_Core:_Functions.2C_Equality" name="BLD_extensions_to_Core:_Functions.2C_Equality"></a><h3> <span class="mw-headline">6.1  BLD extensions to Core: Functions, Equality </span></h3>
<p>So far, the arguments of predicates have been variables like <tt>?Actor</tt> or constants like <tt>vivienleigh</tt>. These are the only arguments to predicates that are allowed in RIF-Core. RIF-BLD is more expressive, and allows predicate arguments to be <i>function</i> applications. (For the purposes of this Primer, it suffices to know that a function is a mapping between a set of elements known as the <i>domain</i>, and a set of elements known as the <i>range</i>, and to note that there is a close connection between predicates and functions, in that both can be characterized by a set of ordered tuples.) For example, if <tt>mainActor</tt> is a function denoting the actor who plays the main character of a film, and <tt>pottersorcerer</tt> is a constant denoting the film <i>Harry Potter and the Sorcerer's Stone</i>, then <tt>mainActor(pottersorcerer)</tt> denotes the actor playing the main character of <i>Harry Potter and the Sorcerer's Stone</i>. 
For example,
</p>
<ul><li> the application <tt>seriesStar(mainActor(pottersorcerer))</tt> of the unary predicate <tt>seriesStar</tt> to the unary function <tt>mainActor</tt> applied to <tt>pottersorcerer</tt> could stand for the proposition <i>the main actor in Harry Potter and the Sorcerer's Stone is a star of a movie series</i>.
</li></ul>
<p>In general, functions are applied to zero or more arguments, which themselves can be variables, constants, or function applications. A function application denotes an individual. This allows us to refer to an individual without coining a new constant (symbol) for it. 
</p><p>Moreover, RIF-BLD has a distinguished equality predicate, '<tt>=</tt>', which enables user-defined functions.
For example, <tt>mainActor(pottersorcerer) = danielradcliffe</tt> could be used to equate the main actor of <i>Harry Potter and the Sorcerer's Stone</i> with <i>Daniel Radcliffe</i>.
Another function, <tt>mainChar</tt>, could be defined to return the main characters of films. For example, <tt>mainChar(pottersorcerer) = harrypotter</tt> would equate the main character of <i>Harry Potter and the Sorcerer's Stone</i> with <i>Harry Potter</i>.
</p><p>Besides such definitions of functions applied to arguments in a 'pointwise' fashion, functions can be also defined generally, using conditional equations, i.e. rules with '<tt>=</tt>' in the consequent.
For example, based on the function <tt>MainChar</tt> and the predicate <tt>playsRole</tt>, the function <tt>mainActor</tt> can be defined as in the following fragment:
</p>
<div class="notvalid">
<pre>If And( mainChar(?Film) =&nbsp;?Char 
        playsRole(?Actor&nbsp;?Char))
Then mainActor(?Film) =&nbsp;?Actor
</pre>
</div>
<p>Similarly, there can be a function <tt>villainActor</tt>, returning the actor playing the primary villain in a film.
</p><p>One could then define a predicate combinedMainCharVillainActor that is true of someone who has played the main character in a film <tt>?Film1</tt> and the villain in a (possibly different) film <tt>?Film2</tt>, as shown in this RIF fragment:
</p>
<div class="notvalid">
<pre>Forall&nbsp;?Actor&nbsp;?Film1&nbsp;?Film2
  If And(&nbsp;?Actor = mainActor(?Film1) 
         &nbsp;?Actor = villainActor(?Film2))
  Then combinedMainCharVillain(?Actor)
</pre>
</div>
<p>For example, Ralph Fiennes, who has played the primary villain, Lord Voldemort, in most of the Harry Potter films, played the main character, Count Laszlo de Almasy, in <i>The English Patient</i>.
</p>
<a id="PRD_Extensions_to_RIF_Core:_Priorities.2C_Negation.2C_and_Knowledge_Base_Modification" name="PRD_Extensions_to_RIF_Core:_Priorities.2C_Negation.2C_and_Knowledge_Base_Modification"></a><h3> <span class="mw-headline">6.2  PRD Extensions to RIF Core: Priorities, Negation, and Knowledge Base Modification </span></h3>
<p>The RIF dialect PRD is targeted to users writing rules for production systems. For any rule 'if P then Q', 'P' is called the 'condition' and 'Q' is called the 'action'.
</p><p>Below, we discuss three features that PRD adds to RIF-Core. Two of these, 'priorities' and 'knowledge base modification', are features which are closely associated with production systems; the other feature, 'negation', is a construct that is present in most declarative rule languages. As of this date, the only RIF dialect that supports negation is PRD.
</p>
<a id="Priorities" name="Priorities"></a><h4> <span class="mw-headline">6.2.1  Priorities </span></h4>
<p>The concept of control is absent in RIF Core. That is, there is no way to specify that an implementation ought to consider one rule before another.
</p><p>Often, however,  one constructs a rule set with the intention that some rules are considered before others. This capability is generally present in production systems, in which there is an explicit notion of rules "firing" in a particular sequence. PRD supports specifying that certain rules have higher priority than others. That is, when there are two rules whose antecedents are satisfied, one can specify that one rule should be fired before the other.
</p><p>The example in the following subsection demonstrates how priorities are used.
</p>
<a id="Negation" name="Negation"></a><h4> <span class="mw-headline">6.2.2  Negation </span></h4>
<p>PRD is currently the only dialect of RIF to allow negation. Specifically, it allows adding negation to rule conditions. For example, the following rule set computes awardless 
film actors. 
</p>
<pre>Document(
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrel &lt;http://example.com/imdbrelations#&gt;)
  Prefix(dbpedia &lt;<a class="external free" href="http://dbpedia.org/ontology/" rel="nofollow" title="http://dbpedia.org/ontology/">http://dbpedia.org/ontology/</a>&gt;)
 Group( 2
   Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Role (
     If   And(imdbrel:playsRole(?Actor&nbsp;?Role) 
              imdbrel:roleInFilm(?Role&nbsp;?Film))
     Then dbpedia:starring(?Film&nbsp;?Actor)
   )
 )
  Group( 1
    Forall&nbsp;?Actor (
      If   Not(Exists&nbsp;?Film ( And(
                  dbpedia:starring(?Actor&nbsp;?Film)
                  imdbrel:winAward(?Actor&nbsp;?Film)) ))
      Then dbpedia:awardlessFilmActor(?Actor)
    )
  )
)
</pre>
<p>Note that priorities are used here as well. One must first compute the set of all actors who have won awards; only then can one compute the set of actors who have not won awards. If one fires the rules in the reverse order, all actors would be considered awardless.
</p>
<a id="Knowledge_Base_Modification" name="Knowledge_Base_Modification"></a><h4> <span class="mw-headline">6.2.3  Knowledge Base Modification </span></h4>
<p>For any PRD rule of the form 'If Condition Then Action', the 'Action' portion may correspond to an action that modifies a knowledge base. Specific examples of such actions are 'Assert', which adds a statement to a knowledge base; 'Retract', which removes a statement from the knowledge base; and 'Modify' which first retracts a statement, and then asserts a statement.. See 7.2 for an example of the use of <tt>Assert</tt> and <tt>Modify</tt> .
</p>
<a id="Using_Frames_in_RIF" name="Using_Frames_in_RIF"></a><h2> <span class="mw-headline">7  Using Frames in RIF </span></h2>
<a id="Example_Using_Frames" name="Example_Using_Frames"></a><h3> <span class="mw-headline">7.1  Example Using Frames </span></h3>
<p>It is often convenient to use a frame construct when writing rules in RIF. For example, 
IMDb could decide to organize information about films in a frame that includes, among other
things, information about the name of the film and the year in which the film was made.
This information could be stored in predefined <i>slots</i>.
</p><p>The use of slots is widespread in object-oriented programming languages such as C++ and Java, as well as
knowledge-representation languages such as CLASSIC and OWL. Incorporating slots into RIF thus facilitates the interchange of information among languages that support slots, although a caveat is discussed in the next subsection.
</p><p>In a variant of the data combination example discussed above, consider how DBpedia could
import information about award winners from IMDb, if the latter used slots. In  this example, the notation <i>frame[slot1-&gt;value1 ... slotn-&gt;valuen]</i> is used. Note the quantification over the particular type of frame (that is, the frame that holds information about film names and release years), as well as the slot values.
</p>
<pre>Document(
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrelf &lt;http://example.com/fauximdbrelations#&gt;)
 Prefix(imdbnamef &lt;http://example.com/fauximdbnames#&gt;)
  Prefix(dbpediaf &lt;http://example.com/fauxdbpediarelations&gt;)
  Group(
    Forall&nbsp;?Actor&nbsp;?Film&nbsp;?Year&nbsp;?FF (
      If   And (?FF#imdbnamef:filmframe
                &nbsp;?FF[imdbnamef:filmName -&gt;&nbsp;?Film
                     imdbname:filmYear -&gt;&nbsp;?Year]
                imdbrelf:winAward(?Actor&nbsp;?FF))
      Then dbpediaf:winAward(?Actor&nbsp;?Film&nbsp;?Year) )
    )
  )
 )
</pre>
<p><br />
</p><p><br /> 
Note that in this fabricated example, both IMDb and DBpedia use a predicate named <i>winAward</i>; these instances of the predicate are distinguished by their IRIs. Note also that DBpedia's <i>winAward</i> predicate has three arguments, while IMDb's has only two arguments (the second of which being a frame with two slots); the use of frames allows IMDb to reduce the number of predicates.
</p>
<a id="Distinguishing_Slots_in_Object-Oriented_Languages_and_RIF" name="Distinguishing_Slots_in_Object-Oriented_Languages_and_RIF"></a><h3> <span class="mw-headline">7.2  Distinguishing Slots in Object-Oriented Languages and RIF </span></h3>
<p>The user of RIF should be aware that slots in RIF are treated differently than slots in object-oriented languages such as C++ or Java. 
</p><p>Consider the following fragment of Java:
</p>
<div class="notvalid">
<pre>Class Example {
  int a;

  public static void main(String args[]) {
    Example e1 = new Example();
  
    e1.a = 1;
    e1.a = 2;
  
    System.out.println(e1.a);
  }
}
</pre>
</div>
<p>The output of this program will be 2. The singleton slot e1.a is first assigned 1, but that value is then <i>replaced</i> by 2. In contrast, RIF frames can be considered as multimaps, supporting multiple assignments to the same attribute:
</p>
<div>
<pre>Document(
  Prefix(ex &lt;http://example.com/exampleconcepts#&gt;)
  Group (
    ex:e1#Example
    ex:e1[ex:a -&gt; 1]
    ex:e1[ex:a -&gt; 2]
  )
)
</pre>
</div>
<p>Under RIF's semantics, <i>a</i> has both the value 1 and 2; that is, both <i>(e1,1)</i>
and <i>(e1,2)</i> are ordered pairs in the relation named by <i>a</i>. In other words, <i>a</i> functions as
a predicate, which can comprise multiple ordered pairs. This is a direct consequence of the
fact that RIF has the semantics of first-order logic.
</p><p>Object-oriented languages, on the other hand, have the semantics of 
programming languages. The slot a is therefore understood as a variable 
which can be overwritten.
</p><p>For applications in which the overwriting facility is desired, RIF-PRD has a modify action with operational semantics that can  overwrite slot values. Consider the following example:
</p>
<div>
<pre>Document(
 Prefix(ex &lt;http://example.com/exampleconcepts#&gt;)
 Group (
   Do (
     (?e1 new())
     Assert(?e1 # ex:Example)
     Assert(?e1[ex:a -&gt; 1])
     Modify(?e1[ex:a -&gt; 2])
   ))
)
</pre>
</div>
<p>At the end of the action block (identified using the keyword "Do"), the 
slot a has the value 2.
</p>
<a id="Compatibility_with_Other_Standards" name="Compatibility_with_Other_Standards"></a><h2> <span class="mw-headline">8  Compatibility with Other Standards </span></h2>
<p>RIF has been designed so that it is intercompatible with other Web Standards. Specifically, it is interoperable with both RDF [<a href="#ref-rdf-concepts" title="">RDF-CONCEPTS</a>] and OWL [<a href="#ref-owl-reference" title="">OWL</a>]. In practice, this means that one can
reason from a combination of RIF documents and RDF and/or OWL documents. The practical import of this is that RIF does not just allow interchange of different rule sets; it also facilitates interchange of RDF triples and/or OWL 2 axioms with rule sets in RIF.  Specifically, RIF supports interchange of RDF triples and OWL axioms with RDF frame formulas.
</p>
<a id="Intercompatibility_of_RIF_and_RDF" name="Intercompatibility_of_RIF_and_RDF"></a><h3> <span class="mw-headline">8.1  Intercompatibility of RIF and RDF </span></h3>
<p>The following example shows how one can reason from a combination of RIF and RDF documents. Consider, first, the following rule, which expresses the fact that the Hollywood Production Code, which at one point regulated the moral content of films produced in the United States, was in force between 1930 and 1968. 
</p><p>This rule can be expressed as follows: (The practitioner should also note the use of frames and built-in predicates in this example.)
</p><p><br />
</p>
<pre>Document(
  Prefix(rdfs &lt;<a class="external free" href="http://www.w3.org/2000/01/rdf-schema" rel="nofollow" title="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a>&gt;)
  Prefix(imdbrelf &lt;http://example.com/fauximdbrelations#&gt;)
 Prefix(imdbnamef &lt;http://example.com/fauximdbnames#&gt;)
  Prefix(dbpediaf &lt;http://example.com/fauxdbpediarelations&gt;)
 Group(
    Forall&nbsp;?Film&nbsp;?Year&nbsp;??FF  (
      If   And (&nbsp;?FF#imdbnamef:filmframe
                 &nbsp;?FF[imdbnamef:filmName -&gt;&nbsp;?Film
                      imdbnamef:filmYear -&gt;&nbsp;?Year]
                  External(pred:date-greater-than(?Year, 1930))
                  External(pred:date-less-than(?Year, 1968)))
      Then dbpediaf:enforcedProductionCode(?Film)
    )
  )
 )
</pre>
<p><br />
Consider, now, the fact that <i>Gone With the Wind</i> was produced in 1939.
</p><p>Naturally, one can represent this as the following fact in RIF:
</p>
<div class="notvalid">
<pre> imdbrel:FF[imdbnamef:filmName -&gt; GoneWiththeWind imdbnamef:filmYear -&gt; 1939]
</pre>
</div>
<p>Moreover, under RIF's semantics, one can conclude
</p>
<div class="notvalid">
<pre> dbpediaf:enforcedProductionCode(GoneWiththeWind)
</pre>
</div>
<p>The fact that RDF is compatible with RIF means that one can equally well represent this fact as an RDF triple. For example, an RDF graph might contain a triple such as 
</p>
<div class="notvalid">
<pre>ex:GoneWiththeWind ex:filmYear ex:1939
</pre>
</div>
<p>which would contain the same information as the RIF fact above. Moreover, one can still use the RIF semantics to conclude, as above, that 
</p>
<div class="notvalid">
<pre>dbpediaf:enforcedProductionCode(GoneWiththeWind)
</pre>
</div>
<p>The complete specification of using combinations of RIF and RDF (along with proofs of correctness) is given in [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p>Note that there is another issue, separate from intercompatibility, that concerns the ability to map a document from one language to another. For example, one may wish to map a RIF syntactic structure into an RDF graph.
</p><p>[<a href="#ref-rif-in-rdf" title="">RIF in RDF</a>] demonstrates how and to what extent this can be done. A reversible mapping is given.
</p><p><br />
</p>
<a id="Intercompatibility_of_RIF_and_OWL" name="Intercompatibility_of_RIF_and_OWL"></a><h3> <span class="mw-headline">8.2  Intercompatibility of RIF and OWL </span></h3>
<p>OWL [<a href="#ref-owl-reference" title="">OWL</a>] is an ontology language that has been incorporated as a web standard. The current accepted version of OWL is OWL 2, an extension of the original OWL (now known as OWL 1). OWL 2 has several standard subsets (profiles) and two similar semantics, called the Direct Semantics and the RDF-Based-Semantics.
</p><p>One can use techniques similar to those used to show that RDF and RIF are intercompatible to show that OWL and RIF are intercompatible, in the following sense:
</p>
<ul><li> The combined use of RIF and OWL is well defined;
</li><li> One can infer conclusions from certain combinations of  OWL axioms and RIF rules and facts. 
</li><li> There is a subset of OWL, [<a href="#ref-rif-owlrl" title="">RIF-OWLRL</a>], that can be implemented with a RIF ruleset.
</li></ul>
<p>One often has a choice as to whether one can do something in RIF or OWL; many sentences of logic can be expressed in either language. However, there are many sentences of RIF that cannot be expressed in OWL. For example, although OWL 2 (unlike OWL 1) allows arbitrary composition of relations/properties, it is still not possible to have an OWL property chain that ends in a data value. One would need RIF for such purposes.
</p><p><br />
More details on the intercompatibility of RIF and OWL are given in  [<a href="#ref-rif-owlrl" title="">RIF-OWLRL</a>] and  [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p>
<a id="The_Test_Suite" name="The_Test_Suite"></a><h2> <span class="mw-headline">9  The Test Suite </span></h2>
<p>The RIF Working Group has put together a test suite of rules [<a href="#ref-rif-test-suite" title="">TESTS</a>]
that have been designed to test certain special cases of RIF semantics in order to verify implementations. As a side effect, this suite also serves as a large body of examples of RIF syntax and semantics.  
</p><p>The RIF Test Cases document [<a href="#ref-rif-test" title="">TEST</a>] describes the organization and format of the test cases. The first item in each test case is of particular importance: it indicates what <i>type</i> of test it is.  Each type of test is documented: readers can click on the test type to see its description.  Two important types of tests are <i>Positive Entailment Tests</i> and <i>Negative Entailment Tests</i>.  Positive Entailment Tests, the most common in the test repository, each contain a set of rules listed as <i>Premises</i> and a set of <i>Conclusions</i>.  If a correctly implemented RIF Rule Engine takes the premises as input, then the statements in the conclusion should be among its outputs.  The conclusions are not necessarily exhaustive: it may be correct for a rule engine to output other statements as well.
</p><p>Each Negative Entailment Test also has a set of premises. Instead of a conclusion, however, it has a <i>Non-conclusion</i> section that shows a set of statements that should <i>not</i> be output by a RIF rule engine.  These test cases are typically used to demonstrate aspects of RIF semantics that may not be obvious.
</p><p>All test cases are provided in standard RIF/XML syntax as well as in RIF Presentation Syntax for readability.  As discussed above, RIF PS is quite close to the RIF Mixed Presentation Syntax used here: what mainly 
distinguishes the two syntaxes is that RIF PS inverts the arguments to IF and THEN and separates them with the <b>:-</b> symbol.
</p>
<a id="Learning_More_about_RIF:_Next_Steps" name="Learning_More_about_RIF:_Next_Steps"></a><h2> <span class="mw-headline">10  Learning More about RIF: Next Steps </span></h2>
<p>After reading this Primer, the reader interested in using RIF is encouraged to learn more about RIF by
</p>
<ul><li> reading the Frequently Asked Questions, and their answers, at <a class="external free" href="http://www.w3.org/2005/rules/wiki/RIF_FAQ" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/RIF_FAQ">http://www.w3.org/2005/rules/wiki/RIF_FAQ</a>&nbsp;;
</li><li> reading the [<a href="#ref-rif-overview" title="">RIF-OVERVIEW</a>], which gives a very brief description of RIF documents;
</li><li> consulting the full specifications for BLD and PRD at [<a href="#ref-rif-bld" title="">RIF-BLD</a>] and [<a href="#ref-rif-prd" title="">RIF-PRD</a>]&nbsp;;
</li><li> joining the developers' mailing list at <a class="external free" href="http://lists.w3.org/Archives/Public/public-rif-dev/" rel="nofollow" title="http://lists.w3.org/Archives/Public/public-rif-dev/">http://lists.w3.org/Archives/Public/public-rif-dev/</a>
</li></ul>
<p>The best way to learn a language is to use it. We encourage the readers of this Primer to start using RIF.
</p>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">11 Acknowledgements</span></h2>
<p>This document is the product of the Rules Interchange Format (RIF) Working Group (see below), all of whom have contributed to this document through their work in developing RIF. The editors extend special thanks to: Gary Hallmark, Sandro Hawke, and  Stella Mitchell, for their thorough reviews, insightful discussions, and substantive suggestions for changes in content and wording; the working group chairs, Chris Welty and Christian de Sainte Marie, for their invaluable technical help and inspirational leadership; and W3C staff contact Sandro Hawke, a constant source of ideas, help, and feedback.
</p><p>The regular attendees at meetings of the Rule Interchange Format (RIF) Working Group at the time of publication of this document were: Adrian Paschke (Freie Universitaet Berlin), Axel Polleres (DERI), Chris Welty (IBM), Christian de Sainte Marie (IBM), Dave Reynolds (HP), Gary Hallmark (ORACLE), Harold Boley (NRC), Jos de Bruijn (FUB), Leora Morgenstern (SAIC), Michael Kifer (Stony Brook), Mike Dean (BBN), Sandro Hawke (W3C/MIT), and Stella Mitchell (Cornell).
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">12  References </span></h2>
<p><span id="ref-owl-reference"></span>
</p>
<dl><dt> [OWL-Reference]
</dt><dd> <i>OWL Web Ontology Language Reference</i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004. Latest version available at <a class="external free" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-concepts"></span>
</p>
<dl><dt> [RDF-Concepts]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax]</i>, G. Klyne, J. Carrol, Editors, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-bld"></span>
</p>
<dl><dt> [RIF-BLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/"><span>RIF Basic Logic Dialect (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-core"></span> 
</p>
<dl><dt> [RIF-Core]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/"><span>RIF Core Dialect (Second Edition)</span></a></cite> Harold Boley, Gary Hallmark, Michael Kifer, Adrian Paschke, Axel Polleres, Dave Reynolds, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-dtb"></span>
</p>
<dl><dt> [RIF-DTB]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-in-rdf"></span>
</p>
<dl><dt> [RIF in RDF]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/"><span>RIF In RDF (Second Edition)</span></a></cite> Sandro Hawke, Axel Polleres, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-in-rdf/">http://www.w3.org/TR/rif-in-rdf/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-xmldata"></span>
</p>
<dl><dt> [RIF+XML-Data]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/"><span>RIF Combination with XML data (Second Edition)</span></a></cite> Christian de Sainte Marie, editor. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-xml-data/">http://www.w3.org/TR/rif-xml-data/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-overview"></span>
</p>
<dl><dt> [RIF-Overview]
</dt><dd> <i>RIF Overview</i>, Kifer M. and Boley H. (Editors), W3C Rule Interchange Format Working Group Note. Latest Version available at <a class="external free" href="http://www.w3.org/TR/rif-overview/" rel="nofollow" title="http://www.w3.org/TR/rif-overview/">http://www.w3.org/TR/rif-overview/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-owlrl"></span>
</p>
<dl><dt> [RIF-OWLRL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/"><span>OWL 2 RL in RIF (Second Edition)</span></a></cite> Dave Reynolds, editor. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-owl-rl/">http://www.w3.org/TR/rif-owl-rl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-fld"></span>
</p>
<dl><dt> [RIF-FLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/"><span>RIF Framework for Logic Dialects (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">http://www.w3.org/TR/2013/REC-rif-fld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-fld/">http://www.w3.org/TR/rif-fld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-prd"></span>
</p>
<dl><dt> [RIF-PRD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/"><span>RIF Production Rule Dialect (Second Edition)</span></a></cite> Christian de Sainte Marie, Gary Hallmark, Adrian Paschke, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-swc"></span>
</p>
<dl><dt> [RIF-RDF+OWL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/"><span>RIF RDF and OWL Compatibility (Second Edition)</span></a></cite> Jos de Bruijn, Chris Welty, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-test"></span>
</p>
<dl><dt> [RIF-Test]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/"><span>RIF Test Cases (Second Edition)</span></a></cite> Stella Mitchell, Leora Morgenstern, Adrian Paschke, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">http://www.w3.org/TR/2013/NOTE-rif-test-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-test/">http://www.w3.org/TR/rif-test/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-ucr"></span>
</p>
<dl><dt> [RIF-UCR]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/"><span>RIF Use Cases and Requirements (Second Edition)</span></a></cite> Adrian Paschke, Leora Morgenstern, David Hirtle, Allen Ginsberg, Paula-Lavinia Patranjan, Frank McCabe, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-ucr/">http://www.w3.org/TR/rif-ucr/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-test-suite"></span>
</p>
<dl><dt> [RIF-Test-Suite]
</dt><dd> <i>RIF Approved Test Cases</i>, Mitchell, S. (Editor), RIF Approved Test Cases. Latest Version available at <a class="external free" href="http://www.w3.org/2005/rules/wiki/Category:Approved" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/Category:Approved">http://www.w3.org/2005/rules/wiki/Category:Approved</a>.
</dd></dl>
<p><span class="anchor" id="ref-bali-2009"></span> 
</p>
<dl><dt> [BA09]
</dt><dd> <i>Drools JBoss Rules 5.0 Developer's Guie", M. Bali, Packt, 2009.</i>
</dd></dl>
<p><span class="anchor" id="ref-friedmanhill-2003"></span> 
</p>
<dl><dt> [FH03]
</dt><dd> <i>Jess in Action: Java Rule-Based Systems</i>, E. Friedman-Hill, Manning, 2003.
</dd></dl>
<p><span class="anchor" id="ref-sparql"></span> 
</p>
<dl><dt> [SPARQL]
</dt><dd> <i>SPARQL Query Language for RDF</i>, E. Prud'hommeaux, A. Seaborne (Editors), W3C Recommendation, World Wide Web Consortium, 12 January 2008, <a class="external free" href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/" rel="nofollow" title="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-sparql-query/" rel="nofollow" title="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/</a>.
</dd></dl>
<p><span class="anchor" id="ref-stable-model"></span> 
</p>
<dl><dt> [GL88]
</dt><dd> <i>The Stable Model Semantics for Logic Programming</i>, M. Gelfond and V. Lifschitz. Logic Programming: Proceedings of the Fifth Conference and Symposium, pages 1070-1080, 1988.
</dd></dl>
<p><span class="anchor" id="ref-wf-model"></span> 
</p>
<dl><dt> [GRS91]
</dt><dd> <i>The Well-Founded Semantics for General Logic Programs</i>, A. Van Gelder, K.A. Ross, J.S. Schlipf. Journal of ACM, 38:3, pages 620-650, 1991.
</dd></dl>
<p><span class="anchor" id="ref-clocksin-mellish-2003a"></span> 
</p>
<dl><dt> [CM03]
</dt><dd> <i>Programming in Prolog: Using the ISO Standard</i>, W. F. Clocksin and C. S. Mellish. Springer, 2003.
</dd></dl>
<p><span class="anchor" id="ref-deckeretal-1999"></span> 
</p>
<dl><dt> [DEFS99]
</dt><dd> <i>Ontobroker:Ontology Based Access to Distributed and Semi-Structured Information</i>, S. Decker, M. Erdmann, D. Fensel, and R. Studer, DS-8, 1999.
</dd></dl>
<p><span class="anchor" id="ref-grosof-2009"></span> 
</p>
<dl><dt> [GR09]
</dt><dd> <i>SILK: Higher Level Rules with Defaults and Semantic Scalability</i>, B. Grosof, "Web Reasoning and Rule Systems", 24--25, 2009.
</dd></dl>
<p><span class="anchor" id="ref-riazanov-2009"></span> 
</p>
<dl><dt> [RZ09]
</dt><dd> <i>Vampire Reasoner</i>, A. Riazanov, <a class="external free" href="http://www.vprover.org/" rel="nofollow" title="http://www.vprover.org/">http://www.vprover.org/</a> , 2009.
</dd></dl>
<p><span class="anchor" id="ref-bernersleeetal-2008"></span> 
</p>
<dl><dt> [BCKSH08]
</dt><dd> <i>N3Logic: A logical framework for the World Wide Web</i>, T. Berners-Lee, D. Connolly, L. Kagal, Y.Scharf,  and J. Hendler, "Theory and Practice of Logic Programming", 8(3), 249-269, 2008.
</dd></dl>
<p><span class="anchor" id="ref-swrl-2004"></span> 
</p>
<dl><dt> [SWRL-Ref]
</dt><dd> <i>SWRL: A Semantic Web Rule Language Combining OWL and Rule-ML</i>, I. Horrocks, P. Patel-Schneider, H. Boley, S. Tabet, B. Grosof, M. Dean, <a class="external free" href="http://www.w3.org/Submission/SWRL/" rel="nofollow" title="http://www.w3.org/Submission/SWRL/">http://www.w3.org/Submission/SWRL/</a>, 2004.
</dd></dl>
<p><span class="anchor" id="ref-eulersharp-2010"></span> 
</p>
<dl><dt> [EULERSHARP10]
</dt><dd> <i>Euler Proof Mechanism</i>, J. de Roo. <a class="external free" href="http://eulersharp.sourceforge.net/" rel="nofollow" title="http://eulersharp.sourceforge.net/">http://eulersharp.sourceforge.net/</a> , 2010.
</dd></dl>
<p><span class="anchor" id="ref-ilog-2010"></span> 
</p>
<dl><dt> [ILOG10]
</dt><dd> <i>ILOG Website</i>,<a class="external free" href="http://www-01.ibm.com/software/websphere/ilog-migration/" rel="nofollow" title="http://www-01.ibm.com/software/websphere/ilog-migration/">http://www-01.ibm.com/software/websphere/ilog-migration/</a> , 2010.
</dd></dl>
<p><span class="anchor" id="ref-oracle-2010"></span> 
</p>
<dl><dt> [ORACLE10]
</dt><dd> <i>ORACLE  Website</i>, <a class="external free" href="http://www.oracle.com/technetwork/middleware/business-rules/overview/index.html" rel="nofollow" title="http://www.oracle.com/technetwork/middleware/business-rules/overview/index.html">http://www.oracle.com/technetwork/middleware/business-rules/overview/index.html</a> , 2010.
</dd></dl>
<p><br />
</p><p><br />
</p>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">13  Appendix: Change Log (Informative) </span></h2>
<p>First publication: 11 December 2012
</p>
</div>

</body>
</html>