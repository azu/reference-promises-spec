<!-- http://www.w3.org/TR/rdf11-mt/ -->
<!DOCTYPE html>
<html lang="en" dir="ltr" typeof="bibo:Document w3p:REC" about="" property="dcterms:language" content="en" prefix="bibo: http://purl.org/ontology/bibo/ w3p: http://www.w3.org/2001/02pd/rec54#" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <title>RDF 1.1 Semantics</title>
    
    
    
<style type="text/css">
.semantictable {background-color: #FFFFAA; padding:0.5em;}
.ruletable {background-color: #DDDDFF; padding:0.5em;}
.othertable {background-color: #FDFDFD; padding:0.5em;}
.tabletitle {font-size: small; font-weight: bolder;}

.technote {
    font-size:small;
    margin: 2em 0em 0em;
    padding:    1em;
    border: 2px solid #cff6d9;
    background: #e2fff0;
}

.technote::before {
    content:    "Technical Note";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #cff6d9;
    background: #eff;
    padding:    3px 1em;
}


.changenote {
    font-size:small;
    margin: 1em 0em 0em;
    padding:    1em;
    border: 2px solid #cff6d9;
    background: #ffddfe;
}

.changenote::before {
    content:    "Change Note";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #cff6d9;
    background: #ffddef;
    padding:    3px 1em;
}


.fact  {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
    background-color: #ffeecc;
    border: 1px solid black
}

  table { border-collapse:collapse; }
  table, td, th { border:1px solid black; }
  caption { font-weight: bold; text-align: left ; }

</style>
  <style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

@media print {
    .removeOnSave {
        display: none;
    }
}
</style><link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/W3C-REC" />
<!--[if lt IE 9]><script src='https://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]-->
</head>
  <body class="h-entry" role="document" id="respecDocument"><div class="head" role="contentinfo" id="respecHeader">
  <p>
    
      <a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="https://www.w3.org/Icons/w3c_home" /></a>
    
  </p>
  <h1 property="dcterms:title" id="title" class="title p-name">RDF 1.1 Semantics</h1>
  
  <h2 content="2014-02-24T23:00:00.000Z" datatype="xsd:dateTime" property="dcterms:issued" id="w3c-recommendation-25-february-2014"><abbr title="World Wide Web Consortium">W3C</abbr> Recommendation <time datetime="2014-02-25" class="dt-published">25 February 2014</time></h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a href="http://www.w3.org/TR/2014/REC-rdf11-mt-20140225/" class="u-url">http://www.w3.org/TR/2014/REC-rdf11-mt-20140225/</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="http://www.w3.org/TR/rdf11-mt/">http://www.w3.org/TR/rdf11-mt/</a></dd>
    
    
    
      <dt>Test suite:</dt>
      <dd><a href="http://www.w3.org/TR/2014/NOTE-rdf11-testcases-20140225/">http://www.w3.org/TR/2014/NOTE-rdf11-testcases-20140225/</a></dd>
    
    
      <dt>Implementation report:</dt>
      <dd><a href="http://www.w3.org/2013/rdf-mt-reports/index.html">http://www.w3.org/2013/rdf-mt-reports/index.html</a></dd>
    
    
    
    
      <dt>Previous version:</dt>
      <dd><a href="http://www.w3.org/TR/2014/PR-rdf11-mt-20140109/" rel="dcterms:replaces">http://www.w3.org/TR/2014/PR-rdf11-mt-20140109/</a></dd>
    
    
      
          <dt>Previous Recommendation:</dt>
          <dd><a href="http://www.w3.org/TR/rdf-mt/" rel="dcterms:replaces">http://www.w3.org/TR/rdf-mt/</a></dd>
      
    
    <dt>Editors:</dt>
    <dd inlist="" rel="bibo:editor" class="p-author h-card vcard"><span typeof="foaf:Person"><a href="http://www.ihmc.us/groups/phayes/" content="Patrick J. Hayes" property="foaf:name" rel="foaf:homepage" class="u-url url p-name fn">Patrick J. Hayes</a>, <a href="http://www.ihmc.us/index.php" class="p-org org h-org h-card" rel="foaf:workplaceHomepage">Florida IHMC</a></span>
</dd>
<dd inlist="" rel="bibo:editor" class="p-author h-card vcard"><span typeof="foaf:Person"><span class="p-name fn" property="foaf:name">Peter F. Patel-Schneider</span>, <a href="http://www.nuance.com/" class="p-org org h-org h-card" rel="foaf:workplaceHomepage">Nuance Communications</a></span>
</dd>

    
    
  </dl>
  
    <p>
      Please check the <a href="http://www.w3.org/2014/rdf1.1-errata"><strong>errata</strong></a> for any errors or issues
      reported since publication.
    </p>
  
  
  
    <p>
      The English version of this specification is the only normative version. Non-normative
      <a href="http://www.w3.org/Consortium/Translation/">translations</a> may also be available.
    </p>
  
  
    
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©
        2004-2014
        
        <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
        (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
        <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), 
        
        All Rights Reserved.
        
        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
        
          <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
        
        rules apply.
      </p>
    
  
  <hr />
</div>
    <section id="abstract" class="introductory" property="dcterms:abstract" datatype="" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h2 aria-level="1" role="heading" id="h2_abstract">Abstract</h2>
    <p>  This document describes a precise semantics for the Resource Description
  Framework 1.1 [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>] and RDF Schema [<cite><a class="bibref" href="#bib-RDF11-SCHEMA">RDF11-SCHEMA</a></cite>]. It defines a number of distinct entailment regimes and corresponding patterns of entailment. It is part of a suite of documents which comprise the full specification of RDF 1.1.</p>
  </section><section class="introductory" id="sotd" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h2 aria-level="1" role="heading" id="h2_sotd">Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication.
          Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the
          latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at
          http://www.w3.org/TR/.</em>
        </p>
        
<p>This document is part of RDF 1.1 document suite.
This is a revision of the 2004 Semantics specification for RDF
[<cite><a class="bibref" href="#bib-RDF-MT">RDF-MT</a></cite>] and supersedes that
document.  For an informal summary of the substantive (non-editorial)
changes since then, see <a href="http://www.w3.org/2011/rdf-wg/wiki/Entailment_Changes">Entailment
Changes</a>. </p>

        <p>
          This document was published by the <a href="http://www.w3.org/2011/rdf-wg/">RDF Working Group</a> as a Recommendation.
          
          
            If you wish to make comments regarding this document, please send them to 
            <a href="mailto:public-rdf-comments@w3.org">public-rdf-comments@w3.org</a> 
            (<a href="mailto:public-rdf-comments-request@w3.org?subject=subscribe">subscribe</a>,
            <a href="http://lists.w3.org/Archives/Public/public-rdf-comments/">archives</a>).
          
          
          
          
            All comments are welcome.
          
        </p>
        
          <p>
            Please see the Working Group's  <a href="http://www.w3.org/2013/rdf-mt-reports/index.html">implementation
            report</a>.
          </p>
        
        
        
          <p>
            This document has been reviewed by <abbr title="World Wide Web Consortium">W3C</abbr> Members, by software developers, and by other <abbr title="World Wide Web Consortium">W3C</abbr>
            groups and interested parties, and is endorsed by the Director as a <abbr title="World Wide Web Consortium">W3C</abbr> Recommendation.
            It is a stable document and may be used as reference material or cited from another
            document. <abbr title="World Wide Web Consortium">W3C</abbr>'s role in making the Recommendation is to draw attention to the
            specification and to promote its widespread deployment. This enhances the functionality
            and interoperability of the Web.
          </p>
        
        
        <p>
          
            This document was produced by a group operating under the 
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/" rel="w3p:patentRules" about="" id="sotd_patent">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent
            Policy</a>.
          
          
          
            
              <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/46168/status">public list of any patent
              disclosures</a> 
            
            made in connection with the deliverables of the group; that page also includes
            instructions for disclosing a patent. An individual who has actual knowledge of a patent
            which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
            Claim(s)</a> must disclose the information in accordance with
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
          
          
        </p>
        
      
    
  
</section><section id="toc"><h2 class="introductory" aria-level="1" role="heading" id="h2_toc">Table of Contents</h2><ul class="toc" role="directory" id="respecContents"><li class="tocline"><a href="#introduction-1" class="tocxref"><span class="secno">1. </span>Introduction</a></li><li class="tocline"><a href="#conformance" class="tocxref"><span class="secno">2. </span>Conformance</a></li><li class="tocline"><a href="#semantic-extensions-and-entailment-regimes" class="tocxref"><span class="secno">3. </span>Semantic Extensions and Entailment Regimes</a></li><li class="tocline"><a href="#notation-and-terminology" class="tocxref"><span class="secno">4. </span>Notation and Terminology</a><ul class="toc"><li class="tocline"><a href="#shared-blank-nodes-unions-and-merges" class="tocxref"><span class="secno">4.1 </span>Shared blank nodes, unions and merges</a></li></ul></li><li class="tocline"><a href="#simple-interpretations" class="tocxref"><span class="secno">5. </span> Simple Interpretations</a><ul class="toc"><li class="tocline"><a href="#blank-nodes" class="tocxref"><span class="secno">5.1 </span>Blank nodes</a><ul class="toc"><li class="tocline"><a href="#shared-blank-nodes-informative" class="tocxref"><span class="secno">5.1.1 </span>Shared blank nodes (Informative)</a></li></ul></li><li class="tocline"><a href="#simpleentailment" class="tocxref"><span class="secno">5.2 </span>Simple Entailment</a></li><li class="tocline"><a href="#properties-of-simple-entailment-informative" class="tocxref"><span class="secno">5.3 </span>Properties of simple entailment (Informative) </a></li></ul></li><li class="tocline"><a href="#skolemization-informative" class="tocxref"><span class="secno">6. </span>Skolemization (Informative)</a></li><li class="tocline"><a href="#literals-and-datatypes" class="tocxref"><span class="secno">7. </span>Literals and datatypes</a><ul class="toc"><li class="tocline"><a href="#D_interpretations" class="tocxref"><span class="secno">7.1 </span>D-interpretations</a></li><li class="tocline"><a href="#datatype-entailment" class="tocxref"><span class="secno">7.2 </span>Datatype entailment</a><ul class="toc"><li class="tocline"><a href="#patterns-of-datatype-entailment-informative" class="tocxref"><span class="secno">7.2.1 </span>Patterns of datatype entailment (Informative)</a></li></ul></li></ul></li><li class="tocline"><a href="#rdf-interpretations" class="tocxref"><span class="secno">8. </span>RDF Interpretations</a><ul class="toc"><li class="tocline"><a href="#rdf-entailment" class="tocxref"><span class="secno">8.1 </span>RDF entailment</a><ul class="toc"><li class="tocline"><a href="#patterns-of-rdf-entailment-informative" class="tocxref"><span class="secno">8.1.1 </span>Patterns of RDF entailment (Informative)</a></li></ul></li></ul></li><li class="tocline"><a href="#rdfs-interpretations" class="tocxref"><span class="secno">9. </span>RDFS Interpretations</a><ul class="toc"><li class="tocline"><a href="#a-note-on-rdfs-literal-informative" class="tocxref"><span class="secno">9.1 </span>A note on rdfs:Literal (Informative)</a></li><li class="tocline"><a href="#rdfs-entailment" class="tocxref"><span class="secno">9.2 </span>RDFS entailment</a><ul class="toc"><li class="tocline"><a href="#patterns-of-rdfs-entailment-informative" class="tocxref"><span class="secno">9.2.1 </span>Patterns of RDFS entailment (Informative)</a></li></ul></li></ul></li><li class="tocline"><a href="#rdf-datasets" class="tocxref"><span class="secno">10. </span>RDF Datasets</a></li><li class="tocline"><a href="#entailment-rules-informative" class="tocxref"><span class="secno">A. </span>Entailment rules (Informative)</a></li><li class="tocline"><a href="#finite-interpretations-informative" class="tocxref"><span class="secno">B. </span>Finite interpretations (Informative)</a></li><li class="tocline"><a href="#proofs-of-some-results-informative" class="tocxref"><span class="secno">C. </span>Proofs of some results (Informative)</a></li><li class="tocline"><a href="#whatnot" class="tocxref"><span class="secno">D. </span>RDF reification, containers and collections (Informative)</a><ul class="toc"><li class="tocline"><a href="#reification" class="tocxref"><span class="secno">D.1 </span>Reification</a></li><li class="tocline"><a href="#rdf-containers" class="tocxref"><span class="secno">D.2 </span>RDF containers</a></li><li class="tocline"><a href="#rdf-collections" class="tocxref"><span class="secno">D.3 </span>RDF collections</a></li></ul></li><li class="tocline"><a href="#change-log-informative" class="tocxref"><span class="secno">E. </span>Change Log (informative)</a></li><li class="tocline"><a href="#acknowledgements-1" class="tocxref"><span class="secno">F. </span>Acknowledgements</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">G. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">G.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">G.2 </span>Informative references</a></li></ul></li></ul></section>



   <section class="introductory" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h2 id="notes" aria-level="1" role="heading">Notes</h2>
<p class="changenote">Notes in this style indicate changes from the 2004 RDF 1.0 semantics.</p>
<p class="technote">Notes in this style are technical asides on obscure or recondite matters.</p></section>
    <section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="introduction-1">
      
<!--OddPage-->
<h2 id="introduction" aria-level="1" role="heading"><span class="secno">1. </span>Introduction</h2>
      <p>
        This document defines a model-theoretic semantics for RDF graphs and the RDF and RDFS vocabularies, providing an exact formal specification of when truth is preserved by transformations of RDF or operations which derive RDF content from other RDF. </p>

    </section>
<section id="conformance" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter">
<!--OddPage-->
<h2 aria-level="1" role="heading" id="h2_conformance"><span class="secno">2. </span>Conformance</h2>
<p>
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,
  and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>
<p>
  The key words <em class="rfc2119" title="MUST">MUST</em>, <em class="rfc2119" title="MUST NOT">MUST NOT</em>, <em class="rfc2119" title="REQUIRED">REQUIRED</em>, <em class="rfc2119" title="SHOULD">SHOULD</em>, <em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em>, <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em>, <em class="rfc2119" title="MAY">MAY</em>,
  and <em class="rfc2119" title="OPTIONAL">OPTIONAL</em> in this specification are to be interpreted as described in [<cite><a class="bibref" href="#bib-RFC2119">RFC2119</a></cite>].
</p>
<p>This specification, <em>RDF 1.1 Semantics</em>, is normative for RDF semantics and the validity of RDF inference processes. It is not normative for many aspects of RDF meaning which are not described or specified by this semantics, including social issues of how IRIs are assigned meanings in use and how the referents of IRIs are related to Web content expressed in other media such as natural language texts. </p></section>

 <section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="semantic-extensions-and-entailment-regimes">
      
<!--OddPage-->
<h2 id="extensions" aria-level="1" role="heading"><span class="secno">3. </span>Semantic Extensions and Entailment Regimes</h2>
      <p>RDF is intended for use as a base notation for a variety of extended notations such as OWL [<cite><a class="bibref" href="#bib-OWL2-OVERVIEW">OWL2-OVERVIEW</a></cite>] and RIF [<cite><a class="bibref" href="#bib-RIF-OVERVIEW">RIF-OVERVIEW</a></cite>], whose expressions can be encoded as RDF graphs which use a particular vocabulary with a specially defined meaning. Also, particular IRI vocabularies may be given meanings by other specifications or conventions. When such extra meanings are assumed, a given RDF graph may support more extensive entailments than are sanctioned by the basic RDF semantics. In general, the more assumptions that are made about the meanings of IRIs in an RDF graph, the more entailments follow from those assumptions. </p>

<p>A particular such set of semantic assumptions is called a <dfn id="dfn-semantic-extension">semantic extension</dfn>. Each <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a> defines an <dfn id="dfn-entailment-regime">entailment regime</dfn> (used here in the same sense as in the SPARQL 1.1 Entailment Regime recommendation [<cite><a class="bibref" href="#bib-SPARQL11-ENTAILMENT">SPARQL11-ENTAILMENT</a></cite>] ) of entailments which are valid under that extension. RDFS, described later in this document, is one such <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>. We will refer to entailment regimes by names such as <em> RDFS entailment</em>, <em>D-entailment</em>, etc. </p>

<p><a href="#dfn-semantic-extension" class="internalDFN">Semantic extension</a>s <em class="rfc2119" title="MAY">MAY</em> impose special syntactic conditions or restrictions upon RDF graphs, such as requiring certain triples to be present, or prohibiting particular combinations of IRIs in triples, and <em class="rfc2119" title="MAY">MAY</em> consider RDF graphs which do not conform to these conditions to be errors. For example, RDF statements of the form <br /><br /> <code>ex:a rdfs:subClassOf &quot;Thing&quot;^^xsd:string .</code><br /><br /> are prohibited in the OWL <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a> based on description logics [<cite><a class="bibref" href="#bib-OWL2-SYNTAX">OWL2-SYNTAX</a></cite>]. In such cases, basic RDF operations such as taking a subset of triples, or combining RDF graphs, may cause syntax errors in parsers which recognize the extension conditions. None of the <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>s normatively defined in this document impose such syntactic restrictions on RDF graphs.</p>

<p>All entailment regimes <em class="rfc2119" title="MUST">MUST</em> be <dfn id="dfn-monotonic">monotonic</dfn> extensions of the simple entailment regime described in the document, in the sense that if A simply <a href="#dfn-entail" class="internalDFN">entail</a>s B then A also entails B under any extended notion of entailment, provided that any syntactic conditions of the extension are also satisfied. Put another way, a <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a> cannot &quot;cancel&quot; an entailment made by a weaker entailment regime, although it can treat the result as a syntax error.</p>
    </section>

 <section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="notation-and-terminology">
      
<!--OddPage-->
<h2 id="notation" aria-level="1" role="heading"><span class="secno">4. </span>Notation and Terminology</h2>


      <p>This document uses the following terminology for describing RDF graph syntax, all as defined in the companion RDF Concepts specification [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>]: <em><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN"><dfn id="dfn-iri">IRI</dfn></a></em>, <em><a href="http://www.w3.org/TR/rdf11-concepts/#section-triples" class="externalDFN"><dfn id="dfn-rdf-triple">RDF triple</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#section-rdf-graph" class="externalDFN"><dfn id="dfn-rdf-graph">RDF graph</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#section-triples" class="externalDFN"><dfn id="dfn-subject">subject</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#section-triples" class="externalDFN"><dfn id="dfn-predicate">predicate</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#section-triples" class="externalDFN"><dfn id="dfn-object">object</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-source" class="externalDFN"><dfn id="dfn-rdf-source">RDF source</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-node" class="externalDFN"><dfn id="dfn-node">node</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN"><dfn id="dfn-blank-node">blank node</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN"><dfn id="dfn-literal">literal</dfn></a>, <a href="http://www.w3.org/TR/rdf11-concepts/#graph-isomorphism" class="externalDFN"><dfn id="dfn-isomorphic">isomorphic</dfn></a>, and <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset" class="externalDFN"><dfn id="dfn-rdf-dataset">RDF dataset</dfn></a>.</em> All the definitions in this document apply unchanged to <a href="http://www.w3.org/TR/rdf11-concepts/#section-generalized-rdf" class="externalDFN">generalized RDF triples, graphs, and datasets</a>. </p>

<p>
An <dfn id="dfn-interpretation">interpretation</dfn> is a mapping from IRIs and literals into a set, together with some constraints upon the set and the mapping. This document defines various notions of interpretation, each corresponding in a standard way to an entailment regime. These are identified by prefixes such as <em>simple interpretation</em>, etc., and are defined in later sections. The unqualified term <em>interpretation</em> is usually used to refer to any compatible kind of interpretation in general, but if clear from the context might refer to a specific kind of interpretation.
</p><p>

</p><p>The words <dfn id="dfn-denote">denote</dfn><strong>s</strong> and <dfn id="dfn-refers-to">refers to</dfn> are used interchangeably as synonyms for the relationship between an IRI or literal and what it refers to in a given interpretation, itself called the <dfn id="dfn-denotation">denotation</dfn> or <dfn id="dfn-referent">referent</dfn>. IRI meanings may also be determined by other constraints external to the RDF semantics; when we wish to refer to such an externally defined naming relationship, we will use the word <dfn id="dfn-identify">identify</dfn> and its cognates. For example, the fact that the IRI <code>http://www.w3.org/2001/XMLSchema#decimal</code> is widely used as the name of a datatype described in the XML Schema document [<cite><a class="bibref" href="#bib-XMLSCHEMA11-2">XMLSCHEMA11-2</a></cite>] might be described by saying that the IRI <em>identifies</em> that datatype. If an IRI identifies something it may or may not refer to it in a given interpretation, depending on how the semantics is specified. For example, an IRI used as a graph name <a href="#dfn-identify" class="internalDFN">identify</a>ing a named graph in an <a class="external" href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF dataset</a> may refer to something different from the graph it identifies. </p>

<p>Throughout this document, the equality sign = indicates strict identity. The statement &quot;A = B&quot; means that there is one entity to which both expressions &quot;A&quot; and &quot;B&quot; refer.  Angle brackets &lt; x, y &gt; are used to indicate an ordered pair
  of x and y.</p>

<p>Throughout this document, <a href="#dfn-rdf-graph" class="internalDFN">RDF graph</a>s and other fragments of RDF abstract syntax are written using the notational conventions of the Turtle syntax [<cite><a class="bibref" href="#bib-TURTLE">TURTLE</a></cite>]. The namespace prefixes <code>rdf:</code> <code>rdfs:</code> and <code>xsd:</code> are used as in [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>], <a href="http://www.w3.org/TR/rdf11-concepts/#vocabularies">section 1.4</a>. When the exact IRI does not matter, the prefix <code>ex:</code> is used. When stating general rules or conditions we use three-character variables such as aaa, xxx, sss  to indicate arbitrary IRIs, literals, or other components of RDF syntax. Some cases are illustrated by node-arc diagrams showing the graph structure directly.</p>

<p>A <dfn id="dfn-name">name</dfn> is any IRI or literal. A typed literal contains
  two <a href="#dfn-name" class="internalDFN">name</a>s: itself and its internal type
  IRI. A <dfn id="dfn-vocabulary">vocabulary</dfn> is a set of <a href="#dfn-name" class="internalDFN">name</a>s.
</p>

<p>The <dfn id="dfn-empty-graph">empty graph</dfn> is the empty set of triples. </p>
<p>A <dfn id="dfn-subgraph">subgraph</dfn> of an RDF graph is a subset
  of the triples in the graph. A triple is identified with the singleton set
  containing it, so that each triple in a graph is considered to be a subgraph.
  A <dfn id="dfn-proper-subgraph">proper subgraph</dfn> is a proper subset of the triples in the graph. </p>


<p>A <dfn id="dfn-ground">ground</dfn> RDF graph is one that contains no blank
  nodes.</p>

<p>Suppose that M is a functional mapping from a set of blank
  nodes to some set of literals, blank nodes and IRIs. Any graph obtained
  from a graph G by replacing some or all of the blank nodes N in G by M(N) is
  an <dfn id="dfn-instance">instance</dfn> of G. Any graph is an instance of itself,
  an instance of an instance of G is an instance of G,
  and if H is an instance of G then every triple in H is an instance of at least one triple
  in G.</p>
<p>An <dfn id="dfn-instance-with-respect-to">instance with respect to</dfn> a vocabulary
  V is an <a href="#dfn-instance" class="internalDFN">instance</a> in which all the
  <a href="#dfn-name" class="internalDFN">name</a>s in the instance that were substituted
  for blank nodes in the original are <a href="#dfn-name" class="internalDFN">name</a>s
  from V.</p>
<p>A <dfn id="dfn-proper-instance">proper instance</dfn> of a graph
  is an <a href="#dfn-instance" class="internalDFN">instance</a> in which a blank node has been replaced by a <a href="#dfn-name" class="internalDFN">name</a>, or two blank
  nodes in the graph have been mapped into the same node in the instance. </p>
<p>Two graphs are <a href="http://www.w3.org/TR/rdf11-concepts/#graph-isomorphism" class="externalDFN">isomorphic</a> when each maps into the other by a 1:1 mapping on blank nodes. Isomorphic graphs are mutual instances with an invertible instance
  mapping. As blank nodes have no particular identity beyond their location in a graph, we will often treat isomorphic graphs as identical.</p>

<p>An RDF graph is <dfn id="dfn-lean">lean</dfn> if it has no instance which is
  a proper subgraph of itself. Non-lean graphs have internal redundancy
  and express the same content as their lean subgraphs. For example, the graph</p>
<p><code>ex:a ex:p _:x .<br />
  _:y ex:p _:x .</code></p>
<p>is not lean, but</p>
<p><code>ex:a ex:p _:x .<br />
  _:x ex:p _:x .</code></p>
<p>is lean. <a href="#dfn-ground" class="internalDFN">Ground</a> graphs are lean. </p>


<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="shared-blank-nodes-unions-and-merges"> <h3 id="unions_merges" aria-level="2" role="heading"><span class="secno">4.1 </span>Shared blank nodes, unions and merges</h3>
<p>
Graphs share blank nodes only if they are derived from graphs
described by documents or other structures (such as an RDF dataset) that explicitly provide for the sharing of blank nodes between different RDF graphs.  Simply downloading a
web document does not mean that the blank nodes in a resulting RDF
graph are the same as the blank nodes coming from other downloads of
the same document or from the same <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-source" class="externalDFN">RDF source</a>.</p>

<p> RDF applications which manipulate concrete syntaxes for RDF which use blank node identifiers should take care to keep track of the identity of the blank nodes they identify. Blank node identifiers often have a local scope, so when RDF from different sources is combined, identifiers may have to be changed in order to avoid accidental conflation of distinct blank nodes.</p>
<p> For example, two documents may both use the blank node identifier &quot;<code>_:x</code>&quot; to identify a blank node, but unless these documents are in a shared identifier scope or are derived from a common source, the occurrences of &quot;<code>_:x</code>&quot; in one document will identify a different blank node than the one in the graph described by the other document. When graphs are formed by combining RDF from multiple sources, it may be necessary to <dfn id="dfn-standardize">standardize</dfn> apart the blank node identifiers by replacing them by others which do not occur in the other document(s). For example, the two graphs represented  by the following texts: </p>
<p><code>ex:a ex:p _:x . </code><br /><br />
<img alt="Graph 1" src="RDF11SemanticsDiagrams/example1.jpg" /></p>
<p><code>ex:b ex:q _:x . </code><br /><br />
<img alt="Graph 2" src="RDF11SemanticsDiagrams/example2.jpg" /></p>

<p>contain four nodes. Their union would therefore also contain four nodes:</p>

<p><img alt="Union Graph" src="RDF11SemanticsDiagrams/example4.jpg" /></p>

<p> However, the document formed by simply concatenating these textual surface representations: </p>

<p><code>ex:a ex:p _:x .<br />
ex:b ex:q _:x .</code><br /></p>

<p>describes a graph containing three nodes:</p>
<p><img alt="Incorrect Union Graph" src="RDF11SemanticsDiagrams/example3.jpg" /></p>
<p> since the two occurrences of the blank node identifier &quot;<code>_:x</code>&quot; occurring in a common identifier scope identify the same blank node. The four-node union of these two graphs is more properly described by a surface form such as:</p>
<p><code>ex:a ex:p _:x1 .<br />
ex:b ex:q _:x2 .</code></p>

<p>in which the blank node identifiers have been <a href="#dfn-standardize" class="internalDFN">standardize</a>d apart to avoid conflating the distinct blank nodes. (The particular blank node identifiers used have no significance, only that they are distinct.) </p>

<p>It is possible for two or more graphs to share a blank node, for example if they are subgraphs of a single larger graph or derived from a common source. In this case, the union of a set of graphs preserves the identity of blank nodes shared between the graphs. In general, the union of a set of RDF graphs accurately represents the same semantic content as the graphs themselves, whether or not they share blank nodes. </p>
<p>A related operation, called <dfn id="dfn-merging">merging</dfn>, takes the union after forcing any shared blank nodes, which occur in more than one graph, to be distinct in each graph. The resulting graph is called the <dfn id="dfn-merge">merge</dfn>. The merge of subgraphs of a graph may be larger than the original graph. For example, the result of merging the two singleton subgraphs of the three-node graph</p>

<p><img alt="Three-node Graph" src="RDF11SemanticsDiagrams/example3.jpg" /></p>

<p>is the four-node graph</p>

<p><img alt="Four-node Graph" src="RDF11SemanticsDiagrams/example4.jpg" /></p>

<p>The union is always an instance of the merge. If graphs have no blank nodes in common, then their merge and union are identical. </p>


</section>

</section>

 <section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="simple-interpretations">
      
<!--OddPage-->
<h2 id="simple" aria-level="1" role="heading"><span class="secno">5. </span> Simple Interpretations</h2>

<p>This section defines the basic notions of simple interpretation and truth for RDF graphs. All <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>s of any vocabulary or higher-level notation encoded in RDF <em class="rfc2119" title="MUST">MUST</em> conform to these minimal truth conditions. Other <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>s may extend and add to these, but they <em class="rfc2119" title="MUST NOT">MUST NOT</em> modify or negate them. For example, because simple interpretations are mappings which apply to IRIs, a <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a> cannot interpret different occurrences of a single IRI differently.</p>

<p>The entire semantics applies to <a href="#dfn-rdf-graph" class="internalDFN">RDF graph</a>s, not to <a href="#dfn-rdf-source" class="internalDFN">RDF source</a>s. An <a href="#dfn-rdf-source" class="internalDFN">RDF source</a> has a semantic meaning only through the graph that is its value at a given time, or in a given state. Graphs cannot change their semantics with time.</p>


<p>A <dfn id="dfn-simple-interpretation">simple interpretation</dfn> I is a structure consisting of:</p>

<table>
<caption>Definition of a simple interpretation.</caption>
  <tbody><tr>
        <td class="semantictable">1. A non-empty set IR of resources, called the domain or universe
            of I.
      <p>2. <span>A set IP, called the set of properties of I.</span></p>
          <p>3. A mapping IEXT from IP into the powerset of IR x IR i.e. the
            set of sets of pairs &lt; x, y &gt; with x and y in IR .</p>
      <p>4. A mapping IS from IRIs into (IR union IP)</p>
      <p>5. A partial mapping IL from literals into IR </p>
     </td>
  </tr>
  </tbody></table>

<p class="changenote">The 2004 RDF 1.0 semantics defined simple interpretations relative to a vocabulary.<br /><br />In the 2004 RDF 1.0 semantics, IL was a total, rather than partial, mapping.<br /><br /> The 2004 RDF 1.0 specification divided literals into 'plain' literals with no type and optional language tags, and typed literals. Usage has shown that it is important that every literal have a type. RDF 1.1 replaces plain literals without language tags by literals typed with the XML Schema <code>string</code> datatype, and introduces the special type <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string"><code>rdf:langString</code></a> for language-tagged strings. The full semantics for typed literals is given in the next section. </p>

<p class="technote"> Simple interpretations are required to interpret all <a href="#dfn-name" class="internalDFN">name</a>s, and are therefore infinite. This simplifies the exposition. However, RDF can be interpreted using finite structures, supporting decidable algorithms. Details are given in Appendix B. </p>


<p>IEXT(x), called
      the <dfn id="dfn-extension">extension</dfn> of x, is a
      set of pairs which identify the arguments for which the property is true,
      that is, a binary relational extension.
      </p>
<p>The distinction between IR and IL will become significant below when the semantics of datatypes are defined. IL is allowed to be partial because some literals may fail to have a referent. </p>

<p class="technote">
It is conventional to map a relation name to a relational extension directly.  This however presumes that the vocabulary is segregated into relation names and individual names, and RDF makes no such assumption. Moreover, RDF allows an IRI to be used as a relation name applied to itself as an argument. Such self-application structures are used in RDFS, for example. The use of the IEXT mapping to distinguish the relation as an object from its relational extension accommodates both of these requirements. It also provides for a notion of RDFS 'class' which can be distinguished from its set-theoretic extension. A similar technique is used in the ISO/IEC Common Logic standard [<cite><a class="bibref" href="#bib-ISO24707">ISO24707</a></cite>].
</p>



 <p>The denotation of a ground RDF graph in a simple interpretation I is then given by the following
  rules, where the interpretation is also treated as a function from expressions (names, triples and graphs) to elements of the universe and truth values:</p>


  <table>
  <caption>Semantic conditions for ground graphs.</caption>
        <tbody>
          <tr>
      <td class="semantictable">if E is a literal then I(E) = IL(E)</td>
          </tr>

          <tr>
      <td class="semantictable">if E is an IRI then I(E) = IS(E)</td>
          </tr>

          <tr>
        <td class="semantictable"><p>if E is a ground triple s p o<code>.</code>
          then I(E) = true if </p>
        <p>I(p) is in IP and the pair &lt;I(s),I(o)&gt;
          is in IEXT(I(p))</p>
          <p>otherwise I(E) = false.</p></td>
          </tr>

          <tr>
            <td class="semantictable">if E is a ground RDF graph then I(E) = false if I(E') =
            false for some triple E' in E, otherwise I(E) =true.</td>
          </tr>
        </tbody>
  </table>


<p> If IL(E) is undefined for some literal E then E has no semantic value, so any triple containing it will be false, so any graph containing that triple will also be false.</p>
<p> The final condition implies that the empty graph (the empty set of triples) is always true.</p>
<p>The sets IP and IR may overlap, indeed IP can be a subset of IR. Because of the domain conditions on IEXT, the denotation of the subject and object of any true triple will be in IR; so any IRI which occurs in a graph both as a predicate and as a subject or object will denote something in the intersection of IP and IR.</p>

<p><a href="#dfn-semantic-extension" class="internalDFN">Semantic extension</a>s may impose further constraints upon interpretation mappings by requiring some IRIs to refer in particular ways. For example, D-interpretations, described below, require some IRIs, understood as <a href="#dfn-identify" class="internalDFN">identify</a>ing and referring to datatypes, to have a fixed denotation. </p>

<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="blank-nodes">
  <h3 id="blank_nodes" aria-level="2" role="heading"><span class="secno">5.1 </span>Blank nodes</h3>


<p>Blank nodes are treated as simply indicating the existence of a thing, without using an IRI to <a href="#dfn-identify" class="internalDFN">identify</a> any particular thing. This is not the same as assuming that the blank node indicates an 'unknown' IRI.
</p>

<p> Suppose I is a simple interpretation and A is a mapping from a set of blank nodes to the universe IR of I. Define the mapping [I+A] to be I on <a href="#dfn-name" class="internalDFN">name</a>s, and A on blank nodes on the set: [I+A](x)=I(x) when x is a <a href="#dfn-name" class="internalDFN">name</a> and [I+A](x)=A(x) when x is a blank node; and extend this mapping to triples and RDF graphs using the rules given above for ground graphs. Then the semantic conditions for an RDF graph are:</p>

      <table>
      <caption>Semantic condition for blank nodes.</caption>
        <tbody>
          <tr>
            <td class="semantictable">If E is an RDF graph then I(E) = true if [I+A](E) =
            true for some mapping A from the set of blank nodes in E to IR, otherwise
            I(E)= false.</td>
          </tr>
        </tbody>
      </table>

<p>Mappings from blank nodes to referents are not part of the definition of a simple interpretation, since the truth condition refers only to <em>some</em> such mapping.
Blank nodes themselves differ from other nodes in not being assigned
a denotation by a simple interpretation, reflecting the intuition that
they have no 'global' meaning. </p>

<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="shared-blank-nodes-informative"><h4 id="shared_blank_nodes" aria-level="3" role="heading"><span class="secno">5.1.1 </span>Shared blank nodes (Informative)</h4><p><em>This section is non-normative.</em></p>

<p> The semantics for blank nodes are stated in terms of the truth of a graph. However, when two (or more) graphs share a blank node, their meaning is not fully captured by treating them in isolation. For example, consider the overlapping graphs</p>
<p><img alt="Overlapping Graphs" src="RDF11SemanticsDiagrams/example5.jpg" /></p>
<p> and a simple interpretation I over the universe {Alice, Bob, Monica, Ruth} with:<br />
I(<code>ex:Alice</code>)=Alice, I(<code>ex:Bob</code>)=Bob, IEXT(I(<code>ex:hasChild</code>))={&lt;Alice,Monica&gt;,&lt;Bob,Ruth&gt; }<br /></p>
<p>Each of the inner graphs is true under this interpretation, but the two of them together is not, because the three-node graph says that Alice and Bob have a child together. In order to capture the full meaning of graphs sharing a blank node, it is necessary to consider the union graph containing all the triples which contain the blank node.</p>
<p class="technote"> RDF graphs can be viewed as conjunctions of simple atomic sentences in first-order logic, where blank nodes are free variables which are understood to be existential. Taking the union of two graphs is then analogous to syntactic conjunction in this syntax. RDF syntax has no explicit variable-binding quantifiers, so the truth conditions for any RDF graph treat the free variables in that graph as existentially quantified in that graph. Taking the union of graphs which share a blank node changes the implied quantifier scopes.
</p>


</section>
</section>


<!-- commented out, to be removed later
<section class="informative">
<h3 id="intuitions" class="informative">Intuitive summary (Informative)</h3>

<p>An RDF graph is true exactly when:</p>
<p>1. the IRIs and literals in subject or object position in the graph all refer to things,</p><p>2. there is some way to interpret all the blank nodes in the graph as referring to things,</p><p>3. the IRIs in property position refer to binary relationships,</p><p>4. and under these interpretations, each triple S P O in the graph asserts that the thing referred to as S, and the thing referred to as O, do in fact stand in the relationship referred to by P. </p>

</section>
-->


<section id="simpleentailment" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_simpleentailment"><span class="secno">5.2 </span>Simple Entailment</h3>

<p>Following standard terminology, we say that I (simply) <dfn id="dfn-satisfies">satisfies</dfn> E when I(E)=true, that E is (simply) <dfn id="dfn-satisfiable">satisfiable</dfn> when a simple interpretation exists which satisfies it, otherwise (simply) <dfn id="dfn-unsatisfiable">unsatisfiable</dfn>, and that a graph G simply <dfn id="dfn-entail">entail</dfn><strong>s</strong> a graph E when every interpretation which satisfies G also satisfies E. If two graphs E and F each entail the other then they are logically <dfn id="dfn-equivalent">equivalent</dfn>.</p>
<p>In later sections these notions will be adapted to other classes of interpretations, but throughout this section 'entailment' should be interpreted as meaning simple entailment.
</p>

<p class="technote">We do not define a notion of entailment between sets of graphs. To determine whether a set of graphs entails a graph, the graphs in the set must first be combined into one graph, either by taking the union or the merge of the graphs. Unions preserve the common meaning of shared blank nodes, while merging effectively ignores any sharing of blank nodes. Merging the set of graphs produces the same definition of entailment by a set that was defined in the 2004 RDF 1.0 specification.</p>

    <p>Any process which constructs a graph E from
    some other graph S is (simply) <dfn id="dfn-valid">valid</dfn> if S
    simply entails E in every case, otherwise <dfn id="dfn-invalid.x">invalid.</dfn></p>

<p>The fact that an inference is valid should not be understood as meaning that any RDF application is obliged or required to make the inference. Similarly, the logical invalidity of some RDF transformation or process does not mean that the process is incorrect or prohibited. Nothing in this specification requires or prohibits any particular operations on RDF graphs or sources. Entailment and validity are concerned solely with establishing the conditions on such operations which guarantee the preservation of truth. While logically invalid processes, which do not follow valid entailments, are not prohibited, users should be aware that they may be at risk of introducing falsehoods into true RDF data. Nevertheless, particular uses of logically invalid processes may be justified and appropriate for data processing under circumstances where truth can be ensured by other means. </p>

<p>Entailment refers only to the truth of RDF graphs, not to their suitability for any other purpose. It is possible for an RDF graph to be fitted for a given purpose and yet validly entail another graph which is not appropriate for the same purpose. An example is the RDF test cases manifest [<cite><a class="bibref" href="#bib-RDF-TESTCASES">RDF-TESTCASES</a></cite>] which is provided as an RDF document for user convenience. This document lists examples of correct entailments by describing their antecedents and conclusions. Considered as an RDF graph, the manifest simply entails a subgraph which omits the antecedents, and would therefore be incorrect if used as a test case manifest. This is not a violation of the RDF semantic rules, but it shows that the property of <em> &quot;being a correct RDF test case manifest&quot;</em> is not preserved under RDF entailment, and therefore cannot be described as an RDF <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>. Such entailment-risky uses of RDF should be restricted to cases, as here, where it is obvious to all parties what the intended special restrictions on entailment are, in contrast with the more normal case of using RDF for the open publication of data on the Web.</p>

</section>

<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="properties-of-simple-entailment-informative">

<h3 id="simple_entailment_properties" aria-level="2" role="heading"><span class="secno">5.3 </span>Properties of simple entailment (Informative) </h3><p><em>This section is non-normative.</em></p>
<p>The properties described here apply only to simple entailment, not to extended notions of entailment introduced in later sections. Proofs are given in Appendix C. </p>

<p class="fact">Every graph is simply satisfiable.</p>

<p>This does not always hold for extended notions of interpretation. For example, a graph containing an <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a> literal is <a href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiable</a>.</p>

<p>The following <dfn id="dfn-interpolation">interpolation</dfn> <strong>lemma</strong> </p>

  <p class="fact">
  G simply entails a graph E if and only if a subgraph of G is an instance of E.
</p>

<p> completely characterizes simple entailment in syntactic
  terms. To detect whether one RDF graph simply entails another, check that
  there is some instance of the entailed graph which is a subset of the first graph. </p>

<p class="technote">This is clearly decidable, but it is also difficult to determine in general, since one can encode the NP-hard subgraph problem (detecting whether one mathematical graph is a subgraph of another) as detecting simple entailment between RDF graphs. This construction (due to Jeremy Carroll) uses graphs all of whose nodes are blank nodes. The complexity of checking simple entailment is reduced by having fewer blank nodes in the conclusion E. When E is a <a href="#dfn-ground" class="internalDFN">ground</a> graph, it is simply a matter of checking the subset relationship on sets of triples.</p>

<p><a href="#dfn-interpolation" class="internalDFN">Interpolation</a> has a number of direct consequences, for example:</p>

<p class="fact"> The <a href="#dfn-empty-graph" class="internalDFN">empty graph</a> is simply entailed by
  any graph, and does not simply entail any graph except itself.

<!-- <a href="#emptygraphlemmaprf" class="termref">[Proof]</a> -->

</p>
<p class="fact"> A graph simply entails all its subgraphs.

<!-- <a href="#subglemprf" class="termref">[Proof]</a> -->

</p>
<p class="fact"> A graph
  is simply entailed by any of its <a href="#dfn-instance" class="internalDFN">instance</a>s.

<!-- <a href="#instlemprf" class="termref"> [Proof]</a> -->

</p>
<p class="fact"> If
  E is a <a href="#dfn-lean" class="internalDFN">lean</a> graph and E' is a <a href="#dfn-proper-instance" class="internalDFN">proper instance</a> of E, then E does
  not simply entail E'.
</p>

<p class="fact"> If S is a subgraph of S' and S simply entails E, then S' simply entails E.

<!-- <a href="#monotonicitylemmaprf" class="termref"> [Proof]</a> -->

</p>
<p class="fact">
  If S entails a finite graph E, then some finite subset S' of S entails E.

<!-- <a href="#compactlemmaprf" class="termref"> [Proof]</a> -->

</p>
<p>The property just above is called <em>compactness</em> - RDF is compact. As RDF graphs can be infinite, this is sometimes important.</p>

<p class="fact"> If E contains an IRI which does not occur anywhere in S, then S does not simply entail E.</p>


</section>
</section>

<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="skolemization-informative">
<!--OddPage-->
<h2 id="skolemization" aria-level="1" role="heading"><span class="secno">6. </span>Skolemization (Informative)</h2><p><em>This section is non-normative.</em></p>
<p><a class="externaldefinition internalDFN" href="#dfn-skolemization"><dfn id="dfn-skolemization">Skolemization</dfn></a> is a transformation on RDF graphs which eliminates blank nodes by replacing them with &quot;new&quot; IRIs, which means IRIs which are coined for this purpose and are therefore guaranteed to not occur in any other RDF graph (at the time of creation). See <a href="http://www.w3.org/TR/rdf11-concepts/#section-skolemization">Section 3.5</a> of [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>] for a fuller discussion. </p>
<p> Suppose G is a graph containing blank nodes and sk is a skolemization mapping from the blank nodes in G to the skolem IRIs which are substituted for them, so that sk(G) is a skolemization of G.  Then the semantic relationship between them can be summarized as follows. </p>

<p class="fact">   sk(G) simply entails G (since sk(G) is an instance of G.)</p>
<p class="fact">   G does not simply entail sk(G) (since sk(G) contains IRIs not in G.) </p>
<p class="fact">  For any graph H, if sk(G) simply entails H then there is a graph H' such that G entails H' and H=sk(H') . </p>
<p class="fact">  For any graph H which does not contain any of the &quot;new&quot; IRIs introduced into sk(G), sk(G) simply entails H if and only if G simply entails H.
</p>

<p>The second property means that a graph is not logically <a href="#dfn-equivalent" class="internalDFN">equivalent</a> to its skolemization. Nevertheless, they are in a strong sense almost interchangeable, as shown the next two properties. The third property means that even when conclusions are drawn from the skolemized graph which do contain the new vocabulary, these will exactly mirror what could have been derived from the original graph with the original blank nodes in place. The replacement of blank nodes by IRIs does not effectively alter what can be validly derived from the graph, other than by giving new names to what were formerly anonymous entities. The fourth property, which is a consequence of the third, clearly shows that in some sense  a skolemization of G can &quot;stand in for&quot; G as far as entailments are concerned. Using sk(G) instead of G will not affect any entailments which do not involve the new skolem vocabulary.  </p>

</section>

<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="literals-and-datatypes">
<!--OddPage-->
<h2 id="datatypes" aria-level="1" role="heading"><span class="secno">7. </span>Literals and datatypes</h2>
<p class="changenote">  In the 2004 RDF 1.0 specification, datatype D-entailment was defined as a <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a> of RDFS-entailment. Here it is defined as a direct extension to basic RDF. This is more in conformity with actual usage, where RDF with datatypes is widely used without the RDFS vocabulary. If there is a need to distinguish this from the 2004 RDF 1.0 terminology, the longer phrasing &quot;simple D-entailment&quot; or &quot;simple datatype entailment&quot; should be used rather than &quot;D-entailment&quot;. </p>

<p> Datatypes are <a title="identify" href="#dfn-identify" class="internalDFN">identified</a> by IRIs. Interpretations will vary according to which IRIs are recognized as denoting datatypes. We describe this using a parameter D on simple interpretations, where D is the set of <dfn id="dfn-recognize">recognize</dfn><em><strong>d</strong></em> datatype IRIs. </p>

<p class="changenote">The previous version of this specification defined the parameter D as a <a href="#dfn-datatype-map" class="internalDFN">datatype map</a> from IRIs to datatypes, i.e. as a restricted kind of interpretation mapping. As the current semantics presumes that a recognized IRI identifies a unique datatype, this IRI-to-datatype mapping is globally unique and externally specified, so we can think of D as either a set of IRIs or as a fixed <a href="#dfn-datatype-map" class="internalDFN">datatype map</a>. Formally, the <dfn id="dfn-datatype-map">datatype map</dfn> corresponding to the set D is the restriction of a <a href="#dfn-d-interpretation" class="internalDFN">D-interpretation</a> to the set D. Semantic extensions which are stated in terms of conditions on <a href="#dfn-datatype-map" class="internalDFN">datatype map</a>s can be interpreted as applying to this mapping. </p>

<p>The exact mechanism by which an IRI <a title="identify" href="#dfn-identify" class="internalDFN">identifies</a> a datatype is considered to be external to the semantics, but the semantics presumes that a recognized IRI <a title="identify" href="#dfn-identify" class="internalDFN">identifies</a> a unique datatype wherever it occurs. RDF processors which are not able to determine which datatype is identified by an IRI cannot <a href="#dfn-recognize" class="internalDFN">recognize</a> that IRI, and should treat any literals with that IRI as their datatype IRI as unknown names. </p>

<p>RDF literals and datatypes are fully described in <a href="http://www.w3.org/TR/rdf11-concepts/#section-Datatypes"> Section 5</a> of [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>]. In summary: with one exception, RDF literals combine a string and an IRI <a href="#dfn-identify" class="internalDFN">identify</a>ing a datatype. The exception is <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string">language-tagged strings</a>, which have two syntactic components, a string and a language tag, and are assigned the type <code>rdf:langString</code>. A datatype is understood to define a partial mapping, called the <dfn id="dfn-lexical-to-value-mapping">lexical-to-value mapping</dfn>, from a lexical space (a set of character strings) to values. The function <dfn id="dfn-l2v">L2V</dfn> maps datatypes to their lexical-to-value mapping. A literal with datatype d denotes the value obtained by applying this mapping to the character string sss: L2V(d)(sss). If the literal string is not in the lexical space, so that the lexical-to-value mapping gives no value for the literal string, then the literal has no referent. The <dfn id="dfn-value-space">value space</dfn> of a datatype is the range of the <a href="#dfn-lexical-to-value-mapping" class="internalDFN">lexical-to-value mapping</a>. Every literal with that type either refers to a value in the value space of the type, or fails to refer at all. An  <dfn id="dfn-ill-typed">ill-typed</dfn> literal is one whose datatype IRI is <a href="#dfn-recognize" class="internalDFN">recognize</a>d, but whose character string is assigned no value by the <a href="#dfn-lexical-to-value-mapping" class="internalDFN">lexical-to-value mapping</a> for that datatype. </p>

<p> RDF processors are not required to <a href="#dfn-recognize" class="internalDFN">recognize</a> any datatype IRIs other than <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string"><code>rdf:langString</code></a> and <a href="http://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a>, but when IRIs listed in <a href="http://www.w3.org/TR/rdf11-concepts/#section-Datatypes">Section 5</a> of [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>] are <a href="#dfn-recognize" class="internalDFN">recognize</a>d, they <em class="rfc2119" title="MUST">MUST</em> be interpreted as described there, and when the IRI <code>rdf:PlainLiteral</code> is <a href="#dfn-recognize" class="internalDFN">recognize</a>d, it <em class="rfc2119" title="MUST">MUST</em> be interpreted to refer to the datatype defined in [<cite><a class="bibref" href="#bib-RDF-PLAIN-LITERAL">RDF-PLAIN-LITERAL</a></cite>]. RDF processors <em class="rfc2119" title="MAY">MAY</em> recognize other datatype IRIs, but when other datatype IRIs are <a href="#dfn-recognize" class="internalDFN">recognize</a>d, the mapping between the datatype IRI and the datatype it refers to <em class="rfc2119" title="MUST">MUST</em> be specified unambiguously, and <em class="rfc2119" title="MUST">MUST</em> be fixed during all RDF transformations or manipulations. In practice, this can be achieved by the IRI linking to an external specification of the datatype which describes both the components of the datatype itself and the fact that the IRI identifies the datatype, thereby fixing a value of the <a href="#dfn-datatype-map" class="internalDFN">datatype map</a> of this IRI.</p>

<p>Literals with <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string"><code>rdf:langString</code></a> as their datatype are an exceptional case which are given a special treatment. The IRI <code>rdf:langString</code> is classified as a datatype IRI, and interpreted to refer to a datatype, even though no L2V mapping is defined for it. The value space of <code>rdf:langString</code> is the set of all pairs of a string with a language tag. The semantics of literals with this as their type are given below. </p>

<p>RDF literal syntax allows any IRI to be used in a typed literal, even when it is not <a href="#dfn-recognize" class="internalDFN">recognize</a>d as referring to a datatype. Literals with such an &quot;unknown&quot; datatype IRI, which is not in the set of <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatypes, <em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em> be treated as errors, although RDF applications <em class="rfc2119" title="MAY">MAY</em> issue a warning. Such literals <em class="rfc2119" title="SHOULD">SHOULD</em> be treated like IRIs and assumed to denote some thing in the universe IR. RDF processors which do not <a href="#dfn-recognize" class="internalDFN">recognize</a> a datatype IRI will not be able to detect some entailments which are visible to one which does.  For example, the fact that </p><p><code>ex:a ex:p &quot;20.0000&quot;^^xsd:decimal .</code></p><p>entails </p><p><code>ex:a ex:p &quot;20.0&quot;^^xsd:decimal .</code></p><p>will not be visible to a processor which does not <a href="#dfn-recognize" class="internalDFN">recognize</a> the datatype IRI <code>xsd:decimal</code>.</p>


<section id="D_interpretations" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_D_interpretations"><span class="secno">7.1 </span>D-interpretations</h3>
<p>Let D be a set of IRIs <a href="#dfn-identify" class="internalDFN">identify</a>ing datatypes. A  <strong>(simple)</strong> <dfn id="dfn-d-interpretation">D-interpretation</dfn> is a <a href="#dfn-simple-interpretation" class="internalDFN">simple interpretation</a>  which satisfies the following conditions:</p>

<table>
<caption>Semantic conditions for datatyped literals.</caption>
    <tbody>
<tr><td class="semantictable">If <code>rdf:langString</code> is in D, then for every language-tagged string E with lexical form sss and language tag ttt, IL(E)= &lt; sss, ttt' &gt;, where ttt' is ttt converted to lower case using US-ASCII rules </td></tr>

<tr><td class="semantictable">For every other IRI aaa in D, I(aaa) is the datatype identified by aaa, and for every literal &quot;sss&quot;^^aaa, IL(&quot;sss&quot;^^aaa) = L2V(I(aaa))(sss)</td></tr>
</tbody></table>


<p>If the literal is <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a> then the L2V(I(aaa)) mapping has no value, and so the literal cannot denote anything. In this case, any triple containing the literal must be false. Thus, any triple, and hence any graph, containing an <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a> literal will be  <a href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiable</a>, i.e. false in every D-interpretation. This applies only to literals typed with recognized datatype IRIs in D; literals with an unrecognized type IRI are not <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a> and cannot give rise to a <a href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiable</a> graph. </p>

<p>The special datatype <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string"><code>rdf:langString</code></a> has no <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a> literals. Any syntactically legal literal with this type will denote a value in every D-interpretation where D includes <code>rdf:langString</code>. The only ill-typed literals of type <a href="http://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a> are those containing a Unicode code point which does not match the <a href="http://www.w3.org/TR/xml11/#NT-Char"><em>Char</em> production</a> in [<cite><a class="bibref" href="#bib-XML10">XML10</a></cite>]. Such strings cannot be written in an XML-compatible surface syntax.

</p>






<p class="changenote">  In the 2004 RDF 1.0 specification, ill-typed literals were required to denote a value in IR, and <a title="D-unsatisfiable" href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiability</a> could be recognized only by using the RDFS semantics. </p>


</section>
<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="datatype-entailment">
<h3 id="D_entailment" aria-level="2" role="heading"><span class="secno">7.2 </span>Datatype entailment</h3>

<p>A graph is (simply) <dfn id="dfn-d-satisfiable">D-satisfiable</dfn> or <dfn id="dfn-satisfiable-recognizing-d">satisfiable recognizing D</dfn> when it has the value true in some D-interpretation, and a graph S (simply) <dfn id="dfn-d-entails">D-entails</dfn> or <dfn id="dfn-entails-recognizing-d">entails recognizing D</dfn> a graph G when every D-interpretation which satisfies S also D-satisfies G.</p>

<p> Unlike the case with <a href="#dfn-simple-interpretation" class="internalDFN">simple interpretation</a>s, it is possible for a graph to have no satisfying D-interpretations, i.e. to be <dfn id="dfn-d-unsatisfiable">D-unsatisfiable</dfn>. RDF processors <em class="rfc2119" title="MAY">MAY</em> treat an unsatisfiable graph as signaling an error condition, but this is not required.</p>

<p> A <a href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiable</a> graph D-entails any graph.</p>

<p class="technote">The fact that an unsatisfiable statement entails any other statement has been known since antiquity. It is called the principle of <em>ex falso quodlibet</em>. It should not be interpreted to mean that it is necessary, or even permissible, to actually draw any conclusion from an unsatisfiable graph.</p>

<p>In all of this language, 'D' is being used as a parameter to represent some set of datatype IRIs, and different D sets will yield different notions of satisfiability and entailment. The more datatypes are <a href="#dfn-recognize" class="internalDFN">recognize</a>d, the stronger is the entailment, so that if D ⊂ E and S E-entails G then S must D-entail G. Simple entailment is { }-entailment, i.e. D-entailment when D is the empty set, so if S D-entails G  then S simply entails G. </p>



<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="patterns-of-datatype-entailment-informative"> <h4 id="datatype_entailment_patterns" aria-level="3" role="heading"><span class="secno">7.2.1 </span>Patterns of datatype entailment (Informative)</h4><p><em>This section is non-normative.</em></p>
<p>Unlike <a title="entail" href="#dfn-entail" class="internalDFN">simple entailment</a>, it is not possible to give a single syntactic criterion to detect all D-entailments, which
can hold because of particular properties of the lexical-to-value mappings of the  <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatypes. For example, if D contains <code>xsd:decimal</code> then </p>

<p><code>ex:a ex:p &quot;25.0&quot;^^xsd:decimal .</code></p>

<p>D-entails</p>

<p><code>ex:a ex:p &quot;25&quot;^^xsd:decimal .</code>
</p>

<p>In general, any triple containing a literal with a <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatype IRI D-entails another literal when the lexical strings of the literals map to the same value under the lexical-to-value map of the datatype.  If two different datatypes in D map lexical strings to a common value, then a triple containing a literal typed with one datatype may D-entail another triple containing a literal typed with a different datatype. For example, <code>&quot;25&quot;^^xsd:integer</code> and <code>&quot;25.0&quot;^^xsd:decimal</code> have the same value, so the above also D-entails  </p>

<p><code>ex:a ex:p &quot;25&quot;^^xsd:integer .</code></p>

<p>when D also contains <code>xsd:integer</code>.

</p><p>(There is a <abbr title="World Wide Web Consortium">W3C</abbr> Note [<cite><a class="bibref" href="#bib-SWBP-XSCH-DATATYPES">SWBP-XSCH-DATATYPES</a></cite>] containing a long <a href="http://www.w3.org/TR/swbp-xsch-datatypes/#sec-values">discussion</a> of literal values.)</p>

<p><a href="#dfn-ill-typed" class="internalDFN">Ill-typed</a> literals are the only way in which a graph can be simply <a href="#dfn-d-unsatisfiable" class="internalDFN">D-unsatisfiable</a>, but datatypes can give rise to a variety of other unsatisfiable graphs when combined with the RDFS vocabulary, defined later.</p>
</section>

</section>
</section>
<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdf-interpretations">
<!--OddPage-->
<h2 id="rdf_d_interpretations" aria-level="1" role="heading"><span class="secno">8. </span>RDF Interpretations</h2>
    <p>RDF interpretations impose extra semantic conditions on <code>xsd:string</code> and part of the infinite
  set of IRIs with the namespace prefix <code>rdf:</code> .

</p><div>
      <table>
        <tbody>
          <tr>
            <td><dfn id="dfn-rdf-vocabulary">RDF vocabulary</dfn></td>
          </tr>

          <tr>
            <td><code>rdf:type rdf:subject rdf:predicate rdf:object
            rdf:first rdf:rest rdf:value rdf:nil
            rdf:List rdf:langString rdf:Property rdf:_1 rdf:_2
             ...
</code></td>
          </tr>
        </tbody>
      </table>
    </div>


<p>An <dfn id="dfn-rdf-interpretation">RDF interpretation</dfn> <strong>recognizing D</strong> is a <a href="#dfn-d-interpretation" class="internalDFN">D-interpretation</a> I where D includes <code>rdf:langString</code> and <code>xsd:string</code>, and which satisfies:</p>

<table>
<caption>RDF semantic conditions.</caption>
  <tbody>
    <tr>
      <td id="rdfsemcond1" class="semantictable">x is
        in IP if and only if &lt;x, I(<code>rdf:Property</code>)&gt; is in IEXT(I(<code>rdf:type</code>))</td>
    </tr>
<tr><td id="rdfsemcond3" class="semantictable">For every IRI aaa in D, &lt; x, I(aaa) &gt; is in IEXT(I(<code>rdf:type</code>)) if and only if x is in the value space of I(aaa)</td></tr>
  </tbody>
</table>
    <p>and satisfies every triple in the following infinite set:</p>

<table>
 <caption>RDF axioms.</caption>
    <tbody><tr>
      <td id="RDF_axiomatic_triples" class="ruletable"><code>rdf:type rdf:type rdf:Property .<br />
        rdf:subject rdf:type rdf:Property .<br />
        rdf:predicate rdf:type rdf:Property .<br />
        rdf:object rdf:type rdf:Property .<br />
        rdf:first rdf:type rdf:Property .<br />
        rdf:rest rdf:type rdf:Property .<br />
        rdf:value rdf:type rdf:Property .<br />
        rdf:nil rdf:type rdf:List .<br />
        rdf:_1 rdf:type rdf:Property .<br />
        rdf:_2 rdf:type rdf:Property .<br />
        ... <br />
</code>

        </td>
    </tr>
  </tbody></table>

<p>RDF imposes no particular normative meanings on the rest of the RDF vocabulary.  <a href="#whatnot">Appendix D</a> describes the intended uses of some of this vocabulary.</p>


<p>The datatype IRIs <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string"><code>rdf:langString</code></a> and <a href="http://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a> <em class="rfc2119" title="MUST">MUST</em> be <a href="#dfn-recognize" class="internalDFN">recognize</a>d by all RDF interpretations. </p>

<p>Two other datatypes <a href="http://www.w3.org/TR/rdf11-concepts/#section-XMLLiteral"><code>rdf:XMLLiteral</code></a> and <a href="http://www.w3.org/TR/rdf11-concepts/#section-html"><code>rdf:HTML</code></a> are defined in [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>]. RDF-D interpretations <em class="rfc2119" title="MAY">MAY</em> fail to <a href="#dfn-recognize" class="internalDFN">recognize</a> these datatypes. </p>


<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdf-entailment">

<h3 id="rdf_entail" aria-level="2" role="heading"><span class="secno">8.1 </span>RDF entailment</h3>

<p>S <dfn id="dfn-rdf-entail">RDF entail</dfn><strong>s</strong> E <strong>recognizing D</strong> when every <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a> recognizing D which satisfies  S also satisfies E. When D is {<code>rdf:langString</code>, <code>xsd:string</code>} then we simply say S <strong>RDF entails</strong> E. E is <dfn id="dfn-rdf-unsatisfiable">RDF unsatisfiable</dfn><strong> (recognizing D)</strong> when it has no satisfying <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a> (recognizing D).</p>

<p>The properties of simple entailment described earlier do not all apply to <a href="#dfn-rdf-entail" class="internalDFN">RDF entail</a>ment. For example, all the RDF axioms are true in every <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a>, and so are <a href="#dfn-rdf-entail" class="internalDFN">RDF entail</a>ed by the empty graph, contradicting <a href="#dfn-interpolation" class="internalDFN">interpolation</a> for RDF entailment. </p>


<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="patterns-of-rdf-entailment-informative"><h4 id="rdf_entailment_patterns" aria-level="3" role="heading"><span class="secno">8.1.1 </span>Patterns of RDF entailment (Informative)</h4><p><em>This section is non-normative.</em></p>
<p> The last semantic condition in the above table gives the following entailment pattern for <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatype IRIs: </p>

<table>
<caption>RDF entailment pattern.</caption>
  <tbody>
    <tr>
      <th> </th>
      <th><strong>if S contains</strong></th>
      <th><strong>then S RDF entails, recognizing D</strong></th>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfd1">rdfD1</dfn></td>
      <td class="othertable">   xxx aaa <code>&quot;</code>sss<code>&quot;^^</code>ddd <code>.</code> <br />
          for ddd in D</td>
      <td class="othertable">xxx aaa _:nnn <code>.</code><br />
_:nnn <code>rdf:type</code> ddd <code>.</code></td>
   </tr>

  </tbody>
</table>
<p>Note, this is valid even when the literal is <a href="#dfn-ill-typed" class="internalDFN">ill-typed</a>, since an unsatisfiable graph entails any triple.</p>

<p>For example,</p>
<p> <code>ex:a ex:p &quot;123&quot;^^xsd:integer .</code></p>

<p>RDF entails recognizing {<code>xsd:integer</code>}</p>

<p><code>ex:a ex:p _:x . <br />
 _:x rdf:type xsd:integer . </code></p>

<p>In addition, the first RDF semantic condition justifies the following entailment pattern:</p>

<table>
  <tbody>
    <tr>
      <th> </th>
      <th><strong>if S contains</strong></th>
      <th><strong>then S RDF entails, recognizing D</strong></th>
    </tr>

    <tr>
       <td class="othertable"><dfn id="dfn-rdfd2">rdfD2</dfn></td>
       <td class="othertable">xxx aaa yyy <code>.</code></td>
       <td class="othertable">aaa <code>rdf:type rdf:Property .</code> </td>
    </tr>


  </tbody>
</table>


<p>So that the above example also RDF entails</p><p><code>ex:p rdf:type rdf:Property .</code></p><p> recognizing {<code>xsd:integer</code>}.</p>


<p>Some datatypes support idiosyncratic entailment patterns which do not hold for other datatypes. For example, </p>

<p><code> ex:a ex:p &quot;true&quot;^^xsd:boolean . <br />
ex:a ex:p &quot;false&quot;^^xsd:boolean .<br />
ex:v rdf:type xsd:boolean .</code></p>

<p>together RDF entail</p>

<p><code>ex:a ex:p ex:v .</code></p>

<p> recognizing {<code>xsd:boolean</code>}.</p>

<p>In addition, the semantic conditions on value spaces may produce other unsatisfiable graphs. For example, when D contains <code>xsd:integer</code> and <code>xsd:boolean</code>, then the following is <a href="#dfn-rdf-unsatisfiable" class="internalDFN">RDF unsatisfiable</a> recognizing D:</p>

<p><code>_:x rdf:type xsd:boolean .<br />
_:x rdf:type xsd:integer . </code></p>

</section>
</section>
</section>
<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdfs-interpretations">
<!--OddPage-->
<h2 id="rdfs_interpretations" aria-level="1" role="heading"><span class="secno">9. </span>RDFS Interpretations</h2>
<p>RDF Schema [<cite><a class="bibref" href="#bib-RDF11-SCHEMA">RDF11-SCHEMA</a></cite>]
  extends RDF to a larger vocabulary
  with more complex semantic constraints:</p>

    <div>
      <table>
        <tbody>
          <tr>
            <td><dfn id="dfn-rdfs-vocabulary">RDFS vocabulary</dfn></td>
          </tr>

          <tr>
            <td><code>rdfs:domain rdfs:range rdfs:Resource rdfs:Literal
            rdfs:Datatype rdfs:Class rdfs:subClassOf rdfs:subPropertyOf
            rdfs:member rdfs:Container rdfs:ContainerMembershipProperty
            rdfs:comment rdfs:seeAlso rdfs:isDefinedBy
            rdfs:label</code></td>
          </tr>
        </tbody>
      </table>
    </div>
<p>(<code>rdfs:comment</code>,<code> rdfs:seeAlso</code>, <code>rdfs:isDefinedBy</code>
  and <code>rdfs:label</code> are included here because some constraints which
  apply to their use can be stated using <code>rdfs:domain</code>,<code> rdfs:range</code>
  and <code>rdfs:subPropertyOf</code>. Other than this, the formal semantics does
  not constrain their meanings.)</p>
<p>It is convenient to state the RDFS semantics
  in terms of a new semantic construct, a <dfn id="dfn-class">class</dfn>, i.e. a resource which represents
  a set of things in the universe which all have that class as a value of their
  <code>rdf:type</code> property. <a href="#dfn-class" class="internalDFN">Class</a>es are defined to be things of type <code>rdfs:Class</code>,
  and the set of all classes in an interpretation will be called IC.
  The semantic conditions are stated in terms of a mapping ICEXT (for the <em>C</em>lass
  <em>Ext</em>ension in I) from IC to the set of subsets of IR.</p><p> A class may have an
  empty class extension. Two different classes can have the same class extension.
  The class extension of <code>rdfs:Class</code> contains the class <code>rdfs:Class</code>.
</p>


<p> An <dfn id="dfn-rdfs-interpretation">RDFS interpretation</dfn> (<strong>recognizing D</strong>) is an <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a> (recognizing D) I
   which satisfies the semantic conditions in the following table, and all the triples in the subsequent table of RDFS axiomatic triples. </p>

  <table>
  <caption>RDFS semantic conditions.</caption>
    <tbody><tr>

    <td id="rdfssemcond1" class="semantictable"> <p>ICEXT(y) is defined to be { x : &lt; x,y &gt; is in IEXT(I(<code>rdf:type</code>)) }</p>
        <p>IC is defined to be ICEXT(I(<code>rdfs:Class</code>))</p>
        <p>LV is defined to be ICEXT(I(<code>rdfs:Literal</code>))</p>
        <p>ICEXT(I(<code>rdfs:Resource</code>)) = IR</p>
<p>ICEXT(I(<code>rdf:langString</code>)) is the set {I(E) : E a language-tagged string }</p>
<p>for every other IRI aaa in D, ICEXT(I(aaa)) is the value space of I(aaa)</p>
<p>for every IRI aaa in D, I(aaa) is in ICEXT(I(<code>rdfs:Datatype</code>)) </p>
</td>
    </tr>
    <tr>

    <td id="rdfssemcond2" class="semantictable"> <p>If
        &lt; x,y &gt; is in IEXT(I(<code>rdfs:domain</code>)) and &lt; u,v &gt; is
        in IEXT(x) then u is in ICEXT(y)</p></td>
    </tr>
    <tr>

    <td id="rdfssemcond3" class="semantictable"> <p>If
        &lt; x,y &gt; is in IEXT(I(<code>rdfs:range</code>)) and &lt; u,v &gt; is
        in IEXT(x) then v is in ICEXT(y)</p></td>
    </tr>
    <tr>

    <td id="rdfssemcond4" class="semantictable"><p>IEXT(I(<code>rdfs:subPropertyOf</code>))
      is transitive and reflexive on IP</p></td>
    </tr>
    <tr>

    <td id="rdfssemcond5" class="semantictable"> <p>If
        &lt;x,y&gt; is in IEXT(I(<code>rdfs:subPropertyOf</code>)) then x and
        y are in IP and IEXT(x) is a subset of IEXT(y)</p></td>
    </tr>
    <tr>

    <td id="rdfssemcond6" class="semantictable"><p>If
        x is in IC then &lt; x, I(<code>rdfs:Resource</code>) &gt; is in IEXT(I(<code>rdfs:subClassOf</code>))</p></td>
    </tr>
    <tr>

       <td id="rdfssemcond8" class="semantictable"><p>IEXT(I(<code>rdfs:subClassOf</code>))
      is transitive and reflexive on IC</p></td>
    </tr>

     <tr>
       <td id="rdfssemcond7" class="semantictable"> <p>If
        &lt; x,y &gt; is in IEXT(I(<code>rdfs:subClassOf</code>)) then x and y are
        in IC and ICEXT(x) is a subset of ICEXT(y)</p></td>
    </tr>

    <tr>
      <td id="rdfssemcond9" class="semantictable"><p>If
        x is in ICEXT(I(<code>rdfs:ContainerMembershipProperty</code>)) then:<br />
        &lt; x, I(<code>rdfs:member</code>) &gt; is in IEXT(I(<code>rdfs:subPropertyOf</code>))<br />
      </p></td>
    </tr>
    <tr>

    <td id="rdfssemcond10" class="semantictable"><p>If
        x is in ICEXT(I(<code>rdfs:Datatype</code>)) then <span>&lt; x,
        I(<code>rdfs:Literal</code>) &gt; is in IEXT(I(<code>rdfs:subClassOf</code>))</span></p></td>
    </tr>
  </tbody></table>
<p></p>




    <p>
	</p>
  <table id="RDFS_axiomatic_triples">
     <caption>RDFS axiomatic triples.</caption>

          <tbody><tr>


    <td class="ruletable"> <code>rdf:type rdfs:domain rdfs:Resource .<br />
      rdfs:domain rdfs:domain rdf:Property .<br />
      rdfs:range rdfs:domain rdf:Property .<br />
      rdfs:subPropertyOf rdfs:domain rdf:Property .<br />
      rdfs:subClassOf rdfs:domain rdfs:Class .<br />
      rdf:subject rdfs:domain rdf:Statement .<br />
      rdf:predicate rdfs:domain rdf:Statement .<br />
      rdf:object rdfs:domain rdf:Statement .<br />
      rdfs:member rdfs:domain rdfs:Resource . <br />
      rdf:first rdfs:domain rdf:List .<br />
      rdf:rest rdfs:domain rdf:List .<br />
      rdfs:seeAlso rdfs:domain rdfs:Resource .<br />
      rdfs:isDefinedBy rdfs:domain rdfs:Resource .<br />
      rdfs:comment rdfs:domain rdfs:Resource .<br />
      rdfs:label rdfs:domain rdfs:Resource .<br />
      rdf:value rdfs:domain rdfs:Resource .<br />
      <br />
      rdf:type rdfs:range rdfs:Class .<br />
      rdfs:domain rdfs:range rdfs:Class .<br />
      rdfs:range rdfs:range rdfs:Class .<br />
      rdfs:subPropertyOf rdfs:range rdf:Property .<br />
      rdfs:subClassOf rdfs:range rdfs:Class .<br />
      rdf:subject rdfs:range rdfs:Resource .<br />
      rdf:predicate rdfs:range rdfs:Resource .<br />
      rdf:object rdfs:range rdfs:Resource .<br />
      rdfs:member rdfs:range rdfs:Resource .<br />
      rdf:first rdfs:range rdfs:Resource .<br />
      rdf:rest rdfs:range rdf:List .<br />
      rdfs:seeAlso rdfs:range rdfs:Resource .<br />
      rdfs:isDefinedBy rdfs:range rdfs:Resource .<br />
      rdfs:comment rdfs:range rdfs:Literal .<br />
      rdfs:label rdfs:range rdfs:Literal .<br />
      rdf:value rdfs:range rdfs:Resource .<br />
      <br />
      rdf:Alt rdfs:subClassOf rdfs:Container .<br />
      rdf:Bag rdfs:subClassOf rdfs:Container .<br />
      rdf:Seq rdfs:subClassOf rdfs:Container .<br />
      rdfs:ContainerMembershipProperty rdfs:subClassOf rdf:Property .<br />
      <br />
      rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .<br />
      <br />

      rdfs:Datatype rdfs:subClassOf rdfs:Class .<br />
      <br />
      rdf:_1 rdf:type rdfs:ContainerMembershipProperty .<br />
      <span>rdf:_1 rdfs:domain rdfs:Resource .<br />
      rdf:_1 rdfs:range rdfs:Resource .</span> <br />
      rdf:_2 rdf:type rdfs:ContainerMembershipProperty .<br />
      rdf:_2 rdfs:domain rdfs:Resource .<br />
      rdf:_2 rdfs:range rdfs:Resource . <br />
      </code>... <br /> </td>
          </tr>

  </tbody></table>

<p class="changenote">In the 2004 RDF 1.0 semantics, LV was defined as part of a simple interpretation structure, and the definition given here was a constraint. </p>


<p>Since I is an <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a>, the first condition implies that IP
  = ICEXT(I(<code>rdf:Property</code>)).</p>
 <p>The semantic conditions on <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a>s, together with the RDFS conditions on ICEXT, mean that every <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatype can be treated as a class whose extension is the value space of the datatype, and every literal with that datatype either fails to refer, or refers to a value in that class.</p>
<p>When using RDFS semantics, the referents of all <a href="#dfn-recognize" class="internalDFN">recognize</a>d datatype IRIs can be considered to be in the <a href="#dfn-class" class="internalDFN">class</a> <code>rdfs:Datatype</code>. </p>
<p>The axioms and conditions listed above have some redundancy. For example, all but one
  of the RDF axiomatic triples can be derived from the RDFS axiomatic triples
  and the semantic conditions on ICEXT,<code> rdfs:domain</code> and <code>rdfs:range</code>. </p>

<p>  Other triples which must be true in all RDFS interpretations
  include the following. This is not a complete set.</p>

<table>
  <caption>Some rdfs-valid triples.</caption>
  <tbody><tr>
    <td class="ruletable"><code>rdfs:Resource rdf:type rdfs:Class .<br />
      rdfs:Class rdf:type rdfs:Class .<br />
      rdfs:Literal rdf:type rdfs:Class .<br />
      rdf:XMLLiteral rdf:type rdfs:Class .<br />
rdf:HTML rdf:type rdfs:Class .<br />
      rdfs:Datatype rdf:type rdfs:Class .<br />
      rdf:Seq rdf:type rdfs:Class .<br />
      rdf:Bag rdf:type rdfs:Class .<br />
      rdf:Alt rdf:type rdfs:Class .<br />
      rdfs:Container rdf:type rdfs:Class .<br />
      rdf:List rdf:type rdfs:Class .<br />
      rdfs:ContainerMembershipProperty rdf:type rdfs:Class .<br />
      rdf:Property rdf:type rdfs:Class .<br />
      rdf:Statement rdf:type rdfs:Class .<br />
      <br />
      rdfs:domain rdf:type rdf:Property .<br />
      rdfs:range rdf:type rdf:Property .<br />
      rdfs:subPropertyOf rdf:type rdf:Property .<br />
      rdfs:subClassOf rdf:type rdf:Property .<br />
      rdfs:member rdf:type rdf:Property .<br />
      rdfs:seeAlso rdf:type rdf:Property .<br />
      rdfs:isDefinedBy rdf:type rdf:Property .<br />
      rdfs:comment rdf:type rdf:Property .<br />
      rdfs:label rdf:type rdf:Property .<br />
      </code><code></code></td>
  </tr>
</tbody></table>

<p>RDFS does not partition the universe into disjoint categories of classes, properties and individuals. Anything in the universe can be used as a class or as a property, or both, while retaining its status as an individual which may be in classes and have properties. Thus, RDFS permits classes which contain other classes, classes of properties, properties of classes, etc. As the axiomatic triples above illustrate, it also permits classes which contain themselves and properties which apply to themselves. A property of a class is not necessarily a property of its members, nor vice versa. </p>
<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="a-note-on-rdfs-literal-informative">
<h3 id="rdfs_literal_note" aria-level="2" role="heading"><span class="secno">9.1 </span>A note on rdfs:Literal (Informative)</h3><p><em>This section is non-normative.</em></p>
<p>The class <code>rdfs:Literal</code> is not the class of literals, but rather that of literal values, which may also be referred to by IRIs. For example, LV does not contain the literal <code>&quot;foodle&quot;^^xsd:string</code> but it does contain the string &quot;foodle&quot;.</p>

  <p>A triple of the form</p>

    <p><code>ex:a rdf:type rdfs:Literal .</code></p>

    <p>is consistent even though its subject is an IRI rather
    than a literal. It says that the IRI '<code>ex:a</code>'
    refers to a literal value, which is quite possible since literal values are things in the universe. Blank nodes may range over literal values, for the same reason. </p>
</section>
<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdfs-entailment">

<h3 id="rdfs_entailment" aria-level="2" role="heading"><span class="secno">9.2 </span>RDFS entailment</h3>
<p>S <dfn id="dfn-rdfs-entails">RDFS entails</dfn> E <strong>recognizing D</strong> when every <a href="#dfn-rdfs-interpretation" class="internalDFN">RDFS interpretation</a> recognizing D
  which satisfies S also satisfies E.</p>
<p> Since every <a href="#dfn-rdfs-interpretation" class="internalDFN">RDFS interpretation</a> is an <a href="#dfn-rdf-interpretation" class="internalDFN">RDF interpretation</a>, if S <a href="#dfn-rdfs-entails" class="internalDFN">RDFS entails</a>
  E then S also <a href="#dfn-rdf-entail" class="internalDFN">RDF entail</a>s E; but RDFS entailment is stronger than RDF entailment.
  Even the empty graph has a large number of RDFS entailments which are not RDF entailments,
  for example all triples of the form </p>
<p> aaa <code>rdf:type rdfs:Resource .</code></p>
<p>where aaa is an IRI, are true in all RDFS interpretations.</p>

<section class="informative" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="patterns-of-rdfs-entailment-informative"> <h4 id="rdfs_patterns" aria-level="3" role="heading"><span class="secno">9.2.1 </span>Patterns of RDFS entailment (Informative)</h4><p><em>This section is non-normative.</em></p>

<p>RDFS entailment holds for all the following patterns, which correspond closely to the RDFS semantic conditions:</p>

<table>
<caption>RDFS entailment patterns.</caption>
  <tbody>
    <tr>
      <th></th>
      <th>If S contains:</th>
      <th>then S RDFS entails recognizing D:</th>
    </tr>
    <tr>
     <td class="othertable"><dfn id="dfn-rdfs1">rdfs1</dfn></td>
     <td class="othertable">any IRI aaa in D</td>
     <td class="othertable">aaa <code>rdf:type rdfs:Datatype . </code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs2">rdfs2</dfn></td>
      <td class="othertable"> aaa <code>rdfs:domain</code> xxx <code>.</code><br />
          yyy aaa zzz <code>.</code></td>
      <td class="othertable">yyy <code>rdf:type</code> xxx <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs3">rdfs3</dfn></td>
      <td class="othertable">aaa <code>rdfs:range</code> xxx <code>.</code><br />
          yyy aaa zzz <code>.</code></td>
      <td class="othertable">zzz <code>rdf:type</code> xxx <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs4a">rdfs4a</dfn></td>
      <td class="othertable">xxx aaa yyy <code>.</code></td>
      <td class="othertable">xxx <code>rdf:type rdfs:Resource .</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs4b">rdfs4b</dfn></td>
      <td class="othertable">xxx aaa yyy<code>.</code></td>
      <td class="othertable">yyy <code>rdf:type rdfs:Resource .</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs5">rdfs5</dfn></td>
      <td class="othertable"> xxx <code>rdfs:subPropertyOf</code> yyy <code>.</code><br />
          yyy <code>rdfs:subPropertyOf</code> zzz <code>.</code></td>
      <td class="othertable">xxx <code>rdfs:subPropertyOf</code> zzz <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs6">rdfs6</dfn></td>
      <td class="othertable">xxx <code>rdf:type rdf:Property .</code></td>
      <td class="othertable">xxx <code>rdfs:subPropertyOf</code> xxx <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs7">rdfs7</dfn></td>
      <td class="othertable"> aaa <code>rdfs:subPropertyOf</code> bbb <code>.</code><br />
          xxx aaa yyy <code>.</code></td>
      <td class="othertable">xxx bbb yyy <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs8">rdfs8</dfn></td>
      <td class="othertable">xxx <code>rdf:type rdfs:Class .</code></td>
      <td class="othertable">xxx <code>rdfs:subClassOf rdfs:Resource .</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs9">rdfs9</dfn></td>
      <td class="othertable">xxx <code>rdfs:subClassOf</code> yyy <code>.</code><br />
          zzz <code>rdf:type</code> xxx <code>.</code></td>
      <td class="othertable">zzz <code>rdf:type</code> yyy <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs10">rdfs10</dfn></td>
      <td class="othertable">xxx <code>rdf:type rdfs:Class .</code></td>
      <td class="othertable">xxx <code>rdfs:subClassOf</code> xxx <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs11">rdfs11</dfn></td>
      <td class="othertable"> xxx <code>rdfs:subClassOf</code> yyy <code>.</code><br />
          yyy <code>rdfs:subClassOf</code> zzz <code>.</code></td>
      <td class="othertable">xxx <code>rdfs:subClassOf</code> zzz <code>.</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs12">rdfs12</dfn></td>
      <td class="othertable">xxx <code>rdf:type rdfs:ContainerMembershipProperty .</code></td>
      <td class="othertable">xxx <code>rdfs:subPropertyOf rdfs:member .</code></td>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-rdfs13">rdfs13</dfn></td>
      <td class="othertable">xxx <code>rdf:type rdfs:Datatype .</code></td>
      <td class="othertable">xxx <code>rdfs:subClassOf rdfs:Literal .</code></td>
    </tr>
  </tbody>
</table>


<p>RDFS provides for several new ways to be unsatisfiable recognizing D. For example, the following graph is RDFS unsatisfiable recognizing {<code>xsd:integer</code>, <code>xsd:boolean</code>}:</p>

<p><code>ex:p rdfs:domain xsd:boolean .<br />
ex:a rdf:type xsd:integer .<br />
ex:a ex:p ex:c .</code></p>

</section>
</section>
</section>
<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdf-datasets">
<!--OddPage-->
<h2 id="rdf_datasets" aria-level="1" role="heading"><span class="secno">10. </span>RDF Datasets</h2>


<!--
<p>An RDF <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset" class="externalDFN">dataset</a> (see [[!RDF11-CONCEPTS]]) is a finite set of RDF graphs each paired with an IRI or blank node called the <strong>graph name</strong>, plus a <strong>default graph</strong>, without a name. Graphs in a single dataset may share blank nodes. The association of graph name IRIs with graphs is used by SPARQL [[RDF-SPARQL-QUERY]] to allow queries to be directed against particular graphs.</p>
-->


<p><a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset" class="externalDFN">RDF datasets</a>, defined in RDF Concepts [<cite><a class="bibref" href="#bib-RDF11-CONCEPTS">RDF11-CONCEPTS</a></cite>], package up zero or more named RDF graphs along with a single unnamed, default RDF graph.  The graphs in a single dataset may share blank nodes. The association of graph name IRIs with graphs is used by SPARQL [<cite><a class="bibref" href="#bib-SPARQL11-QUERY">SPARQL11-QUERY</a></cite>] to allow queries to be directed against particular graphs.</p>

<p>Graph names in a dataset may refer to something other than the graph they are paired with. This allows IRI referring to other kinds of entities, such as persons, to be used in a dataset to <a href="#dfn-identify" class="internalDFN">identify</a> graphs of information relevant to the entity <a href="#dfn-denote" class="internalDFN">denote</a>d by the graph name IRI.</p>

<p>When a graph name is used inside RDF triples in a dataset it may or may not refer to the graph it names. The semantics does not require, nor should RDF engines presume, without some external reason to do so, that graph names used in RDF triples refer to the graph they name.</p>

<p>RDF datasets <em class="rfc2119" title="MAY">MAY</em> be used to express RDF content. When used in this way, a dataset <em class="rfc2119" title="SHOULD">SHOULD</em> be understood to have at least the same content as its default graph. Note however that replacing the default graph of a dataset by a logically equivalent graph will not in general produce a structurally similar dataset, since it may for example disrupt co-occurrences of blank nodes between the default graph and other graphs in the dataset, which may be important for reasons other than the semantics of the graphs in the dataset.</p>

<p>Other <a href="#dfn-semantic-extension" class="internalDFN">semantic extension</a>s and <a href="#dfn-entailment-regime" class="internalDFN">entailment regime</a>s <em class="rfc2119" title="MAY">MAY</em> place further semantic conditions and restrictions on RDF datasets, just as with RDF graphs.  One such extension, for example, could set up a modal-like interpretation structure so that entailment between datasets would require RDF graph entailments between the graphs with the same name (adding in empty graphs as required).</p>


</section>

<h2 id="appendices">Appendices</h2>

<section class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="entailment-rules-informative">
<!--OddPage-->
<h2 id="entailment_rules" aria-level="1" role="heading"><span class="secno">A. </span>Entailment rules (Informative)</h2><p><em>This section is non-normative.</em></p>

<p>(<em>This section is based on work described more fully in </em>[<cite><a class="bibref" href="#bib-HORST04">HORST04</a></cite>]<em>, </em>[<cite><a class="bibref" href="#bib-HORST05">HORST05</a></cite>]<em>, which should be consulted for technical details and proofs.</em>) </p>
<p> The RDF and RDFS entailment patterns listed in the above tables can be viewed as left-to-right rules which add the entailed conclusion to a graph. These rule sets can be used to check RDF (or RDFS) entailment between graphs S and E, by the following sequence of operations:</p>
<p>1. Add to S all the RDF (or RDF and RDFS) axiomatic triples except those containing the container membership property IRIs <code>rdf:_1, rdf:_2, ...</code>.<br />
2. For every container membership property IRI which occurs in E, add the RDF (or RDF and RDFS) axiomatic triples which contain that IRI.<br />
3. Apply the RDF (or RDF and RDFS) inference patterns as rules, adding each conclusion to the graph, to exhaustion; that is, until they generate no new triples. <br />
4. Determine if E has an instance which is a subset of the set, i.e. whether the enlarged set simply entails E.</p>

<p>This process is clearly correct, in that if it gives a positive result then indeed S does RDF (RDFS) entail E. It is not, however, complete: there are cases of S entailing E which are not detectable by this process. Examples include:</p>

<table>
  <tbody>
    <tr>

      <th> </th>
      <th>RDF entails</th>
    </tr>

    <tr>

       <td class="othertable"><code>ex:a ex:p &quot;string&quot;^^xsd:string .<br />
ex:b ex:q &quot;string&quot;^^xsd:string .</code></td>
       <td class="othertable"><code>ex:a ex:p _:b .<br />
ex:b ex:q _:b .<br />
_:b rdf:type xsd:string .</code> </td>
    </tr>

 <tr>

      <th> </th>
      <th>RDFS entails</th>
    </tr>
<tr>

       <td class="othertable"><code>ex:a rdfs:subPropertyOf _:b .<br />
_:b rdfs:domain ex:c .<br />
ex:d ex:a ex:e .</code></td>
       <td class="othertable"><code>ex:d rdf:type ex:c .</code> </td>
    </tr>

  </tbody>
</table>
<p> Both of these can be handled by allowing the rules to apply to a generalization of the RDF syntax in which literals may occur in subject position and blank nodes may occur in predicate position. </p>


<!--<p>Define a <dfn>generalized RDF triple</dfn> to be a triple &lt;x, y, z&gt; where x and z can be an IRI, a blank node or a literal, and y can be an IRI or a blank node; and extend this to the rest of RDF, so that a generalized RDF graph is a set of generalized RDF triples. -->

<p>Consider <a href="http://www.w3.org/TR/rdf11-concepts/#section-generalized-rdf" class="externalDFN">generalized RDF triples, graphs, and datasets</a> instead of RDF triples, graphs and datasets (extending the generalization used in [<cite><a class="bibref" href="#bib-HORST04">HORST04</a></cite>] and following exactly the terms used in [<cite><a class="bibref" href="#bib-OWL2-PROFILES">OWL2-PROFILES</a></cite>]).  The semantics described in this document applies to the generalization without change, so that the notions of interpretation, satisfiability and entailment can be used freely. Then we can replace the first RDF entailment pattern with the simpler and more direct</p>

<table>
<caption>G-RDF-D entailment pattern.</caption>
  <tbody>
    <tr>
      <th> </th>
      <th><strong>if S contains</strong></th>
      <th><strong>then S RDF entails, recognizing D</strong></th>
    </tr>
    <tr>
      <td class="othertable"><dfn id="dfn-grdfd1">GrdfD1</dfn></td>
      <td class="othertable">   xxx aaa <code>&quot;</code>sss<code>&quot;^^</code>ddd <code>.</code> <br />
          for ddd in D</td>
      <td class="othertable"><code>&quot;</code>sss<code>&quot;^^</code>ddd <code>rdf:type</code> ddd <code>.</code></td>
   </tr>

  </tbody>
</table>

<p> which gives the entailments;</p>
<p><code>ex:a ex:p &quot;string&quot;^^xsd:string .<br />
ex:b ex:q &quot;string&quot;^^xsd:string .<br />
&quot;string&quot;^^xsd:string rdf:type xsd:string .</code>  by <a href="#dfn-grdfd1" class="internalDFN">GrdfD1</a></p>

<p>which is an instance (in generalized RDF) of the desired conclusion, above.</p>
<p> The second example can be derived using the RDFS rules:</p>
<p><code>ex:a rdfs:subPropertyOf _:b .<br />
_:b rdfs:domain ex:c .<br />
ex:d ex:a ex:e .<br />
ex:d _:b ex:c .</code>  by <a href="#dfn-rdfs7" class="internalDFN">rdfs7</a><br />
<code>ex:d rdf:type ex:c .</code> by <a href="#dfn-rdfs2" class="internalDFN">rdfs2</a></p>

<p>Where the entailment patterns have been applied to generalized RDF syntax but yield a final conclusion which is legal RDF. </p>

<p>With the generalized syntax, these rules are complete for both RDF and RDFS entailment. Stated exactly:</p>
<p>Let S and E be RDF graphs. Define the <dfn id="dfn-generalized-rdf-rdfs-closure">generalized RDF (RDFS) closure</dfn> <strong>of S towards E</strong> to be the set obtained by the following procedure.</p>
<p>1. Add to S all the RDF (and RDFS) axiomatic triples which do not contain any container membership property IRI.<br />
2. For each container membership property IRI which occurs in E, add the RDF (and RDFS) axiomatic triples which contain that IRI.<br />
3. If no triples were added in step 2., add the RDF (and RDFS) axiomatic triples which contain <code>rdf:_1</code>. <br />
4. Apply the rules <a href="#dfn-grdfd1" class="internalDFN">GrdfD1</a> and <a href="#dfn-rdfd2" class="internalDFN">rdfD2</a> (and the rules <a href="#dfn-rdfs1" class="internalDFN">rdfs1</a> through <a href="#dfn-rdfs13" class="internalDFN">rdfs13</a>), with D={<code>rdf:langString</code>, <code>xsd:string</code>), to the set in all possible ways, to exhaustion. </p>

<p>Then we have the completeness result:</p>
<p class="fact">If S is RDF (RDFS) consistent, then S RDF entails (RDFS entails) E just when the <a href="#dfn-generalized-rdf-rdfs-closure" class="internalDFN">generalized RDF (RDFS) closure</a> of S towards E simply entails E. </p>

<p>The closures are finite. The generation process is decidable and of polynomial complexity. Detecting simple entailment is NP-complete in general, but of low polynomial order when E contains no blank nodes. </p>

<p>Every RDF(S) closure, even starting with the empty graph, will contain all RDF(S) tautologies which can be expressed using the vocabulary of the original graph plus the RDF and RDFS vocabularies. In practice there is little utility in re-deriving these, and a subset of the rules can be used to establish most entailments of practical interest. </p>

<p>If it is important to stay within legal RDF syntax, rule <a href="#dfn-rdfd1" class="internalDFN">rdfD1</a> may be used instead of <a href="#dfn-grdfd1" class="internalDFN">GrdfD1</a>, and the introduced blank node can be used as a substitute for the literal in subsequent derivations. The resulting set of rules will not however be complete.</p>

<p>As noted earlier, detecting datatype entailment for larger sets of datatype IRIs requires attention to idiosyncratic properties of the particular datatypes.</p>

</section>

<section class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="finite-interpretations-informative">
<!--OddPage-->
<h2 id="finite_interpretations" aria-level="1" role="heading"><span class="secno">B. </span>Finite interpretations (Informative)</h2><p><em>This section is non-normative.</em></p>
<p>To keep the exposition simple, the RDF semantics has been phrased in a way which requires interpretations to be larger than absolutely necessary. For example, all interpretations are required to interpret the whole IRI vocabulary, and the universes of all D-interpretations where D contains
<code>xsd:string</code> must contain all possible strings and therefore be infinite. This appendix sketches, without proof, how to re-state the semantics using smaller semantic structures, without changing any entailments. </p>

<p>Basically, it is only necessary for an interpretation structure to interpret the <a href="#dfn-name" class="internalDFN">name</a>s actually used in the graphs whose entailment is being considered, and to consider interpretations whose universes are at most as big as the number of names and blank nodes in the graphs.  More formally, we can define a <dfn id="dfn-pre-interpretation">pre-interpretation</dfn> over a <a href="#dfn-vocabulary" class="internalDFN">vocabulary</a> V to be a structure I similar to a <a href="#dfn-simple-interpretation" class="internalDFN">simple interpretation</a> but with a mapping only from V to its universe IR.  Then when determining whether G entails E, consider only pre-interpretations over the finite vocabulary of <a href="#dfn-name" class="internalDFN">name</a>s actually used in G union E. The universe of such a pre-interpretation can be restricted to the cardinality N+B+1, where N is the size of the vocabulary and B is the number of blank nodes in the graphs. Any such pre-interpretation may be extended to <a href="#dfn-simple-interpretation" class="internalDFN">simple interpretation</a>s, all of which which will give the same truth values for any triples in G or E. Satisfiability, entailment and so on can then be defined with respect to these finite pre-interpretations, and shown to be identical to the ideas defined in the body of the specification.</p>

<p>When considering D-entailment, pre-interpretations may be kept finite by weakening the semantic conditions for datatyped literals so that IR need contain literal values only for literals which actually occur in G or E, and the size of the universe restricted to (N+B)×(D+1), where D is the number of recognized datatypes. (A tighter bound is possible.) For RDF entailment, only the finite part of the RDF vocabulary which includes those container membership properties which actually occur in the graphs need to be interpreted, and the second RDF semantic condition is weakened to apply only to values which are values of literals which actually occur in the vocabulary. For RDFS interpretations, again only that finite part of the infinite container membership property vocabulary which actually occurs in the graphs under consideration needs to be interpreted. In all these cases, a pre-interpretation of the vocabulary of a graph may be extended to a full interpretation of the appropriate type without changing the truth-values of any triples in the graphs.</p>

<p>The whole semantics could be stated in terms of pre-interpretations, yielding the same entailments, and allowing finite RDF graphs to be interpreted in finite structures, if the <em>finite model property</em> is considered important.

</p></section>


<section class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="proofs-of-some-results-informative">
<!--OddPage-->
<h2 id="proofs" aria-level="1" role="heading"><span class="secno">C. </span>Proofs of some results (Informative)</h2><p><em>This section is non-normative.</em></p>

<p class="fact"> The <a href="#dfn-empty-graph" class="internalDFN">empty graph</a> is simply entailed by
  any graph, and does not simply entail any graph except itself.

<!-- <a href="#emptygraphlemmaprf" class="termref">[Proof]</a> -->

</p>

<p>The empty graph is true in all simple interpretations, so is entailed by any graph. If G contains a triple &lt;a b c&gt;, then any simple interpretation I with IEXT(I(b))={ } makes G false; so the empty graph does not entail G. QED.</p>

<p class="fact"> A graph simply entails all its subgraphs.

<!-- <a href="#subglemprf" class="termref">[Proof]</a> -->

</p>
<p>If I satisfies G then it satisfies every triple in G, hence every triple in any subset of G. QED.</p>

<p class="fact"> A graph
  is simply entailed by any of its <a href="#dfn-instance" class="internalDFN">instance</a>s.

<!-- <a href="#instlemprf" class="termref"> [Proof]</a> -->

</p>
<p>Suppose H is an instance of G with the instantiation mapping M, and that I satisfies H. For blank nodes n in G which are not in H define A(n)=I(M(n)); then I+A satisfies G, so I satisfies G. QED.</p>

<p class="fact">Every graph is simply satisfiable.</p>
<p>Consider the simple interpretation with universe {x}, IEXT(x)= &lt;x,x &gt; and I(aaa)=x for any IRI aaa. This interpretation satisfies every RDF graph. QED.</p>

<p class="fact">
  G simply entails a graph E if and only if a subgraph of G is an instance of E.
</p>

<p>If a subgraph E' of G is an instance of E then G entails E' which entails E, so G entails E. Now suppose G entails E, and consider the <a href="http://en.wikipedia.org/wiki/Herbrand_interpretation">Herbrand interpretation</a> I of G defined as follows.  IR contains the <a href="#dfn-name" class="internalDFN">name</a>s and blank nodes which occur in the graph, with I(n)=n for each <a href="#dfn-name" class="internalDFN">name</a> n; n is in IP and &lt;a, b&gt; in IEXT(n) just when the triple &lt;a n b&gt; is in the graph. (For IRIs which do not occur in the graph, assign them values in IR at random.) I satisfies every triple &lt;s p o&gt; in E; that is, for some mapping A from the blank nodes of E to the vocabulary of G, the triple &lt;[I+A](s) I(p) [I+A](o)&gt; occurs in G. But this is an instance of &lt;s p o&gt; under the instance mapping A; so an instance of E is a subgraph of G. QED.</p>

<p class="fact">if E is lean and E' is a proper instance of E, then E does not simply entail E'.</p>
<p>Suppose E entails E', then a subgraph of E is an instance of E', which is a proper instance of E; so a subgraph of E is a proper instance of E, so E is not lean. QED.</p>
<p class="fact">If E contains an IRI which does not occur in S, then S does not simply entail E.</p>
<p>IF S entails E then a subgraph of S is an instance of E, so every IRI in E must occur in that subgraph, so must occur in S. QED.</p>

<p class="fact">For any graph H, if sk(G) simply entails H there there is a graph H' such that G entails H' and H=sk(H').</p>
<p>The skolemization mapping sk substitutes a unique new IRI for each blank node, so it is 1:1, so has an inverse. Define ks to be the inverse mapping which replaces each skolem IRI by the blank node it replaced. Since sk(G) entails H, a subgraph of sk(G) is an instance of H, say A(H) for some instance mapping A on the blank nodes in H. Then ks(A(H)) is a subgraph of G; and ks(A(H))=A(ks(H)) since the domains of A and ks are disjoint. So ks(H) has an instance which is a subgraph of G, so is entailed by G; and H=sk(ks(H)). QED.</p>

<p class="fact">For any graph H which does not contain any of the &quot;new&quot; IRIs introduced into sk(G), sk(G) simply entails H if and only if G simply entails H.</p>
<p>Using the terminology in the previous proof: if H does not contain any skolem IRIs, then H=ks(H). So if sk(G) entails H then G entails ks(H)=H; and if G entails H then sk(G) entails G entails H, so sk(G) entails H. QED.</p>



</section>


<section id="whatnot" class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter">
<!--OddPage-->
<h2 id="non_semantics" aria-level="1" role="heading"><span class="secno">D. </span>RDF reification, containers and collections (Informative)</h2><p><em>This section is non-normative.</em></p>

<p>The RDF semantic conditions do not place formal constraints on the meaning
  of much of the RDF vocabulary which is intended for use in describing containers and bounded collections,
  or the reification vocabulary intended to enable an RDF graph to describe RDF triples. This appendix briefly reviews the intended meanings of this vocabulary. </p>


<p>The omission of these conditions from the formal semantics is a design decision
  to accommodate variations in existing RDF usage and to make it easier to implement
  processes to check formal RDF entailment. For example, implementations may decide
  to use special procedural techniques to implement the RDF collection vocabulary.</p>

<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="reification">

<h3 id="Reif" aria-level="2" role="heading"><span class="secno">D.1 </span>Reification</h3>

    <div class="c1">
      <table>
        <tbody>
          <tr>
            <td class="othertable"><strong>RDF reification vocabulary</strong></td>
          </tr>
          <tr>
            <td class="othertable"><code>rdf:Statement rdf:subject rdf:predicate
                rdf:object</code></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p>The intended meaning of this vocabulary is to allow an RDF graph to act as metadata describing other RDF triples. </p>


    <p>Consider an example graph containing a single triple:</p>

    <p><code>ex:a ex:b ex:c .</code></p>

    <p>and suppose that IRI <code>ex:graph1</code> is used to <a href="#dfn-identify" class="internalDFN">identify</a> this graph. Exactly how this identification is achieved is external to the RDF model, but it might be by the IRI resolving to a concrete syntax document describing the graph, or by the IRI being the associated name of a named graph in a dataset. Assuming that the IRI can be used to refer to the triple, then the reification vocabulary allows us to describe the first graph in another graph:</p>

    <p><code>ex:graph1 rdf:type rdf:Statement .<br />
     ex:graph1 rdf:subject ex:a .<br />
     ex:graph1 rdf:predicate ex:b .<br />
     ex:graph1 rdf:object ex:c .</code></p>

    <p>The second graph is called a <dfn id="dfn-reification">reification</dfn> of the triple in the first
    graph.</p>
<p>  Reification is not a form of quotation. Rather, the reification describes the
    relationship between a token of a triple and the resources that the triple refers
    to. The value of the <code>rdf:subject</code> property is not the
    subject IRI itself but the thing it denotes, and similarly for <code>rdf:predicate</code> and <code>rdf:object</code>. For example, if the referent of <code>ex:a</code> is Mount Everest, then the subject of the reified triple is also the mountain, not the IRI which refers to it.

</p>

<p><a href="#dfn-reification" class="internalDFN">Reification</a>s can be written with a blank node as subject, or with an IRI subject which does not <a href="#dfn-identify" class="internalDFN">identify</a> any concrete realization of a triple, in both of which cases they simply assert the existence of the described triple. </p>

    <p>The subject of a <a href="#dfn-reification" class="internalDFN">reification</a> is intended to refer to a concrete realization of an RDF triple, such as a document in a surface syntax, rather than a triple considered as an abstract object.  This supports use cases where properties such as dates of
    composition or provenance information are applied to the
    reified triple, which are meaningful only when thought of as
    referring to a particular instance or token of a triple. </p>

    <p>A <a href="#dfn-reification" class="internalDFN">reification</a> of a triple does not entail the triple, and is not
    entailed by it. The
    <a href="#dfn-reification" class="internalDFN">reification</a> only says that the triple token exists and what it is about,
      not that it is true, so it does not entail the triple. On the other hand, asserting a triple does not automatically imply that any
    triple tokens exist in the universe being described by the triple.
    For example, the triple might be part of an ontology describing
    animals, which could be satisfied by an interpretation in which the
    universe contained only animals, and in which a <a href="#dfn-reification" class="internalDFN">reification</a> of it was therefore
      false.</p>

    <p>Since the relation between triples and <a href="#dfn-reification" class="internalDFN">reification</a>s of triples
    in any RDF graph or graphs need not be one-to-one, asserting a
    property about some entity described by a <a href="#dfn-reification" class="internalDFN">reification</a> need not
    entail that the same property holds of another such entity, even if
    it has the same components. For example,</p>

    <p><code>_:xxx rdf:type rdf:Statement .<br />
     _:xxx rdf:subject ex:subject .<br />
     _:xxx rdf:predicate ex:predicate .<br />
     _:xxx rdf:object ex:object .<br />
     _:yyy rdf:type rdf:Statement .<br />
     _:yyy rdf:subject ex:subject .<br />
     _:yyy rdf:predicate ex:predicate .<br />
     _:yyy rdf:object ex:object .<br />
     _:xxx ex:property ex:foo .</code></p>

    <p>does not entail</p>

    <p><code>_:yyy ex:property ex:foo .</code></p>
</section>

<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdf-containers">

<h3 id="containers" aria-level="2" role="heading"><span class="secno">D.2 </span>RDF containers</h3>

    <table>
      <tbody>
        <tr>
          <td class="othertable"><strong>RDF(S) Container Vocabulary</strong></td>
        </tr>
        <tr>
          <td class="othertable"><code>rdf:Seq rdf:Bag rdf:Alt rdf:_1 rdf:_2
              ... rdfs:member rdfs:Container rdfs:ContainerMembershipProperty</code></td>
        </tr>
      </tbody>
    </table>
    <p>RDF provides vocabularies for describing three classes of
    containers. Containers have a type, and their members can
    be enumerated by using a fixed set of <em>container membership
    properties</em>. These properties are indexed by integers to
    provide a way to distinguish the members from each other, but these
    indices should not necessarily be thought of as defining an
    ordering of the container itself; some containers are considered to be unordered.</p>

    <p>The <a href="#dfn-rdfs-vocabulary" class="internalDFN">RDFS vocabulary</a> adds a generic membership
    property which holds regardless of position, and classes containing
    all the containers and all the membership properties.</p>

  <p>One should understand this vocabulary as <em>describing</em>
    containers, rather than as a tool for constructing them, as
    would typically be supplied by a programming language. The actual containers are entities in the semantic universe,
    and RDF graphs which use the vocabulary simply provide very basic
    information about these entities, enabling an RDF graph to
    characterize the container type and give partial information about
    the members of a container. Since the RDF container vocabulary is
    so limited, many natural assumptions concerning RDF containers
    cannot be formally sanctioned by the RDF formal semantics. This should not be taken as
    meaning that these assumptions are false, but only that RDF does
    not formally entail that they must be true.</p>

    <p>There are no special semantic conditions on the container
    vocabulary: the only structure which RDF presumes its containers
    to have is what can be inferred from the use of this vocabulary and
    the general RDF semantic conditions. This amounts to knowing the type of a container, and having a partial
    enumeration
    of the items in the container. The intended mode of use is that things
    of type <code>rdf:Bag</code>
    are considered to be unordered but to allow duplicates; things of
    type <code>rdf:Seq</code> are considered to be ordered, and things
    of type <code>rdf:Alt</code> are considered to represent a
    collection of alternatives, possibly with a preference ordering.
    If the container is of an ordered type, then the ordering of items in the container is intended to be
    indicated by the numerical ordering of the container membership
    properties, which are assumed to be single-valued.
    However, these informal conditions are not reflected in any formal RDF
    entailments.</p>


<p>The RDF semantics does not support any entailments which could arise from enumerating
  the elements of an unordered <code>rdf:Bag</code> in a different order. For example,</p>

    <p><code>_:xxx rdf:type rdf:Bag .<br />
     _:xxx rdf:_1 ex:a .<br />
     _:xxx rdf:_2 ex:b .</code></p>

    <p>does not entail</p>

    <p><code>_:xxx rdf:_1 ex:b .<br />
     _:xxx rdf:_2 ex:a .</code></p>

    <p>(If this conclusion were <a href="#dfn-valid" class="internalDFN">valid</a>, then the result of
    adding it to the original graph would be <a href="#dfn-entail" class="internalDFN">entail</a>ed by the graph, and this would assert that both elements were in both
    positions. This is a consequence of the fact that RDF is a purely
    assertional language.)</p>

    <p>There is no assumption that a property of a container applies to
    any of the elements of the container, or vice versa. </p>
    <p>There is no formal requirement that
      the three container classes are disjoint, so that for example
      it is consistent to assert that something is both an <code>rdf:Bag</code> and an <code>rdf:Seq</code>.
      There is no assumption that containers are gap-free, so that for example</p>
    <p><code>_:xxx rdf:type rdf:Seq.<br />
     _:xxx rdf:_1 ex:a .<br />
     _:xxx rdf:_3 ex:c .</code></p>

    <p>does not entail</p>

    <p><code>_:xxx rdf:_2 _:yyy .</code></p>

    <p>There is no way in RDF to assert
    that a container contains only a fixed number of members. This is a
    reflection of the fact that it is always consistent to add a triple
    to a graph asserting a membership property of any container. And
    finally, there is no built-in assumption that an RDF container has
    only finitely many members.</p>
</section>

<section typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="rdf-collections">

<h3 id="collections" aria-level="2" role="heading"><span class="secno">D.3 </span>RDF collections</h3>

    <table>
      <tbody>
        <tr>
          <td class="othertable"><strong>RDF Collection Vocabulary</strong></td>
        </tr>
        <tr>
          <td class="othertable"><code>rdf:List rdf:first rdf:rest rdf:nil</code></td>
        </tr>
      </tbody>
    </table>
    <p>RDF provides a vocabulary for describing collections, i.e.'list
    structures', in terms of head-tail links. Collections differ from
    containers in allowing branching structure and in having an
    explicit terminator, allowing applications to determine the exact
    set of items in the collection.</p>


<p>As with containers, no special semantic conditions are imposed on this vocabulary
  other than the type of <code>rdf:nil</code> being <code>rdf:List</code>. It
  is intended for use typically in a context where a container is described using
  blank nodes to connect a 'well-formed' sequence of items, each described by
  two triples of the form
<code><br />
  <br />
  _:c1 rdf:first aaa .<br />
  _:c1 rdf:rest _:c2 .</code></p>


<p>where the final item is indicated by the use of <code>rdf:nil</code> as the
  value of the property <code>rdf:rest</code>. In a familiar convention, <code>rdf:nil</code>
  can be thought of as the empty collection. Any such graph amounts to an assertion
  that the collection exists, and since the members of the collection can be determined
  by inspection, this is often sufficient to enable applications to determine
  what is meant. The semantics does not require any collections
  to exist other than those mentioned explicitly in a graph (and the empty collection).
  For example, the existence of a collection containing two items does not automatically
  guarantee that the similar collection with the items permuted also exists:
<code>
<br /><br />
  _:c1 rdf:first ex:aaa .<br />
  _:c1 rdf:rest _:c2 .<br />
  _:c2 rdf:first ex:bbb .<br />
  _:c2 rdf:rest rdf:nil . </code></p>
  <p>does not entail</p>

<p><code>_:c3 rdf:first ex:bbb .<br />
  _:c3 rdf:rest _:c4 .<br />
  <span>_:c4 rdf:first</span> ex:aaa .<br />
     _:c4 rdf:rest rdf:nil .
    </code></p>

    <p>Also, RDF imposes no 'well-formedness' conditions on the use of this
    vocabulary, so that it is possible to write RDF graphs which assert
    the existence of highly peculiar objects such as lists with forked
    or non-list tails, or multiple heads:</p>

<p><code>_:666 rdf:first ex:aaa .<br />
     _:666 rdf:first ex:bbb .<br />
     _:666 rdf:rest ex:ccc .<br />
  _:666 rdf:rest rdf:nil . </code></p>


<p>It is also possible to write a set of triples which under-specify a collection
  by failing to specify its <code>rdf:rest</code> property value.</p>


<p><a href="#dfn-semantic-extension" class="internalDFN">Semantic extension</a>s may
  place extra syntactic well-formedness restrictions on the use of this vocabulary
  in order to rule out such graphs. They may
  exclude interpretations of the collection vocabulary which violate the convention
  that the subject of a 'linked' collection of two-triple items of the form described
  above, ending with an item ending with <code>rdf:nil</code>, denotes a totally
  ordered sequence whose members are the denotations of the <code>rdf:first</code>
  values of the items, in the order got by tracing the <code>rdf:rest</code> properties
  from the subject to <code>rdf:nil</code>. This permits sequences which contain
  other sequences.</p>
<p> The RDFS semantic conditions require that any
  subject of the <code>rdf:first</code> property, and any subject or object of
  the <code>rdf:rest</code> property, be of <code>rdf:type rdf:List</code>. </p>
</section>

</section>


    <section class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="change-log-informative">
      
<!--OddPage-->
<h2 id="ChangeLog" aria-level="1" role="heading"><span class="secno">E. </span>Change Log (informative)</h2><p><em>This section is non-normative.</em></p>

<p>Changes since Proposed Recommendation:</p>
<ul>
<li> <a href="http://lists.w3.org/Archives/Public/public-rdf-comments/2014Feb/0012.html">Typo</a> fixed in Sec. 7.</li>
</ul>

<p>Changes since Candidate Recommendation:</p>
<ul>
<li> Minor typos corrected. Some text added to section 7 defining datatype maps.</li>
</ul>

<p>Changes since Last Call:</p>
<ul>
<li> Repaired several broken internal links and typos.</li>
<li> Added table of RDF vocabulary. </li>
<li> Added text mentioning lexical spaces in datatypes.</li>
<li> Added extended change note defining datatype map.</li>
<li> Removed informative section on intuitive summary of truth conditions 	</li>
<li> Added a general description of the notion of interpretation. </li>
<li> Adjusted several uses of &quot;interpretation&quot; and related terminology to state the particular kind of interpretation in question or use a more appropriate term. </li>
<li> Brian McBride was acknowledged as series editor of the previous
  version. </li>
<li> The wording looking like a definition of RDF Datasets was replaced by
  more informative wording. </li>
</ul>
</section>


    <section class="informative appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter" id="acknowledgements-1">
      
<!--OddPage-->
<h2 id="acknowledgements" aria-level="1" role="heading"><span class="secno">F. </span>Acknowledgements</h2><p><em>This section is non-normative.</em></p>

<p>The basic idea of using an explicit extension mapping to allow self-application without violating the axiom of foundation was
suggested by Christopher Menzel. The generalized RDF syntax used in Appendix A, and the example showing the need for it, were suggested by Herman ter Horst, who also proved completeness and complexity results for the rule sets. Jeremy Carroll first showed that simple entailment is NP-complete in general. Antoine Zimmerman suggested several simplifications and improvements to the proofs and presentation.</p>

<p>The RDF 1.1 editors acknowledge valuable contributions from Thomas Baker, Dan Brickley, Gavin Carothers, Jeremy Carroll, Pierre-Antoine Champin, Richard Cyganiak, Martin J. Dürst, Alex Hall, Steve Harris, Ivan Herman, Eric Prud'hommeaux, Andy Seaborne, David Wood and Antoine Zimmermann. </p>
<p>This specification is a product of extended deliberations by
members of the RDF Working Group. This specification draws upon the
earlier specification [<cite><a class="bibref" href="#bib-RDF-MT">RDF-MT</a></cite>], whose editor acknowledged valuable
inputs from  Jeremy Carroll, Dan Connolly, Jan Grant, R. V. Guha,
Herman ter Horst, Graham Klyne, Ora Lassilla, Brian McBride, Sergey
Melnick, Peter Patel-Schneider, Jos deRoo and Patrick Stickler. 
Brian McBride was the series editor for this earlier specification.
</p>


<p>This document was prepared using the <a href="http://dev.w3.org/2009/dap/ReSpec.js/documentation.html">ReSpec.js specification writing tool</a> developed by Robin Berjon. </p>

    </section>
  

<section class="appendix" id="references" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter">
<!--OddPage-->
<h2 aria-level="1" role="heading" id="h2_references"><span class="secno">G. </span>References</h2><section id="normative-references" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_normative-references"><span class="secno">G.1 </span>Normative references</h3><dl class="bibliography" about=""><dt id="bib-RDF-PLAIN-LITERAL">[RDF-PLAIN-LITERAL]</dt><dd rel="dcterms:requires">Jie Bao, Sandro Hawke, Boris Motik, Peter F. Patel-Schneider, Alex Polleres. <cite><a href="http://www.w3.org/TR/rdf-plain-literal/">rdf:PlainLiteral: A Datatype for RDF Plain Literals (Second Edition)</a></cite> 11 December 2012. W3C Recommendation. URL: <a href="http://www.w3.org/TR/rdf-plain-literal/">http://www.w3.org/TR/rdf-plain-literal/</a>
</dd><dt id="bib-RDF11-CONCEPTS">[RDF11-CONCEPTS]</dt><dd rel="dcterms:requires">Richard Cyganiak, David Wood, Markus Lanthaler. <cite><a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF 1.1 Concepts and Abstract Syntax.</a></cite> W3C Recommendation, 25 February 2014. URL: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/</a>. The latest edition is available at <a href="http://www.w3.org/TR/rdf11-concepts/">http://www.w3.org/TR/rdf11-concepts/</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd rel="dcterms:requires">S. Bradner. <a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>Key words for use in RFCs to Indicate Requirement Levels.</cite></a> March 1997. Internet RFC 2119.  URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a> 
</dd><dt id="bib-SPARQL11-ENTAILMENT">[SPARQL11-ENTAILMENT]</dt><dd rel="dcterms:requires">Birte Glimm; Chimezie Ogbuji. <a href="http://www.w3.org/TR/sparql11-entailment/"><cite>SPARQL 1.1 Entailment Regimes</cite></a>. 21 March 2013. W3C Recommendation. URL: <a href="http://www.w3.org/TR/sparql11-entailment/">http://www.w3.org/TR/sparql11-entailment/</a>
</dd><dt id="bib-TURTLE">[TURTLE]</dt><dd rel="dcterms:requires">Eric Prud'hommeaux, Gavin Carothers. <cite><a href="http://www.w3.org/TR/2014/REC-turtle-20140225/">RDF 1.1 Turtle: Terse RDF Triple Language.</a></cite> W3C Recommendation, 25 February 2014. URL: <a href="http://www.w3.org/TR/2014/REC-turtle-20140225/">http://www.w3.org/TR/2014/REC-turtle-20140225/</a>. The latest edition is available at <a href="http://www.w3.org/TR/turtle/">http://www.w3.org/TR/turtle/</a>
</dd></dl></section><section id="informative-references" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_informative-references"><span class="secno">G.2 </span>Informative references</h3><dl class="bibliography" about=""><dt id="bib-HORST04">[HORST04]</dt><dd rel="dcterms:references">Herman J. ter Horst. <cite>Extending the RDFS Entailment Lemma</cite>, in S.A. McIlraith et al. (Eds.), The Semantic Web - ISWC2004, Proceedings of the Third International Semantic Web Conference, Hiroshima, Japan, November 2004, Springer, LNCS 3298, pp. 77-91.
</dd><dt id="bib-HORST05">[HORST05]</dt><dd rel="dcterms:references">Herman J. ter Horst. <cite>Completeness, Decidability and Complexity of Entailment for RDF Schema and a Semantic Extension Involving the OWL Vocabulary</cite>, Journal of Web Semantics 3 (2005) 79-115.
</dd><dt id="bib-ISO24707">[ISO24707]</dt><dd rel="dcterms:references"><cite>Information technology — Common Logic (CL): a framework for a family of logic-based languages</cite> 1 October 2007. International Standard ISO/IEC 24707:2007(E). URL: <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c039175_ISO_IEC_24707_2007%28E%29.zip"> http://standards.iso.org/ittf/PubliclyAvailableStandards/c039175_ISO_IEC_24707_2007%28E%29.zip</a>
</dd><dt id="bib-OWL2-OVERVIEW">[OWL2-OVERVIEW]</dt><dd rel="dcterms:references">W3C OWL Working Group. <a href="http://www.w3.org/TR/owl2-overview/"><cite>OWL 2 Web Ontology Language Document Overview (Second Edition)</cite></a>. 11 December 2012. W3C Recommendation. URL: <a href="http://www.w3.org/TR/owl2-overview/">http://www.w3.org/TR/owl2-overview/</a>
</dd><dt id="bib-OWL2-PROFILES">[OWL2-PROFILES]</dt><dd rel="dcterms:references">Boris Motik; Bernardo Cuenca Grau; Ian Horrocks; Zhe Wu; Achille Fokoue. <a href="http://www.w3.org/TR/owl2-profiles/"><cite>OWL 2 Web Ontology Language Profiles (Second Edition)</cite></a>. 11 December 2012. W3C Recommendation. URL: <a href="http://www.w3.org/TR/owl2-profiles/">http://www.w3.org/TR/owl2-profiles/</a>
</dd><dt id="bib-OWL2-SYNTAX">[OWL2-SYNTAX]</dt><dd rel="dcterms:references">Boris Motik; Peter Patel-Schneider; Bijan Parsia. <a href="http://www.w3.org/TR/owl2-syntax/"><cite>OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)</cite></a>. 11 December 2012. W3C Recommendation. URL: <a href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>
</dd><dt id="bib-RDF-MT">[RDF-MT]</dt><dd rel="dcterms:references">Patrick Hayes. <a href="http://www.w3.org/TR/rdf-mt/"><cite>RDF Semantics</cite></a>. 10 February 2004. W3C Recommendation. URL: <a href="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/</a>
</dd><dt id="bib-RDF-TESTCASES">[RDF-TESTCASES]</dt><dd rel="dcterms:references">jan grant; Dave Beckett. <a href="http://www.w3.org/TR/rdf-testcases"><cite>RDF Test Cases</cite></a>. 10 February 2004. W3C Recommendation. URL: <a href="http://www.w3.org/TR/rdf-testcases">http://www.w3.org/TR/rdf-testcases</a>
</dd><dt id="bib-RDF11-SCHEMA">[RDF11-SCHEMA]</dt><dd rel="dcterms:references">Dan Brickley, R. V. Guha. <cite><a href="http://www.w3.org/TR/2014/REC-rdf-schema-20140225/">RDF Schema 1.1</a></cite>. W3C Recommendation, 25 February 2014. URL: <a href="http://www.w3.org/TR/2014/REC-rdf-schema-20140225/">http://www.w3.org/TR/2014/REC-rdf-schema-20140225/</a>. The latest published version is available at <a href="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a>.
</dd><dt id="bib-RIF-OVERVIEW">[RIF-OVERVIEW]</dt><dd rel="dcterms:references">Michael Kifer; Harold Boley. <a href="http://www.w3.org/TR/rif-overview/"><cite>RIF Overview (Second Edition)</cite></a>. 5 February 2013. W3C Note. URL: <a href="http://www.w3.org/TR/rif-overview/">http://www.w3.org/TR/rif-overview/</a>
</dd><dt id="bib-SPARQL11-QUERY">[SPARQL11-QUERY]</dt><dd rel="dcterms:references">Steven Harris; Andy Seaborne. <a href="http://www.w3.org/TR/sparql11-query/"><cite>SPARQL 1.1 Query Language</cite></a>. 21 March 2013. W3C Recommendation. URL: <a href="http://www.w3.org/TR/sparql11-query/">http://www.w3.org/TR/sparql11-query/</a>
</dd><dt id="bib-SWBP-XSCH-DATATYPES">[SWBP-XSCH-DATATYPES]</dt><dd rel="dcterms:references">Jeremy Carroll; Jeff Pan. <a href="http://www.w3.org/TR/swbp-xsch-datatypes"><cite>XML Schema Datatypes in RDF and OWL</cite></a>. 14 March 2006. W3C Note. URL: <a href="http://www.w3.org/TR/swbp-xsch-datatypes">http://www.w3.org/TR/swbp-xsch-datatypes</a>
</dd><dt id="bib-XML10">[XML10]</dt><dd rel="dcterms:references">Tim Bray; Jean Paoli; Michael Sperberg-McQueen; Eve Maler; François Yergeau et al. <a href="http://www.w3.org/TR/xml"><cite>Extensible Markup Language (XML) 1.0 (Fifth Edition)</cite></a>. 26 November 2008. W3C Recommendation. URL: <a href="http://www.w3.org/TR/xml">http://www.w3.org/TR/xml</a>
</dd><dt id="bib-XMLSCHEMA11-2">[XMLSCHEMA11-2]</dt><dd rel="dcterms:references">David Peterson; Sandy Gao; Ashok Malhotra; Michael Sperberg-McQueen; Henry Thompson; Paul V. Biron et al. <a href="http://www.w3.org/TR/xmlschema11-2/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</cite></a>. 5 April 2012. W3C Recommendation. URL: <a href="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>
</dd></dl></section></section></body></html>