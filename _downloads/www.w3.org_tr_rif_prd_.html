<!-- http://www.w3.org/TR/rif-prd/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF Production Rule Dialect (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF Production Rule Dialect (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/" id="this-version-url">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-rif-prd-20121211/">http://www.w3.org/TR/2012/PER-rif-prd-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Christian de Sainte Marie, IBM/ILOG</dd>
<dd>Gary Hallmark, Oracle</dd>
<dd>Adrian Paschke, Freie Universitaet Berlin</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2010/rif/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/REC-rif-prd-20130205.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2010/rif/translation/rif-prd">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p></p> <p></p> <p></p> <p>This document, developed by the <a class="external text" href="http://www.w3.org/2005/rules" rel="nofollow" title="http://www.w3.org/2005/rules">Rule Interchange Format (RIF) Working Group</a>, specifies the production rule dialect of the W3C rule interchange format (RIF-PRD), a standard XML serialization format for production rule languages. </p> <p></p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a>  (this document)</li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a></li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/PER-rif-prd-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<p><span class="anchor" id="sec-overview"></span> 
</p>
<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a>
<ul>
<li class="toclevel-2"><a href="#Production_rule_interchange"><span class="tocnumber">1.1</span> <span class="toctext">Production rule interchange</span></a></li>
<li class="toclevel-2"><a href="#Running_example"><span class="tocnumber">1.2</span> <span class="toctext">Running example</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conditions"><span class="tocnumber">2</span> <span class="toctext">Conditions</span></a>
<ul>
<li class="toclevel-2"><a href="#Abstract_syntax"><span class="tocnumber">2.1</span> <span class="toctext">Abstract syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Terms"><span class="tocnumber">2.1.1</span> <span class="toctext">Terms</span></a></li>
<li class="toclevel-3"><a href="#Atomic_formulas"><span class="tocnumber">2.1.2</span> <span class="toctext">Atomic formulas</span></a></li>
<li class="toclevel-3"><a href="#Formulas"><span class="tocnumber">2.1.3</span> <span class="toctext">Formulas</span></a></li>
<li class="toclevel-3"><a href="#Well-formed_formulas"><span class="tocnumber">2.1.4</span> <span class="toctext">Well-formed formulas</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Operational_semantics_of_condition_formulas"><span class="tocnumber">2.2</span> <span class="toctext">Operational semantics of condition formulas</span></a>
<ul>
<li class="toclevel-3"><a href="#Matching_substitution"><span class="tocnumber">2.2.1</span> <span class="toctext">Matching substitution</span></a></li>
<li class="toclevel-3"><a href="#Condition_satisfaction"><span class="tocnumber">2.2.2</span> <span class="toctext">Condition satisfaction</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Actions"><span class="tocnumber">3</span> <span class="toctext">Actions</span></a>
<ul>
<li class="toclevel-2"><a href="#Abstract_syntax_2"><span class="tocnumber">3.1</span> <span class="toctext">Abstract syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Actions_2"><span class="tocnumber">3.1.1</span> <span class="toctext">Actions</span></a></li>
<li class="toclevel-3"><a href="#Action_blocks"><span class="tocnumber">3.1.2</span> <span class="toctext">Action blocks</span></a></li>
<li class="toclevel-3"><a href="#Well-formed_action_blocks"><span class="tocnumber">3.1.3</span> <span class="toctext">Well-formed action blocks</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Operational_semantics_of_atomic_actions"><span class="tocnumber">3.2</span> <span class="toctext">Operational semantics of atomic actions</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Production_rules_and_rule_sets"><span class="tocnumber">4</span> <span class="toctext">Production rules and rule sets</span></a>
<ul>
<li class="toclevel-2"><a href="#Abstract_syntax_3"><span class="tocnumber">4.1</span> <span class="toctext">Abstract syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Rules"><span class="tocnumber">4.1.1</span> <span class="toctext">Rules</span></a></li>
<li class="toclevel-3"><a href="#Groups"><span class="tocnumber">4.1.2</span> <span class="toctext">Groups</span></a></li>
<li class="toclevel-3"><a href="#Safeness"><span class="tocnumber">4.1.3</span> <span class="toctext">Safeness</span></a></li>
<li class="toclevel-3"><a href="#Well-formed_rules_and_groups"><span class="tocnumber">4.1.4</span> <span class="toctext">Well-formed rules and groups</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Operational_semantics_of_rules_and_rule_sets"><span class="tocnumber">4.2</span> <span class="toctext">Operational semantics of rules and rule sets</span></a>
<ul>
<li class="toclevel-3"><a href="#Motivation_and_example"><span class="tocnumber">4.2.1</span> <span class="toctext">Motivation and example</span></a></li>
<li class="toclevel-3"><a href="#Rules_normalization"><span class="tocnumber">4.2.2</span> <span class="toctext">Rules normalization</span></a></li>
<li class="toclevel-3"><a href="#Definitions_and_notational_conventions"><span class="tocnumber">4.2.3</span> <span class="toctext">Definitions and notational conventions</span></a></li>
<li class="toclevel-3"><a href="#Operational_semantics_of_a_production_rule_system"><span class="tocnumber">4.2.4</span> <span class="toctext">Operational semantics of a production rule system</span></a></li>
<li class="toclevel-3"><a href="#Conflict_resolution"><span class="tocnumber">4.2.5</span> <span class="toctext">Conflict resolution</span></a></li>
<li class="toclevel-3"><a href="#Halting_test"><span class="tocnumber">4.2.6</span> <span class="toctext">Halting test</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Document_and_imports"><span class="tocnumber">5</span> <span class="toctext">Document and imports</span></a>
<ul>
<li class="toclevel-2"><a href="#Abstract_syntax_4"><span class="tocnumber">5.1</span> <span class="toctext">Abstract syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Import_directive"><span class="tocnumber">5.1.1</span> <span class="toctext">Import directive</span></a></li>
<li class="toclevel-3"><a href="#RIF-PRD_document"><span class="tocnumber">5.1.2</span> <span class="toctext">RIF-PRD document</span></a></li>
<li class="toclevel-3"><a href="#Well-formed_documents"><span class="tocnumber">5.1.3</span> <span class="toctext">Well-formed documents</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Operational_semantics_of_RIF-PRD_documents"><span class="tocnumber">5.2</span> <span class="toctext">Operational semantics of RIF-PRD documents</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Built-in_functions.2C_predicates_and_actions"><span class="tocnumber">6</span> <span class="toctext">Built-in functions, predicates and actions</span></a>
<ul>
<li class="toclevel-2"><a href="#Built-in_actions"><span class="tocnumber">6.1</span> <span class="toctext">Built-in actions</span></a>
<ul>
<li class="toclevel-3"><a href="#act:print"><span class="tocnumber">6.1.1</span> <span class="toctext">act:print</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_and_interoperability"><span class="tocnumber">7</span> <span class="toctext">Conformance and interoperability</span></a>
<ul>
<li class="toclevel-2"><a href="#Semantics-preserving_transformations"><span class="tocnumber">7.1</span> <span class="toctext">Semantics-preserving transformations</span></a></li>
<li class="toclevel-2"><a href="#Conformance_Clauses"><span class="tocnumber">7.2</span> <span class="toctext">Conformance Clauses</span></a></li>
<li class="toclevel-2"><a href="#Interoperability"><span class="tocnumber">7.3</span> <span class="toctext">Interoperability</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#XML_Syntax"><span class="tocnumber">8</span> <span class="toctext">XML Syntax</span></a>
<ul>
<li class="toclevel-2"><a href="#Notational_conventions"><span class="tocnumber">8.1</span> <span class="toctext">Notational conventions</span></a>
<ul>
<li class="toclevel-3"><a href="#Namespaces"><span class="tocnumber">8.1.1</span> <span class="toctext">Namespaces</span></a></li>
<li class="toclevel-3"><a href="#BNF_pseudo-schemas"><span class="tocnumber">8.1.2</span> <span class="toctext">BNF pseudo-schemas</span></a></li>
<li class="toclevel-3"><a href="#Syntactic_components"><span class="tocnumber">8.1.3</span> <span class="toctext">Syntactic components</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Relative_IRIs_and_XML_base"><span class="tocnumber">8.2</span> <span class="toctext">Relative IRIs and XML base</span></a></li>
<li class="toclevel-2"><a href="#Conditions_2"><span class="tocnumber">8.3</span> <span class="toctext">Conditions</span></a>
<ul>
<li class="toclevel-3"><a href="#TERM"><span class="tocnumber">8.3.1</span> <span class="toctext">TERM</span></a>
<ul>
<li class="toclevel-4"><a href="#Const"><span class="tocnumber">8.3.1.1</span> <span class="toctext">Const</span></a></li>
<li class="toclevel-4"><a href="#Var"><span class="tocnumber">8.3.1.2</span> <span class="toctext">Var</span></a></li>
<li class="toclevel-4"><a href="#List"><span class="tocnumber">8.3.1.3</span> <span class="toctext">List</span></a></li>
<li class="toclevel-4"><a href="#External"><span class="tocnumber">8.3.1.4</span> <span class="toctext">External</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#ATOMIC"><span class="tocnumber">8.3.2</span> <span class="toctext">ATOMIC</span></a>
<ul>
<li class="toclevel-4"><a href="#Atom"><span class="tocnumber">8.3.2.1</span> <span class="toctext">Atom</span></a></li>
<li class="toclevel-4"><a href="#Equal"><span class="tocnumber">8.3.2.2</span> <span class="toctext">Equal</span></a></li>
<li class="toclevel-4"><a href="#Member"><span class="tocnumber">8.3.2.3</span> <span class="toctext">Member</span></a></li>
<li class="toclevel-4"><a href="#Subclass"><span class="tocnumber">8.3.2.4</span> <span class="toctext">Subclass</span></a></li>
<li class="toclevel-4"><a href="#Frame"><span class="tocnumber">8.3.2.5</span> <span class="toctext">Frame</span></a></li>
<li class="toclevel-4"><a href="#External_2"><span class="tocnumber">8.3.2.6</span> <span class="toctext">External</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#FORMULA"><span class="tocnumber">8.3.3</span> <span class="toctext">FORMULA</span></a>
<ul>
<li class="toclevel-4"><a href="#ATOMIC_2"><span class="tocnumber">8.3.3.1</span> <span class="toctext">ATOMIC</span></a></li>
<li class="toclevel-4"><a href="#And"><span class="tocnumber">8.3.3.2</span> <span class="toctext">And</span></a></li>
<li class="toclevel-4"><a href="#Or"><span class="tocnumber">8.3.3.3</span> <span class="toctext">Or</span></a></li>
<li class="toclevel-4"><a href="#INeg"><span class="tocnumber">8.3.3.4</span> <span class="toctext">INeg</span></a></li>
<li class="toclevel-4"><a href="#Exists"><span class="tocnumber">8.3.3.5</span> <span class="toctext">Exists</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2"><a href="#Actions_3"><span class="tocnumber">8.4</span> <span class="toctext">Actions</span></a>
<ul>
<li class="toclevel-3"><a href="#ACTION"><span class="tocnumber">8.4.1</span> <span class="toctext">ACTION</span></a>
<ul>
<li class="toclevel-4"><a href="#Assert"><span class="tocnumber">8.4.1.1</span> <span class="toctext">Assert</span></a></li>
<li class="toclevel-4"><a href="#Retract"><span class="tocnumber">8.4.1.2</span> <span class="toctext">Retract</span></a></li>
<li class="toclevel-4"><a href="#Modify"><span class="tocnumber">8.4.1.3</span> <span class="toctext">Modify</span></a></li>
<li class="toclevel-4"><a href="#Execute"><span class="tocnumber">8.4.1.4</span> <span class="toctext">Execute</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#ACTION_BLOCK"><span class="tocnumber">8.4.2</span> <span class="toctext">ACTION_BLOCK</span></a>
<ul>
<li class="toclevel-4"><a href="#New"><span class="tocnumber">8.4.2.1</span> <span class="toctext">New</span></a></li>
<li class="toclevel-4"><a href="#Do"><span class="tocnumber">8.4.2.2</span> <span class="toctext">Do</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2"><a href="#Rules_and_Groups"><span class="tocnumber">8.5</span> <span class="toctext">Rules and Groups</span></a>
<ul>
<li class="toclevel-3"><a href="#RULE"><span class="tocnumber">8.5.1</span> <span class="toctext">RULE</span></a>
<ul>
<li class="toclevel-4"><a href="#ACTION_BLOCK_2"><span class="tocnumber">8.5.1.1</span> <span class="toctext">ACTION_BLOCK</span></a></li>
<li class="toclevel-4"><a href="#Implies"><span class="tocnumber">8.5.1.2</span> <span class="toctext">Implies</span></a></li>
<li class="toclevel-4"><a href="#Forall"><span class="tocnumber">8.5.1.3</span> <span class="toctext">Forall</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#Group"><span class="tocnumber">8.5.2</span> <span class="toctext">Group</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Document_and_directives"><span class="tocnumber">8.6</span> <span class="toctext">Document and directives</span></a>
<ul>
<li class="toclevel-3"><a href="#Import"><span class="tocnumber">8.6.1</span> <span class="toctext">Import</span></a></li>
<li class="toclevel-3"><a href="#Document"><span class="tocnumber">8.6.2</span> <span class="toctext">Document</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Constructs_carrying_no_semantics"><span class="tocnumber">8.7</span> <span class="toctext">Constructs carrying no semantics</span></a>
<ul>
<li class="toclevel-3"><a href="#Annotation"><span class="tocnumber">8.7.1</span> <span class="toctext">Annotation</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Presentation_syntax_.28Informative.29"><span class="tocnumber">9</span> <span class="toctext">Presentation syntax (Informative)</span></a></li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">10</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">11</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_references"><span class="tocnumber">11.1</span> <span class="toctext">Normative references</span></a></li>
<li class="toclevel-2"><a href="#Informational_references"><span class="tocnumber">11.2</span> <span class="toctext">Informational references</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Model-theoretic_semantics_of_RIF-PRD_condition_formulas"><span class="tocnumber">12</span> <span class="toctext">Appendix: Model-theoretic semantics of RIF-PRD condition formulas</span></a>
<ul>
<li class="toclevel-2"><a href="#Semantic_structures"><span class="tocnumber">12.1</span> <span class="toctext">Semantic structures</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_condition_formulas"><span class="tocnumber">12.2</span> <span class="toctext">Interpretation of condition formulas</span></a></li>
<li class="toclevel-2"><a href="#Condition_satisfaction_2"><span class="tocnumber">12.3</span> <span class="toctext">Condition satisfaction</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_XML_schema"><span class="tocnumber">13</span> <span class="toctext">Appendix: XML schema</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">14</span> <span class="toctext">Appendix: Change Log (Informative)</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Overview" name="Overview"></a><h2> <span class="mw-headline">1  Overview </span></h2>
<p>This document specifies the production rule dialect of the W3C rule interchange format (RIF-PRD), a standard XML serialization format for production rule languages.
</p><p>The production rule dialect is one of a set of rule interchange dialects that also includes the RIF Core dialect ([<a href="#ref-core" title="">RIF-Core</a>]) and the RIF basic logic dialect ([<a href="#ref-rif-bld" title="">RIF-BLD</a>]).
</p><p>RIF-Core, the core dialect of the W3C rule interchange format, is designed to support the interchange of definite Horn rules without function symbols ("Datalog"). RIF-Core has both a standard first-order semantics and an operational semantics. Syntactically, RIF-Core has a number of extensions of Datalog:
</p>
<ul><li> frames as in F-logic [<a href="#ref-klw95" title="">KLW95</a>], 
</li><li> internationalized resource identifiers (or IRIs, defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>]) as identifiers for concepts, and 
</li><li> XML Schema datatypes [<a href="#ref-xml-schema2" title="">XML-SCHEMA2</a>]. 
</li></ul>
<p>RIF-Core is based on a rich set of datatypes and built-ins that are aligned with Web-aware rule system implementations [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. In addition, the RIF RDF and OWL Compatibility document [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>] specifies the syntax and semantics of combinations of RIF-Core, RDF, and OWL documents.
</p><p>RIF-Core is intended to be the common core of all RIF dialects, and it has been designed,
in particular, to be a useful common subset of RIF-BLD and RIF-PRD. RIF-PRD includes and extends RIF-Core, and, therefore, RIF-PRD inherits all RIF-Core features. These features make RIF-PRD a Web-aware (even a semantic Web-aware) language. However, it should be kept in mind that RIF is designed to enable interoperability among rule languages in general, and its uses are not limited to the Web.
</p><p>This document targets designers and developers of RIF-PRD implementations. A RIF-PRD implementation is a software application that serializes production rules as RIF-PRD XML (producer application) and/or that deserializes RIF-PRD XML documents into production rules (consumer application).
</p>
<a id="Production_rule_interchange" name="Production_rule_interchange"></a><h3> <span class="mw-headline">1.1  Production rule interchange </span></h3>
<p>Production rules have an <i>if</i> part, or <i>condition</i>, and a <i>then</i> part, or <i>action</i>. The condition is like the condition part of logic rules (as covered by RIF-Core and its basic logic dialect extension, RIF-BLD). The <i>then</i> part contains actions. An action can assert facts, modify facts, retract facts, and have other side-effects. In general, an action is different from the conclusion of a logic rule, which contains only a logical statement. However, the conclusion of rules interchanged using RIF-Core can be interpreted, according to RIF-PRD operational semantics, as actions that assert facts in the knowledge base.  
</p>
<div class="example">
<p><b>Example 1.1.</b> The following are examples of production rules:
</p>
<ul><li> <em>A customer becomes a "Gold" customer when his cumulative purchases during the current year reach $5000</em>.
</li><li> <em>Customers that become "Gold" customers must be notified immediately, and a golden customer card will be printed and sent to them within one week</em>.
</li><li> <em>For shopping carts worth more than $1000, "Gold" customers receive an additional discount of 10% of the total amount.</em> &nbsp;&nbsp;☐
</li></ul>
</div>
<p>Because RIF-PRD is a production rule interchange format, it specifies
an abstract syntax that shares features with concrete
production rule languages, and it associates the abstract constructs with normative semantics and a normative XML concrete syntax. Annotations (<i>e.g.</i> rule author) are the only constructs in RIF-PRD without a formal semantics.
</p><p>The abstract syntax is specified in mathematical English, and the abstract syntactic constructs that are defined in the sections <a href="#sec-conditions-abstract-syntax" title="">Abstract Syntax of Conditions</a>, <a href="#sec-actions-abstract-syntax" title="">Abstract Syntax of Actions</a> and <a href="#sec-rules-abstract-syntax" title="">Abstract Syntax of Rules and Rulesets</a>, are mapped into the concrete XML constructs in the section <a href="#sec-xml-syntax" title="">XML syntax</a>. A lightweight notation is used, instead of the XML syntax, to tie the abstract syntax to the specification of the semantics. A more complete presentation syntax is specified using an EBNF in <a href="#sec-presentation-syntax" title="">Presentation Syntax</a>. However, only the XML syntax and the associated semantics are normative. The normative XML schema is included in <a href="#appendix-xml-schema" title="">Appendix: XML Schema</a>.
</p>
<div class="example">
<p><b>Example 1.2.</b> In RIF-PRD presentation syntax, the first rule in example 1.1. can be represented as follows:
</p>
<pre>Prefix(ex &lt;http://example.com/2008/prd1#&gt;)
(* ex:rule_1 *)
Forall&nbsp;?customer&nbsp;?purchasesYTD (
 If   And(&nbsp;?customer#ex:Customer
          &nbsp;?customer[ex:purchasesYTD-&gt;?purchasesYTD]
           External(pred:numeric-greater-than(?purchasesYTD 5000)) )
 Then Do( Modify(?customer[ex:status-&gt;"Gold"]) ) )
</pre>
<p>☐
</p>
</div>
<p>Production rules are statements of programming logic that specify the execution of one or more actions when their conditions are satisfied. Production rules have an operational semantics, that the OMG Production Rule Representation specification [<a href="#ref-prr" title="">OMG-PRR</a>] summarizes as follows:
</p>
<ol><li> <i>Match:</i> the rules are instantiated based on the definition of the rule conditions and the current state of the data source;
</li><li> <i>Conflict resolution:</i> a decision algorithm, often called <i>the conflict resolution strategy</i>, is applied to select which rule instance will be executed;
</li><li> <i>Act:</i> the state of the data source is changed, by executing the selected rule instance's actions. If a terminal state has not been reached, the control loops back to the first step (<i>Match</i>).
</li></ol>
<p>In the section <a href="#sec-operational-semantics-of-rules-and-rule-sets" title="">Operational semantics of rules and rule sets</a>, the semantics for rules and rule sets is specified, accordingly, as a labeled terminal transition system (<a href="#ref-ltts" title="">PLO04</a>), where state transitions result from executing the action part of instantiated rules. When several rules are found to be executable at the same time, during
the rule execution process, a <i>conflict resolution strategy</i> is used to
select the rule to execute. The section <a href="#sec-conflict-resolution" title="">Conflict resolution</a> specifies how a conflict resolution strategy can be attached to a rule set. RIF-PRD defines a default conflict resolution strategy.
</p><p>In the section <a href="#sec-semantics-of-condition-formulas" title="">Semantics of condition formulas</a>, the semantics of the condition part of rules in RIF-PRD is specified operationally, in terms of matching substitutions. To emphasize the overlap between the rule conditions of RIF-BLD and RIF-PRD, and to share the same RIF definitions for datatypes and built-ins [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], an alternative, and equivalent, specification of the semantics of rule conditions in RIF-PRD, using a model theory, is provided in the appendix <a href="#appendix-model-theory" title="">Model-theoretic semantics of RIF-PRD condition formulas</a>. 
</p><p>The semantics of condition formulas and the semantics of rules and rule sets make no assumption regarding how condition formulas are evaluated. In particular, they do not require that condition formula be evaluated using pattern matching. However, RIF-PRD conformance, as defined in the section <a href="#Conformance_and_interoperability" title="">Conformance and interoperability</a>, requires only support for <a href="#def-safe-rule" title="">safe rules</a>, that is, forward-chaining rules where the conditions can be evaluated based on pattern matching only. 
</p><p>In the section <a href="#sec-operational-semantics-of-atomic-actions" title="">Operational semantics of actions</a>, the semantics of the action part of rules in RIF-PRD is specified using a transition relation between successive states of the data source, represented by ground condition formulas, thus making the link between the model-theoretic semantics of conditions and the operational semantics of rules and rule sets.
</p><p>The abstract syntax of RIF-PRD documents, and the semantics of the combination of multiple RIF-PRD documents, is specified in the section <a href="#sec-document-and-imports" title="">Document and imports</a>.
</p><p>In addition to externally specified functions and predicates, and in particular, in addition to the functions and predicates built-ins defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], RIF-PRD supports externally specified actions, and defines one action built-in, as specified in the section <a href="#sec-builtins" title="">Built-in functions, predicates and actions</a>.
</p><p><br />
</p><p><span class="anchor" id="sec-running-example"></span>
</p>
<a id="Running_example" name="Running_example"></a><h3> <span class="mw-headline">1.2  Running example </span></h3>
<p>The same example rules will be used throughout the document to illustrate the syntax and the semantics of RIF-PRD. 
</p><p>The rules are about the status of customers  at a shop, and the discount awarded to them. The rule set contains four  rules, to be applied when a customer checks out:
</p>
<ol><li> Gold rule: <i>A "Silver" customer with a shopping cart worth at least $2,000 is awarded the "Gold" status</i>. 
</li><li> Discount rule: <i>"Silver" and "Gold" customers are awarded a 5% discount on the total worth of their shopping cart</i>.
</li><li> New customer and widget rule: <i>A "New" customer who buys a widget is awarded a 10% discount on the total worth of her shopping cart, but she looses any voucher she may have been awarded</i>.
</li><li> Unknown status rule: <i>A message must be printed, identifying any customer whose status is unknown (that is, neither "New", "Bronze", "Silver" or "Gold"), and the customer must be assigned the status: "New"</i>. 
</li></ol>
<p>The <i>Gold rule</i> must be applied first; that is, e.g., a customer with "Silver" status and a shopping cart worth exactly $2,000 should be promoted to "Gold" status, before being given the 5% discount that would disallow the application of the <i>Gold rule</i> (since the total worth of his shopping cart would then be only $1,900).
</p><p>In the remainder of this document, the prefix <tt>ex1</tt> stands for the fictitious namespace of this example: <tt>http://example.com/2009/prd2#</tt>.
</p><p><span class="anchor" id="sec-conditions"></span>
</p>
<a id="Conditions" name="Conditions"></a><h2> <span class="mw-headline">2  Conditions </span></h2>
<p>This section specifies the syntax and semantics of the condition language of RIF-PRD.
</p><p>The RIF-PRD condition language specification depends on Section Constants, Symbol Spaces, and Datatypes, in the RIF data types and builtins specification [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p><span class="anchor" id="sec-conditions-abstract-syntax"></span>
</p>
<a id="Abstract_syntax" name="Abstract_syntax"></a><h3> <span class="mw-headline">2.1  Abstract syntax </span></h3>
<p>The alphabet of the RIF-PRD condition language consists of:
</p>
<ul><li> a countably infinite set of <i><b>constant symbols</b></i> <tt>Const</tt>,
</li><li> a countably infinite set of <i><b>variable symbols</b></i> <tt>Var</tt> (disjoint from <tt>Const</tt>),
</li><li> and syntactic constructs to denote:
<ul><li> lists,
</li><li> function calls,
</li><li> relations, including equality, class membership and subclass relations
</li><li> conjunction, disjunction and negation,
</li><li> and existential conditions.
</li></ul>
</li></ul>
<p>For the sake of readability and simplicity, this specification introduces a notation for these constructs. The notation is not intended to be a concrete syntax, so it leaves out many details. The only concrete syntax for RIF-PRD is the XML syntax.
</p><p>RIF-PRD supports externally defined functions only (including the built-in functions specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]). RIF-PRD, unlike <a href="#ref-rif-bld" title="">RIF-BLD</a>, does not support uninterpreted function symbols (sometimes called logically defined functions).
</p><p>RIF-PRD supports a form of negation. Neither <a href="#ref-core" title="">RIF-Core</a> nor <a href="#ref-rif-bld" title="">RIF-BLD</a> support negation, because logic rule languages use many different and incompatible kinds of negation. See also the RIF framework for logic dialects [<a href="#ref-fld" title="">RIF-FLD</a>].
</p><p><span class="anchor" id="sec-terms"></span>
</p>
<a id="Terms" name="Terms"></a><h4> <span class="mw-headline">2.1.1  Terms </span></h4>
<p>The most basic construct in the RIF-PRD condition language is the <i>term</i>. RIF-PRD defines several kinds of term: <i>constants</i>, <i>variables</i>, <i>lists</i> and <i>positional</i> terms.
</p><p><span class="anchor" id="def-bld-term"></span> 
<b>Definition (Term)</b>.
</p>
<ol><li> <i>Constants and variables</i>. If <tt>t</tt> &isin; <tt>Const</tt> or <tt>t</tt> &isin; <tt>Var</tt> then <tt>t</tt> is a <i><b>simple term</b></i>;
</li><li> <i>List terms</i>. A <i><b>list</b></i> has the form <tt>List(t</tt><sub>1</sub>&nbsp;...&nbsp;<tt>t</tt><sub>m</sub><tt>)</tt>, where <tt>m&ge;0</tt> and <tt>t</tt><sub>1</sub>, ..., <tt>t</tt><sub>m</sub> are ground terms, i.e. without variables. A list of the form <tt>List()</tt> (i.e., a list in which <tt>m=0</tt>) is called the <i><b>empty list</b></i>;
</li><li> <i>Positional terms</i>. If <tt>t</tt> &isin; <tt>Const</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt>, <tt>n&ge;0</tt>, are terms then <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>positional term</b></i>.<br />Here, the constant <tt>t</tt> represents a function and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt> represent argument values. &nbsp;&nbsp;☐
</li></ol>
<p>To emphasize interoperability with <a href="#ref-rif-bld" title="">RIF-BLD</a>, positional terms may also be written: <tt>External(t(t<sub>1</sub>...t<sub>n</sub>))</tt>.
</p><p><span class="anchor" id="ref-ex21"></span>
</p>
<div class="example">
<p><b>Example 2.1.</b>
</p>
<ul><li> <tt>List("New" "Bronze" "Silver" "Gold")</tt> is a term that denotes the list of the values for a customer's status that are known to the system. The elements of the list, <tt>"New"</tt>, <tt>"Bronze"</tt>, <tt>"Silver"</tt> and <tt>"Gold"</tt> are terms denoting string constants;
</li><li> <tt>func:numeric-multiply(?value, 0.90)</tt> is a positional term that denotes the product of the value assigned to the variable <tt>?value</tt> and the constant <tt>0.90</tt>. That positional term can be used, for instance, to represent the new value, taking the discount into account, to be assigned a customer's shopping cart, in the rule <i>New customer and widget rule</i>. An alternative notation is to mark explicitly the positional term as externally defined, by wrapping it with the <tt>External</tt> indication: <tt>External(func:numeric-multiply(?value, 0.90))</tt> &nbsp;&nbsp;☐
</li></ul>
</div>
<p><span class="anchor" id="sec-atomic-formulas"></span>
</p>
<a id="Atomic_formulas" name="Atomic_formulas"></a><h4> <span class="mw-headline">2.1.2  Atomic formulas </span></h4>
<p><i>Atomic formulas</i> are the basic tests of the RIF-PRD condition language.
</p><p><span class="anchor" id="def-prd-atomic"></span>
<span class="anchor" id="def-prd-atomic-formula"></span>
<b>Definition (Atomic formula)</b>.
An <i><b>atomic formula</b></i> can have several different forms and is defined as follows:
</p>
<ol><li> <i>Positional atomic formulas</i>. If <tt>t</tt> &isin; <tt>Const</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt>, <tt>n&ge;0</tt>, are terms then <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>positional atomic formula</b></i> (or simply an <i><b>atom</b></i>)
</li><li> <i>Equality atomic formulas</i>.  <tt>t&nbsp;=&nbsp;s</tt> is an <i><b>equality atomic formula</b></i> (or simply an <i><b>equality</b></i>), if <tt>t</tt> and <tt>s</tt> are terms
</li><li> <i>Class membership atomic formulas</i>. <tt>t#s</tt> is a <i><b>membership atomic formula</b></i> (or simply <i><b>membership</b></i>) if <tt>t</tt> and <tt>s</tt> are terms. The term <tt>t</tt> is the <i>object</i> and the term <tt>s</tt> is the <i>class</i>
</li><li> <i>Subclass atomic formulas</i>. <tt>t##s</tt> is a <i><b>subclass atomic formula</b></i> (or simply a <i><b>subclass</b></i>)  if <tt>t</tt> and <tt>s</tt> are terms
</li><li> <i>Frame atomic formulas</i>. <tt>t[p<sub>1</sub>-&gt;v<sub>1</sub> ... p<sub>n</sub>-&gt;v<sub>n</sub>]</tt> is a <i><b>frame atomic formula</b></i> (or simply a <i><b>frame</b></i>) if <tt>t</tt>, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are terms. The term <tt>t</tt> is the <i>object</i> of the frame; the <tt>p<sub>i</sub></tt> are the <i>property</i> or <i>attribute</i> names; and the <tt>v<sub>i</sub></tt> are the property or attribute <i>values</i>. In this document, an attribute/value pair is sometimes called a <i>slot</i>
</li><li> <i>Externally defined atomic formulas.</i> If <tt>t</tt> is a positional atomic formula then <tt>External(t)</tt> is an <i><b>externally defined atomic formula</b></i>. &nbsp;&nbsp;☐
</li></ol>
<p>Class membership, subclass, and frame atomic formulas are used to represent classifications, class hierarchies and object-attribute-value relations.
</p><p>Externally defined atomic formulas are used, in particular, for representing built-in predicates.
</p><p>In the <a href="#ref-rif-bld" title="">RIF-BLD</a> specification, as is common practice in logic languages, 
atomic formulas are also called <i>terms</i>.
</p><p><span class="anchor" id="ref-ex22"></span>
</p>
<div class="example">
<p><b>Example 2.2.</b>
</p>
<ul><li> The membership formula <tt>?customer # ex1:Customer</tt> tests whether the individual bound to the variable <tt>?customer</tt> is a member of the class denoted by <tt>ex1:Customer</tt>.
</li><li> The atom <tt>ex1:Gold(?customer)</tt> tests whether the customer represented by the variable <tt>?customer</tt> has the <i>"Gold"</i> status. 
</li><li> Alternatively, gold status can be tested in a way that is closer to an object-oriented representation using the frame formula <tt>?customer[ex1:status-&gt;"Gold"]</tt>.
</li><li> The following atom uses the built-in predicate <tt>pred:list-contains</tt> to validate the status of a customer against a list of allowed customer statuses: <tt>External(pred:list-contains(List("New", "Bronze", "Silver", "Gold"),&nbsp;?status))</tt>. &nbsp;&nbsp;☐
</li></ul>
</div>
<p><span class="anchor" id="sec-formulas"></span>
</p>
<a id="Formulas" name="Formulas"></a><h4> <span class="mw-headline">2.1.3  Formulas </span></h4>
<p>Composite truth-valued constructs are called <i>formulas</i>, in RIF-PRD.
</p><p>Note that terms (constants, variables, lists and functions) are <i>not</i> formulas.
</p><p>More general formulas are constructed out of atomic formulas with the help of logical connectives.
</p><p><span class="anchor" id="def-bld-formula"></span> 
<b>Definition (Condition formula)</b>.
A <i><b>condition formula</b></i> can have several different forms and is defined as follows:
</p>
<ol><li> <i>Atomic formula</i>: If <tt>&phi;</tt>  is an atomic formula then it is also a condition formula.
</li><li> <i>Conjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>,  <tt>n &ge; 0</tt>, are condition formulas then so is <tt>And(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>, called a <i>conjunctive</i> formula. As a special case, <tt>And()</tt> is allowed and is treated as a tautology, i.e., a formula that is always true. 
</li><li> <i>Disjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are condition formulas then so is <tt>Or(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>, called a <i>disjunctive</i> formula. As a special case, <tt>Or()</tt> is permitted and is treated as a contradiction, i.e., a formula that is always false. 
</li><li> <i>Negation</i>: If <tt>&phi;</tt> is a condition formula, then so is <tt>Not(&phi;)</tt>, called a <i>negative</i> formula.
</li><li> <i>Existentials</i>: If <tt>&phi;</tt>  is a condition formula and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are variables then <tt>Exists&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> is an <i>existential</i> formula.  &nbsp;&nbsp;☐
</li></ol>
<p>In the definition of a formula, the component formulas <tt>&phi;</tt> and <tt>&phi;<sub>i</sub></tt>  are said to be <span class="anchor" id="def-subformula"><i><b>subformulas</b></i></span> of the respective condition formulas that are built using these components.
</p><p><span class="anchor" id="ref-ex23"></span>
</p>
<div class="example">
<p><b>Example 2.3.</b>
</p>
<ul><li> The condition of the <a href="#sec-running-example" title=""><i>New customer and widget rule</i></a>: <i>A "New" customer who buys a widget</i>, can be represented by the following RIF-PRD condition formula:
</li></ul>
<pre>And(&nbsp;?customer # ex1:Customer
    &nbsp;?customer[ex1:status-&gt;"New"]
     Exists&nbsp;?shoppingCart&nbsp;?item ( And (&nbsp;?customer[ex1:shoppingCart-&gt;?shoppingCart]
                                       &nbsp;?shoppingCart[ex1:containsItem-&gt;?item]
                                       &nbsp;?item # ex1:Widget) )
                                )
    )
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="def-free_var_base"></span> 
The function <i><b>Var</b></i>, that maps a term, an atomic formula or a condition formula to the set of its free variables is defined as follows:
</p>
<ul><li> if <i>e</i> &isin; <i>Const</i>, then <i>Var(e) = &empty;</i>;
</li><li> if <i>e</i> &isin; <i>Var</i>, then <i>Var(e)</i> = {<i>e</i>};
</li><li> if <i>e</i> is a <i>list term</i>, then <i>Var(e) = &empty;</i>;
</li><li> if <i>f(arg<sub>1</sub>...arg<sub>n</sub>)</i>, <i>n &ge; 0</i>, is a positional term, then, <i>Var(f(arg<sub>1</sub>...arg<sub>n</sub>)</i> = &cup;<sub>i=1...n</sub> <i>Var(arg<sub>i</sub>)</i>;
</li><li> if <i>p(arg<sub>1</sub>...arg<sub>n</sub>)</i>, n &ge; 0, is an atom, then, <i>Var(p(arg<sub>1</sub>...arg<sub>n</sub>)</i> = <i>Var(External(p(arg<sub>1</sub>...arg<sub>n</sub>))</i> = &cup;<sub>i=1...n</sub> <i>Var(arg<sub>i</sub>)</i>;
</li><li> if <i>t<sub>1</sub></i> and <i>t<sub>2</sub></i> are terms, then <i>Var(t<sub>1</sub> [=|#|##] t<sub>2</sub>)</i> = <i>Var(t<sub>1</sub>)</i> &cup; <i>Var(t<sub>2</sub>)</i>; 
</li><li> if <i>o'</i>, <i>k</i><sub>i</sub>, <i>i</i> = 1...n, and <i>v</i><sub>i</sub>, <i>i</i> = 1...n, n &ge; 1, are terms, then <i>Var(o[k<sub>1</sub>-&gt;v<sub>1</sub> ... k<sub>n</sub>-&gt;v<sub>n</sub>])</i> = <i>Var(o)</i> &cup;<sub>i=1...n</sub> <i>Var(k<sub>i</sub>)</i> &cup;<sub>i=1...n</sub> <i>Var(v<sub>i</sub>)</i>.
</li><li> if <i>f<sub>i</sub></i>, <i>i</i> = 0...n, n &ge; 0, are condition formulas, then <i>Var([And|Or](f<sub>1</sub>...f<sub>n</sub>))</i> = &cup;<sub>i=0...n</sub> <i>Var(f<sub>i</sub>)</i>;
</li><li> if <i>f</i> is a condition formula, then <i>Var(Not(f))</i> = <i>Var(f)</i>;
</li><li> if <i>f</i> is a condition formula and <i>x<sub>i</sub></i> &isin; <i>Var</i> for <i>i</i> = 1...n, <i>n &ge; 1</i>, then, <i>Var(Exists x<sub>1</sub> ... x<sub>n</sub> (f))</i> = <i>Var(f)</i> - <i>{x<sub>1</sub>...x<sub>n</sub>}</i>.
</li></ul>
<p><span class="anchor" id="def-prd-ground-formula"></span> 
<b>Definition (Ground formula)</b>. A condition formula <tt>&phi;</tt> is a <i><b>ground formula</b></i> if and only if <i>Var</i><tt>&phi;</tt> = <i>&empty;</i> and <tt>&phi;</tt> does not contain any existential subformula. &nbsp;&nbsp;☐
</p><p>In other words, a ground formula does not contain any variable term.
</p><p><span class="anchor" id="sec-well-formed-formulas"></span>
</p>
<a id="Well-formed_formulas" name="Well-formed_formulas"></a><h4> <span class="mw-headline">2.1.4  Well-formed formulas </span></h4>
<p>Not all formulas are well-formed in RIF-PRD: it is required that no constant appear in more than one context. What this means precisely is explained below.
</p><p>The set of all constant symbols, <tt>Const</tt>, is partitioned into the following subsets:
</p>
<ul><li> A subset of individuals. The symbols in <tt>Const</tt> that belong to the primitive datatypes are required to be individuals;
</li><li> A subset for external function symbols;
</li><li> A subset of plain predicate symbols;
</li><li> A subset for external predicate symbols.
</li></ul>
<p>As seen from the following definitions, these subsets are not specified explicitly but, rather, are inferred from the occurrences of the symbols.
</p><p><br />
<span class="anchor" id="def-bld-context"></span> 
<b>Definition (Context of a symbol)</b>.
The <i><b>context of an occurrence</b></i> of a symbol, <tt>s&isin;Const</tt>, in a formula, <tt>&phi;</tt>,  is determined as follows:
</p>
<ul><li> If <tt>s</tt> occurs as a predicate in an atomic <a href="#def-subformula" title="">subformula</a> of the form <tt>s(...)</tt> then <tt>s</tt> occurs in the <i>context of a (plain) predicate symbol</i>;
</li><li> If <tt>s</tt> occurs as a predicate in an atomic subformula <tt>External(s(...))</tt> then <tt>s</tt> occurs in the <i>context of an external predicate symbol</i>;
</li><li> If <tt>s</tt> occurs as a function in a term (which is not a subformula) <tt>s(...)</tt> (or <tt>External(s(...))</tt>) then <tt>s</tt> occurs in the <i>context of an (external) function symbol</i>;
</li><li> If <tt>s</tt> occurs in any other context (e.g. in a frame: <tt>s[...]</tt>, <tt>...[s-&gt;...]</tt>, or <tt>...[...-&gt;s]</tt>; or in a positional atom: <tt>p(...s...)</tt>), it is said to occur as an <i>individual</i>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-bld-wff"></span> 
<b>Definition (Well-formed formula)</b>.
A formula <tt>&phi;</tt>  is <i><b>well-formed</b></i> iff:
</p>
<ul><li> every constant symbol mentioned in <tt>&phi;</tt> occurs in exactly one <a href="#def-bld-context" title="">context</a>;
</li><li> whenever a formula contains a positional term, <tt>t</tt> (or <tt>External(t)</tt>), or an external atomic formula, <tt>External(t)</tt>, <tt>t</tt> must be an instance of a schema in the coherent set of external schemas (Section Schemas for Externally Defined Terms in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) associated with the <a href="#def-prd-lang" title="">language of RIF-PRD</a>;
</li><li> if <tt>t</tt> is an instance of a schema in the coherent set of external schemas associated with the language then <tt>t</tt> can occur only as an external term or atomic formula. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-prd-lang"></span> 
<b>Definition (RIF-PRD condition language)</b>.
The <i><b>RIF-PRD condition language</b></i> consists of the set of all well-formed formulas. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="sec-semantics-of-condition-formulas"></span>
</p>
<a id="Operational_semantics_of_condition_formulas" name="Operational_semantics_of_condition_formulas"></a><h3> <span class="mw-headline">2.2  Operational semantics of condition formulas </span></h3>
<p>This section specifies the semantics of the condition formulas in a RIF-PRD document.
</p><p>Informally, a condition formula is evaluated with respect to a state of facts and it is <i>satisfied</i>, or <i>true</i>, if and only if:
</p>
<ul><li> it is an atomic condition formula and its variables are bound to individuals such that, when these constants are substituted for the variables, either
<ul><li> it matches a fact, or
</li><li> it is implied by some background knowledge, or
</li><li> it is an externally defined predicate, and its evaluation yelds <i>true</i>, or
</li></ul>
</li><li> it is a compound condition formula: conjunction, disjunction, negation or existential; and it is evaluated as expected, based on the truth value of its atomic components.
</li></ul>
<p>The semantics is specified in terms of matching substitutions in the sections below. The specification makes no assumption regarding how matching substitutions are determined. In particular, it does not require from <a href="#def-bld-wff" title="">well-formed condition formulas</a> that they can be evaluated using pattern matching only. However, RIF-PRD requires <a href="#def-safe-rule" title="">safeness</a> from <a href="#def-wf-rule" title="">well-formed rules</a>, which implies that all the variables in the left-hand side can be bound by pattern matching.
</p><p>For compatibility with other RIF specifications (in particular, RIF data types and built-ins [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and RIF RDF and OWL compatibility [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>]), and to make explicit the interoperability with RIF logic dialects (in particular RIF Core [<a href="#ref-core" title="">RIF-Core</a>] and RIF-BLD [<a href="#ref-rif-bld" title="">RIF-BLD</a>]), the semantics of RIF-PRD condition formulas is also specified using model theory, in <a href="#appendix-model-theory" title="">appendix Model theoretic semantics of RIF-PRD condition formulas</a>.
</p><p>The two specifications are equivalent and normative.
</p><p><span class="anchor" id="sec-matching-substitution"></span>
</p>
<a id="Matching_substitution" name="Matching_substitution"></a><h4> <span class="mw-headline">2.2.1  Matching substitution </span></h4>
<p>Let <tt>Term</tt> be the set of the terms in the RIF-PRD condition language (as defined in section <a href="#sec-terms" title="">Terms</a>).
</p><p><span class="anchor" id="def-substitution"></span> 
<b>Definition (Substitution).</b> A <i><b>substitution</b></i> is a finitely non-identical assignment of terms to variables; i.e., a function <i>&sigma;</i> from <tt>Var</tt> to <tt>Term</tt> such that the set {<i>x</i> &isin; <tt>Var</tt> | <i>x</i> &ne; &sigma;(<i>x</i>)} is finite. This set is called the domain of &sigma; and denoted by <i>Dom</i>(&sigma;). Such a substitution is also written as a set such as &sigma; = {<i>t<sub>i</sub></i>/<i>x<sub>i</sub></i>}<sub>i=1..n</sub> where <i>Dom</i>(&sigma;) = {<i>x<sub>i</sub></i>}<sub>i=1..n</sub> and &sigma;(<i>x<sub>i</sub></i>) = <i>t<sub>i</sub></i>, <i>i</i> = 1..n. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-ground-subst"></span>
<b>Definition (Ground Substitution).</b> A <i>ground substitution</i> is a substitution &sigma; that assigns only ground terms to the variables in <i>Dom</i>(&sigma;): &forall; <i>x</i> &isin; <i>Dom</i>(&sigma;), <i>Var</i>(&sigma;(<i>x</i>)) = &empty; &nbsp;&nbsp;☐
</p><p>Because RIF-PRD covers only externally defined interpreted functions, a ground positional term can always be replaced by the (non-positional) ground term to which it evaluates. As a consequence, a ground RIF-PRD formula can always be restricted, without loss of generality, to contain no positional term; that is, to be such that any ground positional terms have been replaced with the non-positional ground terms to which they evaluate. In the remainder of this document, it will always be assumed that a ground condition formula never contains any positional term. As a consequence, a ground substitution never assigns a ground positional term to the variables in its domain.
</p><p>If <i>t</i> is a term or a condition formula, and if <i>&sigma;</i> is a ground substitution such that <i>Var(t)&nbsp;&isin;&nbsp;Dom(&sigma;)</i>, <i>&sigma;(t)</i> denotes the ground term or the ground condition formula obtained by substituting, in <i>t</i>:
</p>
<ul><li> <i>&sigma;(x)</i> for all <i>x&nbsp;&isin;&nbsp;Var(t)</i>, and
</li><li> the externally defined results of interpreting a function with ground arguments, for all externally defined terms.
</li></ul>
<p><span class="anchor" id="def-matching-substitution"></span>
<b>Definition (Matching substitution).</b> Let <i>&psi;</i> be a RIF-PRD condition formula; let <i>&sigma;</i> be a ground substitution such that <i>Var(&psi;)&nbsp;&sube;&nbsp;Dom(&sigma;)</i>; and let <i>&Phi;</i> be a set of ground RIF-PRD atomic formulas.
</p><p>We say that the ground substitution <i>&sigma;</i> <i><b>matches</b></i> <i>&psi;</i> to <i>&Phi;</i> if and only if one of the following is true:
</p>
<ul><li> <i>&psi;</i> is an atomic formula and either
<ul><li> <i>&sigma;(&psi;)</i> &isin; <i>&Phi;</i>, or
</li><li> <i>&psi;</i> is a frame with multiple slots, <tt>o[s<sub>1</sub>-&gt;v<sub>1</sub>...s<sub>n</sub>-&gt;v<sub>n</sub>]</tt>, <i>n &gt; 1</i>, and there is one <i>i, 1&le;i&le;n</i>, such that <i>&sigma;</i> matches the conjunction <tt>And(o[s<sub>i</sub>-&gt;v<sub>i</sub>] o[s<sub>1</sub>-&gt;v<sub>1</sub>...s<sub>i-1</sub>-&gt;v<sub>i-1</sub> s<sub>i+1</sub>-&gt;v<sub>i+1</sub>...s<sub>n</sub>-&gt;v<sub>n</sub>]</tt> to <i>&Phi;</i>; or
</li><li> <i>&psi;</i> is an equality formula, <tt>t<sub>1</sub> = t<sub>2</sub></tt>, and either
<ul><li> <i>&sigma;(t<sub>1</sub>)</i> and <i>&sigma;(t<sub>2</sub>)</i> are the same ground term;
</li><li> or the ground terms <i>&sigma;(t<sub>1</sub>)</i> and <i>&sigma;(t<sub>2</sub>)</i> are list terms with the same length <i>n&ge;0</i> and, for all <i>i, 0&le;i&le;n-1</i>, such that <i>l<sub>1<sub>i</sub></sub></i> and <i>l<sub>2<sub>i</sub></sub></i> are the ground terms of rank <i>i</i> in <i>&sigma;(t<sub>1</sub>)</i> and <i>&sigma;(t<sub>2</sub>)</i>, respectively, either <i>l<sub>1<sub>i</sub></sub></i> and <i>l<sub>2<sub>i</sub></sub></i> are both constants in symbol spaces that are data types and they have the same value, or <tt>l<sub>1<sub>i</sub></sub> = l<sub>2<sub>i</sub></sub></tt> &isin; <i>&Phi;</i>,
</li><li> or the ground terms <i>&sigma;(t<sub>1</sub>)</i> and <i>&sigma;(t<sub>2</sub>)</i> are constants in symbol spaces that are data types and they have the same value; or
</li></ul>
</li><li> <i>&psi;</i> is a membership formula <tt>o&nbsp;#&nbsp;c</tt>, and there is a ground term <i>c' </i> such that <i>&sigma;</i> matches the conjunction <tt>And(o#c' c'##c)</tt> to <i>&Phi;</i>, or
</li><li> <i>&psi;</i> is an external atomic formula and the external definition maps <i>&sigma;(&psi;)</i> to <b>t</b> (or <i>true</i>),
</li></ul>
</li><li> <i>&psi;</i> is <tt>Not(f)</tt> and <i>&sigma;</i> does not match the condition formula <tt>f</tt> to <i>&Phi;</i>,
</li><li> <i>&psi;</i> is <tt>And(f<sub>1</sub> ... f<sub>n</sub>)</tt> and either <tt>n = 0</tt> or <i>&forall; i, 1 &le; i &le; n</i>, &nbsp; <i>&sigma;</i> matches <tt>f<sub>i</sub></tt> to <i>&Phi;</i>,
</li><li> <i>&psi;</i> is <tt>Or(f<sub>1</sub> ... f<sub>n</sub>)</tt> and <tt>n</tt> <i>&gt; 0</i> and &exist; <i>i, 1 &le; i &le; n</i>, such that <i>&sigma;</i> matches <tt>f<sub>i</sub></tt> to <i>&Phi;</i>, or
</li><li> <i>&psi;</i> is <tt>Exists&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (f)</tt>, and there is a substitution <i>&sigma;' </i> that extends <i>&sigma;</i> in such a way that <i>&sigma;' </i> agrees with <i>&sigma;</i> where <i>&sigma;</i> is defined, and <i>Var(<tt>f</tt>)&nbsp;&sube;&nbsp;Dom(&sigma;')</i>; and <i>&sigma;' </i> matches <tt>f</tt> to <i>&Phi;</i>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="sec-satisfaction-of-condition"></span>
</p>
<a id="Condition_satisfaction" name="Condition_satisfaction"></a><h4> <span class="mw-headline">2.2.2  Condition satisfaction </span></h4>
<p>We define, now, what it means for a <i>state of the fact base</i> to satisfy a condition formula. The satisfaction of condition formulas in a state of the fact base provides formal underpinning to the operational semantics of rule sets interchanged using RIF-PRD.
</p><p><span class="anchor" id="def-state"></span>
<b>Definition (State of the fact base).</b> A <i><b>state of the fact base</b></i>, <i>w<sub>&Phi;</sub></i>, is associated to every set of ground atomic formulas, <i>&Phi;</i>, that contains no frame with multiple slots and that satisfies all the following conditions:
</p>
<ul><li> for every equality formula <tt>t<sub>1</sub> = t<sub>2</sub></tt> &isin; <i>&Phi;</i>, if <i>t<sub>1</sub></i> and <i>t<sub>2</sub></i> are, both, constants in symbol spaces that are data types, then they have the same value;
</li><li> for every equality formula <tt>t<sub>1</sub> = t<sub>2</sub></tt> &isin; <i>&Phi;</i>, either <i>t<sub>1</sub></i> is not a constant in a symbol space that is a data type, or <i>t<sub>2</sub></i> is not a list term;
</li><li> for every pair of constants <i>c<sub>1</sub></i> and <i>c<sub>2</sub></i>, if <tt>c<sub>1</sub> = c<sub>2</sub></tt> &isin; <i>&Phi;</i>, then <tt>c<sub>2</sub> = c<sub>1</sub></tt> &isin; <i>&Phi;</i>;
</li><li> for every triple of constants <i>c<sub>1</sub></i>, <i>c<sub>2</sub></i> and <i>c<sub>3</sub></i>, if <tt>c<sub>1</sub> = c<sub>2</sub></tt> &isin; <i>&Phi;</i> and <tt>c<sub>2</sub> = c<sub>3</sub></tt> &isin; <i>&Phi;</i>, then <tt>c<sub>1</sub> = c<sub>3</sub></tt> &isin; <i>&Phi;</i>;
</li><li> for all triple of constants <i>c<sub>1</sub>, c<sub>2</sub></i>, <i>c<sub>3</sub></i>, if <tt>c<sub>1</sub>##c<sub>2</sub></tt>&nbsp;&isin;&nbsp;<i>&Phi;</i> and <tt>c<sub>2</sub>##c<sub>3</sub></tt>&nbsp;&isin;&nbsp;<i>&Phi;</i>, then <tt>c<sub>1</sub>##c<sub>3</sub></tt>&nbsp;&isin;&nbsp;<i>&Phi;</i>.
</li></ul>
<p>We say that <i>w<sub>&Phi;</sub></i> is <i>represented</i> by <i>&Phi;</i>; or, equivalently, by the conjunction of all the ground atomic formulas in <i>&Phi;</i>. &nbsp;&nbsp;☐
</p><p>Each ground atomic formula in <i>&Phi;</i> represents a single <b>fact</b>, and, often, the ground atomic formulas, themselves, are called <i>facts</i>, as well. Notice that the restriction that <i>&Phi;</i> can contain only single slot frames, in the definition of a <a href="#def-state" title="">state of the fact base</a> is not a limitation: given the definition of a <a href="#def-matching-substitution" title="">matching substitution</a>, a frame with multiple slots is only syntactic shorthand for the semantically equivalent conjunction of single slot frames.
</p><p><span class="anchor" id="def-condition-satisfaction"></span>
<b>Definition (Condition satisfaction).</b> A RIF-PRD condition formula <tt>&psi;</tt> is <i><b>satisfied</b></i> in a state of the fact base, <i>w</i>, if and only if <i>w</i> is represented by a set of ground atomic formulas <i>&Phi;</i>, and there is a ground substitution <i>&sigma;</i> that matches <i>&psi;</i> to <i>&Phi;</i>. &nbsp;&nbsp;☐
</p><p>Alternative, but equivalent, definitions of a state of the fact base and of the satisfaction of a condition are given in the <a href="#appendix-model-theory" title="">appendix Model theoretic semantics of RIF-PRD condition formulas</a>: they provide the formal link between the model theory of RIF-PRD condition formulas and the operational semantics of RIF-PRD documents.
</p><p><span class="anchor" id="sec-actions"></span>
</p>
<a id="Actions" name="Actions"></a><h2> <span class="mw-headline">3  Actions </span></h2>
<p>This section specifies the syntax and semantics of the RIF-PRD <i>action</i> language. The conclusion of a production rule is often called the <i>action</i> part, the <i>then</i> part, or the <i>right-hand side</i>, or <i>RHS</i>. 
</p><p>The RIF-PRD action language is used to add, delete and modify facts in the fact base.
As a rule interchange format, RIF-PRD does not make any assumption regarding the nature of the data sources that the producer or the consumer of a RIF-PRD document uses (e.g. a rule engine's working memory, an external data base, etc). As a consequence, the syntax of the actions that RIF-PRD supports are defined with respect to the RIF-PRD condition formulas that represent the facts that the actions affect.
In the same way, the semantics of the actions is specified in terms of how their execution affects the evaluation of rule conditions.
</p><p><span class="anchor" id="sec-actions-abstract-syntax"></span> 
</p>
<a id="Abstract_syntax_2" name="Abstract_syntax_2"></a><h3> <span class="mw-headline">3.1  Abstract syntax </span></h3>
<p>The alphabet of the RIF-PRD action language includes symbols to denote:
</p>
<ul><li> the assertion of a fact represented by a positional atom, a frame, or a membership atomic formula,
</li><li> the retraction of a fact represented by a positional atom or a frame,
</li><li> the retraction of all the facts about the values of a given slot of a given frame object,
</li><li> the addition of a new frame object,
</li><li> the removal of a frame object and the retraction of all the facts about it, represented by the corresponding  frame and class membership atomic formulas,
</li><li> the replacement of all the values of an object's attribute by a single, new value,
</li><li> the execution of an externally defined action, and
</li><li> a sequence of these actions, including the declaration of local variables and a mechanism to bind a local variable to a frame slot value or a new frame object.
</li></ul>
<p><span class="anchor" id="sec-atomic-actions"></span> 
</p>
<a id="Actions_2" name="Actions_2"></a><h4> <span class="mw-headline">3.1.1  Actions </span></h4>
<p>The RIF-PRD action language includes constructs for actions that are atomic, from a transactional point of view, and constructs that represent compounds of atomic actions. Action constructs take constructs from the RIF-PRD condition language as their arguments.
</p><p><span class="anchor" id="def-atomic-action"></span> 
<b>Definition (Atomic action).</b> An <i><b>atomic action</b></i> is a construct that represents an atomic transaction. An atomic action can have several different forms and is defined as follows:
</p>
<ol><li> <i>Assert simple fact</i>: If <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">positional atom</a>, a single slot <a href="#def-prd-atomic-formula" title="">frame</a> or a <a href="#def-prd-atomic-formula" title="">membership atomic formula</a> in the RIF-PRD condition language, then <tt>Assert(&phi;)</tt> is an atomic action. <tt>&phi;</tt> is called the <i>target</i> of the action.
</li><li> <i>Retract simple fact</i>: If <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">positional atom</a> or a single slot <a href="#def-prd-atomic-formula" title="">frame</a> in the RIF-PRD condition language, then <tt>Retract(&phi;)</tt> is an atomic action. <tt>&phi;</tt> is called the <i>target</i> of the action.
</li><li> <i>Retract all slot values</i>: If <tt>o</tt> and <tt>s</tt> are terms in the RIF-PRD condition language, then <tt>Retract(o s)</tt> is an atomic action. The pair <tt>(o, s)</tt> is called the <i>target</i> of the action.
</li><li> <i>Retract object</i>: If <tt>t</tt> is a <a href="#def-bld-term" title="">term</a> in the RIF-PRD condition language, then <tt>Retract(t)</tt> is an atomic action. <tt>t</tt> is called the <i>target</i> of the action. 
</li><li> <i>Execute</i>: if <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">positional atom</a> in the RIF-PRD condition language, then <tt>Execute(&phi;)</tt> is an atomic action. <tt>&phi;</tt> is called the <i>target</i> of the action. &nbsp;&nbsp;☐
</li></ol>
<p><span class="anchor" id="def-compound-action"></span> 
<b>Definition (Compound action).</b> A <i><b>compound action</b></i> is a construct that can be replaced equivalently by a pre-defined, and fixed, sequence of atomic actions. In RIF-PRD, a compound action can have three different forms, defined as follows:
</p>
<ol><li> <i>Assert compound fact</i>: If <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">frame</a> with multiple slots:  <tt>&phi;</tt> = <tt>o[s<sub>1</sub>-&gt;v<sub>1</sub>...s<sub>n</sub>-&gt;v<sub>n</sub>]</tt>, <i>n &gt; 1</i>; then <tt>Assert(&phi;)</tt> is a compound action, defined by the sequence <tt>Assert(o[s<sub>1</sub>-&gt;v<sub>1</sub>]) ... Assert(o[s<sub>n</sub>-&gt;v<sub>n</sub>])</tt>. <tt>&phi;</tt> is called the <i>target</i> of the action.
</li><li> <i>Retract compound fact</i>: If <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">frame</a> with multiple slots:  <tt>&phi;</tt> = <tt>o[s<sub>1</sub>-&gt;v<sub>1</sub>...s<sub>n</sub>-&gt;v<sub>n</sub>]</tt>, <i>n &gt; 1</i>; then <tt>Retract(&phi;)</tt> is a compound action, defined by the sequence <tt>Retract(o[s<sub>1</sub>-&gt;v<sub>1</sub>]) ... Retract(o[s<sub>n</sub>-&gt;v<sub>n</sub>])</tt>. <tt>&phi;</tt> is called the <i>target</i> of the action.
</li><li> <i>Modify fact</i>: if <tt>&phi;</tt> is a <a href="#def-prd-atomic-formula" title="">frame</a> in the RIF-PRD condition language: <tt>&phi;</tt> = <tt>o[s<sub>1</sub>-&gt;v<sub>1</sub>...s<sub>n</sub>-&gt;v<sub>n</sub>]</tt>, <i>n &gt; 0</i>; then <tt>Modify(&phi;)</tt> is a compound action, defined by the sequence: <a href="#def-atomic-action" title=""><tt>Retract(o s<sub>1</sub>)</tt></a> ... <tt>Retract(o s<sub>n</sub>)</tt>, followed by <a href="#def-atomic-action" title=""><tt>Assert(&phi;)</tt></a>. <tt>&phi;</tt> is called the <i>target</i> of the action. &nbsp;&nbsp;☐
</li></ol>
<p><span class="anchor" id="def-simple-action"></span> 
<b>Definition (Action).</b> A <i><b>action</b></i> is either an <a href="#def-atomic-action" title="">atomic action</a> or a <a href="#def-compound-action" title="">compound action</a>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-ground-action"></span> 
<b>Definition (Ground action).</b> An action with target <tt>t</tt> is a <i><b>ground action</b></i> if and only if
</p>
<ul><li> <tt>t</tt> is an atomic formula and <i>Var</i>(<tt>t</tt>) = &empty;;
</li><li> or <tt>t = (o, s)</tt> is a pair of terms and <i>Var</i>(<tt>o</tt>) = <i>Var</i>(<tt>s</tt>) = &empty;.
</li></ul>
<p>&nbsp;&nbsp;☐
</p><p><span class="anchor" id="ex-31"></span>
</p>
<div class="example">
<p><b>Example 3.1.</b>
</p>
<ul><li> <tt>Assert(&nbsp;?customer[ex1:voucher-&gt;?voucher] )</tt> and <tt>Retract(&nbsp;?customer[ex1:voucher-&gt;?voucher] )</tt> denote two atomic actions with the frame <tt>?customer[ex1:voucher-&gt;?voucher]</tt> as their target,
</li><li> <tt>Retract(&nbsp;?customer ex1:voucher )</tt> denotes an atomic action with the pair of terms <tt>(?customer, ex1:voucher)</tt> as its target,
</li><li> <tt>Modify(?customer[ex1:voucher-&gt;?voucher])</tt> denotes a compound action with the frame <tt>?customer[ex1:voucher-&gt;?voucher]</tt> as its target. <tt>Modify(?customer[ex1:voucher-&gt;?voucher])</tt> can always be equivalently replaced by the sequence: <tt>Retract(&nbsp;?customer ex1:voucher )</tt> then <tt>Assert(&nbsp;?customer[ex1:voucher-&gt;?voucher] )</tt>;
</li><li> <tt>Retract(&nbsp;?voucher )</tt> denotes an atomic action whose target is the individual bound to the variable <tt>?voucher</tt>,
</li><li> <tt>Execute( <a href="#sec-act-print" title="">act:print</a>("Hello, world!") )</tt> denotes an atomic action whose target is the externally defined action <tt>act:print</tt>. &nbsp;&nbsp;☐
</li></ul>
</div>
<p><span class="anchor" id="sec-action-blocks"></span>
</p>
<a id="Action_blocks" name="Action_blocks"></a><h4> <span class="mw-headline">3.1.2  Action blocks </span></h4>
<p>The <i>action block</i> is the top level construct to represent the conclusions of RIF-PRD rules. An action block contains a non-empty sequence of <a href="#def-simple-action" title="">actions</a>. It may also include <i>action variable declarations</i>.
</p><p>The <i>action variable declaration</i> construct is used to declare variables that are local to the action block, called <i>action variables</i>, and to assign them a value within the action block.
</p><p><span class="anchor" id="def-action-variable-declaration"></span> 
<b>Definition (Action variable declaration).</b> An <i><b>action variable declaration</b></i> is a pair, <i>(v p)</i> made of an <i>action variable</i>, <i>v</i>, and an <i>action variable binding</i> (or, simply, <i>binding</i>), <i>p</i>, where <i>p</i> has one of two forms:
</p>
<ol><li> <i>frame object declaration</i>: if the action variable, <i>v</i>, is to be assigned the identifier of a new frame, then the action variable binding is a <i>frame object declaration</i>: <tt>New()</tt>. In that case, the notation for the action variable declaration is: <tt>(?o&nbsp;New())</tt>;
</li><li> <i>frame slot value</i>: if the action variable, <i>v</i>, is to be assigned the value of a slot of a ground frame, then the action variable binding is a frame: <i>p</i>&nbsp;=&nbsp;<tt>o[s-&gt;</tt><i>v</i><tt>]</tt>, where <tt>o</tt> is a term that represents the identifier of the ground frame and <tt>s</tt> is a term that represents the name of the slot. The associated notation is: <tt>(?value&nbsp;o[s-&gt;?value])</tt>. &nbsp;&nbsp;☐
</li></ol>
<p><span class="anchor" id="def-action-block"></span>
<b>Definition (Action block).</b> If <tt>(v<sub>1</sub> p<sub>1</sub>), ..., (v<sub>n</sub> p<sub>n</sub>)</tt>, <i>n &ge; 0</i>, are  action variable declarations, and if <tt>a<sub>1</sub>, ..., a<sub>m</sub></tt>, <i>m &ge; 1</i>, are <a href="#def-simple-action" title="">actions</a>, then <tt>Do((v<sub>1</sub>&nbsp;p<sub>1</sub>)&nbsp;...&nbsp;(v<sub>n</sub>&nbsp;p<sub>n</sub>)&nbsp;a<sub>1</sub>&nbsp;...&nbsp;a<sub>m</sub>)</tt> denotes an <b>action block</b>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="ex-32"></span>
</p>
<div class="example">
<p><b>Example 3.2.</b> In the following action block, a local variable <tt>?oldValue</tt> is bound to a value of the attribute <tt>value</tt> of the object bound to the variable <tt>?shoppingCart</tt>. The <tt>?oldValue</tt> is then used to compute a new value, and the <tt>Modify</tt> action is used to overwrite the old value with the new value in the fact base:
</p>
<pre>Do( (?oldValue&nbsp;?shoppingCart[ex1:value-&gt;?oldValue])
    Modify(&nbsp;?shoppingCart[ex1:value-&gt;func:numeric-multiply(?oldValue 0.90)] ) )
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-well-formed-action-blocks"></span>
</p>
<a id="Well-formed_action_blocks" name="Well-formed_action_blocks"></a><h4> <span class="mw-headline">3.1.3  Well-formed action blocks </span></h4>
<p>Not all action blocks are well-formed in RIF-PRD:
</p>
<ul><li> one and only one action variable binding can assign a value to each action variable, and
</li><li> the assertion of a membership atomic formula is meaningful only if it is about a frame object that is created in the same action block.
</li></ul>
<p>The notion of well-formedness, already <a href="#def-bld-wff" title="">defined for condition formulas</a>, is extended to actions, action variable declarations and action blocks.
</p><p><span class="anchor" id="def-wf-atomic-action"></span> 
<b>Definition (Well-formed action).</b> An <a href="#def-simple-action" title="">action</a> <tt>&alpha;</tt> is <i><b>well-formed</b></i> if and only if one of the following is true:
</p>
<ul><li> <tt>&alpha;</tt> is an <tt>Assert</tt> and its target is a well-formed atom, a well-formed frame or a well-formed membership atomic formula,
</li><li> <tt>&alpha;</tt> is a <tt>Retract</tt> with one single argument and its target is a well-formed term or a well-formed atom or a well-formed frame atomic formula,
</li><li> <tt>&alpha;</tt> is a <tt>Retract</tt> with two arguments: <tt>o</tt> and <tt>s</tt>, and both are well-formed terms,
</li><li> <tt>&alpha;</tt> is a <tt>Modify</tt> and its target is a well-formed frame, or
</li><li> <tt>&alpha;</tt> is an <tt>Execute</tt> and its content is an instance of the coherent set of external schemas (Section Schemas for Externally Defined Terms in RIF data types and builtins [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) associated with the RIF-PRD language (section <a href="#sec-builtins" title="">Built-in functions, predicates and actions</a>). &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-wf-action-var-decl"></span> 
<b>Definition (Well-formed action variable declaration).</b> An action variable declaration <tt>(?v</tt> <i>p</i><tt>)</tt> is <i><b>well-formed</b></i> if and only if one of the following is true:
</p>
<ul><li> the action variable binding, <i>p</i>, is the declaration of a new frame object: <i>p</i>&nbsp;=&nbsp;<tt>New()</tt>, or
</li><li> the action variable binding, <i>p</i>, is a well formed frame atomic formula, <i>p</i>&nbsp;=&nbsp;<tt>o[a<sub>1</sub>-&gt;t<sub>1</sub>...a<sub>n</sub>-&gt;t<sub>n</sub>]</tt>,&nbsp;<i>n&nbsp;&ge;&nbsp;1</i>, and the action variable, <tt>v</tt> occurs in the position of a slot value, and nowhere else, that is: <tt>v</tt>&nbsp;&isin;&nbsp;{<tt>t<sub>1</sub>&nbsp;...&nbsp;t<sub>n</sub></tt>} and <tt>v</tt>&nbsp;&notin;&nbsp;<i>Var(o)&nbsp;&cup;&nbsp;Var(<tt>a<sub>1</sub></tt>)&nbsp;&cup;&nbsp;...&nbsp;&cup;&nbsp;Var(<tt>a<sub>n</sub></tt>)</i> and &forall; <tt>t<sub>i</sub></tt>, either <i>v</i>&nbsp;=&nbsp;<tt>t<sub>i</sub></tt> or <i>v</i>&nbsp;&notin;&nbsp;<i>Var(</i><tt>t<sub>i</sub></tt><i>)</i>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-free_var_action"></span> 
For the definition of a well-formed action block, the function <i>Var(f)</i>, that has been <a href="#def-free_var_base" title="">defined for condition formulas</a>, is extended to actions and frame object declarations as follows:
</p>
<ul><li> if <i>f</i> is an action with target <i>t</i> and <i>t</i> is an atomic formula, then <i>Var(f) = Var(t)</i>;
</li><li> if <i>f</i> is an action with target <i>t</i> and <i>t</i> is a pair, <i>(o, s)</i> of terms, then <i>Var(f) = Var(o) &cup; Var(s)</i>;
</li><li> if <i>f</i> is a frame object declaration, <tt>New()</tt>, then <i>Var(f) = &empty;</i>.
</li></ul>
<p><span class="anchor" id="def-wf-action-block"></span> 
<b>Definition (Well-formed action block).</b>  An action block is <i><b>well-formed</b></i> if and only if all of the following are true:
</p>
<ul><li> all the action variable declarations, if any, are well-formed,
</li><li> each action variable, if any, is assigned a value by one and only one action variable binding, that is: if <i>b<sub>1</sub></i> = <tt>(v<sub>1</sub>&nbsp;p<sub>1</sub>)</tt> and <i>b<sub>2</sub></i> = <tt>(v<sub>2</sub>&nbsp;p<sub>2</sub>)</tt> are two action variable declarations in the action block with different bindings: <i><tt>p<sub>1</sub></tt>&nbsp;&ne;&nbsp;<tt>p<sub>2</sub></tt></i>, then <i><tt>v<sub>1</sub></tt>&nbsp;&ne;&nbsp;<tt>v<sub>2</sub></tt></i>,
</li><li> in addition, the action variable declarations, if any, are partially ordered by the ordering defined as follows: if <i>b<sub>1</sub></i> = <tt>(v<sub>1</sub>&nbsp;p<sub>1</sub>)</tt> and <i>b<sub>2</sub></i> = <tt>(v<sub>2</sub>&nbsp;p<sub>2</sub>)</tt> are two action variable declarations in the action block, then <i>b<sub>1</sub>&nbsp;&lt;&nbsp;b<sub>2</sub></i> if and only if <tt>v<sub>1</sub></tt>&nbsp;&isin;&nbsp;<i>Var(</i><tt>p<sub>2</sub></tt><i>)</i>,
</li><li> all the actions in the action block are well-formed actions, and
</li><li> if an action in the action block asserts a membership atomic formula, <tt>Assert(t<sub>1</sub>&nbsp;#&nbsp;t<sub>2</sub>)</tt>, then the object term in the membership atomic formula, <tt>t<sub>1</sub></tt>, is an action variable that is declared in the action block and the action variable binding is a <a href="#def-action-variable-declaration" title="">frame object declaration</a>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-prd-action-lang"></span> 
<b>Definition (RIF-PRD action language).</b> The <i><b>RIF-PRD action language</b></i> consists of the set of all the well-formed action blocks. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="sec-operational-semantics-of-atomic-actions"></span>
</p>
<a id="Operational_semantics_of_atomic_actions" name="Operational_semantics_of_atomic_actions"></a><h3> <span class="mw-headline">3.2  Operational semantics of atomic actions </span></h3>
<p>This section specifies the semantics of the atomic actions in a RIF-PRD document.
</p><p>The effect of the ground atomic actions in the RIF-PRD action language is to modify the state of the fact base, in such a way that it changes the set of conditions that are satisfied before and after each atomic action is performed.
</p><p>As a consequence, the semantics of the ground atomic actions in the RIF-PRD action language determines a relation, called the <i>RIF-PRD transition relation</i>: &rarr;<sub><sub>RIF-PRD</sub></sub> &sube; <i>W</i> &times; <i>L</i> &times; <i>W</i>, where <i>W</i> denotes the set of all the states of the fact base, and where <i>L</i> denotes the set of all the ground atomic actions in the RIF-PRD action language.
</p><p>The semantics of a compound action follows directly from the semantics of the atomic actions that compose it.
</p><p>Individual states of the fact base are represented by sets of ground atomic formulas (Section <a href="#sec-satisfaction-of-condition" title="">Satisfaction of a condition</a>). In the following, the operational semantics of RIF-PRD actions, rules, and rule sets is specified by describing the changes they induce in the fact base.
</p><p><span class="anchor" id="def-rif-prd-transition-relation"></span> 
<b>Definition (RIF-PRD transition relation).</b> The semantics of RIF-PRD atomic actions is specified by the <b>transition relation &rarr;<sub><sub>RIF-PRD</sub></sub></b> &sube; <i>W</i> &times; <i>L</i> &times; <i>W</i>. <i>(w, <tt>&alpha;</tt>, w') &isin;  &rarr;<sub><sub>RIF-PRD</sub></sub></i> if and only if <i>w</i> &isin; <i>W</i>, <i>w' </i>&isin; <i>W</i>, <tt>&alpha;</tt> is a ground atomic action, and one of the following is true, where <i>&Phi;</i> is a set of ground atomic formulas that represents <i>w</i> and <i>&Phi;'</i> is a set of ground atomic formulas that represent <i>w'</i>:
</p>
<ol><li> <tt>&alpha;</tt> is <tt>Assert(&phi;)</tt>, where &phi; is a ground atomic formula, and <i>&Phi;'&nbsp;=&nbsp;&Phi;&nbsp;&cup;&nbsp;{&phi;}</i>;
</li><li> <tt>&alpha;</tt> is <tt>Retract(&phi;)</tt>, where &phi; is a ground atomic formula, and <i>&Phi;'&nbsp;=&nbsp;&Phi;&nbsp;\&nbsp;{&phi;}</i>;
</li><li> <tt>&alpha;</tt> is <tt>Retract(o s)</tt>, where <tt>o</tt> and <tt>s</tt> are constants, and <i>&Phi;'&nbsp;=&nbsp;(&Phi;&nbsp;\&nbsp;{<tt>o[s-&gt;v]</tt>&nbsp;| for all the values of <tt>v</tt>});</i>
</li><li> <tt>&alpha;</tt> is <tt>Retract(o)</tt>, where <tt>o</tt> is a constant, and <i>&Phi;'&nbsp;=&nbsp;&Phi;&nbsp;\&nbsp;{<tt>o[s-&gt;v]</tt>&nbsp;| for all the values of terms <tt>s</tt> and <tt>v</tt>}&nbsp;-&nbsp;{<tt>o#c</tt>&nbsp;| for all the values of term <tt>c</tt>}</i>;
</li><li> <tt>&alpha;</tt> is <tt>Execute(&phi;)</tt>, where &phi; is a ground atomic builtin action, and <i>&Phi;'&nbsp;=&nbsp;&Phi;</i>. &nbsp;&nbsp;☐
</li></ol>
<p>Rule 1 says that all the atomic condition formulas that were satisfied before an assertion will be satisfied after, and that, in addition, the atomic condition formulas that are satisfied by the asserted ground formula will be satisfied after the assertion. No other atomic condition formula will be satisfied after the execution of the action.
</p><p>Rule 2 says that all the atomic condition formulas that were satisfied before a retraction will be satisfied after, except if they are satisfied only by the retracted fact. No other atomic condition formula will be satisfied after the execution of the action.
</p><p>Rule 3 says that all the condition formulas that were satisfied before the retraction of all the values of a given slot of a given object will be satisfied after, except if they are satisfied only by one of the frame formulas about the object and the slot that are the target of the action, or a conjunction of such formulas. No other condition formula will be satisfied after the execution of the action.
</p><p>Rule 4 says that all the condition formulas that were satisfied before the removal of a frame object will be satisfied after, except if they are satisfied only by one of the frame or membership formulas about the removed object or a conjunction of such formulas. No other condition formula will be satisfied after the execution of the action.
</p><p>Rule 5 says that all the condition formulas that were satisfied before the execution of an action builtin will be satisfied after. No other condition formula will be satisfied after the execution of the action.
</p><p><span class="anchor" id="ex-33"></span>
</p>
<div class="example">
<p><b>Example 3.3.</b> Assume an initial state of the fact base that is represented by the following set, <i>w<sub>0</sub></i>, of ground atomic formulas, where <tt>_c1</tt>, <tt>_v1</tt> and <tt>_s1</tt> denote individuals and where <tt>ex1:Customer</tt>, <tt>ex1:Voucher</tt> and <tt>ex1:ShoppingCart</tt> represent classes:
</p>
<div style="margin-left: 3em;">
<p>Initial state:
</p>
<ul><li> <i>w<sub>0</sub> = {<tt>_c1#ex1:Customer _v1#ex1:Voucher _s1#ex1:ShoppingCart _c1[ex1:voucher-&gt;_v1] _c1[ex1:shoppingCart-&gt;_s1] _v1[ex1:value-&gt;5] _s1[ex1:value-&gt;500]</tt>}</i>
</li></ul>
</div>
<ol><li> <tt>Assert( _c1[ex1:status-&gt;"New"] )</tt> denotes an atomic action that adds to the fact base, a fact that is represented by the ground atomic formula: <tt>_c1[ex1:status-&gt;"New"]</tt>. After the action is executed, the new state of the fact base is represented by
<ul><li> <i>w<sub>1</sub> = {<tt>_c1#ex1:Customer _v1#ex1:Voucher _s1#ex1:ShoppingCart _c1[ex1:voucher-&gt;_v1] _c1[ex1:shoppingCart-&gt;_s1] _v1[ex1:value-&gt;5] _s1[ex1:value-&gt;500] _c1[ex1:status-&gt;"New"]</tt>}</i>
</li></ul>
</li><li> <tt>Retract( _c1[ex1:voucher-&gt;_v1] )</tt> denotes an atomic action that removes from the fact base, the fact that is represented by the ground atomic formula <tt>_c1[ex1:voucher-&gt;_v1]</tt>. After the action, the new state of the fact base is represenetd by:
<ul><li> <i>w<sub>2</sub> = {<tt>_c1#ex1:Customer _v1#ex1:Voucher _s1#ex1:ShoppingCart _c1[ex1:shoppingCart-&gt;_s1] _v1[ex1:value-&gt;5] _s1[ex1:value-&gt;500] _c1[ex1:status-&gt;"New"]</tt>}</i>
</li></ul>
</li><li> <tt>Retract( _v1 )</tt> denotes an atomic action that removes the individual denoted by the constant <tt>_v1</tt> from the fact base. All the class membership and the object-attribute-value facts where <tt>_v1</tt> is the object are removed. After the action, the new state of the fact base is represenetd by:
<ul><li> <i>w<sub>3</sub> = {<tt>_c1#ex1:Customer _s1#ex1:ShoppingCart _c1[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;500] _c1[ex1:status-&gt;"New"]</tt>}</i>
</li></ul>
</li><li> <tt>Retract( _s1 ex1:value )</tt> denotes an atomic action that removes all the object-attribute-value facts that assign a <tt>ex1:value</tt> to the <tt>ex1:ShoppingCart</tt> <tt>_s1</tt>. After the action, the new state of the fact base is represented by
<ul><li> <i>w<sub>4</sub> = {<tt>_c1#ex1:Customer _s1#ex1:ShoppingCart _c1[ex1:shoppingCart-&gt;_s1] _c1[ex1:status-&gt;"New"]</tt>}</i>
</li></ul>
</li><li> <tt>Assert( _s1[ex1:value-&gt;450] ) adds in the fact base_the single fact that is represented by the ground frame: &lt;tt&gt;_s1[ex1:value-&gt;450]</tt>. After the action, the new state of the fact base is represented by:
<ul><li> <i>w<sub>5</sub> = {<tt>_c1#ex1:Customer _s1#ex1:ShoppingCart _c1[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;450] _c1[ex1:status-&gt;"New"]</tt>}</i>
</li></ul>
</li><li> <tt>Execute( <a href="#sec-act-print" title="">act:print</a>(func:concat("New customer: " _c1)) )</tt> denotes an action that does not impact the state of the fact base, but that prints a string to an output stream. After the action, the new state of the fact base is represented by:
<ul><li> <i>w<sub>6</sub> = w<sub>5</sub> = {<tt>_c1#ex1:Customer _s1#ex1:ShoppingCart _c1[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;450] _c1[ex1:status-&gt;"New"]</tt>}</i> 
</li></ul>
</li></ol>
<p>Notice that steps 4 and 5 can be equivalently replaced by the single compound action:
</p>
<ul><li> <tt>Modify( _s1[ex1:value-&gt;450] )</tt>, which denotes an action that replaces all the object-attribute-value facts that assign a <tt>ex1:value</tt> to the <tt>ex1:ShoppingCart</tt> <tt>_s1</tt> by the single fact that is represented by the ground frame: <tt>_s1[ex1:value-&gt;450]</tt>.
</li></ul>
<p>&nbsp;&nbsp;☐
</p>
</div>
<p><span class="anchor" id="sec-production-rules-and-rulesets"></span>
</p>
<a id="Production_rules_and_rule_sets" name="Production_rules_and_rule_sets"></a><h2> <span class="mw-headline">4  Production rules and rule sets </span></h2>
<p>This section specifies the syntax and semantics of RIF-PRD rules and rule sets.
</p><p><span class="anchor" id="sec-rules-abstract-syntax"></span>
</p>
<a id="Abstract_syntax_3" name="Abstract_syntax_3"></a><h3> <span class="mw-headline">4.1  Abstract syntax </span></h3>
<p>The alphabet of the RIF-PRD rule language includes the alphabets of the <a href="#sec-conditions-abstract-syntax" title="">RIF-PRD condition language</a> and the <a href="#sec-actions-abstract-syntax" title="">RIF-PRD action language</a> and adds symbols for:
</p>
<ul><li> combining a condition and an action block into a rule,
</li><li> declaring (some) variables that are free in a rule <i>R</i>, specifying their bindings, and combining them with <i>R</i> into a new rule <i>R'</i> (with fewer free variables),
</li><li> grouping rules and associating specific operational semantics to groups of rules.
</li></ul>
<p><span class="anchor" id="sec-rules"></span> 
</p>
<a id="Rules" name="Rules"></a><h4> <span class="mw-headline">4.1.1  Rules </span></h4>
<p><span class="anchor" id="def-rule"></span>
<b>Definition (Rule).</b> A <i><b>rule</b></i> can be one of:
</p>
<ul><li> an <i>unconditional action block</i>,
</li><li> a <i>conditional action block</i>: if <tt>condition</tt> is a formula in the RIF-PRD condition language, and if <tt>action</tt> is a well-formed action block, then <tt>If&nbsp;condition,&nbsp;Then&nbsp;action</tt> is a rule,
</li><li> a <i>rule with variable declaration</i>: if <tt>?v<sub>1</sub> ...&nbsp;?v<sub>n</sub></tt>, <i>n &ge; 1</i>, are variables; <tt>p<sub>1</sub> ... p<sub>m</sub></tt>, <i>m &ge; 1</i>, are condition formulas (called <i>patterns</i>), and <tt>rule</tt> is a rule, then <tt>Forall&nbsp;?v<sub>1</sub>...?v<sub>n</sub>&nbsp;such&nbsp;that&nbsp;(p<sub>1</sub>...p<sub>m</sub>)&nbsp;(rule)</tt> is a rule. &nbsp;&nbsp;☐
</li></ul>
<p><br />
<span class="anchor" id="ex-41"></span>
</p>
<div class="example">
<p><b>Example 4.1.</b> The <i>Gold rule</i>, from the <a href="#sec-running-example" title="">running example</a>: <i>A "Silver" customer with a shopping cart worth at least $2,000 is awarded the "Gold" status</i>, can be represented using the following rule with variable declaration:
</p>
<pre>Forall&nbsp;?customer such that And(&nbsp;?customer # ex1:Customer
                               &nbsp;?customer[ex1:status-&gt;"Silver"] )
  (Forall&nbsp;?shoppingCart such that And(&nbsp;?shoppingCart # ex1:ShoppingCart
                                     &nbsp;?customer[ex1:shoppingCart-&gt;?shoppingCart] )
     (If Exists&nbsp;?value (And(&nbsp;?shoppingCart[ex1:value-&gt;?value]
                             pred:numeric-greater-than-or-equal(?value 2000))
      Then Do( Modify(&nbsp;?customer[ex1:status-&gt;"Gold"] ) ) )
</pre>
<p>☐
</p>
</div>
<p>The function <i>Var(f)</i>, that has been <a href="#def-free_var_base" title="">defined for condition formulas</a> and <a href="#def-free_var_action" title="">extended to actions</a>, is further extended to rules, as follows:
</p>
<ul>
<li> if <i>f</i> is an action block that declares action variables <tt>?v<sub>1</sub> ...&nbsp;?v<sub>n</sub></tt>, <i>n &ge; 0</i>, and that contains actions <tt>a<sub>1</sub>&nbsp;...&nbsp;a<sub>m</sub></tt>, <i>m &ge; 1</i>, then <i>Var(f) = <big>&cup;</big><sub>1 &le; i &le; m</sub> Var(<tt>a<sub>i</sub></tt>) \ {<tt>?v<sub>1</sub> ...&nbsp;?v<sub>n</sub></tt>}</i>;</li>
<li> if <i>f</i> is a conditional action block where <tt>c</tt> is the condition formula and <tt>a</tt> is the action block, then <i>Var(f) = Var(c) &cup; Var(a)</i>;</li>
<li> if <i>f</i> is a quantified rule where <tt>?v<sub>1</sub> ...&nbsp;?v<sub>n</sub></tt>, <i>n &gt; 0</i>, are the declared variables; <tt>p<sub>1</sub> ... p<sub>m</sub></tt>, <i>m &ge; 0</i>, are the patterns, and <tt>r</tt> is the rule, then <i>Var(f) = (Var(<tt>r</tt>) &cup; Var(<tt>p<sub>1</sub></tt>) &cup; ... &cup; Var(<tt>p<sub>m</sub></tt>)) \ {<tt>?v<sub>1</sub> ...&nbsp;?v<sub>n</sub></tt>}</i>.</li>
</ul>
<p><span class="anchor" id="sec-groups"></span>
</p>
<a id="Groups" name="Groups"></a><h4> <span class="mw-headline">4.1.2  Groups </span></h4>
<p>As was already mentioned in the <a href="#sec-overview" title="">Overview</a>, production rules have an operational semantics that can be described in terms of matching rules against states of the fact base, selecting rule instances to be executed, and executing rule instances' actions to transition to new states of the fact base.
</p><p>When production rules are interchanged, the intended rule instance selection strategy, often called the <i>conflict resolution strategy</i>, needs to be interchanged along with the rules. In RIF-PRD, the <i>group</i>  construct is used to group sets of rules and to associate them with a conflict resolution strategy. Many production rule systems use priorities associated with rules as part of their conflict resolution strategy. In RIF-PRD, the group is also used to carry the priority information that may be associated with the interchanged rules.
</p><p><span class="anchor" id="def-group"></span> 
<b>Definition (Group).</b> A <i><b>group</b></i> consists of a, possibly empty, set of rules and groups, associated with a conflict resolution strategy and, a priority. If <tt>strategy</tt> is an IRI that identifies a conflict resolution strategy, if <tt>priority</tt> is an integer, and if each <tt>rg<sub>j</sub></tt>, <i>0 &le; j &le; n</i>, is either a rule or a group, then any of the following represents a group:
</p>
<ul><li> <tt>Group (rg<sub>0</sub> ... rg<sub>n</sub>)</tt>, <i>n &ge; 0</i>;
</li><li> <tt>Group strategy (rg<sub>0</sub> ... rg<sub>n</sub>)</tt>, <i>n &ge; 0</i>;
</li><li> <tt>Group priority (rg<sub>0</sub> ... rg<sub>n</sub>)</tt>, <i>n &ge; 0</i>;
</li><li> <tt>Group strategy priority (rg<sub>0</sub> ... rg<sub>n</sub>)</tt>, <i>n &ge; 0</i>. 
</li></ul>
<p>If a conflict resolution strategy is not explicitly attached to a group, the strategy defaults to <tt>rif:forwardChaining</tt> (specified below, in <a href="#sec-conflict-resolution" title="">section Conflict resolution</a>). &nbsp;&nbsp;☐
</p><p><span class="anchor" id="sec-safeness"></span>
</p>
<a id="Safeness" name="Safeness"></a><h4> <span class="mw-headline">4.1.3  Safeness </span></h4>
<p>The definitions in this section are unchanged from the definitions in the section Safeness in [<a href="#ref-core" title="">RIF-Core</a>], except for the definition of <i><a href="#def-safe-rule" title="">RIF-PRD rule safeness</a></i>, that is extended from the definition of <i>RIF-Core rule safeness</i>. The definitions are reproduced for the reader's convenience.
</p><p>Intuitively, safeness of rules guarantees that all the variables in a rule can be bound, using pattern matching only, before they are used, in a test or in an action.
</p><p>To define safeness, we need to define, first, the notion of <i>binding patterns</i> for externally defined functions and predicates, as well as under what conditions variables are considered <i>bound</i>.
</p><p><b>Definition (Binding pattern).</b> (from [<a href="#ref-core" title="">RIF-Core</a>]) <i><b>Binding patterns</b></i> for externally defined functions and predicates are lists of the form (<tt>p<sub>1</sub></tt>, <tt>...</tt>, <tt>p<sub>n</sub></tt>), such that <tt>p<sub>i</sub></tt>=<tt>b</tt> or <tt>p<sub>i</sub></tt>=<tt>u</tt>, for <tt>1 &le; i &le; n</tt>: <tt>b</tt> stands for a "bound" and <tt>u</tt> stands for an "unbound" argument. &nbsp;&nbsp;☐
</p><p>Each external function or predicate has an associated list of <i><b>valid binding patterns</b></i>.  We define here the binding patterns valid for the functions and predicates defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. 
</p><p>Every function or predicate <tt>f</tt> defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] has a valid binding pattern for each of its schemas with only the symbol <tt>b</tt> such that its length is the number of arguments in the schema. In addition,
</p>
<ul><li> the external predicate <tt>pred:iri-string</tt> has the valid binding patterns (<tt>b</tt>, <tt>u</tt>) and (<tt>u</tt>, <tt>b</tt>) and
</li><li> the external predicate <tt>pred:list-contains</tt> has the valid binding pattern (<tt>b</tt>, <tt>u</tt>).
</li></ul>
<p>The functions and predicates defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] have no other valid binding patterns.
</p><p>To keep the definitions concise and intuitive, boundedness and safeness are defined, in [<a href="#ref-core" title="">RIF-Core</a>], for condition formulas in disjunctive normal form, that can be existentially quantified themselves, but that contain, otherwise, no existential sub-formula. The definitions apply to any valid RIF-Core condition formula, because they can always, in principle, be put in that form, by applying the following syntactic transforms, in sequence:
</p>
<ol><li> if <i>f</i> contains existential sub-formulas, all the quantified variables are renamed, if necessary, and given a name that is unique in <i>f</i>, and the scope of the quantifiers is extended to <i>f</i>. Assume, for instance, that <i>f</i> has an existential sub-formula, <i>sf = <tt>Exists v<sub>1</sub>...v<sub>n</sub> (sf')</tt>, n &ge; 1</i>, such that the names <i><tt>v<sub>1</sub>...v<sub>n</sub></tt></i> do not occur in <i>f</i> outside of <i>sf</i>. After the transform, <i>f</i> becomes <i><tt>Exists v<sub>1</sub>...v<sub>n</sub> (f')</tt></i>, where <i>f' </i> is <i>f</i> with <i>sf</i> replaced by <i>sf' </i>. The transform is applied iteratively to all the existential sub-formulas in <i>f</i>;
</li><li> the (possibly existentially quantified) resulting formula is rewritten in disjunctive normal form ([<a href="#ref-mendelson97" title="">Mendelson97</a>], p. 30).
</li></ol>
<p>In RIF-PRD, the definitions apply to conditions formulas in the same form as in [<a href="#ref-core" title="">RIF-Core</a>], with the exception that, in the disjunctive normal form, negated sub-formulas can be atomic formulas or existential formulas: in the latter case, the existentially quantified formula must be, itself, in disjunctive normal form, and contain no further existential sub-formulas. The definitions apply to any valid RIF-PRD condition formula, because they can always, in principle, be put in that form, by applying the above syntactic transform, modified as follows to take negation into account:
</p>
<ul><li> if the condition formula under consideration, <i>f</i>, contains negative sub-formulas, existential formulas that occur inside a negated formula are handled as if they were atomic formulas, with respect to the two processing steps. Extending the scope of an existential quantifier beyond a negation would require its transformation into an universal quantifier, and universal formulas are not part of RIF-PRD condition language;
</li><li> in addition, the two pre-processing steps are applied, separately, to these existentially quantified formulas, to be able to determine the status of the existentially quantified variables with respect to boundedness.
</li></ul>
<p><b>Definition (Boundedness).</b> (from [<a href="#ref-core" title="">RIF-Core</a>]) An external term <tt>External(f(t<sub>1</sub>,...,t<sub>n</sub>))</tt> is <i><b>bound</b></i> in a condition formula, if and only if <tt>f</tt> has a valid binding pattern (<tt>p<sub>1</sub></tt>, <tt>...</tt>, <tt>p<sub>n</sub></tt>) and, for all <i>j, 1 &le; j &le; n</i>, such that <tt>p<sub>j</sub></tt>=<tt>b</tt>, <tt>t<sub>j</sub></tt> is bound in the formula.
</p><p>A variable, <i>v</i>, is <i><b>bound</b></i> in an atomic formula, <i>a</i>, if and only if
</p>
<ul><li> <i>a</i> is neither an equality nor an external predicate, and <i>v</i> occurs as an argument in <i>a</i>;
</li><li> or <i>v</i> is bound in the conjunctive formula <i>f = <tt>And(a)</tt></i>.
</li></ul>
<p>A variable, <i>v</i>, is <i><b>bound</b></i> in a conjunction formula, <i>f = <tt>And(c<sub>1</sub>...c<sub>n</sub>)</tt>, n&nbsp;&ge;&nbsp;1</i>, if and only if, either
</p>
<ul><li> <i>v</i> is bound in at least one of the conjuncts;
</li><li> or <i>v</i> occurs as the <i>j-th</i> argument in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an externally defined predicate, and the <i>j-th</i> position in a binding pattern that is associated with <i><tt>c<sub>i</sub></tt></i> is <tt>u</tt>, and all the arguments that occur, in <i><tt>c<sub>i</sub></tt></i>, in positions with value <i><tt>b</tt></i> in the same binding pattern are bound in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>;
</li><li> or <i>v</i> occurs in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an equality formula, and <i>v</i> occurs as the term on one side of the equality, and the term on the other side of the equality is bound in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>.
</li></ul>
<p>A variable, <i>v</i>, is <i><b>bound</b></i> in a disjunction formula, if and only if <i>v</i> is bound in every disjunct where it occurs;
</p><p>A variable, <i>v</i>, is <i><b>bound</b></i> in an existential formula, <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt>, <i>n &ge; 1</i>, if and only if <i>v</i> is bound in <i><tt>f'</tt></i>. &nbsp;&nbsp;☐
</p><p>Notice that the variables, <tt>v<sub>1</sub>,...,v<sub>n</sub></tt>, that are existentially quantified in an existential formula <i>f = <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt></i>, are bound in any formula, <i>F</i>, that contains <i>f</i> as a sub-formula, if and only if they are bound in <i>f</i>, since they do not exist outside of <i>f</i>.
</p><p><b>Definition (Variable safeness).</b> (from [<a href="#ref-core" title="">RIF-Core</a>]) A variable, <i>v</i>, is <i><b>safe</b></i> in a condition formula, <i>f</i>, if and only if
</p>
<ul><li> <i>f</i> is an atomic formula and <i>f</i> is not an equality formula in which both terms are  variables and <i>v</i> occurs in <i>f</i>;
</li><li> or <i>f</i> is a conjunction, , <i>f = <tt>And(c<sub>1</sub>...c<sub>n</sub>)</tt>, n&nbsp;&ge;&nbsp;1</i>, and <i>v</i> is safe in at least one conjunct in <i>f</i>, or <i>v</i> occurs in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an equality formula in which both terms are variables, and <i>v</i> occurs as the term on one side of the equality, and the variable on the other side of the equality is safe in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>;
</li><li> or <i>f</i> is a disjunction, and <i>v</i> is safe in every disjunct;
</li><li> or <i>f</i> is an existential formula, <i>f = <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt>, n &ge; 1</i>, and <i>v</i> is safe in <i>f' </i>. &nbsp;&nbsp;☐
</li></ul>
<p>Notice that the two definitions, above, are not extended for negation and, followingly, that an universally quantified (rule) variable is never bound or safe in a condition formula as a consequence of occurring in a negative formula. 
</p><p>The definition of <i>rule safeness</i> is replaced by the following one, that extends the one for RIF-Core rules.
</p><p><span class="anchor" id="def-safe-rule"></span>
<b>Definition (RIF-PRD rule safeness).</b> A RIF-PRD rule, <i>r</i>, is <i><b>safe</b></i> if and only if
</p>
<ul><li> <i>r</i> is an unconditional action block, and <i>Var(r) = &empty;</i>;
</li><li> or <i>r</i> is a conditional action block, <tt>If C Then A</tt>, and all the variables in <i>Var(A)</i> are safe in <i>C</i>, and all the variables in <i>Var(r)</i> are bound in <i>C</i>;
</li><li> or <i>r</i> is a rule with variable declaration, <tt>&forall; v<sub>1</sub>...v<sub>n</sub> such that p<sub>1</sub>...p<sub>m</sub> (r')</tt>, <i>n &ge; 1, m &ge; 0</i>, and either
<ul><li> <i>r' </i> is an unconditional action block, <tt>A</tt>, and the conditional action block <tt>If And(p<sub>1</sub>...p<sub>m</sub>) Then A</tt> is safe;
</li><li> or <i>r' </i> is a conditional action block, <tt>If C Then A</tt>, and the conditional action block <tt>If And(C p<sub>1</sub>...p<sub>m</sub>) Then A</tt> is safe;
</li><li> or <i>r' </i> is a rule with variable declaration, <tt>&forall; v'<sub>1</sub>...v'<sub>n'</sub> such that p'<sub>1</sub>...p'<sub>m'</sub> (r")</tt>, <i>n' &ge; 1, m' &ge; 0</i>, and the rule with variable declaration <tt>&forall;&nbsp;v<sub>1</sub>...v<sub>n</sub>&nbsp;v'<sub>1</sub>...v'<sub>n'</sub>&nbsp;such&nbsp;that&nbsp;p<sub>1</sub>...p<sub>m</sub>&nbsp;p'<sub>1</sub>...p'<sub>m'</sub>&nbsp;(r")</tt>, is safe. &nbsp;&nbsp;☐
</li></ul>
</li></ul>
<p><span class="anchor" id="def-safe-group"></span>
<b>Definition (Group safeness).</b> (from [<a href="#ref-core" title="">RIF-Core</a>]) A group, <tt>Group (s<sub>1</sub>...s<sub>n</sub>)</tt>, <i>n &ge; 0</i>, is <i><b>safe</b></i> if and only if
</p>
<ul><li> it is empty, that is, <i>n = 0</i>;
</li><li> or <i>s<sub>1</sub></i> and ... and <i>s<sub>n</sub></i> are safe. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="sec-well-formed-rules-and-groups"></span>
</p>
<a id="Well-formed_rules_and_groups" name="Well-formed_rules_and_groups"></a><h4> <span class="mw-headline">4.1.4  Well-formed rules and groups </span></h4>
<p>If <i>f</i> is a rule, <i>Var(f)</i> is the set of the free variables in <i>f</i>.
</p><p><span class="anchor" id="def-wf-rule"></span> 
<b>Definition (Well-formed rule).</b> A rule, <tt>r</tt>, is a <i><b>well-formed rule</b></i> if and only if either
</p>
<ul><li> <tt>r</tt> is an unconditional <a href="#def-wf-action-block" title="">well-formed action block</a>, <tt>a</tt>,
</li><li> or <tt>r</tt> is a conditional action block where the condition formula, <tt>c</tt>, is a <a href="#def-bld-wff" title="">well-formed condition formula</a>, and the action block, <tt>a</tt>, is a <a href="#def-wf-action-block" title="">well-formed action block</a>,
</li><li> or <tt>r</tt> is a quantified rule (with or without patterns), <tt>Forall V [such that P](r')</tt>, and
<ul><li> each of the patterns, <tt>p<sub>i</sub></tt>&nbsp;&isin;&nbsp;<tt>P = {p<sub>1</sub>,...,p<sub>n</sub>}</tt>, <i>n&nbsp;&ge;&nbsp;0</i>, is a <a href="#def-bld-wff" title="">well-formed condition formula</a>,
</li><li> and the quantified rule, <tt>r'</tt>, is a well-formed rule. &nbsp;&nbsp;☐
</li></ul>
</li></ul>
<p><span class="anchor" id="def-wf-group"></span> 
<b>Definition (Well-formed group).</b> A group is <i><b>well-formed group</b></i> if and only if it is <a href="#def-safe-group" title="">safe</a> and it contains only well-formed groups, <i>g<sub>1</sub>...g<sub>n</sub>, n&nbsp;&ge;&nbsp;0</i>, and well-formed rules, <i>r<sub>1</sub>...r<sub>m</sub>, m&nbsp;&ge;&nbsp;0</i>, such that <i>Var(r<sub>i</sub>)&nbsp;=&nbsp;&empty;</i> for all <i>i, 0&nbsp;&le;&nbsp;i&nbsp;&le;&nbsp;m</i>. &nbsp;&nbsp;☐
</p><p>The variables that are universally quantified in a rule are sometimes called <i>rule variables</i> in the remainder of this document, to distinguish them from the action variables and from the existentially quantified variables. The function <i>CVar</i>, that maps a rule to the set of its rule variables is defined as follows:
</p>
<ul><li> if <i>r</i> is a conditional or unconditional action block, <i>CVar(r) = &empty;</i>
</li><li> if <i>r</i> is a rule with variable declaration, <tt>Forall&nbsp;?v<sub>1</sub>...?v<sub>n</sub>&nbsp;(r')</tt>, <i>CVar(r) = CVar(r') &cup; {<tt>?v<sub>1</sub></tt>...<tt>?v<sub>n</sub></tt>}</i>.
</li></ul>
<p>The set of the well-formed groups contains all the production rule sets that can be meaningfully interchanged using RIF-PRD.
</p><p><span class="anchor" id="sec-operational-semantics-of-rules-and-rule-sets"></span>
</p>
<a id="Operational_semantics_of_rules_and_rule_sets" name="Operational_semantics_of_rules_and_rule_sets"></a><h3> <span class="mw-headline">4.2  Operational semantics of rules and rule sets </span></h3>
<a id="Motivation_and_example" name="Motivation_and_example"></a><h4> <span class="mw-headline">4.2.1  Motivation and example </span></h4>
<p>As mentioned in the <a href="#sec-overview" title="">Overview</a>, the description of a production rule system as a transition system is used to specify the semantics of production rules and rule sets interchanged using RIF-PRD.
</p><p>The intuition of describing a production rule system as a transition system is that, given a set of production rules <i>RS</i> and a fact base <i>w<sub>0</sub></i>, the rules in <i>RS</i> that are satisfied, in some sense, in <i>w<sub>0</sub></i> determine an action <i>a<sub>1</sub></i>, whose execution results in a new fact base <i>w<sub>1</sub></i>; the rules in <i>RS</i> that are satisfied in <i>w<sub>1</sub></i> determine an action <i>a<sub>2</sub></i> to execute in <i>w<sub>1</sub></i>, and so on, until the system reaches a final state and stops. The result is the fact base <i>w<sub>n</sub></i> when the system stops.
</p><p><span class="anchor" id="ref-ex42"></span>
</p>
<div class="example">
<p><b>Example 4.2.</b> The Rif Shop, Inc. is a rif-raf retail chain, with brick and mortar shops all over the world and virtual storefronts in many on-line shops. The Rif Shop, Inc. maintains its customer fidelity management policies in the form of production rule sets. The customer management department uses RIF-PRD to publish rule sets to all the shops and licensees so that everyone uses the latest version of the rules, even though several different rule engines are in use (in fact, some of the smallest shops actually run the rules by hand).
</p><p>Here is a small rule set that governs discounts and customer status updates at checkout time (to keep the example short, this is a subset of the rules described in the <a href="#sec-running-example" title="">running example</a>):
</p>
<pre>(* ex1:CheckoutRuleset *)
Group rif:forwardChaining (

  (* ex1:GoldRule *)
  Group 10 (
    Forall&nbsp;?customer such that (And(&nbsp;?customer # ex1:Customer
                                    &nbsp;?customer[ex1:status-&gt;"Silver"] ) )
      (Forall&nbsp;?shoppingCart such that (?customer[ex1:shoppingCart-&gt;?shoppingCart])
         (If Exists&nbsp;?value (And(&nbsp;?shoppingCart[ex1:value-&gt;?value]
                                 pred:numeric-greater-than-or-equal(?value 2000))
          Then Do( Modify(&nbsp;?customer[ex1:status-&gt;"Gold"] ) ) ) )

  (* ex1:DiscountRule *)
  Group (
    Forall&nbsp;?customer such that (And(&nbsp;?customer # ex1:Customer ) )
      (If Or (?customer[ex1:status-&gt;"Silver"]
             &nbsp;?customer[ex1:status-&gt;"Gold"] )
       Then Do( (?s&nbsp;?customer[ex1:shoppingCart-&gt;?s])
                (?v&nbsp;?s[ex1:value-&gt;?v])
                Modify(&nbsp;?s[ex1:value-&gt;func:numeric-multiply(?v 0.95)] ) ) ) )
</pre>
<p>To see how the rule set works, consider the case of a shop where the checkout processing of customer John is about to start. The initial state of the fact base can be represented as follows:
</p><p><i>w<sub>0</sub> = {<tt>_john#ex1:Customer _john[ex1:status-&gt;"Silver"] _s1#ex1:ShoppingCart _john[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;2000]</tt>}</i>
</p><p>When instantiated against <i>w<sub>0</sub></i>, the first pattern in the "Gold rule", <tt>And(&nbsp;?customer#ex1:Customer&nbsp;?customer[ex1:status-&gt;"Silver"]&nbsp;)</tt>, yields the single matching substitution: <i>{(_john/?customer)}</i>. The second pattern in the same rule also yields a single matching substitution: <i>{(_john/?customer)(_s1/?shoppingCart)}</i>, for which the existential condition is satisfied.
</p><p>Likewise, the instantiation of the "Discount rule" yields a single matching substitution that satisfies the condition: <i>{(_john/?customer)}</i>. The conflict set is:<br />{ex1:GoldRule/{(_john/?customer)(_s1/?shoppingCart)}, ex1:DiscountRule/{(_john/?customer)}}
</p><p>The instance <i>ex1:GoldRule/{(_john/?customer)(_s1/?shoppingCart)}</i> is selected because of its higher priority. The ground compound action: <tt>Modify(_john[ex1:status-&gt;"Gold"])</tt>, is executed, resulting in a new state of the fact base, represented as follows:
</p><p><i>w<sub>1</sub> = {<tt>_john#ex1:Customer _john[ex1:status-&gt;"Gold"] _s1#ex1:ShoppingCart _john[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;2000]</tt>}</i>
</p><p>In the next cycle, there is no substitution for the rule variable <tt>?customer</tt> that matches the pattern to the state of the fact base, and the only matching rule instance is: ex1:DiscountRule/{(_john/?customer)}, which is selected for execution. The action variables <tt>?s</tt> and <tt>?v</tt> are bound, based on the state of the fact base, to <tt>_s1</tt> and <tt>200</tt>, respectively, and the ground compound action, <tt>Modify(_s1[ex1:value-&gt;1900])</tt>, is executed, resulting in a new state of the fact base:
</p><p><i>w<sub>2</sub> = {<tt>_john#ex1:Customer _john[ex1:status-&gt;"Gold"] _s1#ex1:ShoppingCart _john[ex1:shoppingCart-&gt;_s1] _s1[ex1:value-&gt;1900]</tt>}</i>
</p><p>In <i>w<sub>2</sub></i>, the only matching rule instance is, again: ex1:DiscountRule/{(_john/?customer)}. However, that same instance has already been selected and the corresponding action has been executed. Nothing has changed in the state of the fact base that would justify that the rule instance be selected gain. The principle of refraction applies, and the rule instance is removed from consideration.
</p><p>This leaves the conflict set empty, and the system, having detected a final state, stops.
</p><p>The result of the execution of the system is <i>w<sub>2</sub></i>. &nbsp;&nbsp;☐
</p>
</div>
<p><span class="anchor" id="sec-rules-normalization"></span>
</p>
<a id="Rules_normalization" name="Rules_normalization"></a><h4> <span class="mw-headline">4.2.2  Rules normalization </span></h4>
<p>A rule, <i>R</i>, whose condition, rewritten in disjunctive normal form as described in <a href="#sec-safeness" title="">section Safeness</a>, consists of more than one disjunct, is equivalent, logically as well as operationally, to a set (or conjunction) of rules that have, all, the same conclusion as <i>R</i>, and each rule has one of the disjuncts as its condition: the rule <i>R:&nbsp;If&nbsp;C<sub>1</sub>&nbsp;Or&nbsp;...&nbsp;Or&nbsp;C<sub>n</sub>&nbsp;Then&nbsp;A</i> is equivalent to the set of rules <i>{r<sub>i=0..n</sub>|&nbsp;r<sub>i</sub>:&nbsp;If&nbsp;C<sub>i</sub>&nbsp;Then&nbsp;A}</i>.
</p><p>Without loss of generality, and to keep the specification as simple and intuitive as possible, the operational semantics of production rules and rule sets is specified, in the following sections, for rules and rule sets that have been normalized as follows:
</p>
<ol><li> All the rules are rewritten in disjunctive normal form as described in <a href="#sec-safeness" title="">section Safeness</a>;
</li><li> Each rule is replaced by a <a href="#def-group" title="">group</a> of rules
<ul><li> with the same priority as the rule it replaces,
</li><li> that contains as many rules as the condition of the original rule in disjunctive normal form contains disjuncts,
</li><li> where the condition, in each rule in the group is one of the disjunct in the condition of the original rule,
</li><li> and where all the rules in the group have a different condition and the same action part as the original rule.
</li></ul>
</li></ol>
<p>In the same way, without loss of generality, and to keep the specification as simple and intuitive as possible, the operational semantics of production rules and rule sets is specified, in the following sections, for rules and rule sets where all the <a href="#def-compound-action" title="">compound actions</a> have been replaced by the equivalent sequences of <a href="#def-atomic-action" title="">atomic actions</a>.
</p><p><span class="anchor" id="sec-definitions-and-notational-conventions"></span>
</p>
<a id="Definitions_and_notational_conventions" name="Definitions_and_notational_conventions"></a><h4> <span class="mw-headline">4.2.3  Definitions and notational conventions </span></h4>
<p>Formally, a production rule system is defined as a labeled terminal transition system (e.g. <a href="#ref-ltts" title="">PLO04</a>), for the purpose of specifying the semantics of a RIF-PRD <a href="#def-rule" title="">rule</a> or <a href="#def-group" title="">group of rules</a>.
</p><p><span class="anchor" id="def-ltts"></span> 
<b>Definition (labeled terminal transition system):</b> A labeled terminal transition system is a structure {<b>C</b>, <b>L</b>, &rarr;, <b>T</b>}, where
</p>
<ul><li> <b>C</b> is a set of elements, <i>c</i>, called configurations, or states;
</li><li> <b>L</b> is a set of elements, <i>a</i>, called labels, or actions;
</li><li> &rarr; &sube; C &times; L &times; C is the transition relation, that is: (<i>c, a, c' </i>) &isin; &rarr; iff there is a transition labeled <i>a</i> from the state <i>c</i> to the state <i>c' </i>. In the case of a production rule system: in the state <i>c</i> of the fact base, the execution of action <i>a</i>  causes a transition to state the <i>c' </i> of the fact base; 
</li><li> <b>T</b> &sube; C is the set of final states, that is, the set of all the states <i>c</i> from which there are no transitions: T = {<i>c</i> &isin; C | &forall; <i>a</i> &isin; L, &forall; <i>c' </i> &isin; C, (<i>c, a, c'</i>) &notin; &rarr;}. &nbsp;&nbsp;☐
</li></ul>
<p>For many purposes, a representation of the states of the fact base is an appropriate representation of the states of a production rule system seen as a transition system. However, the most widely used conflict resolution strategies require information about the history of the system, in particular with respect to the rule instances that have been selected for execution in previous states. Therefore, each state of the transition system used to represent a production rule system must keep a memory of the previous states and of the rule instances that where selected and that triggered the transition in those states.
</p><p>Here, a <i>rule instance</i> is defined as the result of the substitution of constants for all the rule variables in a rule.
</p><p>Let <i>R</i> denote the set of all the rules in the rule language under consideration.
</p><p><span class="anchor" id="def-rule-instance"></span> 
<b>Definition (Rule instance).</b> Given a rule, <i>r &isin; R</i>, and a <a href="#def-ground-subst" title="">ground substitution</a>, &sigma;, such that <i>CVar(r) &sube; Dom(&sigma;)</i>, where <i>CVar(r)</i> denotes the set of the rule variables in <i>r</i>, the result, <i>ri = &sigma;(r)</i>, of the substitution of the constant <i>&sigma;(<tt>?x</tt>)</i> for each variable <tt>?x</tt>&nbsp;<i>&isin;&nbsp;CVar(r)</i> is a <i><b>rule instance</b></i> (or, simply, an <i><b>instance</b></i>) of <i>r</i>.&nbsp;&nbsp;☐
</p><p>Given a rule instance <i>ri</i>, let <i>rule(ri)</i> identify the rule from which <i>ri</i> is derived by substitution of constants for the rule variables, and let <i>substitution(ri)</i> denote the substitution by which <i>ri</i> is derived from <i>rule(ri)</i>.
</p><p>In the following, two rule instances <i>ri<sub>1</sub></i> and <i>ri<sub>2</sub></i> of a same rule <i>r</i> will be considered <i>different</i> if and only if <i>substitution(ri<sub>1</sub>)</i> and <i>substitution(ri<sub>2</sub>)</i> substitute a different constant for at least one of the rule variables in <i>CVar(r)</i>.
</p><p>A rule instance, <i>ri</i>, is said to match a state of a fact base, <i>w</i>, if its defining substitution, <i>substitution(ri)</i>, matches the RIF-PRD condition formula that represents the condition of the instantiated rule, <i>rule(ri)</i>, to the set of ground atomic formulas that represents the state of facts <i>w</i>.
</p><p>Let <i>W</i> denote the set of all the possible states of a fact base.
</p><p><span class="anchor" id="def-matching-rule-instance"></span> 
<b>Definition (Matching rule instance).</b> Given a rule instance, <i>ri</i>, and a state of the fact base, <i>w &isin; W</i>, <i>ri</i> is said to <i><b>match</b></i> <i>w</i> if and only if one of the following is true:
</p>
<ul><li> <i>rule(ri)</i> is an <a href="#def-rule" title="">unconditional action block</a>;
</li><li> <i>rule(ri)</i> is a <a href="#def-rule" title="">conditional action block</a>: <tt>If condition, Then action</tt>, and <i>substitution(ri)</i> <a href="#def-matching-substitution" title="">matches</a> the condition formula <tt>condition</tt> to the set of ground atomic condition formulas that represents <i>w</i>;
</li><li> <i>rule(ri)</i> is a <a href="#def-rule" title="">rule with variable declaration</a>: <tt>Forall&nbsp;?v<sub>1</sub>...?v<sub>n</sub> (p<sub>1</sub>...p<sub>m</sub>) (r')</tt>, <i>n &ge; 0</i>, <i>m &ge; 0</i>, and <i>substitution(ri)</i> <a href="#def-matching-substitution" title="">matches</a> each of the condition formulas <tt>p<sub>i</sub></tt>, <i>0 &le; i &le; m</i>, to the set of ground atomic condition formulas that represents <i>w</i>, and the rule instance <i>ri' </i> matches <i>w</i>, where <i>rule(ri')</i>&nbsp;=&nbsp;<tt>r'</tt> and <i>substitution(ri') = substitution(ri)</i>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-action-instance"></span> 
<b>Definition (Action instance).</b> Given a state of the fact base, <i>w &isin; W</i>, given a rule instance, <i>ri</i>, of a rule in a rule set, <i>RS</i>, and given the action block in the action part of the rule <i>rule(ri)</i>: <tt>Do((v<sub>1</sub> p<sub>1</sub>)...(v<sub>n</sub> p<sub>n</sub>) a<sub>1</sub>...a<sub>m</sub>)</tt>, <i>n &ge; 0</i>, <i>m &ge; 1</i>, where the <tt>(v<sub>i</sub> p<sub>i</sub>)</tt>, <i>0 &le; i &le; n</i>, represent the <a href="#def-action-variable-declaration" title="">action variable declarations</a> and the <tt>a<sub>j</sub></tt>, <i>1 &le; j &le; m</i>, represent the sequence of atomic actions in the action block; if <i>ri</i> matches <i>w</i>, the substitution <i>&sigma; = substitution(ri)</i> is extended to the action variables <i>v<sub>1</sub>...v<sub>n</sub>, n &ge; 0</i>, in the following way:
</p>
<ul><li> if the binding, <tt>p<sub>i</sub></tt>, associated to <i>v<sub>i</sub></i>, in the action variable declaration, is the declaration of a new frame object: <tt>(</tt><i>v<sub>i</sub></i> <tt>New())</tt>, then <i>&sigma;(v<sub>i</sub>) = c<sub>new</sub></i>, where <i>c<sub>new</sub></i> is a constant of type <tt>rif:IRI</tt> that does not occur in any of the ground atomic formulas in <i>w</i>;
</li><li> if <i>v<sub>i</sub></i> is assigned the value of a frame's slot by the action variable declaration: <tt>(</tt><i>v<sub>i</sub></i> <tt>o[s-&gt;</tt><i>v<sub>i</sub></i><tt>])</tt>, then <i>&sigma;(v<sub>i</sub>)</i> is a ground term such that the  substitution &sigma; <a href="#def-matching-substitution" title="">matches</a> the frame formula <tt>o[s-&gt;</tt><i>v<sub>i</sub></i><tt>]</tt> to <i>w</i>.
</li></ul>
<p>The sequence of ground atomic actions that is the result of substituting a constant for each variable in the atomic actions of the action block
of the rule instance, <i>ri</i>, according to the extended substitution, is the <i><b>action instance</b></i> associated to <i>ri</i>. &nbsp;&nbsp;☐
</p><p>Let <i>actions(ri)</i> denote the action instance that is associated to a rule instance <i>ri</i>. By extension, given an ordered set of rule instances, <i>ori</i>, <i>actions(ori)</i> denotes the sequence of ground atomic actions that is the concatenation, preserving the order in <i>ori</i>, of the action instances associated to the rule instances in <i>ori</i>.
</p><p>Notice that RIF-PRD does not specify semantics for the case where there is no <a href="#def-matching-substitution" title="">matching substitution</a> for the binding frame formula <tt>o[s-&gt;v<sub>i</sub>]</tt> in an action variable declaration <tt>(v<sub>i</sub> o[s-&gt;v<sub>i</sub>])</tt>. Indeed, although the rule might be valid from an interchange viewpoint, applying it in a context where object <tt>o</tt> has no value for 
attribute <tt>s</tt> is applying it outside the domain where it is meaningful, and the specification of the context where an otherwise valid RIF-PRD rule is validly applicable is out of the scope of RIF-PRD.
</p><p>The components of the states of a production rule system seen as a transition system can now be defined more precisely. To avoid confusion between the states of the fact base and the states of the transition system, the latter will be called <i>production rule system states</i>.
</p><p><span class="anchor" id="def-system-state"></span> 
<b>Definition (Production rule system state).</b> A <i><b>production rule system state</b></i> (or, simply, a <i><b>system state</b></i>) is either a <i><b>system cycle state</b></i> or a <i><b>system transitional state</b></i>. Every production rule system state, <i>s</i>, cycle or transitional, is characterized by
</p>
<ul><li> a state of the fact base, <i>facts(s)</i>;
</li><li> if <i>s</i> is not the current state, an ordered set of rule instances, <i>picked(s)</i>, defined as follows:
<ul><li> if <i>s</i> is a system cycle state, <i>picked(s)</i> is the ordered set of rule instances picked by the conflict resolution strategy, among the set of all the rule instances that matched <i>facts(s)</i>;
</li><li> if <i>s</i> is a system transitional state, <i>picked(s)</i> is the empty set;
</li></ul>
</li><li> if <i>s</i> is not the initial state, a previous system state, <i>previous(s)</i>, defined as follows: given a system cycle state, <i>s<sub>c</sub></i>, and given the sequence of system transitional states, <i>s<sub>1</sub>,...,s<sub>n</sub></i>, <i>n &ge; 0</i>, such that the execution of the first ground atomic action in <i>action(picked(s<sub>c</sub>))</i> transitioned the system from <i>s<sub>c</sub></i> to <i>s<sub>1</sub></i> and ... and the <i>n-th</i> ground atomic action in <i>action(picked(s<sub>c</sub>))</i> transitioned the system from <i>s<sub>n-1</sub></i> to <i>s<sub>n</sub></i>, then <i>previous(s)&nbsp;=&nbsp;s<sub>n</sub></i> if and only if the <i>(n+1)-th</i> ground atomic action in <i>action(picked(s<sub>c</sub>))</i> transitioned the system from <i>s<sub>n</sub></i> to <i>s</i>.&nbsp;&nbsp;☐
</li></ul>
<p>In the following, we will write <i>previous(s) = NIL</i> to denote that a system state <i>s</i> is the initial state.
</p><p><span class="anchor" id="def-conflict-set"></span> 
<b>Definition (Conflict set).</b> Given a rule set, <i>RS &sube; R</i>, and a system state, <i>s</i>, the <i><b>conflict set</b></i> determined by <i>RS</i> in <i>s</i> is the set, <i>conflictSet(RS, s)</i> of all the different instances of the rules in <i>RS</i> that match the state of the fact base, <i>facts(s) &isin; W</i>. &nbsp;&nbsp;☐
</p><p>The rule instances that are in the conflict set are, sometimes, said to be <i>fireable</i>.
</p><p>In each non-final cycle state, <i>s</i>, of a production rule system, a subset, <i>picked(s)</i>, of the rule instances in the conflict set is selected and ordered; their action parts are instantiated, and the resulting sequence of ground atomic actions is executed. This is sometimes called: <i>firing</i> the selected instances.
</p><p><span class="anchor" id="sec-operational-semantics-of-a-production-rule-system"></span>
</p>
<a id="Operational_semantics_of_a_production_rule_system" name="Operational_semantics_of_a_production_rule_system"></a><h4> <span class="mw-headline">4.2.4  Operational semantics of a production rule system </span></h4>
<p>All the elements that are required to define a production rule system as a <a href="#def-ltts" title="">labeled terminal transition system</a> have now been defined.
</p><p><span class="anchor" id="def-prs"></span> 
<b>Definition (RIF-PRD Production Rule System).</b> A <i><b>RIF-PRD production rule system</b></i> is defined as a labeled terminal transition system <i>PRS = {S, A, &rarr;<sub><small>PRS</small></sub>, T}</i>, where&nbsp;:
</p>
<ul><li> <i>S</i> is a set of system states, called the <i><a href="#def-system-state" title="">system cycle states</a></i>;
</li><li> <i>A</i> is a set of transition labels, where each transition label is a sequence of ground RIF-PRD atomic actions;
</li><li> The transition relation &rarr;<sub><sub>PRS</sub></sub> &sube; <i>S</i> &times; <i>A</i> &times; <i>S</i>, is defined as follows:<br />&forall; (<i>s</i>, <i>a</i>, <i>s' </i>) &isin; <i>S</i> &times; <i>A</i> &times; <i>S</i>, (<i>s</i>, <i>a</i>, <i>s' </i>) &isin; &rarr;<sub><sub>PRS</sub></sub> if and only if all of the following hold:
<ol><li> <i>(facts(s), a, facts(s'))</i> &isin; &rarr;<sup>*</sup><sub><sub>RIF-PRD</sub></sub>, where &rarr;<sup>*</sup><sub><sub>RIF-PRD</sub></sub> denotes the transitive closure of the transition relation &rarr;<sub><sub>RIF-PRD</sub></sub> that is determined by the specification of the semantics of the atomic actions supported by RIF-PRD; 
</li><li> <i>a = actions(picked(s))</i>;
</li></ol>
</li><li> <i>T &sube; S</i>, a set of final system states. &nbsp;&nbsp;☐
</li></ul>
<p>Intuitively, the first condition in the definition of the transition relation &rarr;<sub><sub>PRS</sub></sub> states that a production rule system can transition from one system cycle state to another only if the state of facts in the latter system cycle state can be reached from the state of facts in the former by performing a sequence of ground atomic actions supported by RIF-PRD, according to the <a href="#sec-operational-semantics-of-atomic-actions" title="">semantics of the atomic actions</a>.
</p><p>The second condition states that the allowed paths out of any given system cycle state are determined only by how rule instances are <i>picked</i> for execution, from the conflict set, by the conflict resolution strategy.
</p>
Given a rule set <i>RS &sube; R</i>, the associated conflict resolution strategy, <i>LS</i>, and halting test, <i>H</i>, and an initial state of the fact base, <i>w &isin; W</i>, the input function to a <a href="#def-prs" title="">RIF-PRD production rule system</a> is defined as:<br /><center><i>Eval(RS, LS, H, w) &rarr;<sub><sub>PRS</sub></sub> s &isin; S</i>, such that <i>facts(s) = w</i> and <i>previous(s) = NIL</i>.</center>
Using <i>&rarr;<sup>*</sup><sub><sub>PRS</sub></sub></i> to denote the transitive closure of the transition relation <i>&rarr;<sub><sub>PRS</sub></sub></i>, there are zero, one or more final states of the system, <i>s' &isin; T</i>, such that:<br /><center><i>Eval(RS, LS, H, w) &rarr;<sup>*</sup><sub><sub>PRS</sub></sub> s'.</i></center>
<p>The execution of a rule set, <i>RS</i>, in a state, <i>w</i>, of a fact base, may result in zero, one or more final state of the fact base, <i>w' = facts(s')</i>, depending on the conflict resolution strategy and the set of final system states.
</p><p>Therefore, the behavior of a <a href="#def-prs" title="">RIF-PRD production rule system</a> also depends on:
</p>
<ol><li> the conflict resolution strategy, that is, how rule instances are precisely selected for execution from the rule instances that match a given state of the fact base, and
</li><li> how the set <i>T</i> of final system states is precisely defined.
</li></ol>
<p><span class="anchor" id="sec-conflict-resolution"></span>
</p>
<a id="Conflict_resolution" name="Conflict_resolution"></a><h4> <span class="mw-headline">4.2.5  Conflict resolution </span></h4>
<p>The process of selecting one or more <a href="#def-rule-instance" title="">rule instances</a> from the <a href="#def-conflict-set" title="">conflict set</a> for firing is often called: <i>conflict resolution</i>.
</p><p>In RIF-PRD the conflict resolution algorithm (or conflict resolution <i>strategy</i>) that is intended for a set of rules is denoted by a keyword or a set of keywords that is attached to the rule set. In this version of the RIF-PRD specification, a single conflict resolution strategy is specified normatively: it is denoted by the keyword <tt>rif:forwardChaining</tt> (a constant of type <i>rif:IRI</i>), because it accounts for a common conflict resolution strategy used in most forward-chaining production rule systems. That conflict resolution strategy selects a single rule instance for execution.
</p><p>Future versions of the RIF-PRD specification may specify normatively the intended conflict resolution strategies to be attached to additional keywords. In addition, RIF-PRD documents may include non-standard keywords: it is the responsibility of the producers and consumers of such document to agree on the intended conflict resolution strategies that are denoted by such non-standard keywords. Future or non-standard conflict resolution strategies may select an ordered set of rule instances for execution, instead of a single one: the functions <i>picked</i> and <i>actions</i>, in the previous section, have been defined to take this case into account.
</p><p><span class="anchor" id="sec-forward-chaining"></span> 
<b>Conflict resolution strategy: <tt>rif:forwardChaining</tt></b>
</p><p>Most existing production rule systems implement conflict resolution algorithms that are a combination of the following elements (under these or other, idiosyncratic names; and possibly combined with additional, idiosyncratic rules):
</p>
<ul><li> <i>Refraction.</i> The essential idea of <i>refraction</i> is that a given instance of a rule must not be fired more than once as long as the reasons that made it eligible for firing hold. In other terms, if an instance has been fired in a given state of the system, it is no longer eligible for firing as long as it satisfies the states of facts associated to all the subsequent system states (cycle and transitional);
</li><li> <i>Priority.</i> The rule instances are ordered by priority of the instantiated rules, and only the rule instances with the highest priority are eligible for firing;
</li><li> <i>Recency.</i> the rule instances are ordered by the number of consecutive system states, cycle and transitional, in which they have been in the conflict set, and only the most recently fireable ones are eligible for firing. Note that the recency rule, used alone, results in depth-first processing.
</li></ul>
<p>Many existing production rule systems implement also some kind of <i>fire the most specific rule first</i> strategy, in combination with the above. However, whereas they agree on the definition of refraction and the priority or recency ordering, existing production rule systems vary widely on the precise definition of the specificity ordering. As a consequence, rule instance specificity was not included in the basic conflict resolution strategy that RIF-PRD specifies normatively.
</p><p>The RIF-PRD keyword <tt>rif:forwardChaining</tt> denotes the common conflict resolution strategy that can be summarized as follows:
given a conflict set
</p>
<ol><li> Refraction is applied to the conflict set, that is, all the refracted rule instances are removed from further consideration;
</li><li> The remaining rule instances are ordered by decreasing priority, and only the rule instances with the highest priority are kept for further consideration;
</li><li> The remaining rule instances are ordered by decreasing recency, and only the most recent rule instances are kept for further consideration;
</li><li> Any remaining tie is broken is some way, and a single rule instance is kept for firing.
</li></ol>
<p>As specified earlier, <i>picked(s)</i> denotes the ordered list of the rule instances that were picked in a system state, <i>s</i>. Under the conflict resolution strategy denoted by <tt>rif:forwardChaining</tt>, for any given system cycle state, <i>s</i>, the list denoted by <i>picked(s)</i> contains a single rule instance. By definition, if <i>s</i> is a <a href="#def-system-state" title="">system transitional state</a>, <i>picked(s)</i> is the empty set.
</p><p>Given a system state, <i>s</i>, a rule set, <i>RS</i>, and a rule instance, <i>ri &isin; <a href="#def-conflict-set" title="">conflictSet(RS, s)</a></i>, let <i>recency(ri, s)</i> denote the number of system states before <i>s</i>, in which <i>ri</i> has been continuously a matching instance: if <i>s</i> is the current system state, <i>recency(ri, s)</i> provides a measure of the recency of the rule instance <i>ri</i>. <i>recency(ri, s)</i> is specified recursively as follows:
</p>
<ul><li> if <i>previous(s) = NIL</i>, then <i>recency(ri, s) = 1</i>;
</li><li> else if <i>ri &isin; conflictSet(RS, previous(s))</i>, then <i>recency(ri, s) = 1 + recency(ri, previous(s))</i>;
</li><li> else, <i>recency(ri, s) = 1</i>.
</li></ul>
<p>In the same way, given a rule instance, <i>ri</i>, and a system state, <i>s</i>, let <i>lastPicked(ri, s)</i> denote the number of system states before <i>s</i>, since <i>ri</i> has been last fired. <i>lastPicked(ri, s)</i> is specified recursively as follows:
</p>
<ul><li> if <i>previous(s) = NIL</i>, then <i>lastPicked(ri, s) = 1</i>;
</li><li> else if <i>ri &isin; picked(previous(s))</i>, then <i>lastPicked(ri, s) = 1</i>;
</li><li> else, <i>lastPicked(ri, s) = 1 + lastPicked(ri, previous(s))</i>.
</li></ul>
<p>Given a rule instance, <i>ri</i>, let <i>priority(ri)</i> denote the priority that is associated to <i>rule(ri)</i>, or zero, if no priority is associated to <i>rule(ri)</i>. If <i>rule(ri)</i> is inside nested <tt>Group</tt>s, <i>priority(ri)</i> denotes the priority that is associated with the innermost <tt>Group</tt> to which a priority is explicitly associated, or zero.
</p><p><span class="anchor" id="ref-ex43"></span>
</p>
<div class="example">
<p><b>Example 4.3.</b> Consider the following RIF-PRD document:
</p>
<pre>Document (
  Prefix( ex2 &lt;http://example.com/2009/prd3#&gt; )
  (* ex2:ExampleRuleSet *)
  Group (
    (* ex2:Rule_1 *) Forall ...
    (* ex2:HighPriorityRules *)
    Group 10 (
      (* ex2:Rule_2 *) Forall ...
      (* ex2:Rule_3 *) 
      Group 9 (Forall ... ) )
    (* ex2:NoPriorityRules *)
    Group (
      (* ex2:Rule_4 *) Forall ...
      (* ex2:Rule_5 *) Forall ... )
 )
</pre>
<p>No conflict resolution strategy is identified explicitly, so the default strategy <tt>rif:forwardChaining</tt> is used.
</p><p>Because the <i>ex2:ExampleRuleSet</i> group does not specify a priority, the default priority <i>0</i> is used. Rule 1, not being in any other group, inherits its priority, <i>0</i>, from the top-level group.
</p><p>Rule 2 inherits its priority, <i>10</i>, from the enclosing group, identified as <i>ex2:HighPriorityRules</i>. Rule 3 specifies its own, lower, priority: <i>9</i>.
</p><p>Since neither Rule 4 nor Rule 5 specify a priority, they inherit their priority from the enclosing group <i>ex2:NoPriorityRules</i>, which does not specify one either, and, thus, they inherit <i>0</i> from the top-level group, <i>ex2:ExampleRuleSet</i>. &nbsp;&nbsp;☐
</p>
</div>
<p>Given a set of rule instances, <i>cs</i>, the conflict resolution strategy <tt>rif:forwardChaining</tt> can now be described with the help of four rules, where <i>ri</i> and <i>ri' </i> are rule instances:
</p>
<ol><li> <b>Refraction rule</b>: if <i>ri &isin; cs</i> and <i>lastPicked(ri, s) &lt; recency(ri, s)</i>, then <i>cs = cs - ri</i>;
</li><li> <b>Priority rule</b>: if <i>ri &isin; cs</i> and <i>ri' &isin; cs</i> and <i>priority(ri) &lt; priority(ri')</i>, then <i>cs = cs - ri</i>;
</li><li> <b>Recency rule</b>: if <i>ri &isin; cs</i> and <i>ri' &isin; cs</i> and <i>recency(ri, s) &gt; recency(ri', s)</i>, then <i>cs = cs - ri</i>;
</li><li> <b>Tie-break rule</b>: if <i>ri &isin; cs</i>, then <i>cs = {ri}</i>. RIF-PRD does not specify the tie-break rule more precisely: how a single instance is selected from the remaining set is implementation specific.
</li></ol>
<p>The <i>refraction rule</i> removes the instances that have been in the conflict set in all the system states at least since they were last fired; the <i>priority rule</i> removes the instances such that there is at least one instance with a higher priority; the <i>recency rule</i> removes the instances such that there is at least one instance that is more recent;  and the <i>tie-break rule</i> keeps one rule from the set.
</p><p>To select the singleton rule instance, <i>picked(s)</i>, to be fired in a system state, <i>s</i>, given a rule set, <i>RS</i>, the conflict resolution strategy denoted by the keyword <tt>rif:forwardChaining</tt> consists of the following sequence of steps:
</p>
<ol><li> initialize <i>picked(s)</i> with the conflict set, that a rule set <i>RS</i> determines in a system state <i>s</i>: <i>picked(s) = conflictSet(RS, s)</i>;
</li><li> apply the <i>refraction rule</i> to all the rule instances in <i>picked(s)</i>;
</li><li> then apply the <i>priority rule</i> to all the remaining instances in <i>picked(s)</i>;
</li><li> then apply the <i>recency rule</i> to all the remaining instances in <i>picked(s)</i>;
</li><li> then apply the <i>tie-break rule</i> to the remaing instance in <i>picked(s)</i>;
</li><li> return <i>picked(s)</i>.
</li></ol>
<p><span class="anchor" id="ref-ex44"></span>
</p>
<div class="example">
<p><b>Example 4.4.</b> Consider, from <a href="#ref-ex42" title="">example 4.2</a>, the conflict set that the rule set <tt>ex1:CheckoutRuleset</tt> determines in the system state, <i>s<sub>2</sub></i>, that corresponds to the state <i>w<sub>2</sub> = facts(s<sub>2</sub>)</i> of the fact base, and use it to initialize the set of rule instance considered for firing, <i>picked(s<sub>2</sub>)</i>:
</p><p><i>conflictSet(<tt>ex1:CheckoutRuleset</tt>, s<sub>2</sub>) = { ex1:DiscountRule/{(_john/?customer)} } = picked(s<sub>2</sub>)</i>
</p><p>The single rule instance in the conflict set, <i>ri = ex1:DiscountRule/{(_john/?customer)}</i>, did already belong to the conflict sets in the two previous states, <i>conflictSet(<tt>ex1:CheckoutRuleset</tt>, s<sub>1</sub>)</i> and <i>conflictSet(<tt>ex1:CheckoutRuleset</tt>, s<sub>0</sub>)</i>; so that its recency in <i>s<sub>2</sub></i> is: <i>recency(ri, s<sub>2</sub>) = 3</i>.
</p><p>On the other hand, that rule instance was fired in system state <i>s<sub>1</sub></i>: <i>picked(s<sub>1</sub>)&nbsp;=&nbsp;(ex1:DiscountRule/{(_john/?customer)})</i>; so that, in <i>s<sub>2</sub></i>, it has been last fired one cycle before: <i>lastPicked(ri, s<sub>2</sub>) = 1</i>.
</p><p>Therefore, <i>lastPicked(ri, s<sub>2</sub>) &lt; recency(ri, s<sub>2</sub>)</i>, and <i>ri</i> is removed from <i>picked(s<sub>2</sub>)</i> by refraction, leaving <i>picked(s<sub>2</sub>)</i> empty. &nbsp;&nbsp;☐
</p>
</div>
<p><span class="anchor" id="sec-halting-test"></span>
</p>
<a id="Halting_test" name="Halting_test"></a><h4> <span class="mw-headline">4.2.6  Halting test </span></h4>
<p>By default, a system state is final, given a rule set, <i>RS</i>, and a conflict resolution strategy, <i>LS</i>, if there is no rule instance available for firing after application of the conflict resolution strategy.
</p><p>For the conflict resolution strategy identified by the RIF-PRD keyword <tt>rif:forwardChaining</tt>, a system state, <i>s</i>, is <i><b>final</b></i> given a rule set, <i>RS</i> if and only if the remaining conflict set is empty after application of the <i>refraction rule</i> to all the rule instances in <i>conflictSet(RS, s)</i>. In particular, all the system states, <i>s</i>, such that <i>conflictSet(RS, s) = &empty;</i> are final.
</p><p><span class="anchor" id="sec-document-and-imports"></span>
</p>
<a id="Document_and_imports" name="Document_and_imports"></a><h2> <span class="mw-headline">5  Document and imports </span></h2>
<p>This section specifies the structure of a RIF-PRD document and its semantics when it includes import directives.
</p>
<a id="Abstract_syntax_4" name="Abstract_syntax_4"></a><h3> <span class="mw-headline">5.1  Abstract syntax </span></h3>
<p>In addition to the language of conditions, actions, and rules, RIF-PRD provides a construct to denote the import of a RIF or non-RIF document. Import enables the modular interchange of RIF documents, and the interchange of combinations of multiple RIF and non-RIF documents.
</p><p><span class="anchor" id="sec-import-directive"></span>
</p>
<a id="Import_directive" name="Import_directive"></a><h4> <span class="mw-headline">5.1.1  Import directive </span></h4>
<p><span class="anchor" id="def-import-directive"></span>
<b>Definition (Import directive).</b> An <i><b>import directive</b></i> consists of:
</p>
<ul><li> an IRI, the <i>locator</i>, that identifies and locates the document to be imported, and
</li><li> an optional second IRI that identifies the <i>profile</i> of the import. &nbsp;&nbsp;☐
</li></ul>
<p>RIF-PRD gives meaning to one-argument import directives only. Such directives can be used to import other RIF-PRD and RIF-Core documents. Two-argument import directives are provided to enable import of other types of documents, and their semantics is covered by other specifications. For example, the syntax and semantics of the import of RDF and OWL documents, and their combination with a RIF document, is specified in [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>].
</p><p><span class="anchor" id="sec-prd-document"></span>
</p>
<a id="RIF-PRD_document" name="RIF-PRD_document"></a><h4> <span class="mw-headline">5.1.2  RIF-PRD document </span></h4>
<p><span class="anchor" id="def-prd-document"></span>
<b>Definition (RIF-PRD document).</b> A RIF-PRD <i><b>document</b></i> consists of zero or more import directives, and zero or one <a href="#def-group" title="">group</a>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-imported-document"></span>
<b>Definition (Imported document).</b> A document is said to be <i><b>directly imported</b></i> by a RIF document, <i>D</i>, if and only if it is identified by the locator IRI in an import directive in <i>D</i>. A document is said to be <i><b>imported</b></i> by a RIF document, <i>D</i>, if it is directly imported by <i>D</i>, or if it is imported, directly or not, by a RIF document that is directly imported by <i>D</i>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-safe-document"></span>
<b>Definition (Document safeness).</b> (from [<a href="#ref-core" title="">RIF-Core</a>]) A document is <i><b>safe</b></i> if and only if it
</p>
<ul><li> it contains a safe group, or no group at all,
</li><li> and all the documents that it imports are safe. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="sec-wf-documents"></span>
</p>
<a id="Well-formed_documents" name="Well-formed_documents"></a><h4> <span class="mw-headline">5.1.3  Well-formed documents </span></h4>
<p><span class="anchor" id="def-associated-crs"></span>
<b>Definition (Conflict resolution strategy associated with a document).</b> A <i><b>conflict resolution strategy is associated with a RIF-PRD document</b></i>, <i>D</i>, if and only if
</p>
<ul><li> it is explicitly or implicitly attached to the top-level group in <i>D</i>, or
</li><li> it is explicitly or implicitly attached to the top-level group in a RIF-PRD document that is imported by <i>D</i>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="def-wf-prd-document"></span>
<b>Definition (Well-formed RIF-PRD document).</b> A RIF-PRD document, <i>D</i>, is <i><b>well-formed</b></i> if and only if it satisfies all the following conditions:
</p>
<ul><li> the locator IRI provided by all the import directives in <i>D</i>, if any, identify well-formed RIF-PRD documents,
</li><li> <i>D</i> contains a well-formed group or no group at all,
</li><li> <i>D</i> has only one associated conflict resolution strategy (that is, all the conflict resolution strategies that can be associated with it are the same), and
</li><li> every non-<tt>rif:local</tt> constant that occurs in <i>D</i> or in one of the documents imported by <i>D</i>, occurs in the same context in <i>D</i> and in all the documents imported by <i>D</i>. &nbsp;&nbsp;☐
</li></ul>
<p>The last condition in the above definition makes the intent behind the <tt>rif:local</tt> constants clear: occurrences of such constants in different documents can be interpreted differently even if they have the same name. Therefore, each document can choose the names for the <tt>rif:local</tt> constants freely and without regard to the names of such constants used in the imported documents.
</p><p><span class="anchor" id="sec-operational-semantics-of-documents"></span>
</p>
<a id="Operational_semantics_of_RIF-PRD_documents" name="Operational_semantics_of_RIF-PRD_documents"></a><h3> <span class="mw-headline">5.2  Operational semantics of RIF-PRD documents </span></h3>
<p>The semantics of a <a href="#def-wf-prd-document" title="">well-formed RIF-PRD document</a> that contains no import directive is the semantics of the rule set that is represented by the top-level group in the document, evaluated with the <a href="#def-associated-crs" title="">conflict resolution strategy that is associated to the document</a>, and the default halting test, as specified above, in <a href="#sec-halting-test" title="">section Halting test</a>.
</p><p>The semantics of a <a href="#def-wf-prd-document" title="">well-formed RIF-PRD document</a>, <i>D</i>, that imports the <a href="#def-wf-prd-document" title="">well-formed RIF-PRD documents</a> <i>D<sub>1</sub></i>, ..., <i>D<sub>n</sub></i>, <i>n &ge; 1</i>, is the semantics of the rule set that is the union of the rule sets represented by the top-level groups in <i>D</i> and the imported documents, with the <tt>rif:local</tt> constants renamed to ensure that the same symbol does not occur in two different component rule sets, and evaluated with the <a href="#def-associated-crs" title="">conflict resolution strategy that is associated to the document</a>, and the <a href="#sec-halting-test" title="">default halting test</a>.
</p><p><span class="anchor" id="sec-builtins"></span>
</p>
<a id="Built-in_functions.2C_predicates_and_actions" name="Built-in_functions.2C_predicates_and_actions"></a><h2> <span class="mw-headline">6  Built-in functions, predicates and actions </span></h2>
<p>In addition to externally specified functions and predicates, and in particular, in addition to the functions and predicates built-ins defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], RIF-PRD supports externally specified actions, and defines action built-ins.
</p><p>The syntax and semantics of action built-ins are specified like for the other buit-ins, as described in the section Syntax and Semantics of Built-ins in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. However, their formal semantics is trivial: action built-ins behave like predicates that are always true, since action built-ins, in RIF-PRD, MUST NOT affect the semantics of the rules.
</p><p>Although they must not affect the semantics of the rules, action built-ins may have other side effects.
</p><p>RIF action built-ins are defined in the namespace: <a class="external free" href="http://www.w3.org/2007/rif-builtin-action" rel="nofollow" title="http://www.w3.org/2007/rif-builtin-action#">http://www.w3.org/2007/rif-builtin-action#</a>. In this document, we will use the prefix: <tt>act:</tt> to denote the RIF action built-ins namespace.
</p><p><span class="anchor" id="sec-builtin-actions"></span>
</p>
<a id="Built-in_actions" name="Built-in_actions"></a><h3> <span class="mw-headline">6.1  Built-in actions </span></h3>
<p><span class="anchor" id="sec-act-print"></span>
</p>
<a id="act:print" name="act:print"></a><h4> <span class="mw-headline">6.1.1  act:print </span></h4>
<ul>
  <li>
     <em>Schema</em>: 
     <p>
       <tt>(?arg; act:print(?arg))</tt>
     </p>
  </li>
  <li>  
    <em>Domains</em>:
    <p>
       The value space of the single argument is <tt>xs:string</tt>.
    </p>
  </li>
  <li>  
    <em>Mapping:</em> 
    <p>When <tt>s</tt> belongs to its domain, <i><b>I</b></i><sub>truth</sub><tt> &omicron; </tt><i><b>I</b></i><sub>External</sub>(&nbsp;?arg; act:print(?arg) )(s) = <b>t</b>.
</p>
    <p>
       If an argument value is outside of its domain, the truth value of the function is left unspecified.
    </p>
  </li>
  <li>  
    <em>Side effects:</em> 
    <p>
       The value of the argument MUST be printed to an output stream, to be determined by the user implementation.
    </p>
  </li>
</ul>
<p><span class="anchor" id="sec-conformance"></span>
</p>
<a id="Conformance_and_interoperability" name="Conformance_and_interoperability"></a><h2> <span class="mw-headline">7  Conformance and interoperability </span></h2>
<p><span class="anchor" id="sec-semantics-preserving-transformations"></span>
</p>
<a id="Semantics-preserving_transformations" name="Semantics-preserving_transformations"></a><h3> <span class="mw-headline">7.1  Semantics-preserving transformations </span></h3>
<p>RIF-PRD conformance is described partially in terms of semantics-preserving transformations.
</p><p>The intuitive idea is that, for any initial state of facts, the conformant consumer of a conformant RIF-PRD document must reach at least one of the final state of facts intended by the conformant producer of the document, and that it must never reach any final state of facts that was not intended by the producer. That is:
</p>
<ul><li> a conformant RIF-PRD producer, <i>P</i>, must translate any rule set from its own rule language, <i>L<sub>P</sub></i>, into RIF-PRD, in such a way that, for any possible initial state of the fact base, the RIF-PRD translation of the rule set must never produce, according to the semantics specified in this document, a final state of the fact base that would not be a possible result of the execution of the rule set according to the semantics of <i>L<sub>P</sub></i> (where the state of the facts base are meant to be represented in <i>L<sub>P</sub></i> or in RIF-PRD as appropriate), and
</li><li> a conformant RIF-PRD consumer, <i>C</i>, must translate any rule set from a RIF-PRD document into a rule set in its own language, <i>L<sub>C</sub></i>, in such a way that, for any possible initial state of the fact base, the translation in <i>L<sub>C</sub></i> of the rule set, must never produce, according to the semantics of <i>L<sub>C</sub></i>, a final state of the fact base that would not be a possible result of the execution of the rule set according to the semantics specified in this document (where the state of the facts base are meant to be represented in <i>L<sub>C</sub></i> or in RIF-PRD as appropriate).
</li></ul>
<p>Let &Tau; be a set of datatypes and symbol spaces that includes the datatypes specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and the symbol spaces <tt>rif:iri</tt> and <tt>rif:local</tt>. Suppose also that &Epsilon; is a set of external predicates and functions that includes the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and in the <a href="#sec-builtin-actions" title="">section Built-in actions</a>. We say that a rule <i>r</i> is a <i>RIF-PRD</i><sub>&Tau;,&Epsilon;</sub> rule if and only if 
</p>
<ul>
  <li>
    <i>r</i> is a <a href="#def-wf-rule" title="">well-formed RIF-PRD rule</a>,
  </li>
  <li>
    all the datatypes and symbol spaces used in <i>r</i> are in &Tau;, and
  </li>
  <li>
    all the externally defined functions and predicates used in <i>r</i> are in &Epsilon;.
  </li>
</ul>
<p>Suppose, further, that C is a set of conflict resolution strategies that includes the one specified in <a href="#sec-conflict-resolution" title="">section Conflict resolution</a>, and that H is a set of halting tests that includes the one specified in <a href="#sec-halting-test" title="">section Halting test</a>: we say that a rule set , <i>R</i>, is a <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> rule set if and only if
</p>
<ul><li> <i>R</i> contains only <i>RIF-PRD</i><sub>&Tau;,&Epsilon;</sub> rules, 
</li><li> the conflict resolution strategy that is associated to <i>R</i> is in C, and
</li><li> the halting test that is associated to <i>R</i> is in H.
</li></ul>
<p>Given a <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> rule set, <i>R</i>, an initial state of the fact base, <i>w</i>, a conflict resolution strategy <i>c &isin;</i> C and a halting test <i>h &isin;</i> H, let <i>F<sub>R,w,c,h</sub></i> denote the set of all the sets, <i>f</i>, of RIF-PRD ground atomic formulas that represent final states of the fact base, <i>w' </i>, according to the <a href="#sec-operational-semantics-of-a-production-rule-system" title="">operational semantics of a RIF-PRD production rule system</a>, that is: <i>f &isin; F<sub>R,w,c,h</sub></i> if and only if there is a state, <i>s' </i>, of the system, such that <i>Eval(R, c, h, w)  &rarr;<sup>*</sup><sub><sub>PRS</sub></sub> s' </i> and <i>w' = facts(s')</i> and <i>f</i> is a representation of <i>w' </i>.
</p><p>In addition, given a rule language, <i>L</i>, a rule set expressed in <i>L</i>, <i>R<sub>L</sub></i>, a conflict resolution strategy, <i>c</i>, a halting test, <i>h</i>, and an initial state of the fact base, <i>w</i>, let <i>F<sub>L,R<sub>L</sub>, c, h, w</sub></i> denote the set of all the formulas in <i>L</i> that represent a final state of the fact base that an <i>L</i> processor can possibly reach.
</p><p><span class="anchor" id="def-semantics-preserving-mapping"></span>
<b>Definition (Semantics preserving mapping).</b> 
</p>
<ul><li> A mapping from a <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub>, <i>R</i>, to a rule set, <i>R<sub>L</sub></i>, expressed in a language <i>L</i>, is <b>semantics-preserving</b> if and only if, for any initial state of the fact base, <i>w</i>, conflict resolution strategy, <i>c</i>, and halting test, <i>h</i>, it also maps each <i>L</i> formula in <i>F<sub>L,R<sub>L</sub>, c, h, w</sub></i> onto a set of RIF-PRD ground formulas in <i>F<sub>R,w,c,h</sub></i>;
</li><li> A mapping from a rule set, <i>R<sub>L</sub></i>, expressed in a language <i>L</i>, to a <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub>, <i>R</i>, is <b>semantics-preserving</b> if an only if, for any initial state of the fact base, <i>w</i>, conflict resolution strategy, <i>c</i>, and halting test, <i>h</i>, it also maps each set of ground RIF-PRD atomic formulas in <i>F<sub>R,w,c,h</sub></i> onto an <i>L</i> formula in <i>F<sub>L,R<sub>L</sub>, c, h, w</sub></i>.  &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="sec-conformance-clauses"></span>
</p>
<a id="Conformance_Clauses" name="Conformance_Clauses"></a><h3> <span class="mw-headline">7.2  Conformance Clauses </span></h3>
<p><span class="anchor" id="def-conformance"></span>
<b>Definition (RIF-PRD conformance).</b>
</p>
<ul><li> A RIF processor is a <i><b>conformant</b></i> <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> <i><b>consumer</b></i> iff it implements a <a href="#def-semantics-preserving-mapping" title=""><i>semantics-preserving mapping</i></a> from the set of all <a href="#def-safe-rule" title=""><i>safe</i></a> <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> rule sets to the language <i>L</i> of the processor;
</li><li> A RIF processor is a <i><b>conformant</b></i> <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> <i><b>producer</b></i> iff it implements a <a href="#def-semantics-preserving-mapping" title=""><i>semantics-preserving mapping</i></a> from a subset of the language <i>L</i> of the processor to a set of <a href="#def-safe-rule" title=""><i>safe</i></a> <i>RIF-PRD</i><sub>&Tau;,&Epsilon;,C,H</sub> rule sets;
</li><li> An <i><b>admissible document</b></i> is an XML document that conforms to all the syntactic constraints of RIF-PRD, including ones that cannot be checked by an XML Schema validator;
</li><li> A <i><b>conformant RIF-PRD consumer</b></i> is a conformant RIF-PRD<sub>&Tau;,&Epsilon;,C,H</sub> consumer in which &Tau; consists only of the symbol spaces and datatypes, &Epsilon; consists only of the externally defined functions and predicates, C consists only of the conflict resolution strategies, and H consists only of halting tests that are required by RIF-PRD. The required symbol spaces are <tt>rif:iri</tt> and <tt>rif:local</tt>, and the datatypes and externally defined terms (built-ins) are the ones specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and in the <a href="#sec-builtin-actions" title="">section Built-in actions</a>. The required conflict resolution strategy is the one that is identified as <tt>rif:forwardChaining</tt>, as specified in <a href="#sec-conflict-resolution" title="">section Conflict resolution</a>; and the required halting test is the one specified in <a href="#sec-halting-test" title="">section Halting test</a>. A conformant RIF-PRD consumer must reject any document containing features it does not support.
</li><li> A <i><b>conformant RIF-PRD producer</b></i> is a conformant RIF-PRD<sub>&Tau;,&Epsilon;,C,H</sub> producer which produces documents that include only the symbol spaces, datatypes, externals, conflict resolution strategies and halting tests that are required by RIF-PRD.  &nbsp;&nbsp;☐
</li></ul>
<p>In addition, conformant RIF-PRD producers and consumers SHOULD preserve annotations.
</p><p><span class="anchor" id="sec-interoperability"></span>
</p>
<a id="Interoperability" name="Interoperability"></a><h3> <span class="mw-headline">7.3  Interoperability </span></h3>
<p>[<a href="#ref-core" title="">RIF-Core</a>] is specified as a specialization of RIF-PRD: all valid [<a href="#ref-core" title="">RIF-Core</a>] documents are valid RIF-PRD documents and must be accepted by any conformant RIF-PRD consumer.
</p><p>Conversely, it is desirable that any valid RIF-PRD document that uses only abstract syntax that is defined in [<a href="#ref-core" title="">RIF-Core</a>] be a valid [<a href="#ref-core" title="">RIF-Core</a>] document as well. For some abstract constructs that are defined in both RIF-Core and RIF-PRD, RIF-PRD defines alternative XML syntax that is not valid RIF-Core XML syntax. For example, an <a href="#def-action-block" title="">action block</a> that contains no <a href="#def-action-variable-declaration" title="">action variable declaration</a> and only <a href="#def-atomic-action" title="">assert atomic actions</a> can be expressed in RIF-PRD using the XML elements <tt>Do</tt> or <tt>And</tt>. Only the latter option is valid RIF-Core XML syntax.
</p><p>To maximize interoperability with RIF-Core and its non-RIF-PRD extensions, a conformant RIF-PRD consumer SHOULD produce valid [<a href="#ref-core" title="">RIF-Core</a>] documents whenever possible. Specifically, a conformant RIF-PRD producer SHOULD use only valid [<a href="#ref-core" title="">RIF-Core</a>] XML syntax to serialize a rule set that satisfies all of the following:
</p>
<ul><li> the conflict resolution strategy is effectively equivalent to the stratagy that RIF-PRD identifies by the IRI <a href="#sec-conflict-resolution" title=""><tt>rif:forwardChaining</tt></a>,
</li><li> no <a href="#def-bld-formula" title="">condition formula</a> contains a negation, in any rule in the rule set,
</li><li> no rule in the rule set has an <a href="#def-action-block" title="">action block</a> that contains an <a href="#def-action-variable-declaration" title="">action variable declaration</a>, and
</li><li> in all the rules in the rule set, the <a href="#def-action-block" title="">action block</a> contains only <a href="#def-atomic-action" title="">assert atomic actions</a>.
</li></ul>
<p>When processing a rule set that satisfies all the above conditions, a RIF-PRD producer is guaranteed to produce a valid [<a href="#ref-core" title="">RIF-Core</a>] XML document by applying the following rules recursively:
</p>
<ol><li> <i>Remove redundant information</i>. The <tt>behavior</tt> role element and all its sub-elements should be omitted in the RIF-PRD XML document;
</li><li> <i>Remove nested rule variable declarations</i>. If the <tt>rule</tt> inside a <a href="#def-rule" title="">rule with variable delcaration</a>, <i>r<sub>1</sub></i>, is also a <a href="#def-rule" title="">rule with variable declaration</a>, <i>r<sub>2</sub></i>, all the rule variable delarations and all the patterns that occur in <i>r<sub>1</sub></i> should be added to the rule variable declarations and the patterns that occur in <i>r<sub>2</sub></i>, and, after the transform, <i>r<sub>1</sub></i> should be replaced by <i>r<sub>2</sub></i>, in the rule set. If the names of some variables declared in <i>r<sub>1</sub></i> are the same as the names of some variables declared in <i>r<sub>2</sub></i>, the former names must be changed prior to the transform.;
</li><li> <i>Remove patterns</i>. If a pattern occurs in a <a href="#def-rule" title="">rule with variable declaration</a>, <i>r<sub>1</sub></i>:
<ul><li> if the <tt>rule</tt> inside <i>r<sub>1</sub></i> is a <a href="#def-rule" title="">unconditional action block</a>, <i>r<sub>2</sub></i>, <i>r<sub>2</sub></i> should be transformed into a <a href="#def-rule" title="">conditional action block</a>, where the condition is the pattern, and the pattern should be removed from <i>r<sub>1</sub></i>,
</li><li> if the <tt>rule</tt> inside <i>r<sub>1</sub></i> is a <a href="#def-rule" title="">conditional action block</a>, <i>r<sub>2</sub></i>, the formula that represents the condition in <i>r<sub>2</sub></i> should be replaced by the conjunction of that formula and the formula that represents the pattern, and the pattern should be removed from <i>r<sub>1</sub></i>;
</li></ul>
</li><li> <i>Convert action blocks</i>. The action block, in each rule, should be replaced by a conjunction, and, inside the conjunction, each <a href="#def-atomic-action" title="">assert action</a> should be replaced by its target atomic formula.
</li></ol>
<div class="example">
<p><b>Example 7.1.</b> Consider the following rule, <i>R</i>, derived from the <i>Gold rule</i>, in the <a href="#sec-running-example" title="">running example</a>, to have only assertions in the action part:
</p>
<pre>R: Forall&nbsp;?customer such that (And(&nbsp;?customer # ex1:Customer
                                   &nbsp;?customer[status-&gt;"Silver"] ) )
      (Forall&nbsp;?shoppingCart such that (?customer[shoppingCart-&gt;?shoppingCart])
         (If Exists&nbsp;?value (And(&nbsp;?shoppingCart[value-&gt;?value]
                                 pred:numeric-greater-than-or-equal(?value 2000))
          Then Do( Assert(ex1:Foo(?customer))
                   Assert(ex1:Bar(?shoppingCart)) ) ) )
</pre>
<p>The serialization of <i>R</i> in the following RIF-Core conformant XML form does not impacts its semantics (see <a href="#ex-512" title="">example 8.12</a> for another valid RIF-PRD XML serialization, that is not RIF-Core conformant):
</p>
<pre>&lt;Forall&gt;
   &lt;declare&gt;&lt;Var&gt;?customer&lt;/Var&gt;&lt;/declare&gt;
   &lt;declare&gt;&lt;Var&gt;?shoppingCart&lt;/Var&gt;&lt;/declare&gt;
   &lt;formula&gt;
      &lt;Implies&gt;
         &lt;if&gt;
            &lt;And&gt;
               &lt;formula&gt;   &lt;!-- first pattern --&gt;
                  &lt;And&gt;
                     &lt;formula&gt;&lt;Member&gt; ... &lt;/Member&gt;&lt;/formula&gt;
                     &lt;formula&gt;&lt;Frame&gt; ... &lt;/Frame&gt;&lt;/formula&gt;
                  &lt;/And&gt;
               &lt;/formula&gt;
               &lt;formula&gt;   &lt;!-- second pattern --&gt;
                  &lt;Member&gt; ... &lt;/Member&gt;
               &lt;/formula&gt;
               &lt;formula&gt;   &lt;!-- original existential condition --&gt;
                  ...
               &lt;/formula&gt;
           &lt;/And&gt;
        &lt;/if&gt;
        &lt;then&gt;
           &lt;And&gt;
              &lt;formula&gt;   &lt;!-- serialization of ex1:Foo(?customer) --&gt;
                 ...
              &lt;/formula&gt;
              &lt;formula&gt;   &lt;!-- serialization of ex1:Bar(?shoppingCart) --&gt;
                 ...
              &lt;/formula&gt;
        &lt;/then&gt;
     &lt;/Implies&gt;
  &lt;/formula&gt;
&lt;/Forall&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-xml-syntax"></span>
</p>
<a id="XML_Syntax" name="XML_Syntax"></a><h2> <span class="mw-headline">8  XML Syntax </span></h2>
<p>This section specifies the concrete XML syntax of RIF-PRD. The concrete syntax is derived from the abstract syntax defined in sections 2.1, 3.1 and 4.1 using simple mappings. The semantics of the concrete syntax is the same as the semantics of the abstract syntax.
</p><p><span class="anchor" id="sec-notational-conventions"></span> 
</p>
<a id="Notational_conventions" name="Notational_conventions"></a><h3> <span class="mw-headline">8.1  Notational conventions </span></h3>
<p><span class="anchor" id="sec-namespaces"></span> 
</p>
<a id="Namespaces" name="Namespaces"></a><h4> <span class="mw-headline">8.1.1  Namespaces </span></h4>
<p>Throughout this document, the <tt>xsd:</tt> prefix stands for the XML Schema namespace URI <tt>http://www.w3.org/2001/XMLSchema#</tt>, the <tt>rdf:</tt> prefix stands for <tt>http://www.w3.org/1999/02/22-rdf-syntax-ns#</tt>, and <tt>rif:</tt> stands for the URI of the RIF namespace, <tt>http://www.w3.org/2007/rif#</tt>.
</p><p>Syntax such as <tt>xsd:string</tt> should be understood as a compact URI [<a href="#ref-curie" title="">CURIE</a>] -- a macro that expands to a concatenation of the character sequence denoted by the prefix <tt>xsd</tt> and the string <tt>string</tt>. The compact URI notation is used for brevity only, and <tt>xsd:string</tt> should be understood, in this document, as an abbreviation for <tt>http://www.w3.org/2001/XMLSchema#string</tt>.
</p><p><span class="anchor" id="sec-bnf-pseudo-schemas"></span>
</p>
<a id="BNF_pseudo-schemas" name="BNF_pseudo-schemas"></a><h4> <span class="mw-headline">8.1.2  BNF pseudo-schemas </span></h4>
<p>The XML syntax of RIF-PRD is specified for each component as a pseudo-schema, as part of the description of the component. The pseudo-schemas use BNF-style conventions for attributes and elements: "?" denotes optionality (i.e. zero or one occurrences), "*" denotes zero or more occurrences, "+" one or more occurrences, "<tt>[</tt>" and "<tt>]</tt>" are used to form groups, and "|" represents choice. Attributes are conventionally assigned a value which corresponds to their type, as defined in the normative schema. Elements are conventionally assigned a value which is the name of the syntactic class of their content, as defined in the normative schema. 
</p>
<pre>&lt;!-- sample pseudo-schema --&gt;
    &lt;<b>defined_element</b>
          required_attribute_of_type_string="<i>xs:string</i>"
          optional_attribute_of_type_int="<i>xs:int</i>"? &gt;
      &lt;required_element /&gt;
      &lt;optional_element /&gt;?
      &lt;one_or_more_of_these_elements /&gt;+
      [ &lt;choice_1 /&gt; | &lt;choice_2 /&gt; ]*
    &lt;/<b>defined_element</b>&gt;
</pre>
<p><span class="anchor" id="sec-syntactic-components"></span> 
</p>
<a id="Syntactic_components" name="Syntactic_components"></a><h4> <span class="mw-headline">8.1.3  Syntactic components </span></h4>
<p>Three kinds of syntactic components are used to specify RIF-PRD: 
</p>
<ul><li> <i><b>Abstract classes</b></i> are defined only by their subclasses: they are not visible in the XML markup and can be thought of as extension points. In this document, abstract constructs will be denoted with all-uppercase names; 
</li><li> <i><b>Concrete classes</b></i> have a concrete definition, and they are associated with specific XML markup. In this document, concrete constructs will be denoted with CamelCase names with leading capital letter; 
</li><li> <i><b>Properties</b></i>, or <i>roles</i>, define how two classes relate to each other. They have concrete definitions and are associated with specific XML markup. In this document, properties will be denoted with camelCase names with leading smallcase letter. 
</li></ul>
<p><span class="anchor" id="sec-xml-base"></span>
</p>
<a id="Relative_IRIs_and_XML_base" name="Relative_IRIs_and_XML_base"></a><h3> <span class="mw-headline">8.2  Relative IRIs and XML base </span></h3>
<p>Relative IRIs are allowed in RIF-PRD XML syntax, anywhere IRIs are allowed, including constant types, symbol spaces, location, and profile. The attribute <tt>xml:base</tt> [<a href="#xml-base" title="">XML-Base</a>] is used to make them absolute.
</p><p><span class="anchor" id="sec-xml-conditions"></span>
</p>
<a id="Conditions_2" name="Conditions_2"></a><h3> <span class="mw-headline">8.3  Conditions </span></h3>
<p>This section specifies the XML constructs that are used in RIF-PRD to serialize <a href="#def-bld-formula" title="">condition formulas</a>.
</p><p><span class="anchor" id="sec-TERM"></span> 
</p>
<a id="TERM" name="TERM"></a><h4> <span class="mw-headline">8.3.1  TERM </span></h4>
<p>The <tt>TERM</tt> class of constructs is used to serialize <a href="#def-bld-term" title="">terms</a>, be they <a href="#def-bld-term" title="">simple terms</a>, that is, constants and variables; lists; or <a href="#def-bld-term" title="">positional terms</a>, the latter being, per the definition of a <a href="#def-bld-wff" title="">well-formed formula</a>, representations of externally defined functions.
</p><p>As an abstract class, <tt>TERM</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>Const</b></i> | <i><b>Var</b></i> | <i><b>List</b></i> | <i><b>External</b></i> ]
</pre>
<p><span class="anchor" id="sec-const"></span> 
</p>
<a id="Const" name="Const"></a><h5> <span class="mw-headline">8.3.1.1  Const </span></h5>
<p>In RIF, the <tt>Const</tt> element is used to serialize a <a href="#def-bld-term" title="">constant</a>.
</p><p>The <tt>Const</tt> element has a required <tt>type</tt> attribute and an optional <tt>xml:lang</tt> attribute: 
</p>
<ul><li> The value of the <tt>type</tt> attribute is the identifier of the <tt>Const</tt> symbol space. It must be a <tt>rif:iri</tt>;
</li><li> The <tt>xml:lang</tt> attribute, as defined by <a class="external text" href="http://www.w3.org/TR/REC-xml/#sec-lang-tag" rel="nofollow" title="http://www.w3.org/TR/REC-xml/#sec-lang-tag">2.12 Language Identification</a> of <a class="external text" href="http://www.w3.org/TR/2000/REC-xml-20001006" rel="nofollow" title="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0</a> or its successor specifications in the W3C recommendation track, is optionally used to identify the language for the presentation of the <tt>Const</tt> to the user. It is allowed only in association with constants of the type <tt>rdf:plainLiteral</tt>. A compliant implementation MUST ignore the <tt>xml:lang</tt> attribute if the type of the <tt>Const</tt> is not <tt>rdf:plainLiteral</tt>. 
</li></ul>
<p>The content of the <tt>Const</tt> element is the constant's literal, which can be any Unicode character string.
</p>
<pre>    &lt;Const type=<i><b>rif:iri</b></i> [xml:lang=<i><b>xsd:language</b></i>]? &gt;
        <i><b>Any Unicode string</b></i>
    &lt;/Const&gt;
</pre>
<p><span class="anchor" id="ex-51"></span>
</p>
<div class="example">
<p><b>Example 8.1.</b>
</p><p>a. A constant with built-in type <i>xsd:integer</i> and value <i>2,000</i>:
</p>
<pre>&lt;Const type="xsd:integer"&gt;2000&lt;/Const&gt;
</pre>
<p>b. The <i>Customer</i> class, in the <a href="#sec-running-example" title="">running example</a>, is identified by a constant of type <tt>rif:iri</tt>, in the namespace <i>http://example.com/2009/prd2#</i>:
</p>
<pre>&lt;Const type="rif:iri"&gt;
   http://example.com/2009/prd2#Customer
&lt;/Const&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-var"></span>
</p>
<a id="Var" name="Var"></a><h5> <span class="mw-headline">8.3.1.2  Var </span></h5>
<p>In RIF, the <tt>Var</tt> element is used to serialize a <a href="#def-bld-term" title="">variable</a>.
</p><p>The content of the <tt>Var</tt> element is the variable's name, serialized as an <a class="external text" href="http://www.w3.org/TR/xmlschema-2/#NCName" rel="nofollow" title="http://www.w3.org/TR/xmlschema-2/#NCName">NCName</a>. 
</p>
<pre>    &lt;Var&gt; <i><b>xsd:NCName</b></i> &lt;/Var&gt;
</pre>
<p><span class="anchor" id="sec-list-term"></span>
</p>
<a id="List" name="List"></a><h5> <span class="mw-headline">8.3.1.3  List </span></h5>
<p>In RIF, the <tt>List</tt> element is used to serialize a <a href="#def-bld-term" title="">list</a>.
</p><p>The <tt>List</tt> element contains an optional <tt>items</tt> element, that contains one or more <tt>TERM</tt>s (without variables) that serialize the elements of the list. The order of the sub-elements is significant and MUST be preserved. This is emphasized by the fixed value <tt>"yes"</tt> of the mandatory attribute <tt>ordered</tt> in the <tt>items</tt> element. 
</p>
<pre>    &lt;List&gt;
      &lt;items ordered="yes"&gt; <i><b>GROUNDTERM</b></i>+ &lt;/items&gt;?
    &lt;/List&gt;
</pre>
<p><span class="anchor" id="ex-52"></span>
</p>
<div class="example">
<p><b>Example 8.2.</b>
</p>
<ul><li> The list of customer status values from <a href="#ref-ex21" title="">example 2.1</a>:
</li></ul>
<pre>&lt;List&gt;
  &lt;items ordered="yes"&gt;
    &lt;Const type="xsd:string&gt; New &lt;/Const&gt;
    &lt;Const type="xsd:string&gt; Bronze &lt;/Const&gt;
    &lt;Const type="xsd:string&gt; Silver &lt;/Const&gt;
    &lt;Const type="xsd:string&gt; Gold &lt;/Const&gt;
  &lt;/items&gt;
&lt;/List&gt;
</pre>
<ul><li> The empty list:
</li></ul>
<pre>&lt;List&gt;
&lt;/List&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-external-term"></span>
</p>
<a id="External" name="External"></a><h5> <span class="mw-headline">8.3.1.4  External </span></h5>
<p>As a <tt>TERM</tt>, the <tt>External</tt> element is used to serialize a <a href="#def-bld-term" title="">positional term</a>. In RIF-PRD, a positional term represents always a call to an externally defined function, e.g. a built-in, a user-defined function, a query to an external data source, etc. 
</p><p>The <tt>External</tt> element contains one <tt>content</tt> element, which in turn contains one <tt>Expr</tt> element that contains one <tt>op</tt> element, followed zero or one <tt>args</tt> element: 
</p>
<ul><li> The <tt>External</tt> and the <tt>content</tt> elements ensure compatibility with the RIF Basic Logic Dialect [<a href="#ref-rif-bld" title="">RIF-BLD</a>] that allows non-evaluated (that is, logic) functions to be serialized using an <tt>Expr</tt> element alone;
</li><li> The content of the <tt>op</tt> element must be a <tt>Const</tt>. When the <tt>External</tt> is a <tt>TERM</tt>, the content of the <tt>op</tt> element serializes a constant symbol of type <tt>rif:iri</tt> that must uniquely identify the externally defined function to be applied to the <tt>args&nbsp;TERM</tt>s;
</li><li> The optional <tt>args</tt> element contains one or more constructs from the <tt>TERM</tt> abstract class. The <tt>args</tt> element is used to serialize the arguments of a <a href="#def-bld-term" title="">positional term</a>. The order of the <tt>args</tt> sub-elements is, therefore, significant and MUST be preserved. This is emphasized by the required value <tt>"yes"</tt> of the attribute <tt>ordered</tt>.
</li></ul>
<pre>    &lt;External&gt;
       &lt;content&gt;
          &lt;Expr&gt;
             &lt;op&gt; <i><b>Const</b></i> &lt;/op&gt;
             &lt;args ordered="yes"&gt; <i><b>TERM</b></i>+ &lt;/args&gt;?
          &lt;/Expr&gt;
       &lt;/content&gt;
    &lt;/External&gt;
</pre>
<p><span class="anchor" id="ex-53"></span>
</p>
<div class="example">
<p><b>Example 8.3.</b> The example shows one way to serialize, in RIF-PRD, the product of a variable named <tt>?value</tt> and the <tt>xsd:decimal</tt> value <i>0.9</i>, where the operation conforms to the specification of the built-in <tt>func:numeric-multiply</tt>, as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>RIF built-in functions are associated with the namespace <a class="external free" href="http://www.w3.org/2007/rif-builtin-function" rel="nofollow" title="http://www.w3.org/2007/rif-builtin-function#">http://www.w3.org/2007/rif-builtin-function#</a>.
</p>
<pre>&lt;External&gt;
   &lt;content&gt;
      &lt;Expr&gt;    
         &lt;op&gt; &lt;Const type="rif:iri"&gt; http://www.w3.org/2007/rif-builtin-function#numeric-multiply &lt;/Const&gt; &lt;/op&gt;
         &lt;args ordered="yes"&gt; 
            &lt;Var&gt;&nbsp;?value &lt;/Var&gt;
            &lt;Const type="xsd:decimal"&gt; 0.9 &lt;/Const&gt;
         &lt;/args&gt;
      &lt;/Expr&gt;
   &lt;/content&gt;
&lt;/External&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-ATOMIC"></span>
</p>
<a id="ATOMIC" name="ATOMIC"></a><h4> <span class="mw-headline">8.3.2  ATOMIC </span></h4>
<p>The <tt>ATOMIC</tt> class is used to serialize <a href="#def-prd-atomic" title="">atomic formulas</a>: positional atoms, equality, membership and subclass atomic formulas, frame atomic formulas and externally defined atomic formulas.
</p><p>As an abstract class, <tt>ATOMIC</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>Atom</b></i> | <i><b>Equal</b></i> | <i><b>Member</b></i> | <i><b>Subclass</b></i> | <i><b>Frame</b></i> | <i><b>External</b></i> ]
</pre>
<p><span class="anchor" id="sec-atom"></span> 
</p>
<a id="Atom" name="Atom"></a><h5> <span class="mw-headline">8.3.2.1  Atom </span></h5>
<p>In RIF, the <tt>Atom</tt> element is used to serialize a <a href="#def-prd-atomic" title="">positional atomic formula</a>.
</p><p>The <tt>Atom</tt> element contains one <tt>op</tt> element, followed by zero or one <tt>args</tt> element: 
</p>
<ul><li> The content of the <tt>op</tt> element must be a <tt>Const</tt>. It serializes the predicate symbol (the name of a relation); 
</li><li> The optional <tt>args</tt> element contains one or more constructs from the <tt>TERM</tt> abstract class. The <tt>args</tt> element is used to serialize the arguments of a <a href="#def-prd-atomic" title="">positional atomic formula</a>. The order of the <tt>arg</tt>'s sub-elements is, therefore, significant and MUST be preserved. This is emphasized by the required value <tt>"yes"</tt> of the attribute <tt>ordered</tt>. 
</li></ul>
<pre>    &lt;Atom&gt;
       &lt;op&gt; <i><b>Const</b></i> &lt;/op&gt;
       &lt;args ordered="yes"&gt; <i><b>TERM</b></i>+ &lt;/args&gt;?
    &lt;/Atom&gt;
</pre>
<p><span class="anchor" id="ex-54"></span>
</p>
<div class="example">
<p><b>Example 8.4.</b> The example shows the RIF XML serialization of the positional atom <i>ex1:gold(?customer)</i>, where the predicate symbol <i>gold</i> is defined in the example namespace <i>http://example.com/2009/prd2#</i>.
</p>
<pre>&lt;Atom&gt;
   &lt;op&gt;
      &lt;Const type="rif:iri"&gt;
         http://example.com/2009/prd2#gold
      &lt;/Const&gt;
   &lt;/op&gt;
   &lt;args ordered="yes"&gt;
      &lt;Var&gt;&nbsp;?customer &lt;/Var&gt;
   &lt;/args&gt;
&lt;/Atom&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-equal"></span>
</p>
<a id="Equal" name="Equal"></a><h5> <span class="mw-headline">8.3.2.2  Equal </span></h5>
<p>In RIF, the <tt>Equal</tt> element is used to serialize <a href="#def-prd-atomic" title="">equality atomic formulas</a>.
</p><p>The <tt>Equal</tt> element must contain one <tt>left</tt> sub-element and one <tt>right</tt> sub-element. The content of the <tt>left</tt> and <tt>right</tt> elements must be a construct from the <tt>TERM</tt> abstract class, that serialize the terms of the equality. The order of the sub-elements is not significant. 
</p>
<pre>    &lt;Equal&gt;
       &lt;left&gt; <i><b>TERM</b></i> &lt;/left&gt;
       &lt;right&gt; <i><b>TERM</b></i> &lt;/right&gt;
    &lt;/Equal&gt;
</pre>
<p><span class="anchor" id="sec-member"></span> 
</p>
<a id="Member" name="Member"></a><h5> <span class="mw-headline">8.3.2.3  Member </span></h5>
<p>In RIF, the <tt>Member</tt> element is used to serialize <a href="#def-prd-atomic" title="">membership atomic formulas</a>.
</p><p>The <tt>Member</tt> element contains two required sub-elements: 
</p>
<ul><li> the <tt>instance</tt> elements must be a construct from the <tt>TERM</tt> abstract class that serializes the reference to the object; 
</li><li> the <tt>class</tt> element must be a construct from the <tt>TERM</tt> abstract class that serializes the reference to the class. 
</li></ul>
<pre>    &lt;Member&gt;
       &lt;instance&gt; <i><b>TERM</b></i> &lt;/instance&gt;
       &lt;class&gt; <i><b>TERM</b></i> &lt;/class&gt;
    &lt;/Member&gt;
</pre>
<p><span class="anchor" id="ex-55"></span>
</p>
<div class="example">
<p><b>Example 8.5.</b> The example shows the RIF XML serialization of class membership atom that tests whether a variable named <tt>?customer</tt> belongs to a class identified by the name <tt>Customer</tt> in the namespace <i>http://example.com/2009/prd2#</i>
</p>
<pre>&lt;Member&gt;
   &lt;instance&gt; &lt;Var&gt;&nbsp;?customer &lt;/Var&gt; &lt;/instance&gt;
   &lt;class&gt;
      &lt;Const type="rif:iri"&gt;
         http://example.com/2009/prd2#Customer
      &lt;/Const&gt;
   &lt;/class&gt;
&lt;/Member&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-subclass"></span>
</p>
<a id="Subclass" name="Subclass"></a><h5> <span class="mw-headline">8.3.2.4  Subclass </span></h5>
<p>In RIF, the <tt>Subclass</tt> element is used to serialize <a href="#def-prd-atomic" title="">subclass atomic formulas</a>.
</p><p>The <tt>Subclass</tt> element contains two required sub-elements: 
</p>
<ul><li> the <tt>sub</tt> element must be a construct from the <tt>TERM</tt> abstract class that serializes the reference to the sub-class; 
</li><li> the <tt>super</tt> elements must be a construct from the <tt>TERM</tt> abstract class that serializes the reference to the super-class. 
</li></ul>
<pre>    &lt;Subclass&gt;
       &lt;sub&gt; <i><b>TERM</b></i> &lt;/sub&gt;
       &lt;super&gt; <i><b>TERM</b></i> &lt;/super&gt;
    &lt;/Subclass&gt;
</pre>
<p><span class="anchor" id="sec-frame"></span>
</p>
<a id="Frame" name="Frame"></a><h5> <span class="mw-headline">8.3.2.5  Frame </span></h5>
<p>In RIF, the <tt>Frame</tt> element is used to serialize <a href="#def-prd-atomic" title="">frame atomic formulas</a>.
</p><p>Accordingly, a <tt>Frame</tt> element must contain: 
</p>
<ul><li> an <tt>object</tt> element, that contains an element of the <tt>TERM</tt> abstract class that serializes the reference to the frame's object; 
</li><li> zero to many <tt>slot</tt> elements, each serializing an attribute-value pair as a pair of elements of the <tt>TERM</tt> abstract class, the first one that serializes the name of the attribute (or property); the second that serializes the attribute's value. The order of the <tt>slot</tt>'s sub-elements is significant and MUST be preserved. This is emphasized by the required value <tt>"yes"</tt> of the required attribute <tt>ordered</tt>.
</li></ul>
<pre>    &lt;Frame&gt;
       &lt;object&gt; <i><b>TERM</b></i> &lt;/object&gt;
       &lt;slot ordered="yes"&gt; <i><b>TERM</b></i> <i><b>TERM</b></i> &lt;/slot&gt;*
    &lt;/Frame&gt;
</pre>
<p><span class="anchor" id="ex-56"></span>
</p>
<div class="example">
<p><b>Example 8.6.</b> The example shows the RIF XML serialization of an expression that states that the object denoted by the variable <i>?customer</i> has the value denoted by the string <i>"Gold"</i> for the property identified by the symbol <i>status</i> that is defined in the example namespace <i>http://example.com/2009/prd2#</i>
</p>
<pre>&lt;Frame&gt;
   &lt;object&gt; &lt;Var&gt;&nbsp;?customer &lt;/Var&gt; &lt;/object&gt;
   &lt;slot ordered="yes"&gt; 
      &lt;Const type="rif:iri"&gt;
         http://example.com/2009/prd2#status
      &lt;/Const&gt;
      &lt;Const type="xsd:string&gt; Gold &lt;/Const&gt;
   &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-external-atomic"></span>
</p>
<a id="External_2" name="External_2"></a><h5> <span class="mw-headline">8.3.2.6  External </span></h5>
<p>In RIF-PRD, the <tt>External</tt> element is also used to serialize an <a href="#def-prd-atomic" title="">externally defined atomic formula</a>, in addition to <a href="#sec-external-term" title="">serializing externally defined functions</a>.
</p><p>When it is an <tt>ATOMIC</tt> (as opposed to a <tt>TERM</tt>; that is, in particular, when it appears in a place where an <tt>ATOMIC</tt> is expected, and not a <tt>TERM</tt>), the <tt>External</tt> element contains one <tt>content</tt> element that contains one <tt>Atom</tt> element. The <tt>Atom</tt> element serializes the <a href="#def-prd-atomic" title="">externally defined atom</a> properly said.
</p><p>The <tt>op</tt> <tt>Const</tt> in the <tt>Atom</tt> element must be a symbol of type <tt>rif:iri</tt> that must uniquely identify the externally defined predicate to be applied to the <tt>args&nbsp;TERM</tt>s.
</p>
<pre>    &lt;External&gt;
       &lt;content&gt;
          <i><b>Atom</b></i>
       &lt;/content&gt;
    &lt;/External&gt;
</pre>
<p><span class="anchor" id="ex-57"></span>
</p>
<div class="example">
<p><b>Example 8.7.</b> The example below shows the RIF XML serialization of an externally defined atomic formula that tests whether the value denoted by the variable named <i>?value</i> is greater than or equal to the integer value <i>2000</i>, where the test is intended to behave like the built-in predicate pred:numeric-greater-than-or-equal as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]:
</p><p>RIF built-in predicates are associated with the namespace <i><a class="external free" href="http://www.w3.org/2007/rif-builtin-predicate" rel="nofollow" title="http://www.w3.org/2007/rif-builtin-predicate#">http://www.w3.org/2007/rif-builtin-predicate#</a></i>.
</p>
<pre>&lt;External&gt;
   &lt;content&gt;
      &lt;Atom&gt;    
         &lt;op&gt; &lt;Const type="rif:iri"&gt; http://www.w3.org/2007/rif-builtin-predicate#numeric-greater-than-or-equal &lt;/Const&gt; &lt;/op&gt;
         &lt;args ordered="yes"&gt;
            &lt;Var&gt;&nbsp;?value &lt;/Var&gt;
            &lt;Const type="xsd:integer"&gt; 2000 &lt;/Const&gt;
         &lt;/args&gt;
      &lt;/Atom&gt;
   &lt;/content&gt;
&lt;/External&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-FORMULA"></span>
</p>
<a id="FORMULA" name="FORMULA"></a><h4> <span class="mw-headline">8.3.3  FORMULA </span></h4>
<p>The <tt>FORMULA</tt> class is used to serialize <a href="#def-bld-formula" title="">condition formulas</a>, that is, atomic formulas, conjunctions, disjunctions, negations and existentials.
</p><p>As an abstract class, <tt>FORMULA</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>ATOMIC</b></i> | <i><b>And</b></i> | <i><b>Or</b></i> | <i><b>INeg</b></i> | <i><b>Exists</b></i> ]
</pre>
<p><span class="anchor" id="sec-atomic-formula"></span> 
</p>
<a id="ATOMIC_2" name="ATOMIC_2"></a><h5> <span class="mw-headline">8.3.3.1  ATOMIC </span></h5>
<p>An <a href="#def-prd-atomic-formula" title="">atomic formula</a> is serialized using a single <tt>ATOMIC</tt> statement. See specification of <a href="#sec-ATOMIC" title="">ATOMIC</a>, above.
</p><p><span class="anchor" id="sec-and"></span> 
</p>
<a id="And" name="And"></a><h5> <span class="mw-headline">8.3.3.2  And </span></h5>
<p>A <a href="#def-bld-formula" title="">conjunction</a> is serialized using the <tt>And</tt> element. 
</p><p>The <tt>And</tt> element contains zero or more <tt>formula</tt> sub-elements, each containing an element of the <tt>FORMULA</tt> group, that serializes one of the conjuncts. 
</p>
<pre>    &lt;And&gt;
       &lt;formula&gt; <i><b>FORMULA</b></i> &lt;/formula&gt;*
    &lt;/And&gt;
</pre>
<p><span class="anchor" id="sec-or"></span> 
</p>
<a id="Or" name="Or"></a><h5> <span class="mw-headline">8.3.3.3  Or </span></h5>
<p>A <a href="#def-bld-formula" title="">disjunction</a> is serialized using the <tt>Or</tt> element. 
</p><p>The <tt>Or</tt> element contains zero or more <tt>formula</tt> sub-elements, each containing an element of the <tt>FORMULA</tt> group, that serializes one of the disjuncts.
</p>
<pre>    &lt;Or&gt;
       &lt;formula&gt; <i><b>FORMULA</b></i> &lt;/formula&gt;*
    &lt;/Or&gt;
</pre>
<p><span class="anchor" id="sec-ineg"></span> 
</p>
<a id="INeg" name="INeg"></a><h5> <span class="mw-headline">8.3.3.4  INeg </span></h5>
<p>The kind of <a href="#def-bld-formula" title="">negation</a> that is used in RIF-PRD is serialized using the <tt>INeg</tt> element. 
</p><p>The <tt>INeg</tt> element contains exactly one <tt>formula</tt> sub-element. The <tt>formula</tt> element contains an element of the <tt>FORMULA</tt> group, that serializes the negated statement. 
</p>
<pre>    &lt;INeg&gt;
       &lt;formula&gt; <i><b>FORMULA</b></i> &lt;/formula&gt;
    &lt;/INeg&gt;
</pre>
<p><span class="anchor" id="sec-exists"></span>
</p>
<a id="Exists" name="Exists"></a><h5> <span class="mw-headline">8.3.3.5  Exists </span></h5>
<p>An <a href="#def-bld-formula" title="">existentially quantified formula</a> is serialized using the <tt>Exists</tt> element.
</p><p>The <tt>Exists</tt> element contains:
</p>
<ul><li> one or more <tt>declare</tt> sub-elements, each containing one <a href="#sec-var" title=""><tt>Var</tt></a> element that serializes one of the existentially quantified variables; 
</li><li> exactly one required <tt>formula</tt> sub-element that contains an element from the <tt>FORMULA</tt> abstract class, that serializes the formula in the scope of the quantifier.
</li></ul>
<pre>    &lt;Exists&gt;
       &lt;declare&gt; <i><b>Var</b></i> &lt;/declare&gt;+
       &lt;formula&gt; <i><b>FORMULA</b></i> &lt;/formula&gt;
    &lt;/Exists&gt;
</pre>
<p><span class="anchor" id="ex-58"></span>
</p>
<div class="example">
<p><b>Example 8.8.</b> The example shows the RIF XML serialization of a condition on the existence of a value greater than or equal to 2.000, in the <i>Gold rule</i> of the <a href="#sec-running-example" title="">running example</a>, as represented in <a href="#ref-ex42" title="">example 4.2</a>.
</p>
<pre>&lt;Exists&gt;
   &lt;declare&gt; &lt;Var&gt;&nbsp;?value &lt;/Var&gt; &lt;/declare&gt;
   &lt;formula&gt;
      &lt;And&gt;
         &lt;Frame&gt;
            &lt;object&gt; &lt;Var&gt;&nbsp;?shoppingCart &lt;/Var&gt; &lt;/object&gt;
            &lt;slot ordered="yes"&gt; 
               &lt;Const type="rif:iri"&gt;
                  http://example.com/2009/prd2#value
               &lt;/Const&gt;
               &lt;Var&gt;&nbsp;?value &lt;/Var&gt;
            &lt;/slot&gt;
         &lt;/Frame&gt;
         &lt;External&gt;
            &lt;content&gt;
               &lt;Atom&gt;    
                  &lt;op&gt; &lt;Const type="rif:iri"&gt; http://www.w3.org/2007/rif-builtin-predicate#numeric-greater-than-or-equal &lt;/Const&gt; &lt;/op&gt;
                  &lt;args ordered="yes"&gt;
                     &lt;Var&gt;&nbsp;?value &lt;/Var&gt;
                     &lt;Const type="xsd:integer"&gt; 2000 &lt;/Const&gt;
                  &lt;/args&gt;
               &lt;/Atom&gt;
            &lt;/content&gt;
         &lt;/External&gt;
      &lt;/And&gt;
   &lt;/formula&gt;
&lt;/Exists&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-xml-actions"></span>
</p>
<a id="Actions_3" name="Actions_3"></a><h3> <span class="mw-headline">8.4  Actions </span></h3>
<p>This section specifies the XML syntax that is used to serialize the action part of a rule supported by RIF-PRD. 
</p>
<a id="ACTION" name="ACTION"></a><h4> <span class="mw-headline">8.4.1  ACTION </span></h4>
<p>The <tt>ACTION</tt> class of elements is used to serialize the <a href="#def-simple-action" title="">actions</a>: <i>assert</i>, <i>retract</i>, <i>modify</i> and <i>execute</i>.
</p><p>As an abstract class, <tt>ACTION</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>Assert</b></i> | <i><b>Retract</b></i> | <i><b>Modify</b></i> | <i><b>Execute</b></i> ]
</pre>
<p><span class="anchor" id="sec-assert"></span> 
</p>
<a id="Assert" name="Assert"></a><h5> <span class="mw-headline">8.4.1.1  Assert </span></h5>
<p>An <a href="#def-atomic-action" title="">atomic assertion action</a> is serialized using the <tt>Assert</tt> element.
</p><p>The <tt>Assert</tt> element has one <tt>target</tt> sub-element that contains an <tt>Atom</tt>, a <tt>Frame</tt> or a <tt>Member</tt> element that represents the target of the action. 
</p><p><br />
</p>
<pre>    &lt;Assert&gt;
         &lt;target&gt; [ <i><b>Atom</b></i> | <i><b>Frame</b></i> | <i><b>Member</b></i> ] &lt;/target&gt;
    &lt;/Assert&gt;
</pre>
<p><span class="anchor" id="sec-retract"></span>
</p>
<a id="Retract" name="Retract"></a><h5> <span class="mw-headline">8.4.1.2  Retract </span></h5>
<p>The <tt>Retract</tt> construct is used to serialize <a href="#def-atomic-action" title="">retract atomic actions</a>.
</p><p>The <tt>Retract</tt> element has one <tt>target</tt> sub-element that contains an <tt>Atom</tt>, a <tt>Frame</tt>, a <tt>TERM</tt>, or a pair of <tt>TERM</tt> constructs that represent the target of the action. The <tt>target</tt> element has an optional attribute, <tt>ordered</tt>, that MUST be present when the element contains two <tt>TERM</tt> sub-elements: the order of the sub-elements is significant and MUST be preserved. This is emphasized by the required value "<tt>yes</tt>" of the attribute.
</p>
<pre>    &lt;Retract&gt;
       &lt;target ordered="yes"?&gt; 
          [ <i><b>Atom</b></i> | <i><b>Frame</b></i> | <i><b>TERM</b></i> | <i><b>TERM TERM</b></i> ]
       &lt;/target&gt;
    &lt;/Retract&gt;
</pre>
<p><span class="anchor" id="sec-modify"></span>
</p>
<a id="Modify" name="Modify"></a><h5> <span class="mw-headline">8.4.1.3  Modify </span></h5>
<p>A <a href="#def-compound-action" title="">compound modification</a> is serialized using the <tt>Modify</tt> element.
</p><p>The <tt>Modify</tt> element has one <tt>target</tt> sub-element that contains one <tt>Frame</tt> that represents the target of the action. 
</p>
<pre>    &lt;Modify&gt;
         &lt;target&gt; <i><b>Frame</b></i> &lt;/target&gt;
    &lt;/Modify&gt;
</pre>
<p><br />
<span class="anchor" id="ex-59"></span>
</p>
<div class="example">
<p><b>Example 8.9.</b> The example shows the RIF XML representation of the action that updates the status of a customer, in the <i>Gold rule</i>, in the <a href="#sec-running-example" title="">running example</a>, as represented in <a href="#ref-ex42" title="">example 4.2</a>: <tt>Modify(?customer[status-&gt;"Gold"])</tt>
</p>
<pre>&lt;Modify&gt;
   &lt;target&gt;
      &lt;Frame&gt;
         &lt;object&gt;
            &lt;Var&gt;&nbsp;?customer &lt;/Var&gt;
         &lt;/object&gt;
         &lt;slot ordered="yes"&gt;
            &lt;Const type="rif:iri"&gt; http://example.com/2009/prd2#status &lt;/Const&gt;
            &lt;Const type="xsd:string"&gt; Gold &lt;/Const&gt;
         &lt;/slot&gt;
      &lt;/Frame&gt;
   &lt;/target&gt;
&lt;/Modify&gt;
</pre>
<p>The action could be equivalently serialized as the sequence of a <tt>Retract</tt> and an <tt>Assert</tt> atomic actions:
</p>
<pre>&lt;Retract&gt;
   &lt;target ordered="yes"&gt;
      &lt;Var&gt;&nbsp;?customer &lt;/Var&gt;
      &lt;Const type="rif:iri"&gt; http://example.com/2009/prd2#status &lt;/Const&gt;
   &lt;/target&gt;
&lt;/Retract&gt;
&lt;Assert&gt;
   &lt;target&gt;
      &lt;Frame&gt;
         &lt;object&gt;
            &lt;Var&gt;&nbsp;?customer &lt;/Var&gt;
         &lt;/object&gt;
         &lt;slot ordered="yes"&gt;
            &lt;Const type="rif:iri"&gt; http://example.com/2009/prd2#status &lt;/Const&gt;
            &lt;Const type="xsd:string"&gt; Gold &lt;/Const&gt;
         &lt;/slot&gt;
      &lt;/Frame&gt;
   &lt;/target&gt;
&lt;/Assert&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-execute"></span>
</p>
<a id="Execute" name="Execute"></a><h5> <span class="mw-headline">8.4.1.4  Execute </span></h5>
<p>The <a href="#def-atomic-action" title="">execution of an externally defined action</a> is serialized using the <tt>Execute</tt> element.
</p><p>The <tt>Execute</tt> element has one <tt>target</tt> sub-element that contains an <tt>Atom</tt>, that represents the externally defined action to be executed. 
</p><p>The <tt>op</tt> <tt>Const</tt> in the <a href="#sec-atom" title=""><tt>Atom</tt> element</a> must be a symbol of type <tt>rif:iri</tt> that must uniquely identify the <a href="#sec-builtin-actions" title="">externally defined action</a> to be applied to the <tt>args&nbsp;TERM</tt>s.
</p>
<pre>    &lt;Execute&gt;
         &lt;target&gt; <i><b>Atom</b></i> &lt;/target&gt;
    &lt;/Execute&gt;
</pre>
<div class="example">
<p><b>Example 8.10.</b> The example shows the RIF XML serialization of the message printing action, in the <i>Unknonw status rule</i>, in the <a href="#sec-running-example" title="">running example</a>, using the <a href="#sec-act-print" title=""><tt>act:print</tt></a> action built-in.
</p><p>The namespace for RIF-PRD action built-ins is <i>http://www.w3.org/2007/rif-builtin-action#</i>.
</p>
<pre>&lt;Execute&gt;
  &lt;target&gt;
    &lt;Atom&gt;
      &lt;op&gt;
        &lt;Constant type="rif:iri"&gt; http://www.w3.org/2007/rif-builtin-action#print &lt;/Const&gt;
      &lt;/op&gt;
      &lt;args ordered="yes"&gt;
        &lt;External&gt;
          &lt;content&gt;
            &lt;Expr&gt;
              &lt;op&gt;
                &lt;Constant type="rif:iri"&gt; http://www.w3.org/2007/rif-builtin-function#concat &lt;/Const&gt;
              &lt;/op&gt;
              &lt;args ordered="yes"&gt;
                &lt;Const type="xsd:string&gt; New customer: &lt;/Const&gt;
                <var>&nbsp;?customer </var>
              &lt;/args&gt;
            &lt;/Expr&gt;
          &lt;/content&gt;
        &lt;/External&gt;
      &lt;/args&gt;
    &lt;/Atom&gt;
  &lt;/target&gt;
&lt;/Execute&gt;
</pre>
<p>☐
</p>
</div>
<a id="ACTION_BLOCK" name="ACTION_BLOCK"></a><h4> <span class="mw-headline">8.4.2  ACTION_BLOCK </span></h4>
<p>The <tt>ACTION_BLOCK</tt> class of constructs is used to represent the <a href="#sec-action-blocks" title="">conclusion, or action part, of a production rule</a> serialized using RIF-PRD.
</p><p>If action variables are declared in the action part of a rule, or if some <a href="#def-simple-action" title="">actions</a> are not assertions, the conclusion must be serialized as a full <a href="#def-action-block" title="">action block</a>, using the <tt>Do</tt> element. However, simple action blocks that contain only one or more assert actions SHOULD be serialized like the conclusions of logic rules using <a href="#ref-core" title="">RIF-Core</a> or <a href="#ref-rif-bld" title="">RIF-BLD</a>, that is, as a single asserted <tt>Atom</tt> or <tt>Frame</tt>, or as a conjunction of the asserted facts, using the <tt>And</tt> element.
</p><p>In the latter case, to conform with the <a href="#def-wf-action-block" title="">definition of an action block well-formedness</a>, the formulas that serialize the individual conjuncts MUST be atomic <tt>Atom</tt>s and/or <tt>Frame</tt>s.
</p><p>As an abstract class, <tt>ACTION_BLOCK</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>Do</b></i> | <i><b>And</b></i> | <i><b>Atom</b></i> | <i><b>Frame</b></i> ]
</pre>
<a id="New" name="New"></a><h5> <span class="mw-headline">8.4.2.1  New </span></h5>
<p>The <tt>New</tt> element is used to serialize the construct used to create a new frame identifer, in an <a href="#def-action-variable-declaration" title="">action variable declaration</a>.
</p><p>The <tt>New</tt> element is always empty.
</p>
<pre>    &lt;New /&gt;
</pre>
<a id="Do" name="Do"></a><h5> <span class="mw-headline">8.4.2.2  Do </span></h5>
<p>An <a href="#def-action-block" title="">action block</a> is serialized using the <tt>Do</tt> element.
</p><p>A <tt>Do</tt> element contains:
</p>
<ul><li> zero or more <tt>actionVar</tt> sub-elements, each of them used to serialize one <a href="#def-action-variable-declaration" title="">action variable declaration</a>. Accordingly, an <tt>actionVar</tt> element must contain a <tt>Var</tt> sub-element, that serializes the declared variable; followed by the serialization of an <a href="#def-action-variable-declaration" title="">action variable binding</a>, that assigns an initial value to the declared variable, that is: either a <tt>frame</tt> or the empty element <tt>New</tt>;
</li><li> one <tt>actions</tt> sub-element that serializes the sequence of actions in the action block, and that contains, accordingly, a sequence of one or more sub-elements of the <tt>ACTION</tt> class. The order of the actions is significant, and the order MUST be preserved, as emphasized by the required <tt>ordered="yes"</tt> attribute.
</li></ul>
<pre>    &lt;Do&gt;
       &lt;actionVar ordered="yes"&gt;
          <i><b>Var</b></i>
          [ <i><b>New</b></i> | <i><b>Frame</b></i> ]
       &lt;/actionVar&gt;*
       &lt;actions ordered="yes"&gt;
          <i><b>ACTION</b></i>+
       &lt;/actions&gt;
    &lt;/Do&gt;
</pre>
<p><span class="anchor" id="ex-511"></span>
</p>
<div class="example">
<p><b>Example 8.11.</b> The example shows the RIF XML serialization of an action block that asserts that a customer gets a new $5 voucher.
</p>
<pre>&lt;Do&gt;
   &lt;actionVar ordered="yes"&gt;
      &lt;Var&gt;?voucher&lt;/Var&gt;
      &lt;New /&gt;
   &lt;/actionVar&gt;
   &lt;actions  ordered="yes"&gt;
      &lt;Assert&gt;
         &lt;target&gt;
            &lt;Member&gt;
               &lt;instance&gt;&lt;Var&gt;?voucher&lt;/Var&gt;&lt;/instance&gt;
               &lt;class&gt;
                  &lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#Voucher&lt;/Const&gt;
               &lt;/class&gt;
            &lt;/Member&gt;
         &lt;/target&gt;
      &lt;/Assert&gt;
      &lt;Assert&gt;
         &lt;target&gt;
            &lt;Frame&gt;
               &lt;object&gt;&lt;Var&gt;?voucher&lt;/Var&gt;&lt;/object&gt;
               &lt;slot ordered="yes"&gt;
                  &lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#value&lt;/Const&gt;
                  &lt;Const type="xsd:integer"&gt;5&lt;/Const&gt;
               &lt;/slot&gt;
            &lt;/Frame&gt;
         &lt;/target&gt;
      &lt;/Assert&gt;
      &lt;Assert&gt;
         &lt;target&gt;
            &lt;Frame&gt;
               &lt;object&gt;&lt;Var&gt;?customer&lt;/Var&gt;&lt;/object&gt;
               &lt;slot ordered="yes"&gt;
                  &lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#voucher&lt;/Const&gt;
                  &lt;Var&gt;?voucher&lt;/Var&gt;
               &lt;/slot&gt;
            &lt;/Frame&gt;
         &lt;/target&gt;
      &lt;/Assert&gt;
   &lt;/actions&gt;
&lt;/Do&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-rules-and-groups"></span>
</p>
<a id="Rules_and_Groups" name="Rules_and_Groups"></a><h3> <span class="mw-headline">8.5  Rules and Groups </span></h3>
<p>This section specifies the XML constructs that are used, in RIR-PRD, to serialize <a href="#def-rule" title="">rules</a> and <a href="#def-group" title="">groups</a>. 
</p><p><span class="anchor" id="sec-RULE"></span> 
</p>
<a id="RULE" name="RULE"></a><h4> <span class="mw-headline">8.5.1  RULE </span></h4>
<p>In RIF-PRD, the <tt>RULE</tt> class of constructs is used to serialize <a href="#def-rule" title="">rules</a>, that is, unconditional as well as conditional actions, or rules with bound variables.
</p><p>As an abstract class, <tt>RULE</tt> is not associated with specific XML markup in RIF-PRD instance documents.
</p>
<pre>    [ <i><b>Implies</b></i> | <i><b>Forall</b></i> | <i><b>ACTION_BLOCK</b></i> ]
</pre>
<p><span class="anchor" id="sec-action-rule"></span> 
</p>
<a id="ACTION_BLOCK_2" name="ACTION_BLOCK_2"></a><h5> <span class="mw-headline">8.5.1.1  ACTION_BLOCK </span></h5>
<p>An <a href="#def-rule" title="">unconditional action block</a> is serialized, in RIF-PRD XML, using the <tt>ACTION_BLOCK</tt> class of construct.
</p><p><span class="anchor" id="sec-implies"></span> 
</p>
<a id="Implies" name="Implies"></a><h5> <span class="mw-headline">8.5.1.2  Implies </span></h5>
<p><a href="#def-rule" title="">Conditional actions</a> are serialized, in RIF-PRD, using the XML element <tt>Implies</tt>.
</p><p>The <tt>Implies</tt> element contains an <tt>if</tt> sub-element and a <tt>then</tt> sub-element: 
</p>
<ul><li> the required <tt>if</tt> element contains an element from the <tt>FORMULA</tt> class of constructs, that serializes the condition of the rule; 
</li><li> the required <tt>then</tt> element contains one element from the <tt>ACTION_BLOCK</tt> class of constructs, that serializes its conclusion.
</li></ul>
<pre>    &lt;Implies&gt;
       &lt;if&gt; <i><b>FORMULA</b></i> &lt;/if&gt;
       &lt;then&gt; <i><b>ACTION_BLOCK</b></i> &lt;/then&gt;
    &lt;/Implies&gt;
</pre>
<p><span class="anchor" id="sec-forall"></span>
</p>
<a id="Forall" name="Forall"></a><h5> <span class="mw-headline">8.5.1.3  Forall </span></h5>
<p>The <tt>Forall</tt> construct is used, in RIF-PRD, to represent <a href="#def-rule" title="">rules with bound variables</a>. 
</p><p>The <tt>Forall</tt> element contains: 
</p>
<ul><li> one or more <tt>declare</tt> sub-elements, each containing one <tt>Var</tt> element that represents one of the declared rule variables; 
</li><li> zero or more <tt>pattern</tt> sub-elements, each containing one element from the <tt>FORMULA</tt> group of constructs, that serializes one <a href="#def-rule" title="">pattern</a>;
</li><li> exactly one <tt>formula</tt> sub-element that serializes the formula in the scope of the variables binding, and that contains an element of the <tt>RULE</tt> group.
</li></ul>
<pre>    &lt;Forall&gt;
       &lt;declare&gt; <i><b>Var</b></i> &lt;/declare&gt;+
       &lt;pattern&gt; <i><b>FORMULA</b></i> &lt;/pattern&gt;*
       &lt;formula&gt; <i><b>RULE</b></i> &lt;/formula&gt;
    &lt;/Forall&gt;
</pre>
<p><span class="anchor" id="ex-512"></span>
</p>
<div class="example">
<p><b>Example 8.12.</b> The example shows the rule variables declaration part of the <i>Gold rule</i>, from the <a href="#sec-running-example" title="">running example</a>, as represented in <a href="#ref-ex42" title="">example 4.2</a>.
</p>
<pre>&lt;Forall&gt;
   &lt;declare&gt;&lt;Var&gt;?customer&lt;/Var&gt;&lt;/declare&gt;
   &lt;pattern&gt;
      &lt;And&gt;
         &lt;formula&gt;&lt;Member&gt; ... &lt;/Member&gt;&lt;/formula&gt;
         &lt;formula&gt;&lt;Frame&gt; ... &lt;/Frame&gt;&lt;/formula&gt;
      &lt;/And&gt;
   &lt;/pattern&gt;
   &lt;formula&gt;
      &lt;Forall&gt;
         &lt;declare&gt;&lt;Var&gt;?shoppingCart&lt;/Var&gt;&lt;/declare&gt;
         &lt;pattern&gt;&lt;Member&gt; ... &lt;/Member&gt;&lt;/pattern&gt;
         &lt;formula&gt;
            &lt;Implies&gt; ... &lt;/Implies&gt;
         &lt;/formula&gt;
      &lt;/Forall&gt;
   &lt;/formula&gt;
&lt;/Forall&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-group"></span>
</p>
<a id="Group" name="Group"></a><h4> <span class="mw-headline">8.5.2  Group </span></h4>
<p>The <tt>Group</tt> construct is used to serialize a <a href="#def-group" title="">group</a>.
</p><p>The <tt>Group</tt> element has zero or one <tt>behavior</tt> sub-element and zero or more <tt>sentence</tt> sub-elements:
</p>
<ul><li> the <tt>behavior</tt> element contains
<ul><li> zero or one <tt>ConflictResolution</tt> sub-element that contains exactly one IRI. The IRI identifies the conflict resolution strategy that is associated with the <tt>Group</tt>;
</li><li> zero or one <tt>Priority</tt> sub-element that contains exactly one signed integer between -10,000 and 10,000. The integer associates a priority with the <tt>Group</tt>'s sentences;
</li></ul>
</li><li> a <tt>sentence</tt> element contains either a <tt>Group</tt> element or an element of the <tt>RULE</tt> abstract class of constructs.
</li></ul>
<pre>    &lt;Group&gt;
       &lt;behavior&gt;
          &lt;ConflictResolution&gt; <i><b>xsd:anyURI</b></i> &lt;/ConflictResolution&gt;?
          &lt;Priority&gt; <i><b>-10,000 &le; xsd:int &le; 10,000</b></i> &lt;/Priority&gt;?
       &lt;/behavior&gt;?
       &lt;sentence&gt; [ <i><b>RULE</b></i> | <i><b>Group</b></i> ] &lt;/sentence&gt;*
    &lt;/Group&gt;
</pre>
<p><span class="anchor" id="sec-directives"></span>
</p>
<a id="Document_and_directives" name="Document_and_directives"></a><h3> <span class="mw-headline">8.6  Document and directives </span></h3>
<a id="Import" name="Import"></a><h4> <span class="mw-headline">8.6.1  Import </span></h4>
<p>The <tt>Import</tt> directive is used to serialize the reference to an RDF graph, an OWL ontology or another RIF document to be combined with a RIF document. The <tt>Import</tt> directive is inherited from [<a href="#ref-core" title="">RIF-Core</a>]. The abstract syntax and semantics of RDF graph and OWL ontology imports are specified in [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>].
</p><p>The <tt>Import</tt> directive contains:
</p>
<ul><li> exactly one <tt>location</tt> sub-element, that contains an IRI, that serializes the location of the RDF or OWL document to be combined with the RIF document;
</li><li> zero or one <tt>profile</tt> sub-element, that contains an IRI. The admitted values for that constant and their semantics are listed in the section Profiles of Imports, in [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>].
</li></ul>
<pre>    &lt;Import&gt;
       &lt;location&gt; <i><b>xsd:anyURI</b></i> &lt;/location&gt;
       &lt;profile&gt; <i><b>xsd:anyURI</b></i> &lt;/profile&gt;?
    &lt;/Import&gt;
</pre>
<p><span class="anchor" id="sec-document"></span>
</p>
<a id="Document" name="Document"></a><h4> <span class="mw-headline">8.6.2  Document </span></h4>
<p>The <tt>Document</tt> is the root element of any RIF-PRD instance document. 
</p><p>The <tt>Document</tt> contains zero or more <tt>directive</tt> sub-elements, each containing an <tt>Import</tt> directive, and zero or one <tt>payload</tt> sub-element, that must contain a <tt>Group</tt> element.
</p>
<pre>    &lt;Document&gt;
       &lt;directive&gt; <i><b>Import</b></i> &lt;/directive&gt;*
       &lt;payload&gt; <i><b>Group</b></i> &lt;/payload&gt;?
    &lt;/Document&gt;
</pre>
<p>The semantics of a document that imports RDF and/or OWL documents is specified in [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>] and [<a href="#ref-rif-bld" title="">RIF-BLD</a>]. The semantics of a document that does not import other documents is the semantics of the rule set that is serialised by the <tt>Group</tt> in the <tt>document</tt>'s <tt>payload</tt> sub-element, if any.
</p><p><br />
<span class="anchor" id="sec-constructs-carrying-no-semantics"></span>
</p>
<a id="Constructs_carrying_no_semantics" name="Constructs_carrying_no_semantics"></a><h3> <span class="mw-headline">8.7  Constructs carrying no semantics </span></h3>
<p><span class="anchor" id="sec-metadata"></span>
</p>
<a id="Annotation" name="Annotation"></a><h4> <span class="mw-headline">8.7.1  Annotation </span></h4>
<p>Annotations can be associated with any concrete class element in RIF-PRD: those are the elements with a CamelCase tagname starting with an upper-case character:
</p>
<pre>    CLASSELT = [ <i><b>TERM</b></i> | <i><b>ATOMIC</b></i> | <i><b>FORMULA</b></i> | <i><b>ACTION</b></i> | <i><b>ACTION_BLOCK</b></i> | <i><b>New</b></i> | <i><b>RULE</b></i> | <i><b>Group</b></i> | <i><b>Document</b></i> | <i><b>Import</b></i> ]
</pre>
<p>An identifier can be associated to any instance element of the abstract <tt>CLASSELT</tt> class of constructs, as an optional <tt>id</tt> sub-element that MUST contain a <tt>Const</tt> of type <tt>rif:iri</tt>.
</p><p>Annotations can be included in any instance of a concrete class element using the <tt>meta</tt> sub-element.
</p><p>The <tt>Frame</tt> construct is used to serialize annotations: the content of the <tt>Frame</tt>'s <tt>object</tt> sub-element identifies the object to which the annotation is associated:, and the <tt>Frame</tt>'s <tt>slot</tt>s represent the annotation properly said as property-value pairs.
</p><p>If all the annotations are related to the same object, the <tt>meta</tt> element can contain a single <tt>Frame</tt> sub-element. If annotations related to several different objects need be serialized, the <tt>meta</tt> role element can contain an <tt>And</tt> element with zero or more <tt>formula</tt> sub-elements, each containing one <tt>Frame</tt> element, that serializes the annotations relative to one identified object.
</p>
<pre>   &lt;<i>any concrete element in CLASSELT</i>&gt;
       &lt;id&gt; <i><b>Const</b></i> &lt;/id&gt;?
       &lt;meta&gt;
          [ <i><b>Frame</b></i> 
            |
            &lt;And&gt;
               &lt;formula&gt; <i><b>Frame</b></i> &lt;/formula&gt;*
            &lt;/And&gt;
          ]
       &lt;/meta&gt;?
       <i><b>other CLASSELT content</b></i>
    &lt;/<i>any concrete element in CLASSELT</i>&gt;
</pre>
<p>Notice that the content of the <tt>meta</tt> sub-element of an instance of a RIF-PRD class element is not necessarily associated to that same instance element: only the content of the <tt>object</tt> sub-element of the <tt>Frame</tt> that represents the annotations specifies what the annotations are about, not where it is included in the instance RIF document.
</p><p>It is suggested to use Dublin Core, RDFS, and OWL properties for annotations, along the lines of <a class="external free" href="http://www.w3.org/TR/owl-ref/#Annotations" rel="nofollow" title="http://www.w3.org/TR/owl-ref/#Annotations">http://www.w3.org/TR/owl-ref/#Annotations</a> -- specifically owl:versionInfo,  rdfs:label, rdfs:comment, rdfs:seeAlso, rdfs:isDefinedBy, dc:creator, dc:description, dc:date, and foaf:maker.
</p><p><span class="anchor" id="ex-513"></span>
</p>
<div class="example">
<p><b>Example 8.13.</b> The example shows the structure of the document that contains the <a href="#sec-running-example" title="">runnig example rule set</a>, as represented in <a href="#ref-ex42" title="">example 4.2</a>, including annotations such as rule set and rule names.
</p>
<pre>&lt;Document&gt;
  &lt;payload&gt;
    &lt;Group&gt;
      &lt;id&gt;&lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#CheckoutRuleSet&lt;/Const&gt;&lt;/id&gt;
      &lt;meta&gt;
        &lt;Frame&gt;
          &lt;object&gt;&lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#CheckoutRuleSet&lt;/Const&gt;&lt;/object&gt;
          &lt;slot ordered="yes"&gt;
            &lt;Const type="rif:iri"&gt;http://dublincore.org/documents/dcmi-namespace/#creator&lt;/Const&gt;
            &lt;Const type="xsd:string&gt;W3C RIF WG&lt;/Const&gt;
          &lt;/slot&gt;
          &lt;slot&gt;
            &lt;Const type="rif:iri"&gt;http://dublincore.org/documents/dcmi-namespace/#description&lt;/Const&gt;
            &lt;Const type="xsd:string"&gt;Running example rule set from the RIF-PRD specification&lt;/Const&gt;
          &lt;/slot&gt;
        &lt;/Frame&gt;
      &lt;/meta&gt;
      &lt;behavior&gt; ... &lt;/behavior&gt;
      &lt;sentence&gt;
        &lt;Group&gt;
          &lt;id&gt;&lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#GoldRule&lt;/Const&gt;&lt;/id&gt;
          &lt;behavior&gt; ... &lt;/behavior&gt;
          &lt;sentence&gt;&lt;Forall&gt; ... &lt;/Forall&gt;&lt;/sentence&gt;
        &lt;/Group&gt;
      &lt;/sentence&gt;
      &lt;sentence&gt;
        &lt;Group&gt;
          &lt;id&gt;&lt;Const type="rif:iri"&gt;http://example.com/2009/prd2#DiscountRule&lt;/Const&gt;&lt;/id&gt;
          &lt;sentence&gt;&lt;Forall&gt; ... &lt;/Forall&gt;&lt;/sentence&gt;
        &lt;/Group&gt;
      &lt;/sentence&gt;
    &lt;/Group&gt;
  &lt;/payload&gt;
&lt;/Document&gt;
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-presentation-syntax"></span>
</p>
<a id="Presentation_syntax_.28Informative.29" name="Presentation_syntax_.28Informative.29"></a><h2> <span class="mw-headline">9  Presentation syntax (Informative) </span></h2>
<p>To make it easier to read, a non-normative, lightweight notation was introduced to complement the mathematical English specification of the abstract syntax and the semantics of RIF-PRD. This section specifies a presentation syntax for RIF-PRD, that extends that notation. The presentation syntax is not normative. However, it may help implementers by providing a more succinct overview of RIF-PRD syntax.
</p><p>The EBNF for the RIF-PRD presentation syntax is given as follows. For convenience of reading we show the entire EBNF in its four parts (rules, conditions, actions, and annotations). 
</p><p><span class="anchor" id="part-rule-language"></span>
<b>Rule Language:</b>
</p>
<pre>  Document      &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base          &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'
  Prefix        &nbsp;::= 'Prefix' '(' Name ANGLEBRACKIRI ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group         &nbsp;::= IRIMETA? 'Group' Strategy? Priority? '(' (RULE | Group)* ')'
  Strategy      &nbsp;::= Const
  Priority      &nbsp;::= Const
  RULE          &nbsp;::= (IRIMETA? 'Forall' Var+ (' such that ' FORMULA+)?  '(' RULE ')') | CLAUSE
  CLAUSE        &nbsp;::= Implies | ACTION_BLOCK 
  Implies       &nbsp;::= IRIMETA? 'If' FORMULA 'Then' ACTION_BLOCK
  LOCATOR       &nbsp;::= ANGLEBRACKIRI
  PROFILE       &nbsp;::= ANGLEBRACKIRI
</pre>
<p><span class="anchor" id="part-action-language"></span>
<b>Action Language:</b>
</p>
<pre>  ACTION &nbsp;::= IRIMETA? (Assert | Retract | Modify | Execute )
  Assert        &nbsp;::= 'Assert' '(' IRIMETA? (Atom | Frame | Member) ')'
  Retract       &nbsp;::= 'Retract' '(' ( IRIMETA? (Atom | Frame) | TERM | TERM TERM ) ')'
  Modify        &nbsp;::= 'Modify'  '(' IRIMETA? Frame ')'
  Execute       &nbsp;::= 'Execute' '(' IRIMETA? Atom ')' 
  ACTION_BLOCK  &nbsp;::= IRIMETA? ('Do (' ('(' IRIMETA? Var IRIMETA? (Frame | 'New()') ')')* ACTION+  ')' |
                     'And (' ( IRIMETA? (Atom | Frame) )* ')' | Atom | Frame)
</pre>
<p><span class="anchor" id="part-condition-language"></span>
<b>Condition Language:</b>
</p>
<pre>  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' (IRIMETA? Var)+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? NEGATEDFORMULA  |
                     IRIMETA? Equal |
                     IRIMETA? Member |
                     IRIMETA? Subclass | 
                     IRIMETA? 'External' '(' IRIMETA? Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= (IRIMETA? Const) '(' (TERM* ')'
  GROUNDUNITERM &nbsp;::= (IRIMETA? Const) '(' (GROUNDTERM* ')'
  NEGATEDFORMULA&nbsp;::= 'Not' '(' FORMULA ')' | 'INeg' '(' FORMULA ')' 
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Subclass      &nbsp;::= TERM '##' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | List | 'External' '(' Expr ')')
  GROUNDTERM    &nbsp;::= IRIMETA? (Const | List | 'External' '(' GROUNDUNITERM ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' GROUNDTERM* ')'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= NCName
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
</pre>
<p><br />
<span class="anchor" id="part-annotations"></span>
<b>Annotations:</b>
</p>
<pre>  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
</pre>
<p>A NEGATEDFORMULA can be written using either <i>Not</i> or <i>INeg</i>.  <i>INeg</i> is short for <i>inflationary negation</i> and is preferred over 'Not' to avoid ambiguity about the semantics of the negation.
</p><p>The RIF-PRD presentation syntax does not commit to any particular vocabulary and permits arbitrary Unicode strings in constant symbols, argument names, and variables. Constant symbols can have this form: <tt>"UNICODESTRING"^^SYMSPACE</tt>, where <tt>SYMSPACE</tt> is an <tt>ANGLEBRACKIRI</tt> or <tt>CURIE</tt> that represents the identifier of the symbol space of the constant, and <tt>UNICODESTRING</tt> is a Unicode string from the lexical space of that symbol space. <tt>ANGLEBRACKIRI</tt> and <tt>CURIE</tt> are defined in the section Shortcuts for Constants in RIF's Presentation Syntax in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Constant symbols can also have several shortcut forms, which are represented by the non-terminal <tt>CONSTSHORT</tt>. These shortcuts are also defined in the same section of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. One of them is the <tt>CURIE</tt> shortcut, which is extensively used in the examples in this document.
Names are XML <tt>NCName</tt>s. Variables are composed of <tt>NCName</tt> symbols prefixed with a <tt>?</tt>-sign.
</p>
<div class="example">
<p><b>Example 9.1.</b> Here is the transcription, in the RIF-PRD presentation syntax, of the complete RIF-PRD document corresponding to the <a href="#sec-running-example" title="">running example</a>:
</p>
<pre>Document(

Prefix( ex1 &lt;http://example.com/2009/prd2&gt; )

(* ex1:CheckoutRuleset *)
Group  (
  (* ex1:GoldRule *)
  Group  (
    Forall&nbsp;?customer such that And(?customer # ex1:Customer
                                  &nbsp;?customer[ex1:status -&gt; "Silver"])
      (Forall&nbsp;?shoppingCart such that&nbsp;?customer[ex1:shoppingCart -&gt;&nbsp;?shoppingCart]
         (If Exists&nbsp;?value (And(?shoppingCart[ex1:value -&gt;&nbsp;?value]
                                External(pred:numeric-greater-than-or-equal(?value 2000))))
          Then Do(Modify(?customer[ex1:status -&gt; "Gold"])))))

  (* ex1:DiscountRule *)
  Group (
    Forall&nbsp;?customer such that&nbsp;?customer # ex1:Customer
      (If Or(&nbsp;?customer[ex1:status -&gt; "Silver"]
             &nbsp;?customer[ex1:status -&gt; "Gold"])
       Then Do ((?s&nbsp;?customer[ex1:shoppingCart -&gt; &nbsp;?s])
                (?v&nbsp;?s[ex1:value -&gt;&nbsp;?v])
                Modify(?s [ex1:value -&gt; External(func:numeric-multiply (?v 0.95))]))))

  (* ex1:NewCustomerAndWidgetRule *)
  Group (
    Forall&nbsp;?customer such that And(?customer # ex1:Customer
                                   &nbsp;?customer[ex1:status -&gt; "New"] )
      (If Exists&nbsp;?shoppingCart&nbsp;?item
                 (And(?customer[ex1:shoppingCart -&gt;&nbsp;?shoppingCart]
                     &nbsp;?shoppingCart[ex1:containsItem -&gt;&nbsp;?item]
                     &nbsp;?item # ex1:Widget ) )
       Then Do( (?s&nbsp;?customer[ex1:shoppingCart -&gt;&nbsp;?s])
                (?val&nbsp;?s[ex1:value -&gt;&nbsp;?val])
                Retract(?customer ex1:voucher)
                Modify(?s[ex1:value -&gt; External(func:numeric-multiply(?val 0.90))]))))

  (* ex1:UnknownStatusRule *)
  Group (
    Forall&nbsp;?customer such that&nbsp;?customer # ex1:Customer
      (If Not(Exists&nbsp;?status
                     (And(?customer[ex1:status -&gt;&nbsp;?status]
                          External(pred:list-contains(List("New" "Bronze" "Silver" "Gold")&nbsp;?status)) )))
       Then Do( Execute(act:print(External(func:concat("New customer: "&nbsp;?customer))))
                Assert(?customer[ex1:status -&gt; "New"]))))
 )
)
</pre>
<p>☐
</p>
</div>
<p><span class="anchor" id="sec-acknowledgements"></span>
</p>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">10  Acknowledgements </span></h2>
<p>This document is the product of the Rules Interchange Format (RIF) Working Group (see below) whose 
members deserve recognition for their time and commitment.  The editors extend special thanks to Harold Boley and Changhai Ke for their thorough reviews and insightful discussions; the working group chairs, Chris Welty and Christian de Sainte Marie, for their invaluable technical help and inspirational leadership; and W3C staff contact Sandro Hawke, a constant source of ideas, help, and feedback.
</p><p><br />
The regular attendees at meetings of the Rule Interchange Format (RIF) Working Group at the time of the publication were:
Adrian Paschke (Freie Universitaet Berlin), 
Axel Polleres (DERI),
Chris Welty (IBM), 
Christian de Sainte Marie (IBM), 
Dave Reynolds (HP), 
Gary Hallmark (ORACLE), 
Harold Boley (NRC), 
Jos de Bruijn (FUB),
Leora Morgenstern (IBM), 
Michael Kifer (Stony Brook), 
Mike Dean (BBN), 
Sandro Hawke (W3C/MIT), and
Stella Mitchell (IBM).
</p><p><span class="anchor" id="sec-references"></span>
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">11  References </span></h2>
<a id="Normative_references" name="Normative_references"></a><h3> <span class="mw-headline">11.1  Normative references </span></h3>
<p><span class="anchor" id="ref-prr"></span> 
</p>
<dl><dt> [OMG-PRR]
</dt><dd> <i><a class="external text" href="http://www.omg.org/spec/PRR/1.0/Beta1/" rel="nofollow" title="http://www.omg.org/spec/PRR/1.0/Beta1/">Production Rule Representation (PRR)</a></i>, OMG specification, version 1.0, 2007. 
</dd></dl>
<p><span class="anchor" id="ref-rdf-concepts"></span> 
</p>
<dl><dt> [RDF-CONCEPTS]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax</i>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-schema"></span> 
</p>
<dl><dt> [RDF-SCHEMA]
</dt><dd> <i>RDF Vocabulary Description Language 1.0: RDF Schema</i>, Brian McBride, Editor, W3C Recommendation 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/">http://www.w3.org/TR/2004/REC-rdf-schema-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-schema/" rel="nofollow" title="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rfc-3066"></span> 
</p>
<dl><dt> [RFC-3066]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3066" title="http://tools.ietf.org/html/rfc3066">RFC 3066</a> - Tags for the Identification of Languages</i>, H. Alvestrand, IETF, January 2001, at <a class="external free" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">http://www.ietf.org/rfc/rfc3066</a>.
</dd></dl>
<p><span class="anchor" id="ref-rfc-3987"></span> 
</p>
<dl><dt> [RFC-3987]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3987" title="http://tools.ietf.org/html/rfc3987">RFC 3987</a> - Internationalized Resource Identifiers (IRIs)</i>, M. Duerst and M. Suignard, IETF, January 2005, <a class="external free" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-bld"></span>
</p>
<dl><dt> [RIF-BLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/"><span>RIF Basic Logic Dialect (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-core"></span>
</p>
<dl><dt> [RIF-Core]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/"><span>RIF Core Dialect (Second Edition)</span></a></cite> Harold Boley, Gary Hallmark, Michael Kifer, Adrian Paschke, Axel Polleres, Dave Reynolds, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-dtb"></span> 
</p>
<dl><dt> [RIF-DTB]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-fld"></span> 
</p>
<dl><dt> [RIF-FLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/"><span>RIF Framework for Logic Dialects (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">http://www.w3.org/TR/2013/REC-rif-fld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-fld/">http://www.w3.org/TR/rif-fld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-rdf-owl"></span> 
</p>
<dl><dt> [RIF-RDF-OWL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/"><span>RIF RDF and OWL Compatibility (Second Edition)</span></a></cite> Jos de Bruijn, Chris Welty, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-xdm"></span> 
</p>
<dl><dt> [XDM]
</dt><dd> <i>XQuery 1.0 and XPath 2.0 Data Model (XDM)</i>, W3C Recommendation, World Wide Web Consortium, 23 January 2007. This version is <a class="external free" href="http://www.w3.org/TR/2007/REC-xpath-datamodel-20070123/" rel="nofollow" title="http://www.w3.org/TR/2007/REC-xpath-datamodel-20070123/">http://www.w3.org/TR/2007/REC-xpath-datamodel-20070123/</a>.  Latest version available at <a class="external free" href="http://www.w3.org/TR/xpath-datamodel/" rel="nofollow" title="http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.
</dd></dl>
<p><span class="anchor" id="xml-base"></span> 
</p>
<dl><dt> [XML-Base]
</dt><dd> <i>XML Base (second edition)</i>, W3C Recommendation, World Wide Web Consortium, 28 January 2009, <a class="external free" href="http://www.w3.org/TR/2009/REC-xmlbase-20090128/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-xmlbase-20090128/">http://www.w3.org/TR/2009/REC-xmlbase-20090128/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/xmlbase/" rel="nofollow" title="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-schema2"></span> 
</p>
<dl><dt> [XML-SCHEMA2]
</dt><dd> <i>XML Schema Part 2: Datatypes Second Edition</i>, W3C Recommendation, World Wide Web Consortium, 28 October 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</a>. Latest version available at  <a class="external free" href="http://www.w3.org/TR/xmlschema-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xpath-functions"></span> 
</p>
<dl><dt> [XPath-Functions]
</dt><dd> <i>XQuery 1.0 and XPath 2.0 Functions and Operators</i>, W3C Recommendation, World Wide Web Consortium, 23 January 2007, <a class="external free" href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/" rel="nofollow" title="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">http://www.w3.org/TR/2007/REC-xpath-functions-20070123/</a>. Latest version available at  <a class="external free" href="http://www.w3.org/TR/xpath-functions/" rel="nofollow" title="http://www.w3.org/TR/xpath-functions/">http://www.w3.org/TR/xpath-functions/</a>.
</dd></dl>
<a id="Informational_references" name="Informational_references"></a><h3> <span class="mw-headline">11.2  Informational references </span></h3>
<p><span class="anchor" id="ref-matching"></span> 
</p>
<dl><dt> [CIR04]
</dt><dd> <i><a class="external text" href="http://hal.inria.fr/docs/00/28/09/38/PDF/rete.formalisation.pdf" rel="nofollow" title="http://hal.inria.fr/docs/00/28/09/38/PDF/rete.formalisation.pdf">Production Systems and Rete Algorithm Formalisation</a></i>, Cirstea H., Kirchner C., Moossen M., Moreau P.-E. Rapport de recherche n&deg; inria-00280938 - version 1 (2004).
</dd></dl>
<p><span class="anchor" id="ref-curie"></span> 
</p>
<dl><dt> [CURIE]
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">CURIE Syntax 1.0</a></cite>, S. McCarron, M. Birbeck,  Editors, W3C Working Group Note, 16 December 2010, <a class="external free" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">http://www.w3.org/TR/2010/NOTE-curie-20101216</a> . Latest version available at <a class="external free" href="http://www.w3.org/TR/curie" rel="nofollow" title="http://www.w3.org/TR/curie">http://www.w3.org/TR/curie</a>.
</dd></dl>
<p><br />
<span class="anchor" id="ref-enderton01"></span> 
</p>
<dl><dt> [Enderton01]
</dt><dd> <i>A Mathematical Introduction to Logic, Second Edition</i>, H. B. Enderton. Academic Press, 2001.
</dd></dl>
<p><span class="anchor" id="ref-fitting"></span> 
</p>
<dl><dt> [FIT02]
</dt><dd> <i><a class="external text" href="http://ii.fmph.uniba.sk/~sefranek/links/FixPointSurvey.pdf" rel="nofollow" title="http://ii.fmph.uniba.sk/~sefranek/links/FixPointSurvey.pdf">Fixpoint Semantics for Logic Programming: A Survey</a></i>, Melvin Fitting, Theoretical Computer Science. Vol. 278, no. 1-2, pp. 25-51. 6 May 2002.
</dd></dl>
<p><span class="anchor" id="ref-substitution"></span> 
</p>
<dl><dt> [HAK07]
</dt><dd> <i><a class="external text" href="http://www.cs.brown.edu/people/pvh/CPL/Papers/v1/hak.pdf" rel="nofollow" title="http://www.cs.brown.edu/people/pvh/CPL/Papers/v1/hak.pdf">Data Models as Constraint Systems: A Key to the Semantic Web</a></i>, Hassan Ait-Kaci, Constraint Programming Letters, 1:33--88, 2007.
</dd></dl>
<p><span class="anchor" id="ref-klw95"></span> 
</p>
<dl><dt> [KLW95]
</dt><dd> <i>Logical foundations of object-oriented and frame-based languages,</i> M. Kifer, G. Lausen, J. Wu. Journal of ACM, July 1995, pp. 741--843.
</dd></dl>
<p><span class="anchor" id="ref-mendelson97"></span> 
</p>
<dl><dt> [Mendelson97]
</dt><dd> <i>Introduction to Mathematical Logic, Fourth Edition</i>, E. Mendelson. Chapman &amp; Hall, 1997.
</dd></dl>
<p><span class="anchor" id="ref-ltts"></span> 
</p>
<dl><dt> [PLO04]
</dt><dd> <i><a class="external text" href="http://homepages.inf.ed.ac.uk/gdp/publications/sos_jlap.pdf" rel="nofollow" title="http://homepages.inf.ed.ac.uk/gdp/publications/sos_jlap.pdf">A Structural Approach to Operational Semantics</a></i>, Gordon D. Plotkin, Journal of Logic and Algebraic Programming,  Volumes 60-61, Pages 17-139 (July - December 2004). 
</dd></dl>
<p><span class="anchor" id="appendix-model-theory"></span>
</p>
<a id="Appendix:_Model-theoretic_semantics_of_RIF-PRD_condition_formulas" name="Appendix:_Model-theoretic_semantics_of_RIF-PRD_condition_formulas"></a><h2> <span class="mw-headline">12  Appendix: Model-theoretic semantics of RIF-PRD condition formulas </span></h2>
<p>This appendix provides an alternative specification of the <a href="#sec-semantics-of-condition-formulas" title="">Semantics of condition formulas</a>, and it is also normative.
</p><p>This alternative specification is provided for the convenience of the reader, for compatibility with other RIF specifications, such as [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and [<a href="#ref-rif-rdf-owl" title="">RIF-RDF-OWL</a>], and to make explicit the interoperability with RIF logic dialects, in particular [<a href="#ref-core" title="">RIF-Core</a>] and [<a href="#ref-rif-bld" title="">RIF-BLD</a>].
</p><p><span class="anchor" id="sec-semantic-structures"></span> 
</p>
<a id="Semantic_structures" name="Semantic_structures"></a><h4> <span class="mw-headline">12.1  Semantic structures </span></h4>
<p>The key concept in a model-theoretic semantics of a logic language is the notion of a semantic structure [Enderton01, Mendelson97].
</p><p><span class="anchor" id="def-sem-struct"></span> 
<b>Definition (Semantic structure)</b>.
A <i><b>semantic structure</b></i>, <i><b>I</b></i>, is a tuple of the form
&lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>list</sub>,
<i><b>I</b></i><sub>P</sub>, <i><b>I</b></i><sub>frame</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>,
<i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;. Here <i><b>D</b></i> is a non-empty set of elements called the <i><b>Herbrand domain</b></i> of <i><b>I</b></i>, that is, the set of all ground terms which can be formed by using the elements of <tt>Const</tt>. <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub> are nonempty subsets of <i><b>D</b></i>. <i><b>D</b></i><sub>ind</sub> is used to interpret the elements of <tt>Const</tt> that are individuals and <i><b>D</b></i><sub>func</sub> is used to interpret the elements of <tt>Const</tt> that are function symbols. <tt>Const</tt> denotes the set of all constant symbols and <tt>Var</tt> the set of all variable symbols. <i><b>TV</b></i> denotes the set of truth values that the semantic structure uses and <i><b>DTS</b></i> is a set of identifiers for primitive datatypes (please refer to Section Datatypes in the RIF data types and builtins specification [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] for the semantics of datatypes).
</p><p>As far as the assignment of a standard meaning to formulas in the RIF-PRD condition language is concerned, the set <i><b>TV</b></i> of truth values consists of just two values, <b>t</b> and <b>f</b>.
</p><p>The other components of <i><b>I</b></i> are <i>total</i> mappings defined as follows: 
</p>
<ol>
  <li>
    <i><b>I</b></i><sub>C</sub> maps <tt>Const</tt> to <i><b>D</b></i>.
    <p>
      This mapping interprets constant symbols. In addition:
    </p>
    <ul>
      <li>
	If a constant, <tt>c</tt>&nbsp;&isin;&nbsp;<tt>Const</tt>,
	is an <i>individual</i> then it is required that
	<i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;&isin;&nbsp;<i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>
	If <tt>c</tt>&nbsp;&isin;&nbsp;<tt>Const</tt>, is a <i>function symbol</i> then it is required that <i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;&isin;&nbsp;<i><b>D</b></i><sub>func</sub>.
      </li>
    </ul>
  </li>
  <li>
    <i><b>I</b></i><sub>V</sub> maps <tt>Var</tt> to <i><b>D</b></i><sub>ind</sub>.
    <p>This mapping interprets variable symbols.</p>
  </li>
  <li><i><b>I</b></i><sub>list</sub>&nbsp;: <i><b>D</b></i><sub>ind</sub><sup>*</sup> &rarr; <i><b>D</b></i><sub>ind</sub> is used to interpret lists. 
     <p>
        In addition, this mapping is required to satisfy the following conditions:
     </p>
     <ul>     
       <li>
	 <i><b>I</b></i><sub>list</sub> is an injective one-to-one function.
       </li>
       <li>
	 <i><b>I</b></i><sub>list</sub>(<i><b>D</b></i><sub>ind</sub>) is disjoint from the value spaces of all data types in <i><b>DTS</b></i>.
       </li>
     </ul>
  </li>
  <li>
    <i><b>I</b></i><sub>P</sub> maps <i><b>D</b></i> to functions <i><b>D*</b></i><sub>ind</sub> &rarr; <i><b>D</b></i> (here <i><b>D*</b></i><sub>ind</sub> is a set of all sequences of any finite length over the domain <i><b>D</b></i><sub>ind</sub>).
    <p>This mapping interprets positional terms atoms.</p>
  </li>
  <li><i><b>I</b></i><sub>frame</sub> maps <i><b>D</b></i><sub>ind</sub> to total functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>) &rarr; <i><b>D</b></i>.
    <p>This mapping interprets frame terms. An argument, <tt>d</tt>&nbsp;? <i><b>D</b></i><sub>ind</sub>, to <i><b>I</b></i><sub>frame</sub> represents an object and the finite bag {&lt;<tt>a1,v1</tt>&gt;, ..., &lt;<tt>ak,vk</tt>&gt;} represents a bag of attribute-value pairs for <tt>d</tt>. We will see shortly how <i><b>I</b></i><sub>frame</sub> is used to determine the truth valuation of frame terms. </p>
    <p>Bags (multi-sets) are used here because the order of the attribute/value pairs in a frame is immaterial and pairs may repeat. Such repetitions arise naturally when variables are instantiated with constants. For instance, <tt>o[?A-&gt;?B&nbsp;?C-&gt;?D]</tt> becomes <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> if variables <tt>?A</tt> and <tt>?C</tt> are instantiated with the symbol <tt>a</tt> while <tt>?B</tt> and <tt>?D</tt> are instantiated with <tt>b</tt>. (We shall see later that <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> is equivalent to <tt>o[a-&gt;b]</tt>.)
    </p>
  </li>
  <li><i><b>I</b></i><sub>sub</sub> gives meaning to the subclass relationship. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>The operator <tt>##</tt> is required to be transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> must imply <tt>c1&nbsp;##&nbsp;c3</tt>. This is ensured by a restriction in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of condition formulas</a>; </p>
  </li>
  <li><i><b>I</b></i><sub>isa</sub> gives meaning to class membership. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>The relationships <tt>#</tt> and <tt>##</tt> are required to have the usual property that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> must imply <tt>o&nbsp;#&nbsp;scl</tt>. This is ensured by a restriction in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of condition formulas</a>; </p>
  </li>
  <li><i><b>I</b></i><sub>=</sub> is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>It gives meaning to the equality operator.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>truth</sub> is a mapping of the form <i><b>D</b></i> &rarr; <i><b>TV</b></i>.
     <p>It is used to define truth valuation for formulas.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>external</sub> is a mapping from the coherent set of schemas for externally defined functions to total functions <i><b>D</b></i>* &rarr; <i><b>D</b></i>. For each external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;)</tt> in the coherent set of external schemas associated with the language, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is a function of the form <i><b>D</b></i><sup>n</sup> &rarr; <i><b>D</b></i>.
    <p>
      For every external schema, <tt>&sigma;</tt>,  associated with the language, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is assumed to be specified externally in some document (hence the name <i>external schema</i>). In particular, if <tt>&sigma;</tt> is a schema of a RIF built-in predicate, function or action, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is specified so that:
    </p>
      <ul>
        <li>
          If <tt>&sigma;</tt> is a schema of a built-in function then <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) must be the function defined  in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>];
        </li>
        <li>
          If <tt>&sigma;</tt> is a schema of a built-in predicate then 
          <i><b>I</b></i><sub>truth</sub><tt> &omicron; </tt>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)) (the composition of <i><b>I</b></i><sub>truth</sub> and <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>), a truth-valued function) must be as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>];
        </li>
        <li>
          If <tt>&sigma;</tt> is a schema of a built-in action then 
          <i><b>I</b></i><sub>truth</sub><tt> &omicron; </tt>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)) (the composition of <i><b>I</b></i><sub>truth</sub> and <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>), a truth-valued function) must be as specified in the <a href="#sec-builtin-actions" title="">section Built-in actions</a> in this document.
        </li>
      </ul>
  </li>
</ol>
<p>For convenience, we also define the following mapping <i><b>I</b></i> from terms to <i><b>D</b></i>: 
</p>
<ul><li> <i><b>I</b></i>(<tt>k</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>k</tt>), if <tt>k</tt> is a symbol in <tt>Const</tt>;
</li><li> <i><b>I</b></i>(<tt>?v</tt>) = <i><b>I</b></i><sub>V</sub>(<tt>?v</tt>), if <tt>?v</tt> is a variable in <tt>Var</tt>;
</li><li> For list terms, the mapping is defined as follows:
<ul><li> <i><b>I</b></i>(<tt>List( )</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>&lt;&gt;</tt>). Here <tt>&lt;&gt;</tt> denotes an empty list of elements of <i><b>D</b></i><sub>ind</sub>. (Note that the domain of <i><b>I</b></i><sub>list</sub> is <i><b>D</b></i><sub>ind</sub><sup>*</sup>, so <i><b>D</b></i><sub>ind</sub><sup>0</sup> is an empty list of elements of <i><b>D</b></i><sub>ind</sub>.)
</li><li> <i><b>I</b></i>(<tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>n</sub>)) = <i><b>I</b></i><sub>list</sub>(<i><b>I</b></i>(<tt>t</tt><sub>1</sub>), ..., <i><b>I</b></i>(<tt>t</tt><sub>n</sub>)), if <tt>n&gt;0</tt>. 
</li></ul>
</li><li> <i><b>I</b></i>(<tt>p(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>P</sub>(<i><b>I</b></i>(<tt>p</tt>))(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>),...,<i><b>I</b></i>(<tt>t<sub>n</sub></tt>));
</li><li> <i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>))({&lt;<i><b>I</b></i>(<tt>a<sub>1</sub></tt>),<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;, ..., &lt;<i><b>I</b></i>(<tt>a<sub>n</sub></tt>),<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})<br />Here {...} denotes a bag of attribute/value pairs.
</li><li> <i><b>I</b></i>(<tt>c1##c2</tt>) = <i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i>(<tt>c1</tt>), <i><b>I</b></i>(<tt>c2</tt>));
</li><li> <i><b>I</b></i>(<tt>o#c</tt>) = <i><b>I</b></i><sub>isa</sub>(<i><b>I</b></i>(<tt>o</tt>), <i><b>I</b></i>(<tt>c</tt>));
</li><li> <i><b>I</b></i>(<tt>x=y</tt>) = <i><b>I</b></i><sub>=</sub>(<i><b>I</b></i>(x), <i><b>I</b></i>(y));
</li><li> <i><b>I</b></i>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>)), if <tt>t</tt> is an instance of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.<br />Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instance of an external schema. Furthermore, by the definition of coherent sets of external schemas, <tt>t</tt> can be an instance of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined.
</li></ul>
<p><i><b>The effect of datatypes.</b></i> The set <i><b>DTS</b></i> must include the datatypes described in Section Primitive Datatypes of the RIF data types and builtins specification [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>The datatype identifiers in <i><b>DTS</b></i> impose the following restrictions. Given <tt>dt</tt> &isin; <i><b>DTS</b></i>, let <i><b>LS</b></i><sub>dt</sub> denote the lexical space of <tt>dt</tt>, <i><b>VS</b></i><sub>dt</sub> denote its value space, and <i><b>L</b></i><sub>dt</sub>: <i><b>LS</b></i><sub>dt</sub> &rarr; <i><b>VS</b></i><sub>dt</sub> the lexical-to-value-space mapping (for the definitions of these concepts, see Section Primitive Datatypes of the RIF data types and builtins specification [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Then the following must hold: 
</p>
<ul><li> <i><b>VS</b></i><sub>dt</sub> &sube; <i><b>D</b></i><sub>ind</sub>; and
</li><li> For each constant <tt>"lit"^^dt</tt> such that <tt>lit</tt> &isin; <i><b>LS</b></i><sub>dt</sub>, <i><b>I</b></i><sub>C</sub>(<tt>"lit"^^dt</tt>) = <i><b>L</b></i><sub>dt</sub>(<tt>lit</tt>). 
</li></ul>
<p>That is, <i><b>I</b></i><sub>C</sub> must map the constants of a datatype <tt>dt</tt> in accordance with <i><b>L</b></i><sub>dt</sub>. 
</p><p>RIF-PRD does not impose restrictions on <i><b>I</b></i><sub>C</sub> for constants in symbol spaces that are not datatypes included in <i><b>DTS</b></i>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="sec-interpretation-of-formulas"></span>
</p>
<a id="Interpretation_of_condition_formulas" name="Interpretation_of_condition_formulas"></a><h4> <span class="mw-headline">12.2  Interpretation of condition formulas </span></h4>
<p>This section defines how a semantic structure, <i><b>I</b></i>, determines
the truth value <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>)  of a condition formula, <tt>&phi;</tt>.
</p><p>We define a mapping, <i>TVal</i><sub>I</sub>, from the set of all condition formulas to <i><b>TV</b></i>. Note that the definition implies that <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) is defined <em>only if</em> the set <i><b>DTS</b></i> of the datatypes of <i><b>I</b></i> includes all the datatypes mentioned in <tt>&phi;</tt> and <i><b>I</b></i><sub>external</sub> is defined on all externally defined functions and predicates in <tt>&phi;</tt>. 
</p><p><span class="anchor" id="def-bld-truth"></span> 
<b>Definition (Truth valuation)</b>.
<i><b>Truth valuation</b></i> for well-formed condition formulas in RIF-PRD is determined using the following function, denoted <i>TVal</i><sub>I</sub>:
</p>
<ul><li> <i>Positional atomic formulas</i>: <i>TVal</i><sub>I</sub>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>));
</li><li> <i>Equality</i>: <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)).<br />To ensure that equality has precisely the expected properties, it is required that:
<ul><li> <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>t</b> if <i><b>I</b></i>(<tt>x</tt>) = <i><b>I</b></i>(<tt>y</tt>) and that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>f</b> otherwise. This is tantamount to saying that <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <b>t</b> iff <i><b>I</b></i>(x) = <i><b>I</b></i>(y);
</li></ul>
</li><li> <i>Subclass</i>: <i>TVal</i><sub>I</sub>(<tt>sc&nbsp;##&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>sc&nbsp;##&nbsp;cl</tt>)).<br />To ensure that the operator <tt>##</tt> is transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>, the following is required:
<ul><li> For all <tt>c1</tt>, <tt>c2</tt>, <tt>c3</tt> &isin; <i><b>D</b></i>, &nbsp; if <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c2</tt>) = <i>TVal</i><sub>I</sub>(<tt>c2&nbsp;##&nbsp;c3</tt>)&nbsp;=&nbsp;<b>t</b> &nbsp; then <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c3</tt>)&nbsp;=&nbsp;<b>t</b>;
</li></ul>
</li><li> <i>Membership</i>: <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o&nbsp;#&nbsp;cl</tt>)).<br />To ensure that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> implies <tt>o&nbsp;#&nbsp;scl</tt>, the following is required:
<ul><li> For all <tt>o</tt>, <tt>cl</tt>, <tt>scl</tt> &isin; <i><b>D</b></i>, &nbsp; if <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i>TVal</i><sub>I</sub>(<tt>cl&nbsp;##&nbsp;scl</tt>) = <b>t</b> &nbsp; then &nbsp; <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;scl</tt>)&nbsp;=&nbsp;<b>t</b>;
</li></ul>
</li><li> <i>Frame</i>: <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>)).<br />Since the bag of attribute/value pairs represents the conjunctions of all the pairs, the following is required, if <tt>k &gt; 0</tt>: 
<ul><li> <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b> if and only if  <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub>]</tt>) = ... = <i>TVal</i><sub>I</sub>(<tt>o[a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b>; 
</li></ul>
</li><li> <i>Externally defined atomic formula</i>: <i>TVal</i><sub>I</sub>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>))), if <tt>t</tt> is an atomic formula that is an instance of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>; &tau;)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.<br />Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instance of an external schema. Furthermore, by the definition of coherent sets of external schemas, <tt>t</tt> can be an instance of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined;
</li><li> <i>Conjunction</i>: <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>t</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b>.<br />The empty conjunction is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>And()</tt>) = <b>t</b>;
</li><li> <i>Disjunction</i>: <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b> if and only if  <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>f</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b>.<br />The empty disjunction is treated as a contradiction, so <i>TVal</i><sub>I</sub>(<tt>Or()</tt>) = <b>f</b>;
</li><li> <i>Negation</i>: <i>TVal</i><sub>I</sub>(<tt>Not(</tt>c<tt>)</tt>) = <b>f</b> if and only if  <i>TVal</i><sub>I</sub>(c) = <b>t</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>Not(</tt>c<tt>)</tt>) = <b>t</b>;
</li><li> <i>Existence</i>: <i>TVal</i><sub>I</sub>(<tt>Exists&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (&phi;)</tt>) = <b>t</b> if and only if for some <i><b>I</b></i>*, described below,  <i>TVal</i><sub>I*</sub>(<tt>&phi;</tt>) = <b>t</b>.<br />Here <i><b>I</b></i>* is a semantic structure of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i>*<sub>V</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>P</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;, which is exactly like <i><b>I</b></i>, except that the mapping <i><b>I</b></i>*<sub>V</sub>, is used instead of <i><b>I</b></i><sub>V</sub>. &nbsp; <i><b>I</b></i>*<sub>V</sub> is defined to coincide with <i><b>I</b></i><sub>V</sub> on all variables except, possibly, on <tt>?v<sub>1</sub></tt>,...,<tt>?v<sub>n</sub></tt>. &nbsp;&nbsp;☐
</li></ul>
<p><span class="anchor" id="sec-satisfaction-of-condition2"></span>
</p>
<a id="Condition_satisfaction_2" name="Condition_satisfaction_2"></a><h4> <span class="mw-headline">12.3  Condition satisfaction </span></h4>
<p>We define, now, what it means for a <i>state of the fact base</i> to satisfy a condition formula. The satisfaction of condition formulas in a state of the fact base provides formal underpinning to the operational semantics of rule sets interchanged using RIF-PRD.
</p><p><span class="anchor" id="def-model"></span>
<b>Definition (Models).</b>
A semantic structure <i><b>I</b></i> is a <i><b>model</b></i> of a condition formula, <tt>&phi;</tt>, written as <i><b>I</b></i><tt>&nbsp;|=&nbsp;&phi;</tt>, iff <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) = <b>t</b>.  &nbsp;&nbsp;☐
</p><p><br />
<span class="anchor" id="def-herbrand-interpretation"></span>
<b>Definition (Herbrand interpretation).</b>  Given a non-empty set of constants, <tt>Const</tt>, the <i>Herbrand domain</i> is the set of all the ground terms that can be formed using the elements of <tt>Const</tt>, and the <i>Herbrand base</i> is the set of all the well-formed ground atomic formulas that can be formed with the elements in the Herbrand domain.
</p><p>A semantic structure, <i><b>I</b></i>, is a <i><b>Herbrand interpretation</b></i>, if the set of all the ground formulas which are true with respect to <i><b>I</b></i> (that is, of which <i><b>I</b></i> is a model), is a subset of the corresponding Herbrand base, <i>B<sub>I</sub></i>.  &nbsp;&nbsp;☐
</p><p>In RIF-PRD, the semantics of condition formulas is defined with respect to semantic structures where the domain, <i><b>D</b></i> is the Herbrand domain that is determined by the set of all the constants, <tt>Const</tt>; that is, with respect to Herbrand interpretations.
</p><p><span class="anchor" id="def-state2"></span>
<b>Definition (State of the fact base).</b> To every Herbrand interpretation <i><b>I</b></i>, we associate a <i><b>state of the fact base</b></i>, <i>w<sub>I</sub></i>, that is represented by the subset of the Herbrand base that contains exactly the ground atomic formulas of which <i><b>I</b></i> is a model; or, equivalently, by the conjunction of all these ground atomic formulas. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-condition-satisfaction2"></span>
<b>Definition (Condition satisfaction).</b> A RIF-PRD condition formula <tt>&phi;</tt> is <i><b>satisfied</b></i> in a state of the fact base, <i>w<sub>I</sub></i>, if and only if <i><b>I</b></i> is a model of <tt>&phi;</tt>. &nbsp;&nbsp;☐
</p><p>At the syntactic level, the interpretation of the variables by a valuation function <i><b>I</b></i><sub>V</sub> is realized by a <a href="#def-substitution" title="">substitution</a>. As a consequence, a ground substitution <i>&sigma;</i> <a href="#def-matching-substitution" title="">matches</a> a condition formula <i>&psi;</i> to a set of ground atomic formulas <i>&Phi;</i> if and only if <i>&sigma;</i> realizes the valuation function <i><b>I</b></i><sub>V</sub> of a semantics structure <i><b>I</b></i> that is a model of <i>&psi;</i> and <i>&Phi;</i> is a representation of a state of the fact base, <i>w<sub>I</sub></i> (as defined <a href="#def-state2" title="">above</a>), that is associated to <i><b>I</b></i>; that is, if and only if <i>&psi;</i> is satisfied in <i>w<sub>I</sub></i> (as defined <a href="#def-condition-satisfaction2" title="">above</a>).
</p><p>This provides the formal link between the <a href="#def-condition-satisfaction2" title="">satisfaction of a condition formula</a>, as defined above, and a <a href="#def-matching-substitution" title="">matching substitution</a>, and, followingly, between the alternative definitions of a state of facts and the satisfaction of a condition, here and in <a href="#sec-semantics-of-condition-formulas" title="">section Semantics of condition formulas</a>.
</p><p><br />
<span class="anchor" id="appendix-xml-schema"></span>
</p>
<a id="Appendix:_XML_schema" name="Appendix:_XML_schema"></a><h2> <span class="mw-headline">13  Appendix: XML schema </span></h2>
<p>The RIF-PRD XML Schema is specified below as a redefinition and an extension of the RIF-Core XML Schema [<a href="#ref-core" title="">RIF-Core</a>] and is also available at <a class="external free" href="http://www.w3.org/2010/rif-schema/prd/" rel="nofollow" title="http://www.w3.org/2010/rif-schema/prd/">http://www.w3.org/2010/rif-schema/prd/</a>.
</p>
<pre>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xs:schema
    targetNamespace="http://www.w3.org/2007/rif#"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xml="http://www.w3.org/XML/1998/namespace"
    xmlns="http://www.w3.org/2007/rif#"
    elementFormDefault="qualified"&gt;

&lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
           schemaLocation='http://www.w3.org/2001/xml.xsd'/&gt;


&lt;!-- ================================================== --&gt;
&lt;!-- Redefine some elements in the Core Conditions      --&gt;
&lt;!-- Extension of the choice                            --&gt;
&lt;!-- ================================================== --&gt;

   &lt;xs:group name="ATOMIC"&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Atom"/&gt;
         &lt;xs:element ref="Frame"/&gt;
         &lt;xs:element ref="Member"/&gt;
         &lt;xs:element ref="Equal"/&gt;
         &lt;xs:element ref="Subclass"/&gt; &lt;!-- Subclass is not in RIF-Core --&gt;
         &lt;xs:element name="External" type="External-FORMULA.type"/&gt;
      &lt;/xs:choice&gt;
   &lt;/xs:group&gt;

   &lt;xs:group name="FORMULA"&gt;
      &lt;xs:choice&gt;
         &lt;xs:group   ref="ATOMIC"/&gt; 
         &lt;xs:element ref="And"/&gt;
         &lt;xs:element ref="Or"/&gt;
         &lt;xs:element ref="Exists"/&gt;
         &lt;xs:element ref="INeg"/&gt; &lt;!-- INeg is nt in RIF-Core --&gt;
      &lt;/xs:choice&gt;
   &lt;/xs:group&gt;

&lt;!-- ================================================== --&gt;
&lt;!-- Additional elements to the Core Condition schema   --&gt;
&lt;!-- ================================================== --&gt;

   &lt;xs:element name="Subclass"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Subclass&gt;                                     --&gt;
&lt;!--        &lt;sub&gt; TERM &lt;/sub&gt;                           --&gt;
&lt;!--        &lt;super&gt; TERM &lt;/super&gt;                       --&gt;
&lt;!--     &lt;/Subclass&gt;                                    --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
            &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element name="sub"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="1"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="super"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="1"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

   &lt;xs:element name="INeg"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;INeg&gt;                                         --&gt;
&lt;!--        &lt;formula&gt; FORMULA &lt;/formula&gt;                --&gt;
&lt;!--     &lt;/INeg&gt;                                        --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
          &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
          &lt;xs:element ref="formula" minOccurs="1" maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

&lt;!-- ============================================ --&gt;
&lt;!-- CoreCond.xsd starts here                     --&gt;
&lt;!-- ============================================ --&gt;

  &lt;xs:complexType name="External-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORMULA.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Atom"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="And"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Or"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Exists"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="formula"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="formula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="declare"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Var"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Atom"&gt;
    &lt;!--
  Atom          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  
  &lt;xs:group name="UNITERM"&gt;
    &lt;!--
  UNITERM       &nbsp;::= Const '(' (TERM* ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:element name="args" type="args-UNITERM.type" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:group name="GROUNDUNITERM"&gt;
    &lt;!-- sensitive to ground terms
  GROUNDUNITERM       &nbsp;::= Const '(' (GROUNDTERM* ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:element name="args" type="args-GROUNDUNITERM.type" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;


  &lt;xs:element name="op"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Const"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="args-UNITERM.type"&gt;
    &lt;!-- sensitive to UNITERM (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;


  &lt;xs:complexType name="args-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDUNITERM (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="GROUNDTERM" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="Equal"&gt;
    &lt;!--
  Equal         &nbsp;::= TERM '=' ( TERM | IRIMETA? 'External' '(' Expr ')' )
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="left"/&gt;
        &lt;xs:element ref="right"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="left"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="right"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Member"&gt;
    &lt;!--
  Member        &nbsp;::= TERM '#' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="instance"/&gt;
        &lt;xs:element ref="class"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="instance"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="class"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Frame"&gt;
    &lt;!--
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="object"/&gt;
        &lt;xs:element name="slot" type="slot-Frame.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="object"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-Frame.type"&gt;
    &lt;!-- sensitive to Frame (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="TERM"&gt;  
    &lt;!--
  TERM          &nbsp;::= IRIMETA? (Const | Var | External | List )
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="Var"/&gt;
         &lt;xs:element name="External" type="External-TERM.type"/&gt;
         &lt;xs:element ref="List"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:group name="GROUNDTERM"&gt;  
    &lt;!--
  GROUNDTERM          &nbsp;::= IRIMETA? (Const | List | 'External' '(' 'Expr' '(' GROUNDUNITERM ')' ')')
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="List"/&gt;
         &lt;xs:element name="External" type="External-GROUNDUNITERM.type"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="List"&gt;
    &lt;!--
      List          &nbsp;::= 'List' '(' GROUNDTERM* ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element name="items"&gt; 
          &lt;xs:complexType&gt; 
            &lt;xs:sequence&gt;
              &lt;xs:group ref="GROUNDTERM" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt; 
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt; 
  
  &lt;xs:complexType name="External-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-TERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  

  &lt;xs:complexType name="External-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDTERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-GROUNDUNITERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;


  &lt;xs:complexType name="content-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Expr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

   
   &lt;xs:complexType name="content-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDTERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Expr" type="content-GROUNDEXPR.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="content-GROUNDEXPR.type"&gt;
    &lt;!-- sensitive to GROUNDEXPR context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="GROUNDUNITERM"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:element name="Expr"&gt;
    &lt;!--
  Expr          &nbsp;::= Const '(' (TERM | IRIMETA? 'External' '(' Expr ')')* ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="op"/&gt;
        &lt;xs:element name="args" type="args-Expr.type" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="args-Expr.type"&gt;
    &lt;!-- sensitive to Expr (TERM) context--&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="Const"&gt;
    &lt;!--
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" type="xs:anyURI" use="required"/&gt;
      &lt;xs:attribute ref="xml:lang"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Var"&gt;
    &lt;!--
  Var           &nbsp;::= '?' NCName
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="IRIMETA"&gt;
    &lt;!--
  IRIMETA  &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="id" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="meta" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="id"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="IRICONST.type"/&gt;   &lt;!-- type="&amp;rif;iri" --&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="meta"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="Frame"/&gt;
       &lt;xs:element name="And" type="And-meta.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="And-meta.type"&gt;
  &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-meta.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-meta.type"&gt;
    &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="IRICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/id context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2007/rif#iri"/&gt;
  &lt;/xs:complexType&gt;

&lt;!-- ============================================ --&gt;
&lt;!-- Definition of the actions (not in RIF-Core)  --&gt;
&lt;!-- ============================================ --&gt;

   &lt;xs:element name="New"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


   &lt;xs:group name="INITIALIZATION"&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="New"/&gt;
         &lt;xs:element ref="Frame"/&gt;
      &lt;/xs:choice&gt;
   &lt;/xs:group&gt;

   &lt;xs:element name="Do"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Do&gt;                                           --&gt;
&lt;!--        &lt;actionVar ordered="yes"&gt;                   --&gt;
&lt;!--          Var                                       --&gt;
&lt;!--          INITIALIZATION                            --&gt;
&lt;!--        &lt;/actionVar&gt;*                               --&gt;
&lt;!--        &lt;actions ordered="yes"&gt;                     --&gt;
&lt;!--          ACTION+                            --&gt;
&lt;!--        &lt;/actions&gt;                                  --&gt;
&lt;!--     &lt;/Do&gt;                                          --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
            &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element name="actionVar" minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                     &lt;xs:element ref="Var" minOccurs="1" maxOccurs="1"/&gt;
                     &lt;xs:group ref="INITIALIZATION" minOccurs="1" maxOccurs="1"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="actions" minOccurs="1" maxOccurs="1"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                     &lt;xs:group ref="ACTION" minOccurs="1" maxOccurs="unbounded"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

   &lt;xs:group name="ACTION"&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Assert"/&gt;
         &lt;xs:element ref="Retract"/&gt;
         &lt;xs:element ref="Modify"/&gt;
         &lt;xs:element ref="Execute"/&gt;
      &lt;/xs:choice&gt;	
   &lt;/xs:group&gt;

   &lt;xs:element name="Assert"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Assert&gt;                                       --&gt;
&lt;!--        &lt;target&gt; [ Atom                             --&gt;
&lt;!--                 | Frame                            --&gt;
&lt;!--                 | Member ]                         --&gt;
&lt;!--        &lt;/target&gt;                                   --&gt;
&lt;!--     &lt;/Assert&gt;                                      --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
            &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element name="target" minOccurs="1" maxOccurs="1"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:choice&gt;
                     &lt;xs:element ref="Atom"/&gt;
                     &lt;xs:element ref="Frame"/&gt;
                     &lt;xs:element ref="Member"/&gt;
                  &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;
	    &lt;/xs:element&gt;
	 &lt;/xs:sequence&gt;
     &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

   &lt;xs:element name="Retract"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Retract&gt;                                      --&gt;
&lt;!--        &lt;target ordered="yes"?&gt;                     --&gt;
&lt;!--           [ Atom                                   --&gt;
&lt;!--             | Frame                                --&gt;
&lt;!--             | TERM                                 --&gt;
&lt;!--             | TERM TERM ]                          --&gt;
&lt;!--        &lt;/target&gt;                                   --&gt;
&lt;!--     &lt;/Assert&gt;                                      --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
            &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element name="target" minOccurs="1" maxOccurs="1"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:choice&gt;
                     &lt;xs:element ref="Atom"/&gt;
                     &lt;xs:element ref="Frame"/&gt;
                     &lt;xs:group ref="TERM"/&gt;
                     &lt;xs:sequence&gt;
                        &lt;xs:group ref="TERM"/&gt;
                        &lt;xs:group ref="TERM"/&gt;
                     &lt;/xs:sequence&gt;
                  &lt;/xs:choice&gt;
                  &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

   &lt;xs:element name="Modify"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Modify&gt;                                       --&gt;
&lt;!--        &lt;target&gt; Frame &lt;/target&gt;                    --&gt;
&lt;!--     &lt;/Modify&gt;                                      --&gt;
&lt;!--                                                    --&gt;
     &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
       &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element name="target" minOccurs="1" maxOccurs="1"&gt;
        &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
          &lt;xs:element ref="Frame"/&gt;
         &lt;/xs:sequence&gt;  
        &lt;/xs:complexType&gt;
       &lt;/xs:element&gt;
      &lt;/xs:sequence&gt; 
     &lt;/xs:complexType&gt;           
   &lt;/xs:element&gt;
   
   &lt;xs:element name="Execute"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;Execute&gt;                                      --&gt;
&lt;!--        &lt;target&gt; Atom &lt;/target&gt;                     --&gt;
&lt;!--     &lt;/Execute&gt;                                     --&gt;
&lt;!--                                                    --&gt;
     &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
       &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element name="target" minOccurs="1" maxOccurs="1"&gt;
        &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
          &lt;xs:element ref="Atom"/&gt;
         &lt;/xs:sequence&gt;  
        &lt;/xs:complexType&gt;
       &lt;/xs:element&gt;
      &lt;/xs:sequence&gt; 
     &lt;/xs:complexType&gt;           
   &lt;/xs:element&gt;    

&lt;!-- ================================================== --&gt;
&lt;!-- Redefine Group related Core construct              --&gt;
&lt;!-- ================================================== --&gt;

   &lt;xs:complexType name="Group-contents"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
         &lt;xs:element ref="behavior" minOccurs="0" maxOccurs="1"/&gt;
                     &lt;!-- behavior in not in RIF-Core --&gt;
         &lt;xs:element ref="sentence" minOccurs="0" maxOccurs="unbounded"/&gt;          
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;

&lt;!-- ================================================== --&gt;
&lt;!-- Group related addition                             --&gt;
&lt;!-- ================================================== --&gt;

   &lt;xs:element name="behavior"&gt;
&lt;!--                                                    --&gt;
&lt;!--     &lt;behavior&gt;                                     --&gt;
&lt;!--        &lt;ConflictResolution&gt;                        --&gt;
&lt;!--           xsd:anyURI                               --&gt;
&lt;!--        &lt;ConflictResolution&gt;?                       --&gt;
&lt;!--        &lt;Priority&gt;                                  --&gt;
&lt;!--           -10,000 &le; xsd:int &le; 10,000         --&gt;
&lt;!--        &lt;/Priority&gt;?                                --&gt;
&lt;!--     &lt;/behavior&gt;                                    --&gt;
&lt;!--                                                    --&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element name="ConflictResolution" minOccurs="0" maxOccurs="1" type="xs:anyURI"/&gt;
            &lt;xs:element name="Priority" minOccurs="0" maxOccurs="1"&gt;
               &lt;xs:simpleType&gt;
                  &lt;xs:restriction base="xs:int"&gt;
                     &lt;xs:minInclusive value="-10000"/&gt;
                     &lt;xs:maxInclusive value="10000"/&gt;
                  &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;

&lt;!-- ================================================== --&gt;
&lt;!-- Redefine rule related Core constructs              --&gt;
&lt;!-- ================================================== --&gt;

  &lt;xs:group name="RULE"&gt;
    &lt;!--
   RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ (' such that ' FORMULA+)?  '(' RULE ')') | CLAUSE
    --&gt;
    &lt;xs:choice&gt;
       &lt;xs:element name="Forall" type="Forall-premises"/&gt;
       &lt;xs:group   ref="CLAUSE"/&gt; 
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:complexType name="Forall-premises"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;xs:element name="pattern" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="FORMULA"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt; 
      &lt;!-- different from formula in And, Or and Exists --&gt;
      &lt;xs:element name="formula"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:group ref="RULE"/&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="CLAUSE"&gt;  
    &lt;!--
  CLAUSE  &nbsp;::= Implies | ACTION_BLOCK
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Implies"/&gt;
      &lt;xs:group ref="ACTION_BLOCK"/&gt; 
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

   &lt;xs:complexType name="then-part"&gt;
            &lt;xs:group ref="ACTION_BLOCK" minOccurs="1" maxOccurs="1"/&gt;
   &lt;/xs:complexType&gt;

&lt;!-- ================================================== --&gt;
&lt;!-- Rule related additions                             --&gt;
&lt;!-- ================================================== --&gt;
  
  &lt;xs:group name="ACTION_BLOCK"&gt;
    &lt;!-- 
  ACTION_BLOCK  &nbsp;::= 'Do (' (Var (Frame | 'New'))* ACTION+  ')' |
                     'And (' (Atom | Frame)* ')' | Atom | Frame 
    --&gt;                   
    &lt;xs:choice&gt;
     &lt;xs:element  ref="Do"/&gt;
     &lt;xs:element  name="And" type="And-then.type"/&gt;
     &lt;xs:element  ref="Atom"/&gt;
     &lt;xs:element  ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

&lt;!-- ================================================== --&gt;
&lt;!-- CoreRule.xsd starts here                           --&gt;
&lt;!-- ================================================== --&gt;
 
  &lt;xs:element name="Document"&gt;
    &lt;!--
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="directive" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="payload" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="directive"&gt;
    &lt;!--
  Base and Prefix represented directly in XML
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Import"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="payload"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Group" type="Group-contents"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Import"&gt;
    &lt;!--
  Import   &nbsp;::= IRIMETA? 'Import' '(' IRICONST PROFILE? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element ref="location"/&gt;
        &lt;xs:element ref="profile" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="location" type="xs:anyURI"/&gt;
 
  &lt;xs:element name="profile" type="xs:anyURI"/&gt;

  &lt;xs:element name="sentence"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element name="Group" type="Group-contents"/&gt;
       &lt;xs:group ref="RULE"/&gt;
       &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
      
  &lt;xs:element name="Implies"&gt;
    &lt;!--
  Implies  &nbsp;::= IRIMETA? ATOMIC  ':-' FORMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="if"/&gt;
        &lt;xs:element name="then" type="then-part"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="if"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="And-then.type"&gt;
    &lt;!-- sensitive to then (And) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-then.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-then.type"&gt;
    &lt;!-- sensitive to then (And) context--&gt;
    &lt;xs:choice&gt;
     &lt;xs:element  ref="Atom"/&gt;
     &lt;xs:element  ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;

 &lt;/xs:schema&gt; 

</pre>
<p><span class="anchor" id="appendix-change-log"></span>
</p>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">14  Appendix: Change Log (Informative) </span></h2>
<p>This appendix summarizes the changes to this document since its publication as a <a class="external text" href="http://www.w3.org/TR/2010/REC-rif-prd-20100622/" rel="nofollow" title="http://www.w3.org/TR/2010/REC-rif-prd-20100622/">Recommendation on 22 June 2010</a>:
</p>
<ul><li> Errata as described in the section <a class="external text" href="http://www.w3.org/2005/rules/wiki/Errata_2012#Proposed_Errata_for_RIF-PRD" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/Errata_2012#Proposed_Errata_for_RIF-PRD">Proposed Errata for RIF-PRD</a> on the <a class="external text" href="http://www.w3.org/2005/rules/wiki/Errata_2012" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/Errata_2012">RIF errata (2010-2012) page</a> have been implemented.
</li></ul>
</div>

</body>
</html>