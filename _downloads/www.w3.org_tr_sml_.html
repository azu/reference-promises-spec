<!-- http://www.w3.org/TR/sml/ -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<meta name="generator" content=
"HTML Tidy for Cygwin (vers 22 March 2008), see www.w3.org" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<title>Service Modeling Language, Version 1.1</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

dt.label       { display: run-in; }

li, p           { margin-top: 0.3em;
                 margin-bottom: 0.8em; }

.diff-chg       { background-color: yellow; }
.diff-del       { background-color: red; text-decoration: line-through;}
.diff-add       { background-color: lime; }

table          { empty-cells: show; }

table caption {
        font-weight: normal;
        font-style: italic;
        text-align: left;
        margin-bottom: .5em;
}

div.issue {
  color: red;
}
.rfc2119 {
  font-variant: small-caps;
}
.figure {
  text-align: center;
}
.center {
  text-align: center;
}
.left {
  text-align: left;
}
.red {
  color: red;
}
table.eg {
  color: #99ffff;
}
code.emph {
  font-style: italic;
}

div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
p.exampleHead { text-align: left;}
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-REC.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>Service Modeling Language,
Version 1.1</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation
12 May 2009</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2009/REC-sml-20090512/">http://www.w3.org/TR/2009/REC-sml-20090512/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/sml/">http://www.w3.org/TR/sml/</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://www.w3.org/TR/2009/PR-sml-20090212/">http://www.w3.org/TR/2009/PR-sml-20090212/</a></dd>
<dt>Editors:</dt>
<dd>Bhalchandra Pandit, Microsoft Corporation</dd>
<dd>Valentina Popescu, IBM Corporation</dd>
<dd>Virginia Smith, HP</dd>
</dl>
<p>Please refer to the <a href=
"http://www.w3.org/2009/05/sml-errata"><strong>errata</strong></a> for this
document, which may include some normative corrections.</p>
<p>This document is also available in these non-normative formats:
<a href="sml.xml">XML</a>.</p>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology="><strong>
translations</strong></a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2009 <a href="http://www.w3.org/"><acronym title=
"World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href=
"http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This specification defines the Service Modeling Language,
Version 1.1 (SML) used to model complex services and systems,
including their structure, constraints, policies, and best
practices. SML uses XML Schema and Schematron.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is the 12 May 2009 W3C Recommendation of the Service
Modeling Language, Version 1.1 specification. This document has
been developed by the <a href="http://www.w3.org/XML/SML/">Service
Modeling Language (SML) Working Group</a>, which is a part of the
<a href="http://www.w3.org/XML/">Extensible Markup Language (XML)
Activity</a>.</p>
<p>Comments on this document are welcome via the Working Group’s
<a href="mailto:public-sml@w3.org">public mailing list</a>
(<a href="http://lists.w3.org/Archives/Public/public-sml/">public
archive</a>). An <a href=
"http://www.w3.org/XML/SML/SMLPRFeatureImplementationReport.html">implementation
report</a> is available.</p>
<p>The design of SML has been widely reviewed and satisfies the
Working Group's technical requirements. Only minor editorial
changes have been made since the <a href=
"http://www.w3.org/TR/2009/PR-sml-20090212/">12 February 2009
Proposed Recommendation</a>.</p>
<p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from
another document. W3C's role in making the Recommendation is to
draw attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/41079/status">public list of any
patent disclosures</a> made in connection with the deliverables of
the group; that page also includes instructions for disclosing a
patent. An individual who has actual knowledge of a patent which
the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1. <a href="#Introduction">Introduction
(Non-Normative)</a><br />
2. <a href="#Notations_and_Terminology">Notations and
Terminology</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href=
"#Notational_Conventions">Notational Conventions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href=
"#Terminology">Terminology</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#XML_Namespaces">XML
Namespaces</a><br />
3. <a href="#Dependencies">Dependencies on Other
Specifications</a><br />
4. <a href="#References">SML References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#Reference_Definitions">SML
Reference Definitions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1 <a href=
"#SML_Reference">SML Reference</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.2 <a href=
"#Null_Reference">Null SML Reference</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.3 <a href=
"#Unresolved_Reference">Unresolved SML Reference</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.4 <a href=
"#SML_Reference_Target">SML Reference Target</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#Reference_Semantics">SML
Reference Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.1 <a href=
"#At_Most_One_Target">At Most One Target</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.2 <a href=
"#Consistent_References">Consistent References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.3 <a href=
"#Identical_Targets">Identical Targets</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.4 <a href=
"#Multiple_References">Multiple References &nbsp;</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.5 <a href=
"#Null_References">Null SML References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.6 <a href=
"#Deterministic_References">Deterministic Evaluation of SML
Constraints</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.7 <a href=
"#deref_XPath_Extension_Function">smlfn:deref() XPath Extension
Function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#Reference_Schemes">SML
Reference Schemes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.1 <a href=
"#URI_Reference_Scheme">SML URI Reference Scheme</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.1.1
<a href="#SMLXPath1_Scheme">smlxpath1() scheme</a><br />
5. <a href="#SML_constraints">SML Constraints</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href=
"#Constraints_on_References">Constraints on SML
References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1 <a href=
"#sml_acyclic">sml:acyclic</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1.1
<a href="#Acyclic_Mapping_From_Schema">SML Constraint
Construction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1.2
<a href="#Acyclic_Schema_Validity_Rules">Schema Component
Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1.3
<a href="#Acyclic_Instance_Validity_Rules">Instance Validity
Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2 <a href=
"#Constraints_on_Targets">Constraints on SML Reference
Targets</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2.1
<a href="#Target_Mapping_From_Schema">SML Constraint
Construction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2.2
<a href="#Target_Schema_Validity_Rules">Schema Component
Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2.3
<a href="#Target_Instance_Validity_Rules">Instance Validity
Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.3 <a href=
"#constraints_summary">SML Reference Constraints Summary
(Non-Normative)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#Identity_Constraints">SML
Identity Constraints</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href=
"#Identity_Constraints_Syntax_Semantics">Syntax and
Semantics</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1.1
<a href="#Identity_Constraints_Mapping_from_Schema">SML Constraint
Construction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1.2
<a href="#Identity_Constraints_Schema_Validity_Rules">Schema
Component Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1.3
<a href="#Identity_Constraints_Instance_Validity_Rules">Instance
Validity Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href=
"#Constraints_Valid_Restriction">Valid Restriction of SML
Constraint Values</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href=
"#SML_Constraints_and_Complex_Type_Derivation">SML Constraints and
Complex Type Derivation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.1 <a href=
"#Sml_Constraints_and_Derivation_Overview">Overview of SML
Constraint Processing and Complex Type Derivation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 <a href=
"#Constraints_Definition">Formal Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2.1
<a href="#Constraints_Properties">Properties</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2.2
<a href="#Constraints_Derivation_Rules">SML Constraint
Construction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2.3
<a href="#Constraints_Instance_Validity_Rules">Instance Validity
Rules</a><br />
6. <a href="#SML_Rules">Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href=
"#Rules_Informal_Description">Informal Description
(Non-Normative)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#Rule_Support">Rule
Support</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="#Embedded_Rules">Rules
Associated with Schema Components</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.1 <a href=
"#Rules_Mapping_From_Schema">SML Rule Construction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.2 <a href=
"#Rules_Schema_Validity_Rules">Schema Component Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3.3 <a href=
"#Rules_Instance_Validity_Rules">Instance Validity Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.4 <a href=
"#Rules_in_Rule_Documents">Rules Authored in Rule
Documents</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4.1 <a href=
"#Rule_Binding">Rule Binding</a><br />
7. <a href="#Localization_of_Messages">Localization of Natural
Language Messages</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;7.1 <a href=
"#Variable_Substitution">Variable Substitution</a><br />
8. <a href="#Conformance">Conformance Criteria</a><br />
9. <a href="#SML_Extension_Reference">SML Extensions Reference
(Non-Normative)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;9.1 <a href=
"#Attributes">Attributes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.1 <a href=
"#sml_acyclic_nonnormative_reference">sml:acyclic</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.2 <a href=
"#sml_ref_nonnormative_referenc">sml:ref</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.3 <a href=
"#sml_nilref_nonnormative_referenc">sml:nilref</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.4 <a href=
"#sml_targetElement_nonnormative_referenc">sml:targetElement</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.5 <a href=
"#sml_targetRequired_nonnormative_referenc">sml:targetRequired</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.6 <a href=
"#sml_targetType_nonnormative_referenc">sml:targetType</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.1.7 <a href=
"#locid_nonnormative_referenc">sml:locid</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;9.2 <a href="#Elements">Elements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.1 <a href=
"#sml_key_nonnormative_referenc">sml:key</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.2 <a href=
"#sml_keyref_nonnormative_referenc">sml:keyref</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.3 <a href=
"#sml_unique_nonnormative_referenc">sml:unique</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.2.4 <a href=
"#sml_uri_nonnormative_referenc">sml:uri</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;9.3 <a href="#XPath_functions">XPath
functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.3.1 <a href=
"#smlfn_deref_nonnormative_referenc">smlfn:deref</a><br />
10. <a href="#bibl">References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;10.1 <a href=
"#Normative-References">Normative</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;10.2 <a href=
"#NonNormative-References">Non-Normative</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A. <a href="#SML_schema">Normative SML
Schema</a><br />
B. <a href="#Model_Definition_Document_Sample">Model Definition
Document Sample</a> (Non-Normative)<br />
C. <a href="#SML_References_Sample">SML References Sample</a>
(Non-Normative)<br />
D. <a href="#SML_URI_Reference_Scheme_Example">SML URI Reference
Scheme Sample</a> (Non-Normative)<br />
E. <a href="#Identity_Constraints_Example">SML Identity Constraints
Sample</a> (Non-Normative)<br />
F. <a href="#Localization_Sample">Localization and Variable
Substitution Samples</a> (Non-Normative)<br />
G. <a href="#Acknowledgements">Acknowledgements</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="Introduction" id="Introduction"></a>1. Introduction
(Non-Normative)</h2>
<p>The Service Modeling Language (SML) provides a rich set of
constructs for creating models of complex services and systems.
Depending on the application domain, these models may include
information such as configuration, deployment, monitoring, policy,
health, capacity planning, target operating range, service level
agreements, and so on. Models provide value in several important
ways.</p>
<ol class="enumar">
<li>
<p>Models focus on capturing all <b>invariant aspects</b> of a
service/system that must be maintained for the service/system to
function properly.</p>
</li>
<li>
<p>Models represent a powerful mechanism for <b>validating
changes</b> <b>before</b> applying the changes to a service/system.
Also, when changes happen in a running service/system, they can be
validated against the intended state described in the model. The
actual service/system and its model together enable a
<b>self-healing service/system</b> ― the ultimate objective.
<b>Models of a service/system must necessarily stay decoupled from
the live service/system to create the control loop</b>.</p>
</li>
<li>
<p>Models are units of <b>communication</b> <b>and
collaboration</b> between designers, implementers, operators, and
users; and can easily be shared, tracked, and revision controlled.
This is important because complex services are often built and
maintained by a variety of people playing different roles.</p>
</li>
<li>
<p>Models drive <b>modularity</b>, <b>reuse, and
standardization</b>. Most real-world complex services and systems
are composed of sufficiently complex parts. &nbsp;Reuse and
standardization of services/systems and their parts is a key factor
in reducing overall production and operation cost and in increasing
reliability.</p>
</li>
<li>
<p>Models enable increased <b>automation</b> of management tasks.
Automation facilities exposed by the majority of services/systems
today could be driven by software ― not people ― both for reliable
initial realization of a service/system as well as for ongoing
lifecycle management.</p>
</li>
</ol>
<p>A model in SML is realized as a set of interrelated XML
documents. The XML documents contain information about the parts of
a service, as well as the constraints that each part must satisfy
for the service to function properly. Constraints are captured in
two ways:</p>
<ol class="enumar">
<li>
<p><b>Schemas</b> ― these are constraints on the structure and
content of the documents in a model. SML uses XML Schema
[<cite><a href="#XSD1">XML Schema Structures</a></cite>,
<cite><a href="#XSD2">XML Schema Datatypes</a></cite>] as the
schema language. In addition SML defines a set of extensions to XML
Schema to support references that may cross document
boundaries.</p>
</li>
<li>
<p><b>Rules</b> ― are Boolean expressions that constrain the
structure and content of documents in a model. SML uses Schematron
[<cite><a href="#Schematron">ISO/IEC 19757-3</a></cite>,
<cite><a href="#intro_schematron">Introduction to
Schematron</a></cite>, <cite><a href=
"#improving_schematron">Improving Validation with
Schematron</a></cite>] and XPath [<cite><a href=
"#XPath">XPath</a></cite>] for rules.</p>
</li>
</ol>
<p>One of the important operations on the model is to establish its
validity. This involves checking whether all data in a model
satisfies the schemas and rules declared.</p>
<p>This specification focuses primarily on defining the extensions
to XML Schema for references that cross document boundaries,
Schematron usage in SML, as well as the process of model
validation. It is assumed that the reader is familiar with XML
Schema and Schematron.</p>
<p>SML scenarios require several features that either do not exist
or are not fully supported in XML Schema. These features can be
classified as follows:</p>
<ol class="enumar">
<li>
<p><b>SML references</b> – XML documents introduce boundaries
across content that needs to be treated as a unit. XML Schema does
not have any support for references that cross documents, although
it does support references to elements in the same document through
<code>xs:ID</code>, <code>xs:IDREF</code>, <code>xs:key</code> and
<code>xs:keyref</code>. References between elements defined in
separate SML <a title="" href="#model">model</a> documents are
fundamental to the SML specification. SML extends XML Schema to
support references that may cross document boundaries, and a set of
constraints on those references that apply regardless of whether
they cross document boundaries or not.</p>
</li>
<li>
<p><b>Rules</b> – XML Schema does not support a language for
defining arbitrary constraints on the structure and content of XML
documents. SML uses Schematron to express assertions on the
structure and content of XML documents.</p>
</li>
</ol>
<p>XML Schema supports two forms of extension: "attributes in
different namespace" and "application information elements"; both
forms are used by SML extensions.</p>
</div>
<div class="div1">
<h2><a name="Notations_and_Terminology" id=
"Notations_and_Terminology"></a>2. Notations and Terminology</h2>
<div class="div2">
<h3><a name="Notational_Conventions" id=
"Notational_Conventions"></a>2.1 Notational Conventions</h3>
<p>The keywords "<span class="rfc2119">MUST</span>", "<span class=
"rfc2119">MUST NOT</span>", "<span class=
"rfc2119">REQUIRED</span>", "<span class="rfc2119">SHALL</span>",
"<span class="rfc2119">SHALL NOT</span>", "<span class=
"rfc2119">SHOULD</span>", "<span class="rfc2119">SHOULD
NOT</span>", "<span class="rfc2119">RECOMMENDED</span>",
"<span class="rfc2119">MAY</span>", and "<span class=
"rfc2119">OPTIONAL</span>" in this document are to be interpreted
as described in RFC 2119 [<cite><a href="#RFC2119">IETF RFC
2119</a></cite>].</p>
<p>This specification uses the Augmented Backus-Naur Form (ABNF)
notation [<cite><a href="#RFC2234">RFC 2234</a></cite>].</p>
<p>This specification follows the same conventions for schema
components as those used in the XML schema specification
[<cite><a href="#XSD1">XML Schema Structures</a></cite>]. That is,
references to properties of schema components, such as {example
property}, are links to the relevant definition, set off with curly
braces. References to properties of information items as defined in
[<cite><a href="#XMLInfoset">XML Information Set</a></cite>], such
as [children], are notated as links to the relevant section
thereof, set off with square brackets.</p>
<p>This specification refers to terms such as XML document,
element, attribute, etc. for the sake of brevity. The alternative
would be to use terms like "XML document or a <a href=
"http://www.w3.org/TR/xml-infoset/#intro.synthetic">Synthetic
Infoset</a>", "<a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.element">element
information item</a>", "<a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">attribute
information item</a>", etc. at each place. This would make the
specification excessively verbose without adding to or changing the
meaning of the existing text. The use of the concise terms is not
intended to exclude other XML representations. The concepts defined
in this specification apply to all forms of XML
representations.</p>
<p>The content of this specification is normative except for
sections or texts that are explicitly marked as non-normative. If a
section is marked as non-normative, then all contained sub-sections
are non-normative, even if they are not explicitly marked as such.
All notes are non-normative unless otherwise specified.</p>
</div>
<div class="div2">
<h3><a name="Terminology" id="Terminology"></a>2.2 Terminology</h3>
<p>The following terms are used in this specification. They are
listed here in alphabetical order.</p>
<dl>
<dt class="label"><a name="document" id=
"document"></a>Document</dt>
<dd>
<p>A well-formed XML <b>document</b>, as defined in [<cite><a href=
"#XML10">XML</a></cite>].</p>
</dd>
<dt class="label"><a name="implementation_defined" id=
"implementation_defined"></a>Implementation-Defined</dt>
<dd>
<p>An <b>implementation-defined</b> feature or behavior may vary
among <a title="" href="#model">model processors</a>; the precise
behavior is not specified by this specification but <span class=
"rfc2119">MUST</span> be specified by the implementor of each
<a title="" href="#model">model processor</a>.</p>
</dd>
<dt class="label"><a name="implementation_dependent" id=
"implementation_dependent"></a>Implementation-Dependent</dt>
<dd>
<p>An <b>implementation-dependent</b> feature or behavior may vary
among <a title="" href="#model">model processors</a>; the precise
behavior is not specified by this or any other W3C specification
and is not required to be specified by the implementor for any
particular implementation.</p>
</dd>
<dt class="label"><a name="model" id="model"></a>Model</dt>
<dd>
<p>A set of inter-related <a title="" href=
"#document">documents</a> that describe a service or system.
&nbsp;Each <b>model</b> consists of two disjoint subsets of
documents – <a title="" href="#model_definition">model definition
documents</a> and <a title="" href="#model_instance">model instance
documents</a>.</p>
</dd>
<dt class="label"><a name="model_definition" id=
"model_definition"></a>Model Definition Documents</dt>
<dd>
<p>The subset of documents in a <a title="" href="#model">model</a>
that describes the schemas and rules that govern the structure and
content of the model's documents. This specification defines two
types of <b>model definition</b> document, <a title="" href=
"#schemaDocument">schema documents</a> and <a title="" href=
"#ruleDocument">rule documents</a>, but permits implementations to
define other types of model definition documents. Such other types
of model definition documents do not play any role in <a title=""
href="#model_validation_t">model validation</a>.</p>
</dd>
<dt class="label"><a name="model_instance" id=
"model_instance"></a>Model Instance Documents</dt>
<dd>
<p>The subset of documents in a <a title="" href="#model">model</a>
that describes the structure and content of the modeled
entities.</p>
</dd>
<dt class="label"><a name="model_processor" id=
"model_processor"></a>Model Processor</dt>
<dd>
<p>A <b>model processor</b> is an embodiment that processes a
conforming SML model using, in whole or in part, semantics defined
by this specification.</p>
</dd>
<dt class="label"><a name="model_validation_t" id=
"model_validation_t"></a>Model Validation</dt>
<dd>
<p><b>Model validation</b> is the process of determining whether or
not a <a title="" href="#model">model</a> is both conforming and
valid. [<a href="#Conformance"><b>8. Conformance
Criteria</b></a>]</p>
</dd>
<dt class="label"><a name="model_validator" id=
"model_validator"></a>Model Validator</dt>
<dd>
<p>A <b>model validator</b> is a <a title="" href="#model">model
processor</a> capable of performing <a title="" href=
"#model_validation_t">model validation.</a></p>
</dd>
<dt class="label"><a name="rule" id="rule"></a>Rule</dt>
<dd>
<p>A <b>rule</b> is a boolean expression that constrains the
structure and content of a set of documents in a <a title="" href=
"#model">model</a>.</p>
</dd>
<dt class="label"><a name="ruleBinding" id="ruleBinding"></a>Rule
Bindings</dt>
<dd>
<p>A <b>rule binding</b> is an association of a set of one or more
<a title="" href="#ruleDocument">rule documents</a> with a set of
zero or more model documents. The documents associated with a given
rule document are said to be "bound" to it. For a model to be
valid, every <a title="" href="#model_definition">definition
document</a> and <a title="" href="#model_instance">instance
document</a> in the <a title="" href="#model">model</a> must
conform to the constraints defined by every rule document it is
bound to. It is permissible for a rule document to have no bindings
associated with it, and for a model document to be bound to zero
rule documents.</p>
</dd>
<dt class="label"><a name="ruleDocument" id="ruleDocument"></a>Rule
Document</dt>
<dd>
<p>A <b>rule document</b> is a <a title="" href=
"#model_definition">model definition document</a> consisting of
<a title="" href="#schematron_constraint">Schematron
constraints</a>.</p>
</dd>
<dt class="label"><a name="schemaDocument" id=
"schemaDocument"></a>Schema document</dt>
<dd>
<p>A <b>schema document</b> is a <a title="" href=
"#model_definition">model definition document</a> that conforms to
the XML Schema specification [<a href="#XSD1">XML Schema
Structures</a>] definition of a schema document.</p>
</dd>
<dt class="label"><a name="schematron_constraint" id=
"schematron_constraint"></a>Schematron Constraint</dt>
<dd>
<p>The information contained within a single
<code>sch:schema</code> element.</p>
</dd>
<dt class="label"><a name="reference" id="reference"></a>SML
Reference</dt>
<dd>
<p>An <b>SML Reference</b> is an element with an sml:ref attribute
whose value is "true".</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Conceptually, an SML reference is used to signal a link from one
element in an SML model to another element in the same model.</p>
</div>
</dd>
<dt class="label"><a name="reference_scheme" id=
"reference_scheme"></a>SML Reference Scheme</dt>
<dd>
<p>An <b>SML Reference Scheme</b> is a set of rules defining the
syntax used to create an instance of the reference scheme in the
context of an <a title="" href="#reference">SML reference</a>, plus
a set of rules for resolving an instance of the reference scheme to
its <a title="" href="#target">target</a>. Whenever "reference
scheme" occurs in this specification, it should be assumed to mean
"SML reference scheme" unless otherwise noted. Despite similar
names, the term SML reference scheme is unrelated to XPointer
schemes and URI schemes.</p>
</dd>
<dt class="label"><a name="target" id="target"></a>Target</dt>
<dd>
<p>An element in a model to which an <a title="" href=
"#reference">SML reference</a> resolves is called the <b>target</b>
of that SML reference.</p>
</dd>
<dt class="label"><a name="target_complete_identifier" id=
"target_complete_identifier"></a>Target-complete Identifier</dt>
<dd>
<p>A <b>target-complete identifier</b> is a URI or IRI that
contains all the information required to locate the <a title=""
href="#target">target</a> of an <a title="" href="#reference">SML
reference</a>. It is a consequence of this definition that a
target-complete identifier cannot be a relative URI/IRI.</p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="XML_Namespaces" id="XML_Namespaces"></a>2.3 XML
Namespaces</h3>
<p><a href="#Table1">Table 2-1</a> lists XML namespaces that are
used in this specification. The choice of any namespace prefix is
arbitrary and not semantically significant.</p>
<a name="Table1" id="Table1"></a>
<table border="1" cellspacing="0" cellpadding="5">
<caption>Table 2-1. XML Namespaces used in this
specification.</caption>
<thead>
<tr>
<th rowspan="1" colspan="1">Prefix</th>
<th rowspan="1" colspan="1">XML Namespace</th>
<th rowspan="1" colspan="1">Specification(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1"><code>sml</code></td>
<td rowspan="1" colspan="1">
<code>http://www.w3.org/ns/sml</code></td>
<td rowspan="1" colspan="1">This specification</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>smlfn</code></td>
<td rowspan="1" colspan="1">
<code>http://www.w3.org/ns/sml-function</code></td>
<td rowspan="1" colspan="1">This specification</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>xs</code></td>
<td rowspan="1" colspan="1">
<code>http://www.w3.org/2001/XMLSchema</code></td>
<td rowspan="1" colspan="1">[<cite><a href="#XSD1">XML Schema
Structures</a></cite>, <cite><a href="#XSD2">XML Schema
Datatypes</a></cite>]</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sch</code></td>
<td rowspan="1" colspan="1">
<code>http://purl.oclc.org/dsdl/schematron</code></td>
<td rowspan="1" colspan="1">[<cite><a href="#Schematron">ISO/IEC
19757-3</a></cite>]</td>
</tr>
</tbody>
</table>
<br /></div>
</div>
<div class="div1">
<h2><a name="Dependencies" id="Dependencies"></a>3. Dependencies on
Other Specifications</h2>
<p>Other specifications on which this one depends are listed in
[<cite><a href=
"#Normative-References">Normative-References</a></cite>].</p>
</div>
<div class="div1">
<h2><a name="References" id="References"></a>4. SML References</h2>
<p>Support for <a title="" href="#reference">SML references</a> in
an SML <a title="" href="#model">model</a> includes:</p>
<ol class="enumar">
<li>
<p>The ability to use multiple SML reference schemes for an SML
reference.</p>
</li>
<li>
<p>An extensibility mechanism allowing new SML reference schemes to
be defined.</p>
</li>
<li>
<p>Constraints on the type of a referenced element.</p>
</li>
<li>
<p>The ability to define key, unique, and key reference constraints
across SML references.</p>
</li>
</ol>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> support <a title="" href=
"#reference">SML references</a> as defined by this
specification.</p>
<p>Appendix <a href="#SML_References_Sample"><b>C. SML References
Sample</b></a> has an example that shows how SML references are
defined and used.</p>
<div class="div2">
<h3><a name="Reference_Definitions" id=
"Reference_Definitions"></a>4.1 SML Reference Definitions</h3>
<div class="div3">
<h4><a name="SML_Reference" id="SML_Reference"></a>4.1.1 SML
Reference</h4>
<p>An element information item in an SML model instance document is
as an <a title="" href="#reference">SML reference</a> if and only
if it has an attribute information item for which all of the
following is true:</p>
<ol class="enumar">
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[local
name]</a> is <code>ref</code></p>
</li>
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[namespace
name]</a> is <code>http://www.w3.org/ns/sml</code></p>
</li>
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[normalized
value]</a>, after whitespace normalization using
<code>collapse</code> following <a href=
"http://www.w3.org/TR/xmlschema-2/">schema rules</a>, is either
<code>"true"</code> or <code>"1"</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This mechanism enables schema-less identification of SML
references; i.e., SML references can be identified without relying
on the Post Schema Validation Infoset (PSVI). [<cite><a href=
"#XSD1">XML Schema Structures</a></cite>]</p>
</div>
<p>It is implementation-defined whether <a title="" href=
"#model_processor">model processors</a> that are not also <a title=
"" href="#model_validator">model validators</a> use the XML Infoset
[<cite><a href="#XMLInfoset">XML Information Set</a></cite>] or the
Post Schema Validation Infoset (PSVI) [<cite><a href="#XSD1">XML
Schema Structures</a></cite>] for SML reference identification.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>SML model validators must use PSVI to identify SML references.
See <a href="#Conformance"><b>8. Conformance Criteria</b></a>.</p>
</div>
<p>An SML reference is considered to be an instance of a specific
SML <a title="" href="#reference_scheme">reference scheme</a> if it
can be identified as such according to that SML reference scheme's
rules. See <a href="#Reference_Schemes"><b>4.3 SML Reference
Schemes</b></a>. An SML reference MAY be an instance of multiple
SML reference schemes.</p>
<p>Although its normative definition allows several syntaxes to be
used to identify an SML reference, for the sake of brevity and
consistency, the rest of this specification uses
<code>sml:ref="true"</code> to denote an SML reference in examples
and text.</p>
<p>The following example shows an SML reference that is an instance
of the SML URI Reference scheme.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true"&gt;
    &lt;sml:uri&gt;targetDocument.xml&lt;/sml:uri&gt;
&lt;/RefElement&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Null_Reference" id="Null_Reference"></a>4.1.2 Null SML
Reference</h4>
<p>An SML reference is null if and only if it has an attribute
information item for which all of the following is true</p>
<ol class="enumar">
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[local
name]</a> is <code>nilref</code></p>
</li>
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[namespace
name]</a> is <code>http://www.w3.org/ns/sml</code></p>
</li>
<li>
<p>Its <a href=
"http://www.w3.org/TR/xml-infoset/#infoitem.attribute">[normalized
value]</a> after whitespace normalization using
<code>collapse</code> following <a href=
"http://www.w3.org/TR/xmlschema-2/">schema rules</a>, is either
<code>"true"</code> or <code>"1"</code>.</p>
</li>
</ol>
<p>It is a consequence of the preceding that this specification
assigns no meaning to the <code>sml:nilref</code> attribute when it
is used on an element that is not an SML reference. Model
validators <span class="rfc2119">MAY</span> choose to warn their
invokers should they detect this condition in a document.</p>
<p>The following example shows a null SML reference.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true" sml:nilref="true"&gt;
    &lt;sml:uri&gt;targetDocument.xml&lt;/sml:uri&gt;
&lt;/RefElement&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>sml:nilref</code> may be useful in the case where the
schema author defines a complex type specifying
<code>sml:ref="true"</code> with a fixed value of "true", but the
instance author wants to signal the absence of a target.</p>
</div>
<p>It is implementation-defined whether <a title="" href=
"#model_processor">model processors</a> that are not also <a title=
"" href="#model_validator">model validators</a> use the XML Infoset
[<cite><a href="#XMLInfoset">XML Information Set</a></cite>] or the
Post Schema Validation Infoset (PSVI) [<cite><a href="#XSD1">XML
Schema Structures</a></cite>] to identify null SML references.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>SML model validators must use PSVI to identify null SML
references. See <a href="#Conformance"><b>8. Conformance
Criteria</b></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="Unresolved_Reference" id=
"Unresolved_Reference"></a>4.1.3 Unresolved SML Reference</h4>
<p>An SML reference is unresolved if and only if all of the
following is true:</p>
<ol class="enumar">
<li>
<p>It is a non-null SML reference.</p>
</li>
<li>
<p>None of the <a title="" href="#reference_scheme">reference
schemes</a>, which the SML reference is recognized as using,
resolves to an element in the model.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The notion of unresolved reference is context-dependent. That
is, different <a title="" href="#model_processor">model
processors</a>, based on the set of SML reference schemes they
understand and which are used in the model they process, may
consider different SML references to be unresolved.</p>
</div>
<p>The following example shows an unresolved SML reference
(assuming that the document <code>dummy.xml</code> does not exist
in the model).</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true"&gt;
    &lt;sml:uri&gt;dummy.xml&lt;/sml:uri&gt;
&lt;/RefElement&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="SML_Reference_Target" id=
"SML_Reference_Target"></a>4.1.4 SML Reference Target</h4>
<p>The element node that a non-null SML reference resolves to is
its target. The target of an SML reference <span class=
"rfc2119">MUST</span> be part of the same SML model as the SML
reference. Null SML references have no target.</p>
<p>The method of determining which documents are part of an SML
model is implementation-defined.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, an SML model may consist of documents listed in a
configuration file or an SML model could be construed as the
transitive closure of documents referred to by any SML references
starting from a set of documents known to be in the model.</p>
</div>
<p>The following example shows an SML reference that targets the
second <code>Course</code> child element of the root element of the
document <code>target.xml</code>.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true" xmlns:e="urn:example"&gt;
    &lt;sml:uri&gt;target.xml#smlxpath1(e:Course[2])&lt;/sml:uri&gt;
&lt;/RefElement&gt;

document 'target.xml':
----------------------
&lt;Courses xmlns="urn:example"&gt;
    &lt;Course&gt;
        &lt;Name&gt;PHY101&lt;/Name&gt;
        &lt;Grade&gt;A&lt;/Grade&gt;
    &lt;/Course&gt;
    &lt;Course&gt;
        &lt;Name&gt;MAT101&lt;/Name&gt;
        &lt;Grade&gt;A&lt;/Grade&gt;
    &lt;/Course&gt;
&lt;/Courses&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="Reference_Semantics" id="Reference_Semantics"></a>4.2
SML Reference Semantics</h3>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> attempt to resolve an SML
reference using all the reference schemes of which the SML
reference is recognized as an instance.</p>
<div class="div3">
<h4><a name="At_Most_One_Target" id="At_Most_One_Target"></a>4.2.1
At Most One Target</h4>
<p>Every non-null SML reference <span class="rfc2119">MUST</span>
target at most one element in a <a title="" href=
"#model">model</a>. This means that each recognized reference
scheme used in the SML reference <span class="rfc2119">MUST
NOT</span> resolve to more than one target.</p>
<p>The following example shows an SML reference that violates the
at-most-one-target rule.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true" xmlns:e="urn:example"&gt;
    &lt;sml:uri&gt;target.xml#smlxpath1(e:Course)&lt;/sml:uri&gt;
&lt;/RefElement&gt;

document 'target.xml':
----------------------
&lt;Courses xmlns="urn:example"&gt;
    &lt;Course&gt;
        &lt;Name&gt;PHY101&lt;/Name&gt;
        &lt;Grade&gt;A&lt;/Grade&gt;
    &lt;/Course&gt;
    &lt;Course&gt;
        &lt;Name&gt;MAT101&lt;/Name&gt;
        &lt;Grade&gt;A&lt;/Grade&gt;
    &lt;/Course&gt;
&lt;/Courses&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Consistent_References" id=
"Consistent_References"></a>4.2.2 Consistent References</h4>
<p>If a non-null SML reference is an instance of multiple reference
schemes, all recognized reference schemes <span class=
"rfc2119">MUST</span> resolve to the same target or they all
<span class="rfc2119">MUST</span> be unresolved.</p>
</div>
<div class="div3">
<h4><a name="Identical_Targets" id="Identical_Targets"></a>4.2.3
Identical Targets</h4>
<p>To determine if two targets are the same or different, <a title=
"" href="#model_validator">model validators</a> MUST obey the
following rules.</p>
<ol class="enumar">
<li>
<p>If both of the following are true, then a model validator
<span class="rfc2119">MUST</span> consider both targets to be the
same.</p>
<ol class="enumla">
<li>
<p>The definition of the reference scheme(s) specifies how URIs are
transformed to <a title="" href=
"#target_complete_identifier">target-complete identifiers</a>.</p>
</li>
<li>
<p>The two target-complete identifiers are identical using a
case-sensitive, codepoint-by-codepoint comparison.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, a model validator <span class="rfc2119">MUST</span>
consider both targets to be different when there is something
available in the element information items for the targets that
tells them apart. For example, if there is an infoset property for
which the 2 targets have different values, they are different. This
applies recursively for complex-valued properties.</p>
</li>
<li>
<p>For all other cases, it is implementation-defined whether to
treat the targets as the same or not.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="Multiple_References" id=
"Multiple_References"></a>4.2.4 Multiple References &nbsp;</h4>
<p>An element in a document <span class="rfc2119">MAY</span> be
targeted by multiple SML references.</p>
</div>
<div class="div3">
<h4><a name="Null_References" id="Null_References"></a>4.2.5 Null
SML References</h4>
<p>A null SML reference is an explicit declaration of intent by the
document author that the <a title="" href="#target">target</a> of
the SML reference does not exist. If an SML reference is recognized
as null, then <a title="" href="#model">model processors</a>
<span class="rfc2119">MUST NOT</span> attempt to recognize any
reference schemes used in it.</p>
</div>
<div class="div3">
<h4><a name="Deterministic_References" id=
"Deterministic_References"></a>4.2.6 Deterministic Evaluation of
SML Constraints</h4>
<p>Each non-null SML reference <span class="rfc2119">MUST</span>
satisfy all of the following conditions in order to be able to
deterministically evaluate SML constraints and rules associated
with it.</p>
<ol class="enumar">
<li>
<p>The reference must have at most one target. [<a href=
"#At_Most_One_Target"><b>4.2.1 At Most One Target</b></a>]</p>
</li>
<li>
<p>The reference <span class="rfc2119">MUST</span> be consistent.
[<a href="#Consistent_References"><b>4.2.2 Consistent
References</b></a>]</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="deref_XPath_Extension_Function" id=
"deref_XPath_Extension_Function"></a>4.2.7 smlfn:deref() XPath
Extension Function</h4>
<p>The <code>deref()</code> function takes a node set of elements
and returns a node set consisting of element nodes corresponding to
the elements referenced by the input node set. &nbsp;In particular,
for each SML reference R in the input node set the output node set
contains at most one element node.</p>
<p>Let I = input node set; that is, the set of nodes passed to the
<code>deref()</code> function.</p>
<p>Let O = output node set; that is, the set of nodes returned by
the <code>deref()</code> function.</p>
<p>The behavior of <code>deref()</code> function <span class=
"rfc2119">MUST</span> satisfy the following constraints:</p>
<ol class="enumar">
<li>
<p>For each SML reference R in the input node set I:</p>
<ol class="enumla">
<li>
<p>If the implementation recognizes no SML reference scheme used in
the SML reference R, then no element is added to O.</p>
</li>
<li>
<p>If the implementation recognizes R as an instance of N supported
reference schemes, then <code>deref()</code> is not required to
attempt to resolve all N schemes. Its behavior in this case is
implementation-defined and the set of reference schemes that are
actually attempted may be any subset of the recognized schemes.
This is subject to the following constraints:</p>
<ol class="enumlr">
<li>
<p>If deref() doesn't attempt to resolve any reference scheme or if
none of the attempted reference schemes resolves, then no element
is added to O.</p>
</li>
<li>
<p>If at least one of the attempted reference schemes resolves to
more than one target element, then 0 or 1 of the targets is added
to O.</p>
</li>
<li>
<p>If one attempted reference scheme resolves to a target different
from the target resolved by another attempted reference scheme,
then 0 or 1 of the targets is added to O.</p>
</li>
<li>
<p>If one attempted reference scheme resolves and another doesn't,
then 0 or 1 of the targets is added to O.</p>
</li>
<li>
<p>If none of the above is true (that is, all attempted reference
schemes resolve to the same one and only one target element, call
it T), then one target element (namely, T) is added to O, if it
does not already exist in O.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above describes the behavior required for a general XPath
1.0 deref() library function, and as such exhibits several
significant differences from the behavior required to validate SML
references during model validation. First, it can be used to
successfully process instance documents whose SML model validity is
unknown or invalid, although the results in this case may not be
interoperable. Second, since XPath 1.0 defines no way for a
function to signal erroneous input to its caller, the behavior here
is specified to return results for SML references that do not obey
all of the validity rules, e.g. a reference whose XPath expression
evaluates to more than one node. As described in this section, such
a function would be insufficient to check the validity of SML
references.</p>
</div>
<p>Model validators MUST provide an implementation of the deref()
XPath extension function. In addition to the above requirements for
general deref() function implementations, for each SML reference
using recognized schemes, deref() in model validators MUST attempt
to resolve at least one of the recognized schemes.</p>
</div>
</div>
<div class="div2">
<h3><a name="Reference_Schemes" id="Reference_Schemes"></a>4.3 SML
Reference Schemes</h3>
<p>An SML reference <span class="rfc2119">MAY</span> be an instance
of a variety of reference schemes. SML does not mandate the use of
any specific reference schemes. An SML reference scheme
<span class="rfc2119">MAY</span> use child elements, attributes,
both, or neither to capture the information necessary to identify
the reference target. It is <span class="rfc2119">OPTIONAL</span>
that all elements in an SML model be reachable via an SML
reference. This will depend on the support defined by the chosen
reference scheme.</p>
<p>Although SML does not require the use of any specific scheme, it
does specify how a reference <span class="rfc2119">MUST</span> be
represented when using SML-defined reference schemes. This
specification defines the <a href="#URI_Reference_Scheme"><b>4.3.1
SML URI Reference Scheme</b></a> for use in SML references.</p>
<p>An SML reference scheme definition <span class=
"rfc2119">MUST</span> specify all of the following:</p>
<ol class="enumar">
<li>
<p>The set of rules that, when satisfied, identify an SML reference
as an instance of the scheme. An SML reference scheme definition
<span class="rfc2119">MAY</span> impose additional validity
requirements on SML references recognized as instances of that
scheme. <a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST NOT</span> apply such requirements to
SML references that are not instances of the corresponding
reference scheme.</p>
</li>
<li>
<p>The set of rules that, when evaluated, resolve the SML reference
to its target element node.</p>
</li>
<li>
<p>An assertion that states whether instances of the reference
scheme are transformed to <a title="" href=
"#target_complete_identifier">target-complete identifiers</a>. If
they are transformed to <a title="" href=
"#target_complete_identifier">target-complete identifiers</a>, the
reference scheme definition MUST describe the transformation
process.</p>
</li>
</ol>
<p>An SML reference scheme definition <span class=
"rfc2119">MUST</span> specify all of the preceding items as they
apply to valid instances of the SML reference scheme, and
<span class="rfc2119">MAY</span> specify them for other (invalid)
instances.</p>
<div class="div3">
<h4><a name="URI_Reference_Scheme" id=
"URI_Reference_Scheme"></a>4.3.1 SML URI Reference Scheme</h4>
<p>The SML URI Reference Scheme is defined as follows:</p>
<ol class="enumar">
<li>
<p>An SML reference is identified as an instance of the SML URI
Reference Scheme if and only if exactly one element information
item [<cite><a href="#XMLInfoset">XML Information Set</a></cite>]
whose [local name] is <code>uri</code> and whose [namespace name]
is <code>http://www.w3.org/ns/sml</code> is present as a child of
that reference element.</p>
<p>An instance of the SML reference scheme is valid if it meets all
of the following requirements.</p>
<ol class="enumla">
<li>
<p>The content of the <code>uri</code> element <span class=
"rfc2119">MUST</span> be of type <code>xs:anyURI</code> as defined
in the XML schema specification [<cite><a href="#XSD2">XML Schema
Datatypes</a></cite>].</p>
</li>
<li>
<p>The fragment identifier (if present) <span class=
"rfc2119">MUST</span> follow the syntax of one of the
following.</p>
<ol class="enumlr">
<li>
<p><a href="#SMLXPath1_Scheme"><b>4.3.1.1 smlxpath1()
scheme</b></a></p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xptr-framework/#shorthand">Shorthand
Pointer</a></p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>An SML reference that is an instance of the SML URI Reference
Scheme is resolved using the following steps:</p>
<ol class="enumla">
<li>
<p>An XML document <b>D</b> is obtained as follows:</p>
<ol class="enumlr">
<li>
<p>If the URI reference is a same-document reference as defined in
the applicable URI RFC, then <b>D</b> is the document containing
the SML reference.</p>
</li>
<li>
<p>Otherwise, <b>D</b> is determined as follows:</p>
<ol class="enumua">
<li>
<p>If the URI reference is a relative reference, then let <b>U</b>
be the result of resolving the reference using the [base URI]
property [<cite><a href="#XMLInfoset">XML Information
Set</a></cite>] of the <code>&lt;sml:uri&gt;</code> element as the
base URI. Otherwise, <b>U</b> is the URI reference itself. The
computation of the [base URI] property is
implementation-defined.</p>
</li>
<li>
<p>Dereference <b>U</b> as defined in the applicable
specifications. If the document targeted by <b>U</b> is in the
current SML model, then <b>D</b> is that document. Otherwise, if
the document is not in the current SML model, then the SML URI
Reference Scheme instance is unresolved (and <b>D</b> has no
value).</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As a result of the above definition, if the retrieved object is
not of XML media type or if it is not well-formed XML then, by
definition, that object is not a document as defined by this
specification. In this case, the SML reference scheme instance is
unresolved.</p>
</div>
</li>
<li>
<p>If no fragment component is present in the URI reference, the
SML URI Reference Scheme instance resolves to the root element of
<b>D</b>.</p>
</li>
<li>
<p>If a fragment component is present in the URI reference, then
the appropriate case among the following applies:</p>
<ol class="enumlr">
<li>
<p>If the fragment component complies with the
<code>smlxpath1()</code> XPointer scheme syntax, then the reference
target is obtained by applying the fragment component to <b>D</b>,
as defined in section <a href="#SMLXPath1_Scheme"><b>4.3.1.1
smlxpath1() scheme</b></a> .</p>
</li>
<li>
<p>If the fragment component complies with the <a href=
"http://www.w3.org/TR/xptr-framework/#shorthand">Shorthand
Pointer</a> syntax, then the appropriate case among the following
applies:</p>
<ol class="enumua">
<li>
<p>If a target <b>T</b> can be identified in <b>D</b> based on the
<a href=
"http://www.w3.org/TR/xptr-framework/#term-sdi">XML-Schema-determined
ID</a>, then the reference target is <b>T</b>.</p>
</li>
<li>
<p>If a target in <b>D</b> cannot be identified based on the
<a href=
"http://www.w3.org/TR/xptr-framework/#term-sdi">XML-Schema-determined
ID</a>, then it is implementation-defined whether the reference
target in <b>D</b> is identified based on other criteria allowed
for <a href=
"http://www.w3.org/TR/xptr-framework/#shorthand">Shorthand
Pointers</a>.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Instances of the SML URI Reference Scheme are transformed to
<a title="" href="#target_complete_identifier">target-complete
identifiers</a> through standard URI processing, as described in
the applicable URI RFC.</p>
</li>
</ol>
<p>The following example shows an SML reference that is an instance
of the SML URI Reference scheme. The reference targets the element
with ID <code>targetId</code> in document
<code>target.xml</code>.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true"&gt;
    &lt;sml:uri&gt;target.xml#targetId&lt;/sml:uri&gt;
&lt;/RefElement&gt;
</pre></div>
<div class="div4">
<h5><a name="SMLXPath1_Scheme" id="SMLXPath1_Scheme"></a>4.3.1.1
<code>smlxpath1()</code> scheme</h5>
<p>The <code>smlxpath1()</code> scheme is intended to be used with
the XPointer Framework [<cite><a href="#XPTR">XPointer</a></cite>]
to allow addressing of elements. The <a href=
"#URI_Reference_Scheme"><b>4.3.1 SML URI Reference Scheme</b></a>
uses it to encode fragment identifiers.</p>
<p>This section describes the syntax and semantics of the
<code>smlxpath1()</code> scheme and the behavior of XPointer
processors with respect to this scheme.</p>
<ol class="enumar">
<li>
<p>Scheme name: <code>smlxpath1</code></p>
</li>
<li>
<p>Scheme syntax using ABNF [<cite><a href="#RFC2234">RFC
2234</a></cite>]:</p>
<p><code>SMLXPath1_Fragment_ID ::= 'smlxpath1' '('
SMLXPath1_SchemeData ')'</code></p>
<p><code>SMLXPath1_SchemeData ::= XPath1.0_LocationPath</code></p>
<p>where,</p>
<p><code>XPath1.0_LocationPath</code> is the <a href=
"http://www.w3.org/TR/1999/REC-xpath-19991116#NT-LocationPath">LocationPath
production</a> defined in the XPath 1.0 specification
[<cite><a href="#XPath">XPath</a></cite>].</p>
</li>
<li>
<p>The <code>deref()</code> XPath extension function <span class=
"rfc2119">MUST NOT</span> be present in the expression evaluation
context function library when processing the location path in
<code>SMLXPath1_SchemeData</code>.</p>
</li>
<li>
<p>Namespace Binding Context: The <code>smlxpath1()</code> scheme
inherits the set of namespace bindings available to the parent
<code>sml:uri</code> element.</p>
</li>
<li>
<p>For a given document <b>D</b>, the element targeted by a scheme
instance is obtained by applying the location path in
<code>SMLXPath1_SchemeData</code> to the root element of <b>D</b>.
The result <span class="rfc2119">MUST</span> either be 1 element
node or be empty. Otherwise, the XPointer result is an error.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the case of instances of the SML URI Reference scheme,
<b>D</b> is the document resolved to by the non-fragment part of
the URI reference, as defined in item 2.a in section <a href=
"#URI_Reference_Scheme"><b>4.3.1 SML URI Reference
Scheme</b></a>.</p>
</div>
</li>
</ol>
<p>The following example shows an SML reference that is an instance
of the SML URI Reference scheme. The reference targets the root
element of the document <code>target.xml</code>.</p>
<div class="exampleInner">
<pre>
&lt;RefElement sml:ref="true"&gt;
    &lt;sml:uri&gt;target.xml#smlxpath1(/*)&lt;/sml:uri&gt;
&lt;/RefElement&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="SML_constraints" id="SML_constraints"></a>5. SML
Constraints</h2>
<div class="div2">
<h3><a name="Constraints_on_References" id=
"Constraints_on_References"></a>5.1 Constraints on SML
References</h3>
<p>SML supports the following attributes for expressing constraints
on SML references.</p>
<a name="Table3" id="Table3"></a>
<table border="1" cellspacing="0" cellpadding="5">
<caption>Table 5-1. Attributes</caption>
<thead>
<tr>
<th rowspan="1" colspan="1">Name</th>
<th rowspan="1" colspan="1">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1"><code>sml:acyclic</code></td>
<td rowspan="1" colspan="1">Used to specify whether cycles are
prohibited for an SML reference.</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sml:targetRequired</code></td>
<td rowspan="1" colspan="1">Used to specify that an SML reference's
target element is required to be present in the model.</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sml:targetElement</code></td>
<td rowspan="1" colspan="1">Used to constrain the name of the SML
reference's target.</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sml:targetType</code></td>
<td rowspan="1" colspan="1">Used to constrain the type of the SML
reference's target.</td>
</tr>
</tbody>
</table>
<br />
<p>SML defines a new property for every Complex Type Definition
schema component:</p>
<dl>
<dt class="label"><a name="acyclic" id="acyclic"></a>{acyclic}</dt>
<dd>
<p>An <code>xs:boolean</code> value. Required.</p>
</dd>
</dl>
<p>The value of <a title="" href="#acyclic">{acyclic}</a> for
<code>xs:anyType</code> is <code>false</code>.</p>
<p>SML defines three new properties for every Element Declaration
component:</p>
<dl>
<dt class="label"><a name="targetRequired" id=
"targetRequired"></a>{target required}</dt>
<dd>
<p>An <code>xs:boolean</code> value. Required.</p>
</dd>
<dt class="label"><a name="targetElement" id=
"targetElement"></a>{target element}</dt>
<dd>
<p>An Element Declaration component. Optional.</p>
</dd>
<dt class="label"><a name="targetType" id="targetType"></a>{target
type}</dt>
<dd>
<p>A Type Definition component. Optional.</p>
</dd>
</dl>
<div class="div3">
<h4><a name="sml_acyclic" id="sml_acyclic"></a>5.1.1
sml:acyclic</h4>
<p><code>sml:acyclic</code> is used to specify whether or not a
cycle is allowed on instances of a complex type. <a title="" href=
"#model_validator">Model validators</a> <span class=
"rfc2119">MUST</span> support the <code>sml:acyclic</code>
attribute on any <code>&lt;xs:complexType&gt;</code> element in a
schema document. This attribute is of type <code>xs:boolean</code>
and its <a href=
"http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-vv">actual
value</a> can be either <code>true</code> or
<code>false</code>.</p>
<div class="div4">
<h5><a name="Acyclic_Mapping_From_Schema" id=
"Acyclic_Mapping_From_Schema"></a>5.1.1.1 SML Constraint
Construction</h5>
<p>The <a title="" href="#acyclic">{acyclic}</a> property value of
a complex type definition is as specified by the appropriate case
among the following:</p>
<ol class="enumar">
<li>
<p>If <code>sml:acyclic</code> is present, then <a title="" href=
"#acyclic">{acyclic}</a> has the actual value of this
attribute.</p>
</li>
<li>
<p>Otherwise, if its {base type definition} is a complex type
definition, then <a title="" href="#acyclic">{acyclic}</a> has the
same value of <a title="" href="#acyclic">{acyclic}</a> as its
{base type definition}.</p>
</li>
<li>
<p>Otherwise ({base type definition} is a simple type definition),
<a title="" href="#acyclic">{acyclic}</a> is false.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="Acyclic_Schema_Validity_Rules" id=
"Acyclic_Schema_Validity_Rules"></a>5.1.1.2 Schema Component
Rules</h5>
<p>If a complex type definition <b>CT</b>'s {base type definition}
is also a complex type definition and has <a title="" href=
"#acyclic">{acyclic}</a> true, then <b>CT</b> <span class=
"rfc2119">MUST</span> have <a title="" href=
"#acyclic">{acyclic}</a> true.</p>
</div>
<div class="div4">
<h5><a name="Acyclic_Instance_Validity_Rules" id=
"Acyclic_Instance_Validity_Rules"></a>5.1.1.3 Instance Validity
Rules</h5>
<p>If <b>CT</b> is a complex type definition with <a title="" href=
"#acyclic">{acyclic}</a> true, then instances of <b>CT</b>
<span class="rfc2119">MUST NOT</span> create cycles in the model.
More precisely, the directed graph constructed in the following way
<span class="rfc2119">MUST</span> be acyclic:</p>
<ol class="enumar">
<li>
<p>The nodes in the graph are all the elements resolved to by SML
references of type <b>CT</b> or types derived from <b>CT</b>.</p>
</li>
<li>
<p>If a node <b>N</b> in the graph is or contains an SML reference
<b>R</b> of type <b>CT</b> or a type derived from <b>CT</b>, and
<b>R</b> resolves to <b>T</b> (which must also be a node in the
graph), then an arc is drawn from <b>N</b> to <b>T</b>.</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="Constraints_on_Targets" id=
"Constraints_on_Targets"></a>5.1.2 Constraints on SML Reference
Targets</h4>
<p>SML defines three attributes: <code>sml:targetRequired</code>,
<code>sml:targetElement</code>, and <code>sml:targetType,</code>
for constraining the target of an SML reference. These three
attributes are collectively called <code>sml:target*</code>
attributes. <a title="" href="#model_validator">Model
validators</a> <span class="rfc2119">MUST</span> support these
attributes on all <code>xs:element</code> elements with a name
attribute. The <code>sml:target*</code> constraints are attached to
the element declaration schema component.</p>
<div class="div4">
<h5><a name="Target_Mapping_From_Schema" id=
"Target_Mapping_From_Schema"></a>5.1.2.1 SML Constraint
Construction</h5>
<ol class="enumar">
<li>
<p><a title="" href="#targetRequired">{target required}</a> is as
specified by the appropriate case among the following:</p>
<ol class="enumla">
<li>
<p>If <code>sml:targetRequired</code> is present, then <a title=""
href="#targetRequired">{target required}</a> is the actual value of
this attribute.</p>
</li>
<li>
<p>Otherwise if the element declaration has a {substitution group
affiliation}, then <a title="" href="#targetRequired">{target
required}</a> is the same as that of the {substitution group
affiliation}.</p>
</li>
<li>
<p>Otherwise <a title="" href="#targetRequired">{target
required}</a> is false.</p>
</li>
</ol>
</li>
<li>
<p><a title="" href="#targetElement">{target element}</a> is as
specified by the appropriate case among the following:</p>
<ol class="enumla">
<li>
<p>If <code>sml:targetElement</code> is present, then its actual
value <span class="rfc2119">MUST</span> resolve to a global element
declaration <b>G</b>, and <a title="" href="#targetElement">{target
element}</a> is <b>G</b>.</p>
</li>
<li>
<p>Otherwise if {substitution group affiliation} is present, then
<a title="" href="#targetElement">{target element}</a> is the same
as that of the {substitution group affiliation}.</p>
</li>
<li>
<p>Otherwise <a title="" href="#targetElement">{target element}</a>
is absent.</p>
</li>
</ol>
</li>
<li>
<p><a title="" href="#targetType">{target type}</a> is as specified
by the appropriate case among the following:</p>
<ol class="enumla">
<li>
<p>If <code>sml:targetType</code> is present, then its actual value
<span class="rfc2119">MUST</span> resolve to a global type
definition <b>T</b>, and <a title="" href="#targetType">{target
type}</a> is <b>T</b>.</p>
</li>
<li>
<p>Otherwise if {substitution group affiliation} is present, then
<a title="" href="#targetType">{target type}</a> is the same as
that of the {substitution group affiliation}.</p>
</li>
<li>
<p>Otherwise <a title="" href="#targetType">{target type}</a> is
absent.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="Target_Schema_Validity_Rules" id=
"Target_Schema_Validity_Rules"></a>5.1.2.2 Schema Component
Rules</h5>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> enforce the following:</p>
<ol class="enumar">
<li>
<p>If a global element declaration <b>E</b> has a {substitution
group affiliation} <b>G</b>, then the value of <b>E</b>'s SML
target constraint property P (one of <a title="" href=
"#targetRequired">{target required}</a>, <a title="" href=
"#targetElement">{target element}</a> or <a title="" href=
"#targetType">{target type}</a>) <span class="rfc2119">MUST</span>
be a valid restriction of the corresponding property of <b>G</b> as
defined in section <a href="#Constraints_Valid_Restriction"><b>5.3
Valid Restriction of SML Constraint Values</b></a>.</p>
</li>
<li>
<p>If two element declarations <b>E1</b> and <b>E2</b> have the
same {namespace name} and {name} and they are both contained
(directly, indirectly, or implicitly) in a content model of a
complex type, then <b>E1</b> and <b>E2</b> have the same <a title=
"" href="#targetRequired">{target required}</a>, <a title="" href=
"#targetElement">{target element}</a>, and <a title="" href=
"#targetType">{target type}</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above condition #2 on the use of <code>sml:target*</code>
attributes has been defined to reduce the implementation
burden&nbsp;on <a title="" href="#model_validator">model
validators</a>. Please refer to section <a href=
"#Sml_Constraints_and_Derivation_Overview"><b>5.4.1 Overview of SML
Constraint Processing and Complex Type Derivation</b></a> for more
information.</p>
</div>
</div>
<div class="div4">
<h5><a name="Target_Instance_Validity_Rules" id=
"Target_Instance_Validity_Rules"></a>5.1.2.3 Instance Validity
Rules</h5>
<p>If an element declaration <b>E</b> has <a title="" href=
"#targetRequired">{target required}</a> <code>true</code>, then
each element instance of <b>E</b> that is also an SML reference
<span class="rfc2119">MUST</span> target some element in the model.
That is, no instance of <b>E</b> can be a null or unresolved SML
reference.</p>
<p>If an element declaration <b>E</b> has <a title="" href=
"#targetElement">{target element}</a> <b>TE</b>, then each element
instance of <b>E</b> that is also a resolved SML reference
<span class="rfc2119">MUST</span> target an element that is an
instance of <b>TE</b> or an instance of some global element
declaration in the substitution group of <b>TE</b>.</p>
<p>If an element declaration <b>E</b> has <a title="" href=
"#targetType">{target type}</a> <b>TT</b>, then each element
instance of <b>E</b> that is also a resolved SML reference
<span class="rfc2119">MUST</span> target an element whose [type
definition] is <b>TT</b> or a type derived from <b>TT</b>.</p>
</div>
</div>
<div class="div3">
<h4><a name="constraints_summary" id=
"constraints_summary"></a>5.1.3 SML Reference Constraints Summary
(Non-Normative)</h4>
<p>The effect of the above instance validation rules is summarized
in the following table.</p>
<a name="Table_TargetConstraintsAndRefCategories" id=
"Table_TargetConstraintsAndRefCategories"></a>
<table border="1" cellspacing="0" cellpadding="5">
<caption>Table 5-2. Target Constraints and SML Reference
Categories.</caption>
<thead>
<tr>
<th rowspan="1" colspan="1">Reference Category</th>
<th rowspan="1" colspan="1"><code>Acyclic</code></th>
<th rowspan="1" colspan="1"><code>targetRequired</code></th>
<th rowspan="1" colspan="1"><code>targetElement</code></th>
<th rowspan="1" colspan="1"><code>targetType</code></th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1">Non-reference</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Satisfied</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Null</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Violated</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Satisfied</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Unresolved</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Violated</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Satisfied</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Resolved</td>
<td rowspan="1" colspan="1">Check</td>
<td rowspan="1" colspan="1">Satisfied</td>
<td rowspan="1" colspan="1">Check</td>
<td rowspan="1" colspan="1">Check</td>
</tr>
</tbody>
</table>
<br />
<p>"Check" in the table above means that the appropriate constraint
must be evaluated.</p>
<p>The constraints described above can be useful even on element
declarations whose instances are not necessarily SML references,
because the decision about whether to include a constraint and the
decision about whether to make the element an SML reference can be
made independently - some choices made by the schema author, other
choices made by the instance document author.</p>
</div>
</div>
<div class="div2">
<h3><a name="Identity_Constraints" id=
"Identity_Constraints"></a>5.2 SML Identity Constraints</h3>
<p>XML Schema supports the definition of uniqueness and reference
constraints through <code>xs:key</code>, <code>xs:unique</code>,
and <code>xs:keyref</code> elements. However, the scope of these
constraints is restricted to a single document. SML defines analogs
for these constraints, whose scope extends to multiple documents by
allowing them&nbsp;to traverse <a title="" href="#reference">SML
references</a>.</p>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> support the following elements
for defining SML identity constraints across SML references, as
child elements of <code>xs:element/xs:annotation/xs:appinfo</code>
where the <code>xs:element</code> has a name attribute.</p>
<a name="Table5" id="Table5"></a>
<table border="1" cellspacing="0" cellpadding="5">
<thead>
<tr>
<th rowspan="1" colspan="1">Name</th>
<th rowspan="1" colspan="1">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="1" colspan="1"><code>sml:key</code></td>
<td rowspan="1" colspan="1">Similar to <code>xs:key</code> except
that the selector and field XPath expression can use the
<code>smlfn:deref</code> function</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sml:unique</code></td>
<td rowspan="1" colspan="1">Similar to <code>xs:unique</code>
except that the selector and field XPath expression can use the
<code>smlfn:deref</code> function</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><code>sml:keyref</code></td>
<td rowspan="1" colspan="1">Similar to <code>xs:keyref</code>
except that the selector and field XPath expression can use the
<code>smlfn:deref</code> function</td>
</tr>
</tbody>
</table>
<br />
<p>Appendix <a href="#Model_Definition_Document_Sample"><b>B. Model
Definition Document Sample</b></a> and Appendix <a href=
"#Identity_Constraints_Example"><b>E. SML Identity Constraints
Sample</b></a> have examples that show how SML identity constraints
are defined.</p>
<p>SML identity constraints are attached to the element declaration
schema component. SML defines a new property for every element
declaration schema component:</p>
<dl>
<dt class="label"><a name="id_constr_def" id=
"id_constr_def"></a>{SML identity-constraints definitions}</dt>
<dd>
<p>A set of SML identity constraint definitions components, which
have the same set of properties as XML Schema identity constraint
definitions.</p>
</dd>
</dl>
<div class="div3">
<h4><a name="Identity_Constraints_Syntax_Semantics" id=
"Identity_Constraints_Syntax_Semantics"></a>5.2.1 Syntax and
Semantics</h4>
<p>Names of all SML identity constraint definitions exist in a
single symbol space, which is disjoint from any symbol space of XML
Schema components.</p>
<div class="div4">
<h5><a name="Identity_Constraints_Mapping_from_Schema" id=
"Identity_Constraints_Mapping_from_Schema"></a>5.2.1.1 SML
Constraint Construction</h5>
<p>For each <code>sml:key</code>, <code>sml:unique</code>, or
<code>sml:keyref</code> element without the <code>ref</code>
attribute specified, <a title="" href="#id_constr_def">{SML
identity-constraints definitions}</a> contains a component
corresponding to this element, as specified in section <a href=
"http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions">
3.11 Identity-constraint Definitions</a> of the XML Schema
specification [<a href="#XSD1">XML Schema Structures</a>]), where
<code>sml:selector</code> and <code>sml:field</code> elements are
used in place of <code>xs:selector</code> and
<code>xs:field</code>.</p>
<p>For each <code>sml:key</code>, <code>sml:unique</code>, or
<code>sml:keyref</code> element with the <code>ref</code> attribute
specified, <a title="" href="#id_constr_def">{SML
identity-constraints definitions}</a> contains the component
resolved to by the actual value of the <code>ref</code> attribute,
with the following conditions:</p>
<ol class="enumar">
<li>
<p>The name attribute <span class="rfc2119">MUST NOT</span> be
specified.</p>
</li>
<li>
<p>The <code>sml:selector</code> and <code>sml:field</code> child
elements <span class="rfc2119">MUST NOT</span> be specified.</p>
</li>
<li>
<p>If the element is <code>sml:key</code>, then the value of
<code>ref</code> attribute <span class="rfc2119">MUST</span>
resolve to an SML key constraint.</p>
</li>
<li>
<p>If the element is <code>sml:unique</code>, then the value of the
<code>ref</code> attribute <span class="rfc2119">MUST</span>
resolve to an SML unique constraint.</p>
</li>
<li>
<p>If element is <code>sml:keyref</code>, then the value of the
<code>ref</code> attribute <span class="rfc2119">MUST</span>
resolve to an SML keyref constraint, and the <code>refer</code>
attribute <span class="rfc2119">MUST NOT</span> be specified.</p>
</li>
</ol>
<p>In addition to SML identity constraints obtained from the above
explicit definitions or references, if an element declaration
<b>S</b> has a {substitution group affiliation} <b>G</b>, then its
<a title="" href="#id_constr_def">{SML identity-constraints
definitions}</a> also contains members of <a title="" href=
"#id_constr_def">{SML identity-constraints definitions}</a> of
<b>G</b>.</p>
</div>
<div class="div4">
<h5><a name="Identity_Constraints_Schema_Validity_Rules" id=
"Identity_Constraints_Schema_Validity_Rules"></a>5.2.1.2 Schema
Component Rules</h5>
<ol class="enumar">
<li>
<p><code>sml:selector</code> XPath expression has the same syntax
as that defined in the XML Schema identity constraint selector
XPath syntax with one exception. The <code>sml:selector</code>
XPath <span class="rfc2119">MAY</span> use
<code>smlfn:deref()</code> functions, with function calls nested to
any depth, at the beginning of the expression. The XML Schema
identity constraint selector Path production is amended to support
this requirement as defined below.</p>
<div class="exampleInner">
<pre>
Path ::= ('.//')? Step ( '/' Step)* | DerefExpr
DerefExpr ::= NCName ':' 'deref' '(' Step ('/'Step)* ')' ('/'Step)* |
              NCName ':' 'deref' '(' DerefExpr ')' ('/'Step)*
</pre></div>
</li>
<li>
<p><code>sml:field</code> XPath expression has the same syntax as
that defined in the XML Schema identity constraint field XPath
syntax with one exception. The <code>sml:field</code> XPath
<span class="rfc2119">MAY</span> use <code>smlfn:deref()</code>
functions, with function calls nested to any depth, at the
beginning of the expression. The XML Schema identity constraint
field Path production is amended to support this requirement as
defined below.</p>
<div class="exampleInner">
<pre>
Path ::= ('.//')? ( Step '/')* ( Step | '@' NameTest ) |
         DerefExpr ('/' '@' NameTest)?
DerefExpr ::= NCName ':' 'deref' '(' Step ('/'Step)* ')' ('/'Step)* |
              NCName ':' 'deref' '(' DerefExpr ')' ('/'Step)*
</pre></div>
</li>
<li>
<p>The <a title="" href="#id_constr_def">{SML identity-constraints
definitions}</a> of an element declaration <span class=
"rfc2119">MUST NOT</span> contain two identity constraints with the
same name.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This could happen if the ref attribute resolves to an identity
constraint already contained in the same element declaration’s
<a title="" href="#id_constr_def">{SML identity-constraints
definitions}</a>.</p>
</div>
</li>
<li>
<p>If a global element declaration <b>E</b> has a {substitution
group affiliation} <b>G</b>, then the value of <b>E</b>'s <a title=
"" href="#id_constr_def">{SML identity-constraints definitions}</a>
property <span class="rfc2119">MUST</span> be a valid restriction
of the value of the corresponding property of <b>G</b> as defined
in section <a href="#Constraints_Valid_Restriction"><b>5.3 Valid
Restriction of SML Constraint Values</b></a>.</p>
</li>
<li>
<p>If two element declarations <b>E1</b> and <b>E2</b> have the
same {namespace name} and {name} and they are both contained
(directly, indirectly, or implicitly) in a content model of a
complex type, then <b>E1</b> and <b>E2</b> <span class=
"rfc2119">MUST</span> have the same set of <a title="" href=
"#id_constr_def">{SML identity-constraints definitions}</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule is defined to reduce the implementation burden for
model validators. Please refer to section <a href=
"#Sml_Constraints_and_Derivation_Overview"><b>5.4.1 Overview of SML
Constraint Processing and Complex Type Derivation</b></a> for more
information.</p>
</div>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="Identity_Constraints_Instance_Validity_Rules" id=
"Identity_Constraints_Instance_Validity_Rules"></a>5.2.1.3 Instance
Validity Rules</h5>
<p>Validation rules for SML identity constraints are the same as
specified in section <a href=
"http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions">
3.11 Identity-constraint Definitions</a> of the XML Schema
specification [<a href="#XSD1">XML Schema Structures</a>]), with
the addition of support for the <code>smlfn:deref()</code>
function.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="Constraints_Valid_Restriction" id=
"Constraints_Valid_Restriction"></a>5.3 Valid Restriction of SML
Constraint Values</h3>
<p>Let BV = value of SML constraint property P (one of <a title=""
href="#targetRequired">{target required}</a>, <a title="" href=
"#targetElement">{target element}</a>, <a title="" href=
"#targetType">{target type}</a> or <a title="" href=
"#id_constr_def">{SML identity-constraints definitions}</a>).</p>
<p>Let RV = value that restricts BV.</p>
<p>For RV to be a valid restriction of BV, the appropriate case
among the following <span class="rfc2119">MUST</span> be true.</p>
<ol class="enumar">
<li>
<p>For <a title="" href="#targetRequired">{target required}</a>,
the appropriate case among the following applies.</p>
<ol class="enumla">
<li>
<p>If BV is true, RV is true.</p>
</li>
<li>
<p>If BV is false, RV is either true or false.</p>
</li>
</ol>
</li>
<li>
<p>For <a title="" href="#targetElement">{target element}</a>, one
of the following applies.</p>
<ol class="enumla">
<li>
<p>RV is same as BV.</p>
</li>
<li>
<p>RV is in the substitution group of BV.</p>
</li>
</ol>
</li>
<li>
<p>For <a title="" href="#targetType">{target type}</a>, one of the
following applies.</p>
<ol class="enumla">
<li>
<p>RV is same as BV.</p>
</li>
<li>
<p>RV is a type derived from BV.</p>
</li>
</ol>
</li>
<li>
<p>For <a title="" href="#id_constr_def">{SML identity-constraints
definitions}</a>, one of the following applies.</p>
<ol class="enumla">
<li>
<p>RV is same as BV. That is, all of the following is true.</p>
<ol class="enumlr">
<li>
<p>The number of entries in RV is same as the number of entries in
BV.</p>
</li>
<li>
<p>For each entry in BV, there exists an entry in RV with the same
qualified name ({name} + {target namespace}).</p>
</li>
</ol>
</li>
<li>
<p>RV is a superset of BV. That is, RV has all of the entries from
BV as defined in the previous item and it has one or more
additional entries.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="SML_Constraints_and_Complex_Type_Derivation" id=
"SML_Constraints_and_Complex_Type_Derivation"></a>5.4 SML
Constraints and Complex Type Derivation</h3>
<div class="div3">
<h4><a name="Sml_Constraints_and_Derivation_Overview" id=
"Sml_Constraints_and_Derivation_Overview"></a>5.4.1 Overview of SML
Constraint Processing and Complex Type Derivation</h4>
<p>This section is non-normative.</p>
<p>For a complex type D derived from its {base type definition} B,
if an element declaration ED is included in D and an element
declaration EB is included in B, and ED and EB satisfy the
"NameAndTypeOK" constraint, then the SML constraints (target* and
SML identity constraints) applicable to ED must be</p>
<ol class="enumar">
<li>
<p>the same as those on EB in case of derivation by extension,
and</p>
</li>
<li>
<p>the same or more restrictive compared to those on EB in case of
derivation by restriction.</p>
</li>
</ol>
<p>SML defines this behavior to ensure that one cannot get rid of
SML constraints on elements in a complex type by simply deriving
another type from that type.</p>
<p>Enforcing this condition across derivation by restriction would
require an implementation to match a restricting particle to the
corresponding restricted particle in order to evaluate condition 2
above. This level of support is not provided by most XML Schema
frameworks; thus most SML validators would otherwise need to
duplicate large parts of XML Schema's compilation logic to verify
consistent usage of SML constraints across derivation by
restriction. In order to reduce this implementation burden on model
validators, SML requires that all element declarations with a given
name that are included in a complex type definition must have the
same SML constraint value. This allows model validators to find the
restricted particle for a restricting particle using a simple name
match.</p>
<p>This also means that the value of a given SML constraint
applicable to all element declarations of a given name in complex
type definition can be logically viewed as available at a single
place, for example in a property attached to that complex type,
rather than being scattered across element declarations in that
type. The next section uses this logical view because it makes it
easier to understand and formally define SML constraint behavior
across complex type derivation.</p>
</div>
<div class="div3">
<h4><a name="Constraints_Definition" id=
"Constraints_Definition"></a>5.4.2 Formal Definition</h4>
<div class="div4">
<h5><a name="Constraints_Properties" id=
"Constraints_Properties"></a>5.4.2.1 Properties</h5>
<p>SML defines four properties for every complex type definition
schema component CT.</p>
<dl>
<dt class="label"><a name="targetRequiredConstraintList" id=
"targetRequiredConstraintList"></a>{target required constraint
list}</dt>
<dd>
<p>A list of (qname, value) pairs, where,</p>
<ol class="enumar">
<li>
<p>qname is a qualified name ({namespace name} + {name}).</p>
</li>
<li>
<p>value is the value of a <a title="" href=
"#targetRequired">{target required}</a> property.</p>
</li>
</ol>
</dd>
<dt class="label"><a name="targetElementConstraintList" id=
"targetElementConstraintList"></a>{target element constraint
list}</dt>
<dd>
<p>A list of (qname, value) pairs, where,</p>
<ol class="enumar">
<li>
<p>qname is a qualified name ({namespace name} + {name}).</p>
</li>
<li>
<p>value is the value of a <a title="" href=
"#targetElement">{target element}</a> property.</p>
</li>
</ol>
</dd>
<dt class="label"><a name="targetTypeConstraintList" id=
"targetTypeConstraintList"></a>{target type constraint list}</dt>
<dd>
<p>A list of (qname, value) pairs, where,</p>
<ol class="enumar">
<li>
<p>qname is a qualified name ({namespace name} + {name}).</p>
</li>
<li>
<p>value is the value of a <a title="" href="#targetType">{target
type}</a> property.</p>
</li>
</ol>
</dd>
<dt class="label"><a name="identityConstraintList" id=
"identityConstraintList"></a>{identity constraint list}</dt>
<dd>
<p>A list of (qname, value) pairs, where,</p>
<ol class="enumar">
<li>
<p>qname is a qualified name ({namespace name} + {name}).</p>
</li>
<li>
<p>value is the value of a <a title="" href="#id_constr_def">{SML
identity-constraints definitions}</a> property.</p>
</li>
</ol>
</dd>
</dl>
<p>The value of the above 4 properties for <code>xs:anyType</code>
is empty.</p>
</div>
<div class="div4">
<h5><a name="Constraints_Derivation_Rules" id=
"Constraints_Derivation_Rules"></a>5.4.2.2 SML Constraint
Construction</h5>
<p>Let</p>
<ul>
<li>
<p>CT = A complex type definition.</p>
</li>
<li>
<p>C = SML constraint (one of targetRequired, targetElement,
targetType, SML identity constraint).</p>
</li>
<li>
<p>P = A property of CT corresponding to constraint C (one of
<a title="" href="#targetRequiredConstraintList">{target required
constraint list}</a>, <a title="" href=
"#targetElementConstraintList">{target element constraint
list}</a>, <a title="" href="#targetTypeConstraintList">{target
type constraint list}</a>, <a title="" href=
"#identityConstraintList">{identity constraint list}</a>).</p>
</li>
<li>
<p>V = The value of P, a list of (qname, value) pairs.</p>
</li>
<li>
<p>ED = An element declaration contained in CT.</p>
</li>
<li>
<p>PED = A property of ED corresponding to constraint C (one of
<a title="" href="#targetRequired">{target required}</a>, <a title=
"" href="#targetElement">{target element}</a>, <a title="" href=
"#targetType">{target type}</a>, <a title="" href=
"#id_constr_def">{SML identity-constraints definitions}</a>).</p>
</li>
</ul>
<p>Property P is assigned value V as defined below:</p>
<ol class="enumar">
<li>
<p>For each element declaration ED, with qualified name qn,
contained in CT:</p>
<ol class="enumla">
<li>
<p>If ED does not have constraint C, that is, the value of PED is
absent (or false in case of targetRequired), then skip ED.</p>
</li>
<li>
<p>Otherwise, if there is already an entry in V for qn, then skip
ED.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the value of the existing entry is different from the value
of PED then it is treated as a schema validation error as defined
in section <a href="#Target_Schema_Validity_Rules"><b>5.1.2.2
Schema Component Rules</b></a> and section <a href=
"#Identity_Constraints_Schema_Validity_Rules"><b>5.2.1.2 Schema
Component Rules</b></a>.</p>
</div>
</li>
<li>
<p>Otherwise, the entry (qn, value of PED) is added to the list
V.</p>
</li>
</ol>
</li>
<li>
<p>The appropriate case among the following applies:</p>
<ol class="enumla">
<li>
<p>If CT is derived by extension from a simple type definition then
value V is empty.</p>
</li>
<li>
<p>If CT is derived by extension from a complex type definition
BT:</p>
<p>The initial value of V is computed as defined in list item 1
above and then,</p>
<p>For each entry (qn, v<sub>b</sub>) in the value of P in BT:</p>
<ol class="enumlr">
<li>
<p>If V has an entry (qn, v<sub>c</sub>) present, then ensure that
v<sub>c</sub> is same as v<sub>b</sub>. If it is not same, then it
is treated as a schema validation error.</p>
</li>
<li>
<p>If V does not have any entry (qn, v<sub>c</sub>) present, then
copy (qn, v<sub>b</sub>) into V.</p>
</li>
</ol>
</li>
<li>
<p>If CT is derived by restriction from a complex type definition
BT:</p>
<p>The initial value of V is computed as defined in list item 1
above and then,</p>
<p>For each entry (qn, v<sub>b</sub>) in the value of P in BT:</p>
<ol class="enumlr">
<li>
<p>If V has an entry (qn, v<sub>c</sub>) present, then ensure that
v<sub>c</sub> is a valid restriction of v<sub>b</sub> as defined in
section <a href="#Constraints_Valid_Restriction"><b>5.3 Valid
Restriction of SML Constraint Values</b></a>. If it is not, then it
is treated as a schema validation error.</p>
</li>
<li>
<p>If V does not have any entry (qn, v<sub>c</sub>) present, then
copy (qn, v<sub>b</sub>) into V.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="Constraints_Instance_Validity_Rules" id=
"Constraints_Instance_Validity_Rules"></a>5.4.2.3 Instance Validity
Rules</h5>
<p>Let,</p>
<ul>
<li>
<p>CT = the complex type of element declaration ED.</p>
</li>
<li>
<p>E = an instance of ED.</p>
</li>
<li>
<p>C = a child element of E.</p>
</li>
</ul>
<p>If C matches an element declaration contained in CT and if one
or more of CT's constraint properties, defined in <a href=
"#Constraints_Properties"><b>5.4.2.1 Properties</b></a>, contain an
entry matching C's qualified name ({namespace name} + {name}) then
the value of each of those entries is used for evaluating the
corresponding constraint on C, as defined in section <a href=
"#Target_Instance_Validity_Rules"><b>5.1.2.3 Instance Validity
Rules</b></a> and section <a href=
"#Identity_Constraints_Instance_Validity_Rules"><b>5.2.1.3 Instance
Validity Rules</b></a>, as if the matching element declaration has
the corresponding constraint with that value.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>One way for constraints to be embedded in element declarations
or type definitions in a schema is for constraint element to be
included in a schema document, embedded at the appropriate
locations within the <code>xs:element</code> or
<code>xs:complexType</code> elements which describe the element
declaration or type definition.</p>
<p>Element declarations and type definitions created by other means
can, however, also have constraints embedded within the
{application information} of their {annotation} properties. How
such embedding is accomplished is outside the scope of this
specification and is likely to vary among <a title="" href=
"#model">model processors</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="SML_Rules" id="SML_Rules"></a>6. Rules</h2>
<p>XML Schema supports a number of built-in grammar-based
constraints but it does not support a language for defining
arbitrary rules for constraining the structure and content of
documents. Schematron [<cite><a href="#Schematron">ISO/IEC
19757-3</a></cite>] is an ISO/IEC standard for defining assertions
concerning a set of XML documents. SML uses Schematron to add
support for additional model constraints not supported in XML
Schema.</p>
<div class="div2">
<h3><a name="Rules_Informal_Description" id=
"Rules_Informal_Description"></a>6.1 Informal Description
(Non-Normative)</h3>
<p>This section assumes that the reader is familiar with Schematron
concepts; the Schematron standard is documented in [<cite><a href=
"#Schematron">ISO/IEC 19757-3</a></cite>] and [<cite><a href=
"#intro_schematron">Introduction to Schematron</a></cite>,
<cite><a href="#improving_schematron">Improving Validation with
Schematron</a></cite>] are good tutorials on an older version of
Schematron.</p>
<p>Constraints can be specified using the <code>sch:assert</code>
and <code>sch:report</code> elements from Schematron. &nbsp;The
following example uses <code>sch:assert</code> elements to specify
two constraints:</p>
<ol class="enumar">
<li>
<p>An IPv4 address must have four bytes</p>
</li>
<li>
<p>An IPv6 address must have sixteen bytes</p>
</li>
</ol>
<div class="exampleInner">
<pre>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="urn:x-example:IPAddress"&gt;
    &lt;xs:simpleType  name="IPAddressVersionType"&gt;
        &lt;xs:restriction base="xs:string" &gt;
            &lt;xs:enumeration value="V4" /&gt;
            &lt;xs:enumeration value="V6" /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:complexType name="IPAddress"&gt;
        &lt;xs:annotation&gt;
            &lt;xs:appinfo&gt;
                &lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
                   &lt;sch:ns prefix="tns" uri="urn:x-example:IPAddress" /&gt;
                   &lt;sch:pattern id="Length"&gt;
                      &lt;sch:rule context="."&gt;
                         &lt;sch:assert test="tns:version != 'V4' or count(tns:address) = 4"&gt;
                              A v4 IP address must have 4 bytes.
                         &lt;/sch:assert&gt;
                         &lt;sch:assert test="tns:version != 'V6' or count(tns:address) = 16"&gt;
                              A v6 IP address must have 16 bytes.
                         &lt;/sch:assert&gt;
                      &lt;/sch:rule&gt;
                   &lt;/sch:pattern&gt;
                &lt;/sch:schema&gt;            
            &lt;/xs:appinfo&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="version" type="tns:IPAddressVersionType" /&gt;
            &lt;xs:element name="address" type="xs:byte" minOccurs="4" maxOccurs="16" /&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;     
</pre></div>
<p>A <a title="" href="#schematron_constraint">Schematron
constraint</a> embedded in the
<code>xs:annotation/xs:appinfo</code> element for a complex type
definition or an element declaration is applicable to all instances
of the complex type or element. In the above example, the pattern
<code>Length</code> (which is a part of the containing Schematron
constraint) is applicable for all elements whose type is
<code>IPAddress</code> or a derived type of <code>IPAddress</code>.
A <code>pattern</code> element contains one or more
<code>sch:rule</code> elements and a single <code>sch:rule</code>
element contains one or more <code>assert</code> and/or
<code>report</code> elements. Each <code>sch:rule</code> element
specifies its context using the <code>context</code> attribute.
This context expression is evaluated in the context of each
applicable element and results in an element node set for which the
assert and report <code>test</code> expressions contained in the
<code>sch:rule</code> element are evaluated. The
<code>context</code> expression is defined as an XSLT Pattern. This
means that the <code>smlfn:deref</code> function may not be used in
the location path of a <code>context</code> expression.</p>
<p>In the above example, <code>context="."</code>. Therefore the
two assert expressions are evaluated in the context of each
applicable element; i.e., each element of type
<code>IPAddress</code>. The <code>test</code> expression for an
<code>assert</code> is a boolean expression, and the
<code>assert</code> is violated (or fires) if its <code>test</code>
expression evaluates to false. A <code>report</code> is violated
(or fires) if its <code>test</code> expression evaluates to true.
Thus, an <code>assert</code> can be converted to a
<code>report</code> by simply negating its test expression. The
following example uses <code>report</code> elements to represent
the IP address constraints of the previous example:</p>
<div class="exampleInner">
<pre>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="urn:x-example:IPAddress"&gt;
    &lt;xs:simpleType  name="IPAddressVersionType"&gt;
        &lt;xs:restriction base="xs:string"&gt;
           &lt;xs:enumeration value="V4"/&gt;
           &lt;xs:enumeration value="V6"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:complexType name="IPAddress"&gt;
        &lt;xs:annotation&gt;
            &lt;xs:appinfo&gt;
                &lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
                    &lt;sch:ns prefix="tns" uri="urn:x-example:IPAddress" /&gt;
                    &lt;sch:pattern id="Length"&gt;
                        &lt;sch:rule context="."&gt;
                            &lt;sch:report test="tns:version = 'V4' and count(tns:address)!= 4"&gt;
                                A v4 IP address must have 4 bytes.
                            &lt;/sch:report&gt;
                            &lt;sch:report test="tns:version = 'V6' and count(tns:address) != 16"&gt;
                                A v6 IP address must have 16 bytes.
                            &lt;/sch:report&gt;
                        &lt;/sch:rule&gt;
                    &lt;/sch:pattern&gt;
                &lt;/sch:schema&gt;            
            &lt;/xs:appinfo&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="version" type="tns:IPAddressVersionType" /&gt;
            &lt;xs:element name="address" type="xs:byte" minOccurs="4" maxOccurs="16" /&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;     
</pre></div>
<p>If a <code>sch:assert</code> or <code>sch:report</code> is
violated, the violation is reported together with the specified
message. The message can include substitution strings based on
XPath expressions. These can be specified using the
<code>sch:value-of</code> element. The following example uses the
<code>sch:value-of</code> element to include the number of
specified address bytes in the message:</p>
<div class="exampleInner">
<pre>
&lt;sch:assert test="tns:version != 'v4' or count(tns:address) = 4"&gt;
     A v4 IP address must have 4 bytes instead of the specified
     &lt;sch:value-of select="string(count(tns:address))"/&gt; bytes.
&lt;/sch:assert&gt;
</pre></div>
<p>In addition to being embedded in complex type definitions,
constraints can also be embedded in global element declarations.
Such constraints are evaluated for each instance element
corresponding to the global element declaration. Consider the
following example:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="StrictUniversity" type="tns:UniversityType"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:appinfo&gt;
            &lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
                &lt;sch:ns prefix="u" uri="http://www.university.example.org/ns" /&gt;
                &lt;sch:ns prefix="smlfn"  
                        uri="http://www.w3.org/ns/sml-function"/&gt;
                &lt;sch:pattern id="StudentPattern"&gt;
                    &lt;sch:rule context="u:Students/u:Student"&gt;
                        &lt;sch:assert test="smlfn:deref(.)[starts-with(u:ID,'99')]"&gt;
                            The specified ID &lt;sch:value-of select="string(u:ID)"/&gt;
                             does not begin with 99.
                        &lt;/sch:assert&gt;
                        &lt;sch:assert test="count(u:Courses/u:Course)&gt;0"&gt;
                            The student &lt;sch:value-of select="string(u:ID)"/&gt; must be enrolled
                            in at least one course.
                        &lt;/sch:assert&gt;
                    &lt;/sch:rule&gt;
                &lt;/sch:pattern&gt;
             &lt;/sch:schema&gt;
         &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
</pre></div>
<p>The <code>sch:rule</code> elements contained in
<code>StudentPattern</code> are applicable to all element instances
of the <code>StrictUniversity</code> global element declaration.
For each <code>StrictUniversity</code> element, the XPath
expression specified as the value of the <code>context</code>
attribute is evaluated to return a node set, and the test
expressions for the two asserts are evaluated for each node in this
node set. &nbsp;Thus, these two asserts verify the following
conditions for each instance of <code>StrictUniversity</code>.</p>
<ol class="enumar">
<li>
<p>The ID of each student must begin with '99'.</p>
</li>
<li>
<p>Each student must be enrolled in at least one course.</p>
</li>
</ol>
<p>Schematron patterns can be authored in separate rule documents
that are then bound to a set of documents in the model.</p>
<p>The following example shows the constraints for
<code>StrictUniversity</code> expressed in a separate document:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
    &lt;sch:ns prefix="u" uri="http://www.university.example.org/ns" /&gt;
    &lt;sch:ns prefix="smlfn" uri="http://www.w3.org/ns/sml-function"/&gt;
    &lt;sch:pattern id="StudentPattern"&gt;
        &lt;sch:rule context="u:StrictUniversity/u:Students/u:Student"&gt;
            &lt;sch:assert test="smlfn:deref(.)[starts-with(u:ID,'99')]"&gt;
                The specified ID &lt;sch:value-of select="string(u:ID)"/&gt;
                does not begin with 99.
            &lt;/sch:assert&gt;
            &lt;sch:assert test="count(u:Courses/u:Course)&gt;0"&gt;
                The student &lt;sch:value-of select="string(u:ID)"/&gt; must be enrolled
                in at least one course.
            &lt;/sch:assert&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;
</pre></div>
<p>The binding of the rule document containing the
<code>StudentPattern</code> pattern to documents that may contain
instances of <code>StrictUniversity</code> element is
implementation-defined.</p>
</div>
<div class="div2">
<h3><a name="Rule_Support" id="Rule_Support"></a>6.2 Rule
Support</h3>
<p><a title="" href="#model_validator">Model validators</a> are
<span class="rfc2119">REQUIRED</span> to support and evaluate XPath
expressions augmented with the <code>smlfn:deref()</code> function
in the body of Schematron constraints.</p>
<p>If the <code>queryBinding</code> attribute is not specified,
then its value is assumed to be set to <code>"xslt"</code>.
<a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> support the <code>"xslt"</code>
query binding. <a title="" href="#model_validator">Model
validators</a> <span class="rfc2119">MAY</span> additionally
support query bindings other than <code>"xslt"</code>.</p>
</div>
<div class="div2">
<h3><a name="Embedded_Rules" id="Embedded_Rules"></a>6.3 Rules
Associated with Schema Components</h3>
<p>SML defines a new property for every complex type definition
schema component and every element declaration schema
component.</p>
<dl>
<dt class="label"><a name="rules" id="rules"></a>{rules}</dt>
<dd>
<p>A set of <a title="" href="#schematron_constraint">Schematron
constraints</a>.</p>
</dd>
</dl>
<div class="div3">
<h4><a name="Rules_Mapping_From_Schema" id=
"Rules_Mapping_From_Schema"></a>6.3.1 SML Rule Construction</h4>
<p>The <a title="" href="#rules">{rules}</a> property contains all
of the Schematron constraints applicable to instances of the given
type definition or element declaration. Its value is derived in
part from <code>sch:schema</code> elements embedded within the
component, and sometimes in part from the <a title="" href=
"#rules">{rules}</a> properties of other components.</p>
<p><code>sch:schema</code> elements <span class=
"rfc2119">MAY</span> appear as items in the {application
information} of the {annotation} of a global element declaration or
a global complex type definition. This specification assigns no
meaning to <code>sch:schema</code> elements if they appear as items
in any other location.</p>
<p>Let the <b>local-rules</b> of a given global element declaration
or global complex type definition be the set of Schematron
constraints embedded in the {application information} of that
schema component's {annotation} property. For other schema
components, <b>local-rules</b> is empty.</p>
<p>The value of the <a title="" href="#rules">{rules}</a> property
of a schema component is computed as follows:</p>
<ol class="enumar">
<li>
<p>The value of <a title="" href="#rules">{rules}</a> for
<code>xs:anyType</code> is the empty set.</p>
</li>
<li>
<p>If the schema component is a global element declaration, then
the value of its <a title="" href="#rules">{rules}</a> is the union
of its <b>local-rules</b> and the appropriate case from the
following:</p>
<ol class="enumla">
<li>
<p>If the element declaration has a {substitution group
affiliation}, then the value of <a title="" href=
"#rules">{rules}</a> of the {substitution group affiliation}.</p>
</li>
<li>
<p>Otherwise (the element declaration has no {substitution group
affiliation}), the empty set.</p>
</li>
</ol>
</li>
<li>
<p>If the schema component is a complex type definition, then the
value of its <a title="" href="#rules">{rules}</a> property is the
union of its <b>local-rules</b> and the appropriate case from the
following:</p>
<ol class="enumla">
<li>
<p>If the component's {base type definition} is a complex type
definition, then the <a title="" href="#rules">{rules}</a> of the
{base type definition}. This is true for derivation by extension as
well as for derivation by restriction.</p>
</li>
<li>
<p>Otherwise (i.e., when {base type definition} is a simple type
definition), the empty set.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, the value of the <a title="" href=
"#rules">{rules}</a> property is not affected by this
specification.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="Rules_Schema_Validity_Rules" id=
"Rules_Schema_Validity_Rules"></a>6.3.2 Schema Component Rules</h4>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> enforce the following rules.</p>
<ol class="enumar">
<li>
<p>If a complex type <b>D</b> is derived by restriction or
extension from {base type definition} <b>B</b> and if <b>B</b> has
<a title="" href="#rules">{rules}</a> defined on it then they
<span class="rfc2119">MUST</span> be automatically copied to
<b>D</b> and unioned with the <a title="" href="#rules">{rules}</a>
defined on <b>D</b>.</p>
</li>
<li>
<p>If a complex type <b>D</b> is derived by restriction from {base
type definition} <b>B</b>, then a global element declaration with
non-empty <a title="" href="#rules">{rules}</a> contained in
<b>B</b> <span class="rfc2119">MUST NOT</span> be restricted to a
local element declaration in <b>D</b>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is an error if all of the following are true.</p>
<ol class="enumla">
<li>
<p>An element declaration <b>ED</b> is contained (directly,
indirectly, or implicitly) in <b>D</b> and an element declaration
<b>EB</b> is contained (directly, indirectly, or implicitly) in
<b>B</b>.</p>
</li>
<li>
<p><b>ED</b> and <b>EB</b> satisfy the "NameAndTypeOK" constraint
(for XML Schema's definition of valid restrictions, see <a href=
"http://www.w3.org/TR/xmlschema-1/#cos-particle-restrict">Schema
Component Constraint: Particle Valid (Restriction)</a>, <a href=
"http://www.w3.org/TR/xmlschema-1/#coss-particle">Constraints on
Particle Schema Components</a> in [<a href="#XSD1">XML Schema
Structures</a>]).</p>
</li>
<li>
<p><b>EB</b> is a reference to a global element declaration with a
Schematron constraint on it.</p>
</li>
<li>
<p><b>ED</b> is a local element declaration with the same name as
<b>EB</b>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="Rules_Instance_Validity_Rules" id=
"Rules_Instance_Validity_Rules"></a>6.3.3 Instance Validity
Rules</h4>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> behave as follows: &nbsp;</p>
<ol class="enumar">
<li>
<p>Each <a title="" href="#schematron_constraint">Schematron
constraint</a> in <a title="" href="#rules">{rules}</a> of a
complex-type definition <b>CT</b> <span class="rfc2119">MUST</span>
be evaluated for all element instances of type <b>CT</b> in a model
during the model's validation.</p>
</li>
<li>
<p>Each <a title="" href="#schematron_constraint">Schematron
constraint</a> in <a title="" href="#rules">{rules}</a> of a global
element declaration <b>G</b> <span class="rfc2119">MUST</span> be
evaluated for all element instances of <b>G</b> in a model during
the model's validation.</p>
</li>
<li>
<p>All of the assertion tests in fired rules <span class=
"rfc2119">MUST</span> succeed.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="Rules_in_Rule_Documents" id=
"Rules_in_Rule_Documents"></a>6.4 Rules Authored in Rule
Documents</h3>
<div class="div3">
<h4><a name="Rule_Binding" id="Rule_Binding"></a>6.4.1 Rule
Binding</h4>
<p><a title="" href="#model_validator">Model validators</a>
<span class="rfc2119">MUST</span> provide a mechanism to support
the binding of Schematron patterns, authored in separate <a title=
"" href="#ruleDocument">rule documents</a>, to a set of documents
in a model. Rule documents <span class="rfc2119">MAY</span> be
bound to model instance documents as well as model definition
documents. The mechanism for binding rule documents to a set of
documents in a model is implementation-defined.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Localization_of_Messages" id=
"Localization_of_Messages"></a>7. Localization of Natural Language
Messages</h2>
<p>SML defines the <code>sml:locid</code> attribute in support of
localization of natural-language texts, for example,
<code>smlif:description</code> or Schematron messages. <a title=""
href="#model_validator">Model validators</a> <span class=
"rfc2119">MAY</span> support <code>sml:locid</code> attribute on
the following elements:</p>
<ol class="enumar">
<li>
<p><code>sch:assert</code> and <code>sch:report</code> in a
<a title="" href="#ruleDocument">rule document</a>.</p>
</li>
<li>
<p><code>sch:assert</code> and <code>sch:report</code> in a
Schematron <code>pattern</code> embedded in the {application
information} of the {annotation} property of a complex type
definition or an element declaration.</p>
</li>
<li>
<p>Elements in instance documents with textual content.</p>
</li>
</ol>
<p>Model validators that support the <code>sml:locid</code>
attribute <span class="rfc2119">MUST</span> use the
<code>sml:locid</code> attribute value to access the location of
the translated text.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The mechanism for using the <code>QName</code> value of the
<code>sml:locid</code> attribute to locate the translated text is
implementation-dependent. For example, the <a href=
"http://www.w3.org/TR/xml-names/#dt-NSName">namespace name</a> can
be used to identify the resource containing the text and the
<a href="http://www.w3.org/TR/xml-names/#dt-NSName">local name</a>
can be used to identify the text within such a resource. Refer to
Appendix <a href="#Localization_Sample"><b>F. Localization and
Variable Substitution Samples</b></a> for a concrete sample of how
the <code>sml:locid</code> attribute can be used to support text
localization.</p>
</div>
<div class="div2">
<h3><a name="Variable_Substitution" id=
"Variable_Substitution"></a>7.1 Variable Substitution</h3>
<p>It is often the case that a <code>sch:assert</code> or
<code>sch:report</code> message can be reused in different
situations. To be able to reuse a message, the rule author must be
able to substitute variable content based on the context in which
the message is being used.</p>
<p>Although this specification does not mandate the use of variable
substitution in Schematron messages, it suggests the use of
<code>xsl:variable</code> when variable substitution is desired.
Refer to Appendix <a href="#Localization_Sample"><b>F. Localization
and Variable Substitution Samples</b></a> section for a concrete
sample of how the <code>xsl:variable</code> can be used in support
of reusing localized messages.</p>
</div>
</div>
<div class="div1">
<h2><a name="Conformance" id="Conformance"></a>8. Conformance
Criteria</h2>
<p>A program is a <em>conforming SML model processor</em> if and
only if it satisfies all the constraints imposed on processors
elsewhere in this specification.</p>
<p>A conforming SML model processor is a <em>conforming SML model
validator</em> if and only if it satisfies the following
conditions:</p>
<ol class="enumar">
<li>
<p>The validator <span class="rfc2119">MUST</span> perform
<a title="" href="#model_validation_t">model validation</a> as
defined in this specification.</p>
</li>
<li>
<p>The validator <span class="rfc2119">MUST</span> support XML 1.0
[<cite><a href="#XML10">XML</a></cite>], XML Schema 1.0
[<cite><a href="#XSD1">XML Schema Structures</a></cite>,
<cite><a href="#XSD2">XML Schema Datatypes</a></cite>], and XPath
1.0 [<cite><a href="#XPath">XPath</a></cite>] but <span class=
"rfc2119">MAY</span> also additionally support any future versions
of these specifications.</p>
</li>
<li>
<p>The validator MUST support Schematron [<cite><a href=
"#Schematron">ISO/IEC 19757-3</a></cite>].</p>
</li>
<li>
<p>The validator <span class="rfc2119">MUST</span> perform
Schematron rule evaluation on the #ALL phase.</p>
</li>
<li>
<p>The validator <span class="rfc2119">MUST</span> support the
<code>deref()</code> XPath extension function.</p>
</li>
<li>
<p>The validator <span class="rfc2119">MUST</span> identify all SML
references in the model using the Post Schema Validation Infoset.
[<cite><a href="#XSD1">XML Schema Structures</a></cite>]</p>
</li>
<li>
<p>The validator <span class="rfc2119">MUST</span> use the Post
Schema Validation Infoset to determine if an SML reference in the
model is a null SML reference. [<cite><a href="#XSD1">XML Schema
Structures</a></cite>]</p>
</li>
</ol>
<p>The conformance of a model and the validity of a model can be
assessed if and only if all documents in the model are available to
the model validator. A model validator <span class=
"rfc2119">MUST</span> document its behavior when a model document
is found to be unavailable (i.e. the behavior is
implementation-defined). It <span class="rfc2119">MAY</span>
respond to this condition in ways that include but are not limited
to: assessing the model as invalid, or treating this as a warning.
The intent of the latitude granted to model validators in this case
is to provide some implementation flexibility by not prescribing a
limited set of choices, however it is be read narrowly rather than
as a broad license to take unrelated actions like failing to
enforce SML constraints on unrelated documents.</p>
<p>A model is a <em>conforming SML <a title="" href=
"#model">model</a></em> if and only if it satisfies the following
conditions:</p>
<ol class="enumar">
<li>
<p>Each <a title="" href="#document">document</a> in the model
<span class="rfc2119">MUST</span> be a well-formed XML document
[<cite><a href="#XML10">XML</a></cite>]</p>
</li>
<li>
<p>For each XML Schema document in the model's definition
documents, the [validity] property of the root element <span class=
"rfc2119">MUST</span> be "valid" when schema validity is assessed
with respect to a schema constructed from the <cite><a href=
"#XSD3">XML Schema for Schemas</a></cite> and <a href=
"#SML_schema"><b>A. Normative SML Schema</b></a> schema
documents.</p>
</li>
<li>
<p>All schemas assembled from the XML Schema documents in the
model's definition documents <span class="rfc2119">MUST</span>
satisfy the conditions expressed in Errors in Schema Construction
and Structure (§5.1). [<cite><a href="#XSD1">XML Schema
Structures</a></cite>]</p>
</li>
<li>
<p>All schemas assembled from the XML Schema documents in the
model's definition documents <span class="rfc2119">MUST</span>
satisfy the conditions expressed in sections <a href=
"#Acyclic_Mapping_From_Schema"><b>5.1.1.1 SML Constraint
Construction</b></a>, <a href=
"#Acyclic_Schema_Validity_Rules"><b>5.1.1.2 Schema Component
Rules</b></a>, <a href="#Target_Mapping_From_Schema"><b>5.1.2.1 SML
Constraint Construction</b></a>, <a href=
"#Target_Schema_Validity_Rules"><b>5.1.2.2 Schema Component
Rules</b></a>, <a href=
"#Identity_Constraints_Mapping_from_Schema"><b>5.2.1.1 SML
Constraint Construction</b></a>, <a href=
"#Identity_Constraints_Schema_Validity_Rules"><b>5.2.1.2 Schema
Component Rules</b></a>, <a href=
"#Rules_Mapping_From_Schema"><b>6.3.1 SML Rule Construction</b></a>
and <a href="#Rules_Schema_Validity_Rules"><b>6.3.2 Schema
Component Rules</b></a>.</p>
</li>
<li>
<p>Each Schematron document in the model's definition documents
<span class="rfc2119">MUST</span> be a valid Schematron document
[<cite><a href="#Schematron">ISO/IEC 19757-3</a></cite>]</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not define how schemas are assembled and
which schema documents contribute to assembling the schemas.</p>
</div>
<p>A <em>conforming SML model is valid</em> if and only if it
satisfies all of the following conditions:</p>
<ol class="enumar">
<li>
<p>In each instance document in the model, which is bound to a
schema, the [validity] property of the root element <span class=
"rfc2119">MUST</span> be "valid", and the [validity] property of
all the other elements and all the attributes <span class=
"rfc2119">MUST NOT</span> be "invalid", when schema validity is
assessed with respect to any schema that is bound to this instance
document. The schema validity assessment starts with no stipulated
declaration or definition at the root element. [<cite><a href=
"#XSD1">XML Schema Structures</a></cite>]</p>
<p>The schema-validity of instance documents not bound to any
schema does not contribute to the validity or invalidity of the
model.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>How schemas are bound to instance documents is not defined by
this specification. Multiple schemas may be bound to the same
instance document.</p>
<p>SML validity entails NOT being Schema-Invalid on the root or any
descendant. SML validity can be non-vacuously checked only after
assessment of Schema validity, and only on the portions of the
subtree for which PSVI is available.</p>
<p>Because the depth of PSVI is implementation-dependent, there is
variability in the visibility of SML constraints available to the
SML validator, and consequently in SML validity results.</p>
</div>
</li>
<li>
<p>Each document in the model <span class="rfc2119">MUST</span>
satisfy all applicable Schematron constraints when validated in the
#ALL phase.</p>
</li>
<li>
<p>Each document in the model <span class="rfc2119">MUST</span>
satisfy all normative statements in this specification that pertain
to model documents.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means, for example, that each document must satisfy all
applicable sml:acyclic, sml:target*, and SML identity
constraints.</p>
</div>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="SML_Extension_Reference" id=
"SML_Extension_Reference"></a>9. SML Extensions Reference
(Non-Normative)</h2>
<p>This section is a reference guide to the SML extensions of XML
Schema and XPath.</p>
<div class="div2">
<h3><a name="Attributes" id="Attributes"></a>9.1 Attributes</h3>
<div class="div3">
<h4><a name="sml_acyclic_nonnormative_reference" id=
"sml_acyclic_nonnormative_reference"></a>9.1.1 sml:acyclic</h4>
<p>Used to specify that instances of an SML reference of a given
type and its derived types do not create any cycles in a model</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="acyclic" type="xs:boolean"/&gt;
</pre></div>
<p>If this attribute is set to true for a complex type <b>CT</b>,
then instances of <b>CT</b> (including any derived types of
<b>CT</b>) that are SML references cannot create any cycles in a
model. In the following example, HostedOnRefType is a complex type
declaration whose instances cannot create a cycle:</p>
<div class="exampleInner">
<pre>
&lt;xs:complexType name="HostedOnRefType" sml:acyclic="true"&gt;
...
&lt;/xs:complexType&gt;
</pre></div>
<p>If the <code>sml:acyclic</code> attribute is not specified or
set to false for a complex type declaration, then instances of this
type that are SML references may create cycles in a model.</p>
</div>
<div class="div3">
<h4><a name="sml_ref_nonnormative_referenc" id=
"sml_ref_nonnormative_referenc"></a>9.1.2 sml:ref</h4>
<p>This global attribute is used to identify SML references.</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="ref" type="xs:boolean"/&gt;
</pre></div>
<p>&nbsp;Any element that has sml:ref="true" will be treated as an
SML reference.</p>
</div>
<div class="div3">
<h4><a name="sml_nilref_nonnormative_referenc" id=
"sml_nilref_nonnormative_referenc"></a>9.1.3 sml:nilref</h4>
<p>This global attribute is used to identify null SML
references.</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="nilref" type="xs:boolean"/&gt;
</pre></div>
<p>Any SML reference that has <code>sml:nilref="true"</code> or
<code>sml:nilref="1"</code> will be treated as a null SML
reference.</p>
</div>
<div class="div3">
<h4><a name="sml_targetElement_nonnormative_referenc" id=
"sml_targetElement_nonnormative_referenc"></a>9.1.4
sml:targetElement</h4>
<p>A <code>QName</code> representing the name of a referenced
element</p>
<div class="exampleInner">
<pre>
 
&lt;xs:attribute name="targetElement" type="xs:QName"/&gt;
</pre></div>
<p><code>sml:targetElement</code> is supported as an attribute for
any&nbsp;element declaration. The value of this attribute must be
the name of some global element declaration. Let
<code>sml:targetElement="ns:GTE"</code> for some element
declaration <b>E</b>. Then each element instance of <b>E</b> must
target an element that is an instance of <b>ns:GTE</b> or an
instance of some global element declaration in the substitution
group hierarchy whose head is <b>ns:GTE</b>.</p>
<p>In the following example, the element referenced by instances of
<code>HostOS</code> must be an instance of
<code>win:Windows</code></p>
<div class="exampleInner">
<pre>
&lt;xs:element name="HostOS" type="tns:HostOSRefType" sml:targetElement="win:Windows" minOccurs="0"/&gt;

&lt;xs:complexType name="HostOSRefType"&gt;
    &lt;xs:sequence&gt;
            &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>A model is invalid if its documents violate one or more
sml:targetElement constraints.</p>
</div>
<div class="div3">
<h4><a name="sml_targetRequired_nonnormative_referenc" id=
"sml_targetRequired_nonnormative_referenc"></a>9.1.5
sml:targetRequired</h4>
<p>Used to specify that instances of an SML reference must target
elements in the model; i.e., an instance of the SML reference can
not be null or contain an unresolved reference. Therefore it is an
error if <code>targetRequired="true"</code> is specified on an
element declaration where the corresponding SML reference element R
has <code>sml:nilref="true"</code>.</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="targetRequired" type="xs:boolean"/&gt;
</pre></div>
<p>In the following example, the <code>targetRequired</code>
attribute is used to specify that application instances must have a
host operating system.</p>
<div class="exampleInner">
<pre>
&lt;xs:complexType name="ApplicationType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="Name" type="xs:string"/&gt;
        &lt;xs:element name="Vendor" type="xs:string"/&gt;
        &lt;xs:element name="Version" type="xs:string"/&gt;
        &lt;xs:element name="HostOSRef" type="tns:HostOSRefType" sml:targetRequired="true"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="HostOSRefType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>A model is invalid if its documents violate one or more
<code>sml:targetRequired</code> constraints.</p>
</div>
<div class="div3">
<h4><a name="sml_targetType_nonnormative_referenc" id=
"sml_targetType_nonnormative_referenc"></a>9.1.6
sml:targetType</h4>
<p>A <code>QName</code> representing the type of a referenced
element</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="targetType" type="xs:QName" /&gt;
</pre></div>
<p><code>sml:targetType</code> is supported as an attribute for any
element declarations. If the value of this attribute is specified
as <code>T</code>, then the type of the referenced element must
either be <code>T</code> or a derived type of <code>T</code>. In
the following example, the type of the element referenced by the
<code>OperatingSystem</code> element must be
"<code>ibm:LinuxType</code>" or its derived type</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="OperatingSystem" type="tns:OperatingSystemRefType"
            sml:targetType="ibm:LinuxType" minOccurs="0"/&gt;

&lt;xs:complexType name="OperatingSystemRefType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;

</pre></div>
<p>A model is invalid if its documents violate one or more
sml:targetType constraints.</p>
</div>
<div class="div3">
<h4><a name="locid_nonnormative_referenc" id=
"locid_nonnormative_referenc"></a>9.1.7 sml:locid</h4>
<p>This attribute can be defined on the <code>sch:assert</code>,
<code>sch:report</code> and on any element with textual content.
The <code>sml:locid</code> attribute is used to define the
translation location for the text content of the containing
element.</p>
<div class="exampleInner">
<pre>
&lt;xs:attribute name="locid" type="xs:QName"/&gt;
</pre></div>
<p>The mechanism for using the <code>QName</code> value of the
<code>sml:locid</code> attribute to locate a translated text is
implementation specific and hence outside the scope of this
specification.</p>
</div>
</div>
<div class="div2">
<h3><a name="Elements" id="Elements"></a>9.2 Elements</h3>
<div class="div3">
<h4><a name="sml_key_nonnormative_referenc" id=
"sml_key_nonnormative_referenc"></a>9.2.1 sml:key</h4>
<p>This element is used to specify a key constraint in some scope.
The semantics are the same as that for <code>xs:key</code> except
that <code>sml:key</code> can also be used to specify key
constraints on other documents; i.e., the
&nbsp;<code>sml:selector</code> child element of
<code>sml:key</code> can contain <code>deref</code> functions to
resolve elements in another document.</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="key" type="sml:keybase"/&gt;
</pre></div>
<p><code>sml:key</code> is supported in the <code>appinfo</code> of
an <code>xs:element</code>. &nbsp;</p>
</div>
<div class="div3">
<h4><a name="sml_keyref_nonnormative_referenc" id=
"sml_keyref_nonnormative_referenc"></a>9.2.2 sml:keyref</h4>
<p>Applies a constraint in the context of the containing
<code>xs:element</code> that scopes the range of a nested document
reference.</p>
<div class="exampleInner">
<pre>
    
&lt;xs:element name="keyref"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:extension base="sml:keybase"&gt;
                &lt;xs:attribute name="refer" type="xs:QName" use="optional"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></div>
<p><code>sml:keyref</code> is supported in the <code>appinfo</code>
of an <code>xs:element</code>. &nbsp;</p>
</div>
<div class="div3">
<h4><a name="sml_unique_nonnormative_referenc" id=
"sml_unique_nonnormative_referenc"></a>9.2.3 sml:unique</h4>
<p>This element is used to specify a uniqueness constraint in some
scope. The semantics are the same as that for
<code>xs:unique</code> except that <code>sml:unique</code> can also
be used to specify uniqueness constraints on other documents; i.e.,
the &nbsp;<code>sml:selector</code> child element of
<code>sml:unique</code> can contain <code>deref</code> functions to
resolve elements in another document.</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="unique" type="sml:keybase"/&gt;
</pre></div>
<p><code>sml:unique</code> is supported in the <code>appinfo</code>
of an <code>xs:element</code>. &nbsp;</p>
</div>
<div class="div3">
<h4><a name="sml_uri_nonnormative_referenc" id=
"sml_uri_nonnormative_referenc"></a>9.2.4 sml:uri</h4>
<p>Specifies an SML reference that is an instance of the SML URI
reference scheme.</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="uri" type="xs:anyURI"/&gt;
</pre></div>
<p>This element must be used to specify SML references that use the
SML URI Reference Scheme.</p>
</div>
</div>
<div class="div2">
<h3><a name="XPath_functions" id="XPath_functions"></a>9.3 XPath
functions</h3>
<div class="div3">
<h4><a name="smlfn_deref_nonnormative_referenc" id=
"smlfn_deref_nonnormative_referenc"></a>9.3.1 smlfn:deref</h4>
<div class="exampleInner">
<pre>
node-set deref(node-set)
</pre></div>
<p>This function takes a node set and attempts to resolve the SML
references.&nbsp;The resulting node set is the set of elements that
are obtained by successfully resolving (or de-referencing) the
&nbsp;SML references. For example,</p>
<div class="exampleInner">
<pre>
deref(/u:Universities/u:Students/u:Student)
</pre></div>
<p>will resolve the SML reference, <code>Student</code>. The target
of an SML reference must always be an element.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="bibl" id="bibl"></a>10. References</h2>
<div class="div2">
<h3><a name="Normative-References" id=
"Normative-References"></a>10.1 Normative</h3>
<dl>
<dt class="label"><a name="SML-IF" id="SML-IF"></a>[SML-IF
1.1]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2009/REC-sml-if-20090512/">Service Modeling
Language Interchange Format Version 1.1</a></cite>, Bhalchandra
Pandit, Valentina Popescu, Virginia Smith, Editors. World Wide Web
Consortium, 12 May 2009. This version of the Service Modeling
Language Interchange Format specification is available at
http://www.w3.org/TR/2009/REC-sml-if-20090512/. The <a href=
"http://www.w3.org/TR/sml-if/">latest version of the Service
Modeling Language Interchange Format Version 1.1</a> specification
is available at http://www.w3.org/TR/sml-if/.</dd>
<dt class="label"><a name="RFC2119" id="RFC2119"></a>[IETF RFC
2119]</dt>
<dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">Key words
for use in RFCs to Indicate Requirement Levels</a></cite>, S.
Bradner, Author. Internet Engineering Task Force, June 1999.
Available at http://www.ietf.org/rfc/rfc2119.txt.</dd>
<dt class="label"><a name="RFC3986" id="RFC3986"></a>[IETF RFC
3986]</dt>
<dd><cite><a href="http://www.ietf.org/rfc/rfc3986.txt">Uniform
Resource Identifier (URI): Generic Syntax</a></cite> , T.
Berners-Lee, R. Fielding, L. Masinter, Authors. Internet
Engineering Task Force, January 2005. Available at
http://www.ietf.org/rfc/rfc3986.txt.</dd>
<dt class="label"><a name="RFC3987" id="RFC3987"></a>[IETF RFC
3987]</dt>
<dd><cite><a href=
"http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource
Identifiers (IRIs)</a></cite> , M. Duerst, M. Suignard, Authors.
Internet Engineering Task Force, January 2005. Available at
http://www.ietf.org/rfc/rfc3987.txt.</dd>
<dt class="label"><a name="RFC2234" id="RFC2234"></a>[RFC
2234]</dt>
<dd><cite><a href=
"http://www.rfc-editor.org/rfc/rfc2234.txt">Augmented BNF for
Syntax Specifications: ABNF</a></cite>, Internet Mail Consortium,
November 1997. Available at
http://www.rfc-editor.org/rfc/rfc2234.txt.</dd>
<dt class="label"><a name="Schematron" id="Schematron"></a>[ISO/IEC
19757-3]</dt>
<dd><cite><a href=
"http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip">
Information technology ― Document Schema Definition Languages
(DSDL) ― Part 3: Rule-based validation ― Schematron</a></cite>.
International Organization for Standardization and International
Electrotechnical Commission, 1 January 2006. Available at
http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</dd>
<dt class="label"><a name="XML_NAMESPACES" id=
"XML_NAMESPACES"></a>[XML-NS]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2006/REC-xml-names-20060816/">Namespaces in
XML 1.0 (Second Edition)</a></cite>, Tim Bray, Dave Hollander,
Andrew Layman, Richard Tobin, Editors. World Wide Web Consortium,
16 August 2006. This version of the Namespaces in XML
Recommendation is
http://www.w3.org/TR/2006/REC-xml-names-20060816/. The <a href=
"http://www.w3.org/TR/xml-names/">latest version of Namespaces in
XML</a> is available at http://www.w3.org/TR/xml-names/.</dd>
<dt class="label"><a name="XML10" id="XML10"></a>[XML]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2006/REC-xml-20060816/">Extensible Markup
Language (XML) 1.0 (Fourth Edition)</a></cite>, T. Bray, J. Paoli,
C. M. Sperberg-McQueen, and E. Maler, Editors. World Wide Web
Consortium, 10 February 1998, revised 16 August 2006. The edition
cited (http://www.w3.org/TR/2006/REC-xml-20060816) was the one
current at the date of publication of this specification as a
Candidate Recommendation. The <a href=
"http://www.w3.org/TR/xml/">latest version of XML 1.0</a> is
available at http://www.w3.org/TR/xml/. Implementations may follow
the edition cited and/or any later edition(s); it is
implementation-defined which editions are supported by an
implementation.</dd>
<dt class="label"><a name="XMLInfoset" id="XMLInfoset"></a>[XML
Information Set]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">XML
Information Set (Second Edition)</a></cite>, John Cowan, Richard
Tobin, Editors. World Wide Web Consortium, 4 February 2004. This
version of the XML Information Set Recommendation is
http://www.w3.org/TR/2004/REC-xml-infoset-20040204/. The <a href=
"http://www.w3.org/TR/xml-infoset/">latest version of XML
Information Set</a> is available at
http://www.w3.org/TR/xml-infoset/.</dd>
<dt class="label"><a name="XSD1" id="XSD1"></a>[XML Schema
Structures]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">XML Schema
Part 1: Structures Second Edition</a></cite>, H. Thompson, D.
Beech, M. Maloney, and N. Mendelsohn, Editors. World Wide Web
Consortium, 2 May 2001, revised 28 October 2004. This version of
the XML Schema Part 1 Recommendation is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version of XML Schema
1.0 Part 1</a> is available at
http://www.w3.org/TR/xmlschema-1.</dd>
<dt class="label"><a name="XSD2" id="XSD2"></a>[XML Schema
Datatypes]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema
Part 2: Datatypes Second Edition</a></cite>, P. Byron and A.
Malhotra, Editors. World Wide Web Consortium, 2 May 2001, revised
28 October 2004. This version of the XML Schema Part 2
Recommendation is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version of XML Schema
1.0 Part 2</a> is available at
http://www.w3.org/TR/xmlschema-2.</dd>
<dt class="label"><a name="XSD3" id="XSD3"></a>[XML Schema for
Schemas]</dt>
<dd><cite><a href="http://www.w3.org/2001/XMLSchema.xsd">XML Schema
for XML Schemas</a></cite>. World Wide Web Consortium, 2 May 2001,
revised 28 October 2004.</dd>
<dt class="label"><a name="XPath" id="XPath"></a>[XPath]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/1999/REC-xpath-19991116">XML Path Language
(XPath) Version 1.0</a></cite>, J. Clark and S. DeRose, Editors.
World Wide Web Consortium, 16 November 1999. This version of XML
Path Language (XPath) Version 1.0 is
http://www.w3.org/TR/1999/REC-xpath-19991116. The <a href=
"http://www.w3.org/TR/xpath">latest version of XML Path Language
(XPath) Version 1.0</a> is available at
http://www.w3.org/TR/xpath.</dd>
<dt class="label"><a name="XPTR" id="XPTR"></a>[XPointer]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2003/REC-xptr-framework-20030325/">XPointer
Framework</a></cite>, P. Grosso, E. Maler, J. Marsh, and N. Walsh,
Editors. World Wide Web Consortium, 25 March 2003. This version of
the XPointer Framework Recommendation is
http://www.w3.org/TR/2003/REC-xptr-framework-20030325/ The <a href=
"http://www.w3.org/TR/xptr-framework/">latest version of XPointer
Framework</a> is available at
http://www.w3.org/TR/xptr-framework/.</dd>
<dt class="label"><a name="XPTR-xmlns" id="XPTR-xmlns"></a>[xmlns()
Scheme]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325/">XPointer
xmlns() Scheme</a></cite>, S. DeRose, R. Daniel Jr., E. Maler, and
J. Marsh, Editors. World Wide Web Consortium, 25 March 2003. This
version of the XPointer xmlns() Scheme Recommendation is
http://www.w3.org/TR/2003/REC-xptr-framework-20030325/ The <a href=
"http://www.w3.org/TR/xptr-xmlns/">latest version of XPointer
xmlns() Scheme</a> is available at
http://www.w3.org/TR/xptr-xmlns/.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="NonNormative-References" id=
"NonNormative-References"></a>10.2 Non-Normative</h3>
<dl>
<dt class="label"><a name="intro_schematron" id=
"intro_schematron"></a>[Introduction to Schematron]</dt>
<dd><cite><a href=
"http://www.xml.com/pub/a/2003/11/12/schematron.html">An
Introduction to Schematron</a></cite>, Eddie Robertsson, Author.
O'Reilly Media, Inc., 12 November 2003. Available at
http://www.xml.com/pub/a/2003/11/12/schematron.html</dd>
<dt class="label"><a name="improving_schematron" id=
"improving_schematron"></a>[Improving Validation with
Schematron]</dt>
<dd><cite><a href=
"http://msdn.microsoft.com/en-us/library/aa468554.aspx">Improving
XML Document Validation with Schematron</a></cite>, Dare Obasanjo,
Author. Microsoft Corporation, September 2004. Available at
http://msdn.microsoft.com/en-us/library/aa468554.aspx</dd>
<dt class="label"><a name="XSD0" id="XSD0"></a>[XML Schema
Primer]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/">XML Schema
Part 0: Primer Second Edition</a></cite>, D. Fallside and P.
Walmsley, Editors. World Wide Web Consortium, 2 May 2001, revised
28 October 2004. This version of the XML Schema Part 0
Recommendation is
http://www.w3.org/TR/2004/REC-xmlschema-0-20041028. The <a href=
"http://www.w3.org/TR/xmlschema-0/">latest version of XML Schema
Part 0</a> is available at http://www.w3.org/TR/xmlschema-0.</dd>
</dl>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="SML_schema" id="SML_schema"></a>A. Normative SML
Schema</h2>
<div class="exampleInner">
<pre>
&lt;!--
/*
 * Copyright © ns World Wide Web Consortium,
 *
 * (Massachusetts Institute of Technology, European Research Consortium for
 * Informatics and Mathematics, Keio University). All Rights Reserved. This
 * work is distributed under the W3C® Document License [1] in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * [1] http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
 */
--&gt;&lt;xs:schema
      xmlns:sml="http://www.w3.org/ns/sml"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      targetNamespace="http://www.w3.org/ns/sml"
      elementFormDefault="qualified"
      blockDefault="#all"
      version="1.0"
      xml:lang="en"
      finalDefault=""
      attributeFormDefault="unqualified"&gt;
   &lt;!--
        References
        ==========
    --&gt;
   
   &lt;!-- CONTEXT: To be used in any &lt;xs:element&gt; --&gt;
   &lt;xs:attribute name="ref" type="xs:boolean"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                Specifies if the element contains a reference
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in any &lt;xs:element&gt; --&gt;
   &lt;xs:attribute name="nilref" type="xs:boolean"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                Specifies that the reference element denotes a “null” reference. 
                To be used only on elements for which sml:ref="true".
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in any &lt;xs:element&gt; --&gt;
   &lt;xs:attribute name="targetElement" type="xs:QName"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                A qualified name of a global element in the referenced document.
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in any &lt;xs:element&gt;--&gt;
   &lt;xs:attribute name="targetRequired" type="xs:boolean"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                If true, requires the target element of the reference to
                exist in the model.
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in any &lt;xs:element&gt;--&gt;
   &lt;xs:attribute name="targetType" type="xs:QName"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                A qualified name of the type of the element in the
                referenced document.
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in any &lt;xs:complexType&gt;--&gt;
   &lt;xs:attribute name="acyclic" type="xs:boolean"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                If this attribute is set to true for a type D 
                then instances of D should not create any
                cycles in a model. See Section 5.1.1.3 titled "Instance Validity Rules".                
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:attribute&gt;
   &lt;!-- CONTEXT: To be used in &lt;sch:assert&gt;, &lt;sch:report&gt;
         and elements with textual content.
         This attribute is used to support string localization.
         It is used to define the translation location for 
         the text content of the containing element.--&gt;
   &lt;xs:attribute name="locid" type="xs:QName"/&gt;
   &lt;!-- CONTEXT: Represents a reference using the URI scheme. To be
         used as a child  element of elements for which
         sml:ref="true". --&gt;
   &lt;xs:element name="uri" type="xs:anyURI"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                References in URI scheme must be representend by this
                element.  
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
   &lt;/xs:element&gt;
   &lt;!--
        Uniqueness and Key constraints
        ==============================
    --&gt;
   &lt;xs:complexType name="keybase" mixed="false"&gt;
      &lt;xs:sequence minOccurs="0"&gt;
         &lt;xs:element
               name="selector"
               type="sml:selectorXPathType"/&gt;
         &lt;xs:element
               name="field"
               type="sml:fieldXPathType"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               minOccurs="0"
               maxOccurs="unbounded"
               processContents="lax"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="name" type="xs:NCName"/&gt;
      &lt;xs:attribute name="ref" type="xs:QName"/&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element name="key" type="sml:keybase"/&gt;
   &lt;xs:element name="unique" type="sml:keybase"/&gt;
   &lt;xs:element name="keyref"&gt;
      &lt;xs:complexType mixed="false"&gt;
         &lt;xs:complexContent&gt;
            &lt;xs:extension base="sml:keybase"&gt;
               &lt;xs:attribute
                     name="refer"
                     type="xs:QName"
                     use="optional"/&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;
   &lt;!--
        Other Complex Types
        ==================
    --&gt;
   &lt;xs:complexType name="selectorXPathType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any
               namespace="##other"
               minOccurs="0"
               maxOccurs="unbounded"
               processContents="lax"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="xpath" use="required"&gt;
         &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:string"&gt;
   &lt;!-- The value MUST conform to the selector BNF grammar defined in
                         section '4.4 Identity Constraints' in the SML specification.
                    --&gt;
   &lt;/xs:restriction&gt;
         &lt;/xs:simpleType&gt;
      &lt;/xs:attribute&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="fieldXPathType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any
               namespace="##other"
               minOccurs="0"
               maxOccurs="unbounded"
               processContents="lax"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="xpath" use="required"&gt;
         &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:string"&gt;
   &lt;!-- The value MUST conform to the field BNF grammar defined in
                         section '4.4 Identity Constraints' in the SML specification.
                    --&gt;
   &lt;/xs:restriction&gt;
         &lt;/xs:simpleType&gt;
      &lt;/xs:attribute&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="Model_Definition_Document_Sample" id=
"Model_Definition_Document_Sample"></a>B. Model Definition Document
Sample (Non-Normative)</h2>
<p>This <a title="" href="#model_definition">model definition
document</a> sample illustrates the use of the following SML
extensions:</p>
<ol class="enumar">
<li>
<p><a title="" href="#reference">SML references</a></p>
</li>
<li>
<p><code>key</code> and <code>keyref</code> constraints</p>
</li>
<li>
<p>Schematron constraints</p>
</li>
</ol>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;!--
/*
 * Copyright ©  World Wide Web Consortium,
 *
 * (Massachusetts Institute of Technology, European Research Consortium for
 * Informatics and Mathematics, Keio University). All Rights Reserved. This
 * work is distributed under the W3C® Document License [1] in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * [1] http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
 */
--&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://example.org/SampleModel" xmlns:sml="http://www.w3.org/ns/sml" xmlns:smlfn="http://www.w3.org/ns/sml-function" xmlns:sch="http://purl.oclc.org/dsdl/schematron" targetNamespace="http://example.org/SampleModel" elementFormDefault="qualified" finalDefault="" blockDefault="" attributeFormDefault="unqualified"&gt;

  &lt;xs:simpleType name="SecurityLevel"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="Low"/&gt;
      &lt;xs:enumeration value="Medium"/&gt;
      &lt;xs:enumeration value="High"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:complexType name="Hostref" sml:acyclic="true" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;

  
   &lt;!-- This element represents the host operating system for
       an application. Note that the type of the referenced
       element must be OperatingSystemType or a derived type
       of OperatingSystemType --&gt;
   
  &lt;xs:element name="HostOSRef" type="tns:Hostref" sml:targetType="tns:OperatingSystemType"/&gt;

  &lt;xs:complexType name="ApplicationType" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Name" type="xs:string"/&gt;
      &lt;xs:element name="Vendor" type="xs:string"/&gt;
      &lt;xs:element name="Version" type="xs:string"/&gt;
      &lt;xs:element ref="tns:HostOSRef" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt; 

  &lt;xs:simpleType name="ProtocolType"&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:enumeration value="TCP"/&gt;
          &lt;xs:enumeration value="UDP"/&gt;
          &lt;xs:enumeration value="SMTP"/&gt;
          &lt;xs:enumeration value="SNMP"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:complexType name="GuestAppRefType" sml:acyclic="false" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="GuestAppRef" type="tns:GuestAppRefType" sml:targetType="tns:ApplicationType"/&gt;

  &lt;xs:complexType name="OperatingSystemType" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Name" type="xs:string"/&gt;
      &lt;xs:element name="FirewallEnabled" type="xs:boolean"/&gt;
      &lt;xs:element name="Protocol" type="tns:ProtocolType"/&gt;
      
   &lt;!-- The following element represents the applications hosted by
           operating system --&gt;
   
      &lt;xs:element name="Applications" minOccurs="0"&gt;
        &lt;xs:complexType mixed="false"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="tns:GuestAppRef" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="OSRefType" sml:acyclic="false" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="OSRef" type="tns:OSRefType" sml:targetType="tns:OperatingSystemType"/&gt;

  &lt;xs:complexType name="WorkstationType" mixed="false"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Name" type="xs:string"/&gt;
      &lt;xs:element ref="tns:OSRef"/&gt;
      &lt;xs:element name="Applications" minOccurs="0"&gt;
        &lt;xs:complexType mixed="false"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="tns:GuestAppRef" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt; 

  &lt;xs:element name="Workstation" type="tns:WorkstationType"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:appinfo&gt;
        &lt;sch:schema&gt;
          &lt;sch:ns prefix="sm" uri="SampleModel"/&gt;
          &lt;sch:ns prefix="smlfn" uri="http://www.w3.org/ns/sml-function"/&gt;
          &lt;sch:pattern id="OneHostOS"&gt;
            
   &lt;!-- The constraints in the following rule are evaluated  
                 For all instances of the Workstation global element--&gt;
   
            &lt;sch:rule context="."&gt;
              
   &lt;!-- define a named variable - MyApplications -
                   for use in test expression--&gt;
   
              &lt;sch:let name="MyApplications" value="smlfn:deref(sm:Applications/sm:GuestAppRef)"/&gt;
              &lt;sch:assert test="count($MyApplications)=count($MyApplications/sm:HostOSRef)"&gt;
                Each application in workstation
                &lt;sch:value-of select="string(sm:Name)"/&gt;
                must be hosted on an operating system
              &lt;/sch:assert&gt;
            &lt;/sch:rule&gt;
          &lt;/sch:pattern&gt;
        &lt;/sch:schema&gt;

        
   &lt;!-- In a workstation, (Vendor,Name,Version) is the key for
             guest applications --&gt;
   
        &lt;sml:key name="GuestApplicationKey"&gt;
          &lt;sml:selector xpath="smlfn:deref(tns:Applications/tns:GuestAppRef)"/&gt;
          &lt;sml:field xpath="tns:Vendor"/&gt;
          &lt;sml:field xpath="tns:Name"/&gt;
          &lt;sml:field xpath="tns:Version"/&gt;
        &lt;/sml:key&gt;

        
   &lt;!-- In a workstation, Name is the key for operating system --&gt;
   
        &lt;sml:key name="OSKey"&gt;
          &lt;sml:selector xpath="smlfn:deref(tns:OSRef)"/&gt;
          &lt;sml:field xpath="tns:Name"/&gt;
        &lt;/sml:key&gt;
        
        
   &lt;!-- In a workstation, the applications hosted by the
             referenced operatinsystem must be a subset of the
             applications in the workstation --&gt;
   
        &lt;sml:keyref name="OSGuestApplication" refer="tns:GuestApplicationKey"&gt;
          &lt;sml:selector xpath="smlfn:deref(tns:OSRef)/tns:Applications/tns:GuestAppRef"/&gt;
          &lt;sml:field xpath="tns:Vendor"/&gt;
          &lt;sml:field xpath="tns:Name"/&gt;
          &lt;sml:field xpath="tns:Version"/&gt;   
        &lt;/sml:keyref&gt;

        
   &lt;!-- In a workstation, the host operating system of guest
             applications must be a subset of the operating system in
             the workstation --&gt;
   
        &lt;sml:keyref name="ApplicationHostOS" refer="tns:OSKey"&gt;
          &lt;sml:selector xpath="smlfn:deref(tns:Applications/tns:GuestAppRef)/tns:HostOSRef"/&gt;
          &lt;sml:field xpath="tns:Name"/&gt;
        &lt;/sml:keyref&gt;
      &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="SecureWorkstation" type="tns:WorkstationType"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:appinfo&gt;
        &lt;sch:schema&gt;
          &lt;sch:ns prefix="sm" uri="SampleModel"/&gt;
          &lt;sch:ns prefix="smlfn" uri="http://www.w3.org/ns/sml-function"/&gt;
          &lt;sch:pattern id="SecureApplication"&gt;
            &lt;sch:rule context="sm:Applications/sm:Application"&gt;
              &lt;sch:report test="smlfn:deref(.)[sm:SecurityLevel!='High']"&gt;
                Application &lt;sch:value-of select="string(sm:Name)"/&gt;
                from &lt;sch:value-of select="string(sm:Vendor)"/&gt;
                does not have high security level.
              &lt;/sch:report&gt;
              &lt;sch:assert test="smlfn:deref(.)[sm:Vendor='TrustedVendor']"&gt;
                A secure workstation can only contain
                applications from TrustedVendor.
              &lt;/sch:assert&gt;
            &lt;/sch:rule&gt;
          &lt;/sch:pattern&gt;
        &lt;/sch:schema&gt;
      &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:element&gt;

&lt;/xs:schema&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="SML_References_Sample" id=
"SML_References_Sample"></a>C. SML References Sample
(Non-Normative)</h2>
<p>The following example illustrates the use of SML references.
Consider the following schema fragment:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="EnrolledCourse"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element name="Name" type="xs:string"/&gt;
          &lt;xs:element name="Grade" type="xs:string"/&gt;
          &lt;xs:any namespace="##any" minOccurs="0"
                  maxOccurs="unbounded" processContents="lax"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="StudentType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="ID" type="xs:string"/&gt;
        &lt;xs:element name="Name" type="xs:string"/&gt;
        &lt;xs:element name="EnrolledCourses" minOccurs="0"&gt;
            &lt;xs:complexType&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element ref="tns:EnrolledCourse" maxOccurs="unbounded"/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>The schema definition in the above example is SML agnostic and
does not make use of any SML attributes, elements, or types. The
<code>EnrolledCourse</code> element, however, has an open content
model and this can be used to mark instances of
<code>EnrolledCourse</code> as SML references as shown below:</p>
<div class="exampleInner">
<pre>
&lt;Student xmlns="http://www.university.example.org/ns"
         xmlns:sml="http://www.w3.org/ns/sml"
         xmlns:u="http://www.university.example.org/ns"&gt;
    &lt;ID&gt;1000&lt;/ID&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;EnrolledCourses&gt;
        &lt;EnrolledCourse sml:ref="true"&gt;
            &lt;Name&gt;PHY101&lt;/Name&gt;
            &lt;Grade&gt;A&lt;/Grade&gt;
            &lt;sml:uri&gt;
                http://www.university.example.org/Universities/MIT/Courses.xml
                #smlxpath1(/u:Courses/u:Course[u:Name='PHY101'])
            &lt;/sml:uri&gt;
        &lt;/EnrolledCourse&gt;
        &lt;EnrolledCourse sml:ref="false"&gt;
            &lt;Name&gt;MAT100&lt;/Name&gt;
            &lt;Grade&gt;B&lt;/Grade&gt;
            &lt;sml:uri&gt;
                http://www.university.example.org/Universities/MIT/Courses.xml
                #smlxpath1(/u:Courses/u:Course[u:Name='MAT100'])
            &lt;/sml:uri&gt;
        &lt;/EnrolledCourse&gt;
        &lt;EnrolledCourse&gt;
            &lt;Name&gt;SocialSkills&lt;/Name&gt;
            &lt;Grade&gt;F&lt;/Grade&gt;
        &lt;/EnrolledCourse&gt;
    &lt;/EnrolledCourses&gt;
&lt;/Student&gt;
</pre></div>
<p>The first <code>EnrolledCourse</code> element in the above
example is an SML reference since it specifies
<code>sml:ref="true"</code>. It uses the SML URI Reference Scheme
to target the element for course &nbsp;PHY101. The second and third
<code>EnrolledCourse</code> elements are not SML references; the
second element specifies <code>sml:ref="false"</code> and the third
element does not specify the <code>sml:ref</code> attribute. Note
that the second <code>EnrolledCourse</code> element contains an
<code>sml:uri</code> element which satisfies the syntax of the SML
URI Reference Scheme (referring to course MAT100) but this will be
ignored since <code>sml:ref="false"</code> for this
<code>EnrolledCourse</code> element.</p>
<p>Note that, there are no SML constraints defined on the
<code>EnrolledCourse</code> element or on the type of that element
in the schema. Therefore, even if the first
<code>EnrolledCourse</code> element instance is marked as an SML
reference, no SML constraints are evaluated for that element during
model validation. However, checks such as the ones defined in
section <a href="#At_Most_One_Target"><b>4.2.1 At Most One
Target</b></a> and section <a href=
"#Consistent_References"><b>4.2.2 Consistent References</b></a> are
still performed on that SML reference during model validation.</p>
<p>An <code>EnrolledCourse</code> SML reference can be a marked as
a null reference if it specifies the <code>sml:nilref="true"</code>
attribute as shown in the following example (the first
<code>EnrolledCourse</code> element is a null SML reference):</p>
<div class="exampleInner">
<pre>
&lt;Student xmlns="http://www.university.example.org/ns"
         xmlns:sml="http://www.w3.org/ns/sml"
         xmlns:u="http://www.university.example.org/ns"&gt;
    &lt;ID&gt;1000&lt;/ID&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;EnrolledCourses&gt;
        &lt;EnrolledCourse sml:ref="true" sml:nilref="true"&gt;
            &lt;Name&gt;PHY101&lt;/Name&gt;
            &lt;Grade&gt;A&lt;/Grade&gt;
        &lt;/EnrolledCourse&gt;
        &lt;EnrolledCourse sml:ref="false"&gt;
            &lt;Name&gt;MAT100&lt;/Name&gt;
            &lt;Grade&gt;B&lt;/Grade&gt;
            &lt;sml:uri&gt;
                http://www.university.example.org/Universities/MIT/Courses.xml
                #smlxpath1(/u:Courses/u:Course[u:Name='MAT100'])
            &lt;/sml:uri&gt;
        &lt;/EnrolledCourse&gt;
        &lt;EnrolledCourse&gt;
            &lt;Name&gt;SocialSkills&lt;/Name&gt;
            &lt;Grade&gt;F&lt;/Grade&gt;
        &lt;/EnrolledCourse&gt;
    &lt;/EnrolledCourses&gt;
&lt;/Student&gt;
</pre></div>
<p>In the above example, the first SML reference,
<code>EnrolledCourse</code>, defines the
<code>sml:nilref="true"</code> attribute which marks this as a null
SML reference. By specifying a null reference, the document author
makes an explicit declaration that this <code>Student</code>
element does not refer to any target element. Specifying a null
reference does not have any SML-defined effect on the
interpretation of element in non-SML contexts. In particular, in
this case, SML says nothing about the interpretation of the
<code>Grade</code> and <code>Name</code> elements. Any such
interpretation is left to the application, its usage context, other
specifications, etc.</p>
</div>
<div class="div1">
<h2><a name="SML_URI_Reference_Scheme_Example" id=
"SML_URI_Reference_Scheme_Example"></a>D. SML URI Reference Scheme
Sample (Non-Normative)</h2>
<p>The following example illustrates the use of the SML URI
Reference Scheme [<a href="#URI_Reference_Scheme"><b>4.3.1 SML URI
Reference Scheme</b></a>]. Consider the case where all courses
offered by MIT are stored in a single XML document –
<code>Courses.xml</code> – whose URI is
&nbsp;<code>http://www.university.example.org/Universities/MIT/Courses.xml</code>.
In this case, the element inside <code>Courses.xml</code> that
corresponds to the course PHY101 can be referenced as follows
(assuming that <code>Courses</code>is the root element in
<code>Courses.xml</code>)</p>
<div class="exampleInner">
<pre>
&lt;Student xmlns="http://www.university.example.org/ns"&gt;
    &lt;ID&gt;1000&lt;/ID&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;EnrolledCourses&gt;
        &lt;EnrolledCourse sml:ref="true" xmlns:u="http://www.university.example.org/ns"&gt;
            &lt;sml:uri&gt;
                http://www.university.example.org/Universities/MIT/Courses.xml
                #smlxpath1(/u:Courses/u:Course[u:Name='PHY101'])
            &lt;/sml:uri&gt;
        &lt;/EnrolledCourse&gt;
    &lt;/EnrolledCourses&gt;
&lt;/Student&gt;
</pre></div>
<p>An SML reference can also reference an element in its own
document. To see this consider the following instance document</p>
<div class="exampleInner">
<pre>
&lt;University xmlns="http://www.university.example.org/ns"&gt;
    &lt;Name&gt;MIT&lt;/Name&gt;
    &lt;Courses&gt;
        &lt;Course&gt;
            &lt;Name&gt;PHY101&lt;/Name&gt;
        &lt;/Course&gt;
        &lt;Course&gt;
            &lt;Name&gt;MAT200&lt;/Name&gt;
        &lt;/Course&gt;
    &lt;/Courses&gt;
    &lt;Students&gt;
        &lt;Student&gt;
            &lt;ID&gt;123&lt;/ID&gt;
            &lt;Name&gt;Jane Doe&lt;/Name&gt;
            &lt;EnrolledCourses&gt;
                &lt;EnrolledCourse sml:ref="true" xmlns:u="http://www.university.example.org/ns"&gt;
                    &lt;sml:uri&gt;
                        #smlxpath1(/u:University/u:Courses/u:Course[u:Name='MAT200'])
                    &lt;/sml:uri&gt;
                &lt;/EnrolledCourse&gt;
            &lt;/EnrolledCourses&gt;
        &lt;/Student&gt;
    &lt;/Students&gt;
&lt;/University&gt;
</pre></div>
<p>Here, the <code>EnrolledCourse</code> element for the student
Jane Doe references the <code>Course</code> element for MAT200 in
the same document.</p>
</div>
<div class="div1">
<h2><a name="Identity_Constraints_Example" id=
"Identity_Constraints_Example"></a>E. SML Identity Constraints
Sample (Non-Normative)</h2>
<p>The following example will be used to illustrate the
<code>sml:key</code>, <code>sml:unique</code>, and
<code>sml:keyref</code> constraints across SML references. This
example consists of three schema documents.
<code>university.xsd</code> contains the type definitions for a
University element, a Student SML reference and a Course SML
reference. <code>students.xsd</code> contains the type definitions
for an EnrolledCourse SML reference and a Student element.
<code>courses.xsd</code> contains the type definition for a Course
element.</p>
<div class="exampleInner">
<pre>
&lt;!-- from university.xsd --&gt;
&lt;xs:complexType name="StudentRefType"&gt;
    &lt;!-- SML reference to a Student --&gt;
    &lt;xs:sequence&gt;
        &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;
  
&lt;xs:element name="Student" type="StudentRefType"/&gt;

&lt;xs:complexType name="CourseRefType"&gt;
    &lt;!-- SML reference to a Course --&gt;
    &lt;xs:sequence&gt;
        &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="Course" type="CourseRefType"/&gt;

&lt;xs:complexType name="UniversityType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="Name" type="xs:string"/&gt;
        &lt;xs:element name="Students" minOccurs="0"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
              &lt;xs:element ref="Student" maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
        &lt;xs:element name="Courses" minOccurs="0"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
              &lt;xs:element ref="Course" maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;!-- from students.xsd --&gt;
&lt;xs:complexType name="EnrolledCourseRefType"&gt;
    &lt;!-- SML reference to a Course --&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="Grade" type="xs:string"/&gt;
        &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute namespace="##any" processContents="lax"/&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="EnrolledCourse" type="EnrolledCourseRefType"/&gt;

&lt;xs:complexType name="StudentType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="ID" type="xs:string"/&gt;
        &lt;xs:element name="SSN" type="xs:string" minOccurs="0"/&gt;
        &lt;xs:element name="Name" type="xs:string"/&gt;
        &lt;xs:element name="EnrolledCourses" minOccurs="0"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="EnrolledCourse" maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="Students"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Student" type="StudentType"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;!-- from courses.xsd --&gt;
&lt;xs:complexType name="CourseType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="Name" type="xs:string"/&gt;
        &lt;xs:element name="EnrolledStudents" minOccurs="0"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="EnrolledStudent" maxOccurs="unbounded"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:sequence&gt;
                        &lt;xs:element name="StudentID" type="xs:string"/&gt;
                    &lt;/xs:sequence&gt;
                &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="Courses"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Course" type="CourseType"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></div>
<p><b>sml:key and sml:unique</b></p>
<p>XML Schema supports key and uniqueness constraints through
<code>xs:key</code> and <code>xs:unique,</code> but these
constraints can only be specified within a single XML document. The
<code>sml:key</code> and <code>sml:unique</code> elements
&nbsp;support the specification of key and uniqueness constraints
across documents. &nbsp;We'll use the <code>UniversityType</code>
definition to illustrate this concept. It is reasonable to expect
that each student in a university must have a unique identity, and
this identity must be specified. This can be expressed as
follows:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="University" type="tns:UniversityType"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:appinfo&gt;
            &lt;sml:key name="StudentIDisKey"&gt;
                &lt;sml:selector xpath="smlfn:deref(tns:Students/tns:Student)/tns:ID"/&gt;
                &lt;sml:field xpath="."/&gt;  
            &lt;/sml:key&gt;  
        &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
</pre></div>
<p>The <code>sml:key</code> and <code>sml:unique</code> constraints
are similar but not the same. <code>sml:key</code> requires that
the specified fields must be present in instance documents and have
unique values, whereas <code>sml:unique</code> simply requires the
specified fields to have unique values but does not require them to
be present in instance documents. &nbsp;Thus keys imply uniqueness,
but uniqueness does not imply keys. &nbsp;For example, students in
a university must have a unique social security numbers, but the
university may have foreign students who do not possess this
number. This constraint can be specified as follows:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="University" type="tns:UniversityType"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:appinfo&gt;
            &lt;sml:unique name="StudentSSNisUnique"&gt;
                &lt;sml:selector xpath="smlfn:deref(tns:Students/tns:Student)"/&gt;
                &lt;sml:field xpath="tns:SSN"/&gt;  
            &lt;/sml:unique&gt;  
        &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
</pre></div>
<p>The <code>sml:key</code> and <code>sml:unique</code>
&nbsp;constraint are always specified in the context of a scoping
element. In the above example, the <code>University</code> element
declaration is the context for the key and unique constraints.</p>
<p>The following example illustrates the use of the
<code>ref</code> attribute in an SML identity constraint:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="PrivateUniversity" type="tns:UniversityType"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:appinfo&gt;
            &lt;sml:unique ref="tns:StudentSSNisUnique"/&gt;
        &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
</pre></div>
<p>In the above example, the <code>PrivateUniversity</code> element
declaration specifies the <code>StudentSSNisUnique</code> unique
constraint by referencing its <code>name</code> in the
<code>University</code> element declaration.</p>
<p><b>sml:keyref</b></p>
<p>XML Schema supports key references through
<code>xs:keyref</code> to ensure that one set of values is a subset
of another set of values within an XML document. Such constraints
are similar to foreign keys in relational databases. Key references
in XML Schema are only supported within a single XML document. The
<code>sml:keyref</code> element allows key references to be
specified across SML references and across XML documents. The
following example uses <code>sml:keyref</code> to capture the
requirement that students enrolled in a course must be currently
enrolled in the university:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="University" type="tns:UniversityType"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:appinfo&gt;
            &lt;sml:key name="StudentIDisKey"&gt;
                &lt;sml:selector xpath="smlfn:deref(tns:Students/tns:Student)"/&gt;
                &lt;sml:field xpath="tns:ID"/&gt;  
            &lt;/sml:key&gt;  
            &lt;sml:keyref name="CourseStudents" refer="tns:StudentIDisKey"&gt;
                &lt;sml:selector xpath="smlfn:deref(tns:Courses/tns:Course)/tns:EnrolledStudents/tns:EnrolledStudent"/&gt;
                &lt;sml:field xpath="tns:ID"/&gt;
            &lt;/sml:keyref&gt;
        &lt;/xs:appinfo&gt;
    &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
</pre></div>
<p>The above constraint specifies that for a university, the set of
IDs of students enrolled in a course is a subset of the set of IDs
of students currently enrolled in the university. In particular,
the <code>selector</code> and <code>field</code> elements in
<code>StudentIDisKey</code> key constraint identify the set of IDs
of students currently enrolled in the university, and the
<code>selector</code> and <code>field</code> elements in
<code>CourseStudents</code> key reference constraint identify the
set of IDs of students enrolled in courses. &nbsp;</p>
</div>
<div class="div1">
<h2><a name="Localization_Sample" id="Localization_Sample"></a>F.
Localization and Variable Substitution Samples (Non-Normative)</h2>
<p>The following examples demonstrate how localization can be
applied to a message text resulting from Schematron rule
evaluation, allowing a <a title="" href="#model_processor">model
processor</a> to support multiple locales without changes to either
the model processor or the Schematron rules. Summarized below are
the benefits resulting from using the <code>sml:locid</code>
localization support:</p>
<ol class="enumar">
<li>
<p>The Schematron rule message text is locale-independent in the
sense that the author does not have to be concerned with the rule
evaluator's runtime locale. The Schematron rule is defined
generically, consumable for any evaluator (including a model
processor) for which a translation file is made available at the
location defined by the <code>sml:locid</code> value's <a href=
"http://www.w3.org/TR/xml-names/#dt-NSName">namespace name</a>.</p>
</li>
<li>
<p>There is a clear separation between the message text
translation, Schematron rule authoring, and Schematron rule
evaluator code. The Schematron rules require no changes when
translations for other languages are made available. The same
Schematron rule can be used by multiple evaluators, each supporting
a distinct set of languages. To support a new language, all that
needs to be done is to add a new translation file under the
location identified by the <code>sml:locid</code> value's <a href=
"http://www.w3.org/TR/xml-names/#dt-NSName">namespace name</a>.</p>
</li>
</ol>
<p>Building on the preceding university example, the following
example of a Schematron rule uses the <code>sml:locid</code>
attribute to locate translation information for the Schematron
<code>sch:assert</code> error message:</p>
<div class="exampleInner">
<pre>
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"
            xmlns:lang="http://www.university.example.org/translation/"&gt;
  
    &lt;sch:ns prefix="u" uri="http://www.university.example.org/ns" /&gt;
    &lt;sch:ns prefix="smlfn" uri="http://www.w3.org/ns/sml-function"/&gt;
    &lt;sch:pattern id="StudentPattern”&gt;
        &lt;sch:rule context="u:Students/u:Student"&gt;
            &lt;sch:assert test=".[starts-with(u:ID,'99')]"
                        sml:locid="lang:StudentIDErrorMsg"&gt;
                The specified ID &lt;sch:value-of select="string(u:ID)"/&gt; does not begin with 99.
            &lt;/sch:assert&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;
</pre></div>
<p>In general, the <a href=
"http://www.w3.org/TR/xml-names/#dt-NSName">namespace name</a> can
point to a file containing the translated message, a folder
containing a set of translated files or any other type of resource
that can help locate the translated message. It is
implementation-dependent how the model validator makes use of this
information for finding the actual resource containing the
translated message.</p>
<p>In this concrete example, the <a href=
"http://www.w3.org/TR/xml-names/#dt-NSName">namespace name</a> of
the <code>sml:locid</code> attribute value is used to define the
location of the resource containing the translated text:</p>
<div class="exampleInner">
<pre>
xmlns:lang="http://www.university.example.org/translation/"
</pre></div>
<p>Also, in this concrete example,
<code>http://www.university.example.org/translation/</code> names a
folder containing a set of translation resources, and there is one
set of translation files located under
<code>http://www.university.example.org/translation/</code>. Each
of these translation files corresponds to a language into which the
messages have been translated. The translations to French and
German are available in the following files:</p>
<ol class="enumar">
<li>
<p>File
<code>http://www.university.example.org/translation/lang_fr.txt</code>
contains the French translation of the <code>sch:assert</code>
message.</p>
</li>
<li>
<p>File
<code>http://www.university.example.org/translation/lang_de.txt</code>
contains the German translation of the <code>sch:assert</code>
message.</p>
</li>
</ol>
<p>The {local part} of the <code>sml:locid</code> attribute value
(<code>StudentIDErrorMsg</code>) is used to define the identity of
the message being translated. This identity is used to locate the
translated text within the translation resource.</p>
<p>The French translation of the <code>sch:assert</code> message is
found in the following entry:</p>
<div class="exampleInner">
<pre>
StudentIDErrorMsg = L'identifiant specifié &lt;sch:value-of select="string(u:ID)"/&gt; ne commence pas par 99.
</pre></div>
<p>The German translation for the <code>sch:assert</code> message
is found in the following entry:</p>
<div class="exampleInner">
<pre>
StudentIDErrorMsg = Der angegebene Wert des Attributs ID (&lt;sch:value-of  select="string(u:ID)"/&gt;) beginnt nicht mit "99".
</pre></div>
<p>Translatable messages, especially strings containing XML tags
(such as <code>&lt;sch:value-of select="string(u:ID)"/&gt;</code>
in the example below), may be best stored in XML containers. This
allows more flexibility to manipulate and translate the data. For
example, the XML document could utilize ITS (see <a href=
"http://www.w3.org/TR/its/">Internationalization Tag Set (ITS)
specification</a>) to add localization-related information.</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"/&gt;
&lt;messages xml:lang="en"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:its="http://www.w3.org/2005/11/its"&gt;  
    &lt;msg xml:id='StudentIDErrorMsg'
          its:locNote="This message should not be longer than 128 characters"&gt;
          The specified ID &lt;sch:value-of select="string(u:ID)"/&gt; does not begin with 99.
    &lt;/msg&gt; 
&lt;/messages&gt;
</pre></div>
<p><b>Best Practice Recommendation for Variable
Substitution</b></p>
<p>It is often the case that translated text can be reused, for
example, a Schematron message can be reused in different
<code>sch:assert</code> or <code>sch:report</code> rules and
patterns. In the example above, the author of the Schematron rule
may want to use this error message in other contexts:</p>
<div class="exampleInner">
<pre>
The specified ID &lt;sch:value-of select="string(u:ID)"/&gt; does not begin with 99.
</pre></div>
<p>Reuse opportunities for this message are limited since the
translated message contains implicit assumptions about the rule
context. To be able to reuse this message more widely, the message
author should substitute a context-independent expression, such as
a variable, in place of the <code>u:ID</code> in
<code>&lt;sch:value-of select="string(u:ID)"/&gt;</code>.</p>
<p>Thus, the original message translations</p>
<div class="exampleInner">
<pre>
StudentIDErrorMsg = L'identifiant specifié &lt;sch:value-of select="string(u:ID)"/&gt; ne commence pas par 99.
StudentIDErrorMsg = Der angegebene Wert des Attributs ID (&lt;sch:value-of  select="string(u:ID)"/&gt;) beginnt nicht mit "99".
</pre></div>
<p>should instead be coded to use a variable's value, as shown
below.</p>
<div class="exampleInner">
<pre>
StudentIDErrorMsg = L'identifiant specifié &lt;sch:value-of select="$studentID"/&gt; ne commence pas par 99.
StudentIDErrorMsg = Der angegebene Wert des Attributs ID (&lt;sch:value-of  select="$studentID"/&gt;) beginnt nicht mit "99".
</pre></div>
<p>The error message in <code>sch:assert</code>, identified by the
<code>lang:StudentIDErrorMsg</code> value, can now be reused in
Schematron rule contexts other than the one described by the sample
above. In cases where variable substitution is used in this way,
the responsibility for setting the variable in the message's
various usage contexts rests with the rule author(s). Specifically,
the Schematron rule used to start the Appendix F portion of this
running example would need to set the value of the
<code>studentID</code> variable. The sample below shows how the
revised translation resources would be referenced from a Schematron
rule.</p>
<div class="exampleInner">
<pre>
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"
            xmlns:lang="http://www.university.example.org/translation/"&gt;
    &lt;sch:ns prefix="u" uri="http://www.university.example.org/ns" /&gt;
    &lt;sch:ns prefix="smlfn" uri="http://www.w3.org/ns/sml-function"/&gt;
    &lt;sch:pattern id="StudentPattern”&gt;
        &lt;sch:rule context="u:Students/u:Student"&gt;
        &lt;sch:let name="studentID" value="u:ID"/&gt;
            &lt;sch:assert test="starts-with(u:ID,'99')"
                        sml:locid="lang:StudentIDErrorMsg"&gt;
                The specified ID &lt;sch:value-of select="$studentID"/&gt; does not begin with 99.
            &lt;/sch:assert&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;
</pre></div>
<p>The error message in <code>sch:assert</code> and the
localization identifier <code>lang:StudentIDErrorMsg</code> can now
be reused in contexts other than
<code>u:Students/u:Student</code>.</p>
<p>If the translated string named by <code>StudentIDErrorMsg</code>
is intended for use only in the context of Schematron elements,
this mechanism is sufficient. If the message is intended for use in
additional contexts, the preceding syntax is not necessarily
sufficient. In order to allow reuse of translated strings
exploiting variable substitution in other contexts, a syntax
understood both inside and outside of Schematron elements is
required. <code>xsl:variable</code> and <code>sch:let</code> are
possible choices, made more practical by SML’s requirement that
validators support the “xslt" query binding for Schematron.
However, there is currently insufficient practical experience to
label this a best practice.</p>
</div>
<div class="div1">
<h2><a name="Acknowledgements" id="Acknowledgements"></a>G.
Acknowledgements (Non-Normative)</h2>
<p>The editors acknowledge the members of the Service Modeling
Language Working Group, the members of other W3C Working Groups,
and industry experts in other forums who have contributed directly
or indirectly to the process or content of creating this
document.</p>
<p>At the time this specification was published, the members of the
Service Modeling Language Working Group were:</p>
<p>John Arwe (IBM Corporation), Len Charest (Microsoft
Corporation), Sandy Gao (IBM Corporation), Paul Lipton (CA), James
Lynn (HP), Kumar Pandit (Microsoft Corporation), Valentina Popescu
(IBM Corporation), Virginia Smith (HP), Henry Thompson (W3C/ERCIM),
David Whiteman (IBM Corporation), Kirk Wilson (CA).</p>
<p>The Service Modeling Language Working Group has benefited in its
work from the participation and contributions of a number of people
not currently members of the Working Group, including in particular
those named below.</p>
<p>Dave Ehnebuske (IBM), Jon Hass (Dell), Steve Jerman (Cisco),
Heather Kreger (IBM), Vincent Kowalski (BMC), Milan Milenkovic
(Intel), Bryan Murray (HP), Phil Prasek (HP), Junaid Saiyed (EMC),
Harm Sluiman (IBM), C. Michael Sperberg-McQueen (W3C/MIT), Bassam
Tabbara (Microsoft), Vijay Tewari (Intel), William Vambenepe (HP),
Marv Waschke (CA), Andrea Westerinen (Microsoft), Pratul Dublish
(Microsoft), Julia McCarthy (IBM).</p>
<p>Affiliations given above are those current at the time of their
work with the working group.</p>
</div>
</div>
</body>
</html>
