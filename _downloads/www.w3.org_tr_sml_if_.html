<!-- http://www.w3.org/TR/sml-if/ -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<meta name="generator" content=
"HTML Tidy for Cygwin (vers 22 March 2008), see www.w3.org" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<title>Service Modeling Language Interchange Format Version
1.1</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

dt.label       { display: run-in; }

li, p           { margin-top: 0.3em;
                 margin-bottom: 0.8em; }

.diff-chg       { background-color: yellow; }
.diff-del       { background-color: red; text-decoration: line-through;}
.diff-add       { background-color: lime; }

table          { empty-cells: show; }

table caption {
        font-weight: normal;
        font-style: italic;
        text-align: left;
        margin-bottom: .5em;
}

div.issue {
  color: red;
}
.rfc2119 {
  font-variant: small-caps;
}
.figure {
  text-align: center;
}
.center {
  text-align: center;
}
.left {
  text-align: left;
}
.red {
  color: red;
}
table.eg {
  color: #99ffff;
}
code.emph {
  font-style: italic;
}

div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
p.exampleHead { text-align: left;}
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-REC.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>Service Modeling Language
Interchange Format Version 1.1</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation
12 May 2009</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2009/REC-sml-if-20090512/">http://www.w3.org/TR/2009/REC-sml-if-20090512/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/sml-if/">http://www.w3.org/TR/sml-if/</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://www.w3.org/TR/2009/PR-sml-if-20090212/">http://www.w3.org/TR/2009/PR-sml-if-20090212/</a></dd>
<dt>Editors:</dt>
<dd>Bhalchandra Pandit, Microsoft Corporation</dd>
<dd>Valentina Popescu, IBM Corporation</dd>
<dd>Virginia Smith, HP</dd>
</dl>
<p>Please refer to the <a href=
"http://www.w3.org/2009/05/sml-errata"><strong>errata</strong></a> for this
document, which may include some normative corrections.</p>
<p>This document is also available in these non-normative formats:
<a href="sml-if.xml">XML</a>.</p>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology="><strong>
translations</strong></a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2009 <a href="http://www.w3.org/"><acronym title=
"World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href=
"http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This specification defines the interchange format for Service
Modeling Language, Version 1.1 (SML) models. This format identifies
the model being interchanged, distinguishes between model
definition documents and model instance documents, and defines the
binding of rule documents with other documents in the interchange
model.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is the 12 May 2009 W3C Recommendation of the Service
Modeling Language Interchange Format Version 1.1 specification.
This document has been developed by the <a href=
"http://www.w3.org/XML/SML/">Service Modeling Language (SML)
Working Group</a>, which is a part of the <a href=
"http://www.w3.org/XML/">Extensible Markup Language (XML)
Activity</a>.</p>
<p>Comments on this document are welcome via the Working Group’s
<a href="mailto:public-sml@w3.org">public mailing list</a>
(<a href="http://lists.w3.org/Archives/Public/public-sml/">public
archive</a>). An <a href=
"http://www.w3.org/XML/SML/SMLPRFeatureImplementationReport.html">implementation
report</a> is available.</p>
<p>The design of SML has been widely reviewed and satisfies the
Working Group's technical requirements. Only minor editorial
changes have been made since the <a href=
"http://www.w3.org/TR/2009/PR-sml-if-20090212/">12 February 2009
Proposed Recommendation</a>.</p>
<p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from
another document. W3C's role in making the Recommendation is to
draw attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/41079/status">public list of any
patent disclosures</a> made in connection with the deliverables of
the group; that page also includes instructions for disclosing a
patent. An individual who has actual knowledge of a patent which
the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1. <a href="#Introduction">Introduction
(Non-Normative)</a><br />
2. <a href="#Notations_and_Terminology">Notations and
Terminology</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href=
"#Notational_Conventions">Notational Conventions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href=
"#Terminology">Terminology</a><br />
3. <a href="#Dependencies">Dependencies on Other
Specifications</a><br />
4. <a href="#Informal_Description">Informal Description
(Non-Normative)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href=
"#Packaging">Packaging</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#URI_References">URI
References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#Rule_Bindings">Rule
Bindings</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="#Schema_Bindings">Schema
Bindings</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href=
"#Interoperability">Interoperability of SML Models</a><br />
5. <a href="#SML-IF_Normative_Definition">SML Interchange Format
Definition</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href=
"#ConformanceClause">Conformance Criteria</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#SML-IF_Documents">SML-IF
Documents</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href=
"#Embedded_Documents">Embedded Documents</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a href=
"#Referenced_Documents">Referenced Documents</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a href=
"#Schema_Completeness">Schema Completeness</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 <a href=
"#smlif_version">SML-IF Document Version</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href=
"#URI_References_Definition">URI References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.1 <a href=
"#URI_equality">URI equality</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.2 <a href=
"#Base_URI">Base URIs</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.2.1
<a href="#smlif_baseuri">smlif:baseURI</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.3 <a href=
"#Document_aliases">Document Aliases</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.4 <a href=
"#URI_Processing">URI Reference Processing</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href="#Document_Bindings">Document
Bindings</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.1 <a href=
"#URI_prefix_matching">URI Prefix Matching</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 <a href=
"#Rule_Bindings_Definition">Rule Bindings</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3 <a href=
"#Schema_Bindings_Definition">Schema Bindings</a><br />
6. <a href="#References">References</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href=
"#Normative_References">Normative</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href=
"#NonNormative_References">Non-Normative</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A. <a href="#SML_IF_Schema">SML-IF Schema</a><br />
B. <a href="#LocalizationSample">Localization of IF Identity
Sample</a> (Non-Normative)<br />
C. <a href="#Acknowledgements">Acknowledgements</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="Introduction" id="Introduction"></a>1. Introduction
(Non-Normative)</h2>
<p>As defined in the Service Modeling Language, Version 1.1 (SML)
Specification [<cite><a href="#SML">SML 1.1</a></cite>] an SML
model is a collection of XML documents that may be used to describe
complex services and systems such as a set of IT resources,
services and their interrelations.</p>
<p>In every SML model there are two distinguished subsets of the
model's documents, the definition documents and the instance
documents. The model's definition documents describe the abstract
structure of the model, and provide much of the information a model
validator needs to decide whether the model, as a whole, is valid.
The model's instance documents describe or support the description
of the individual resources that the model portrays.</p>
<p>The SML Specification identifies two categories of model
definition documents that participate in SML model validation:
Schema documents and rule documents. Schema documents in a model
are XML documents that conform to the [<cite><a href="#SML">SML
1.1</a></cite>] defined extensions to XML Schema [<cite><a href=
"#XSD1">XML Schema Structures</a></cite>, <cite><a href="#XSD2">XML
Schema Datatypes</a></cite>]. Rule documents in a model include XML
documents that conform to the [<cite><a href="#SML">SML
1.1</a></cite>] defined extensions of Schematron [<cite><a href=
"#Schematron">ISO/IEC 19757-3</a></cite>].</p>
<p>To ensure accurate and convenient interchange of the documents
that make up an SML model, it is useful to define both an
implementation-neutral interchange format that preserves the
content and interrelationships among the documents and a
constrained form of SML model validation. For this purpose, this
specification defines a standard format called the SML Interchange
Format (SML-IF) and a process called interchange model
validation.</p>
<p>The specification consists of two parts. The first part is an
informal description of SML-IF to set the context. This is followed
by SML-IF's normative definition.</p>
</div>
<div class="div1">
<h2><a name="Notations_and_Terminology" id=
"Notations_and_Terminology"></a>2. Notations and Terminology</h2>
<div class="div2">
<h3><a name="Notational_Conventions" id=
"Notational_Conventions"></a>2.1 Notational Conventions</h3>
<p>The keywords "<span class="rfc2119">MUST</span>", "<span class=
"rfc2119">MUST NOT</span>", "<span class=
"rfc2119">REQUIRED</span>", "<span class="rfc2119">SHALL</span>",
"<span class="rfc2119">SHALL NOT</span>", "<span class=
"rfc2119">SHOULD</span>", "<span class="rfc2119">SHOULD
NOT</span>", "<span class="rfc2119">RECOMMENDED</span>",
"<span class="rfc2119">MAY</span>", and "<span class=
"rfc2119">OPTIONAL</span>" in this document are to be interpreted
as described in RFC 2119 [<cite><a href="#RFC2119">IETF RFC
2119</a></cite>].</p>
<p>This specification follows the same conventions for schema
components as those used in the XML schema specification
[<cite><a href="#XSD1">XML Schema Structures</a></cite>]. That is,
references to properties of schema components are links to the
relevant definition, set off with curly braces, for instance
{example property}. References to properties of information items
as defined in [<cite><a href="#XMLInfoset">XML Information
Set</a></cite>] are notated as links to the relevant section
thereof, set off with square brackets, for example [children].</p>
<p>The content of this specification is normative except for
sections or texts that are explicitly marked as non-normative. If a
section is marked as non-normative, then all contained sub-sections
are non-normative, even if they are not explicitly marked as such.
All notes are non-normative unless otherwise specified.</p>
</div>
<div class="div2">
<h3><a name="Terminology" id="Terminology"></a>2.2 Terminology</h3>
<p>The following terms are used in this specification. They are
listed here in alphabetical order. This specification also uses
terms defined in the [<cite><a href="#SML">SML 1.1</a></cite>]
specification.</p>
<dl>
<dt class="label"><a name="alias" id="alias"></a>Alias</dt>
<dd>
<p>An <b>alias</b> is a temporary name assigned to a model document
[<cite><a href="#SML">SML 1.1</a></cite>] within the context of an
<a title="" href="#interchange_model">interchange model</a>.</p>
</dd>
<dt class="label"><a name="implementation_defined" id=
"implementation_defined"></a>Implementation-Defined</dt>
<dd>
<p>An <b>implementation-defined</b> feature or behavior may vary
among processors conforming to this specification; the precise
behavior is not specified by this specification but <span class=
"rfc2119">MUST</span> be specified by the implementor for each
particular conforming implementation.</p>
</dd>
<dt class="label"><a name="implementation_dependent" id=
"implementation_dependent"></a>Implementation-Dependent</dt>
<dd>
<p>An <b>implementation-dependent</b> feature or behavior may vary
among processors conforming to this specification; the precise
behavior is not specified by this or any other W3C specification
and is not required to be specified by the implementor for any
particular implementation.</p>
</dd>
<dt class="label"><a name="interchange_model" id=
"interchange_model"></a>Interchange Model</dt>
<dd>
<p>An <b>interchange model</b> is an SML model [<cite><a href=
"#SML">SML 1.1</a></cite>] being interchanged.</p>
</dd>
<dt class="label"><a name="interchange_validation" id=
"interchange_validation"></a>Interchange Model Validation</dt>
<dd>
<p><b>Interchange model validation</b> is the process of performing
SML model validation [<cite><a href="#SML">SML 1.1</a></cite>] on
the interchange model while maintaining all assertions and
interrelationships among the documents in the interchange model as
defined by this specification.</p>
</dd>
<dt class="label"><a name="schema_binding" id=
"schema_binding"></a>Schema Binding</dt>
<dd>
<p>A <b>schema binding</b> is an association of a namespace with a
set of schema documents in the <a title="" href=
"#interchange_model">interchange model</a> and the instance
documents [<cite><a href="#SML">SML 1.1</a></cite>] that should be
validated against this set of schema documents.</p>
</dd>
<dt class="label"><a name="smlif_consumer" id=
"smlif_consumer"></a>SML-IF Consumer</dt>
<dd>
<p>An <b>SML-IF consumer</b> is a program that processes an
<a title="" href="#smlif_document">SML-IF Document</a> using, in
whole or part, semantics defined by this specification. It may or
may not perform <a title="" href=
"#interchange_validation">interchange model validation</a>.</p>
</dd>
<dt class="label"><a name="smlif_document" id=
"smlif_document"></a>SML-IF Document</dt>
<dd>
<p>An <b>SML-IF document</b> is an XML representation of an
<a title="" href="#interchange_model">interchange model</a>. It
includes the model's identity, its documents (by value or by
reference), metadata about its documents, and a syntactic
representation of concepts defined as part of an SML model but
lacking an SML-defined sytnax (e.g. rule bindings).</p>
</dd>
<dt class="label"><a name="smlif_producer" id=
"smlif_producer"></a>SML-IF Producer</dt>
<dd>
<p>An <b>SML-IF producer</b> is a program able to generate an
<a title="" href="#smlif_document">SML-IF Document</a> from an SML
model.</p>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="Dependencies" id="Dependencies"></a>3. Dependencies on
Other Specifications</h2>
<p>Other specifications on which this one depends are listed in
[<cite><a href=
"#Normative_References">Normative_References</a></cite>].</p>
<p>Conforming implementations of this specification MUST support
SML 1.1 [<cite><a href="#SML">SML 1.1</a></cite>], XML 1.0
[<cite><a href="#XML10">XML</a></cite>] and XML Schema 1.0
[<cite><a href="#XSD1">XML Schema Structures</a></cite>,
<cite><a href="#XSD2">XML Schema Datatypes</a></cite>]. Conforming
implementations MAY additionally support later versions of the XML
or XML Schema specifications.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although <a href="http://www.w3.org/TR/sml/#Dependencies">SML
1.1</a> and SML-IF allow conforming implementations to support
newer versions of dependent specifications, there are
interoperability implications to be considered when documents based
on those versions are interchanged using SML-IF. When an SML-IF
document interchanges data built using newer versions of the SML
and SML-IF dependent specifications, consumers of the SML-IF
document not supporting these versions may be unable to interpret
some of the data exchanged by this document.</p>
</div>
</div>
<div class="div1">
<h2><a name="Informal_Description" id="Informal_Description"></a>4.
Informal Description (Non-Normative)</h2>
<p>To represent an SML model in a standard way for interchange, the
following topics need to be addressed.</p>
<p><b>Packaging:</b> The collection of XML documents that make up a
model to be interchanged need to be gathered together. In doing so,
the model definition and model instance documents need to be
distinguished from one another since they play distinct roles in
the model.</p>
<p><b>Explicit references:</b> The documents to be interchanged may
explicitly refer to one another and to documents that are not
packaged with the documents being interchanged. [<cite><a href=
"#SML">SML 1.1</a></cite>] SML references among SML model instance
documents are an obvious example. Less obvious are such references
as certain <code>schemaLocation</code> attributes in schema
documents and <code>xsi:schemaLocation</code> attributes in
instance documents. Section <a href="#Schema_Bindings"><b>4.4
Schema Bindings</b></a> defines how <code>schemaLocation</code> is
processed in these cases.</p>
<p><b>Rule bindings and schema bindings:</b> [<cite><a href=
"#SML">SML 1.1</a></cite>] permits models in which rule documents
apply to all, none, or subsets of the model's documents. SML-IF
specifies how to describe which rule documents apply to which of
the model's documents.</p>
<p><b>Model validation:</b> The process of SML model validation
defined in [<cite><a href="#SML">SML 1.1</a></cite>] contains
points of variability that, left unconstrained, would make it
difficult for SML-IF to ensure interoperability of independent
implementations in any practical way. Many of these sources of
variability are inherited from other specifications that SML uses,
e.g. URI comparison RFC 3986 ([<cite><a href="#RFC3986">IETF RFC
3986</a></cite>]) and the source of Schema components
([<cite><a href="#XSD1">XML Schema Structures</a></cite>]) used to
validate model instance documents. SML-IF constrains these points
of variability, with the goal of ensuring interoperability when
specific conditions are met and of increasing the likelihood of
interoperability in other cases. The enforcement of these
additional constraints on SML model validation occurs during the
process of <a title="" href="#interchange_validation">interchange
model validation</a>.</p>
<div class="div2">
<h3><a name="Packaging" id="Packaging"></a>4.1 Packaging</h3>
<p>An SML-IF document packages a collection of SML model documents
to be interchanged as a single XML document. All SML-IF documents
conform to the XML Schema defined in the normative part of this
specification.</p>
<p>Informally, the structure of SML-IF documents, using the
pseudo-schema notation from WSDL 2.0 [<cite><a href="#WSDL20">WSDL
2.0 Core Language</a></cite>] is as follows:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;model xmlns="http://www.w3.org/ns/sml-if"
       xmlns:xs="http://www.w3.org/2001/XMLSchema"
       SMLIFVersion="xs:token Version number of the SML-IF spec used to generate the current document"
       schemaComplete="xs:boolean"&gt;
    &lt;identity&gt;
        &lt;name&gt;
            xs:anyURI Namespace identifying the model
        &lt;/name&gt;
        &lt;version&gt; ?
            xs:token &lt;!-- The version of this model. E.g., 1.2 or 0.3 --&gt;
        &lt;/version&gt;
        &lt;displayName sml:locid="xs:anyURI URI identifying the translation
                                resource for the display name" ?&gt; ?
            xs:string Descriptive name of model intended for display
        &lt;/displayName&gt;
        &lt;baseURI&gt;
            xs:anyURI &lt;!-- Base URI for relative references defined in the interchange model; 
                           must be an absolute reference --&gt;
        &lt;/baseURI&gt; ?
        &lt;description sml:locid="xs:anyURI URI identifying the translation
                                resource for the description" ?&gt; ?
            xs:string Textual description of model for human consumption
        &lt;/description&gt;
    &lt;/identity&gt;
    &lt;ruleBindings&gt; ?
        &lt;ruleBinding&gt; *
            &lt;documentAlias="xs:anyURI"/&gt; ?
            &lt;ruleAlias="xs:anyURI"/&gt;
        &lt;/ruleBinding&gt;
    &lt;/ruleBindings&gt;
    &lt;schemaBindings&gt; ?
        &lt;defaultSchema&gt; ?
            &lt;namespaceBinding/&gt; *  
        &lt;/defaultSchema&gt;
        &lt;schemaBinding&gt; *
            &lt;namespaceBinding/&gt; *  
            &lt;documentAlias/&gt; *     
        &lt;/schemaBinding&gt;
        &lt;noSchemaBinding&gt; ?
            &lt;documentAlias/&gt; *     
        &lt;/noSchemaBinding&gt;
    &lt;/schemaBindings&gt;
    &lt;definitions&gt; ?
        &lt;document&gt; *
            &lt;docInfo&gt; ?
                    &lt;baseURI&gt; ?
                        xs:anyURI &lt;!-- If a document has a baseURI, then this will be used to form the 
                                       base URI for all relative URIs subject to SML URI processing 
                                       contained by that document. --&gt;            
                    &lt;/baseURI&gt;        
                    &lt;aliases&gt; ?
                        &lt;alias&gt; *
                            xs:anyURI &lt;!-- A URI by which SML references from other documents may refer to this document. --&gt;
                        &lt;/alias&gt;
                    &lt;/aliases&gt;
            &lt;/docInfo&gt;
                [
                &lt;data&gt;
                    xs:any &lt;!-- At most one definition document goes here --&gt;
                &lt;/data&gt;
                |
                &lt;base64Data&gt;
                    xs:any &lt;!-- At most one base64 encoded definition document goes here --&gt;
                &lt;/base64Data&gt;
                |
                &lt;locator&gt;
                    &lt;documentURI/&gt; ?
                        xs:any &lt;!-- A URI or IRI that points to a definition document goes here --&gt;
                &lt;/locator&gt;
                ]
        &lt;/document&gt;
    &lt;/definitions&gt;
    &lt;instances&gt; ?
        &lt;document&gt; *
            &lt;docInfo&gt; ?
                &lt;baseURI&gt; ?
                     xs:anyURI &lt;!-- If a document has a baseURI, then this will be used to form the 
                            base URI for all relative URIs subject to SML URI processing 
                            contained by that document. --&gt;            
                &lt;/baseURI&gt;        
                &lt;aliases&gt; ?
                   &lt;alias&gt; *
                       xs:anyURI &lt;!-- A URI by which SML references from other documents may refer to this document. --&gt;                        
                   &lt;/alias&gt;
                &lt;/aliases&gt;
            &lt;/docInfo&gt;
            [
            &lt;data&gt;
                xs:any&lt;!-- At most one instance document goes here --&gt;
            &lt;/data&gt;
            |
            &lt;base64Data&gt;
                xs:any &lt;!-- At most one base64 encoded instance document goes here --&gt;
            &lt;/base64Data&gt;
            |
            &lt;locator&gt;
                &lt;documentURI/&gt; ?
                    xs:any &lt;!-- A URI or IRI that points to an instance document goes here --&gt;
            &lt;/locator&gt;
            ]
        &lt;/document&gt;
    &lt;/instances&gt;
&lt;/model&gt;
</pre></div>
<p>A document producer can specify the version of the specification
under which the current document was generated, and with which
conformance is claimed, in the <code>SMLIFVerion</code> attribute.
For example, if this version of SML-IF is used as the basis of a
document, the value of this attribute would be the value "1.1".</p>
<p>The <code>identity</code> element provides information
applications can use to identify and describe the set of SML
documents being interchanged. The <code>baseURI</code> child
element is one way to specify a base URI to be used by relative URI
references in the <a title="" href="#interchange_model">interchange
model</a>. Another way to specify a base URI is to use the
<code>document/docInfo/baseURI</code> element. [<a href=
"#Base_URI"><b>5.3.2 Base URIs</b></a>]</p>
<p>The <code>SMLIFVersion</code> attribute is defined on the
<code>model</code> element and may be useful when diagnosing
failures encountered while processing SML-IF documents. For
example, if a document asserts conformance with version 1.1 of the
SML-IF specification and a human can see that it is not in fact
conformant, then it is likely that the problem occurred during the
production of the document. If the same document appears to humans
to be conformant, then the focus of diagnosis might shift toward
the <a title="" href="#smlif_consumer">SML-IF consumer</a> and its
invocation parameters.</p>
<p>The <code>schemaComplete</code> attribute is defined on the
<code>model</code> element and is used to indicate that the schemas
constructed from the definition documents in the interchange model
are complete, in the sense that the validity of the interchanged
SML model is fully determined by these schemas. Formally, however,
the <code>schemaComplete</code> attribute does not express any
assertion that the schemas so constructed are in fact complete, or
that <a title="" href="#interchange_validation">interchange model
validation</a> using these schemas will not result in any errors
indicating that some components are missing from the schemas. The
only formal effect of <code>schemaComplete</code> attribute with a
value of <code>true</code> or <code>1</code> is to specify
precisely the schemas with which interchange model validation is to
be performed.</p>
<p>The optional <code>ruleBindings</code> element is used to
contain information that associates rule documents with the
documents they apply to. See <a href="#Rule_Bindings"><b>4.3 Rule
Bindings</b></a> for further details.</p>
<p>Every document in the <a title="" href=
"#interchange_model">interchange model</a> appears as content of a
<code>document</code> element in either the
<code>definitions</code> or the <code>instances</code> element,
depending on whether the document in question is a model definition
or a model instance document. There can be at most one embedded
document contained by a <code>document/data</code> element. Both
<code>definitions</code> and <code>instances</code> are optional.
So, for example, if there are no model definition documents being
packaged, the <code>definitions</code> element must be omitted.</p>
<p>The first child of each <code>document</code> is typically a
<code>docInfo</code> element that contains a <code>baseURI</code>
element and a list of <code>alias</code> elements. The
<code>baseURI</code> element can be used to specify a base URI for
relative references in the document. Defining base URIs is
specified in <a href="#Base_URI"><b>5.3.2 Base URIs</b></a>. The
content of each <code>alias</code> element is a URI with no
fragment component (i.e., one with no "#" in it). Each of the
<code>alias</code> elements serves as a name that other documents
can use to refer to this document. Examples of how aliases are used
to handle URI references are given in <a href=
"#URI_References"><b>4.2 URI References</b></a>.</p>
<p>A document in the interchange model can be represented in either
of two ways, by embedding its content, or by providing a reference
to it. Which is being used is indicated by the child of the
<code>document</code> element. A document can be embedded as-is or
in a base64 encoded format. In the former case, a <code>data</code>
element is used to contain the actual content of the document
whereas a <code>base64Data</code> element is used for the latter.
The base64 format is typically used for, but is not restricted to,
documents with DTD. If the document is being referenced rather than
embedded, a <code>locator</code> element is used to contain the
reference. The content of a <code>locator</code> can be a
<code>documentURI</code> element defined by SML-IF or anything else
understood by the <a title="" href="#smlif_consumer">SML-IF
consumer</a>.</p>
<p>Although it is not fully shown in the pseudo-schema above, the
SML-IF schema has an "open content model." To provide
extensibility, essentially every element in it can contain
additional content and/or attributes from other XML namespaces.</p>
</div>
<div class="div2">
<h3><a name="URI_References" id="URI_References"></a>4.2 URI
References</h3>
<p>When processing the SML model packaged inside an SML-IF
document, certain URI references (as defined in RFC 3986
[<cite><a href="#RFC3986">IETF RFC 3986</a></cite>]) may need to be
processed to find their corresponding target. For example, in order
to assess SML validity of the interchanged model, SML references
using the SML URI Reference Scheme [<cite><a href="#SML">SML
1.1</a></cite>] need to be resolved. In addition, in order to
assemble schemas from multiple schema documents as part of the
interchange model validity assessment, the schemaLocation attribute
on an <code>xs:include</code> element needs to be processed to
locate the schema document.</p>
<p>To see how these URI references are handled, consider the
following SML-IF document:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;model xmlns="http://www.w3.org/ns/sml-if" version="1.0"&gt;
    &lt;identity&gt;
        &lt;name&gt;http://www.university.example.org/sml/models/Sample/InterDocReferences&lt;/name&gt;
        &lt;baseURI&gt;http://www.university.example.org/Universities/&lt;/baseURI&gt;   
    &lt;/identity&gt;
    &lt;definitions&gt;
        &lt;document&gt;
            &lt;data&gt;
                &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
                    &lt;xs:include schemaLocation="http://www.university.example.org/university/enrollmodel.xsd"/&gt;
                &lt;/xs:schema&gt;     
            &lt;/data&gt;      
        &lt;/document&gt;
    &lt;/definitions&gt;
 
    &lt;instances&gt;
        &lt;document&gt;
            &lt;data&gt;
                &lt;Student xmlns="http://www.university.example.org/ns"
                         xmlns:sml="http://www.w3.org/2007/09/sml"
                         xmlns:u="http://www.university.example.org/ns"&gt;
                    &lt;ID&gt;1000&lt;/ID&gt;
                    &lt;Name&gt;John Doe&lt;/Name&gt;
                    &lt;EnrolledCourses&gt;
                        &lt;EnrolledCourse sml:ref="true"&gt;
                            &lt;!-- SML Reference to a course INside the interchange model --&gt;                                     
                            &lt;sml:uri&gt;
                                http://www.university.example.org/Universities/MIT/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='PHY101'])
                            &lt;/sml:uri&gt;
                        &lt;/EnrolledCourse&gt;
                        &lt;EnrolledCourse sml:ref="true"&gt;
                            &lt;!-- SML Reference to a course INside the interchange model --&gt;                        
                            &lt;sml:uri&gt;
                                http://www.university.example.org/Universities/SFU/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='MUSIC205'])
                            &lt;/sml:uri&gt;
                        &lt;/EnrolledCourse&gt;           
                        &lt;EnrolledCourse sml:ref="true"&gt;
                            &lt;!-- SML Reference to a course OUTside the interchange model --&gt;                        
                            &lt;sml:uri&gt;
                                http://www.university.example.org/Universities/Capella/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='LIT103'])
                            &lt;/sml:uri&gt;
                        &lt;/EnrolledCourse&gt;
                    &lt;/EnrolledCourses&gt;
                &lt;/Student&gt;
            &lt;/data&gt;
        &lt;/document&gt;
        &lt;document&gt;
            &lt;!-- The following alias matches the first course referenced above --&gt;
            &lt;docInfo&gt;
                &lt;aliases&gt;
                    &lt;alias&gt;http://www.university.example.org/Universities/MIT/Courses.xml&lt;/alias&gt;
                &lt;/aliases&gt;
            &lt;/docInfo&gt;
            &lt;data&gt;
                &lt;Courses xmlns="http://www.university.example.org/ns"&gt;
                    &lt;Course&gt;
                        &lt;Name&gt;PHY101&lt;/Name&gt;
                    &lt;/Course&gt;
                    &lt;Course&gt;
                        &lt;Name&gt;MAT200&lt;/Name&gt;
                    &lt;/Course&gt;
                &lt;/Courses&gt;
            &lt;/data&gt;
        &lt;/document&gt;
        &lt;document&gt;
            &lt;docInfo&gt;
                &lt;baseURI&gt;SFU/Courses.xml&lt;/baseURI&gt;
                    &lt;!-- The following alias matches the second course referenced above (after
                    being converted to an absolute URI)  --&gt;
                &lt;/aliases&gt;
                    &lt;alias&gt;SFU/Courses.xml&lt;/alias&gt;
                &lt;/aliases&gt;
            &lt;/docInfo&gt;
            &lt;data&gt;
                &lt;Courses xmlns="http://www.university.example.org/ns"&gt;
                    &lt;Course&gt;
                        &lt;Name&gt;ENG106&lt;/Name&gt;
                    &lt;/Course&gt;
                    &lt;Course&gt;
                        &lt;Name&gt;MUSIC205&lt;/Name&gt;
                    &lt;/Course&gt;
                &lt;/Courses&gt;
            &lt;/data&gt;
        &lt;/document&gt;   
    &lt;/instances&gt;
&lt;/model&gt;
</pre></div>
<p>When not packaged in an SML-IF document, certain URI references
(e.g. values of <code>sml:uri</code> elements or certain
<code>schemaLocation</code> attributes) are dereferenced to find
their corresponding document. When these references are packaged in
an SML-IF document, consumers of the SML-IF document need to first
examine whether the target document or element is packaged in the
same SML-IF document. To determine this, the fragment component, if
any, is temporarily ignored to form a URI. This URI is then
compared against the <code>alias</code> URIs of packaged model
documents.</p>
<p>If the URI is equal to the URI in an <code>alias</code> element
(see <a href="#URI_equality"><b>5.3.1 URI equality</b></a>), the
<a title="" href="#smlif_consumer">SML-IF consumer</a> will not
attempt to look for targets of this URI outside of the SML-IF
document, although there may exist a document retrievable at this
URI. If the URI is not equal to the URI in any <code>alias</code>
element, then the SML-IF document does not contain the
corresponding target of the original URI reference. The consumer
may or may not attempt to look for targets outside of the SML-IF
document, depending on the nature of the URI reference. Formal
rules about how URI references are processed are defined in section
<a href="#URI_Processing"><b>5.3.4 URI Reference
Processing</b></a>.</p>
<p>Several examples of resolving references can be seen in the
example SML-IF document shown above, illustrating the use of both
relative and absolute alias URI values. In the first example, a
reference with an absolute URI, the following SML reference, must
first be separated into its document URI and fragment
components:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/MIT/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='PHY101'])
</pre></div>
<p>After removing the fragment, the document portion of the
reference is:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/MIT/Courses.xml
</pre></div>
<p>This document URI is equal to the URI listed in an
<code>alias</code> accompanying the <code>Courses</code> document.
So, by applying the fragment in the URI reference to the
<code>Courses</code> document, we determine that the reference is
to the <code>Course</code> element whose <code>Name</code> element
has <code>"PHY101"</code> as its content.</p>
<p>The second example reference, using a relative URI, is processed
similarly. The full reference is:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/SFU/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='MUSIC205'])
</pre></div>
<p>After removing the fragment, the document portion of the
reference is:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/SFU/Courses.xml
</pre></div>
<p>This URI is equal to an <code>alias</code> defined on the last
instance document in the interchange model, after the
<code>model/identity/baseURI</code> content is applied to the
relative URI contained by the document’s <code>alias</code>
element. So, by applying the fragment in the reference to the
<code>Courses</code> document, we determine that the reference is
to the <code>Course</code> element whose <code>Name</code> element
has <code>"MUSIC205"</code> as its content.</p>
<p>The third example, showing an unresolved reference, is processed
similarly. The full reference is:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/Capella/Courses.xml#smlxpath1(/u:Courses/u:Course[u:Name='LIT103'])
</pre></div>
<p>After removing the fragment, the document portion of the
reference is:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/Universities/Capella/Courses.xml
</pre></div>
<p>This document URI is not equal to the URI in any
<code>alias</code> element. This means that it is an unresolved SML
reference.</p>
<p>The URI:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/university/enrollmodel.xsd 
</pre></div>
<p>(value of the <code>schemaLocation</code> attribute on the
<code>include</code> element) is not equal to any
<code>alias</code>. The <a title="" href="#smlif_consumer">SML-IF
consumer</a> may or may not attempt to locate a schema document
using this URI reference.</p>
</div>
<div class="div2">
<h3><a name="Rule_Bindings" id="Rule_Bindings"></a>4.3 Rule
Bindings</h3>
<p>[<cite><a href="#SML">SML 1.1</a></cite>] uses Schematron
patterns embedded in SML schemas and in separate explicitly bound
rule documents to express constraints that cannot be expressed in
XML Schemas. Schematron patterns embedded in SML Schema documents
all have well defined targets. [<cite><a href="#SML">SML
1.1</a></cite>] permits models in which rule documents apply to
all, none, or subsets of the model's documents. SML-IF uses the
list of <code>ruleBinding</code> elements contained in the optional
<code>ruleBindings</code> element to associate rule documents with
the documents in the interchange model to which they apply. Each
<code>ruleBinding</code> associates the documents having an alias
beginning with the URI prefix given in the
<code>documentAlias</code> with the rule documents having an alias
beginning with the prefix given in the <code>ruleAlias</code>. So,
for example, the <code>ruleBinding</code>:</p>
<div class="exampleInner">
<pre>
&lt;ruleBinding&gt;
    &lt;documentAlias="http://www.university.example.org/sml/infrastructure/"/&gt;
    &lt;ruleAlias="http://www.university.example.org/sml/infrastructurerules/"/&gt;
&lt;/ruleBinding&gt;
</pre></div>
<p>Would associate documents that have the aliases such as:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/sml/infrastructure/server427.xml
</pre></div>
<p>and</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/sml/infrastructure/switch6E.xml
</pre></div>
<p>with rule documents that have aliases such as:</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/sml/infrastructurerules/assetistracked.sch
</pre></div>
<p>and</p>
<div class="exampleInner">
<pre>
http://www.university.example.org/sml/infrastructurerules/managedbycorporate.sch
</pre></div>
<p>SML-IF specifies rule bindings among documents in the
interchange model. It does not specify rule bindings that apply to
documents not in the interchange model. That said, it is often the
case that the intent of transferring an SML-IF document is to
relate its contents with other SML documents not in the interchange
model. For example, the intent might be to merge the interchange
model with an existing SML model. In such cases the context of use
may choose to extend the definition of <code>ruleBinding</code> to
bind documents not in the interchange model. For example, if the
interchange model is merged into an existing model, the merge
process might choose to extend the definition of
<code>ruleBinding</code> elements to bind rule documents in the
interchange model to documents in the merged model that weren't
included in the interchange model.</p>
</div>
<div class="div2">
<h3><a name="Schema_Bindings" id="Schema_Bindings"></a>4.4 Schema
Bindings</h3>
<p>Schema documents can be connected with other schema documents
using composition features provided by XML Schema. This includes
<code>xs:include</code>, <code>xs:redefine</code>, and
<code>xs:import</code>. A schema document's validity may depend on
other schema documents it includes/redefines/imports, or even other
schema documents that include/redefine/import it. When performing
<a title="" href="#interchange_validation">interchange model
validation</a> over the SML model packaged in an SML-IF instance,
an SML-IF consumer must draw associations between XML Schema
definition documents and instance documents, both to completely
validate XML Schema documents themselves and to establish the
schema-validity of the instance documents.</p>
<p>The XML Schema specification provides more flexibility in
constructing the schema used for assessment than is appropriate for
the semantics defined by SML and SML-IF for <a title="" href=
"#interchange_validation">interchange model validation.</a></p>
<ol class="enumar">
<li>
<p>It allows XML Schema processors latitude in terms of locating
schema documents (resolving namespace and schema location
attributes) and composing schema documents together to form a
single schema.</p>
</li>
<li>
<p>Schema location attributes can be ignored in some cases
(<code>xsi:schemaLocation</code> in instance documents and
<code>schemaLocation</code> attribute on <code>xs:import</code>)
and allowed to "fail to resolve" in others
(<code>schemaLocation</code> attribute on <code>xs:include</code>
and <code>xs:import</code>).</p>
</li>
<li>
<p>Multiple imports of the same namespace allow all but the first
one to be ignored.</p>
</li>
</ol>
<p>As a result, SML-IF cannot guarantee general case
interoperability based only on XML Schema and, therefore, needs to
specify how to determine such associations. This section describes
a method to achieve this goal.</p>
<p>An SML-IF document can be:</p>
<ol class="enumar">
<li>
<p><b>Schema-complete</b> - All schema documents are included in
the SML-IF document, either as an <a href=
"#Embedded_Documents"><b>5.2.1 Embedded Documents</b></a> or as
<a href="#Referenced_Documents"><b>5.2.2 Referenced
Documents</b></a>.</p>
</li>
<li>
<p><b>Schema-incomplete</b> - Some required schema documents may
not be included in the SML-IF document, either as an embedded
document or a referenced document.</p>
</li>
</ol>
<p>It is necessary for an SML-IF producer to declaratively
distinguish between these two cases because making that distinction
is not always possible for an <a title="" href=
"#smlif_consumer">SML-IF consumer</a> based on the content alone.
SML-IF uses the <code>schemaComplete</code> attribute on the
<code>model</code> element to indicate whether this SML-IF document
includes all necessary schema definition documents. When this
attribute is specified with a value of "true", then the schema
validity of the schema definition documents and instance documents
depend only on built-in components or components from definition
documents included in the SML-IF document. Built-in components
include:</p>
<ol class="enumar">
<li>
<p>four xsi: attributes (defined by XML Schema)</p>
</li>
<li>
<p>all schema built-in types (xs:anyType and simple types defined
in XML Schema Part 2)</p>
</li>
<li>
<p>sml:ref attribute declaration</p>
</li>
<li>
<p>sml:uri element declaration</p>
</li>
</ol>
<p>An SML model represented by a schema-incomplete SML-IF document
is not necessarily invalid. However, SML-IF cannot guarantee
interoperability for a schema-incomplete SML-IF document.</p>
<p>SML-IF uses a list of <code>schemaBinding</code> elements
contained in the optional <code>schemaBindings</code> element to
associate a namespace with a set of schema documents in the
interchange model and the instance documents that should be
validated against this set of schema documents. Each
<code>namespaceBinding</code> child of a <code>schemaBinding</code>
element associates the namespace specified in its
<code>namespace</code> attribute with the schema documents whose
aliases are specified in its <code>aliases</code> attribute. In
addition, the instance documents that are to be assessed against
this set of schemas are specified in the <code>documentAlias</code>
child element of the same <code>schemaBinding</code> element.</p>
<p>The following example illustrates schema bindings.</p>
<div class="exampleInner">
<pre>
&lt;schemaBindings&gt;
    &lt;!-- Each "schemaBinding" element corresponds to a schema and model
         instance documents that are assessed against this schema --&gt;
    &lt;schemaBinding&gt;
        &lt;!-- all "namespaceBinding" children together build the schema --&gt;
        &lt;namespaceBinding namespace="ns1" aliases="xsd1-a xsd1-b"/&gt;
        &lt;namespaceBinding namespace="ns2" aliases="xsd2-v1"/&gt;
        &lt;!-- list all applicable instances; same as for rule bindings --&gt;
        &lt;documentAlias&gt;doc1&lt;/documentAlias&gt;
        &lt;documentAlias&gt;doc2-v1-a&lt;/documentAlias&gt;
        &lt;documentAlias&gt;doc2-v1-b&lt;/documentAlias&gt;
    &lt;/schemaBinding&gt;
    &lt;schemaBinding&gt;
        &lt;namespaceBinding namespace="ns1" aliases="xsd1-a xsd1-b"/&gt;
        &lt;namespaceBinding namespace="ns2" aliases="xsd2-v2"/&gt;
        &lt;documentAlias&gt;doc1&lt;/documentAlias&gt;
        &lt;documentAlias&gt;doc2-v2&lt;/documentAlias&gt;
    &lt;/schemaBinding&gt;
&lt;/schemaBindings&gt;
&lt;definitions&gt;
    &lt;!-- schema documents for xsd1-a, xsd1-b, xsd2-v1, xsd2-v2 --&gt;
&lt;/definitions&gt;
</pre></div>
<p>There are cases where many instance documents use the same
schema. In this case, it is desirable to have a default schema
binding rather than specifying a <code>schemaBinding</code> that
lists all these instance documents. The <code>defaultSchema</code>
can be used to cover instance documents not included in any
other<code>schemaBinding</code> as in the following example.</p>
<div class="exampleInner">
<pre>
&lt;schemaBindings&gt;
    &lt;!-- The "defaultSchema" element corresponds to a schema that governs
         all instance documents *not* included in any "schemaBinding". --&gt;
    &lt;defaultSchema&gt;
        &lt;!-- all "namespaceBinding" children together build the schema --&gt;
        &lt;namespaceBinding namespace="ns1" aliases="ns1.xsd"/&gt;
        &lt;namespaceBinding namespace="ns2" aliases="ns2.xsd"/&gt;
    &lt;/defaultSchema&gt;
&lt;/schemaBindings&gt;
</pre></div>
<p>There may be cases where an instance document should not be
bound to any schema, including the default schema. The
<code>noSchemaBinding</code> element can be used in this case to
cover such instance documents as in the following example.</p>
<div class="exampleInner">
<pre>
&lt;schemaBindings&gt;
    &lt;!-- The "noSchemaBinding" element contains the aliases for 
         all instance documents *not* bound to any schema. --&gt;
    &lt;noSchemaBinding&gt;
        &lt;documentAlias&gt;doc-a&lt;/documentAlias&gt;
        &lt;documentAlias&gt;doc-b&lt;/documentAlias&gt;
    &lt;/noSchemaBinding&gt;
&lt;/schemaBindings&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="Interoperability" id="Interoperability"></a>4.5
Interoperability of SML Models</h3>
<p>The goal of SML-IF is to enable the exchange of SML models.
However, this interoperability goal is affected by several aspects
of SML models.</p>
<ol class="enumar">
<li>
<p>Use of the SML URI Reference Scheme as defined in the SML
specification is the only guaranteed way of achieving
interoperability for all SML references in the model. Use of any
other reference scheme requires that the <a title="" href=
"#smlif_consumer">SML-IF consumer</a> know about its use in the
document and understand how to dereference it.</p>
</li>
<li>
<p>SML documents can be included by reference using the
<code>locator</code> element and, therefore, are not directly
embedded in the SML-IF document. This can be very useful,
especially when the SML-IF document is large or when the documents
are readily accessible to the consumer. However, the
<code>locator</code> element may be ignored by the consumer, may
not resolve, or may resolve to different resources in different
contexts. Because of these uncertainties, interoperability is not
guaranteed when documents are included by reference.</p>
</li>
<li>
<p>The SML-IF document may be schema-incomplete [<a href=
"#Schema_Bindings"><b>4.4 Schema Bindings</b></a>]. An SML model
represented by a schema-incomplete SML-IF document is not
necessarily invalid. However, SML-IF cannot guarantee
interoperability for a schema-incomplete SML-IF document.</p>
</li>
<li>
<p>The SML-IF document may use reference schemes that do not use
target-complete identifiers. In addition to the requirements
imposed by SML on reference scheme definitions, SML-IF imposes
additional requirements on references schemes that do not use
target-complete identifiers in order to make them useful in the
context of SML-IF [<a href="#URI_Processing"><b>5.3.4 URI Reference
Processing</b></a>].</p>
</li>
<li>
<p>The presence of relative references subject to SML-IF URI
processing introduces the necessity to transform them into absolute
references [<a href="#URI_Processing"><b>5.3.4 URI Reference
Processing</b></a>]. SML-IF provides two alternative mechanisms
[<a href="#Base_URI"><b>5.3.2 Base URIs</b></a>] for doing so, one
of which is deprecated. SML-IF producers can construct SML-IF
documents that use either only absolute URIs or both base URI
mechanisms in order to achieve interoperability with the maximum
number of consumers.</p>
</li>
</ol>
</div>
</div>
<div class="div1">
<h2><a name="SML-IF_Normative_Definition" id=
"SML-IF_Normative_Definition"></a>5. SML Interchange Format
Definition</h2>
<p>This section normatively defines the Service Modeling Language
Interchange Format (SML-IF). It defines the requirements that
SML-IF documents must adhere to and how URI references contained in
them are to be interpreted by consumers of SML-IF documents.</p>
<div class="div2">
<h3><a name="ConformanceClause" id="ConformanceClause"></a>5.1
Conformance Criteria</h3>
<p>SML-IF defines two levels of conformance for SML-IF
Documents:</p>
<ol class="enumar">
<li>
<p>Minimal Conformance: A <em>minimally conforming SML-IF
Document</em> <span class="rfc2119">MUST</span> adhere to all
SML-IF document requirements as described in the normative sections
of this specification.</p>
</li>
<li>
<p>Reference Conformance: A <em>referentially conforming SML-IF
Document</em> <span class="rfc2119">MUST</span> adhere to all
SML-IF document requirements as described in the normative sections
of this specification. In addition, each non-null SML reference in
the document <span class="rfc2119">MUST</span> be an instance of
the SML URI Reference Scheme [<cite><a href="#SML">SML
1.1</a></cite>].</p>
</li>
</ol>
<p>A <em>conforming SML-IF Producer</em> <span class=
"rfc2119">MUST</span> be able to generate a referentially
conforming SML-IF Document from a conforming SML model.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When a producer generates a referentially conforming SML-IF
document from a conforming source model, it is expected that the
source model and the generated model are equivalent. That is, the
source model and the destination model both have the same validity,
same number of documents with similar structure and content
differing only in places where references are updated to have
equivalent SML URI scheme representation. However, this
specification does not normatively define the notion of model
equivalence.</p>
</div>
<p>A <em>conforming SML-IF Consumer</em> <span class=
"rfc2119">MUST</span> process a conforming SML-IF Document using,
in whole or part, semantics defined by this specification. It is
<span class="rfc2119">OPTIONAL</span> that a conforming SML-IF
Consumer process all elements defined in this specification, but
any element that is processed <span class="rfc2119">MUST</span> be
processed according to the requirements stated in the normative
sections of this specification. In particular, if a conforming
SML-IF Consumer performs <a title="" href=
"#interchange_validation">interchange model validation</a>, then
that process <span class="rfc2119">MUST</span> be performed as
described in this specification.</p>
</div>
<div class="div2">
<h3><a name="SML-IF_Documents" id="SML-IF_Documents"></a>5.2 SML-IF
Documents</h3>
<p>The purpose of SML-IF is to package the set of documents that
constitute an SML model into a standard format so that it can be
exchanged in a standard way.</p>
<p>An SML-IF document <span class="rfc2119">MUST</span> be a
well-formed XML document [<cite><a href=
"#XML10">XML</a></cite>].</p>
<p>An SML-IF document <span class="rfc2119">MUST</span> be valid
under the XML Schema given in Appendix A.</p>
<p>The definition and instance documents packaged by an SML-IF
document <span class="rfc2119">MAY</span> form a valid SML model
but it is not required to do so.</p>
<p>Each document in the interchange model <span class=
"rfc2119">MUST</span> be represented in the SML-IF document by a
separate <code>document</code> element as follows:</p>
<ol class="enumar">
<li>
<p>Each definition document in the interchange model <span class=
"rfc2119">MUST</span> appear as a descendant of a
<code>model/definitions/document</code> element. The order of the
<code>document</code> children is not significant.</p>
</li>
<li>
<p>Each instance document in the interchange model <span class=
"rfc2119">MUST</span> appear as a descendant of a
<code>model/instances/document</code> element. The order of the
<code>document</code> children is not significant.</p>
</li>
</ol>
<p>Each document in the interchange model <span class=
"rfc2119">MUST</span> be included in the SML-IF document either as
an embedded document (where the document to be included is embedded
in the SML-IF document) or by including a reference to the
document.</p>
<div class="div3">
<h4><a name="Embedded_Documents" id="Embedded_Documents"></a>5.2.1
Embedded Documents</h4>
<p>Documents that are to be embedded in the SML-IF document
<span class="rfc2119">MUST</span> be embedded as text or in an
encoded format as follows:</p>
<ol class="enumar">
<li>
<p>If the document is embedded as text, it <span class=
"rfc2119">MUST</span> be included as the content of a
<code>model/definitions/document/data</code> element if it is a
definition document or a <code>model/instances/document/data</code>
element if it is an instance document. Each
<code>model/*/document/data</code> element <span class=
"rfc2119">MUST</span> contain at most one document.</p>
</li>
<li>
<p>If the document is embedded in an encoded format, then the octet
stream representing the document <span class="rfc2119">MUST</span>
be encoded in base64 format. The resultant data stream <span class=
"rfc2119">MUST</span> be embedded as the content of a
<code>model/definitions/document/base64Data</code> element if it is
a definition document or a
<code>model/instances/document/base64Data</code> element if it is
an instance document. Each <code>model/*/document/base64Data</code>
element <span class="rfc2119">MUST</span> contain at most one
document. Documents that contain a DTD <span class=
"rfc2119">MUST</span> be embedded in this encoded format.</p>
</li>
</ol>
<p>When extracting an embedded document that is contained in a
<code>base64Data</code> element, an SML-IF consumer <span class=
"rfc2119">MUST</span> decode the content of the
<code>base64Data</code> element first and then process the
resulting document as an embedded instance document. All embedded
instance documents not encoded in base64 <span class=
"rfc2119">MUST</span> be processed as if they contained the same
DTD as the one associated with the SML-IF document.</p>
<p>If the <code>model/*/document/data</code> element has no child
element, then an SML-IF consumer <span class="rfc2119">MUST</span>
treat the document as if it is not part of the interchange model.
If the <code>model/*/document/base64Data</code> element has a
zero-length sequence of octets as its value, then an SML-IF
consumer <span class="rfc2119">MUST</span> treat the document as if
it is not part of the interchange model.</p>
</div>
<div class="div3">
<h4><a name="Referenced_Documents" id=
"Referenced_Documents"></a>5.2.2 Referenced Documents</h4>
<p>Documents that are to be referenced rather than embedded
<span class="rfc2119">MUST</span> be included as follows:</p>
<ol class="enumar">
<li>
<p>If the document is a definition document, the location of the
document <span class="rfc2119">MUST</span> be included as the
content of a <code>model/definitions/document/locator</code>
element.</p>
</li>
<li>
<p>If the document is an instance document, the location of the
document <span class="rfc2119">MUST</span> be included as the
content of a <code>model/instances/document/locator</code>
element.</p>
</li>
</ol>
<p>SML-IF specifies one way that <span class="rfc2119">MAY</span>
be used to provide the location of the referenced document, the
<code>documentURI</code> element. It is a consequence of
<code>documentURI</code> schema definition that it contains a URI
reference, i.e., it may be an absolute URI or relative reference.
When it is a relative reference, the [base URI] property SHOULD be
used to transform it to an absolute URI, as stated in [<a href=
"#Base_URI"><b>5.3.2 Base URIs</b></a>].</p>
<p>An SML-IF consumer <span class="rfc2119">MAY</span> choose to
locate a referenced document. If an SML-IF consumer chooses not to
locate a referenced document or if it attempts to locate the
referenced document and this attempt fails, then the SML-IF
consumer <span class="rfc2119">MUST</span> treat the referenced
document as if it is not part of the <a title="" href=
"#interchange_model">interchange model</a>. If either of these
conditions occurs, the SML-IF consumer <span class=
"rfc2119">SHOULD</span> make its invoker aware of this
condition.</p>
</div>
<div class="div3">
<h4><a name="Schema_Completeness" id=
"Schema_Completeness"></a>5.2.3 Schema Completeness</h4>
<p>The <code>smlif:schemaComplete</code> attribute is defined on
the <code>model</code> element. The attribute indicates whether or
not all the definition documents required for <a title="" href=
"#interchange_validation">interchange model validation</a> are
included in the <a title="" href="#interchange_model">interchange
model</a>.</p>
<p>If <code>schemaComplete</code> has the value <code>true</code>
or <code>1</code>, then schemas used for interchange model
validation <span class="rfc2119">MUST</span> contain only schema
components declared in built-in components or in model definition
documents within the interchange model. If
<code>schemaComplete</code> has the value <code>false</code> or
<code>0</code>, then this specification does not constrain whether
or not definition documents required for interchange model
validation are retrieved from outside the interchange model.</p>
</div>
<div class="div3">
<h4><a name="smlif_version" id="smlif_version"></a>5.2.4 SML-IF
Document Version</h4>
<p>An SML-IF producer <span class="rfc2119">MAY</span> specify the
version of the SML-IF specification with which conformance is
declared by including the version number of the relevant
specification as the value of the <code>SMLIFVersion</code>
attribute in the document's <code>model</code> element. This value
<span class="rfc2119">MUST</span> be <code>"1.1"</code> for
documents declared by the producer to conform to the SML-IF 1.1
specification. SML-IF Consumers <span class="rfc2119">MUST</span>
attempt to process an SML-IF document regardless of the value of
the <code>SMLIFVersion</code> attribute. That is, an SML-IF
Consumer <span class="rfc2119">MUST NOT</span> reject the document
solely because of the value of the <code>SMLIFVersion</code>
attribute.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Requiring <a title="" href="#smlif_consumer">SML-IF
consumers</a> to continue processing in the face of unknown version
values makes it easier to deploy documents that support future
versions of this specification.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="URI_References_Definition" id=
"URI_References_Definition"></a>5.3 URI References</h3>
<div class="div3">
<h4><a name="URI_equality" id="URI_equality"></a>5.3.1 URI
equality</h4>
<p>SML-IF uses URI equality extensively to handle references among
documents in the interchange model. To determine whether two URIs
are equal, <a title="" href="#smlif_consumer">SML-IF consumers</a>
<span class="rfc2119">MUST</span> perform case sensitive
codepoint-by-codepoint comparison of the corresponding characters
in the URI references.</p>
</div>
<div class="div3">
<h4><a name="Base_URI" id="Base_URI"></a>5.3.2 Base URIs</h4>
<p>If a document in the interchange model contains a relative
reference subject to SML-IF URI processing (see <a href=
"#URI_Processing"><b>5.3.4 URI Reference Processing</b></a>), then
the base URI used to transform the relative URI reference into an
absolute URI is the value of its [base URI] property according to
the rules in section 4.3 of <cite><a href="#XMLBase">XML
Base</a></cite>. When a base URI is needed to transform a relative
reference, then the information necessary to calculate the [base
URI] property <span class="rfc2119">MUST</span> be embedded within
the SML-IF document’s content using at least one of the following
mechanisms.</p>
<ol class="enumar">
<li>
<p>The base URI is embedded using the <code>xml:base</code>
attribute according to <cite><a href="#XMLBase">XML
Base</a></cite>. The value of an element's [base URI] property is
calculated according to <cite><a href="#XMLBase">XML
Base</a></cite>.</p>
</li>
<li>
<p>The base URI is embedded using the <code>smlif:baseURI</code>
element as described in <a href="#smlif_baseuri"><b>5.3.2.1
smlif:baseURI</b></a>. The value of an element's [base URI]
property is calculated as described in that section.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because this specification requires that the base URI
information be embedded in the document content, it follows that an
element’s [base URI] will never be computed from the URI of the
document entity or external entity (see section 4.2 of
<cite><a href="#XMLBase">XML Base</a></cite>) containing the
element.</p>
</div>
<p><a title="" href="#smlif_consumer">SML-IF consumers</a>
<span class="rfc2119">MUST</span> support at least one of these
mechanisms. The selection of which base URI mechanism(s) a
consumer’s implementation supports is implementation-defined, i.e.
it might be done as a fixed coding choice, as a run-time parameter,
by scanning the content, or through any other means. <a title=""
href="#smlif_producer">SML-IF producers</a> <span class=
"rfc2119">MUST</span> support <code>xml:base</code> and
<span class="rfc2119">MAY</span> support
<code>smlif:baseURI</code>.</p>
<p>If an SML-IF consumer supports both mechanisms and the
interchange model document it is consuming contains markup for both
mechanisms, then the SML-IF consumer <span class=
"rfc2119">MUST</span> use the [base URI] value calculated using the
<code>xml:base</code> mechanism.</p>
<p>All of the base URI mechanisms used in each interchange model
document <span class="rfc2119">MUST</span> be used consistently. In
other words, all of the base URI mechanisms whose markup appears in
the document <span class="rfc2119">MUST</span> result in the s ame
[base URI] value being calculated for each relative reference
subject to SML-IF URI processing. SML-IF consumers <span class=
"rfc2119">MAY</span> check this consistency.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As a consequence of the granularity of the consistency
requirement, a single SML-IF document may use different mechanisms
in distinct interchange model documents. In this scenario, it is
true that only consumers that support all mechanisms used would be
able to process the entire SML-IF document correctly.</p>
<p>Consistency checking of base URI results by SML-IF consumers is
made optional to avoid requiring the potential overhead of
performing twice as many calculations per relative reference as is
minimally required to consume the model. An SML-IF consumer might
choose to check base URI mechanism consistency based on input
parameters, always, never, or based on any other criteria it
chooses. If both base URI mechanisms are used in a given
interchange model document contained within a conforming SML-IF
document, and a consumer understands both mechanisms, such a
consumer must use the xml:base mechanism to compute the [base URI]
property. This consumer may choose to ignore the smlif:baseURI
information or it may choose to verify that consistent results are
obtained from both mechanisms. If both base URI mechanisms are used
in a given interchange model document contained within a
non-conforming SML-IF document, SML-IF provides no guarantees about
the consistency of any [base URI] property computed using both
mechanisms.</p>
<p>SML-IF producers have several combinations to consider when
defining base URIs in an SML-IF document:</p>
<ol class="enumar">
<li>
<p>When the interchange model contains no relative URI references
subject to SML-IF URI processing, neither <code>xml:base</code> nor
<code>smlif:baseURI</code> is necessary.</p>
</li>
<li>
<p>When relative URI references subject to SML-IF URI processing
exist in the interchange model and all require the same base URI
value, providing an <code>xml:base</code> or
<code>smlif:baseURI</code> value for the model element is
sufficient.</p>
</li>
<li>
<p>When relative URI references subject to SML-IF URI processing
exist in the interchange model and they require different base URI
values, a combination of <code>xml:base</code> values or a
combination of <code>smlif:baseURI</code> values can be used to
ensure each document has the correct base URI.</p>
</li>
<li>
<p>When relative URI references subject to SML-IF URI processing
exist within the same SML model document and they require different
base URI values, <code>xml:base</code> can be used within the
document to ensure that each relative URI has the correct base
URI.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="smlif_baseuri" id="smlif_baseuri"></a>5.3.2.1
smlif:baseURI</h5>
<p>This syntax is supported in this version of the SML-IF
specification for compatibility with existing SML-IF documents. It
is, however, deprecated and may be removed in a future version of
this specification.</p>
<p>In the <code>smlif:baseURI</code> mechanism, two base URI values
values are used to compute the value of an element’s [base URI]
property, which is then used to resolve relative URI references
defined in the interchange model that are subject to SML-IF URI
processing (see <a href="#URI_Processing"><b>5.3.4 URI Reference
Processing</b></a>).</p>
<dl>
<dt class="label"><a name="interchange_baseURI" id=
"interchange_baseURI"></a>Interchange model base URI</dt>
<dd>
<p>A URI reference that complies with the “absolute-URI” production
as defined in RFC 3986 ([<cite><a href="#RFC3986">IETF RFC
3986</a></cite>]). The value of the <b>interchange model base
URI</b> is the content of the <code>/model/identity/baseURI</code>
element, if any.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is roughly equivalent to specifying the same value in an
<code>xml:base</code> attribute on the /model element.</p>
</div>
</dd>
<dt class="label"><a name="document_baseURI" id=
"document_baseURI"></a>Document base URI</dt>
<dd>
<p>A URI reference that complies with the “absolute-URI” production
as defined in RFC 3986 ([<cite><a href="#RFC3986">IETF RFC
3986</a></cite>]). Each document in the interchange model has a
document base URI whose value is a computed value.</p>
</dd>
</dl>
<p>For each document in the interchange model, the value of the
<a title="" href="#document_baseURI">document base URI</a> is
computed as follows:</p>
<ol class="enumar">
<li>
<p>If the document has a <code>docInfo/baseURI</code> element, let
<b>U</b> be its value.</p>
<ol class="enumla">
<li>
<p>If <b>U</b> is a relative reference, let <b>B</b> be the value
of the <a title="" href="#interchange_baseURI">interchange model
base URI</a>. Then the value of the document base URI is the result
of transforming <b>U</b> into an absolute URI, using <b>B</b> as
the base URI.</p>
</li>
<li>
<p>Otherwise the value of the document base URI is <b>U</b>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise if the <a title="" href=
"#interchange_baseURI">interchange model base URI</a> has a value,
then the value of the document base URI is the value of the
interchange model base URI.</p>
</li>
<li>
<p>Otherwise, the document base URI has no value.</p>
</li>
</ol>
<p>According to the <code>smlif:baseURI</code> mechanism, the [base
URI] property of an element is calculated as follows:</p>
<ol class="enumar">
<li>
<p>If the element is part of a document in the interchange model
(i.e. it has as one of its ancestor elements smlif:locator,
smlif:data, smlif:base64Data), its [base URI] value is the
<a title="" href="#document_baseURI">document base URI</a>.</p>
</li>
<li>
<p>Otherwise, its [base URI] value is the <a title="" href=
"#interchange_baseURI">interchange model base URI</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="Document_aliases" id="Document_aliases"></a>5.3.3
Document Aliases</h4>
<p>For each document in the <a title="" href=
"#interchange_model">interchange model</a>, the
<code>document</code> element contains a set of zero or more
<code>alias</code> elements that are used to define the <a title=""
href="#alias">aliases</a> of the document.</p>
<p>Conceptually, each document in the interchange model has the
following property:</p>
<dl>
<dt class="label"><a name="aliases" id="aliases"></a>[aliases]</dt>
<dd>
<p>A set of URI references that comply with the “absolute-URI”
production as defined in RFC 3986 ([<cite><a href="#RFC3986">IETF
RFC 3986</a></cite>]).</p>
</dd>
</dl>
<p>The value of the content of <a title="" href=
"#aliases">[aliases]</a> is computed as follows:</p>
<ol class="enumar">
<li>
<p>For each <code>alias</code> child element under the model
document’s <code>docInfo/aliases</code>, there is a corresponding
member in the <a title="" href="#aliases">[aliases]</a>. Let
<b>U</b> be the value of such child element:</p>
<ol class="enumla">
<li>
<p>If <b>U</b> is a relative reference, let <b>B</b> be value of
the [base URI] property of the containing <code>alias</code>
element, then <a title="" href="#aliases">[aliases]</a> contains
the result of transforming <b>U</b> into an absolute URI, using
<b>B</b> as the base URI, as defined in section 5 of RFC 3986
([<cite><a href="#RFC3986">IETF RFC 3986</a></cite>]).</p>
</li>
<li>
<p>Otherwise <a title="" href="#aliases">[aliases]</a> contains
<b>U</b>.</p>
</li>
</ol>
</li>
</ol>
<p>Aliases <span class="rfc2119">MUST</span> be unique. That is,
there <span class="rfc2119">MUST NOT</span> exist two model
documents whose <a title="" href="#aliases">[aliases]</a>
properties overlap.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As a consequence of the above property definition’s reliance on
the “absolute-URI” production, the <code>alias</code> elements
<span class="rfc2119">MUST NOT</span> contain fragment
components.</p>
</div>
</div>
<div class="div3">
<h4><a name="URI_Processing" id="URI_Processing"></a>5.3.4 URI
Reference Processing</h4>
<p>When processing an SML-IF document, there are 3 categories of
URI references that may need to be resolved:</p>
<ol class="enumar">
<li>
<p><code>schemaLocation</code> attributes on
<code>xs:include</code> and <code>xs:redefine</code> in schema
documents, when they are model definition documents.</p>
</li>
<li>
<p>URI references specified in instances of SML reference schemes
that use target-complete identifiers [<cite><a href="#SML">SML
1.1</a></cite>].</p>
</li>
<li>
<p>URI references specified in instances of SML reference schemes
that do not use target-complete identifiers.</p>
</li>
</ol>
<p>It is clear which references fall into category #1. An example
of category #2 is URI references used in SML references that use
the SML URI Reference Scheme. When new reference schemes that use
URI references are defined, whether they fall into category #2 or
#3 will be clear from the reference scheme definitions. Resolution
of URI references in category #3 is defined in their respective
scheme definitions. It is also possible to have reference schemes
that do not use URI references. Their resolution is governed by
their scheme definitions and is not covered by this section.</p>
<p>To process a URI reference <b>UR</b> that is within categories
#1 or #2 above, the following steps are performed:</p>
<ol class="enumar">
<li>
<p>Determine the document <b>D</b> that possibly contains the
target:</p>
<ol class="enumla">
<li>
<p>If <b>UR</b> is a same-document reference [<cite><a href=
"#RFC3986">IETF RFC 3986</a></cite>], then <b>D</b> is the model
document that contains <b>UR</b>.</p>
</li>
<li>
<p>Otherwise</p>
<ol class="enumlr">
<li>
<p>If <b>UR</b> has a fragment component, then let <b>UR'</b> be
the URI reference formed by removing the fragment component;
otherwise let <b>UR'</b> be <b>UR</b>.</p>
</li>
<li>
<p>If <b>UR'</b> is a relative reference, then transform <b>UR'</b>
to form an (absolute) URI <b>U</b>, using its [base URI] as the
base URI, as defined in section 5 of RFC 3986 ([<cite><a href=
"#RFC3986">IETF RFC 3986</a></cite>]); otherwise let <b>U</b> be
<b>UR'</b>.</p>
</li>
<li>
<p>If there exists a model document with an alias URI that is equal
to <b>U</b> (<a href="#URI_equality"><b>5.3.1 URI
equality</b></a>), then <b>D</b> is that document; otherwise
<b>D</b> has no value.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>If <b>D</b> has no value, then</p>
<ol class="enumla">
<li>
<p>If <b>UR</b> is within category #1
(<code>schemaLocation</code>), then the SML-IF document does not
contain the target schema document. Whether the <a title="" href=
"#smlif_consumer">SML-IF consumer</a> continues to dereference
<b>UR</b> or <b>U</b> is governed by other sections of this
specification.</p>
</li>
<li>
<p>Otherwise (<b>UR</b> is within category #2, used in an SML
reference), <b>UR</b> has no target.</p>
</li>
</ol>
</li>
<li>
<p>If <b>D</b> has a value, then</p>
<ol class="enumla">
<li>
<p>If <b>UR</b> is within category #1
(<code>schemaLocation</code>), then <b>UR</b> has a target if and
only if all of the following are true.</p>
<ol class="enumlr">
<li>
<p><b>D</b> is a schema document that is also a model definition
document in the interchange model.</p>
</li>
<li>
<p><b>UR</b> does not contain a fragment component.</p>
</li>
</ol>
</li>
<li>
<p>If <b>UR</b> is within category #2, then</p>
<ol class="enumlr">
<li>
<p>If <b>UR</b> does not contain a fragment component, then it
targets the root element of D.</p>
</li>
<li>
<p>Otherwise (<b>UR</b> contains a fragment component), the
fragment component of <b>UR</b> is applied to the root element of
<b>D</b>, which may result in 0, 1, or many target elements.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>To process a URI reference UR that is within category #3 above,
a set of steps corresponding to those described above for
categories #1 and #2 MUST be defined as part of the reference
scheme definition.</p>
</div>
</div>
<div class="div2">
<h3><a name="Document_Bindings" id="Document_Bindings"></a>5.4
Document Bindings</h3>
<div class="div3">
<h4><a name="URI_prefix_matching" id=
"URI_prefix_matching"></a>5.4.1 URI Prefix Matching</h4>
<p>To associate SML rule or schema documents with the subset of
documents in the model to which they apply, SML-IF uses a
combination of the <a title="" href="#alias">alias</a> mechanism
described above [<a href="#Document_aliases"><b>5.3.3 Document
Aliases</b></a>] and URI prefix matching.</p>
<p>Two URIs, one called the <em>prefix</em>, and one called the
<em>target</em> participate in URI prefix matching. The target is
said to match the prefix if and only if the target, truncated to
the length of the prefix, is equal to the prefix as defined in
section <a href="#URI_equality"><b>5.3.1 URI equality</b></a>.</p>
</div>
<div class="div3">
<h4><a name="Rule_Bindings_Definition" id=
"Rule_Bindings_Definition"></a>5.4.2 Rule Bindings</h4>
<p>A rule binding is an association of a set of one or more rule
documents with a set of zero or more model documents. The documents
associated with a given rule document are said to be "bound" to it.
For a model to be valid, every document in the model must conform
to the constraints defined by every rule document it is bound to.
It is permissible for a rule document to have no bindings
associated with it, and for a model document to be bound to zero
rule documents.</p>
<p>The <code>ruleBinding</code> element is used in SML-IF to
express rule bindings. In any given binding the set of rule
documents is that subset of rule documents in the interchange model
with an alias that matches the URI prefix given by the content of
the <code>ruleAlias</code> element. The set of model documents in
the binding is that subset of the documents in the interchange
model with an alias that matches the URI prefix given by the
content of the <code>documentAlias</code> element. If the
<code>documentAlias</code> element is omitted in a
<code>ruleBinding</code>, the set of model documents in the binding
is all documents in the interchange model.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since the URI prefixes specified as <code>ruleAlias</code> and
<code>documentAlias</code> elements are aliases, they are subject
to all of the processing for aliases as described in [<a href=
"#Document_aliases"><b>5.3.3 Document Aliases</b></a>]. For
example, if they are relative references then they would be
transformed to absolute URIs before comparison.</p>
</div>
<p>SML-IF consumers <span class="rfc2119">MAY</span> choose to
extend the sets of documents involved in bindings to include
documents not contained in the interchange model. For example, if
an SML-IF document is used to represent a model fragment that is
intended to be merged with some other model, it is entirely
possible that some or all of the bindings may involve not just the
documents in the interchange model, but documents in the other
model.</p>
</div>
<div class="div3">
<h4><a name="Schema_Bindings_Definition" id=
"Schema_Bindings_Definition"></a>5.4.3 Schema Bindings</h4>
<p>SML-IF consumers <span class="rfc2119">MAY</span> choose to
ignore the <code>schemaBindings</code> element when present in the
SML-IF document, in which case the consumer <span class=
"rfc2119">SHOULD</span> make its invoker aware of this
situation.</p>
<p>If an SML-IF consumer chooses to process the schemaBindings
element, then, as part of the <a title="" href=
"#interchange_validation">interchange model validation</a>, for
every schema binding <b>SB</b> in the model, i.e. every
<code>/model/schemaBindings/schemaBinding</code> element, the
SML-IF consumer <span class="rfc2119">MUST</span> perform the
following steps for instance document validation.</p>
<ol class="enumar">
<li>
<p>Compose a schema using all documents specified under all
<b>SB</b>'s <code>namespaceBinding</code> children.</p>
</li>
<li>
<p>Whenever an <code>import</code> for a namespace <b>N</b> is
encountered, perform the following steps.</p>
<ol class="enumla">
<li>
<p>If there is a <code>namespaceBinding</code> child of <b>SB</b>
whose <code>namespace</code> attribute matches <b>N</b>, then
components from schema documents listed in the corresponding
<code>aliases</code> attribute are used. As with rule bindings, URI
prefixing [<a href="#URI_prefix_matching"><b>5.4.1 URI Prefix
Matching</b></a>] is used for matching schema document aliases. At
most one <code>namespaceBinding</code> is allowed per namespace
<b>N</b> within a given <b>SB</b>. If more than one namespace
binding exists for the namespace as part of a single schema
binding, the SML-IF document is in error. If the set of aliases for
namespace <b>N</b> is empty, the namespace has no schema documents
defining it in the schema binding.</p>
</li>
<li>
<p>Otherwise, if there are schema documents in the SML-IF document
whose targetNamespace is <b>N</b>, then components from all those
schema documents are used.</p>
</li>
<li>
<p>Otherwise, if this is a schema-complete SML-IF document
(<code>/model/@schemaComplete</code> = "true"), then no component
from <b>N</b> (other than built-ins) is included in the schema
being composed.</p>
</li>
<li>
<p>Otherwise, it is implementation-defined whether SML-IF consumer
attempts to retrieve components for <b>N</b> from outside the
SML-IF document.</p>
</li>
</ol>
</li>
<li>
<p>Whenever an <code>include</code> or <code>redefine</code> is
encountered, the <code>schemaLocation</code> is used to match
aliases of schema documents, as with base SML-IF.</p>
<ol class="enumla">
<li>
<p>If there is a schema document in the SML-IF document matching
that alias, then that document is used.</p>
</li>
<li>
<p>Otherwise, if this is a schema-complete SML-IF document, then
the <code>include</code> or <code>redefine</code> is unresolved
(which is allowed by XML Schema validity assessment rules).</p>
</li>
<li>
<p>Otherwise, it is implementation-defined whether an SML-IF
consumer attempts to resolve <code>include</code> or
<code>redefine</code> to schema documents outside the SML-IF
document.</p>
</li>
</ol>
</li>
<li>
<p>The instance documents that are referenced in the
<code>documentAlias</code> element of <b>SB</b> <span class=
"rfc2119">MUST</span> be validated against the schema constructed
in steps 1 through 3. <code>sml:target*</code> and SML identity
constraints can now be checked. Similar to
<code>documentAlias</code> under <code>ruleBinding</code> elements
[<a href="#Rule_Bindings_Definition"><b>5.4.2 Rule
Bindings</b></a>], each <code>documentAlias</code> can refer to
multiple documents via URI prefixing.</p>
</li>
</ol>
<p>Whether or not a <code>schemaBindings</code> element is present
or is ignored, SML-IF consumers <span class="rfc2119">MUST</span>
process an <code>include</code> or <code>redefine</code> element as
described in step 3 above.</p>
<p>The common use case where match-all namespace matching is
desired can be achieved by omitting <code>schemaBindings</code>
without introducing any additional complexity into the SML-IF
document.</p>
<p>If an SML-IF consumer chooses to process the
<code>schemaBindings</code> element, then the following rules
regarding the default schema must be followed:</p>
<ol class="enumar">
<li>
<p>If the optional <code>defaultSchema</code> element is present,
then an SML-IF consumer <span class="rfc2119">MUST</span> compose a
default schema from this element following rules 1 to 3 above,
replacing <b>SB</b> in the text with <b>DS</b> (i.e., the
<code>/model/schemaBindings/defaultSchema</code> element).</p>
</li>
<li>
<p>Otherwise, an SML-IF consumer <span class="rfc2119">MUST</span>
compose a default schema using all schema documents included in the
SML-IF document.</p>
</li>
<li>
<p>An SML-IF consumer <span class="rfc2119">MUST</span> use this
default schema to validate those SML instance documents whose alias
is not matched by any <code>documentAlias</code> in a
<code>schemaBinding</code> element or <code>noSchemaBinding</code>
element. Note that URI prefixing [<a href=
"#URI_prefix_matching"><b>5.4.1 URI Prefix Matching</b></a>] is
used for matching document aliases.</p>
</li>
</ol>
<p>In all other cases, the SML-IF consumer <span class=
"rfc2119">MUST</span> compose a schema using all schema documents
included in the SML-IF document and <span class=
"rfc2119">MUST</span> use this schema to validate all instance
documents in the <a title="" href="#interchange_model">interchange
model</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples of these cases include:</p>
<ol class="enumar">
<li>
<p>An SML-IF consumer chooses not to process the schemaBindings
element.</p>
</li>
<li>
<p>No schema documents are found among the SML-IF document's
definition documents.</p>
</li>
</ol>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The distinction between schema and schema documents is both
intentional and important; the absence of schema documents does not
imply the absence of a schema. A schema containing only built-in
components will be constructed given zero schema documents as
input, and this schema will be used to validate all instance
documents in the interchange model. This distinction has an impact
on model validation results according to the definition of validity
for a conforming SML model [<a href="#ConformanceClause"><b>5.1
Conformance Criteria</b></a>].</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="References" id="References"></a>6. References</h2>
<div class="div2">
<h3><a name="Normative_References" id=
"Normative_References"></a>6.1 Normative</h3>
<dl>
<dt class="label"><a name="SML" id="SML"></a>[SML 1.1]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2009/REC-sml-20090512/">Service Modeling
Language, Version 1.1</a></cite>, Bhalchandra Pandit, Valentina
Popescu, Virginia Smith, Editors. World Wide Web Consortium, 12 May
2009. This version of the Service Modeling Language specification
is available at http://www.w3.org/TR/2009/REC-sml-20090512/. The
<a href="http://www.w3.org/TR/sml/">latest version of Service
Modeling Language, Version 1.1</a> is available at
http://www.w3.org/TR/sml/.</dd>
<dt class="label"><a name="XSD1" id="XSD1"></a>[XML Schema
Structures]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">XML Schema
Part 1: Structures Second Edition</a></cite>, H. Thompson, D.
Beech, M. Maloney, and N. Mendelsohn, Editors. World Wide Web
Consortium, 2 May 2001, revised 28 October 2004. This version of
the XML Schema Part 1 Recommendation is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version of XML Schema
Part 1</a> is available at http://www.w3.org/TR/xmlschema-1.</dd>
<dt class="label"><a name="XSD2" id="XSD2"></a>[XML Schema
Datatypes]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema
Part 2: Datatypes Second Edition</a></cite>, P. Byron and A.
Malhotra, Editors. World Wide Web Consortium, 2 May 2001, revised
28 October 2004. This version of the XML Schema Part 2
Recommendation is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version of XML Schema
Part 2</a> is available at http://www.w3.org/TR/xmlschema-2.</dd>
<dt class="label"><a name="XML10" id="XML10"></a>[XML]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2006/REC-xml-20060816/">Extensible Markup
Language (XML) 1.0 (Fourth Edition)</a></cite>, T. Bray, J. Paoli,
C. M. Sperberg-McQueen, and E. Maler, Editors. World Wide Web
Consortium, 10 February 1998, revised 16 August 2006. The edition
cited (http://www.w3.org/TR/2006/REC-xml-20060816) was the one
current at the date of publication of this specification as a
Candidate Recommendation. The <a href=
"http://www.w3.org/TR/xml/">latest version of XML 1.0</a> is
available at http://www.w3.org/TR/xml/. Implementations may follow
the edition cited and/or any later edition(s); it is
implementation-defined which editions are supported by an
implementation.</dd>
<dt class="label"><a name="XMLInfoset" id="XMLInfoset"></a>[XML
Information Set]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">XML
Information Set</a></cite>, John Cowan and Richard Tobin, Editors.
World Wide Web Consortium, 4 February 2004. This version of the XML
Infoset Recommendation is
http://www.w3.org/TR/2004/REC-xml-infoset-20040204/. The <a href=
"http://www.w3.org/TR/xml-infoset/">latest version of the XML
Infoset</a> is available at http://www.w3.org/TR/xml-infoset/.</dd>
<dt class="label"><a name="XMLBase" id="XMLBase"></a>[XML
Base]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2001/REC-xmlbase-20010627/">XML
Base</a></cite>, Jonathan Marsh, Editor. World Wide Web Consortium,
27 June 2001. This version of the XML Base Recommendation is
http://www.w3.org/TR/2001/REC-xmlbase-20010627/. The <a href=
"http://www.w3.org/TR/xmlbase/">latest version of XML Base</a> is
available at http://www.w3.org/TR/xmlbase/.</dd>
<dt class="label"><a name="RFC3986" id="RFC3986"></a>[IETF RFC
3986]</dt>
<dd><cite><a href="http://www.ietf.org/rfc/rfc3986.txt">Uniform
Resource Identifier (URI): Generic Syntax</a></cite>, T.
Berners-Lee, R. Fielding, L. Masinter Authors. Internet Engineering
Task Force, January 2005. Available at
http://www.ietf.org/rfc/rfc3986.txt.</dd>
<dt class="label"><a name="RFC2119" id="RFC2119"></a>[IETF RFC
2119]</dt>
<dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">Key words
for use in RFCs to Indicate Requirement Levels</a></cite>, S.
Bradner, Author. Internet Engineering Task Force, June 1999.
Available at http://www.ietf.org/rfc/rfc2119.txt.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="NonNormative_References" id=
"NonNormative_References"></a>6.2 Non-Normative</h3>
<dl>
<dt class="label"><a name="Schematron" id="Schematron"></a>[ISO/IEC
19757-3]</dt>
<dd><cite><a href=
"http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip">
Information technology ― Document Schema Definition Languages
(DSDL) ― Part 3: Rule-based validation ― Schematron</a></cite>.
International Organization for Standardization and International
Electrotechnical Commission, 1 January 2006. Available at
http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</dd>
<dt class="label"><a name="Canonical" id="Canonical"></a>[Canonical
XML]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical
XML</a></cite>, J. Boyer, Author. World Wide Web Consortium, 15
March 2001. This version of the Canonical XML Recommendation is
http://www.w3.org/TR/2001/REC-xml-c14n-20010315. The <a href=
"http://www.w3.org/TR/xml-c14n">latest version of Canonical XML</a>
is available at http://www.w3.org/TR/xml-c14n.</dd>
<dt class="label"><a name="XML-Signature" id=
"XML-Signature"></a>[XML-Signature]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">XML-Signature
Syntax and Processing</a></cite>, D. Eastlake, J. Reagle, and D.
Solo, Editors. Internet Engineering Task Force &amp; World Wide Web
Consortium, 12 February 2002. This version of the XML-Signature
Syntax and Processing Recommendation is
http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/. The <a href=
"http://www.w3.org/TR/xmldsig-core/">latest version of
XML-Signature Syntax and Processing</a> is available at
http://www.w3.org/TR/xmldsig-core/.</dd>
<dt class="label"><a name="WSADDR-CORE" id=
"WSADDR-CORE"></a>[WS-Addressing Core]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2006/REC-ws-addr-core-20060509/">Web Services
Addressing 1.0 - Core</a></cite>, M. Gudgin, M. Hadley, and T.
Rogers, Editors. World Wide Web Consortium, 9 May 2006. This
version of the WS-Addressing Core Recommendation is
http://www.w3.org/TR/2006/REC-ws-addr-core-20060509/. The <a href=
"http://www.w3.org/TR/ws-addr-core/">latest version of
WS-Addressing Core</a> is available at
http://www.w3.org/TR/ws-addr-core/.</dd>
<dt class="label"><a name="WSDL20" id="WSDL20"></a>[WSDL 2.0 Core
Language]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2007/PR-wsdl20-20070523/">Web Services
Description Language (WSDL) Version 2.0 Part 1: Core
Language</a></cite>, R. Chinnici, M. Gudgin, J-J. Moreau, S.
Weerawarana, Editors. World Wide Web Consortium, 23 May 2007. This
version of the "Web Services Description Language (WSDL) Version
2.0 Part 1: Core Language" Specification is available is available
at http://www.w3.org/TR/2007/PR-wsdl20-20070523/. The <a href=
"http://www.w3.org/TR/wsdl20/">latest version of "Web Services
Description Language (WSDL) Version 2.0 Part 1: Core Language"</a>
is available at http://www.w3.org/TR/wsdl20/.</dd>
<dt class="label"><a name="XLink" id="XLink"></a>[XLink]</dt>
<dd><cite><a href=
"http://www.w3.org/TR/2001/REC-xlink-20010627/">XML Linking
Language (XLink) Version 1.0</a></cite>, Steve DeRose, Eve Maler,
David Orchard, Editors. World Wide Web Consortium, 27 June 2001.
This version of the XLink Recommendation is
http://www.w3.org/TR/2001/REC-xlink-20010627/ The <a href=
"http://www.w3.org/TR/xlink/">latest version of XLink</a> is
available at http://www.w3.org/TR/xlink/.</dd>
</dl>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="SML_IF_Schema" id="SML_IF_Schema"></a>A. SML-IF
Schema</h2>
<div class="exampleInner">
<pre>
&lt;!--
/*
 * Copyright © ns World Wide Web Consortium,
 *
 * (Massachusetts Institute of Technology, European Research Consortium for
 * Informatics and Mathematics, Keio University). All Rights Reserved. This
 * work is distributed under the W3C® Document License [1] in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * [1] http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
 */
--&gt;&lt;xs:schema
      xmlns:smlif="http://www.w3.org/ns/sml-if"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      targetNamespace="http://www.w3.org/ns/sml-if"
      elementFormDefault="qualified"
      blockDefault="#all"
      version="1.0"
      xml:lang="EN"
      finalDefault=""
      attributeFormDefault="unqualified"&gt;
   &lt;xs:element name="model" type="smlif:modelType"/&gt;
   &lt;xs:complexType name="modelType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="identity" type="smlif:identityType"/&gt;
         &lt;xs:element ref="smlif:ruleBindings" minOccurs="0"/&gt;
         &lt;xs:element ref="smlif:schemaBindings" minOccurs="0"/&gt;
         &lt;xs:element
               name="definitions"
               type="smlif:documentCollectionType"
               minOccurs="0"/&gt;
         &lt;xs:element
               name="instances"
               type="smlif:documentCollectionType"
               minOccurs="0"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute
            name="SMLIFVersion"
            type="xs:token"
            use="optional"/&gt;
      &lt;xs:attribute
            name="schemaComplete"
            type="xs:boolean"
            default="false"/&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;!-- If there is a need for localized string values, e.g. in displayName
         or description, the sml:locid global attribute can be
         used --&gt;
   &lt;xs:complexType name="identityType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="name" type="smlif:uriType"/&gt;
         &lt;xs:element
               name="version"
               type="smlif:tokenType"
               minOccurs="0"/&gt;
         &lt;xs:element
               name="displayName"
               type="smlif:displayType"
               minOccurs="0"/&gt;
         &lt;xs:element
               name="baseURI"
               type="smlif:uriType"
               minOccurs="0"/&gt;
         &lt;xs:element
               name="description"
               type="smlif:displayType"
               minOccurs="0"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="displayType" mixed="false"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:string"&gt;
            &lt;xs:anyAttribute
                  namespace="##other"
                  processContents="lax"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="tokenType" mixed="false"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:token"&gt;
            &lt;xs:anyAttribute
                  namespace="##other"
                  processContents="lax"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="uriType" mixed="false"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:anyURI"&gt;
            &lt;xs:anyAttribute
                  namespace="##other"
                  processContents="lax"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="ruleBindings"
         type="smlif:ruleBindingCollectionType"/&gt;
   &lt;xs:complexType
         name="ruleBindingCollectionType"
         mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               ref="smlif:ruleBinding"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element name="ruleBinding" type="smlif:ruleBindingType"/&gt;
   &lt;xs:complexType name="ruleBindingType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               name="documentAlias"
               type="smlif:uriType"
               minOccurs="0"/&gt;
         &lt;xs:element name="ruleAlias" type="smlif:uriType"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="schemaBindings"
         type="smlif:schemaBindingCollectionType"/&gt;
   &lt;xs:complexType
         name="schemaBindingCollectionType"
         mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element ref="smlif:defaultSchema" minOccurs="0"/&gt;
         &lt;xs:element
               ref="smlif:schemaBinding"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:element
               ref="smlif:noSchemaBinding"
               minOccurs="0"
               maxOccurs="1"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="schemaBinding"
         type="smlif:schemaBindingType"/&gt;
   &lt;xs:complexType name="schemaBindingType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               ref="smlif:namespaceBinding"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:element
               name="documentAlias"
               type="smlif:uriType"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="namespaceBinding"
         type="smlif:namespaceBindingType"/&gt;
   &lt;!-- The value of the aliases attribute in the complexType below 
       is a list of instance document URIs --&gt;
   &lt;xs:complexType name="namespaceBindingType" mixed="false"&gt;
      &lt;xs:attribute
            name="namespace"
            type="xs:anyURI"
            use="optional"/&gt;
      &lt;xs:attribute name="aliases" use="required"&gt;
         &lt;xs:simpleType&gt;
            &lt;xs:list itemType="xs:anyURI"/&gt;
         &lt;/xs:simpleType&gt;
      &lt;/xs:attribute&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="noSchemaBinding"
         type="smlif:noSchemaBindingType"/&gt;
   &lt;xs:complexType name="noSchemaBindingType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               name="documentAlias"
               type="smlif:uriType"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element
         name="defaultSchema"
         type="smlif:defaultSchemaType"/&gt;
   &lt;xs:complexType name="defaultSchemaType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               ref="smlif:namespaceBinding"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="documentCollectionType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element ref="smlif:document" maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element name="document" type="smlif:documentType"/&gt;
   &lt;xs:complexType name="documentType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element ref="smlif:docinfo" minOccurs="0"/&gt;
         &lt;xs:choice&gt;
            &lt;xs:element name="data" type="smlif:dataType"/&gt;
            &lt;xs:element
                  name="base64Data"
                  type="smlif:base64DataType"/&gt;
            &lt;xs:element name="locator" type="smlif:locatorType"/&gt;
         &lt;/xs:choice&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element name="docinfo" type="smlif:docinfoType"/&gt;
   &lt;xs:complexType name="docinfoType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               name="baseURI"
               type="smlif:uriType"
               minOccurs="0"/&gt;
         &lt;xs:element ref="smlif:aliases" minOccurs="0"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:element name="aliases" type="smlif:aliasCollectionType"/&gt;
   &lt;xs:complexType name="aliasCollectionType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               name="alias"
               type="smlif:uriType"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="dataType" mixed="false"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
                The wildcard with processContents "skip" matches the root element of the  
                model document being packaged. The value of processContents is set to "skip" so
                that the contained element is not processed for schema validation. As a result,
                validity of the packaged document will not affect validity of the IF document
                itself.
            &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any
               processContents="skip"
               minOccurs="0"
               namespace="##any"
               maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="base64DataType" mixed="false"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:base64Binary"&gt;
            &lt;xs:anyAttribute
                  namespace="##other"
                  processContents="lax"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="locatorType" mixed="false"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element
               name="documentURI"
               type="smlif:uriType"
               minOccurs="0"/&gt;
         &lt;xs:any
               namespace="##other"
               processContents="lax"
               minOccurs="0"
               maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:anyAttribute
            namespace="##other"
            processContents="lax"/&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="LocalizationSample" id="LocalizationSample"></a>B.
Localization of IF Identity Sample (Non-Normative)</h2>
<p>The following example shows how the <code>sml:locid</code>
attribute can be used to define the translation information for the
interchange model identity attributes:</p>
<div class="exampleInner">
<pre>
&lt;model xmlns="http://www.w3.org/ns/sml-if" version="1.0"
       xmlns:sml="http://www.w3.org/ns/sml"&gt;
       xmlns:lang="http://www.university.example.org/translation/core"&gt;
    &lt;identity&gt;
        &lt;name sml:locid="lang:nameID“&gt;Univerity interchange model&lt;/name&gt;
        &lt;description sml:locid="lang:descrID"&gt; This document contains a list of universities.&lt;/description&gt;
    &lt;/identity&gt;
&lt;/model&gt;
</pre></div>
<p>In this example, the [namespace name] URI information of the
<code>sml:locid</code> attribute can be used to define the location
for the resource containing the translated text. The
<code>smlif:name</code> and <code>smlif:description</code> elements
are using the same URI to identify the resource containing the
translated strings:</p>
<div class="exampleInner">
<pre>
&lt;xmlns:lang="http://www.university.example.org/translation/core"&gt;
</pre></div>
<p>The [local part] information of the <code>sml:locid</code>
attribute can be used to define the id of the text being
translated. This information will be used to locate the translation
of the name and description texts within the translation
resource.</p>
</div>
<div class="div1">
<h2><a name="Acknowledgements" id="Acknowledgements"></a>C.
Acknowledgements (Non-Normative)</h2>
<p>The editors acknowledge the members of the Service Modeling
Language Working Group, the members of other W3C Working Groups,
and industry experts in other forums who have contributed directly
or indirectly to the process or content of creating this
document.</p>
<p>At the time this specification was published, the members of the
Service Modeling Language Working Group were:</p>
<p>John Arwe (IBM Corporation), Len Charest (Microsoft
Corporation), Sandy Gao (IBM Corporation), Paul Lipton (CA), James
Lynn (HP), Kumar Pandit (Microsoft Corporation), Valentina Popescu
(IBM Corporation), Virginia Smith (HP), Henry Thompson (W3C/ERCIM),
David Whiteman (IBM Corporation), Kirk Wilson (CA).</p>
<p>The Service Modeling Language Working Group has benefited in its
work from the participation and contributions of a number of people
not currently members of the Working Group, including in particular
those named below.</p>
<p>Dave Ehnebuske (IBM), Jon Hass (Dell), Steve Jerman (Cisco),
Heather Kreger (IBM), Vincent Kowalski (BMC), Milan Milenkovic
(Intel), Bryan Murray (HP), Phil Prasek (HP), Junaid Saiyed (EMC),
Harm Sluiman (IBM), C. Michael Sperberg-McQueen (W3C/MIT), Bassam
Tabbara (Microsoft), Vijay Tewari (Intel), William Vambenepe (HP),
Marv Waschke (CA), Andrea Westerinen (Microsoft), Pratul Dublish
(Microsoft), Julia McCarthy (IBM).</p>
<p>Affiliations given above are those current at the time of their
work with the working group.</p>
</div>
</div>
</body>
</html>
