<!-- http://www.w3.org/TR/xslt11/ -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="EN"><head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>XSL Transformations (XSLT) Version 1.1</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; font-weight: bold }

dt.label       { display: run-in; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }
      
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
        </style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-WD.css"></head><body>
<div class="head"><p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a></p>
<h1>XSL Transformations (XSLT) Version 1.1</h1>
<h2>W3C Working Draft 24 August 2001</h2><dl><dt>This version:</dt><dd>
<a href="http://www.w3.org/TR/2001/WD-xslt11-20010824/">http://www.w3.org/TR/2001/WD-xslt11-20010824/</a><br />
(also available as <a href="http://www.w3.org/TR/2001/WD-xslt11-20010824/xslt.xml">XML</a> and 
<a href="http://www.w3.org/TR/2001/WD-xslt11-20010824/Overview.html">HTML</a>)

</dd>
<dt>Latest version:</dt><dd>
<a href="http://www.w3.org/TR/xslt11/">http://www.w3.org/TR/xslt11/</a>
</dd>
<dt>Previous version:</dt><dd>
<a href="http://www.w3.org/TR/2000/WD-xslt11-20001212/">
http://www.w3.org/TR/2000/WD-xslt11-20001212/</a></dd>
<dt>Editor:</dt>
<dd>James Clark <a href="mailto:jjc@jclark.com">&lt;jjc@jclark.com&gt;</a></dd>
</dl><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Copyright">Copyright</a>&nbsp;�&nbsp;2001&nbsp;<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>�</sup> (<a href="http://www.lcs.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.inria.fr/"><abbr lang="fr" title="Institut National de Recherche en Informatique et Automatique">INRIA</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#W3C_Trademarks">trademark</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents-19990405">document use</a>, and <a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720">software licensing</a> rules apply.</p></div><hr><div>
<h2><a name="abstract">Abstract</a></h2>

<p>This specification defines the syntax and semantics of XSLT, which
is a language for transforming XML documents into other XML
documents.</p>

<p>XSLT is designed for use as part of XSL, which is a stylesheet
language for XML. In addition to XSLT, XSL includes an XML vocabulary
for specifying formatting.  XSL specifies the styling of an XML
document by using XSLT to describe how the document is transformed
into another XML document that uses the formatting vocabulary.</p>

<p>XSLT is also designed to be used independently of XSL.  However,
XSLT is not intended as a completely general-purpose XML
transformation language.  Rather it is designed primarily for the
kinds of transformations that are needed when XSLT is used as part of
XSL.</p>

</div><div>
<h2><a name="status">Status of this Document</a></h2>

<p>This document is a W3C Working Draft for review by W3C
members and other interested parties.</p>

<div class="notice"><p class="prefix"><b>NOTICE:</b></p>As of 24
August 2001 no further work on this draft is expected. The work on
XSLT 2.0 identified a number of issues with the approaches being
pursued in this document; solutions to the requirements of XSLT 1.1
will be considered in the development of XSLT 2.0 <a
href="#XSLT20REQ">[XSLT20REQ]</a>. Other than this paragraph, the
document is unchanged from the previous version.</div>

<p>It is inappropriate to use W3C Working Drafts as reference material
or to cite them as other than "work in progress".</p>

<p>This document is based on the XSLT 1.0 Recommendation
<a href="#XSLT10">[XSLT10]</a>.  The changes made in this document are
intended to meet the requirements for XSLT 1.1 described in <a href="#XSLT11REQ">[XSLT11REQ]</a> and to incorporate fixes for <a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</a>
that have been detected in XSLT 1.0.</p>

<p>Comments on this specification may be sent to <a href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</a>; <a href="http://lists.w3.org/Archives/Public/xsl-editors/">archives</a>
of the comments are available.  Public discussion of XSL, including
XSL Transformations, takes place on the <a href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</a>
mailing list.</p>

<p>The English version of this specification is the only normative
version. However, for translations of this document, see <a href="http://www.w3.org/Style/XSL/translations.html">http://www.w3.org/Style/XSL/translations.html</a>.</p>

<p>A list of current W3C Recommendations and other technical documents
can be found at <a href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.</p>

<p>This specification has been produced as part of the <a href="http://www.w3.org/Style/Activity">W3C Style activity</a>.</p>

</div>
<div class="toc">
<h2><a name="contents">Table of Contents</a></h2><p class="toc">1 <a href="#N472">Introduction</a><br>2 <a href="#N602">Stylesheet Structure</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#xslt-namespace">XSLT Namespace</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#stylesheet-element">Stylesheet Element</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#result-element-stylesheet">Literal Result Element as Stylesheet</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#qname">Qualified Names</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#forwards">Forwards-Compatible Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#N1316">Combining Stylesheets</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6.1 <a href="#include">Stylesheet Inclusion</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6.2 <a href="#import">Stylesheet Import</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.7 <a href="#N1715">Embedding Stylesheets</a><br>3 <a href="#data-model">Data Model</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#root-node-children">Root Node Children</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#base-uri">Base URI</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#unparsed-entities">Unparsed Entities</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#strip">Whitespace Stripping</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#namespace-fixup">Namespace Fixup</a><br>4 <a href="#N2221">Expressions</a><br>5 <a href="#rules">Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#N2337">Processing Model</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#patterns">Patterns</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href="#N2967">Defining Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href="#N3115">Applying Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.5 <a href="#conflict">Conflict Resolution for Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.6 <a href="#apply-imports">Overriding Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.7 <a href="#modes">Modes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.8 <a href="#built-in-rule">Built-in Template Rules</a><br>6 <a href="#named-templates">Named Templates</a><br>7 <a href="#N3791">Creating the Result Tree</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.1 <a href="#N3799">Creating Elements and Attributes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1 <a href="#literal-result-element">Literal Result Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.2 <a href="#N4021">Creating Elements with xsl:element</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.3 <a href="#creating-attributes">Creating Attributes with xsl:attribute</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.4 <a href="#attribute-sets">Named Attribute Sets</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.2 <a href="#N4656">Creating Text</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.3 <a href="#N4760">Creating Processing Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.4 <a href="#N4885">Creating Comments</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.5 <a href="#copying">Copying</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.6 <a href="#N5075">Computing Generated Text</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.6.1 <a href="#value-of">Generating Text with xsl:value-of</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.6.2 <a href="#attribute-value-templates">Attribute Value Templates</a><br>&nbsp;&nbsp;&nbsp;&nbsp;7.7 <a href="#number">Numbering</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.7.1 <a href="#convert">Number to String Conversion Attributes</a><br>8 <a href="#for-each">Repetition</a><br>9 <a href="#N6058">Conditional Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.1 <a href="#N6078">Conditional Processing with xsl:if</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.2 <a href="#N6137">Conditional Processing with xsl:choose</a><br>10 <a href="#sorting">Sorting</a><br>11 <a href="#variables">Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.1 <a href="#N6743">Result Tree Fragments</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.2 <a href="#variable-values">Values of Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.3 <a href="#copy-of">Using Values of Variables and Parameters with
xsl:copy-of</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.4 <a href="#top-level-variables">Top-level Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.5 <a href="#local-variables">Variables and Parameters within Templates</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.6 <a href="#with-param">Passing Parameters to Templates</a><br>12 <a href="#add-func">Additional Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.1 <a href="#document">Multiple Source Documents</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.2 <a href="#key">Keys</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.3 <a href="#format-number">Number Formatting</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.4 <a href="#misc-func">Miscellaneous Additional Functions</a><br>13 <a href="#message">Messages</a><br>14 <a href="#extension">Extensions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.1 <a href="#extension-element">Using Extension Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.2 <a href="#N8607">Using Extension Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.3 <a href="#external-objects">External Objects</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.4 <a href="#define-extension-functions">Defining Extension Functions</a><br>15 <a href="#fallback">Fallback</a><br>16 <a href="#output">Output</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.1 <a href="#N9628">XML Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.2 <a href="#N9978">HTML Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.3 <a href="#N10310">Text Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.4 <a href="#disable-output-escaping">Disabling Output Escaping</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.5 <a href="#multiple-output">Multiple Output Documents</a><br>17 <a href="#conformance">Conformance</a><br>18 <a href="#notation">Notation</a><br></p>
<h3>Appendices</h3><p class="toc">A <a href="#N10922">References</a><br>&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#N10927">Normative References</a><br>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="#N11053">Other References</a><br>B <a href="#element-syntax-summary">Element Syntax Summary</a><br>C <a href="#N11359">DOM-Based Language Bindings</a><br>&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href="#N11368">DOM Issues</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.1.1 <a href="#node-set-to-external-function">Passing an XPath node-set to an Extension Function</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.1.2 <a href="#N11530">Returning a NodeList or Node from an Extension Function</a><br>&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href="#N11723">IDL/DOM2 Language Binding</a><br>&nbsp;&nbsp;&nbsp;&nbsp;C.3 <a href="#ecmascript-binding">ECMAScript/DOM2 Language Binding</a><br>&nbsp;&nbsp;&nbsp;&nbsp;C.4 <a href="#java-binding">Java/DOM2 Language Binding</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.4.1 <a href="#java-identify-method">Identifying the Java Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.4.2 <a href="#java-argument-conversions">Argument Conversions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.4.3 <a href="#N13111">Return Value Conversions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.4.4 <a href="#java-expression-context">Accessing XSLT Context Information</a><br>D <a href="#dtd">DTD Fragment for XSLT Stylesheets</a> (Non-Normative)<br>E <a href="#N13295">Examples</a> (Non-Normative)<br>&nbsp;&nbsp;&nbsp;&nbsp;E.1 <a href="#N13300">Document Example</a><br>&nbsp;&nbsp;&nbsp;&nbsp;E.2 <a href="#data-example">Data Example</a><br>F <a href="#N13416">Acknowledgements</a> (Non-Normative)<br>G <a href="#N14079">Changes from XSLT 1.0</a> (Non-Normative)<br></p></div><hr><div class="body">
<div class="div1">

<h2><a name="N472"></a>1 Introduction</h2>

<p>This specification defines the syntax and semantics of the XSLT
language.  A transformation in the XSLT language is expressed as a
well-formed XML document <a href="#XML">[XML]</a> conforming to the
Namespaces in XML Recommendation <a href="#XMLNAMES">[XML Names]</a>, which may
include both elements that are defined by XSLT and elements that are
not defined by XSLT.  [<a name="dt-xslt-namespace" title="XSLT Namespace">Definition</a>: XSLT-defined elements are distinguished by belonging to a
specific XML namespace (see <a href="#xslt-namespace"><b>2.1 XSLT Namespace</b></a>), which is
referred to in this specification as the <b>XSLT
namespace</b>.] Thus this specification is a definition of
the syntax and semantics of the XSLT namespace.</p>

<p>A transformation expressed in XSLT describes rules for transforming
a source tree into a result tree.  The transformation is achieved by
associating patterns with templates.  A pattern is matched against
elements in the source tree.  A template is instantiated to create
part of the result tree.  The result tree is separate from the source
tree.  The structure of the result tree can be completely different
from the structure of the source tree. In constructing the result
tree, elements from the source tree can be filtered and reordered, and
arbitrary structure can be added.</p>

<p>A transformation expressed in XSLT is called a stylesheet.  This is
because, in the case when XSLT is transforming into the XSL formatting
vocabulary, the transformation functions as a stylesheet.</p>

<p>This document does not specify how an XSLT stylesheet is associated
with an XML document.  It is recommended that XSL processors support
the mechanism described in <a href="#XMLSTYLE">[XML Stylesheet]</a>.  When this or any
other mechanism yields a sequence of more than one XSLT stylesheet to
be applied simultaneously to a XML document, then the effect
should be the same as applying a single stylesheet that imports each
member of the sequence in order (see <a href="#import"><b>2.6.2 Stylesheet Import</b></a>).</p>

<p>A stylesheet contains a set of template rules.  A template rule has
two parts: a pattern which is matched against nodes in the source tree
and a template which can be instantiated to form part of the result
tree.  This allows a stylesheet to be applicable to a wide class of
documents that have similar source tree structures.</p>

<p>A template is instantiated for a particular source element
to create part of the result tree. A template can contain elements
that specify literal result element structure.  A template can also
contain elements from the XSLT namespace
that are instructions for creating result tree
fragments.  When a template is instantiated, each instruction is
executed and replaced by the result tree fragment that it creates.
Instructions can select and process descendant source elements.  Processing a
descendant element creates a result tree fragment by finding the
applicable template rule and instantiating its template. Note
that elements are only processed when they have been selected by the
execution of an instruction.  The result tree is constructed by
finding the template rule for the root node and instantiating
its template.</p>

<p>In the process of finding the applicable template rule, more
than one template rule may have a pattern that matches a given
element. However, only one template rule will be applied. The
method for deciding which template rule to apply is described
in <a href="#conflict"><b>5.5 Conflict Resolution for Template Rules</b></a>.</p>

<p>A single template by itself has considerable power: it can create
structures of arbitrary complexity; it can pull string values out of
arbitrary locations in the source tree; it can generate structures
that are repeated according to the occurrence of elements in the
source tree.  For simple transformations where the structure of the
result tree is independent of the structure of the source tree, a
stylesheet can often consist of only a single template, which
functions as a template for the complete result tree.  Transformations
on XML documents that represent data are often of this kind (see
<a href="#data-example"><b>E.2 Data Example</b></a>). XSLT allows a simplified syntax for
such stylesheets (see <a href="#result-element-stylesheet"><b>2.3 Literal Result Element as Stylesheet</b></a>).</p>

<p>When a template is instantiated, it is always instantiated with
respect to a [<a name="dt-current-node" title="Current Node">Definition</a>: <b>current node</b>] and a [<a name="dt-current-node-list" title="Current Node List">Definition</a>: <b>current node
list</b>]. The current node is always a member of the
current node list.  Many operations in XSLT are relative to the
current node. Only a few instructions change the current node list or
the current node (see <a href="#rules"><b>5 Template Rules</b></a> and <a href="#for-each"><b>8 Repetition</b></a>); during the instantiation of one of these
instructions, the current node list changes to a new list of nodes and
each member of this new list becomes the current node in turn; after
the instantiation of the instruction is complete, the current node and
current node list revert to what they were before the instruction was
instantiated.</p>

<p>XSLT makes use of the expression language defined by <a href="#XPATH">[XPath]</a> for selecting elements for processing, for conditional
processing and for generating text.</p>

<p>XSLT provides two "hooks" for extending the language,
one hook for extending the set of instruction elements used in
templates and one hook for extending the set of functions used in
XPath expressions.  These hooks are both based on XML namespaces.
See <a href="#extension"><b>14 Extensions</b></a>.  This version of
XSLT defines a mechanism for providing implementations of extension
functions (see <a href="#define-extension-functions"><b>14.4 Defining Extension Functions</b></a>), but does
not define a mechanism for providing implementations of extension
elements.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The XSL WG intends to define such a mechanism for extension elements in a future version of
this specification or in a separate specification.</p></div>

<p>The element syntax summary notation used to describe the syntax of
XSLT-defined elements is described in <a href="#notation"><b>18 Notation</b></a>.</p>

<p>The MIME media types <code>text/xml</code> and
<code>application/xml</code> <a href="#RFC2376">[RFC2376]</a> should be used
for XSLT stylesheets.  It is possible that a media type will be
registered specifically for XSLT stylesheets; if and when it is, that
media type may also be used.</p>

</div>

<div class="div1">

<h2><a name="N602"></a>2 Stylesheet Structure</h2>

<div class="div2">

<h3><a name="xslt-namespace"></a>2.1 XSLT Namespace</h3>

<p>The XSLT namespace has the URI <code>http://www.w3.org/1999/XSL/Transform</code>.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>1999</code> in the URI indicates the year in which
the URI was allocated by the W3C.  It does not indicate the version of
XSLT being used, which is specified by attributes (see <a href="#stylesheet-element"><b>2.2 Stylesheet Element</b></a> and <a href="#result-element-stylesheet"><b>2.3 Literal Result Element as Stylesheet</b></a>).</p></div>

<p>XSLT processors must use the XML namespaces mechanism <a href="#XMLNAMES">[XML Names]</a> to recognize elements and attributes from this
namespace. Elements from the XSLT namespace are recognized only in the
stylesheet and not in the source document. The complete list of
XSLT-defined elements is specified in <a href="#element-syntax-summary"><b>B Element Syntax Summary</b></a>.  Vendors must not extend the XSLT
namespace with additional elements or attributes. Instead, any
extension must be in a separate namespace.  Any namespace that is used
for additional instruction elements must be identified by means of the
extension element mechanism specified in <a href="#extension-element"><b>14.1 Using Extension Elements</b></a>.</p>

<p>This specification uses a prefix of <code>xsl:</code> for referring
to elements in the XSLT namespace. However, XSLT stylesheets are free
to use any prefix, provided that there is a namespace declaration that
binds the prefix to the URI of the XSLT namespace.</p>

<p>An element from the XSLT namespace may have any attribute not from
the XSLT namespace, provided that the <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
attribute has a non-null namespace URI.  The presence of such
attributes must not change the behavior of XSLT elements and functions
defined in this document. Thus, an XSLT processor is always free to
ignore such attributes, and must ignore such attributes without giving
an error if it does not recognize the namespace URI. Such attributes
can provide, for example, unique identifiers, optimization hints, or
documentation.</p>

<p>It is an error for an element from the XSLT namespace to have
attributes with expanded-names that have null namespace URIs
(i.e. attributes with unprefixed names) other than attributes defined
for the element in this document.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The conventions used for the names of XSLT elements,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they already
appear in the syntax of a related language such as XML or
HTML.</p></div>


</div>

<div class="div2">

<h3><a name="stylesheet-element"></a>2.2 Stylesheet Element</h3>


  
    
  
  
    
  
  
    
  
  
    
  
  
    
    
  



  
    
  
  
    
  
  
    
  
  
    
  
  
    
    
  


<p>A stylesheet is represented by an <code>xsl:stylesheet</code>
element in an XML document.  <code>xsl:transform</code> is allowed as
a synonym for <code>xsl:stylesheet</code>.</p>

<p>An <code>xsl:stylesheet</code> element must have a
<code>version</code> attribute, indicating the version of XSLT that
the stylesheet requires.  For this version of XSLT, the value should
be <code>1.1</code>.  When the value is not equal to
<code>1.0</code> or <code>1.1</code>,
forwards-compatible processing mode is enabled (see <a href="#forwards"><b>2.5 Forwards-Compatible Processing</b></a>).</p>

<p>The <code>xsl:stylesheet</code> element may contain the following types
of elements:</p>
<ul>
<li><p><code>xsl:import</code></p></li>
<li><p><code>xsl:include</code></p></li>
<li><p><code>xsl:strip-space</code></p></li>
<li><p><code>xsl:preserve-space</code></p></li>
<li><p><code>xsl:output</code></p></li>
<li><p><code>xsl:key</code></p></li>
<li><p><code>xsl:decimal-format</code></p></li>
<li><p><code>xsl:namespace-alias</code></p></li>
<li><p><code>xsl:attribute-set</code></p></li>
<li><p><code>xsl:variable</code></p></li>
<li><p><code>xsl:param</code></p></li>
<li><p><code>xsl:template</code></p></li>
<li><p><code>xsl:script</code></p></li>
</ul>

<p>[<a name="dt-top-level" title="Top-level">Definition</a>: An element occurring as
a child of an <code>xsl:stylesheet</code> element is called a
<b>top-level</b> element.]</p>

<p>This example shows the structure of a stylesheet.  Ellipses
(<code>...</code>) indicate where attribute values or content have
been omitted.  Although this example shows one of each type of allowed
element, stylesheets may contain zero or more of each of these
elements.</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="..."/&gt;

  &lt;xsl:include href="..."/&gt;

  &lt;xsl:strip-space elements="..."/&gt;
  
  &lt;xsl:preserve-space elements="..."/&gt;

  &lt;xsl:output method="..."/&gt;

  &lt;xsl:key name="..." match="..." use="..."/&gt;

  &lt;xsl:decimal-format name="..."/&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/&gt;

  &lt;xsl:attribute-set name="..."&gt;
    ...
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:variable name="..."&gt;...&lt;/xsl:variable&gt;

  &lt;xsl:param name="..."&gt;...&lt;/xsl:param&gt;

  &lt;xsl:script implements-prefix="..." language="..."&gt;
    ...
  &lt;/xsl:script&gt;

  &lt;xsl:template match="..."&gt;
    ...
  &lt;/xsl:template&gt;

  &lt;xsl:template name="..."&gt;
    ...
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div>

<p>The order in which the children of the <code>xsl:stylesheet</code>
element occur is not significant except for <code>xsl:import</code>
elements and for error recovery.  Users are free to order the elements
as they prefer, and stylesheet creation tools need not provide control
over the order in which the elements occur.</p>

<p>In addition, the <code>xsl:stylesheet</code> element may contain
any element not from the XSLT namespace, provided that the
expanded-name of the element has a non-null namespace URI.  The presence of
such top-level elements must not change the behavior of XSLT elements
and functions defined in this document; for example, it would not be
permitted for such a top-level element to specify that
<code>xsl:apply-templates</code> was to use different rules to resolve
conflicts. Thus, an XSLT processor is always free to ignore such
top-level elements, and must ignore a top-level element without giving
an error if it does not recognize the namespace URI. Such elements can
provide, for example,</p>

<ul>

<li><p>information used by extension elements or extension functions
(see <a href="#extension"><b>14 Extensions</b></a>),</p></li>

<li><p>information about what to do with the result tree,</p></li>

<li><p>information about how to obtain the source tree,</p></li>

<li><p>metadata about the stylesheet,</p></li>

<li><p>structured documentation for the stylesheet.</p></li>

</ul>

</div>

<div class="div2">

<h3><a name="result-element-stylesheet"></a>2.3 Literal Result Element as Stylesheet</h3>

<p>A simplified syntax is allowed for stylesheets that consist of only
a single template for the root node.  The stylesheet may consist of
just a literal result element (see <a href="#literal-result-element"><b>7.1.1 Literal Result Elements</b></a>).  Such a stylesheet is equivalent to a
stylesheet with an <code>xsl:stylesheet</code> element containing a
template rule containing the literal result element; the template rule
has a match pattern of <code>/</code>. For example</p>

<div class="exampleInner"><pre>&lt;html xsl:version="1.1"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/TR/xhtml1"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div>

<p>has the same meaning as</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>

<p>A literal result element that is the document element of a
stylesheet must have an <code>xsl:version</code> attribute, which
indicates the version of XSLT that the stylesheet requires.  For this
version of XSLT, the value should be <code>1.1</code>; the
value must be a <a href="http://www.w3.org/TR/xpath#NT-Number">Number</a>.  Other
literal result elements may also have an <code>xsl:version</code>
attribute. When the <code>xsl:version</code> attribute is not equal to
<code>1.0</code> or <code>1.1</code>,
forwards-compatible processing mode is enabled (see <a href="#forwards"><b>2.5 Forwards-Compatible Processing</b></a>).</p>

<p>The allowed content of a literal result element when used as a
stylesheet is no different from when it occurs within a
stylesheet. Thus, a literal result element used as a stylesheet cannot
contain <a title="Top-level" href="#dt-top-level">top-level</a> elements.</p>

<p>In some situations, the only way that a system can recognize that an
XML document needs to be processed by an XSLT processor as an XSLT
stylesheet is by examining the XML document itself.  Using the
simplified syntax makes this harder.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>For example, another XML language (AXL) might also use an
<code>axl:version</code> on the document element to indicate that an
XML document was an AXL document that required processing by an AXL
processor; if a document had both an <code>axl:version</code>
attribute and an <code>xsl:version</code> attribute, it would be
unclear whether the document should be processed by an XSLT processor
or an AXL processor.</p></div>

<p>Therefore, the simplified syntax should not be used for XSLT
stylesheets that may be used in such a situation.  This situation can,
for example, arise when an XSLT stylesheet is transmitted as a message
with a MIME media type of <code>text/xml</code> or
<code>application/xml</code> to a recipient that will use the MIME
media type to determine how the message is processed.</p>

</div>

<div class="div2">

<h3><a name="qname"></a>2.4 Qualified Names</h3>

<p>The name of an internal XSLT object, specifically a named template
(see <a href="#named-templates"><b>6 Named Templates</b></a>), a mode (see <a href="#modes"><b>5.7 Modes</b></a>), an attribute set (see <a href="#attribute-sets"><b>7.1.4 Named Attribute Sets</b></a>), a key (see <a href="#key"><b>12.2 Keys</b></a>), a
decimal-format (see <a href="#format-number"><b>12.3 Number Formatting</b></a>), a variable or a
parameter (see <a href="#variables"><b>11 Variables and Parameters</b></a>) is specified as a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  If it has a prefix, then the
prefix is expanded into a URI reference using the namespace
declarations in effect on the attribute in which the name occurs.  The
<a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
consisting of the local part of the name and the possibly null URI
reference is used as the name of the object.  The default namespace is
<em>not</em> used for unprefixed names.</p>

</div>

<div class="div2">

<h3><a name="forwards"></a>2.5 Forwards-Compatible Processing</h3>

<p>An element enables forwards-compatible mode for itself, its
attributes, its descendants and their attributes if either it is an
<code>xsl:stylesheet</code> element whose <code>version</code>
attribute is not equal to <code>1.0</code> or
<code>1.1</code>, or it is a literal result element that has
an <code>xsl:version</code> attribute whose value is not equal to
<code>1.0</code> or
<code>1.1</code>.  A literal result element
that has an <code>xsl:version</code> attribute whose value is equal to
<code>1.0</code> or <code>1.1</code>
disables forwards-compatible mode for itself, its attributes, its
descendants and their attributes.</p>

<p>If an element is processed in forwards-compatible mode, then:</p>

<ul>

<li><p>if it is a <a title="Top-level" href="#dt-top-level">top-level</a>
element and XSLT 1.1 does not allow such
elements as top-level elements, then the element must be ignored along
with its content;</p></li>

<li><p>if it is an element in a template and XSLT 1.1 does not allow such elements to occur in
templates, then if the element is not instantiated, an error must not
be signaled, and if the element is instantiated, the XSLT must perform
fallback for the element as specified in <a href="#fallback"><b>15 Fallback</b></a>;</p></li>

<li><p>if the element has an attribute that XSLT 1.1 does not allow the element to have or if the
element has an optional attribute with a value that the XSLT 1.1 does not allow the attribute to have, then the
attribute must be ignored.</p></li>

</ul>

<p>Thus, any XSLT 1.1 processor must be
able to process the following stylesheet without error, although the
stylesheet includes elements from the XSLT namespace that are not
defined in this specification:</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &gt;= 17.0"&gt;
        &lt;xsl:exciting-new-17.0-feature/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>If a stylesheet depends crucially on a top-level element
introduced by a version of XSLT after 1.1, then
the stylesheet can use an <code>xsl:message</code> element with
<code>terminate="yes"</code> (see <a href="#message"><b>13 Messages</b></a>) to ensure
that XSLT processors implementing earlier versions of XSLT will not silently ignore the
top-level element. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &lt; 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre></div>
</div>

<p>If an <a title="Expression" href="#dt-expression">expression</a> occurs in
an attribute that is processed in forwards-compatible mode, then an
XSLT processor must recover from errors in the expression as
follows:</p>

<ul>

<li><p>if the expression does not match the syntax allowed by the
XPath grammar, then an error must not be signaled unless the
expression is actually evaluated;</p></li>

<li><p>if the expression calls a function with an unprefixed name
that is not part of the XSLT library, then an error must not be
signaled unless the function is actually called;</p></li>

<li><p>if the expression calls a function with a number of arguments
that XSLT does not allow or with arguments of types that XSLT does not
allow, then an error must not be signaled unless the function is
actually called.</p></li>

</ul>


</div>

<div class="div2">

<h3><a name="N1316"></a>2.6 Combining Stylesheets</h3>

<p>XSLT provides two mechanisms to combine stylesheets:</p>

<blockquote><p>

an inclusion mechanism that allows stylesheets to be combined
without changing the semantics of the stylesheets being combined,
and

<br>an import mechanism that allows stylesheets to override each
other.

</p></blockquote>

<div class="div3">

<h4><a name="include"></a>2.6.1 Stylesheet Inclusion</h4>


  
  
    
  
  


<p>An XSLT stylesheet may include another XSLT stylesheet using an
<code>xsl:include</code> element. The <code>xsl:include</code> element
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet to be included.  A relative URI is resolved
relative to the base URI of the <code>xsl:include</code> element (see
<a href="#base-uri"><b>3.2 Base URI</b></a>).</p>

<p>The <code>xsl:include</code> element is only allowed as a <a title="Top-level" href="#dt-top-level">top-level</a> element.</p>

<p>The inclusion works at the XML tree level.  The resource located by
the <code>href</code> attribute value is parsed as an XML document,
and the children of the <code>xsl:stylesheet</code> element in this
document replace the <code>xsl:include</code> element in the including
document.  The fact that template rules or definitions are included
does not affect the way they are processed.</p>

<p>The included stylesheet may use the simplified syntax described in
<a href="#result-element-stylesheet"><b>2.3 Literal Result Element as Stylesheet</b></a>.  The included stylesheet
is treated the same as the equivalent <code>xsl:stylesheet</code>
element.</p>

<p>It is an error if a stylesheet directly or indirectly includes
itself.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Including a stylesheet multiple times can cause errors
because of duplicate definitions.  Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes
both stylesheet <var>B</var> and stylesheet <var>C</var>, then
<var>A</var> will be included indirectly by <var>D</var> twice.  If
all of <var>B</var>, <var>C</var> and <var>D</var> are used as
independent stylesheets, then the error can be avoided by separating
everything in <var>B</var> other than the inclusion of <var>A</var>
into a separate stylesheet <var>B'</var> and changing <var>B</var> to
contain just inclusions of <var>B'</var> and <var>A</var>, similarly
for <var>C</var>, and then changing <var>D</var> to include
<var>A</var>, <var>B'</var>, <var>C'</var>.</p></div>

</div>

<div class="div3">

<h4><a name="import"></a>2.6.2 Stylesheet Import</h4>


  
    
  
  


<p>An XSLT stylesheet may import another XSLT stylesheet using an
<code>xsl:import</code> element.  Importing a stylesheet is the same
as including it (see <a href="#include"><b>2.6.1 Stylesheet Inclusion</b></a>) except that definitions
and template rules in the importing stylesheet take precedence over
template rules and definitions in the imported stylesheet; this is
described in more detail below.  The <code>xsl:import</code> element
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet to be imported.  A relative URI is resolved
relative to the base URI of the <code>xsl:import</code> element (see
<a href="#base-uri"><b>3.2 Base URI</b></a>).</p>

<p>The <code>xsl:import</code> element is only allowed as a <a title="Top-level" href="#dt-top-level">top-level</a> element.  The
<code>xsl:import</code> element children must precede all other
element children of an <code>xsl:stylesheet</code> element, including
any <code>xsl:include</code> element children.  When
<code>xsl:include</code> is used to include a stylesheet, any
<code>xsl:import</code> elements in the included document are moved up
in the including document to after any existing
<code>xsl:import</code> elements in the including document.</p>

<p>For example,</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre></div>

<p>[<a name="dt-import-tree" title="Import Tree">Definition</a>: The
<code>xsl:stylesheet</code> elements encountered during processing of
a stylesheet that contains <code>xsl:import</code> elements are
treated as forming an <b>import tree</b>.  In the import tree,
each <code>xsl:stylesheet</code> element has one import child for each
<code>xsl:import</code> element that it contains. Any
<code>xsl:include</code> elements are resolved before constructing the
import tree.] [<a name="dt-import-precedence" title="Import Precedence">Definition</a>: An <code>xsl:stylesheet</code> element in the import tree
is defined to have lower <b>import precedence</b> than another
<code>xsl:stylesheet</code> element in the import tree if it would be
visited before that <code>xsl:stylesheet</code> element in a
post-order traversal of the import tree (i.e. a traversal of the
import tree in which an <code>xsl:stylesheet</code> element is visited
after its import children).] Each definition and template
rule has import precedence determined by the
<code>xsl:stylesheet</code> element that contains it.</p>

<p>For example, suppose</p>

<ul>

<li><p>stylesheet <var>A</var> imports stylesheets <var>B</var>
and <var>C</var> in that order;</p></li>

<li><p>stylesheet <var>B</var> imports stylesheet
<var>D</var>;</p></li>

<li><p>stylesheet <var>C</var> imports stylesheet
<var>E</var>.</p></li>

</ul>

<p>Then the order of import precedence (lowest first) is
<var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>,
<var>A</var>.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Since <code>xsl:import</code> elements are required to occur
before any definitions or template rules, an implementation that
processes imported stylesheets at the point at which it encounters the
<code>xsl:import</code> element will encounter definitions and
template rules in increasing order of import precedence.</p></div>

<p>In general, a definition or template rule with higher import
precedence takes precedence over a definition or template rule with
lower import precedence.  This is defined in detail for each kind of
definition and for template rules.</p>

<p>It is an error if a stylesheet directly or indirectly imports
itself. Apart from this, the case where a stylesheet with a particular
URI is imported in multiple places is not treated specially. The
<a title="Import Tree" href="#dt-import-tree">import tree</a> will have a
separate <code>xsl:stylesheet</code> for each place that it is
imported.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>If <code>xsl:apply-imports</code> is used (see <a href="#apply-imports"><b>5.6 Overriding Template Rules</b></a>), the behavior may be different from the
behavior if the stylesheet had been imported only at the place with
the highest <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a>.</p></div>

</div>

</div>

<div class="div2">

<h3><a name="N1715"></a>2.7 Embedding Stylesheets</h3>

<p>Normally an XSLT stylesheet is a complete XML document with the
<code>xsl:stylesheet</code> element as the document element. However,
an XSLT stylesheet may also be embedded in another resource. Two forms
of embedding are possible:</p>

<blockquote><p>

the XSLT stylesheet may be textually embedded in a non-XML
resource, or

<br>the <code>xsl:stylesheet</code> element may occur in an XML
document other than as the document element.

</p></blockquote>

<p>To facilitate the second form of embedding, the
<code>xsl:stylesheet</code> element is allowed to have an ID attribute
that specifies a unique identifier.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>In order for such an attribute to be used with the XPath
id function, it must actually be declared in
the DTD as being an ID.</p></div>

<p>The following example shows how the <code>xml-stylesheet</code>
processing instruction <a href="#XMLSTYLE">[XML Stylesheet]</a> can be used to allow a
document to contain its own stylesheet.  The URI reference uses a
relative URI with a fragment identifier to locate the
<code>xsl:stylesheet</code> element:</p>

<div class="exampleInner"><pre>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet that is embedded in the document to which it is
to be applied or that may be included or imported into a stylesheet that is so embedded typically needs
to contain a template rule that specifies that
<code>xsl:stylesheet</code> elements are to be ignored.</p></div>

</div>

</div>

<div class="div1">

<h2><a name="data-model"></a>3 Data Model</h2>

<p>The data model used by XSLT is the same as that used by <a href="http://www.w3.org/TR/xpath#data-model">XPath</a> with the additions
described in this section.  XSLT operates on source, result and
stylesheet documents using the same data model.  Any two XML documents
that have the same tree will be treated the same by XSLT.</p>

<p>Processing instructions and comments in the stylesheet are ignored:
the stylesheet is treated as if neither processing instruction nodes
nor comment nodes were included in the tree that represents the
stylesheet.</p>

<div class="div2">

<h3><a name="root-node-children"></a>3.1 Root Node Children</h3>

<p>The normal restrictions on the children of the root node are
relaxed for the result tree.  The result tree may have any sequence of
nodes as children that would be possible for an element node. In
particular, it may have text node children, and any number of element
node children. When written out using the XML output method (see
<a href="#output"><b>16 Output</b></a>), it is possible that a result tree will not
be a well-formed XML document; however, it will always be a
well-formed external general parsed entity.</p>

<p>When the source tree is created by parsing a well-formed XML
document, the root node of the source tree will automatically satisfy
the normal restrictions of having no text node children and exactly
one element child.  When the source tree is created in some other way,
for example by using the DOM, the usual restrictions are relaxed for
the source tree as for the result tree.</p>

</div>

<div class="div2">

<h3><a name="base-uri"></a>3.2 Base URI</h3>

<p>Every node also has an associated URI called its base URI, which is
used for resolving attribute values that represent relative URIs into
absolute URIs. The base URI is determined as follows:</p>

<ul>

<li><p>The base URI for a root node is the URI of the document
entity.</p></li>

<li><p>The base URI for an element node is as specified in Section
4.2 of <a href="#XMLBASE">[XMLBASE]</a>.</p></li>

<li><p>The base URI for a processing instruction node is the base
URI that Section 4.3 of <a href="#XMLBASE">[XMLBASE]</a> specifies would be
applicable to a URI reference occurring in the content of the
processing instruction.</p></li>

<li><p>The base URI for a text node, a comment node or an attribute
node is the base URI of the parent of the node.</p></li>

<li><p>The base URI for a namespace node is
implementation-dependent.</p></li>

</ul>

</div>

<div class="div2">

<h3><a name="unparsed-entities"></a>3.3 Unparsed Entities</h3>

<p>The root node has a mapping that gives the URI for each unparsed
entity declared in the document's DTD.  The URI is generated from the
system identifier and public identifier specified in the entity
declaration. The XSLT processor may use the public identifier to
generate a URI for the entity instead of the URI specified in the
system identifier.  If the XSLT processor does not use the public
identifier to generate the URI, it must use the system identifier; if
the system identifier is a relative URI, it must be resolved into an
absolute URI using the URI of the resource containing the entity
declaration as the base URI <a href="#RFC2396">[RFC2396]</a>.</p>

</div>

<div class="div2">

<h3><a name="strip"></a>3.4 Whitespace Stripping</h3>

<p>After the tree for a source document or stylesheet document has
been constructed, but before it is otherwise processed by XSLT,
some text nodes are stripped.  A text node is never stripped
unless it contains only whitespace characters.  Stripping the text
node removes the text node from the tree.  The stripping process takes
as input a set of element names for which whitespace must be
preserved.  The stripping process is applied to both stylesheets and
source documents, but the set of whitespace-preserving element names
is determined differently for stylesheets and for source
documents.</p>

<p>A text node is preserved if any of the following apply:</p>

<ul>

<li><p>The element name of the parent of the text node is in the set
of whitespace-preserving element names.</p></li>

<li><p>The text node contains at least one non-whitespace character.
As in XML, a whitespace character is #x20, #x9, #xD or #xA.</p></li>

<li><p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of
<code>default</code>.</p></li>

</ul>

<p>Otherwise, the text node is stripped.</p>

<p>The <code>xml:space</code> attributes are not stripped from the
tree.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>This implies that if an <code>xml:space</code> attribute is
specified on a literal result element, it will be included in the
result.</p></div>

<p>For stylesheets, the set of whitespace-preserving element names
consists of just <code>xsl:text</code>.</p>


  
  
    
  
  



  
  
    
  
  


<p id="diff-4">For source documents, the set of
whitespace-preserving element names is specified by
<code>xsl:strip-space</code> and <code>xsl:preserve-space</code>
<a title="Top-level" href="#dt-top-level">top-level</a> elements.  Whether an
element name is included in the set of whitespace-preserving names is
determined by the best match amongst <code>xsl:strip-space</code> or
<code>xsl:preserve-space</code> elements: it is included if and only
if there is no match or the best match is an
<code>xsl:preserve-space</code> element.  The
<code>xsl:strip-space</code> and <code>xsl:preserve-space</code>
elements each have an <code>elements</code> attribute whose value is a
whitespace-separated list of <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a>s; an element name matches an
<code>xsl:strip-space</code> or <code>xsl:preserve-space</code>
element if it matches one of the <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a>s. An element matches a <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> if and only if the <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> would be true for the
element as an <a href="http://www.w3.org/TR/xpath#node-tests">XPath node
test</a>.  When more than one <code>xsl:strip-space</code> and
<code>xsl:preserve-space</code> element matches, the best matching
element is determined by the best matching <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a>.  This is determined in the
same way as with template rules:</p>

<ul>

<li><p>First, any match with lower <a title="Import Precedence" href="#dt-import-precedence">import precedence</a> than another
match is ignored.</p></li>

<li><p id="diff-5">Next, any match that has a lower
<a title="Default Priority" href="#dt-default-priority">default priority</a> than the
<a title="Default Priority" href="#dt-default-priority">default priority</a> of
another match is ignored.</p></li>

</ul>

<p>It is an error if this leaves more than one match.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing, from amongst the matches that are left, the
one that occurs last in the stylesheet.</p>

</div>

<div class="div2">

<h3><a name="namespace-fixup"></a>3.5 Namespace Fixup</h3>

<p>In a tree constructed by parsing an XML document, the following
constraints relating to namespace nodes will be satisfied:</p>

<ul>

<li><p>If an element node has an expanded-name with a non-null
namespace URI, then that element node will have at least one namespace
node whose string-value is the same as that namespace URI.</p></li>

<li><p>If an attribute node has an expanded-name with a non-null
namespace URI, then the parent element of that attribute will have at
least one namespace node whose string-value is the same as that
namespace URI and whose expanded-name has a non-empty local
part.</p></li>

<li><p>If an element node has a namespace node with an expanded-name
with a non-empty local part, then every child element of that element
will also have a namespace node with that expanded-name (possibly with
a different string-value).</p></li>

<li><p>Every element has a namespace node whose expanded-name has
local-part <code>xml</code> and whose string-value is
<code>http://www.w3.org/XML/1998/namespace</code>.</p></li>

</ul>

<p>However, when a tree is being constructed as the result of an XSLT
transformation, these constraints may not be satisfied. In particular,
since <code>xsl:element</code> and <code>xsl:attribute</code>
instructions do not create namespace nodes, they will often cause
these constraints not to be satisfied. [<a name="dt-namespace-fixup" title="Namespace Fixup">Definition</a>: The process of
<b>namespace fixup</b> transforms a result tree by adding
namespace nodes so that it satisfies these constraints.]
What namespace nodes are added and where they are added by
namespace fixup is implementation-dependent, provided that the
resulting tree satisfies the constraints and provided that all
namespaces nodes in the resulting tree are <b>allowable</b>,
where a namespace node is allowable if any of the following conditions
applies:</p>

<ul>

<li><p>The namespace node was in the tree before namespace
fixup.</p></li>

<li><p>The local-part of the expanded-name of the namespace node is
<code>xml</code>.</p></li>

<li><p>The namespace node has a string-value equal to the namespace
URI of the expanded-name of the element that is the parent of the
namespace node.</p></li>

<li><p>The namespace node has a string-value equal to the namespace
URI of the expanded-name of an attribute of the element that is the
parent of the namespace node; this applies only if the local part of
the expanded-name of the namespace node is non-empty.</p></li>

<li><p>The element that is the parent of the namespace node has a
parent element with a namespace node that is allowable and that has
the same expanded-name and same string-value as the other namespace
node; this applies only if the local part of the expanded-name of the
namespace node is non-empty.</p></li>

</ul>

<p>Namespace fixup must not result in an element having multiple
namespace nodes with the same expanded-name.</p>

<p>Namespace fixup is performed in two situations:</p>

<ul>

<li><p>It is applied before a result tree is output (see <a href="#output"><b>16 Output</b></a>).</p></li>

<li><p>It is applied when a tree is constructed and bound to a
variable by a variable-binding element with content (see <a href="#variable-values"><b>11.2 Values of Variables and Parameters</b></a>).</p></li>

</ul>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">What about stylesheet parameters that are
node-sets?</td></tr></table>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">What about extension functions returning
node-sets?</td></tr></table>

</div>

</div>

<div class="div1">

<h2><a name="N2221"></a>4 Expressions</h2>

<p>XSLT uses the expression language defined by XPath <a href="#XPATH">[XPath]</a>.  Expressions are used in XSLT for a variety of purposes
including:</p>

<blockquote><p>
selecting nodes for processing;
<br>specifying conditions for different ways of processing a node;
<br>generating text to be inserted in the result tree.
</p></blockquote>

<p>[<a name="dt-expression" title="Expression">Definition</a>: An
<b>expression</b> must match the XPath production <a href="http://www.w3.org/TR/xpath#NT-Expr">Expr</a>.]</p>

<p>Expressions occur as the value of certain attributes on
XSLT-defined elements and within curly braces in <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute value
template</a>s.</p>

<p>In XSLT, an outermost expression (i.e. an expression that is not
part of another expression) gets its context as follows:</p>

<ul>

<li><p>the context node comes from the <a title="Current Node" href="#dt-current-node">current node</a></p></li>

<li><p>the context position comes from the position of the <a title="Current Node" href="#dt-current-node">current node</a> in the <a title="Current Node List" href="#dt-current-node-list">current node list</a>; the first
position is 1</p></li>

<li><p>the context size comes from the size of the <a title="Current Node List" href="#dt-current-node-list">current node list</a></p></li>

<li><p>the variable bindings are the bindings in scope on the
element which has the attribute in which the expression occurs (see
<a href="#variables"><b>11 Variables and Parameters</b></a>)</p></li>

<li><p>the set of namespace declarations are those in scope on the
element which has the attribute in which the expression occurs;
this includes the implicit declaration of the prefix <code>xml</code>
required by the the XML Namespaces Recommendation <a href="#XMLNAMES">[XML Names]</a>;
the default
namespace (as declared by <code>xmlns</code>) is not part of this
set</p></li>

<li><p>the function library consists of the core function library
together with the additional functions defined in <a href="#add-func"><b>12 Additional Functions</b></a> and extension functions as described in <a href="#extension"><b>14 Extensions</b></a>; it is an error for an expression to include a call
to any other function</p></li>

</ul>

</div>

<div class="div1">

<h2><a name="rules"></a>5 Template Rules</h2>

<div class="div2">

<h3><a name="N2337"></a>5.1 Processing Model</h3>

<p>A list of source nodes is processed to create a result tree
fragment.  The result tree is constructed by processing a list
containing just the root node.  A list of source nodes is processed by
appending the result tree structure created by processing each of the
members of the list in order.  A node is processed by finding all the
template rules with patterns that match the node, and choosing the
best amongst them; the chosen rule's template is then instantiated
with the node as the <a title="Current Node" href="#dt-current-node">current
node</a> and with the list of source nodes as the <a title="Current Node List" href="#dt-current-node-list">current node list</a>.  A template
typically contains instructions that select an additional list of
source nodes for processing.  The process of matching, instantiation
and selection is continued recursively until no new source nodes are
selected for processing.</p>

<p>Implementations are free to process the source document in any way
that produces the same result as if it were processed using this
processing model.</p>

</div>

<div class="div2">

<h3><a name="patterns"></a>5.2 Patterns</h3>

<p>[<a name="dt-pattern" title="Pattern">Definition</a>: Template rules identify the
nodes to which they apply by using a <b>pattern</b>.  As well as
being used in template rules, patterns are used for numbering (see
<a href="#number"><b>7.7 Numbering</b></a>) and for declaring keys (see <a href="#key"><b>12.2 Keys</b></a>).  A pattern specifies a set of conditions on a node.  A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for expressions. In
particular, location paths that meet certain restrictions can be used
as patterns.  An expression that is also a pattern always evaluates to
an object of type node-set.  A node matches a pattern if the node is a
member of the result of evaluating the pattern as an expression with
respect to some possible context; the possible contexts are those
whose context node is the node being matched or one of its
ancestors.]</p>

<p>Here are some examples of patterns:</p>

<ul>

<li><p><code>para</code> matches any <code>para</code> element</p></li>

<li><p><code>*</code> matches any element</p></li>

<li><p><code>chapter|appendix</code> matches any
<code>chapter</code> element and any <code>appendix</code>
element</p></li>

<li><p><code>olist/item</code> matches any <code>item</code> element with
an <code>olist</code> parent</p></li>

<li><p><code>appendix//para</code> matches any <code>para</code> element with
an <code>appendix</code> ancestor element</p></li>

<li><p><code>/</code> matches the root node</p></li>

<li><p><code>text()</code> matches any text node</p></li>

<li><p><code>processing-instruction()</code> matches any processing
instruction</p></li>

<li><p><code>node()</code> matches any node other than an attribute
node and the root node</p></li>

<li><p><code>id("W11")</code> matches the element with unique ID
<code>W11</code></p></li>

<li><p><code>para[1]</code> matches any <code>para</code> element
that is the first <code>para</code> child element of its
parent</p></li>

<li><p><code>*[position()=1 and self::para]</code> matches any
<code>para</code> element that is the first child element of its
parent</p></li>

<li><p><code>para[last()=1]</code> matches any <code>para</code>
element that is the only <code>para</code> child element of its
parent</p></li>

<li><p><code>items/item[position()&gt;1]</code> matches any
<code>item</code> element that has an <code>items</code> parent and that is not the
first <code>item</code> child of its parent</p></li>

<li><p><code>item[position() mod 2 = 1]</code> would be true for any
<code>item</code> element that is an odd-numbered <code>item</code>
child of its parent.</p></li>

<li><p><code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element that
has a <code>class</code> attribute with value
<code>appendix</code></p></li>

<li><p><code>@class</code> matches any <code>class</code> attribute
(<em>not</em> any element that has a <code>class</code>
attribute)</p></li>

<li><p><code>@*</code> matches any attribute</p></li>

</ul>

<p>A pattern must match the grammar for <a href="#NT-Pattern">Pattern</a>.  A <a href="#NT-Pattern">Pattern</a> is
a set of location path patterns separated by <code>|</code>.  A
location path pattern is a location path whose steps all use only the
<code>child</code> or <code>attribute</code> axes.  Although patterns
must not use the <code>descendant-or-self</code> axis, patterns may
use the <code>//</code> operator as well as the <code>/</code>
operator.  Location path patterns can also start with an
id or <code>key</code> function call
with a literal argument.  Predicates in a pattern can use arbitrary
expressions just like predicates in a location path.</p>


<h5>Patterns</h5><table class="scrap" summary="Scrap"><tbody>
<tr valign="baseline"><td><a name="NT-Pattern"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code>Pattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#NT-LocationPathPattern">LocationPathPattern</a></code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-Pattern">Pattern</a> '|' <a href="#NT-LocationPathPattern">LocationPathPattern</a></code></td></tr>
<tr valign="baseline"><td><a name="NT-LocationPathPattern"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code>LocationPathPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'/' <a href="#NT-RelativePathPattern">RelativePathPattern</a>?</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-IdKeyPattern">IdKeyPattern</a> (('/' | '//') <a href="#NT-RelativePathPattern">RelativePathPattern</a>)?</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| '//'? <a href="#NT-RelativePathPattern">RelativePathPattern</a></code></td></tr>
<tr valign="baseline"><td><a name="NT-IdKeyPattern"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code>IdKeyPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'id' '(' <a href="http://www.w3.org/TR/xpath#NT-Literal">Literal</a> ')'</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| 'key' '(' <a href="http://www.w3.org/TR/xpath#NT-Literal">Literal</a> ',' <a href="http://www.w3.org/TR/xpath#NT-Literal">Literal</a> ')'</code></td></tr>
<tr valign="baseline"><td><a name="NT-RelativePathPattern"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code>RelativePathPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#NT-StepPattern">StepPattern</a></code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-RelativePathPattern">RelativePathPattern</a> '/' <a href="#NT-StepPattern">StepPattern</a></code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-RelativePathPattern">RelativePathPattern</a> '//' <a href="#NT-StepPattern">StepPattern</a></code></td></tr>
<tr valign="baseline"><td><a name="NT-StepPattern"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code>StepPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
<a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a>
<a href="http://www.w3.org/TR/xpath#NT-Predicate">Predicate</a>*
</code></td></tr>
<tr valign="baseline"><td><a name="NT-ChildOrAttributeAxisSpecifier"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code>ChildOrAttributeAxisSpecifier</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/xpath#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</a></code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| ('child' | 'attribute') '::'</code></td></tr>
</tbody></table>

<p>A pattern is defined to match a node if and only if there is
possible context such that when the pattern is evaluated as an
expression with that context, the node is a member of the resulting
node-set.  When a node is being matched, the possible contexts have a
context node that is the node being matched or any ancestor of that
node, and a context node list containing just the context node.</p>

<p>For example, <code>p</code> matches any <code>p</code> element,
because for any <code>p</code> if the expression <code>p</code> is
evaluated with the parent of the <code>p</code> element as context the
resulting node-set will contain that <code>p</code> element as one of
its members.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>This matches even a <code>p</code> element that is the
document element, since the document root is the parent of the
document element.</p></div>

<p>Although the semantics of patterns are specified indirectly in
terms of expression evaluation, it is easy to understand the meaning
of a pattern directly without thinking in terms of expression
evaluation.  In a pattern, <code>|</code> indicates alternatives; a
pattern with one or more <code>|</code> separated alternatives matches
if any one of the alternative matches.  A pattern that consists of a
sequence of <a href="#NT-StepPattern">StepPattern</a>s separated by
<code>/</code> or <code>//</code> is matched from right to left.  The
pattern only matches if the rightmost <a href="#NT-StepPattern">StepPattern</a> matches and a suitable element
matches the rest of the pattern; if the separator is <code>/</code>
then only the parent is a suitable element; if the separator is
<code>//</code>, then any ancestor is a suitable element.  A <a href="#NT-StepPattern">StepPattern</a> that uses the child axis matches
if the <a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a> is true for the
node and the node is not an attribute node.  A <a href="#NT-StepPattern">StepPattern</a> that uses the attribute axis
matches if the <a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a> is true
for the node and the node is an attribute node.  When <code>[]</code>
is present, then the first <a href="http://www.w3.org/TR/xpath#NT-PredicateExpr">PredicateExpr</a> in a <a href="#NT-StepPattern">StepPattern</a> is evaluated with the node being
matched as the context node and the siblings of the context node that
match the <a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a> as the
context node list, unless the node being matched is an attribute node,
in which case the context node list is all the attributes that have
the same parent as the attribute being matched and that match the <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a>.</p>

<p>For example</p>

<div class="exampleInner"><pre>appendix//ulist/item[position()=1]</pre></div>

<p>matches a node if and only if all of the following are true:</p>

<ul>

<li><p>the <a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a> <code>item</code> is
true for the node and the node is not an attribute; in other words the
node is an <code>item</code> element</p></li>

<li><p>evaluating the <a href="http://www.w3.org/TR/xpath#NT-PredicateExpr">PredicateExpr</a>
<code>position()=1</code> with the node as context node and the
siblings of the node that are <code>item</code> elements as the
context node list yields true</p></li>

<li><p>the node has a parent that matches
<code>appendix//ulist</code>; this will be true if the parent is a
<code>ulist</code> element that has an <code>appendix</code> ancestor
element.</p></li>

</ul>

</div>

<div class="div2">

<h3><a name="N2967"></a>5.3 Defining Template Rules</h3>


  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
    
  


<p>A template rule is specified with the <code>xsl:template</code>
element. The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a> that identifies the source node or nodes
to which the rule applies.  The <code>match</code> attribute is
required unless the <code>xsl:template</code> element has a
<code>name</code> attribute (see <a href="#named-templates"><b>6 Named Templates</b></a>).
It is an error for the value of the <code>match</code> attribute to
contain a <a href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</a>. The
content of the <code>xsl:template</code> element is the template that
is instantiated when the template rule is applied.</p>

<p>For example, an XML document might contain:</p>

<div class="exampleInner"><pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre></div>

<p>The following template rule matches <code>emph</code> elements and
produces a <code>fo:inline-sequence</code> formatting object with a
<code>font-weight</code> property of <code>bold</code>.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:inline-sequence font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;
</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Examples in this document use the <code>fo:</code> prefix for
the namespace <code>http://www.w3.org/1999/XSL/Format</code>, which is
the namespace of the formatting objects defined in <a href="#XSL">[XSL]</a>.</p></div>

<p>As described next, the <code>xsl:apply-templates</code> element
recursively processes the children of the source element.</p>

</div>

<div class="div2">

<h3><a name="N3115"></a>5.4 Applying Template Rules</h3>


  
  
    
  
  
    
  
  
    
    
  


<p>This example creates a block for a <code>chapter</code> element and
then processes its immediate children.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<p>In the absence of a <code>select</code> attribute, the
<code>xsl:apply-templates</code> instruction processes all of the
children of the current node, including text nodes.  However, text
nodes that have been stripped as specified in <a href="#strip"><b>3.4 Whitespace Stripping</b></a>
will not be processed.  If stripping of whitespace nodes has not been
enabled for an element, then all whitespace in the content of the
element will be processed as text, and thus whitespace
between child elements will count in determining the position of a
child element as returned by the position
function.</p>

<p>A <code>select</code> attribute can be used to process nodes
selected by an expression instead of processing all children.  The
value of the <code>select</code> attribute is an <a title="Expression" href="#dt-expression">expression</a>.  The expression must
evaluate to a node-set.  The selected set of nodes is processed in
document order, unless a sorting specification is present (see
<a href="#sorting"><b>10 Sorting</b></a>).  The following example processes all of the
<code>author</code> children of the <code>author-group</code>:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The following example processes all of the <code>given-name</code>s
of the <code>author</code>s that are children of
<code>author-group</code>:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre></div>

<p>This example processes all of the <code>heading</code> descendant
elements of the <code>book</code> element.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<p>It is also possible to process elements that are not descendants of
the current node.  This example assumes that a <code>department</code>
element has <code>group</code> children and <code>employee</code>
descendants. It finds an employee's department and then processes
the <code>group</code> children of the <code>department</code>.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<p>Multiple <code>xsl:apply-templates</code> elements can be used within a
single template to do simple reordering.  The following example
creates two HTML tables. The first table is filled with domestic sales
while the second table is filled with foreign sales.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p>

<p>It is possible for there to be two matching descendants where one
is a descendant of the other.  This case is not treated specially:
both descendants will be processed as usual. For example, given a
source document</p>

<div class="exampleInner"><pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre></div>

<p>the rule</p>

<div class="exampleInner"><pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>will process both the outer <code>div</code> and inner <code>div</code>
elements.</p>

</div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Typically, <code>xsl:apply-templates</code> is used to
process only nodes that are descendants of the current node.  Such use
of <code>xsl:apply-templates</code> cannot result in non-terminating
processing loops.  However, when <code>xsl:apply-templates</code> is
used to process elements that are not descendants of the current node,
the possibility arises of non-terminating loops. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>Implementations may be able to detect such loops in some cases, but
the possibility exists that a stylesheet may enter a non-terminating
loop that an implementation is unable to detect. This may present a
denial of service security risk.</p></div>

</div>

<div class="div2">

<h3><a name="conflict"></a>5.5 Conflict Resolution for Template Rules</h3>

<p>It is possible for a source node to match more than one template
rule. The template rule to be used is determined as follows:</p>

<ol>

<li><p>First, all matching template rules that have lower <a title="Import Precedence" href="#dt-import-precedence">import precedence</a> than the
matching template rule or rules with the highest import precedence are
eliminated from consideration.</p></li>

<li><p>Next, all matching template rules that have lower priority
than the matching template rule or rules with the highest priority are
eliminated from consideration.  The priority of a template rule is
specified by the <code>priority</code> attribute on the template rule.
The value of this must be a real number (positive or negative),
matching the production <a href="http://www.w3.org/TR/xpath#NT-Number">Number</a>
with an optional leading minus sign (<code>-</code>).  [<a name="dt-default-priority" title="Default Priority">Definition</a>: The <b>default
priority</b> is computed as follows:]</p>

<ul>

<li><p>If the pattern contains multiple alternatives separated by
<code>|</code>, then it is treated equivalently to a set of template
rules, one for each alternative.</p></li>

<li><p>If the pattern has the form of a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> preceded by a <a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
or has the form
<code>processing-instruction(</code><a href="http://www.w3.org/TR/xpath#NT-Literal">Literal</a><code>)</code> preceded by a <a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>,
then the priority is 0.</p></li>

<li><p>If the pattern has the form <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><code>:*</code> preceded by a
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>,
then the priority is -0.25.</p></li>

<li><p>Otherwise, if the pattern consists of just a <a href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</a> preceded by a <a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>,
then the priority is -0.5.</p></li>

<li><p>Otherwise, the priority is 0.5.</p></li>

</ul>

<p>Thus, the most common kind of pattern (a pattern that tests for a
node with a particular type and a particular expanded-name) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node with a particular type and an expanded-name with a
particular namespace URI) has priority -0.25.  Patterns less specific
than this (patterns that just tests for nodes with particular types)
have priority -0.5.  Patterns more specific than the most common kind
of pattern have priority 0.5.</p>

</li>

</ol>

<p>It is an error if this leaves more than one matching template
rule.  An XSLT processor may signal the error; if it does not signal
the error, it must recover by choosing, from amongst the matching
template rules that are left, the one that occurs last in the
stylesheet.</p>

</div>

<div class="div2">

<h3><a name="apply-imports"></a>5.6 Overriding Template Rules</h3>


  
  


<p>A template rule that is being used to override a template rule in
an imported stylesheet (see <a href="#conflict"><b>5.5 Conflict Resolution for Template Rules</b></a>) can use the
<code>xsl:apply-imports</code> element to invoke the overridden
template rule.</p>

<p>[<a name="dt-current-template-rule" title="Current Template Rule">Definition</a>: At any point in the processing of a stylesheet, there is a
<b>current template rule</b>.  Whenever a template rule is
chosen by matching a pattern, the template rule becomes the current
template rule for the instantiation of the rule's template. When an
<code>xsl:for-each</code> element is instantiated, the current
template rule becomes null for the instantiation of the content of the
<code>xsl:for-each</code> element.]</p>

<p><code>xsl:apply-imports</code> processes the current node using
only template rules that were imported into the stylesheet element
containing the current template rule; the node is processed in the
current template rule's mode.
An <code>xsl:apply-imports</code> element may use
<code>xsl:with-param</code> child elements to pass
parameters to the matching template rule's template
(see <a href="#with-param"><b>11.6 Passing Parameters to Templates</b></a>). It is an error if
<code>xsl:apply-imports</code> is instantiated when the current
template rule is null.</p>

<p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
template rule for <code>example</code> elements:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</pre></div>

<p>Another stylesheet could import <code>doc.xsl</code> and modify the
treatment of <code>example</code> elements as follows:</p>

<div class="exampleInner"><pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The combined effect would be to transform an <code>example</code>
into an element of the form:</p>

<div class="exampleInner"><pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre></div>

</div>

<div class="div2">

<h3><a name="modes"></a>5.7 Modes</h3>

<p>Modes allow an element to be processed multiple times, each time
producing a different result.</p>

<p>Both <code>xsl:template</code> and <code>xsl:apply-templates</code>
have an optional <code>mode</code> attribute.  The value of the
<code>mode</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>. If <code>xsl:template</code> does not have
a <code>match</code> attribute, it must not have a <code>mode</code>
attribute.  If an <code>xsl:apply-templates</code> element has a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that have a
<code>mode</code> attribute with the same value; if an
<code>xsl:apply-templates</code> element does not have a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that do not have a
<code>mode</code> attribute.</p>

</div>

<div class="div2">

<h3><a name="built-in-rule"></a>5.8 Built-in Template Rules</h3>

<p>There is a built-in template rule to allow recursive processing to
continue in the absence of a successful pattern match by an explicit
template rule in the stylesheet.  This template rule applies to both
element nodes and the root node.  The following shows the equivalent
of the built-in template rule:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>There is also a built-in template rule for each mode, which allows
recursive processing to continue in the same mode in the absence of a
successful pattern match by an explicit template rule in the
stylesheet.  This template rule applies to both element nodes and the
root node.  The following shows the equivalent of the built-in
template rule for mode <code><var>m</var></code>.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="*|/" mode="<var>m</var>"&gt;
  &lt;xsl:apply-templates mode="<var>m</var>"/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>There is also a built-in template rule for text and attribute nodes
that copies text through:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The built-in template rule for processing instructions and comments
is to do nothing.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="processing-instruction()|comment()"/&gt;</pre></div>

<p>The built-in template rule for namespace nodes is also to do
nothing. There is no pattern that can match a namespace node; so, the
built-in template rule is the only template rule that is applied for
namespace nodes.</p>

<p>The built-in template rules are treated as if they were imported
implicitly before the stylesheet and so have lower <a title="Import Precedence" href="#dt-import-precedence">import precedence</a> than all other
template rules.  Thus, the author can override a built-in template
rule by including an explicit template rule.</p>

</div>


</div>

<div class="div1">

<h2><a name="named-templates"></a>6 Named Templates</h2>


  
  
    
  
  


<p>Templates can be invoked by name.  An <code>xsl:template</code>
element with a <code>name</code> attribute specifies a named template.
The value of the <code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>. If an <code>xsl:template</code> element has
a <code>name</code> attribute, it may, but need not, also have a
<code>match</code> attribute.  An <code>xsl:call-template</code>
element invokes a template by name; it has a required
<code>name</code> attribute that identifies the template to be
invoked.  Unlike <code>xsl:apply-templates</code>,
<code>xsl:call-template</code> does not change the current node or the
current node list.</p>

<p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
<code>xsl:template</code> element do not affect whether the template
is invoked by an <code>xsl:call-template</code> element.  Similarly,
the <code>name</code> attribute on an <code>xsl:template</code>
element does not affect whether the template is invoked by an
<code>xsl:apply-templates</code> element.</p>

<p>It is an error if a stylesheet contains more than one template with
the same name and same <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a>.</p>

</div>


<div class="div1">

<h2><a name="N3791"></a>7 Creating the Result Tree</h2>

<p>This section describes instructions that directly create nodes in
the result tree.</p>

<div class="div2">

<h3><a name="N3799"></a>7.1 Creating Elements and Attributes</h3>

<div class="div3">

<h4><a name="literal-result-element"></a>7.1.1 Literal Result Elements</h4>

<p>In a template, an element in the stylesheet that does not belong to
the XSLT namespace and that is not an extension element (see <a href="#extension-element"><b>14.1 Using Extension Elements</b></a>) is instantiated to create an element node
with the same <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>.  The content
of the element is a template, which is instantiated to give the
content of the created element node. The created element node will
have the attribute nodes that were present on the element node in the
stylesheet tree, other than attributes with names in the XSLT
namespace.</p>

<p>The created element node will also have a copy of the namespace
nodes that were present on the element node in the stylesheet tree
with the exception of any namespace node whose string-value is the
XSLT namespace URI (<code>http://www.w3.org/1999/XSL/Transform</code>), a
namespace URI declared as an extension namespace (see <a href="#extension-element"><b>14.1 Using Extension Elements</b></a>), or a namespace URI designated as an
excluded namespace.  A namespace URI is designated as an excluded
namespace by using an <code>exclude-result-prefixes</code> attribute
on an <code>xsl:stylesheet</code> element or an
<code>xsl:exclude-result-prefixes</code> attribute on a literal result
element.  The value of both these attributes is a whitespace-separated
list of namespace prefixes. The namespace bound to each of the
prefixes is designated as an excluded namespace.  It is an error if
there is no namespace bound to the prefix on the element bearing the
<code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
excluded namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an excluded
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>When a stylesheet uses a namespace declaration only for the
purposes of addressing the source tree, specifying the prefix in the
<code>exclude-result-prefixes</code> attribute will avoid superfluous
namespace declarations in the result tree.</p></div>

<p>The value of an attribute of a literal result element is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>: it can contain expressions contained
in curly braces (<code>{}</code>).</p>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Add note warning against using AVTs with
<code>xml:base</code>.</td></tr></table>

<p>[<a name="dt-literal-namespace-uri" title="Literal Namespace URI">Definition</a>: A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a <b>literal
namespace URI</b>.] This applies to:</p>

<ul>

<li><p>the namespace URI in the expanded-name of a literal
result element in the stylesheet</p></li>

<li><p>the namespace URI in the expanded-name of an attribute
specified on a literal result element in the stylesheet</p></li>

<li><p>the string-value of a namespace node on a literal result
element in the stylesheet</p></li>

</ul>


  
  
    
    
  
  
    
    
  
  


<p>[<a name="dt-alias" title="Alias">Definition</a>: A stylesheet can use the
<code>xsl:namespace-alias</code> element to declare that one namespace
URI is an <b>alias</b> for another namespace URI.] When
a <a title="Literal Namespace URI" href="#dt-literal-namespace-uri">literal namespace
URI</a> has been declared to be an alias for another namespace
URI, then the namespace URI in the result tree will be the namespace
URI that the literal namespace URI is an alias for, instead of the
literal namespace URI itself.  The <code>xsl:namespace-alias</code>
element declares that the namespace URI bound to the prefix specified
by the <code>stylesheet-prefix</code> attribute is an alias for the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute.  Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace URI
that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the result tree.  The default
namespace (as declared by <code>xmlns</code>) may be specified by
using <code>#default</code> instead of a prefix.  If a namespace URI
is declared to be an alias for multiple different namespace URIs, then
the declaration with the highest <a title="Import Precedence" href="#dt-import-precedence">import precedence</a> is used. It is
an error if there is more than one such declaration.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing, from amongst the declarations with the
highest import precedence, the one that occurs last in the
stylesheet.</p>

<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use the XSLT namespace URI, the
stylesheet must use an alias.  For example, the stylesheet</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet
  version="1.1"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div>

<p>will generate an XSLT stylesheet from a document of the form:</p>

<div class="exampleInner"><pre>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI.  For example, literal result elements
belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security
software; using an alias for the namespace would avoid the possibility
of such mishandling.</p></div>

</div>

<div class="div3">

<h4><a name="N4021"></a>7.1.2 Creating Elements with <code>xsl:element</code></h4>


  
  
    
      
    
  
  
    
      
    
  
  
    
  
  


<p>The <code>xsl:element</code> element allows an element to be
created with a computed name.  The <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
element to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.  The
content of the <code>xsl:element</code> element is a template for the
attributes and children of the created element.</p>

<p>The <code>name</code> attribute is interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute value template</a>.
It is an error if the string that results from instantiating the
attribute value template is not a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  An XSLT processor may signal
the error; if it does not signal the error, then it must recover
by making the result of instantiating the <code>xsl:element</code>
element be the sequence of nodes created by instantiating
the content of the  <code>xsl:element</code> element, excluding
any initial attribute nodes. If the <code>namespace</code> attribute is
not present then the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:element</code> element, including any default
namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>. The string that results from instantiating
the attribute value template should be a URI reference.  It is not an
error if the string is not a syntactically legal URI reference.  If
the string is empty, then the expanded-name of the element has a null
namespace URI.  Otherwise, the string is used as the namespace URI of
the expanded-name of the element to be created. The local part of the
<a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the element to be created.</p>

<p>XSLT processors may make use of the prefix of the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created element as XML; however, they are not required
to do so.</p>

</div>

<div class="div3">

<h4><a name="creating-attributes"></a>7.1.3 Creating Attributes with <code>xsl:attribute</code></h4>


  
  
    
      
    
  
  
    
      
    
  
  


<p>The <code>xsl:attribute</code> element can be used to add
attributes to result elements whether created by literal result
elements in the stylesheet or by instructions such as
<code>xsl:element</code>. The <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
attribute to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.
Instantiating an <code>xsl:attribute</code> element adds an attribute
node to the containing result element node. The content of the
<code>xsl:attribute</code> element is a template for the value of the
created attribute.</p>

<p>The <code>name</code> attribute is interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute value template</a>.
It is an error if the string that results from instantiating the
attribute value template is not a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> or is the string
<code>xmlns</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by not adding the attribute
to the result tree. If the <code>namespace</code> attribute is not
present, then the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:attribute</code> element, <em>not</em>
including any default namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>. The string that results from instantiating
it should be a URI reference.  It is not an error if the string is not
a syntactically legal URI reference.  If the string is empty, then the
expanded-name of the attribute has a null namespace URI.  Otherwise,
the string is used as the namespace URI of the expanded-name of the
attribute to be created. The local part of the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the attribute to be created.</p>

<p>XSLT processors may make use of the prefix of the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created attribute as XML; however, they are not
required to do so and, if the prefix is <code>xmlns</code>, they must
not do so. Thus, although it is not an error to do:</p>

<div class="exampleInner"><pre>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</pre></div>

<p>it will not result in a namespace declaration being output.</p>

<p>Adding an attribute to an element replaces any existing attribute
of that element with the same expanded-name.</p>

<p>The following are all errors:</p>

<ul>

<li><p>Adding an attribute to an element after children have been
added to it; implementations may either signal the error or ignore the
attribute.</p></li>

<li><p>Adding an attribute to a node that is not an element;
implementations may either signal the error or ignore the
attribute.</p></li>

<li><p>Creating nodes other than text nodes during the instantiation
of the content of the <code>xsl:attribute</code> element;
implementations may either signal the error or ignore the offending
nodes together with their
content.</p></li>

</ul>

<div class="note"><p class="prefix"><b>Note:</b></p><p>When an <code>xsl:attribute</code> contains a text node with
a newline, then the XML output must contain a character reference.
For example,</p>

<div class="exampleInner"><pre>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</pre></div>

<p>will result in the output</p>

<div class="exampleInner"><pre>a="x&amp;#xA;y"</pre></div>

<p>(or with any equivalent character reference). The XML output cannot
be</p>

<div class="exampleInner"><pre>a="x
y"</pre></div>

<p>This is because XML 1.0 requires newline characters in attribute
values to be normalized into spaces but requires character references
to newline characters not to be normalized.  The attribute values in
the data model represent the attribute value after normalization.  If
a newline occurring in an attribute value in the tree were output as a
newline character rather than as character reference, then the
attribute value in the tree created by reparsing the XML would contain
a space not a newline, which would mean that the tree had not been
output correctly.</p></div>

</div>

<div class="div3">


<h4><a name="attribute-sets"></a>7.1.4 Named Attribute Sets</h4>


  
  
    
  
  
    
  
  


<p>The <code>xsl:attribute-set</code> element defines a named set of
attributes.  The <code>name</code> attribute specifies the name of the
attribute set.  The value of the <code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>. The content of the <code>xsl:attribute-set</code>
element consists of zero or more <code>xsl:attribute</code> elements
that specify the attributes in the set.</p>

<p>Attribute sets are used by specifying a
<code>use-attribute-sets</code> attribute on <code>xsl:element</code>,
<code>xsl:copy</code> (see <a href="#copying"><b>7.5 Copying</b></a>) or
<code>xsl:attribute-set</code> elements.  The value of the
<code>use-attribute-sets</code> attribute is a whitespace-separated
list of names of attribute sets.  Each name is specified as a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>.  Specifying a
<code>use-attribute-sets</code> attribute is equivalent to adding
<code>xsl:attribute</code> elements for each of the attributes in each
of the named attribute sets to the beginning of the content of the
element with the <code>use-attribute-sets</code> attribute, in the
same order in which the names of the attribute sets are specified in
the <code>use-attribute-sets</code> attribute.  It is an error if use
of <code>use-attribute-sets</code> attributes on
<code>xsl:attribute-set</code> elements causes an attribute set to
directly or indirectly use itself.</p>

<p>Attribute sets can also be used by specifying an
<code>xsl:use-attribute-sets</code> attribute on a literal result
element.  The value of the <code>xsl:use-attribute-sets</code>
attribute is a whitespace-separated list of names of attribute sets.
The <code>xsl:use-attribute-sets</code> attribute has the same effect
as the <code>use-attribute-sets</code> attribute on
<code>xsl:element</code> with the additional rule that attributes
specified on the literal result element itself are treated as if they
were specified by <code>xsl:attribute</code> elements before any
actual <code>xsl:attribute</code> elements but after any
<code>xsl:attribute</code> elements implied by the
<code>xsl:use-attribute-sets</code> attribute.  Thus, for a literal
result element, attributes from attribute sets named in an
<code>xsl:use-attribute-sets</code> attribute will be added first, in
the order listed in the attribute; next, attributes specified on the
literal result element will be added; finally, any attributes
specified by <code>xsl:attribute</code> elements will be added.  Since
adding an attribute to an element replaces any existing attribute of
that element with the same name, this means that attributes specified
in attribute sets can be overridden by attributes specified on the
literal result element itself.</p>

<p>The template within each <code>xsl:attribute</code> element in an
<code>xsl:attribute-set</code> element is instantiated each time the
attribute set is used; it is instantiated using the same current node
and current node list as is used for instantiating the element bearing
the <code>use-attribute-sets</code> or
<code>xsl:use-attribute-sets</code> attribute. However, it is the
position in the stylesheet of the <code>xsl:attribute</code> element
rather than of the element bearing the <code>use-attribute-sets</code>
or <code>xsl:use-attribute-sets</code> attribute that determines which
variable bindings are visible (see <a href="#variables"><b>11 Variables and Parameters</b></a>); thus,
only variables and parameters declared by <a title="Top-level" href="#dt-top-level">top-level</a> <code>xsl:variable</code> and
<code>xsl:param</code> elements are visible.</p>

<p>The following example creates a named attribute set
<code>title-style</code> and uses it in a template rule.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block quadding="start" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre></div>

<p>Multiple definitions of an attribute set with the same
expanded-name are merged.  An attribute from a definition that has
higher <a title="Import Precedence" href="#dt-import-precedence">import precedence</a>
takes precedence over an attribute from a definition that has lower
<a title="Import Precedence" href="#dt-import-precedence">import precedence</a>.  It
is an error if there are two attribute sets that have the same
expanded-name and equal import precedence and that both contain
the same attribute, unless there is a definition of the attribute set
with higher <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a> that also contains the attribute.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing from amongst the definitions that specify the
attribute that have the highest import precedence the one that was
specified last in the stylesheet.  Where the attributes in an
attribute set were specified is relevant only in merging the
attributes into the attribute set; it makes no difference when the
attribute set is used. For each
attribute set name occurring in a <code>use-attribute-sets</code> attribute on
an <code>xsl:attribute-set</code> element, all definitions of an
attribute set with that name must be merged <em>before</em> the
<code>use-attribute-sets</code> attribute is replaced by the
equivalent sequence of <code>xsl:attribute</code> child elements.  Any
<code>use-attribute-sets</code> attribute on an
<code>xsl:attribute-set</code> element must be replaced by the
equivalent sequence of <code>xsl:attribute</code> child elements
<em>before</em> that <code>xsl:attribute-set</code> element is
merged with other <code>xsl:attribute-set</code> elements with the
same expanded-name. When <code>xsl:attribute-set</code> elements with
the same expanded-name are merged, any <code>xsl:attribute</code>
child elements added to replace a <code>use-attribute-sets</code>
attribute are treated exactly as if they had originally been specified
in the stylesheet as child elements.</p>

</div>

</div>

<div class="div2">


<h3><a name="N4656"></a>7.2 Creating Text</h3>

<p>A template can also contain text nodes.  Each text node in a
template remaining after whitespace has been stripped as specified in
<a href="#strip"><b>3.4 Whitespace Stripping</b></a> will create a text node with the same
string-value in the result tree.  Adjacent text nodes in the result
tree are automatically merged.</p>

<p>Note that text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the result tree
that contains a <code>&lt;</code> character, which will be represented
by the markup <code>&amp;lt;</code> (or an equivalent character
reference) when the result tree is externalized as an XML document
(unless output escaping is disabled as described in <a href="#disable-output-escaping"><b>16.4 Disabling Output Escaping</b></a>).</p>


  
  
    
    
  
    


<p>Literal data characters may also be wrapped in an
<code>xsl:text</code> element.  This wrapping may change what
whitespace characters are stripped (see <a href="#strip"><b>3.4 Whitespace Stripping</b></a>) but
does not affect how the characters are handled by the XSLT processor
thereafter.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>xml:lang</code> and <code>xml:space</code>
attributes are not treated specially by XSLT. In particular,</p>

<ul>
<li><p>it is the responsibility of the stylesheet author explicitly
to generate any <code>xml:lang</code> or <code>xml:space</code>
attributes that are needed in the result;</p></li>

<li><p>specifying an <code>xml:lang</code> or <code>xml:space</code>
attribute on an element in the XSLT namespace will not cause any
<code>xml:lang</code> or <code>xml:space</code> attributes to appear
in the result.</p></li>
</ul>
</div>

</div>


<div class="div2">

<h3><a name="N4760"></a>7.3 Creating Processing Instructions</h3>



  
  
    
      
    
  
  


<p>The <code>xsl:processing-instruction</code> element is instantiated
to create a processing instruction node.  The content of the
<code>xsl:processing-instruction</code> element is a template for the
string-value of the processing instruction node.  The
<code>xsl:processing-instruction</code> element has a required
<code>name</code> attribute that specifies the name of the processing
instruction node.  The value of the <code>name</code> attribute is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>.</p>

<p>For example, this</p>

<div class="exampleInner"><pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;href="book.css" type="text/css"&lt;/xsl:processing-instruction&gt;</pre></div>

<p>would create the processing instruction</p>

<div class="exampleInner"><pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre></div>

<p>It is an error if the string that results from instantiating the
<code>name</code> attribute is not both an <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a> and a <a href="http://www.w3.org/TR/REC-xml#NT-PITarget">PITarget</a>.  An XSLT processor may signal
the error; if it does not signal the error, it must recover by not
adding the processing instruction to the result tree.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <code>xsl:processing-instruction</code>
cannot be used to output an XML declaration.  The
<code>xsl:output</code> element should be used instead (see <a href="#output"><b>16 Output</b></a>).</p></div>

<p>It is an error if instantiating the content of
<code>xsl:processing-instruction</code> creates nodes other than
text nodes.  An XSLT processor may signal the error; if it does not
signal the error, it must recover by ignoring the offending nodes
together with their content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:processing-instruction</code> contains the string
<code>?&gt;</code>.  An XSLT processor may signal the error; if it does
not signal the error, it must recover by inserting a space after any
occurrence of <code>?</code> that is followed by a <code>&gt;</code>.</p>

</div>

<div class="div2">

<h3><a name="N4885"></a>7.4 Creating Comments</h3>


  
  


<p>The <code>xsl:comment</code> element is instantiated to create a
comment node in the result tree.  The content of the
<code>xsl:comment</code> element is a template for the string-value of
the comment node.</p>

<p>For example, this</p>

<div class="exampleInner"><pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre></div>

<p>would create the comment</p>

<div class="exampleInner"><pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre></div>

<p>It is an error if instantiating the content of
<code>xsl:comment</code> creates nodes other than text nodes.  An
XSLT processor may signal the error; if it does not signal the error,
it must recover by ignoring the offending nodes together with their
content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:comment</code> contains the string <code>--</code> or ends
with <code>-</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by inserting a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.</p>

</div>

<div class="div2">

<h3><a name="copying"></a>7.5 Copying</h3>


  
  
    
  
  


<p>The <code>xsl:copy</code> element provides an easy way of copying
the current node. Instantiating the <code>xsl:copy</code> element
creates a copy of the current node.  The namespace nodes of the
current node are automatically copied as well, but the attributes and
children of the node are not automatically copied.  The content of the
<code>xsl:copy</code> element is a template for the attributes and
children of the created node; the content is instantiated only for
nodes of types that can have attributes or children (i.e. root
nodes and element nodes).</p>

<p>The <code>xsl:copy</code> element may have a
<code>use-attribute-sets</code> attribute (see <a href="#attribute-sets"><b>7.1.4 Named Attribute Sets</b></a>). This is used only when copying element
nodes.</p>

<p>The root node is treated specially because the root node of the
result tree is created implicitly.  When the current node is the root
node, <code>xsl:copy</code> will not create a root node, but will just
use the content template.</p>

<p>For example, the identity transformation can be written using
<code>xsl:copy</code> as follows:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre></div>

<p>When the current node is an attribute, then if it would be an error
to use <code>xsl:attribute</code> to create an attribute with the same
name as the current node, then it is also an error to use
<code>xsl:copy</code> (see <a href="#creating-attributes"><b>7.1.3 Creating Attributes with xsl:attribute</b></a>).</p>

<p id="diff-9">When the current node is a namespace node,
then copying it adds a namespace node to the containing node in the
result tree. It is an error if this containing node is not an element;
implementations may either signal the error or ignore the namespace
node.  It is an error to add a namespace node to an element after
children have been added to it or after attributes have been added to
it; implementations may either signal an error or ignore the namespace
node.  It is an error to add a namespace node to an element if the
element already has a namespace node with the same name, unless both
namespace nodes have the same <a href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a>, in which case
the duplicate is ignored. It is an error to add a namespace node to an
element if the namespace node has a null name and the element has a
null namespace URI.</p>

<p>The following example shows how <code>xml:lang</code> attributes
can be easily copied through from source to result. If a stylesheet
defines the following named template:</p>

<div class="exampleInner"><pre>&lt;xsl:template name="apply-templates-copy-lang"&gt;
 &lt;xsl:for-each select="@xml:lang"&gt;
   &lt;xsl:copy/&gt;
 &lt;/xsl:for-each&gt;
 &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>then it can simply do</p>

<div class="exampleInner"><pre>&lt;xsl:call-template name="apply-templates-copy-lang"/&gt;</pre></div>

<p>instead of</p>

<div class="exampleInner"><pre>&lt;xsl:apply-templates/&gt;</pre></div>

<p>when it wants to copy the <code>xml:lang</code> attribute.</p>

</div>

<div class="div2">

<h3><a name="N5075"></a>7.6 Computing Generated Text</h3>

<p>Within a template, the <code>xsl:value-of</code> element can be
used to compute generated text, for example by extracting text from
the source tree or by inserting the value of a variable.  The
<code>xsl:value-of</code> element does this with an <a title="Expression" href="#dt-expression">expression</a> that is specified as the
value of the <code>select</code> attribute.  Expressions can
also be used inside attribute values of literal result elements by
enclosing the expression in curly braces (<code>{}</code>).</p>

<div class="div3">

<h4><a name="value-of"></a>7.6.1 Generating Text with <code>xsl:value-of</code></h4>


  
  
    
  
  
    
    
  
  


<p>The <code>xsl:value-of</code> element is instantiated to create a
text node in the result tree.  The required <code>select</code>
attribute is an <a title="Expression" href="#dt-expression">expression</a>;
this expression is evaluated and the resulting object is converted to
a string as if by a call to the string
function. The string specifies the string-value of the created text
node.  If the string is empty, no text node will be created.  The
created text node will be merged with any adjacent text nodes.</p>

<p>The <code>xsl:copy-of</code> element can be used to copy a node-set
over to the result tree without converting it to a string. See <a href="#copy-of"><b>11.3 Using Values of Variables and Parameters with
xsl:copy-of</b></a>.</p>

<p>For example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> attributes.  The paragraph will contain the value
of the <code>given-name</code> attribute of the current node followed
by a space and the value of the <code>family-name</code> attribute of the
current node.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div>

<p>For another example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> children elements.  The paragraph will
contain the string-value of the first <code>given-name</code> child
element of the current node followed by a space and the string-value
of the first <code>family-name</code> child element of the current
node.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The following precedes each <code>procedure</code> element with a
paragraph containing the security level of the procedure.  It assumes
that the security level that applies to a procedure is determined by a
<code>security</code> attribute on the procedure element or on an
ancestor element of the procedure. It also assumes that if more than
one such element has a <code>security</code> attribute then the
security level is determined by the element that is closest to the
procedure.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="procedure"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

<div class="div3">

<h4><a name="attribute-value-templates"></a>7.6.2 Attribute Value Templates</h4>

<p>[<a name="dt-attribute-value-template" title="Attribute Value Template">Definition</a>: In an attribute value that is interpreted as an
<b>attribute value template</b>, such as an attribute of a
literal result element, an <a title="Expression" href="#dt-expression">expression</a> can be used by surrounding
the expression with curly braces (<code>{}</code>)].  The
attribute value template is instantiated by replacing the expression
together with surrounding curly braces by the result of evaluating the
expression and converting the resulting object to a string as if by a
call to the string function.  Curly braces are
not recognized in an attribute value in an XSLT stylesheet unless the
attribute is specifically stated to be one that is interpreted as an
attribute value template; in an element syntax summary, the value
of such attributes is surrounded by curly braces.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Not all attributes are interpreted as attribute value
templates.  Attributes whose value is an expression or pattern,
attributes of <a title="Top-level" href="#dt-top-level">top-level</a> elements
and attributes that refer to named XSLT objects are not interpreted as
attribute value templates. In addition, <code>xmlns</code> attributes
are not interpreted as attribute value templates; it would not be
conformant with the XML Namespaces Recommendation to do
this. The <code>xsl:output</code> element is an
exception: although it is a top-level element, its attributes are all
interpreted as attribute value templates for consistency with
<code>xsl:document</code>.</p></div>

<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of the
<code>src</code> attribute of the <code>img</code> element is computed
from the value of the <code>image-dir</code> variable and the
string-value of the <code>href</code> child of the
<code>photograph</code> element; the value of the <code>width</code>
attribute of the <code>img</code> element is computed from the value
of the <code>width</code> attribute of the <code>size</code> child of
the <code>photograph</code> element:</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="image-dir"&gt;/images&lt;/xsl:variable&gt;

&lt;xsl:template match="photograph"&gt;
&lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>With this source</p>

<div class="exampleInner"><pre>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</pre></div>

<p>the result would be</p>

<div class="exampleInner"><pre>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</pre></div>

<p>When an attribute value template is instantiated, a double left or
right curly brace outside an expression will be replaced by a single
curly brace.  It is an error if a right curly brace occurs in an
attribute value template outside an expression without being followed
by a second right curly brace.  A right curly brace inside a <a href="http://www.w3.org/TR/xpath#NT-Literal">Literal</a> in an expression is not
recognized as terminating the expression.</p>

<p>Curly braces are <em>not</em> recognized recursively inside
expressions.  For example:</p>

<div class="exampleInner"><pre>&lt;a href="#{id({@ref})/title}"&gt;</pre></div>

<p>is <em>not</em> allowed.  Instead, use simply:</p>

<div class="exampleInner"><pre>&lt;a href="#{id(@ref)/title}"&gt;</pre></div>

</div>

</div>

<div class="div2">

<h3><a name="number"></a>7.7 Numbering</h3>


  
  
    
    
    
  
  
    
  
  
    
  
  
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
      
    
  
  
    
      
    
  
  
    
      
    
  
  


<p>The <code>xsl:number</code> element is used to insert a formatted
number into the result tree.  The number to be inserted may be
specified by an expression. The <code>value</code> attribute contains
an <a title="Expression" href="#dt-expression">expression</a>.  The expression
is evaluated and the resulting object is converted to a number as if
by a call to the number function.  It is an error if the number is NaN, infinite
or less than 0.5; an XSLT processor may signal the error; if it does
not signal the error, it must recover by converting the number to a
string as if by a call to the string function
and inserting the resulting string into the result tree.
Otherwise, the number is
rounded to an integer and then converted to a string using the
attributes specified in <a href="#convert"><b>7.7.1 Number to String Conversion Attributes</b></a>; in this
context, the value of each of these attributes is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>.  After conversion, the resulting string is
inserted in the result tree. For example, the following example
numbers a sorted list:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre></div>

<p>If no <code>value</code> attribute is specified, then the
<code>xsl:number</code> element inserts a number based on the position
of the current node in the source tree. The following attributes
control how the current node is to be numbered:</p>

<ul>

<li><p>The <code>level</code> attribute specifies what levels of the
source tree should be considered; it has the values
<code>single</code>, <code>multiple</code> or <code>any</code>. The
default is <code>single</code>.</p></li>

<li><p>The <code>count</code> attribute is a pattern that specifies
what nodes should be counted at those levels.  If <code>count</code>
attribute is not specified, then it defaults to the pattern that
matches any node with the same node type as the current node and, if
the current node has an expanded-name, with the same expanded-name as
the current node.</p></li>

<li><p>The <code>from</code> attribute is a pattern that specifies
where counting starts.</p></li>

</ul>

<p>In addition, the attributes specified in <a href="#convert"><b>7.7.1 Number to String Conversion Attributes</b></a>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>

<p>The <code>xsl:number</code> element first constructs a list of
positive integers using the <code>level</code>, <code>count</code> and
<code>from</code> attributes:</p>

<ul>

<li><p>When <code>level="single"</code>, it goes up to the first
node in the ancestor-or-self axis that matches
the <code>count</code> pattern, and constructs a list of length one
containing one plus the number of preceding siblings of that ancestor
that match the <code>count</code> pattern. If there is no such
ancestor, it constructs an empty list.  If the <code>from</code>
attribute is specified, then the only ancestors that are searched are
those that are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></li>

<li><p>When <code>level="multiple"</code>, it constructs a list of all
ancestors of the current node in document order followed by the
element itself; it then selects from the list those nodes that match
the <code>count</code> pattern; it then maps each node in the list to
one plus the number of preceding siblings of that node that match the
<code>count</code> pattern.  If the <code>from</code> attribute is
specified, then the only ancestors that are searched are those that
are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></li>

<li><p>When <code>level="any"</code>, it constructs a list of length
one containing the number of nodes that match the <code>count</code>
pattern and belong to the set containing the current node and all
nodes at any level of the document that are before the current node in
document order, excluding any namespace and attribute nodes (in other
words the union of the members of the <code>preceding</code> and
<code>ancestor-or-self</code> axes).
If there are no matching nodes, it constructs an empty list.
If the <code>from</code> attribute is specified, then only nodes after
the first node before the current node that match the
<code>from</code> pattern are considered.</p></li>

</ul>

<p>The list of numbers is then converted into a string using the
attributes specified in <a href="#convert"><b>7.7.1 Number to String Conversion Attributes</b></a>; in this
context, the value of each of these attributes is
interpreted as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value template</a>.  After conversion, the resulting string is
inserted in the result tree.</p>

<p>The following would number the items in an ordered list:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</pre></div>

<p>The following two rules would number <code>title</code> elements.
This is intended for a document that contains a sequence of chapters
followed by a sequence of appendices, where both chapters and
appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The following example numbers notes sequentially within a
chapter:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The following example would number <code>H4</code> elements in HTML
with a three-part label:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div>

<div class="div3">

<h4><a name="convert"></a>7.7.1 Number to String Conversion Attributes</h4>

<p>The following attributes are used to control conversion of a list
of numbers into a string. The numbers are integers greater than
0. The attributes are all optional.</p>

<p>The main attribute is <code>format</code>.  The default value for
the <code>format</code> attribute is <code>1</code>.  The
<code>format</code> attribute is split into a sequence of tokens where
each token is a maximal sequence of alphanumeric characters or a
maximal sequence of non-alphanumeric characters.  Alphanumeric means
any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt,
Lm or Lo.  The alphanumeric tokens (format tokens) specify the format
to be used for each number in the list.  If the first token is a
non-alphanumeric token, then the constructed string will start with
that token; if the last token is non-alphanumeric token, then the
constructed string will end with that token.  Non-alphanumeric tokens
that occur between two format tokens are separator tokens that are
used to join numbers in the list.  The <var>n</var>th format token
will be used to format the <var>n</var>th number in the list.  If
there are more numbers than format tokens, then the last format token
will be used to format remaining numbers.  If there are no format
tokens, then a format token of <code>1</code> is used to format all
numbers.  The format token specifies the string to be used to
represent the number 1.  Each number after the first will be separated
from the preceding number by the separator token preceding the format
token used to format that number, or, if there are no separator
tokens, then by <code>.</code> (a period character).</p>

<p>Format tokens are a superset of the allowed values for the
<code>type</code> attribute for the <code>OL</code> element in HTML
4.0 and are interpreted as follows:</p>

<ul>

<li><p>Any token where the last character has a decimal digit value
of 1 (as specified in the Unicode character property database),
and the Unicode value of preceding characters is one less than the
Unicode value of the last character generates a decimal
representation of the number where each number is at least as long as
the format token.  Thus, a format token <code>1</code> generates the
sequence <code>1 2 ... 10 11 12 ...</code>, and a format token
<code>01</code> generates the sequence <code>01 02 ... 09 10 11 12
... 99 100 101</code>.</p></li>

<li><p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p></li>

<li><p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p></li>

<li><p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p></li>

<li><p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p></li>

<li><p>Any other format token indicates a numbering sequence that
starts with that token.  If an implementation does not support a
numbering sequence that starts with that token, it must use a format
token of <code>1</code>.</p></li>

</ul>

<p>When numbering with an alphabetic sequence, the <code>lang</code>
attribute specifies which language's alphabet is to be used; it has
the same range of values as <code>xml:lang</code> <a href="#XML">[XML]</a>;
if no <code>lang</code> value is specified, the language should be
determined from the system environment.  Implementers should document
for which languages they support numbering.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Implementers should not make any assumptions about how
numbering works in particular languages and should properly research
the languages that they wish to support.  The numbering conventions of
many languages are very different from English.</p></div>

<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  A value of <code>alphabetic</code> specifies the
alphabetic sequence; a value of <code>traditional</code> specifies the
other sequence.  If the <code>letter-value</code> attribute is not
specified, then it is implementation-dependent how any ambiguity is
resolved.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible for two conforming XSLT processors not to
convert a number to exactly the same string.  Some XSLT processors may not
support some languages.  Furthermore, there may be variations possible
in the way conversions are performed for any particular language that
are not specifiable by the attributes on <code>xsl:number</code>.
Future versions of XSLT may provide additional attributes to provide
control over these variations.  Implementations may also use
implementation-specific namespaced attributes on
<code>xsl:number</code> for this.</p></div>

<p>The <code>grouping-separator</code> attribute gives the separator
used as a grouping (e.g. thousands) separator in decimal numbering
sequences, and the optional <code>grouping-size</code> specifies the
size (normally 3) of the grouping.  For example,
<code>grouping-separator=","</code> and <code>grouping-size="3"</code>
would produce numbers of the form <code>1,000,000</code>.  If only one
of the <code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>

<p>Here are some examples of conversion specifications:</p>

<ul>

<li><p><code>format="&amp;#x30A2;"</code> specifies Katakana
numbering</p></li>

<li><p><code>format="&amp;#x30A4;"</code> specifies Katakana
numbering in the "iroha" order</p></li>

<li><p><code>format="&amp;#x0E51;"</code> specifies numbering with
Thai digits</p></li>

<li><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
specifies "traditional" Hebrew numbering</p></li>

<li><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
specifies Georgian numbering</p></li>

<li><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
specifies "classical" Greek numbering</p></li>

<li><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
specifies Old Slavic numbering</p></li>

</ul>

</div>
</div>
</div>

<div class="div1">


<h2><a name="for-each"></a>8 Repetition</h2>


  
  
    
  
  
    
    
  


<p>When the result has a known regular structure, it is useful to be
able to specify directly the template for selected nodes.  The
<code>xsl:for-each</code> instruction contains a template, which is
instantiated for each node selected by the <a title="Expression" href="#dt-expression">expression</a> specified by the
<code>select</code> attribute. The <code>select</code> attribute is
required.  The expression must evaluate to a node-set.  The template
is instantiated with the selected node as the <a title="Current Node" href="#dt-current-node">current node</a>, and with a list of all
of the selected nodes as the <a title="Current Node List" href="#dt-current-node-list">current node list</a>.  The nodes are
processed in document order, unless a sorting specification is present
(see <a href="#sorting"><b>10 Sorting</b></a>).</p>

<p>For example, given an XML document with this structure</p>

<div class="exampleInner"><pre>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre></div>

<p>the following would create an HTML document containing a table with
a row for each <code>customer</code> element</p>

<div class="exampleInner"><pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	&lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
		&lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
		&lt;td&gt;
		  &lt;xsl:apply-templates/&gt;
		&lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

<div class="div1">

<h2><a name="N6058"></a>9 Conditional Processing</h2>

<p>There are two instructions in XSLT that support conditional
processing in a template: <code>xsl:if</code> and
<code>xsl:choose</code>. The <code>xsl:if</code> instruction provides
simple if-then conditionality; the <code>xsl:choose</code> instruction
supports selection of one choice when there are several
possibilities.</p>

<div class="div2">

<h3><a name="N6078"></a>9.1 Conditional Processing with <code>xsl:if</code></h3>


  
  
    
  
  


<p>The <code>xsl:if</code> element has a <code>test</code> attribute,
which specifies an <a title="Expression" href="#dt-expression">expression</a>.
The content is a template.  The expression is evaluated and the
resulting object is converted to a boolean as if by a call to the
boolean function.  If the result is true, then
the content template is instantiated; otherwise, nothing is created.
In the following example, the names in a group of names are formatted
as a comma separated list:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The following colors every other table row yellow:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</pre></div>

</div>


<div class="div2">

<h3><a name="N6137"></a>9.2 Conditional Processing with <code>xsl:choose</code></h3>


  
  
    
    
  



  
    
  
  



  


<p>The <code>xsl:choose</code> element selects one among a number of
possible alternatives. It consists of a sequence of
<code>xsl:when</code> elements followed by an optional
<code>xsl:otherwise</code> element.  Each <code>xsl:when</code>
element has a single attribute, <code>test</code>, which specifies an
<a title="Expression" href="#dt-expression">expression</a>. The content of the
<code>xsl:when</code> and <code>xsl:otherwise</code> elements is a
template.  When an <code>xsl:choose</code> element is processed, each
of the <code>xsl:when</code> elements is tested in turn, by evaluating
the expression and converting the resulting object to a boolean as if
by a call to the boolean function.  The content
of the first, and only the first, <code>xsl:when</code> element whose
test is true is instantiated.  If no <code>xsl:when</code> is true,
the content of the <code>xsl:otherwise</code> element is
instantiated. If no <code>xsl:when</code> element is true, and no
<code>xsl:otherwise</code> element is present, nothing is created.</p>

<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth to
which the ordered lists are nested.</p>

<div class="exampleInner"><pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre></div>

</div>
</div>

<div class="div1">

<h2><a name="sorting"></a>10 Sorting</h2>


  
    
  
  
    
      
    
  
  
    
       
       
       
    
  
  
    
       
       
    
  
  
    
       
       
    
  
  


<p>Sorting is specified by adding <code>xsl:sort</code> elements as
children of an <code>xsl:apply-templates</code> or
<code>xsl:for-each</code> element.  The first <code>xsl:sort</code>
child specifies the primary sort key, the second <code>xsl:sort</code>
child specifies the secondary sort key and so on.  When an
<code>xsl:apply-templates</code> or <code>xsl:for-each</code> element
has one or more <code>xsl:sort</code> children, then instead of
processing the selected nodes in document order, it sorts the nodes
according to the specified sort keys and then processes them in sorted
order.  When used in <code>xsl:for-each</code>, <code>xsl:sort</code>
elements must occur first.  When a template is instantiated by
<code>xsl:apply-templates</code> and <code>xsl:for-each</code>, the
<a title="Current Node List" href="#dt-current-node-list">current node list</a>
consists of the complete list of nodes being processed in sorted
order.</p>

<p><code>xsl:sort</code> has a <code>select</code> attribute whose
value is an <a title="Expression" href="#dt-expression">expression</a>. For
each node to be processed, the expression is evaluated with that node
as the current node and with the complete list of nodes being
processed in document
order as the current node list.
The resulting object is converted to a string as
if by a call to the string function; this string
is used as the sort key for that node. The default value of the
<code>select</code> attribute is <code>.</code>, which will cause the
string-value of the current node to be used as the sort key.</p>

<p>This string serves as a sort key for the node.  The following
optional attributes on <code>xsl:sort</code> control how the list of
sort keys are sorted; the values of all of these attributes are
interpreted as <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute
value templates</a>.</p>

<ul>

<li><p><code>order</code> specifies whether the strings should be
sorted in ascending or descending order; <code>ascending</code>
specifies ascending order; <code>descending</code> specifies
descending order; the default is <code>ascending</code></p></li>

<li><p><code>lang</code> specifies the language of the sort keys; it
has the same range of values as <code>xml:lang</code> <a href="#XML">[XML]</a>; if no <code>lang</code> value is specified, the language
should be determined from the system environment</p></li>

<li><p><code>data-type</code> specifies the data type of the
strings; the following values are allowed:</p>

<ul>

<li><p><code>text</code> specifies that the sort keys should be
sorted lexicographically in the culturally correct manner for the
language specified by <code>lang</code></p></li>

<li><p><code>number</code> specifies that the sort keys should be
converted to numbers and then sorted according to the numeric value;
the sort key is converted to a number as if by a call to the
number function; the <code>lang</code>
attribute is ignored; in ascending order
a NaN precedes all other numeric values and in descending
order it follows them</p></li>

<li><p>a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> with a prefix
is expanded into an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>; the expanded-name identifies the data-type;
the behavior in this case is not specified by this document</p></li>

</ul>

<p>The default value is <code>text</code>.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The XSL Working Group plans that future versions of XSLT will
leverage XML Schemas to define further values for this
attribute.</p></div>

</li>

<li><p><code>case-order</code> has the value
<code>upper-first</code> or <code>lower-first</code>; this applies
when <code>data-type="text"</code>, and specifies that in ascending order upper-case
letters should sort before lower-case letters or vice-versa
respectively. For example, if <code>lang="en"</code>, then <code>A a B
b</code> are sorted in ascending
order with <code>case-order="upper-first"</code> and <code>a
A b B</code> are sorted  in ascending
order with <code>case-order="lower-first"</code>. In descending order, the effect is
reversed. For example, if <code>lang="en"</code>, then <code>b B a
A</code> are sorted in descending order with
<code>case-order="upper-first"</code>. The default value is
language dependent.</p></li>

</ul>

<div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible for two conforming XSLT processors not to sort
exactly the same.  Some XSLT processors may not support some
languages.  Furthermore, there may be variations possible in the
sorting of any particular language that are not specified by the
attributes on <code>xsl:sort</code>, for example, whether Hiragana or
Katakana is sorted first in Japanese.  Future versions of XSLT may
provide additional attributes to provide control over these
variations.  Implementations may also use implementation-specific
namespaced attributes on <code>xsl:sort</code> for this.</p></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>It is recommended that implementers consult <a href="#UNICODE-TR10">[UNICODE TR10]</a> for information on internationalized
sorting.</p></div>

<p>The sort must be stable: in the sorted list of nodes, any sub list
that has sort keys that all compare equal must be in document
order.</p>

<p>For example, suppose an employee database has the form</p>

<div class="exampleInner"><pre>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</pre></div>
  
<p>Then a list of employees sorted by name could be generated
using:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

<div class="div1">

<h2><a name="variables"></a>11 Variables and Parameters</h2>


  
  
  
    
  
  
    
  
  



  
  
    
  
  
    
  
  


<p>A variable is a name that may be bound to a value.  The value to
which a variable is bound (the <b>value</b> of the variable) can
be an object of any of the types that can be returned by expressions.
There are two elements that can be used to bind variables:
<code>xsl:variable</code> and <code>xsl:param</code>. The difference
is that the value specified on the <code>xsl:param</code> variable is
only a default value for the binding; when the template or stylesheet
within which the <code>xsl:param</code> element occurs is invoked,
parameters may be passed that are used in place of the default
values.</p>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> have a
required <code>name</code> attribute, which specifies the name of the
variable.  The value of the <code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>.</p>

<p>For any use of these variable-binding elements, there is a region
of the stylesheet tree within which the binding is visible.  The set
of variable bindings in scope for an expression consists of those
bindings that are visible at the point in the stylesheet where the
expression occurs.</p>

<div class="div2">

<h3><a name="N6743"></a>11.1 Result Tree Fragments</h3>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The result tree fragment data-type has been removed
in XSLT 1.1.</p></div>

</div>
 
<div class="div2">

<h3><a name="variable-values"></a>11.2 Values of Variables and Parameters</h3>

<p>A variable-binding element can specify the value of the variable in
three alternative ways.</p>

<ul>

<li><p>If the variable-binding element has a <code>select</code>
attribute, then the value of the attribute must be an <a title="Expression" href="#dt-expression">expression</a> and the value of the variable
is the object that results from evaluating the expression.  In this
case, the content must be empty.</p></li>

<li>

<p>If the variable-binding element does not have a <code>select</code>
attribute and has non-empty content (i.e. the variable-binding element
has one or more child nodes), then the content of the
variable-binding element specifies the value. The content of the
variable-binding element is a template; a new
document is constructed with a root node having as its children
the sequence of nodes that results from instantiating this template;
<a title="Namespace Fixup" href="#dt-namespace-fixup">namespace fixup</a> is
performed on this document (see <a href="#namespace-fixup"><b>3.5 Namespace Fixup</b></a>); the
value of the variable is a node-set that contains just the root node
of this newly constructed document.</p>

<p>The base URI of a node in this document is determined as
if all the nodes in the document came from a single entity whose URI
was the base URI of the variable-binding element (see <a href="#base-uri"><b>3.2 Base URI</b></a>). Thus, the base URI of the root node will be equal
to the base URI of the variable-binding element; an
<code>xml:base</code> attribute within this document will change the
base URI for its parent element and that element's descendants, just
as it would within a document constructed by parsing.</p>

<p>It is an error if a member of the sequence of nodes created by
instantiating the template is an attribute node or a namespace node,
since a root node cannot have an attribute node or a namespace node as
a child. An XSLT processor may signal the error; if it does not signal
the error, it must recover by not adding the attribute node or
namespace node.</p>

</li>

<li>

<p>If the variable-binding element has empty content and does not have
a <code>select</code> attribute, then the value of the variable is an
empty string. Thus</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="x"/&gt;</pre></div>

<p>is equivalent to</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="x" select="''"/&gt;</pre></div>

</li>

</ul>

<div class="note"><p class="prefix"><b>Note:</b></p><p>When a variable is used to select nodes by position, be careful
not to do:</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre></div>

<p>This will output the value of the first item element, because the
variable <code>n</code> will be bound to a node-set, not a number. Instead, do either</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre></div>

<p>or</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[position()=$n]"/&gt;</pre></div>
</div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>One convenient way to specify the empty node-set as the default
value of a parameter is:</p>

<div class="exampleInner"><pre>&lt;xsl:param name="x" select="/.."/&gt;</pre></div>
</div>

</div>

<div class="div2">

<h3><a name="copy-of"></a>11.3 Using Values of Variables and Parameters with
<code>xsl:copy-of</code></h3>


  
  
    
  
  


<p>The <code>xsl:copy-of</code> element can be used to insert a
node-set into the result tree, without
first converting it to a string as <code>xsl:value-of</code> does (see
<a href="#value-of"><b>7.6.1 Generating Text with xsl:value-of</b></a>).  The required <code>select</code>
attribute contains an <a title="Expression" href="#dt-expression">expression</a>.  When the
result of evaluating the expression is a node-set, all the
nodes in the set are copied in document order into the result tree;
copying an element node copies the attribute nodes, namespace nodes
and children of the element node as well as the element node itself; a
root node is copied by copying its children. For copying an attribute or namespace node, the same
rules apply as with <code>xsl:copy</code> (see <a href="#copying"><b>7.5 Copying</b></a>). When the result is not a
node-set, the result is converted to a string and then
inserted into the result tree, as with <code>xsl:value-of</code>.</p>

</div>

<div class="div2">

<h3><a name="top-level-variables"></a>11.4 Top-level Variables and Parameters</h3>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> are
allowed as <a title="Top-level" href="#dt-top-level">top-level</a> elements.
A top-level variable-binding element declares a global variable that
is visible everywhere (except where it
is <a title="Shadows" href="#dt-shadows">shadowed</a> by another
binding).  A top-level <code>xsl:param</code> element
declares a parameter to the stylesheet; XSLT does not define the
mechanism by which parameters are passed to the stylesheet. If a stylesheet contains more than one
binding for a variable of a particular name, then the binding with the
highest <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a> is used. It is an
error if a stylesheet contains more than one binding of a top-level
variable with the same name and same <a title="Import Precedence" href="#dt-import-precedence">import precedence</a>. At the
top-level, the expression or template specifying the variable value is
evaluated with the same context as that used to process the root node
of the source document: the current node is the root node of the
source document and the current node list is a list containing just
the root node of the source document.  If the template or expression
specifying the value of a global variable <var>x</var> references a
global variable <var>y</var>, then the value for <var>y</var> must
be computed before the value of <var>x</var>.  It is an error if it
is impossible to do this for all global variable definitions; in other
words, it is an error if the definitions are circular.</p>

<p>This example declares a global variable <code>para-font-size</code>,
which it references in an attribute value template.</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="para-font-size"&gt;12pt&lt;/xsl:variable&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>

</div>

<div class="div2">

<h3><a name="local-variables"></a>11.5 Variables and Parameters within Templates</h3>

<p>As well as being allowed at the top-level, both
<code>xsl:variable</code> and <code>xsl:param</code> are also
allowed in templates.  <code>xsl:variable</code> is allowed anywhere
within a template that an instruction is allowed.  In this case, the
binding is visible for all following siblings and their descendants.
Note that the binding is not visible for the <code>xsl:variable</code>
element itself.  <code>xsl:param</code> is allowed as a child
at the beginning of an <code>xsl:template</code> element.  In this
context, the binding is visible for all following siblings and their
descendants.  Note that the binding is not visible for the
<code>xsl:param</code> element itself.</p>

<p>[<a name="dt-shadows" title="Shadows">Definition</a>: A binding
<b>shadows</b> another binding if the binding occurs at a point
where the other binding is visible, and the bindings have the same
name.] It is an error if a binding established by an
<code>xsl:variable</code> or <code>xsl:param</code> element within a
template <a title="Shadows" href="#dt-shadows">shadows</a> another binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element also within the template.  It is not an error if a binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element in a template <a title="Shadows" href="#dt-shadows">shadows</a>
another binding established by an <code>xsl:variable</code> or
<code>xsl:param</code> <a title="Top-level" href="#dt-top-level">top-level</a>
element. In this case, the top-level
binding will not be visible in the region of the stylesheet where it
is shadowed by the other binding. Thus, the following is an
error:</p>

<div class="exampleInner"><pre>&lt;xsl:template name="foo"&gt;
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre></div>

<p>However, the following is allowed:</p>

<div class="exampleInner"><pre>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The nearest equivalent in Java to an <code>xsl:variable</code>
element in a template is a final local variable declaration with an
initializer.  For example,</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="x" select="'value'"/&gt;</pre></div>

<p>has similar semantics to</p>

<div class="exampleInner"><pre>final Object x = "value";</pre></div>

<p>XSLT does not provide an equivalent to the Java assignment operator</p>

<div class="exampleInner"><pre>x = "value";</pre></div>

<p>because this would make it harder to create an implementation that
processes a document other than in a batch-like way, starting at the
beginning and continuing through to the end.</p></div>

</div>

<div class="div2">

<h3><a name="with-param"></a>11.6 Passing Parameters to Templates</h3>


  
    
  
  
    
  
  


<p>Parameters are passed to templates using the
<code>xsl:with-param</code> element.  The required <code>name</code>
attribute specifies the name of the parameter (the variable the value
of whose binding is to be replaced).  The value of the
<code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>.  <code>xsl:with-param</code> is allowed
within
<code>xsl:call-template</code>,
<code>xsl:apply-templates</code> and
<code>xsl:apply-imports</code>.
It is an error if a single <code>xsl:call-template</code>,
<code>xsl:apply-templates</code> or <code>xsl:apply-imports</code>
element contains more than one <code>xsl:with-param</code> element
with the same name.
The value of the parameter is
specified in the same way as for <code>xsl:variable</code> and
<code>xsl:param</code>.  The current node and current node list used
for computing the value specified by <code>xsl:with-param</code>
element is the same as that used for the
<code>xsl:apply-templates</code>,
<code>xsl:apply-imports</code>, or
<code>xsl:call-template</code>
element within which it occurs.  It is not an error to pass a
parameter <var>x</var> to a template that does not have an
<code>xsl:param</code> element for <var>x</var>; the parameter is
simply ignored.</p>

<p>This example defines a named template for a
<code>numbered-block</code> with an argument to control the format of
the number.</p>

<div class="exampleInner"><pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

</div>

<div class="div1">

<h2><a name="add-func"></a>12 Additional Functions</h2>

<p>This section describes XSLT-specific additions to the core XPath
function library.  Some of these additional functions also make use of
information specified by <a title="Top-level" href="#dt-top-level">top-level</a>
elements in the stylesheet; this section also describes these
elements.</p>

<div class="div2">


<h3><a name="document"></a>12.1 Multiple Source Documents</h3>

<p><em>node-set</em> <b>document</b>(<var>object</var>
, <var>node-set</var>?)</p>

<p>The <code>document</code> function allows
access to XML documents other than the main source document.</p>

<p>When the <code>document</code> function has exactly one
argument and the argument is a node-set, then the result is the union,
for each node in the argument node-set, of the result of calling the
<code>document</code> function with the first argument being
the <a href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a>
of the node, and the second argument being a node-set with the node as
its only member. When the <code>document</code> function has
two arguments and the first argument is a node-set, then the result is
the union, for each node in the argument node-set, of the result of
calling the <code>document</code> function with the first
argument being the <a href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a> of the node,
and with the second argument being the second argument passed to the
<code>document</code> function.</p>

<p>When the first argument to the <code>document</code>
function is not a node-set, the first argument is converted to a
string as if by a call to the string function.
This string is treated as a URI reference; the resource identified by
the URI is retrieved. The data resulting from the retrieval action is
parsed as an XML document and a tree is constructed in accordance with
the data model (see <a href="#data-model"><b>3 Data Model</b></a>).  If there is an
error retrieving the resource, then the XSLT processor may signal an
error; if it does not signal an error, it must recover by returning an
empty node-set.  One possible kind of retrieval error is that the XSLT
processor does not support the URI scheme used by the URI.  An XSLT
processor is not required to support any particular URI schemes.  The
documentation for an XSLT processor should specify which URI schemes
the XSLT processor supports.</p>

<p>If the URI reference does not contain a fragment identifier, then a
node-set containing just the root node of the document is returned.
If the URI reference does contain a fragment identifier, the function
returns a node-set containing the nodes in the tree identified by the
fragment identifier of the URI reference. The semantics of the
fragment identifier are
dependent on the media type of the result of retrieving the URI.  If
there is an error in processing the fragment identifier, the XSLT
processor may signal the error; if it does not signal the error, it
must recover by returning an empty node-set.  Possible errors
include:</p>

<ul>

<li><p>The fragment identifier identifies something that cannot be
represented by an XSLT node-set (such as a range of characters within
a text node).</p></li>

<li><p>The XSLT processor does not support fragment identifiers for
the media-type of the retrieval result.  An XSLT processor is not
required to support any particular media types.  The documentation for
an XSLT processor should specify for which media types the XSLT
processor supports fragment identifiers.</p></li>

</ul>

<p>The data resulting from the retrieval action is parsed as an XML
document regardless of the media type of the retrieval result; if the
top-level media type is <code>text</code>, then it is parsed in the
same way as if the media type were <code>text/xml</code>; otherwise,
it is parsed in the same way as if the media type were
<code>application/xml</code>.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Since there is no top-level <code>xml</code> media type, data
with a media type other than <code>text/xml</code> or
<code>application/xml</code> may in fact be XML.</p></div>

<p>The URI reference may be relative. The base URI (see <a href="#base-uri"><b>3.2 Base URI</b></a>) of the node in the second argument node-set that is
first in document order is used as the base URI for resolving the
relative URI into an absolute URI. It
is an error if the second argument node-set is empty and the URI
reference is relative; the XSLT processor may signal the error; if it
does not signal an error, it must recover by returning an empty
node-set. If the second argument is omitted,
then it defaults to the node in the stylesheet that contains the
expression that includes the call to the <code>document</code>
function.  Note that a zero-length URI reference is a reference to the
document relative to which the URI reference is being resolved; thus
<code>document("")</code> refers to the root node of the stylesheet;
the tree representation of the stylesheet is exactly the same as if
the XML document containing the stylesheet was the initial source
document.</p>

<p>Two documents are treated as the same document if they are
identified by the same URI. The URI used for the comparison is the
absolute URI into which any relative URI was resolved and does not
include any fragment identifier.  One root node is treated as the same
node as another root node if the two nodes are from the same document.
Thus, the following expression will always be true:</p>

<div class="exampleInner"><pre>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</pre></div>

<p>The <code>document</code> function gives rise to the
possibility that a node-set may contain nodes from more than one
document.  With such a node-set, the relative document order of two
nodes in the same document is the normal <a href="http://www.w3.org/TR/xpath#dt-document-order">document order</a> defined by
XPath <a href="#XPATH">[XPath]</a>.  The relative document order of two nodes
in different documents is determined by an implementation-dependent
ordering of the documents containing the two nodes.  There are no
constraints on how the implementation orders documents other than that
it must do so consistently: an implementation must always use the same
order for the same set of documents.</p>

</div>

<div class="div2">

<h3><a name="key"></a>12.2 Keys</h3>

<p>Keys provide a way to work with documents that contain an implicit
cross-reference structure.  The <code>ID</code>, <code>IDREF</code>
and <code>IDREFS</code> attribute types in XML provide a mechanism to
allow XML documents to make their cross-reference explicit.  XSLT
supports this through the XPath id function.
However, this mechanism has a number of limitations:</p>

<ul>

<li><p>ID attributes must be declared as such in the DTD.  If an ID
attribute is declared as an ID attribute only in the external DTD
subset, then it will be recognized as an ID attribute only if the XML
processor reads the external DTD subset.  However, XML does not require
XML processors to read the external DTD, and they may well choose not
to do so, especially if the document is declared
<code>standalone="yes"</code>.</p></li>

<li><p>A document can contain only a single set of unique IDs.
There cannot be separate independent sets of unique IDs.</p></li>

<li><p>The ID of an element can only be specified in an attribute;
it cannot be specified by the content of the element, or by a child
element.</p></li>

<li><p>An ID is constrained to be an XML name.  For example, it
cannot contain spaces.</p></li>

<li><p>An element can have at most one ID.</p></li>

<li><p>At most one element can have a particular ID.</p></li>

</ul>

<p>Because of these limitations XML documents sometimes contain a
cross-reference structure that is not explicitly declared by
ID/IDREF/IDREFS attributes.</p>

<p>A key is a triple containing:</p>

<ol>

<li><p>the node which has the key</p></li>

<li><p>the name of the key (an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>)</p></li>

<li><p>the value of the key (a string)</p></li>

</ol>

<p>A stylesheet declares a set of keys for each document using the
<code>xsl:key</code> element.  When this set of keys contains a member
with node <var>x</var>, name <var>y</var> and value
<var>z</var>, we say that node <var>x</var> has a key with name
<var>y</var> and value <var>z</var>.</p>

<p>Thus, a key is a kind of generalized ID, which is not subject to the
same limitations as an XML ID:</p>

<ul>

<li><p>Keys are declared in the stylesheet using
<code>xsl:key</code> elements.</p></li>

<li><p>A key has a name as well as a value; each key name may be
thought of as distinguishing a separate, independent space of
identifiers.</p></li>

<li><p>The value of a named key for an element may be specified in
any convenient place; for example, in an attribute, in a child element
or in content.  An XPath expression is used to specify where to find
the value for a particular named key.</p></li>

<li><p>The value of a key can be an arbitrary string; it is not
constrained to be a name.</p></li>

<li><p>There can be multiple keys in a document with the same node,
same key name, but different key values.</p></li>

<li><p>There can be multiple keys in a document with the same key
name, same key value, but different nodes.</p></li>

</ul>


  
  
    
  
  
    
  
  
    
  
  


<p>The <code>xsl:key</code> element is used to declare keys.  The
<code>name</code> attribute specifies the name of the key.  The value
of the <code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>. The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a>; an <code>xsl:key</code> element gives
information about the keys of any node that matches the pattern
specified in the match attribute.  The <code>use</code> attribute is
an <a title="Expression" href="#dt-expression">expression</a> specifying the
values of the key; the expression is evaluated once for each node that
matches the pattern.  If the result is a node-set, then for each node
in the node-set, the node that matches the pattern has a key of the
specified name whose value is the string-value of the node in the
node-set; otherwise, the result is converted to a string, and the node
that matches the pattern has a key of the specified name with value
equal to that string.  Thus, a node <var>x</var> has a key with name
<var>y</var> and value <var>z</var> if and only if there is an
<code>xsl:key</code> element such that:</p>

<ul>

<li><p><var>x</var> matches the pattern specified in the
<code>match</code> attribute of the <code>xsl:key</code> element;</p></li>

<li><p>the value of the <code>name</code> attribute of the
<code>xsl:key</code> element is equal to <var>y</var>;
and</p></li>

<li><p>when the expression specified in the <code>use</code>
attribute of the <code>xsl:key</code> element is evaluated with
<var>x</var> as the current node and with a node list containing
just <var>x</var> as the current node list resulting in an object
<var>u</var>, then either <var>z</var> is equal to the result of
converting <var>u</var> to a string as if by a call to the
string function, or <var>u</var> is a
node-set and <var>z</var> is equal to the string-value of one or
more of the nodes in <var>u</var>.</p></li>

</ul>

<p>Note also that there may be more than one <code>xsl:key</code>
element that matches a given node; all of the matching
<code>xsl:key</code> elements are used, even if they do not have the
same <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a>.</p>

<p>It is an error for the value of either the <code>use</code>
attribute or the <code>match</code> attribute to contain a <a href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</a>, or a call to the
<code>key</code> function.</p>

<p><em>node-set</em> <b>key</b>(<var>string</var>, <var>object</var>)</p>

<p>The <code>key</code> function does for keys what the
id function does for IDs.  The first argument
specifies the name of the key. The value of the argument must be a
<a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as
described in <a href="#qname"><b>2.4 Qualified Names</b></a>. When the second argument to the
<code>key</code> function is of type node-set, then the result
is the union of the result of applying the <code>key</code>
function to the <a href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a> of
each of the nodes in the argument node-set.  When the second argument
to <code>key</code> is of any other type, the argument is
converted to a string as if by a call to the
string function; it returns a node-set
containing the nodes in the same document as the context node that
have a value for the named key equal to this string.</p>

<p>For example, given a declaration</p>

<div class="exampleInner"><pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre></div>

<p>an expression <code>key("idkey",@ref)</code> will return the same
node-set as <code>id(@ref)</code>, assuming that the only ID attribute
declared in the XML source document is:</p>

<div class="exampleInner"><pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre></div>

<p>and that the <code>ref</code> attribute of the current node
contains no whitespace.</p>

<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>

<div class="exampleInner"><pre>&lt;prototype name="key" return-type="node-set"&gt;
&lt;arg type="string"/&gt;
&lt;arg type="object"/&gt;
&lt;/prototype&gt;</pre></div>

<p>and a <code>function</code> element to refer to function names</p>

<div class="exampleInner"><pre>&lt;function&gt;key&lt;/function&gt;</pre></div>

<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>

<div class="exampleInner"><pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The <code>key</code> always
returns nodes that are in the same document as the current node; to
retrieve a key from any other document, it is necessary first to
change the current node. For
example, suppose a document contains bibliographic references in the
form <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a
separate XML document <code>bib.xml</code> containing a bibliographic
database with entries in the form:</p>

<div class="exampleInner"><pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre></div>

<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>

<div class="exampleInner"><pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:for-each select="document('bib.xml')"&gt;
    &lt;xsl:apply-templates select="key('bib',$name)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

<div class="div2">

<h3><a name="format-number"></a>12.3 Number Formatting</h3>

<p><em>string</em> <b>format-number</b>(<var>number</var>, <var>string</var>, <var>string</var>?)</p>

<p>The <code>format-number</code> function converts its first
argument to a string using the format pattern string specified by the
second argument and the decimal-format named by the third argument, or
the default decimal-format, if there is no third argument.  The format
pattern string is in the syntax specified by the JDK 1.1 <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html">DecimalFormat</a> class. The format pattern string is in a
localized notation: the decimal-format determines what characters have
a special meaning in the pattern (with the exception of the quote
character, which is not localized).  The format pattern must not
contain the currency sign (#x00A4); support for this feature was added
after the initial release of JDK 1.1.  The decimal-format name must be
a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as
described in <a href="#qname"><b>2.4 Qualified Names</b></a>.  It is an error if the stylesheet
does not contain a declaration of the decimal-format with the specified
<a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are not required to use the JDK 1.1
implementation, nor are implementations required to be implemented in
Java.</p></div>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Stylesheets can use other facilities in XPath to control
rounding.</p></div>


  
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  
    
  
  


<p>The <code>xsl:decimal-format</code> element declares a
decimal-format, which controls the interpretation of a format pattern
used by the <code>format-number</code> function.  If there is
a <code>name</code> attribute, then the element declares a named
decimal-format; otherwise, it declares the default decimal-format.
The value of the <code>name</code> attribute is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>, which is expanded as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>.  It is an error to declare either the
default decimal-format or a decimal-format with a given name more than
once (even with different <a title="Import Precedence" href="#dt-import-precedence">import
precedence</a>), unless it is declared every time with the same
value for all attributes (taking into account any default values). If a stylesheet does not contain a declaration of
the default decimal format, a declaration equivalent to
an <code>xsl:decimal-format</code> element with no attributes
is implied.</p>

<p>The other attributes on <code>xsl:decimal-format</code> correspond
to the methods on the JDK 1.1 <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</a> class.  For each
<code>get</code>/<code>set</code> method pair there is an attribute
defined for the <code>xsl:decimal-format</code> element.</p>

<p>The following attributes both control the interpretation of
characters in the format pattern and specify characters that may
appear in the result of formatting the number:</p>

<ul>

<li><p><code>decimal-separator</code> specifies the character used
for the decimal sign; the default value is the period character
(<code>.</code>)</p></li>

<li><p><code>grouping-separator</code> specifies the character used
as a grouping (e.g. thousands) separator; the default value is the
comma character (<code>,</code>)</p></li>

<li><p><code>percent</code> specifies the character used as a
percent sign; the default value is the percent character
(<code>%</code>)</p></li>

<li><p><code>per-mille</code> specifies the character used as a per
mille sign; the default value is the Unicode per-mille character
(#x2030)</p></li>

<li><p><code>zero-digit</code> specifies the character used as the
digit zero; the default value is the digit zero
(<code>0</code>)</p></li>

</ul>

<p>The following attributes control the interpretation of characters
in the format pattern:</p>

<ul>

<li><p><code>digit</code> specifies the character used for a digit
in the format pattern; the default value is the number sign character
(<code>#</code>)</p></li>

<li><p><code>pattern-separator</code> specifies the character used
to separate positive and negative sub patterns in a pattern; the
default value is the semi-colon character (<code>;</code>)</p></li>

</ul>

<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>

<ul>

<li><p><code>infinity</code> specifies the string used to represent
infinity; the default value is the string
<code>Infinity</code></p></li>

<li><p><code>NaN</code> specifies the string used to represent the
NaN value; the default value is the string <code>NaN</code></p></li>

<li><p><code>minus-sign</code> specifies the character used as the
default minus sign; the default value is the hyphen-minus character
(<code>-</code>, #x2D)</p></li>

</ul>

</div>

<div class="div2">

<h3><a name="misc-func"></a>12.4 Miscellaneous Additional Functions</h3>

<p><em>node-set</em> <b>current</b>()</p>

<p>The <code>current</code> function returns a node-set that
has the <a title="Current Node" href="#dt-current-node">current node</a> as its
only member.  For an outermost expression (an expression not occurring
within another expression), the current node is always the same as the
context node.  Thus,</p>

<div class="exampleInner"><pre>&lt;xsl:value-of select="current()"/&gt;</pre></div>

<p>means the same as</p>

<div class="exampleInner"><pre>&lt;xsl:value-of select="."/&gt;</pre></div>

<p>However, within square brackets the current node is usually
different from the context node. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</pre></div>

<p>will process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute with value equal to the value of the current node's
<code>ref</code> attribute. This is different from</p>

<div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</pre></div>

<p>which means the same as</p>

<div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</pre></div>

<p>and so would process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute and a <code>ref</code> attribute with the same value.</p>

<p>It is an error to use the <code>current</code> function in
a <a title="Pattern" href="#dt-pattern">pattern</a>.</p>

<p><em>string</em> <b>unparsed-entity-uri</b>(<var>string</var>)</p>

<p>The <code>unparsed-entity-uri</code> returns the URI of the
unparsed entity with the specified name in the same document as the
context node (see <a href="#unparsed-entities"><b>3.3 Unparsed Entities</b></a>).  It returns the
empty string if there is no such entity.</p>

<p><em>string</em> <b>generate-id</b>(<var>node-set</var>?)</p>

<p>The <code>generate-id</code> function returns a string that
uniquely identifies the node in the argument node-set that is first in
document order.  The unique identifier must consist of ASCII
alphanumeric characters and must start with an alphabetic character.
Thus, the string is syntactically an XML name.  An implementation is
free to generate an identifier in any convenient way provided that it
always generates the same identifier for the same node and that
different identifiers are always generated from different nodes. An
implementation is under no obligation to generate the same identifiers
each time a document is transformed.  There is no guarantee that a
generated unique identifier will be distinct from any unique IDs
specified in the source document.  If the argument node-set is empty,
the empty string is returned. If the argument is omitted, it defaults
to the context node.</p>

<p><em>object</em> <b>system-property</b>(<var>string</var>)</p>

<p>The argument must evaluate to a string that is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  The <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into a name using
the namespace declarations in scope for the expression. The
<code>system-property</code> function returns an object
representing the value of the system property identified by the name.
If there is no such system property, the empty string should be
returned.</p>

<p>Implementations must provide the following system properties, which
are all in the XSLT namespace:</p>

<blockquote><p>

<code>xsl:version</code>, a number giving the version of XSLT
implemented by the processor; for XSLT processors implementing the
version of XSLT specified by this document, this is the number
1.0

<br><code>xsl:vendor</code>, a string identifying the vendor of the
XSLT processor

<br><code>xsl:vendor-url</code>, a string containing a URL
identifying the vendor of the XSLT processor; typically this is the
host page (home page) of the vendor's Web site.

</p></blockquote>

<p id="diff-26">Vendors must not define additional system
properties in the XSLT namespace.</p>

</div>

</div>

<div class="div1">

<h2><a name="message"></a>13 Messages</h2>


  
  
    
    
  
  


<p>The <code>xsl:message</code> instruction sends a message in a way
that is dependent on the XSLT processor.  The content of the
<code>xsl:message</code> instruction is a template.  The
<code>xsl:message</code> is instantiated by instantiating the content
to create an XML fragment.  This XML fragment is the content of the
message.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>An XSLT processor might implement <code>xsl:message</code> by
popping up an alert box or by writing to a log file.</p></div>

<p>If the <code>terminate</code> attribute has the value
<code>yes</code>, then the XSLT processor should terminate processing
after sending the message.  The default value is <code>no</code>.</p>

<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes an
additional input file to the stylesheet.  For example, suppose
messages for a language <code><var>L</var></code> are stored in an XML
file <code>resources/<var>L</var>.xml</code> in the form:</p>

<div class="exampleInner"><pre>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</pre></div>

<p>Then a stylesheet could use the following approach to localize
messages:</p>

<div class="exampleInner"><pre>&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"/&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div>

</div>

<div class="div1">

<h2><a name="extension"></a>14 Extensions</h2>

<p>XSLT allows two kinds of extension, extension elements and
extension functions.</p>

<p>This version of XSLT does not provide a mechanism for defining
implementations of extension elements. It does
provide a mechanism for defining extension functions; however, XSLT
does not require that XSLT processors support any particular languages
for implementing extensions.
Therefore, an XSLT stylesheet that must
be portable between XSLT implementations cannot rely on particular
extensions being available.  XSLT provides mechanisms that allow an
XSLT stylesheet to determine whether the XSLT processor by which it is
being processed has implementations of particular extensions
available, and to specify what should happen if those extensions are
not available.  If an XSLT stylesheet is careful to make use of these
mechanisms, it is possible for it to take advantage of extensions and
still work with any XSLT implementation.</p>

<div class="div2">

<h3><a name="extension-element"></a>14.1 Using Extension Elements</h3>

<p>[<a name="dt-extension-namespace" title="Extension Namespace">Definition</a>: The
element extension mechanism allows namespaces to be designated as
<b>extension namespace</b>s. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a template, then the element is treated as an instruction
rather than as a literal result element.] The namespace
determines the semantics of the instruction.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Since an element that is a child of an
<code>xsl:stylesheet</code> element is not occurring <em>in a
template</em>, non-XSLT <a title="Top-level" href="#dt-top-level">top-level</a> elements are not extension
elements as defined here, and nothing in this section applies to
them.</p></div>

<p>A namespace is designated as an extension namespace by using an
<code>extension-element-prefixes</code> attribute on an
<code>xsl:stylesheet</code> element or an
<code>xsl:extension-element-prefixes</code> attribute on a literal
result element or extension element.
The value of both these attributes is a
whitespace-separated list of namespace prefixes. The namespace bound
to each of the prefixes is designated as an extension namespace.  It
is an error if there is no namespace bound to the prefix on the
element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
extension namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an extension
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<p>If the XSLT processor does not have an implementation of a
particular extension element available, then the
<code>element-available</code> function must return false for
the name of the element.  When such an extension element is
instantiated, then the XSLT processor must perform fallback for the
element as specified in <a href="#fallback"><b>15 Fallback</b></a>.  An XSLT processor
must not signal an error merely because a template contains an
extension element for which no implementation is available.</p>

<p>If the XSLT processor has an implementation of a particular
extension element available, then the
<code>element-available</code> function must return true for
the name of the element.</p>

</div>

<div class="div2">

<h3><a name="N8607"></a>14.2 Using Extension Functions</h3>

<p>If a <a href="http://www.w3.org/TR/xpath#NT-FunctionName">FunctionName</a> in a
<a href="http://www.w3.org/TR/xpath#NT-FunctionCall">FunctionCall</a> expression is
not an <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a> (i.e. if it
contains a colon), then it is treated as a call to an extension
function.  The <a href="http://www.w3.org/TR/xpath#NT-FunctionName">FunctionName</a>
is expanded to a name using the namespace declarations from the
evaluation context.</p>

<p>If the XSLT processor does not have an implementation of an
extension function of a particular name available, then the
<code>function-available</code> function must return false for
that name.  If such an extension function occurs in an expression and
the extension function is actually called, the XSLT processor must
signal an error.  An XSLT processor must not signal an error merely
because an expression contains an extension function for which no
implementation is available.</p>

<p>If the XSLT processor has an implementation of an extension
function of a particular name available, then the
<code>function-available</code> function must return
true for that name. If such an extension is called, then the XSLT
processor must call the implementation passing it the function call
arguments; the result returned by the implementation is returned as
the result of the function call.</p>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Say something about automatic argument conversions
here.</td></tr></table>

<p>Typically, implementations of extension functions
represent strings as a sequence of code values (usually 16-bit
integers or bytes).  It is possible for an extension function to
return a sequence of code values that cannot be mapped to a sequence
of legal XML characters.  The behavior of an XSLT processor in this
case is implementation-dependent.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Requiring the XSLT processor to check the contents
of every string returned by an extension function could be a
significant performance burden.</p></div>

</div>

<div class="div2">

<h3><a name="external-objects"></a>14.3 External Objects</h3>

<p>[<a name="dt-external-object" title="external object">Definition</a>: Support for
extension functions introduces an additional data-type into the
expression language. This additional data type is called an
<b>external object</b>. A variable may be bound to an object of
type external object instead of one of the four XPath data-types
(string, number, boolean, node-set). An external object represents an
object that is not convertible to one of the four XPath data types
which is created by an external programming language and returned by
an extension function. Expressions can only return values of type
external object by referencing variables of type external object or
calling extension functions that return an external
object.]</p>

<p>An external object may only be passed as an argument to another
extension function. It may not be copied to the result tree or
converted (implicitly or explicitly) to any of the XPath data types.
So, for example, if the <code>myvar</code> variable is bound an
external object, then the following are <em>not</em> allowed:</p>

<ul>
<li>
<p><code>&lt;xsl:copy-of select="$myvar"/&gt; &lt;!--
Cannot copy to result tree --&gt;</code></p>
</li>
<li>
<p><code>&lt;xsl:value-of select="$myvar"/&gt; &lt;!--
Cannot implicitly convert to String --&gt;</code></p>
</li>
<li>
<p><code>&lt;xsl:value-of select="string($myvar)"/&gt;
&lt;!-- Cannot explicitly convert to String --&gt;</code></p>
</li>
</ul>

<p>If an external object is passed to an extension function with an
<a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
whose namespace URI is different from the namespace URI of the
<a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of
the extension function that returned that external object, the
behavior is implementation-dependent.</p>

<p>An extension function can be used to convert the argument to a
string or return an XML fragment to be copied to the result tree if
desired. For example, assuming the <code>myext:print()</code>
extension function accepts an argument of a compatible data type and
returns a string, the following is allowed:</p> <div class="exampleInner"><pre>&lt;!-- Convert to
string with extension function --&gt; &lt;xsl:value-of
select="myext:print($myvar)"/&gt; </pre></div>

<div class="issue"><p class="prefix"><a name="issue-null-external-object"></a><b>Issue (issue-null-external-object):</b></p><p>Should the spec have the
concept that an external object may be null, and provide a way for
testing this, for example, by conversion to
<code>boolean</code>?</p></div>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Define the idea that an external object
"wraps" an object created by an external programming
language.</td></tr></table>

</div>

<div class="div2">

<h3><a name="define-extension-functions"></a>14.4 Defining Extension Functions</h3>


  
  
    
  
  
    
    
    
    
  
  
    
  
  
    
  
  


<p>The top-level <code>xsl:script</code> element provides an
implementation of extension functions in a particular namespace. The
function implementations may be provided as a separate resource.  Some
language bindings also allow the function implementations to be
provided directly in the content of the <code>xsl:script</code>.</p>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Make sure that it is clear that it is allowed to call
extension functions without using xsl:script to define
them.</td></tr></table>

<p>The <code>implements-prefix</code> attribute specifies a namespace
prefix.  This prefix is expanded into a URI using the namespace
declarations in scope on the <code>xsl:script</code> element.  This
URI is the namespace URI of the expanded-names of the functions of
which an implementation is being provided. The implementation of the
extension functions identifies the local names of the functions that
is is implementing.</p>

<p>The <code>language</code> attribute identifies the language used by
the implementation being provided.  It also identifies the way
arguments are passed by the XSLT processor to the implementation of
the extension function, the way results are returned from the
implementation of the extension function, and the way the XSLT
expression context is made available to the extension function
(collectively known as the language binding).  The value must be a
<a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  If the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> does not have a prefix, then it
identifies a language binding specified in this document and must be
<code>ecmascript</code>, <code>javascript</code> or <code>java</code>.
If the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> has a prefix, then
the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into an
<a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> as
described in <a href="#qname"><b>2.4 Qualified Names</b></a>; the expanded-name identifies the
language binding; the language binding in this case is not specified
by this document.  XSLT processors are not required to support any
particular language binding. <code>xsl:script</code> elements with
<code>language</code> values not supported by the processor are
ignored.</p>

<p>When the function implementations are provided as a separate
resource, the content of the <code>xsl:script</code> element must be
empty and the <code>src</code> attribute is required.  The
<code>src</code> attribute is a URI reference that identifies the
resource containing the implementation of the extension functions.
For example,</p>

<ul>
<li>
<p>A Java class:
<code>src="java:com.example.datestuff.DateRoutines"</code></p>
</li>
<li>
<p>An ECMAScript library:
<code>src="http://example.org/somecode.js"</code></p>
</li>
</ul>

<p>When a function implementation is provided locally in the content
of the <code>xsl:script</code> element, the <code>src</code>
attribute must not be specified. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:script implements-prefix="<var>pref</var>" language="<var>lang</var>"&gt;
// Function Declarations in Supported Language Syntax
function f(x)   { ... }
function g(y,z) { ... }
&lt;/xsl:script&gt;</pre></div>

<p>The <code>archive</code> attribute is a whitespace-separated list
of URI references, each pointing to an archive to be loaded by the
processor before executing the extension function.  The
<code>archive</code> attribute may be used on an
<code>xsl:script</code> element regardless of whether that
<code>xsl:script</code> element has a <code>src</code> attribute.</p>

<p>The <code>function-available</code> function can be used to
detect the availability of an extension function provided by an
<code>xsl:script</code> element.  The precise details of what it
means for an extension function to be available is specific to the
language-binding.</p>

<p>A stylesheet can contain any number of <code>xsl:script</code>
elements. The order of these elements is not significant in the
stylesheet, except for fallback behavior. In particular, calls to
extension function can occur before <code>xsl:script</code> elements
that provide implementations of those extension functions.</p>

<p>If there are multiple <code>xsl:script</code> elements with the
same namespace URI but different implementation languages, then each
implementation language corresponds to an alternative implementation
of the same extension functions.  If an XSLT processor supports two
or more of the languages in which an extension function implementation
is provided, then it is free to choose any of its supported
languages, provided that it always chooses the same implementation for
the same extension function namespace URI. A processor is under no
obligation to choose the same implementation each time a document is
transformed.</p>

<p>If there are multiple <code>xsl:script</code> elements with the
same namespace URI and the same language but different import
precedences, a processor must reconcile the separate elements using
the import precedence.  The manner in which the elements are
reconciled is determined by the language binding.  For example, some
language bindings may simply use the <code>xsl:script</code> element
with the highest import precedence; others may merge the
<code>xsl:script</code> elements in some way.  It is an error for two
<code>xsl:script</code> elements with the same import precedence to
implement the same namespace URI for the same language.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by treating the two <code>xsl:script</code> elements as
if the <code>xsl:script</code> element that occurs later in the
stylesheet had a higher import precedence than the other
<code>xsl:script</code> element.</p>

</div>

</div>

<div class="div1">

<h2><a name="fallback"></a>15 Fallback</h2>


  
  


<p>Normally, instantiating an <code>xsl:fallback</code> element does
nothing.  However, when an XSLT processor performs fallback for an
instruction element, if the instruction element has one or more
<code>xsl:fallback</code> children, then the content of each of the
<code>xsl:fallback</code> children must be instantiated in sequence;
otherwise, an error must be signaled. The content of an
<code>xsl:fallback</code> element is a template.</p>

<p>The following functions can be used with the
<code>xsl:choose</code> and <code>xsl:if</code> instructions to
explicitly control how a stylesheet should behave if particular
elements or functions are not available.</p>

<p><em>boolean</em> <b>element-available</b>(<var>string</var>)</p>

<p>The argument must evaluate to a string that is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  The <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> using the
namespace declarations in scope for the expression. If there is a default namespace in scope,
then it is used to expand an unprefixed <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>. The
<code>element-available</code> function returns true if and
only if the expanded-name is the name of an instruction.  If the
expanded-name has a namespace URI equal to the XSLT namespace URI,
then it refers to an element defined by XSLT.  Otherwise, it refers to
an extension element. If the expanded-name has a null namespace URI,
the <code>element-available</code> function will return
false.</p>

<p><em>boolean</em> <b>function-available</b>(<var>string</var>)</p>

<p>The argument must evaluate to a string that is a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  The <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> using the
namespace declarations in scope for the expression. The
<code>function-available</code> function returns true if and
only if the expanded-name is the name of a function in the function
library. If the expanded-name has a non-null namespace URI, then it
refers to an extension function; otherwise, it refers to a function
defined by XPath or XSLT.</p>

</div>

<div class="div1">

<h2><a name="output"></a>16 Output</h2>


  
  
    
      
      
      
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
      
    
  
  
    
      
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
      
    
  
  
    
      
    
  
  


<p>An XSLT processor may output the result tree as a sequence of
bytes, although it is not required to be able to do so (see <a href="#conformance"><b>17 Conformance</b></a>). The <code>xsl:output</code> element allows
stylesheet authors to specify how they wish the result tree to be
output. If an XSLT processor outputs the result tree, it should do so
as specified by the <code>xsl:output</code> element; however, it is
not required to do so. Before the result tree
is output, <a title="Namespace Fixup" href="#dt-namespace-fixup">namespace fixup</a>
is performed (see <a href="#namespace-fixup"><b>3.5 Namespace Fixup</b></a>).</p>

<p>The <code>xsl:output</code> element is only allowed as a <a title="Top-level" href="#dt-top-level">top-level</a> element.
All attributes on <code>xsl:output</code> are interpreted as <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute value
template</a>s. Expressions recognized in the attributes of
<code>xsl:output</code> are evaluated with the same context as used to
process the root node of the source document: the current node is the
root node of the source document and the current node list is a list
containing just the root node of the source document.</p>

<p>The <code>method</code> attribute on <code>xsl:output</code>
identifies the overall method that should be used for outputting the
result tree.  The value must be a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>.  If the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> does not have a prefix, then it
identifies a method specified in this document and must be one of
<code>xml</code>, <code>html</code> or <code>text</code>.  If the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> has a prefix, then the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> as described
in <a href="#qname"><b>2.4 Qualified Names</b></a>; the expanded-name identifies the output
method; the behavior in this case is not specified by this
document.</p>

<p>The default for the <code>method</code> attribute is chosen as
follows.  If</p>

<ul>

<li><p>the root node of the result tree has an element
child,</p></li>

<li><p>the expanded-name of the first element child of the root node
(i.e. the document element) of the result tree has local part
<code>html</code> (in any combination of upper and lower case) and a
null namespace URI, and</p></li>

<li><p>any text nodes preceding the first element child of the root
node of the result tree contain only whitespace characters,</p></li>

</ul>

<p>then the default output method is <code>html</code>; otherwise, the
default output method is <code>xml</code>.  The default output method
should be used if there are no <code>xsl:output</code> elements or if
none of the <code>xsl:output</code> elements specifies a value for the
<code>method</code> attribute.</p>

<p>The other attributes on <code>xsl:output</code> provide parameters
for the output method.  The following attributes are allowed:</p>

<ul>

<li><p><code>version</code> specifies the version of the output
method</p></li>

<li><p><code>indent</code> specifies whether the XSLT processor may
add additional whitespace when outputting the result tree; the value
must be <code>yes</code> or <code>no</code></p></li>

<li><p><code>encoding</code> specifies the preferred character
encoding that the XSLT processor should use to encode sequences of
characters as sequences of bytes; the value of the attribute should be
treated case-insensitively; the value must contain only characters in
the range #x21 to #x7E (i.e. printable ASCII characters); the value
should either be a <code>charset</code> registered with the Internet
Assigned Numbers Authority <a href="#IANA">[IANA]</a>, <a href="#RFC2278">[RFC2278]</a> or start with <code>X-</code></p></li>

<li><p><code>media-type</code> specifies the media type (MIME
content type) of the data that results from outputting the result
tree; the <code>charset</code> parameter should not be specified
explicitly; instead, when the top-level media type is
<code>text</code>, a <code>charset</code> parameter should be added
according to the character encoding actually used by the output
method</p></li>

<li><p><code>doctype-system</code> specifies the system identifier
to be used in the document type declaration</p></li>

<li><p><code>doctype-public</code> specifies the public identifier
to be used in the document type declaration</p></li>

<li><p><code>omit-xml-declaration</code> specifies whether the XSLT
processor should output an XML declaration; the value must be
<code>yes</code> or <code>no</code></p></li>

<li><p><code>standalone</code> specifies whether the XSLT processor
should output a standalone document declaration; the value must be
<code>yes</code> or <code>no</code></p></li>

<li><p><code>cdata-section-elements</code> specifies a list of the
names of elements whose text node children should be output using
CDATA sections</p></li>

</ul>

<p>The detailed semantics of each attribute will be described
separately for each output method for which it is applicable.  If the
semantics of an attribute are not described for an output method, then
it is not applicable to that output method.</p>

<p>A stylesheet may contain multiple <code>xsl:output</code> elements
and may include or import stylesheets that also contain
<code>xsl:output</code> elements.  All the <code>xsl:output</code>
elements occurring in a stylesheet are merged into a single effective
<code>xsl:output</code> element. For the
<code>cdata-section-elements</code> attribute, the effective value is
the union of the specified values.  For other attributes, the
effective value is the specified value with the highest <a title="Import Precedence" href="#dt-import-precedence">import precedence</a>. It is an error
if there is more than one such value for an attribute.  An XSLT
processor may signal the error; if it does not signal the error, if
should recover by using the value that occurs last in the stylesheet.
The values of attributes are defaulted after the
<code>xsl:output</code> elements have been merged; different output
methods may have different default values for an attribute.</p>

<div class="div2">

<h3><a name="N9628"></a>16.1 XML Output Method</h3>

<p>The <code>xml</code> output method outputs the result tree as a
well-formed XML external general parsed entity. If the root node of
the result tree has a single element node child and no text node
children, then the entity should also be a well-formed XML document
entity. When the entity is referenced within a trivial XML document
wrapper like this</p>

<div class="exampleInner"><pre>
&lt;!DOCTYPE doc [
&lt;!ENTITY e SYSTEM "<var>entity-URI</var>"&gt;
]&gt;
&lt;doc&gt;&amp;e;&lt;/doc&gt;</pre></div>

<p>where <code><var>entity-URI</var></code> is a URI for the entity,
then the wrapper
document as a whole should be a well-formed XML document conforming to
the XML Namespaces Recommendation <a href="#XMLNAMES">[XML Names]</a>.  In
addition, the output should be such that if a new tree was constructed
by parsing the wrapper as an XML document as specified in <a href="#data-model"><b>3 Data Model</b></a>, and then removing the document element, making its
children instead be children of the root node, then the new tree would
be the same as the result tree, with the following possible
exceptions:</p>

<ul>

<li><p>The order of attribute and
namespace nodes in the two trees may be different.</p></li>

<li><p id="diff-29">The base URIs of nodes in the two
trees may be different.</p></li>

</ul>

<p>If the XSLT processor generated a document type declaration because
of the <code>doctype-system</code> attribute or generated a standalone document declaration because
of the <code>standalone</code> attribute, then the output must be a well-formed XML
document, and the above requirements apply to the tree constructed by parsing that document
directly, without any wrapper, using an XML processor that does not
process the DTD.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Processing the DTD might cause
additional attributes to appear in the tree because of attribute
defaulting.</p></div>

<p>The <code>version</code> attribute specifies the version of XML to
be used for outputting the result tree.  If the XSLT processor does
not support this version of XML, it should use a version of XML that
it does support.  The version output in the XML declaration (if an XML
declaration is output) should correspond to the version of XML that
the processor used for outputting the result tree. The value of the
<code>version</code> attribute should match the <a href="http://www.w3.org/TR/REC-xml#NT-VersionNum">VersionNum</a> production of the XML
Recommendation <a href="#XML">[XML]</a>. The default value is
<code>1.0</code>.</p>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to use for outputting the result tree.  XSLT processors are
required to respect values of <code>UTF-8</code> and
<code>UTF-16</code>.  For other values, if the XSLT processor does not
support the specified encoding it may signal an error; if it does not
signal an error it should use <code>UTF-8</code> or
<code>UTF-16</code> instead.  The XSLT processor must not use an
encoding whose name does not match the <a href="http://www.w3.org/TR/REC-xml#NT-EncName">EncName</a> production of the XML
Recommendation <a href="#XML">[XML]</a>.  If no <code>encoding</code>
attribute is specified, then the XSLT processor should use either
<code>UTF-8</code> or <code>UTF-16</code>.  It is possible that the
result tree will contain a character that cannot be represented in the
encoding that the XSLT processor is using for output.  In this case,
if the character occurs in a context where XML recognizes character
references (i.e. in the value of an attribute node or text node), then
the character should be output as a character reference; otherwise
(for example if the character occurs in the name of an element) the
XSLT processor should signal an error.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>xml</code> output method may output
whitespace in addition to the whitespace in the result tree (possibly
based on whitespace stripped from either the source document or the
stylesheet) in order to indent the result nicely; if the
<code>indent</code> attribute has the value <code>no</code>, it should
not output any additional whitespace. The default value is
<code>no</code>.  The <code>xml</code> output method should use an
algorithm to output additional whitespace that ensures that the result
if whitespace were to be stripped from the output using the process
described in <a href="#strip"><b>3.4 Whitespace Stripping</b></a> with the set of
whitespace-preserving elements consisting of just
<code>xsl:text</code> would be the same when additional whitespace is
output as when additional whitespace is not output.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>It is usually not safe to use <code>indent="yes"</code> with
document types that include element types with mixed content.</p></div>

<p>The <code>cdata-section-elements</code> attribute contains a
whitespace-separated list of <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>s.  Each <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> is expanded into an
expanded-name using the namespace declarations in effect on the
<code>xsl:output</code> element in which the <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> occurs; if there is a default
namespace, it is used for <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>s
that do not have a prefix.  The expansion is performed before the
merging of multiple <code>xsl:output</code> elements into a single
effective <code>xsl:output</code> element. If the expanded-name of the
parent of a text node is a member of the list, then the text node
should be output as a CDATA section. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:output cdata-section-elements="example"/&gt;</pre></div>

<p>would cause a literal result element written in the stylesheet as</p>

<div class="exampleInner"><pre>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</pre></div>

<p>or as</p>

<div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div>

<p>to be output as</p>

<div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div>

<p>If the text node contains the sequence of characters
<code>]]&gt;</code>, then the currently open CDATA section should be
closed following the <code>]]</code> and a new CDATA section opened
before the <code>&gt;</code>. For example, a literal result element
written in the stylesheet as</p>

<div class="exampleInner"><pre>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</pre></div>

<p>would be output as</p>

<div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</pre></div>

<p>If the text node contains a character that is not representable in
the character encoding being used to output the result tree, then the
currently open CDATA section should be closed before the character,
the character should be output using a character reference or entity
reference, and a new CDATA section should be opened for any further
characters in the text node.</p>

<p>CDATA sections should not be used except for text nodes that the
<code>cdata-section-elements</code> attribute explicitly specifies
should be output using CDATA sections.</p>

<p>The <code>xml</code> output method should output an XML declaration
unless the <code>omit-xml-declaration</code> attribute has the value
<code>yes</code>. The XML declaration should include both version
information and an encoding declaration. If the
<code>standalone</code> attribute is specified, it should include a
standalone document declaration with the same value as the value as
the value of the <code>standalone</code> attribute.  Otherwise, it
should not include a standalone document declaration; this ensures
that it is both an XML
declaration (allowed at the beginning of a document entity) and a text
declaration (allowed at the beginning of an external general parsed
entity).</p>

<p>If the <code>doctype-system</code> attribute is specified, the
<code>xml</code> output method should output a document type
declaration immediately before the first element.  The name following
<code>&lt;!DOCTYPE</code> should be the name of the first element.  If
<code>doctype-public</code> attribute is also specified, then the
<code>xml</code> output method should output <code>PUBLIC</code>
followed by the public identifier and then the system identifier;
otherwise, it should output <code>SYSTEM</code> followed by the system
identifier.  The internal subset should be empty.  The
<code>doctype-public</code> attribute should be ignored unless the
<code>doctype-system</code> attribute is specified.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>xml</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/xml</code>.</p>

</div>

<div class="div2">

<h3><a name="N9978"></a>16.2 HTML Output Method</h3>

<p>The <code>html</code> output method outputs the result tree as
HTML; for example,</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

...

&lt;/xsl:stylesheet&gt;</pre></div>

<p>The <code>version</code> attribute indicates the version of the
HTML.  The default value is <code>4.0</code>, which specifies that the
result should be output as HTML conforming to the HTML 4.0
Recommendation <a href="#HTML">[HTML]</a>.</p>

<p>The <code>html</code> output method should not output an element
differently from the <code>xml</code> output method unless the
expanded-name of the element has a null namespace URI; an element
whose expanded-name has a non-null namespace URI should be output as
XML.  If the expanded-name of the element has a null namespace URI,
but the local part of the expanded-name is not recognized as the name
of an HTML element, the element should output in the same way as a
non-empty, inline element such as <code>span</code>.</p>

<p>The <code>html</code> output method should not output an end-tag
for empty elements.  For HTML 4.0, the empty elements are
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> and
<code>param</code>. For example, an element written as
<code>&lt;br/&gt;</code> or <code>&lt;br&gt;&lt;/br&gt;</code> in the
stylesheet should be output as <code>&lt;br&gt;</code>.</p>

<p>The <code>html</code> output method should recognize the names of
HTML elements regardless of case.  For example, elements named
<code>br</code>, <code>BR</code> or <code>Br</code> should all be
recognized as the HTML <code>br</code> element and output without an
end-tag.</p>

<p>The <code>html</code> output method should not perform escaping for
the content of the <code>script</code> and <code>style</code>
elements. For example, a literal result element written in the
stylesheet as</p>

<div class="exampleInner"><pre>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</pre></div>

<p>or</p>

<div class="exampleInner"><pre>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</pre></div>

<p>should be output as</p>

<div class="exampleInner"><pre>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</pre></div>

<p>The <code>html</code> output method should not escape
<code>&lt;</code> characters occurring in attribute values.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>html</code> output method may add or
remove whitespace as it outputs the result tree, so long as it does
not change how an HTML user agent would render the output.  The
default value is <code>yes</code>.</p>

<p>The <code>html</code> output method should escape non-ASCII
characters in URI attribute values using the method recommended in
<a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">Section
B.2.1</a> of the HTML 4.0 Recommendation.</p>

<p>The <code>html</code> output method may output a character using a
character entity reference, if one is defined for it in the version of
HTML that the output method is using.</p>

<p>The <code>html</code> output method should terminate processing
instructions with <code>&gt;</code> rather than
<code>?&gt;</code>.</p>

<p>The <code>html</code> output method should output boolean
attributes (that is attributes with only a single allowed value that
is equal to the name of the attribute) in minimized form. For example,
a start-tag written in the stylesheet as</p>

<div class="exampleInner"><pre>&lt;OPTION selected="selected"&gt;</pre></div>

<p>should be output as</p>

<div class="exampleInner"><pre>&lt;OPTION selected&gt;</pre></div>

<p>The <code>html</code> output method should not escape a
<code>&amp;</code> character occurring in an attribute value
immediately followed by a <code>{</code> character (see <a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">Section
B.7.1</a> of the HTML 4.0 Recommendation). For example, a start-tag
written in the stylesheet as</p>

<div class="exampleInner"><pre>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</pre></div>

<p>should be output as</p>

<div class="exampleInner"><pre>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</pre></div>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to be used. If there is a <code>HEAD</code> element, then the
<code>html</code> output method should add a <code>META</code> element
immediately after the start-tag of the <code>HEAD</code> element
specifying the character encoding actually used. For example,</p>

<div class="exampleInner"><pre>&lt;HEAD&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</pre></div>

<p>It is possible that the result tree will contain a character that
cannot be represented in the encoding that the XSLT processor is using
for output.  In this case, if the character occurs in a context where
HTML recognizes character references, then the character should be
output as a character entity reference or decimal numeric character
reference; otherwise (for example, in a
<code>script</code> or <code>style</code> element or in a comment),
the XSLT processor should signal an error.</p>

<p>If the <code>doctype-public</code> or <code>doctype-system</code>
attributes are specified, then the <code>html</code> output method
should output a document type declaration immediately before the first
element.  The name following <code>&lt;!DOCTYPE</code> should be
<code>HTML</code> or <code>html</code>.  If the
<code>doctype-public</code> attribute is specified, then the output
method should output <code>PUBLIC</code> followed by the specified
public identifier; if the <code>doctype-system</code> attribute is
also specified, it should also output the specified system identifier
following the public identifier.  If the <code>doctype-system</code>
attribute is specified but the <code>doctype-public</code> attribute
is not specified, then the output method should output
<code>SYSTEM</code> followed by the specified system identifier.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>html</code> output method.  The default value is
<code>text/html</code>.</p>

</div>

<div class="div2">

<h3><a name="N10310"></a>16.3 Text Output Method</h3>

<p>The <code>text</code> output method outputs the result tree by
outputting the string-value of every text node in the result tree in
document order without any escaping.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>text</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/plain</code>.</p>

<p>The <code>encoding</code> attribute identifies the encoding that
the <code>text</code> output method should use to convert sequences of
characters to sequences of bytes.  The default is system-dependent. If
the result tree contains a character that cannot be represented in the
encoding that the XSLT processor is using for output, the XSLT
processor should signal an error.</p>

</div>

<div class="div2">

<h3><a name="disable-output-escaping"></a>16.4 Disabling Output Escaping</h3>

<p>Normally, the <code>xml</code> output method escapes &amp; and &lt;
(and possibly other characters) when outputting text nodes.  This
ensures that the output is well-formed XML. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed
sections which are intended to be transformed into well-formed XML by
a subsequent non-XML aware process.  For this reason, XSLT provides a
mechanism for disabling output escaping. An <code>xsl:value-of</code>
or <code>xsl:text</code> element may have a
<code>disable-output-escaping</code> attribute; the allowed values are
<code>yes</code> or <code>no</code>; the default is <code>no</code>;
if the value is <code>yes</code>, then a text node generated by
instantiating the <code>xsl:value-of</code> or <code>xsl:text</code>
element should be output without any escaping. For example,</p>

<div class="exampleInner"><pre>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</pre></div>

<p>should generate the single character <code>&lt;</code>.</p>

<p>It is an error for output escaping to be disabled for a text node
that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an
<code>xsl:value-of</code> or <code>xsl:text</code> element that is
used to generate the string-value of a comment, processing instruction
or attribute node; it is also an error to convert a node-set to a number or a string if the node-set contains a text node for which escaping
was disabled.  In both cases, an XSLT processor may signal the error;
if it does not signal the error, it must recover by ignoring the
<code>disable-output-escaping</code> attribute.</p>

<p id="diff-35">When a root node is copied using an
<code>xsl:copy-of</code> element (see <a href="#copy-of"><b>11.3 Using Values of Variables and Parameters with
xsl:copy-of</b></a>) and
escaping was disabled for a text node descendant of that root node,
then escaping should also be disabled for the resulting copy of that
text node. For example</p>

<div class="exampleInner"><pre>&lt;xsl:variable name="x"&gt;
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
&lt;/xsl:variable&gt;
&lt;xsl:copy-of select="$x"/&gt;</pre></div>

<p>should output <code>&lt;</code> not
<code>&amp;lt;</code>.</p>

<p>Text nodes for which escaping is disabled are subject to
merging with text nodes that are adjacent in the result tree in the
same way as text nodes for which is escaping is not disabled.  An
element or root node in the result tree never has two consecutive text
node children. Thus, it is possible for a escaping to be disabled for
some but not all of the characters in a text node.</p>

<p>The <code>disable-output-escaping</code> attribute may be used with
the <code>html</code> output method as well as with the
<code>xml</code> output method.  The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since it
does not perform any output escaping.</p>

<p>An XSLT processor will only be able to disable output escaping if
it controls how the result tree is output. This may not always be the
case.  For example, the result tree may be used as the source tree for
another XSLT transformation instead of being output.  An XSLT
processor is not required to support disabling output escaping.  If an
<code>xsl:value-of</code> or <code>xsl:text</code> specifies that
output escaping should be disabled and the XSLT processor does not
support this, the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>If output escaping is disabled for a character that is not
representable in the encoding that the XSLT processor is using for
output, then the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>Since disabling output escaping may not work with all XSLT
processors and can result in XML that is not well-formed, it should be
used only when there is no alternative.</p>


</div>

<div class="div2">

<h3><a name="multiple-output"></a>16.5 Multiple Output Documents</h3>


  
  
    
      
    
  
  
    
      
      
      
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
      
    
  
  
    
      
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
    
  
  
    
      
      
    
  
  
    
      
    
  
  


<p>The <code>xsl:document</code> element is used to create multiple
result documents.  As well as the main result document, there can be
subsidiary result documents.  Each subsidiary result document is
created using an <code>xsl:document</code> element. The content of the
<code>xsl:document</code> element is a template; this is instantiated
to create a sequence of nodes; a root node is created with this
sequence of nodes as its children; the tree with this root node
represents the subsidiary result document. The <code>href</code>
attribute specifies where the subsidiary document should be stored; it
must be an absolute or relative URI; it must not have a fragment
identifier. For example, the following would create a main result
document specifying an HTML frameset with two frames, together with
two subsidiary documents, one for the contents of each frame:</p>

<div class="exampleInner"><pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;&lt;title&gt;Frame example&lt;/title&gt;&lt;/head&gt;
    &lt;frameset cols="20%, 80%"&gt;
      &lt;frame src="toc.html"/&gt;
      &lt;xsl:document href="toc.html"&gt;
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
             &lt;xsl:apply-templates mode="toc" select="*"/&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:document&gt;
      &lt;frame src="body.html"/&gt;
      &lt;xsl:document href="body.html"&gt;
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Body&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
             &lt;xsl:apply-templates select="*"/&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:document&gt;
    &lt;/frameset&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre></div>

<p>The attributes on <code>xsl:output</code> elements affect only the
main result document. The output of a subsidiary result document is
controlled by the attributes on the <code>xsl:document</code> element
that was used to create that subsidiary result document. With the
exception of the <code>href</code> attribute which is allowed only on
<code>xsl:document</code>, the attributes on <code>xsl:document</code>
are applied to a subsidiary result document in the same way that the
attributes on <code>xsl:output</code> are applied to the main result
document. In particular, the <code>method</code> attribute on an
<code>xsl:document</code> element is defaulted based on the content of
the subsidiary document created by that <code>xsl:document</code>
element, not based on the content of the main result document.</p>

<p>Normally, <code>xsl:document</code> can be understood as directly
creating an additional result document.  However, when
<code>xsl:document</code> is used within <code>xsl:variable</code> or
<code>xsl:param</code> elements, the following more sophisticated
conceptual model is needed.</p>

<p>Documents involved in XSLT processing can be divided into two
categories.</p>

<ul>

<li><p>One category contains the documents that the XSLT processor
constructs by instantiating templates; these are the main
result document, subsidiary documents created by
<code>xsl:document</code>, and documents created by a variable-binding
element with content.</p></li>

<li><p>The other category contains the documents
constructed by parsing or other processes external to the XSLT
processor; these are the main source document and documents
returned by the <code>document</code> function.</p></li>

</ul>

<p>With each document in the former category, an XSLT processor
associates a possibly empty set of subsidiary documents. The
relationship between a document and its associated subsidiary
documents thus organizes documents in this category into one or more
unordered trees, where the associated subsidiary documents of a
document are considered the children of that document.  The main
result document is the root of one such tree; the documents created by
variable-binding elements with content are the roots of the other
trees.  Each subsidiary document created by an
<code>xsl:document</code> element has a parent within this tree of
documents.</p>

<p>During the processing of a stylesheet, there is a current result
document; initially this is the main result document; the current
result document is changed by the <code>xsl:document</code> element
and by variable-binding elements with content.  When an
<code>xsl:document</code> element is instantiated, the content is
instantiated with the subsidiary document being created by that
<code>xsl:document</code> element as the current result document. When
a variable-binding element with content is instantiated, the content
is instantiated with the document being created (that is, the document
whose root node is the sole member of the node-set that will be the
value of the variable defined by that element) as the current result
document.  A document created by the instantiation of an
<code>xsl:document</code> is not automatically output; instead, it is
added to the set of subsidiary documents associated with the current
result document.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>xsl:document</code> is allowed inside
<code>xsl:attribute</code>, <code>xsl:comment</code> and
<code>xsl:processing-instruction</code> and behaves in those contexts
in the same way as elsewhere.</p></div>

<div class="issue"><p class="prefix"><a name="issue-message-document"></a><b>Issue (issue-message-document):</b></p><p>What should happen if
<code>xsl:document</code> occurs inside
<code>xsl:message</code>?</p></div>

<p>When a root node is copied with <code>xsl:copy</code> or
<code>xsl:copy-of</code>, the subsidiary documents associated with the
document of which it is the root node are copied and added to the set
of subsidiary documents associated with the current result document.
Copying a subsidiary document copies its subsidiary documents
recursively.</p>

<p>Output conceptually follows the construction of the main result
document and any subsidiary documents.  The XSLT processor outputs the
main result document and its associated subsidiary documents; when the
XSLT processor outputs a subsidiary document it also recursively
outputs its associated subsidiary documents. Apart from this, no other
subsidiary documents are output.  A subsidiary document associated
with the document created by a variable-binding element with content
is not output; only copies created by the copying of the root node of
that document are ever output.</p>

<p>For each document that is output, there is an absolute URI that
can, in the appropriate circumstances, be used to access that
document.  Call this the output URI of the document.  The output URI
of the main result document is system-dependent, typically specified
when the XSLT processor is invoked.  When the <code>href</code>
attribute of a subsidiary document is an absolute URI, then that
absolute URI serves as the output URI.  When the <code>href</code>
attribute of a subsidiary document is a relative URI, the
relative URI is resolved into an absolute URI only if and when the
subsidiary document is output.  The output URI of the document with
which the subsidiary document is associated (ie the output URI of its
parent in the tree of documents) is used as the base URI.  The
resulting absolute URI is used as the output URI of the subsidiary
document.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>The output URI of a document is not dependent on the base URI
of the root node of the document.</p></div>

<p>It is an error if the set of documents to be output as the result
of a single XSLT transformation (that is, the main result document and
its subsidiary documents recursively) contain two documents with the
same output URI.</p>

</div>

</div>

<div class="div1">

<h2><a name="conformance"></a>17 Conformance</h2>

<p>A conforming XSLT processor must be able to use a stylesheet to
transform source trees into result trees as specified in this document.  A
conforming XSLT processor need not be able to output the result in XML
or in any other form.</p>

<div class="note"><p class="prefix"><b>Note:</b></p><p>Vendors of XSLT processors are strongly encouraged to provide
a way to verify that their processor is behaving conformingly by
allowing the result tree to be output as XML or by providing access to
the result tree through a standard API such as the DOM or
SAX.</p></div>

<p>A conforming XSLT processor must signal any errors except for those
that this document specifically allows an XSLT processor not to
signal. A conforming XSLT processor may but need not recover from any
errors that it signals.</p>

<p>A conforming XSLT processor may impose limits on the processing
resources consumed by the processing of a stylesheet.</p>

</div>

<div class="div1">

<h2><a name="notation"></a>18 Notation</h2>

<p>The specification of each XSLT-defined element type is preceded by
a summary of its syntax in the form of a model for elements of that
element type.  The meaning of syntax summary notation is as
follows:</p>

<ul>

<li><p>An attribute is required if and only if its name is in
bold.</p></li>

<li><p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute.  If this is surrounded
by curly braces, then the attribute value is treated as an <a title="Attribute Value Template" href="#dt-attribute-value-template">attribute value template</a>,
and the string occurring within curly braces specifies the allowed
values of the result of instantiating the attribute value template.
Alternative allowed values are separated by <code>|</code>.  A quoted
string indicates a value equal to that specific string. An unquoted,
italicized name specifies a particular type of value.</p></li>

<li><p>If the element is allowed not to be empty, then the element
contains a comment specifying the allowed content.  The allowed
content is specified in a similar way to an element type declaration
in XML; <em>template</em> means that any mixture of text nodes,
literal result elements, extension elements, and XSLT elements from
the <code>instruction</code> category is allowed;
<em>top-level-elements</em> means that any mixture of XSLT
elements from the <code>top-level-element</code> category is
allowed.</p></li>

<li><p>The element is prefaced by comments indicating if it belongs
to the <code>instruction</code> category or
<code>top-level-element</code> category or both.  The category of an
element just affects whether it is allowed in the content of elements
that allow a <em>template</em> or
<em>top-level-elements</em>.</p></li>

</ul>

</div>

</div>

<div class="back">
<div class="div1">

<h2><a name="N10922"></a>A References</h2>
<div class="div2">

<h3><a name="N10927"></a>A.1 Normative References</h3>

<dl>

<dt class="label"><a name="DOM2"></a>DOM2</dt><dd>World Wide Web Consortium. <em>Document
Object Model (DOM) Level 2 Core Specification.</em> W3C
Recommendation. See <a href="http://www.w3.org/TR/DOM-Level-2-Core/">http://www.w3.org/TR/DOM-Level-2-Core/</a></dd>

<dt class="label"><a name="ECMA262"></a>ECMA262</dt><dd>ECMA. <em>ECMA-262,
ECMAScript Language Specification, 3rd Edition</em> ECMA Standard.
See <a href="ftp://ftp.ecma.ch/ecma-st/Ecma-262.pdf">ftp://ftp.ecma.ch/ecma-st/Ecma-262.pdf</a></dd>

<dt class="label"><a name="XML"></a>XML</dt><dd>World Wide Web Consortium. <em>Extensible
Markup Language (XML) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</a></dd>

<dt class="label"><a name="XMLBASE"></a>XMLBASE</dt><dd>World Wide Web
Consortium. <em>XML Base.</em> W3C Candidate Recommendation. See
<a href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a></dd>

<dt class="label"><a name="XMLNAMES"></a>XML Names</dt><dd>World Wide Web
Consortium. <em>Namespaces in XML.</em> W3C Recommendation. See
<a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>

<dt class="label"><a name="XPATH"></a>XPath</dt><dd>World Wide Web Consortium. <em>XML Path
Language.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a></dd>

</dl>
</div>
<div class="div2">

<h3><a name="N11053"></a>A.2 Other References</h3>

<dl>

<dt class="label"><a name="CSS2"></a>CSS2</dt><dd>World Wide Web Consortium.  <em>Cascading
Style Sheets, level 2 (CSS2)</em>.  W3C Recommendation.  See <a href="http://www.w3.org/TR/1998/REC-CSS2-19980512/">http://www.w3.org/TR/1998/REC-CSS2-19980512/</a></dd>

<dt class="label"><a name="DSSSL"></a>DSSSL</dt><dd>International Organization
for Standardization, International Electrotechnical Commission.
<em>ISO/IEC 10179:1996.  Document Style Semantics and Specification
Language (DSSSL)</em>.  International Standard.</dd>

<dt class="label"><a name="HTML"></a>HTML</dt><dd>World Wide Web Consortium. <em>HTML 4.0
specification</em>. W3C Recommendation. See <a href="http://www.w3.org/TR/REC-html40/">http://www.w3.org/TR/REC-html40/</a></dd>

<dt class="label"><a name="IANA"></a>IANA</dt><dd>Internet Assigned Numbers
Authority. <em>Character Sets</em>. See <a href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</a>.</dd>

<dt class="label"><a name="LC3"></a>LC3</dt><dd>Scott Furman. <em>Java Method Overloading and
Live Connect 3</em>. See <a href="http://www.mozilla.org/js/liveconnect/lc3_method_overloading.html">http://www.mozilla.org/js/liveconnect/lc3_method_overloading.html</a>.</dd>

<dt class="label"><a name="RFC2278"></a>RFC2278</dt><dd>N. Freed, J. Postel.  <em>IANA
Charset Registration Procedures</em>.  IETF RFC 2278. See <a href="http://www.ietf.org/rfc/rfc2278.txt">http://www.ietf.org/rfc/rfc2278.txt</a>.</dd>

<dt class="label"><a name="RFC2376"></a>RFC2376</dt><dd>E. Whitehead, M. Murata.  <em>XML
Media Types</em>. IETF RFC 2376. See <a href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</a>.</dd>

<dt class="label"><a name="RFC2396"></a>RFC2396</dt><dd>T. Berners-Lee, R. Fielding, and
L. Masinter.  <em>Uniform Resource Identifiers (URI): Generic
Syntax</em>. IETF RFC 2396. See <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>

<dt class="label"><a name="UNICODE-TR10"></a>UNICODE TR10</dt><dd>Unicode Consortium.
<em>Unicode Technical Report #10. Unicode Collation
Algorithm</em>.  Unicode Technical Report.  See <a href="http://www.unicode.org/unicode/reports/tr10/index.html">http://www.unicode.org/unicode/reports/tr10/index.html</a>.</dd>

<dt class="label"><a name="XHTML"></a>XHTML</dt><dd>World Wide Web Consortium. <em>XHTML
1.0: The Extensible HyperText Markup Language.</em> W3C Proposed
Recommendation. See <a href="http://www.w3.org/TR/xhtml1/">http://www.w3.org/TR/xhtml1/</a></dd>

<dt class="label"><a name="XPTR"></a>XPointer</dt><dd>World Wide Web
Consortium. <em>XML Pointer Language (XPointer).</em> W3C Working
Draft. See <a href="http://www.w3.org/TR/xptr">http://www.w3.org/TR/xptr</a></dd>

<dt class="label"><a name="XMLSTYLE"></a>XML Stylesheet</dt><dd>World Wide Web
Consortium. <em>Associating stylesheets with XML documents.</em>
W3C Recommendation. See <a href="http://www.w3.org/TR/xml-stylesheet/">http://www.w3.org/TR/xml-stylesheet/</a></dd>

<dt class="label"><a name="XSL"></a>XSL</dt><dd>World Wide Web Consortium.  <em>Extensible
Stylesheet Language (XSL).</em>  W3C Working Draft.  See <a href="http://www.w3.org/TR/xsl/">http://www.w3.org/TR/xsl/</a></dd>

<dt class="label"><a name="XSLT10"></a>XSLT10</dt><dd>World Wide Web
Consortium. <em>XSL Transformations (XSLT) Version 1.0</em> W3C
Recommendation. See <a href="http://www.w3.org/TR/1999/REC-xslt-19991116">http://www.w3.org/TR/1999/REC-xslt-19991116</a></dd>

<dt class="label"><a name="XSLT11REQ"></a>XSLT11REQ</dt><dd>World Wide Web
Consortium. <em>XSL Transformations Requirements Version 1.1</em>
W3C Working Draft. See <a href="http://www.w3.org/TR/xslt11req">http://www.w3.org/TR/xslt11req</a></dd>

<dt class="label"><a name="XSLT20REQ"></a>XSLT20REQ</dt><dd>World Wide Web
Consortium. <em>XSL Transformations Requirements Version 2.0</em>
W3C Working Draft. See <a href="http://www.w3.org/TR/xslt20req">http://www.w3.org/TR/xslt20req</a></dd>

</dl>

</div>
</div>

<div class="div1">

<h2><a name="element-syntax-summary"></a>B Element Syntax Summary</h2>



</div>

<div class="div1">

<h2><a name="N11359"></a>C DOM-Based Language Bindings</h2>

<p>This appendix defines three language bindings for extension
functions, each of which use the DOM2 core.</p>

<div class="div2">

<h3><a name="N11368"></a>C.1 DOM Issues</h3>

<p>XSLT Trees are presented to extensions functions in the form of
Document Object Model (DOM) Level 2 <a href="#DOM2">[DOM2]</a> core
interfaces.</p>

<p>Since the <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1590626202">The
DOM Structure Model</a> and the <a href="http://www.w3.org/TR/xslt#data-model">XSLT Data Model</a>,
along with the <a href="http://www.w3.org/TR/xpath#data-model">XPath
Data Model</a>, are not fully equivalent, it is necessary to define
the mapping between the two models, and identify where tree
presentations may not be consistent between XSLT processors that use
different implementation strategies. The two types of XSLT processors
that we are concerned with are:</p>

<ul>

<li><p>The processor creates its own internal tree structure (or
internal XPath cache), and presents that structure to extensions via
DOM interfaces. In this case, the processor is fully in control of
the structure of the tree.</p></li>

<li><p>The XPath/XSLT data model is implemented as a view over the
a DOM that was passed to the XSLT processor. In this case the XSLT
processor generally has a contract with the caller that it can not
mutate the DOM, and so the XSLT processor is not fully in control of the
structure of the tree. For XSLT processors that are passed a DOM,
this DOM should be able to be presented to extensions without
modification.</p></li>

</ul>

<p>Thus, in order for an extension function to be fully interoperable,
it must take into account that it may be given node structures that
are not consistent from implementation to implementation. For
instance, Text nodes could be broken into several chunks, or could be
a single node. The text below enumerates the guidelines for how nodes
are to be passed to extension functions, and how node results are to
be returned.</p>

<p>An XSLT processor maintains a mapping that associates each XSLT
document with the DOM Document or DocumentFragment that represents it.
An XSLT processor need not create a DOM Document or DocumentFragment
to represent an XSLT document until a node from that XSLT document is
passed to an extension function using a DOM-based language binding.
Distinct XSLT documents are mapped to distinct DOM Documents or
DocumentFragments.</p>

<div class="div3">

<h4><a name="node-set-to-external-function"></a>C.1.1 Passing an XPath node-set to an Extension Function</h4>

<p>A XPath node-set is mapped to a DOM NodeList, by building a list of
the XPath nodes in document order and then mapping each XPath node in
the list to a DOM node.</p>

<p>XPath nodes are mapped to DOM nodes as follows.</p>

<ul>
<li>
<p>A root node is presented as a Document node.</p>
</li>
<li>
<p>An element node is presented as an Element node.</p>
</li>
<li>
<p>An attribute node is presented as an Attr node.</p>
</li>
<li>
<p>The DOM tree may contain additional Attr nodes with
the name "xmlns" or "xmlns:*" to represent namespaces. Since a DOM
may use namespaces that are not declared, an extension function can
not rely on these namespace declarations being present.</p>
</li>
<li>
<p>A text node is presented as a Text node (which might
or might not be normalized). This Text may be a derived CDATASection.
</p>
<div class="issue"><p class="prefix"><a name="issue-multiple-dom-text-nodes"></a><b>Issue (issue-multiple-dom-text-nodes):</b></p><p>What happens
if a single XPath text node is represented by multiple
DOM Text nodes (because of unnormalized Text nodes, CDATA sections
or entity references)?</p></div>
</li>
<li>
<p>A comment node is presented as a Comment node.</p>
</li>
<li>
<p>A processing instruction node is presented as a
ProcessingInstruction node.</p>
</li>
<li>
<p>The DOM tree may or may not contain nodes to
represent constructs that are absent from the XPath data model, for
example entity references, and Notation nodes.</p>
</li>
</ul>

<p>Where whitespace has been stripped from the XPath tree,
the DOM tree may or may not contain nodes representing such
whitespace. Extension functions should not rely on the presence or
absense of such whitespace.</p>

<p>The extension function may navigate freely from the nodes actually
supplied to other nodes in the tree, using the standard DOM
interfaces. Attempting to modify the tree is not recommended: the
processor may throw a DOMException if such an attempt is made. In any
case, the effect of mutation of the source tree during transformation
is undefined.</p>

<p>The result of calling methods that create new nodes, for example
<code>createElement</code>, is undefined; the processor may throw a
DOMException if such an attempt is made.  This restriction does not
apply to the DOM <code>Document</code> that is the value
of the ownerDocument attribute on XSLTContext.</p>

<p>The names and values of DOM nodes will follow the standard DOM
semantics, not the XPath semantics. For example the name of a comment
node will be <code>#comment</code>.</p>

<p>The result of calling <code>getDocumentType</code> is undefined:
the processor may throw a DOMException if such an attempt is made.</p>

<p>The result of calling <code>getSpecified</code> on an
<code>Attr</code> node is undefined, since this information is not
available in the XPath data model.</p>

</div>

<div class="div3">

<h4><a name="N11530"></a>C.1.2 Returning a NodeList or Node from an Extension Function</h4>

<p>When the implementation of an extension function returns a DOM
Node, an XSLT processor will attempt to map that Node to an XSLT node
as follows:</p>

<ol>

<li><p>First, it determines the root of the DOM tree containing this
DOM Node by using the <code>parentNode</code> <code>Node</code>
attribute and the <code>ownerElement</code> <code>Attr</code>
attribute.  It is an error if this root is neither a DOM
<code>Document</code> nor a DOM
<code>DocumentFragment</code>.</p></li>

<li><p>Next, it determines which XSLT document is associated with
this DOM <code>Document</code> or <code>DocumentFragment</code> root.
If there is no such XSLT document, then the XSLT processor attempts to
create a new XSLT document from the DOM <code>Document</code> or
<code>DocumentFragment</code> root.  It is only required to be able to
do so in the case where the root is a <code>DocumentFragment</code>
whose <code>ownerDocument</code> is the same as the
<code>XSLTContext</code> <code>ownerDocument</code> attribute.  When
it creates a new XSLT document, namespace fixup (see <a href="#namespace-fixup"><b>3.5 Namespace Fixup</b></a>) is performed; whitespace stripping
(see <a href="#strip"><b>3.4 Whitespace Stripping</b></a>) is <em>not</em> performed.
Once an XSLT document has
been created for a particular DOM <code>Document</code> or
<code>DocumentFragment</code>, modification to that
<code>Document</code> or <code>DocumentFragment</code> is no longer
allowed; the XSLT processor may throw a DOM exception if an extension
function attempts this.  The newly created XSLT document is associated
with the DOM <code>Document</code> or <code>DocumentFragment</code>
root from which it was created, so that if an extension function
subsequently returns that same <code>Document</code> or
<code>DocumentFragment</code>, it will be mapped to the same XSLT
document.</p></li>

<li><p>Finally, it determines which node in that XSLT document
corresponds to the DOM <code>Node</code> that is being mapped.</p></li>

</ol>

<p>Thus, if a node-set containing a single node is passed to an
extension function as a DOM <code>Node</code> and the implementation
of the extension function returns that same DOM <code>Node</code>,
then the result of calling function will be a node-set containing a
single node, which is the same node as the node in the node-set passed
to the extension function.</p>

<p>An implementation of an extension function may also return a DOM
<code>NodeList</code>.  In this case, each DOM <code>Node</code> in
the <code>NodeList</code> is converted to an XSLT node and the
<code>NodeList</code> is converted to a node-set containing all of the
resulting nodes.</p>

<p>The implementation of an extension function can use the
<code>XSLTContext</code> <code>ownerDocument</code> attribute to
create DOM <code>Node</code>s.  Before an implementation of an
extension function returns DOM <code>Node</code>s that it has created,
it should also create a <code>DocumentFragment</code> in the same way
and add those <code>Node</code>s to that
<code>DocumentFragment</code>.  It can also return the
<code>DocumentFragment</code> itself, which will be mapped to an XSLT
root node.</p>

<p>The only operations allowed on the <code>Document</code> that is
the value of the <code>XSLTContext</code> <code>ownerDocument</code>
attribute are calls to the following methods:
<code>createDocumentFragment</code>, <code>createElement</code>,
<code>createElementNS</code>, <code>createAttribute</code>,
<code>createAttributeNS</code>, <code>createTextNode</code>,
<code>createComment</code>, <code>createProcessingInstruction</code>,
<code>importNode</code>.  The result of calling any other methods or
accessing any attributes is implementation-dependent.</p>

</div>

</div>

<div class="div2">

<h3><a name="N11723"></a>C.2 IDL/DOM2 Language Binding</h3>

<p>The following specifies the <code>XSLTContext</code> interface in
IDL:</p>

<div class="exampleInner"><pre>// File: xslt.idl
#pragma prefix "w3c.org"
#include "dom.idl"
module xslt
{
  typedef sequence&lt;unsigned short&gt; XPathString;
  interface XSLTContext {
    // ---- Properties/Attributes ----
    // context node from XPath expression context
    readonly attribute dom::Node contextNode;
    // context position from XPath expression context
    readonly attribute unsigned long contextPosition;
    // context size from XPath expression context
    readonly attribute unsigned long contextSize;
    // current node from XSLT context; same as calling
    // current() function from the XPath expression context
    readonly attribute dom::Node currentNode;
    // Document to be used for creating nodes
    readonly attribute dom::Document ownerDocument;
    // ---- Methods ----
    // XSLT System Property
    Object systemProperty(in XPathString namespaceURI,
                          in XPathString localName);
    // Return the string value of the Node passed in
    stringValue(in dom::Node n);
  };
};</pre></div>

</div>

<div class="div2">

<h3><a name="ecmascript-binding"></a>C.3 ECMAScript/DOM2 Language Binding</h3>

<p>This section defines the ECMAScript <a href="#ECMA262">[ECMA262]</a>
language binding for XSLT extension functions.</p>

<p>To implement an extension function in ECMAScript, stylesheet
developers associate an implementation to their extension function
namespace prefix using an <code>xsl:script</code> element with
<code>language="ecmascript"</code> or <code>language="javascript"</code>
as in the following example:</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:date="http://www.example.com/2000/XSLT/library/date"&gt;

&lt;xsl:param name="upperCust" select="true()"/&gt;

&lt;xsl:script implements-prefix="date"
             language="ecmascript"
             src="DateRoutines.js"/&gt;
&lt;xsl:script implements-prefix="util"
             language="ecmascript"&gt;
function upper(n) {
  return n.toUpperCase();
}
function lower(n) {
 return n.toLowerCase();
}

function iff(arg1, arg2, arg3) {
  if (arg1) {
    return arg2;
  }
  else {
    return arg3;
  }
}
&lt;/xsl:script&gt;

&lt;xsl:template match="/"&gt;
  &lt;CustomerId&gt;
    &lt;xsl:value-of select="util:iff($upperCust,
                                   util:upper(/order/custid),
                                   util:lower(/order/custid))"/&gt;
  &lt;/CustomerId&gt;
  &lt;OrderDate&gt;
    &lt;xsl:value-of select="date:format(/order/date,'MM/DD/YY')"/&gt;
  &lt;/OrderDate&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div>

<p>For ECMAScript, the value of the <code>src</code> attribute on
<code>xsl:script</code> is a URI reference of an ECMAScript resource
that defines the functions associated with the namespace URI specified
by the <code>implements-prefix</code> attribute. The implementation
can also be provided locally by omitting the <code>src</code>
attribute and including the script function definitions as the content
of the <code>xsl:script</code> element.</p>

<p>The ECMAScript standard <a href="#ECMA262">[ECMA262]</a> allows conforming
implementations to provide additional types, values, objects
properties and program syntax beyond that described in the ECMAScript
standard.  For maximum portability, implementations of extension
functions should rely only what is defined in the ECMAScript standard
itself.</p>

<p>Functions provided by <code>xsl:script</code> elements with
distinct namespace URIs execute in distinct contexts to avoid name
collisions.</p>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Figure out what the correct way to say this is in
terms of the ECMAScript standard. Probably need to say there is a
distinct global object for each namespace URI.</td></tr></table>

<p>When multiple <code>xsl:script</code> elements with the same
namespace URI and the <code>ecmascript</code> language are
encountered, the scripts for each element are concatenated in import
precedence order, lowest precedence first. This allows a function
provided by an <code>xsl:script</code> element of higher import
precedence to redefine a function of the same name provided by an
<code>xsl:script</code> element of lower import precedence.</p>

<p>A function with given local name and namespace URI is considered to
be available for the purposes of the <code>function-available</code>
function if, after executing all the scripts associated with that
namespace URI, the global object for the namespace URI has a property
with the specified local name whose value is a function.</p>

<p>The local part of the expanded-name of the extension function is
converted to the ECMAScript function name as follows. For each hyphen
in the local part of the expanded-name of the function, the character
following the hyphen is converted to upper-case using the
<code>toUpperCase</code> method of the ECMAScript <code>String</code>
object, and then the hyphen is removed. For example, the name
<code>get-value</code> would be treated as equivalent to
<code>getValue</code>.</p>

<p>The following function argument conversions are performed:</p>

<ul>
<li><p>An XPath <code>string</code> object is mapped to an ECMAScript
<code>string</code> value</p></li>
<li><p>An XPath <code>number</code> object is mapped to an ECMAScript
<code>number</code> value</p></li>
<li><p>An XPath <code>boolean</code> object is mapped to an ECMAScript
<code>boolean</code> value</p></li>
<li><p>An XPath <code>node-set</code> object is mapped to the ECMAScript
binding for the DOM <code>NodeList</code></p></li>
<li><p>An XSLT external object is mapped to the ECMAScript
<code>object</code> that it wraps</p></li>
</ul>

<p>The following conversions are performed on return values.</p>

<ul>

<li><p>An ECMAScript string value or String object is mapped to an XPath
string object.</p></li>

<li><p>An ECMAScript number value or Number object is mapped to an XPath
number object.</p></li>

<li><p>An ECMAScript boolean value or Boolean object is mapped to
an XPath boolean object.</p></li>

<li><p>An ECMAScript objects that is an instance of any of the
following objects:</p>

<ul>
<li>
<p>DocumentFragment</p>
</li>
<li>
<p>Document</p>
</li>
<li>
<p>Node</p>
</li>
<li>
<p>NodeList</p>
</li>
<li>
<p>Attr</p>
</li>
<li>
<p>Element</p>
</li>
<li>
<p>Text</p>
</li>
<li>
<p>Comment</p>
</li>
<li>
<p>CDATASection</p>
</li>
<li>
<p>EntityReference</p>
</li>
<li>
<p>ProcessingInstruction</p>
</li>
</ul>
<p>are mapped to an XPath <code>node-set</code>.</p>
</li>
<li>
<p>The ECMAScript null value is mapped to an XSLT external object.</p>
</li>
<li>
<p>The ECMAScript undefined value is mapped to an empty node-set.</p>
</li>
<li>
<p>Any other ECMAScript object is mapped to an XSLT external object.</p>
</li>
</ul>

<p>The following specifies the <code>XSLTContext</code> object
language binding for ECMAScript. It is accessible as a property
of the global object.</p>

<div class="exampleInner"><pre>Object XSLTContext

// Property: context node from XPath expression context
//     Type: Node
contextNode

// Property: context position from XPath expression context
//     Type: number
contextPosition

// Property: context size from XPath expression context
//     Type: number
contextSize

// Property: current node from XSLT context
//     Type: Node
currentNode

// Property: Document to be used for creating nodes
//     Type: Document
ownerDocument

//   Method: Return the system property of the specified name
//  Returns: Object
systemProperty(String namespaceURI, String localName)

//   Method: Return the XPath string value of the node passed in
//  Returns: string value
stringValue(Node n)</pre></div>

</div>

<div class="div2">

<h3><a name="java-binding"></a>C.4 Java/DOM2 Language Binding</h3>

<p>This section defines the Java language binding for XSLT extension
functions.</p>

<table border="1" summary="Editorial note"><tr><td align="left" valign="top" width="50%"><b>Editorial note</b></td><td align="right" valign="top" width="50%">&nbsp;</td></tr><tr><td colspan="2" align="left" valign="top">Need normative reference to Java language
spec.</td></tr></table>

<p>To implement an extension function in Java, stylesheet developers
associate an implementation to their extension function namespace
prefix using an <code>xsl:script</code> element with
<code>language="java"</code> as in the following example:</p>

<div class="exampleInner"><pre>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
xmlns:date="<var>uri.any</var>"&gt;

&lt;xsl:script implements-prefix="date" language="java"
src="java:com.example.datestuff.DateRoutines"/&gt;

&lt;xsl:template match="/"&gt;
&lt;OrderDate&gt;
&lt;xsl:value-of select="date:format(/order/date,'MM/DD/YY')"/&gt;
&lt;/OrderDate&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>

<p>For Java, the value of the <code>src</code> attribute on
<code>xsl:script</code> is a URI reference identifying a Java class;
the methods of this class implement the functions whose expanded-names
have the namespace URI specified by the <code>implements-prefix</code>
attribute.  The URI specified by the <code>src</code> attribute may
use the <code>java:</code> URI scheme:
<code>src="java:<var>fully.qualified.ClassName</var>"</code>; the XSLT
processor may also allow the URI to use other URI schemes to locate
a resource containing the Java class file.</p>

<p>When multiple <code>xsl:script</code> elements implementing
the same prefix for the same language are encountered, the processor
will use the <code>xsl:script</code> element with the highest
import precedence to identify the code unit for the extension
function namespace.</p>

<p>The <code>function-available</code> function returns true
if the named class can be loaded and if it has at least one public
method with the specified name. The expression
<code>function-available('xyz:new')</code> evaluates to true if the
associated class has any constructor.  If
<code>function-available</code> returns false, then a call on
the function will fail; if it returns true, there is no guarantee that
any particular call will succeed.</p>

<p>If a Java extension function throws an unhandled exception, it will
be considered an error in the XSLT processing, the transformation may
stop, and the error message from the exception should be reported.</p>

<div class="issue"><p class="prefix"><a name="issue-java-extension-state"></a><b>Issue (issue-java-extension-state):</b></p><p>At the moment, there is no way for
the implementation of a function in Java to cache information in a
thread-safe way.  For example, there is no way to implement an
extension function that would behave like the built-in
<code>document</code> function, which needs to keep a URI-to-Document
mapping, in order to ensure that it always returns the same Document
for the same URI.</p></div>

<div class="div3">

<h4><a name="java-identify-method"></a>C.4.1 Identifying the Java Method</h4>

<p>The local part of the <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
extension function specifies the name of the method to be called.  To
invoke an instance method for a particular Java object, that Java
object is passed as the first argument to the function call.  A
constructor is treated as a static method named <code>new</code>.</p>

<p>Names are "camel-cased" as follows. For each hyphen in
the local part of the expanded-name of the function, the character
following the hyphen is converted to upper-case using the
<code>toUpperCase</code> method of <code>java.lang.Character</code>,
and then the hyphen is removed. For example, the name
<code>get-value</code> would be treated as equivalent to
<code>getValue</code>.</p>

<p>It is not possible to invoke a Java method whose name is not an
<a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a>, for example, a name
containing a dollar sign character.</p>

<p>Java allows method overloading: a class may have more than one
method with the same name, so long as each method has a different
signature (different argument types).  The XSLT processor uses the
arguments passed to the extension function to determine which method
to call and resolve the method name to a particular method.  The
algorithm used for method resolution is based on <a href="#LC3">[LC3]</a>;
this uses an approach that is similar to the approach that the Java
language uses to resolve method names.</p>

<p>The first step in resolving a method invocation is to determine which
methods of a class are accessible and applicable. A Java method is
accessible and applicable if all of the following are true:</p>
<ul>
<li>
<p>The method is public.</p>
</li>
<li>
<p>The method name is the same as the local name of the extension function after camel-casing.</p>
</li>
<li>
<p>The number of parameters in the method declaration equals the
number of argument expressions in the function call expression with the
following exceptions:</p>
<ul>
<li>
<p>The method may have an optional, leading
<code>XSLTContext</code> argument. In this case the method would have one more
than the number of argument expressions in the method invocation.</p>
</li>
<li>
<p>If the method is an instance method, the current instance of
the object is passed as the first extension function argument. In
this case, the method would have one fewer than the number of
argument expressions in the function call expression.</p>
</li>
</ul>
</li>
<li>
<p>The type of each actual argument can be converted according to
the rules specified in <a href="#java-argument-conversions"><b>C.4.2 Argument Conversions</b></a>
below.</p>
</li>
</ul>

<p>If there are no applicable methods for an invocation, an error
occurs. If there is only one applicable method, it is the one
invoked. If there is more than one applicable method, then the
following algorithm is applied to determine which to invoke.</p>

<p>When determining which of the applicable methods to invoke, the
processor must apply the algorithm described below with a special test
for an XSLTContext object (see <a href="#java-expression-context"><b>C.4.4 Accessing XSLT Context Information</b></a>), as the first argument to the
method. Methods that have the XSLTContext as the first argument are
preferred over methods that do not.</p>

<p>When choosing between two or more applicable methods, an algorithm
is used that is similar in spirit to the ones used in Java and C++.
Suppose that <var>U</var> and <var>S</var> are both applicable methods
for an invocation, each having n parameters. Suppose, moreover, that
the Java types of the parameters for method <var>U</var> are
<var>u</var><sub>1</sub>,...,<var>u</var><var><sub>n</sub></var> and
the Java types of the parameters for method <var>S</var> are
<var>s</var><sub>1</sub>,...,<var>s</var><var><sub>n</sub></var>. Finally,
the runtime XSLT types of the actual arguments are
<var>t</var><sub>1</sub>,...,<var>t</var><var><sub>n</sub></var>. Then
the method <var>U</var> is preferred over method <var>S</var> if and
only if for all <var>j</var> from 1 to <var>n</var>:</p>

<ul>
<li>
<p><var>u</var><var><sub>j</sub></var> and
<var>s</var><var><sub>j</sub></var> are the same type, or</p>
</li>
<li>
<p>conversion to type <var>u</var><var><sub>j</sub></var> is preferred
to the conversion to type <var>s</var><var><sub>j</sub></var> when
converting from <var>t</var><var><sub>j</sub></var></p>
</li>
</ul>

<p>A method is said to be maximally preferred for a method invocation if
it is applicable and there is no more preferred applicable method. If
there is only one maximally preferred method, that method is
necessarily preferred to all other applicable methods and it is the
one invoked. If there is more than one maximally preferred method, an
error should be thrown.</p>

</div>

<div class="div3">

<h4><a name="java-argument-conversions"></a>C.4.2 Argument Conversions</h4>

<p>The following table specifies the allowed conversions of XSLT
objects to Java values when converting arguments for method
invocation. If a conversion is not specifically listed below, then it
is disallowed.  In each section corresponding to an XPath type below,
Java types are listed in order of preference, most preferred
first. Types that are equally preferred are listed in the same table
cell.</p>

<table width="100%" border="1">
<tbody>
<tr>
<th align="center" rowspan="1" colspan="1">XSLT argument type</th>
<th align="center" rowspan="1" colspan="1">Java argument type</th>
<th align="center" rowspan="1" colspan="1">Conversion technique</th>
</tr>
<tr>
<td rowspan="6" colspan="1">boolean</td>
<td rowspan="1" colspan="1">boolean</td>
<td rowspan="2" colspan="1">Convert XSLT true, false objects to corresponding
Java true, false values.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Object</td>
<td rowspan="1" colspan="1">Convert as for java.lang.Boolean.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.String</td>
<td rowspan="1" colspan="1">Convert to a string as if by a call to the
string function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">double, float, long, int, short, byte</td>
<td rowspan="2" colspan="1">Convert to a number as if by a call to the
number and then
use the rules for converting from an XSLT number.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Double, java.lang.Float, java.lang.Long,
java.lang.Integer, java.lang.Short, java.lang.Byte</td>
</tr>
<tr>
<td rowspan="18" colspan="1">number</td>
<td rowspan="1" colspan="1">double</td>
<td rowspan="2" colspan="1">Transfer exact value to Java without any conversion.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Double</td>
</tr>
<tr>
<td rowspan="1" colspan="1">float</td>
<td rowspan="2" colspan="1">Round XSLT number to float precision.
Values that are to large to be represented by a float
are converted to positive or negative infinity.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Float</td>
</tr>
<tr>
<td rowspan="1" colspan="1">long</td>
<td rowspan="10" colspan="1">Truncate XSLT number to integral value by eliminating
fractional part. NaNs or numbers with a magnitude too large to be
represented in the target integral type result in a runtime error.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Long</td>
</tr>
<tr>
<td rowspan="1" colspan="1">int</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Integer</td>
</tr>
<tr>
<td rowspan="1" colspan="1">short</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Short</td>
</tr>
<tr>
<td rowspan="1" colspan="1">char</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Character</td>
</tr>
<tr>
<td rowspan="1" colspan="1">byte</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Byte</td>
</tr>
<tr>
<td rowspan="1" colspan="1">boolean</td>
<td rowspan="2" colspan="1">Convert number to boolean as if by a call to the
boolean function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Boolean</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.String</td>
<td rowspan="1" colspan="1">Convert number to string as if by a call to the
string function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Object</td>
<td rowspan="1" colspan="1">Convert as for java.lang.Double.</td>
</tr>
<tr>
<td rowspan="8" colspan="1">string</td>
<td rowspan="1" colspan="1">java.lang.String</td>
<td rowspan="1" colspan="1">Convert from XSLT string to java.lang.String</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Object</td>
<td rowspan="1" colspan="1">Convert as for java.lang.String.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">char</td>
<td rowspan="2" colspan="1">For one-character strings, result is
Unicode character. For strings longer than 1 character, an error is
raised.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Character</td>
</tr>
<tr>
<td rowspan="1" colspan="1">double, float, long, int, short, byte</td>
<td rowspan="2" colspan="1">Convert string to number as if by a call to the
number function, and then use
the rules for converting from an XSLT number.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Double, java.lang.Float, java.lang.Long,
java.lang.Integer, java.lang.Short, java.lang.Byte</td>
</tr>
<tr>
<td rowspan="1" colspan="1">boolean</td>
<td rowspan="2" colspan="1">Convert string to boolean as if by a call to the
boolean function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Boolean</td>
</tr>
<tr>
<td rowspan="10" colspan="1">node-set</td>
<td rowspan="1" colspan="1"><a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.NodeList">org.w3c.dom.NodeList</a></td>
<td rowspan="1" colspan="1">Map the node-set to a org.w3c.dom.NodeList as described in
<a href="#node-set-to-external-function"><b>C.1.1 Passing an XPath node-set to an Extension Function</b></a>.</td>
</tr>
<tr>
<td rowspan="1" colspan="1"><a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Node">org.w3c.dom.Node</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Attr">org.w3c.dom.Attr,</a>
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.CDATASection">org.w3c.dom.CDATASection</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.CharacterData">org.w3c.dom.CharacterData</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Comment">org.w3c.dom.Comment</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Document">org.w3c.dom.Document</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Element">org.w3c.dom.Element</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.ProcessingInstruction">org.w3c.dom.ProcessingInstruction</a>,
<a href="http://www.w3.org/TR/DOM-Level-2-Core/java-binding.html#org.w3c.dom.Text">org.w3c.dom.Text</a></td>
<td rowspan="1" colspan="1">Take first node from node-set, and
map to a Node as described in the section on
<a href="#node-set-to-external-function"><b>C.1.1 Passing an XPath node-set to an Extension Function</b></a>.
It is a runtime error if the resulting Node is not assignable
to the Java argument type.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.String</td>
<td rowspan="1" colspan="1">Convert node-set to string as if by a call to the
string function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Object</td>
<td rowspan="1" colspan="1">Convert as to org.w3c.dom.NodeList</td>
</tr>
<tr>
<td rowspan="1" colspan="1">char</td>
<td rowspan="2" colspan="1">Convert node-set to string as if by a call to the
string function;
then use the rule for converting from an XSLT string to a char.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Character</td>
</tr>
<tr>
<td rowspan="1" colspan="1">double, float, long, int, short, byte</td>
<td rowspan="2" colspan="1">Convert node-set to number as if by a call to the
number function, then
use the rules for converting from an XSLT number.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Double, java.lang.Float, java.lang.Long,
java.lang.Integer, java.lang.Short, java.lang.Byte</td>
</tr>
<tr>
<td rowspan="1" colspan="1">boolean</td>
<td rowspan="2" colspan="1">Convert node-set to boolean as if by a call to the
boolean function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Boolean</td>
</tr>
<tr>
<td rowspan="6" colspan="1">external object</td>
<td rowspan="1" colspan="1">Any interface or class that is
assignment-compatible with the Java object wrapped by the external
object, i.e. the wrapped Java object is an
<code>instanceof</code> the Java argument type</td>
<td rowspan="1" colspan="1">Use the Java object wrapped by the external object.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.String</td>
<td rowspan="1" colspan="1">Call the wrapped object's <code>toString</code> method
and return the result as a new java.lang.String.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">char</td>
<td rowspan="2" colspan="1">Call the wrapped object's <code>toString</code> method
and convert the string to a char using the rules
for converting from an XSLT string.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Character</td>
</tr>
<tr>
<td rowspan="1" colspan="1">double, float, long, int, short, byte</td>
<td rowspan="2" colspan="1">Call the wrapped object's <code>toString</code> method,
and convert the resulting string to an XSLT number
as by a call to the number function.
Then convert the number using the rules
for converting from an XSLT number.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">java.lang.Double, java.lang.Float, java.lang.Long,
java.lang.Integer, java.lang.Short, java.lang.Byte</td>
</tr>
</tbody>
</table>

<p>Among Java class or interface types, further processing is
required.  Intuitively, the rule for preference among Java types when
converting from a Java object that is wrapped in an XSLT external
object is that the most specific class or interface is preferred. More
formally, let <var>T</var> be the Java class of the Java object
wrapped by an external object.  Let <var>S</var> and <var>U</var> be
class or interface types. <var>S</var> is preferred to <var>U</var> if
and only if:</p>

<ul>
<li>
<p>An instance of <var>T</var> is assignable to a variable of type
<var>S</var>, i.e. <var>T</var> instanceof <var>S</var> is true</p>
</li>
<li>
<p>An instance of <var>S</var> is assignable to a variable of type
<var>U</var>, i.e. <var>S</var> instanceof <var>U</var> is true</p>
</li>
<li>
<p><var>S</var> and <var>U</var> are not the same types</p>
</li>
</ul>

</div>

<div class="div3">

<h4><a name="N13111"></a>C.4.3 Return Value Conversions</h4>

<p>Values returned by an extension function implemented
by a Java method are converted as follows.</p>

<ul>

<li><p>If the Java method returns void, the XPath function returns
an empty node-set.</p></li>

<li><p>If the Java method returns null, the XPath function
returns an external object that wraps null.</p></li>

<li><p>If the Java method returns a String, the XPath function returns the
equivalent string. This string must consist of characters that are
valid in XML.</p></li>

<li><p>If the Java method returns a <code>double</code>, <code>int</code>,
<code>float</code>, <code>long</code>, <code>short</code>,
<code>char</code>, <code>byte</code> or their object equivalents, the
XPath function returns the equivalent number.</p></li>

<li><p>If the Java method returns a <code>boolean</code> or
<code>Boolean</code>, the XPath function returns the equivalent
boolean.</p></li>

<li><p>If the Java method returns an <code>org.w3c.dom.NodeList</code>, the
XPath function returns a node-set.</p></li>

<li><p>If the Java method returns a DOM Node or an object of a type from a
DOM Node, then XPath function returns a node-set with a single
member.</p></li>

<li><p>If the Java method returns any other object, the XPath function
returns a external object that wraps that object.</p></li>

</ul>

</div>

<div class="div3">

<h4><a name="java-expression-context"></a>C.4.4 Accessing XSLT Context Information</h4>

<p>The way in which the XSLTContext object is passed to an extension
function is specified in <a href="#java-identify-method"><b>C.4.1 Identifying the Java Method</b></a>. The
<code>XSLTContext</code> interface is as follows:</p>

<div class="exampleInner"><pre>package org.w3c.xsl;

import org.w3c.dom.Node;
import org.w3c.dom.Document;

/**
 * Interface to be used with XSLT extension functions written in Java
 */
interface XSLTContext
{
    /**
     * Return context node from the XPath expression context.
     */
    Node getContextNode();
    /**
     * Returns the context position from the XPath expression context.
     */
    int getContextPosition();
    /**
     * Returns the context size from the XPath expression context.
     */
    int getContextSize();
    /**
     * Returns the current node from the XSLT context; the same
     * as calling current() function from the XPath expression context.
     */
    Node getCurrentNode();
    /**
     * Returns a Document to be used for creating nodes.
     */
    Document getOwnerDocument();
    /**
     * Returns an Object representing the value of the system property
     * whose expanded-name has the specified namespace URI and local part.
     */
    Object systemProperty(String namespaceURI, String localName);
    /**
     * Returns the string-value of the specified Node.
     */
    String stringValue(Node n);
};</pre></div>

</div>
</div>
</div>

<div class="div1">

<h2><a name="dtd"></a>D DTD Fragment for XSLT Stylesheets (Non-Normative)</h2>

<div class="note"><p class="prefix"><b>Note:</b></p><p>This DTD Fragment is not normative because XML 1.0 DTDs do
not support XML Namespaces and thus cannot correctly describe the
allowed structure of an XSLT stylesheet.</p></div>

<p>The following entity can be used to construct a DTD for XSLT
stylesheets that create instances of a particular result DTD.  Before
referencing the entity, the stylesheet DTD must define a
<code>result-elements</code> parameter entity listing the allowed
result element types.  For example:</p>

<div class="exampleInner"><pre>&lt;!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
"&gt;</pre></div>

<p>Such result elements should be declared to have
<code>xsl:use-attribute-sets</code> and
<code>xsl:extension-element-prefixes</code> attributes.  The following
entity declares the <code>result-element-atts</code> parameter for
this purpose. The content that XSLT allows for result elements is the
same as it allows for the XSLT elements that are declared in the
following entity with a content model of <code>%template;</code>.  The
DTD may use a more restrictive content model than
<code>%template;</code> to reflect the constraints of the result
DTD.</p>

<p>The DTD may define the <code>non-xsl-top-level</code> parameter
entity to allow additional top-level elements from namespaces other
than the XSLT namespace.</p>

<p>The use of the <code>xsl:</code> prefix in this DTD does not imply
that XSLT stylesheets are required to use this prefix.  Any of the
elements declared in this DTD may have attributes whose name starts
with <code>xmlns:</code> or is equal to <code>xmlns</code> in addition
to the attributes declared in this DTD.</p>

<div class="exampleInner"><pre>&lt;!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
  | xsl:document
"&gt;

&lt;!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
"&gt;

&lt;!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
"&gt;

&lt;!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
"&gt;

&lt;!-- Used for the type of an attribute value that is a URI reference.--&gt;
&lt;!ENTITY % URI "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is list of URI
references. --&gt;
&lt;!ENTITY % URIs "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a pattern.--&gt;
&lt;!ENTITY % pattern "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is an
     attribute value template.--&gt;
&lt;!ENTITY % avt "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a QName; the prefix
     gets expanded by the XSLT processor. --&gt;
&lt;!ENTITY % qname "NMTOKEN"&gt;

&lt;!-- Like qname but a whitespace-separated list of QNames. --&gt;
&lt;!ENTITY % qnames "NMTOKENS"&gt;

&lt;!-- Used for the type of an attribute value that is an NCName. --&gt;
&lt;!ENTITY % ncname "NMTOKEN"&gt;

&lt;!-- Used for the type of an attribute value that is an expression.--&gt;
&lt;!ENTITY % expr "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that consists
     of a single character.--&gt;
&lt;!ENTITY % char "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a priority. --&gt;
&lt;!ENTITY % priority "NMTOKEN"&gt;

&lt;!ENTITY % space-att "xml:space (default|preserve) #IMPLIED"&gt;

&lt;!-- This may be overridden to customize the set of elements allowed
at the top-level. --&gt;

&lt;!ENTITY % non-xsl-top-level ""&gt;

&lt;!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  | xsl:script
  %non-xsl-top-level;)*)
"&gt;

&lt;!ENTITY % top-level-atts '
  extension-element-prefixes CDATA #IMPLIED
  exclude-result-prefixes CDATA #IMPLIED
  id ID #IMPLIED
  version NMTOKEN #REQUIRED
  xmlns:xsl CDATA #FIXED "http://www.w3.org/1999/XSL/Transform"
  %space-att;
'&gt;

&lt;!-- This entity is defined for use in the ATTLIST declaration
for result elements. --&gt;

&lt;!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA #IMPLIED
  xsl:exclude-result-prefixes CDATA #IMPLIED
  xsl:use-attribute-sets %qnames; #IMPLIED
  xsl:version NMTOKEN #IMPLIED
'&gt;

&lt;!ENTITY % output-atts '
  method %avt; #IMPLIED
  version %avt; #IMPLIED
  encoding %avt; #IMPLIED
  omit-xml-declaration %avt; #IMPLIED
  standalone %avt; #IMPLIED
  doctype-public %avt; #IMPLIED
  doctype-system %avt; #IMPLIED
  cdata-section-elements %avt; #IMPLIED
  indent %avt; #IMPLIED
  media-type %avt; #IMPLIED
'&gt;

&lt;!ELEMENT xsl:stylesheet %top-level;&gt;
&lt;!ATTLIST xsl:stylesheet %top-level-atts;&gt;

&lt;!ELEMENT xsl:transform %top-level;&gt;
&lt;!ATTLIST xsl:transform %top-level-atts;&gt;

&lt;!ELEMENT xsl:import EMPTY&gt;
&lt;!ATTLIST xsl:import href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:include EMPTY&gt;
&lt;!ATTLIST xsl:include href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:strip-space EMPTY&gt;
&lt;!ATTLIST xsl:strip-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:preserve-space EMPTY&gt;
&lt;!ATTLIST xsl:preserve-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:output EMPTY&gt;
&lt;!ATTLIST xsl:output %output-atts;&gt;

&lt;!ELEMENT xsl:key EMPTY&gt;
&lt;!ATTLIST xsl:key
  name %qname; #REQUIRED
  match %pattern; #REQUIRED
  use %expr; #REQUIRED
&gt;

&lt;!ELEMENT xsl:decimal-format EMPTY&gt;
&lt;!ATTLIST xsl:decimal-format
  name %qname; #IMPLIED
  decimal-separator %char; "."
  grouping-separator %char; ","
  infinity CDATA "Infinity"
  minus-sign %char; "-"
  NaN CDATA "NaN"
  percent %char; "%"
  per-mille %char; "&amp;#x2030;"
  zero-digit %char; "0"
  digit %char; "#"
  pattern-separator %char; ";"
&gt;

&lt;!ELEMENT xsl:namespace-alias EMPTY&gt;
&lt;!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix CDATA #REQUIRED
&gt;

&lt;!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
&gt;

&lt;!ATTLIST xsl:template
  match %pattern; #IMPLIED
  name %qname; #IMPLIED
  priority %priority; #IMPLIED
  mode %qname; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:value-of EMPTY&gt;
&lt;!ATTLIST xsl:value-of
  select %expr; #REQUIRED
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:copy-of EMPTY&gt;
&lt;!ATTLIST xsl:copy-of select %expr; #REQUIRED&gt;

&lt;!ELEMENT xsl:number EMPTY&gt;
&lt;!ATTLIST xsl:number
   level (single|multiple|any) "single"
   count %pattern; #IMPLIED
   from %pattern; #IMPLIED
   value %expr; #IMPLIED
   format %avt; '1'
   lang %avt; #IMPLIED
   letter-value %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*&gt;
&lt;!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-imports EMPTY&gt;

&lt;!-- xsl:sort cannot occur after any other elements or
any non-whitespace character --&gt;

&lt;!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
&gt;

&lt;!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:sort EMPTY&gt;
&lt;!ATTLIST xsl:sort
  select %expr; "."
  lang %avt; #IMPLIED
  data-type %avt; "text"
  order %avt; "ascending"
  case-order %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:if %template;&gt;
&lt;!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)&gt;
&lt;!ATTLIST xsl:choose %space-att;&gt;

&lt;!ELEMENT xsl:when %template;&gt;
&lt;!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:otherwise %template;&gt;
&lt;!ATTLIST xsl:otherwise %space-att;&gt;

&lt;!ELEMENT xsl:attribute-set (xsl:attribute)*&gt;
&lt;!ATTLIST xsl:attribute-set
  name %qname; #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:call-template (xsl:with-param)*&gt;
&lt;!ATTLIST xsl:call-template
  name %qname; #REQUIRED
&gt;

&lt;!ELEMENT xsl:with-param %template;&gt;
&lt;!ATTLIST xsl:with-param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:variable %template;&gt;
&lt;!ATTLIST xsl:variable 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:param %template;&gt;
&lt;!ATTLIST xsl:param 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:text (#PCDATA)&gt;
&lt;!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:processing-instruction %char-template;&gt;
&lt;!ATTLIST xsl:processing-instruction 
  name %avt; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:element %template;&gt;
&lt;!ATTLIST xsl:element 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:attribute %char-template;&gt;
&lt;!ATTLIST xsl:attribute 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:comment %char-template;&gt;
&lt;!ATTLIST xsl:comment %space-att;&gt;

&lt;!ELEMENT xsl:copy %template;&gt;
&lt;!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:message %template;&gt;
&lt;!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:fallback %template;&gt;
&lt;!ATTLIST xsl:fallback %space-att;&gt;

&lt;!ELEMENT xsl:document %template;&gt;
&lt;!ATTLIST xsl:document
  href %avt; #REQUIRED
  %output-atts;
&gt;

&lt;!ELEMENT xsl:script (#PCDATA)&gt;
&lt;!ATTLIST xsl:script
  implements-prefix %ncname; #REQUIRED
  language %qname; #REQUIRED
  src %URI; #IMPLIED
  archive %URIs; #IMPLIED
&gt;</pre></div>


</div>

<div class="div1">

<h2><a name="N13295"></a>E Examples (Non-Normative)</h2>

<div class="div2">

<h3><a name="N13300"></a>E.1 Document Example</h3>

<p>This example is a stylesheet for transforming documents that
conform to a simple DTD into XHTML <a href="#XHTML">[XHTML]</a>.  The DTD
is:</p>

<div class="exampleInner"><pre>&lt;!ELEMENT doc (title, chapter*)&gt;
&lt;!ELEMENT chapter (title, (para|note)*, section*)&gt;
&lt;!ELEMENT section (title, (para|note)*)&gt;
&lt;!ELEMENT title (#PCDATA|emph)*&gt;
&lt;!ELEMENT para (#PCDATA|emph)*&gt;
&lt;!ELEMENT note (#PCDATA|emph)*&gt;
&lt;!ELEMENT emph (#PCDATA|emph)*&gt;</pre></div>

<p>The stylesheet is:</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1"&gt;

&lt;xsl:strip-space elements="doc chapter section"/&gt;
&lt;xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-1"
/&gt;

&lt;xsl:template match="doc"&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;title&gt;
       &lt;xsl:value-of select="title"/&gt;
     &lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;xsl:apply-templates/&gt;
   &lt;/body&gt;
 &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="doc/title"&gt;
  &lt;h1&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter/title"&gt;
  &lt;h2&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="section/title"&gt;
  &lt;h3&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h3&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="note"&gt;
  &lt;p class="note"&gt;
    &lt;b&gt;NOTE: &lt;/b&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div>

<p>With the following input document</p>

<div class="exampleInner"><pre>&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;chapter&gt;
&lt;title&gt;Chapter Title&lt;/title&gt;
&lt;section&gt;
&lt;title&gt;Section Title&lt;/title&gt;
&lt;para&gt;This is a test.&lt;/para&gt;
&lt;note&gt;This is a note.&lt;/note&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;title&gt;Another Section Title&lt;/title&gt;
&lt;para&gt;This is &lt;emph&gt;another&lt;/emph&gt; test.&lt;/para&gt;
&lt;note&gt;This is another note.&lt;/note&gt;
&lt;/section&gt;
&lt;/chapter&gt;
&lt;/doc&gt;</pre></div>

<p>it would produce the following result</p>

<div class="exampleInner"><pre>&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;html xmlns="http://www.w3.org/TR/xhtml1"&gt;
&lt;head&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Document Title&lt;/h1&gt;
&lt;h2&gt;Chapter Title&lt;/h2&gt;
&lt;h3&gt;Section Title&lt;/h3&gt;
&lt;p&gt;This is a test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is a note.&lt;/p&gt;
&lt;h3&gt;Another Section Title&lt;/h3&gt;
&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is another note.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div>

</div>

<div class="div2">

<h3><a name="data-example"></a>E.2 Data Example</h3>

<p>This is an example of transforming some data represented in XML
using three different XSLT stylesheets to produce three different
representations of the data, HTML, SVG and VRML.</p>

<p>The input data is:</p>

<div class="exampleInner"><pre>&lt;sales&gt;

        &lt;division id="North"&gt;
                &lt;revenue&gt;10&lt;/revenue&gt;
                &lt;growth&gt;9&lt;/growth&gt;
                &lt;bonus&gt;7&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="South"&gt;
                &lt;revenue&gt;4&lt;/revenue&gt;
                &lt;growth&gt;3&lt;/growth&gt;
                &lt;bonus&gt;4&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="West"&gt;
                &lt;revenue&gt;6&lt;/revenue&gt;
                &lt;growth&gt;-1.5&lt;/growth&gt;
                &lt;bonus&gt;2&lt;/bonus&gt;
        &lt;/division&gt;

&lt;/sales&gt;</pre></div>

<p>The following stylesheet, which uses the simplified syntax
described in <a href="#result-element-stylesheet"><b>2.3 Literal Result Element as Stylesheet</b></a>, transforms
the data into HTML:</p>

<div class="exampleInner"><pre>&lt;html xsl:version="1.1"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      lang="en"&gt;
    &lt;head&gt;
	&lt;title&gt;Sales Results By Division&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
	&lt;table border="1"&gt;
	    &lt;tr&gt;
		&lt;th&gt;Division&lt;/th&gt;
		&lt;th&gt;Revenue&lt;/th&gt;
		&lt;th&gt;Growth&lt;/th&gt;
		&lt;th&gt;Bonus&lt;/th&gt;
	    &lt;/tr&gt;
	    &lt;xsl:for-each select="sales/division"&gt;
		&lt;!-- order the result by revenue --&gt;
		&lt;xsl:sort select="revenue"
			  data-type="number"
			  order="descending"/&gt;
		&lt;tr&gt;
		    &lt;td&gt;
			&lt;em&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/em&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;xsl:value-of select="revenue"/&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;!-- highlight negative growth in red --&gt;
			&lt;xsl:if test="growth &amp;lt; 0"&gt;
			     &lt;xsl:attribute name="style"&gt;
				 &lt;xsl:text&gt;color:red&lt;/xsl:text&gt;
			     &lt;/xsl:attribute&gt;
			&lt;/xsl:if&gt;
			&lt;xsl:value-of select="growth"/&gt;
		    &lt;/td&gt;
		    &lt;td&gt;
			&lt;xsl:value-of select="bonus"/&gt;
		    &lt;/td&gt;
		&lt;/tr&gt;
	    &lt;/xsl:for-each&gt;
	&lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div>

<p>The HTML output is:</p>

<div class="exampleInner"><pre>&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;title&gt;Sales Results By Division&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;th&gt;Division&lt;/th&gt;&lt;th&gt;Revenue&lt;/th&gt;&lt;th&gt;Growth&lt;/th&gt;&lt;th&gt;Bonus&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;North&lt;/em&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;West&lt;/em&gt;&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td style="color:red"&gt;-1.5&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;South&lt;/em&gt;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div>

<p>The following stylesheet transforms the data into SVG:</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd"&gt;

&lt;xsl:output method="xml" indent="yes" media-type="image/svg"/&gt;

&lt;xsl:template match="/"&gt;

&lt;svg width = "3in" height="3in"&gt;
    &lt;g style = "stroke: #000000"&gt; 
        &lt;!-- draw the axes --&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Division&lt;/text&gt;
        &lt;xsl:for-each select="sales/division"&gt;
	    &lt;!-- define some useful variables --&gt;

	    &lt;!-- the bar's x position --&gt;
	    &lt;xsl:variable name="pos"
	                  select="(position()*40)-30"/&gt;

	    &lt;!-- the bar's height --&gt;
	    &lt;xsl:variable name="height"
	                  select="revenue*10"/&gt;

	    &lt;!-- the rectangle --&gt;
	    &lt;rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/&gt;

	    &lt;!-- the text label --&gt;
	    &lt;text x="{$pos}" y="165"&gt;
	        &lt;xsl:value-of select="@id"/&gt;
	    &lt;/text&gt; 

	    &lt;!-- the bar value --&gt;
	    &lt;text x="{$pos}" y="{145-$height}"&gt;
	        &lt;xsl:value-of select="revenue"/&gt;
	    &lt;/text&gt;
        &lt;/xsl:for-each&gt;
    &lt;/g&gt;
&lt;/svg&gt;

&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>

<p>The SVG output is:</p>

<div class="exampleInner"><pre>&lt;svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd"&gt;
    &lt;g style="stroke: #000000"&gt;
	&lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
	&lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
	&lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
	&lt;text x="150" y="165"&gt;Division&lt;/text&gt;
	&lt;rect x="10" y="50" width="20" height="100"/&gt;
	&lt;text x="10" y="165"&gt;North&lt;/text&gt;
	&lt;text x="10" y="45"&gt;10&lt;/text&gt;
	&lt;rect x="50" y="110" width="20" height="40"/&gt;
	&lt;text x="50" y="165"&gt;South&lt;/text&gt;
	&lt;text x="50" y="105"&gt;4&lt;/text&gt;
	&lt;rect x="90" y="90" width="20" height="60"/&gt;
	&lt;text x="90" y="165"&gt;West&lt;/text&gt;
	&lt;text x="90" y="85"&gt;6&lt;/text&gt;
    &lt;/g&gt;
&lt;/svg&gt;</pre></div>

<p>The following stylesheet transforms the data into VRML:</p>

<div class="exampleInner"><pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- generate text output as mime type model/vrml, using default charset --&gt;
&lt;xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/&gt;  

        &lt;xsl:template match="/"&gt;#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                &lt;xsl:for-each select="sales/division"&gt;
bar {
        x &lt;xsl:value-of select="revenue"/&gt;
        y &lt;xsl:value-of select="growth"/&gt;
        z &lt;xsl:value-of select="bonus"/&gt;
        name "&lt;xsl:value-of select="@id"/&gt;" 
        }
                &lt;/xsl:for-each&gt;
        
        &lt;/xsl:template&gt; 
 
&lt;/xsl:stylesheet&gt;</pre></div>

<p>The VRML output is:</p>

<div class="exampleInner"><pre>#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                
bar {
        x 10
        y 9
        z 7
        name "North" 
        }
                
bar {
        x 4
        y 3
        z 4
        name "South" 
        }
                
bar {
        x 6
        y -1.5
        z 2
        name "West" 
        }</pre></div>

</div>

</div>

<div class="div1">

<h2><a name="N13416"></a>F Acknowledgements (Non-Normative)</h2>
<p>The following have contributed to authoring this draft:</p>
<blockquote><p>
Scott Boag, Lotus
<br>Michael Kay, ICL
<br>Daniel Lipkin, Saba
<br>Jonathan Marsh, Microsoft
<br>Steve Muench, Oracle
<br>Henry Thompson, University of Edinburgh
<br>Norman Walsh, Arbortext
<br>Steve Zilles, Adobe
</p></blockquote>

<p>This specification was developed and approved for publication by the
W3C XSL Working Group (WG). WG approval of this specification does not
necessarily imply that all WG members voted for its approval. The
current members of the XSL WG are:</p>

<ul>
<li>
Sharon Adler
, IBM
 (<i>Co-Chair</i>) 
</li>
<li>
Anders Berglund
, IBM
</li>
<li>
Perin Blanchard
, Novell
</li>
<li>
Scott Boag
, Lotus
</li>
<li>
Jeff Caruso
, Pageflex
</li>
<li>
James Clark
</li>
<li>
Max Froumentin
, W3C
</li>
<li>
Andrew Greene
, Pageflex
</li>
<li>
Paul Grosso
, ArborText
</li>
<li>
Eduardo Gutentag
, Sun
</li>
<li>
Juliane Harbarth
, Software AG
</li>
<li>
Michael Kay
, ICL
</li>
<li>
Bill Lindsey
, B-Bop
</li>
<li>
Bob Lojek
, Ask Jeeves
</li>
<li>
Chris Maden
, Lexica
</li>
<li>
Jonathan Marsh
, Microsoft
</li>
<li>
Steve Muench
, Oracle
</li>
<li>
Drew Munro
, XMLSolutions
</li>
<li>
Scott Parnell
, Xerox
</li>
<li>
Eduardo Pelegri-Llopart
, Sun
</li>
<li>
Ramesh Pendakur
, Intel
</li>
<li>
Vincent Quint
, W3C
</li>
<li>
Zarella Rendon
, DataChannel
</li>
<li>
Jeremy Richman
, Interleaf
</li>
<li>
Jonathan Robie
, Software AG
</li>
<li>
Mark Scardina
, Oracle
</li>
<li>
Henry Thompson
, University of Edinburgh
</li>
<li>
Amr Yassin
, Philips Electronics
</li>
<li>
Ray Waldin
, Lexica
</li>
<li>
Norman Walsh
, Sun
</li>
<li>
Linda Welsh
, Intel
</li>
<li>
Shon Vella
, Novell
</li>
<li>
Sanjiva Weerawarana
, IBM
</li>
<li>
Steve Zilles
, Adobe
 (<i>Co-Chair</i>) 
</li>
</ul>

<p>The members of the XSL WG at the time of the publication
of XSLT 1.0 were:</p>

<ul>
<li>
Sharon Adler
, IBM
 (<i>Co-Chair</i>) 
</li>
<li>
Anders Berglund
, IBM
</li>
<li>
Perin Blanchard
, Novell
</li>
<li>
Scott Boag
, Lotus 
</li>
<li>
Larry Cable
, Sun
</li>
<li>
Jeff Caruso
, Bitstream
</li>
<li>
James Clark
</li>
<li>
Peter Danielsen
, Bell Labs
</li>
<li>
Don Day
, IBM
</li>
<li>
Stephen Deach
, Adobe
</li>
<li>
Dwayne Dicks
, SoftQuad
</li>
<li>
Andrew Greene
, Bitstream
</li>
<li>
Paul Grosso
, Arbortext
</li>
<li>
Eduardo Gutentag
, Sun
</li>
<li>
Juliane Harbarth
, Software AG
</li>
<li>
Mickey Kimchi
, Enigma
</li>
<li>
Chris Lilley
, W3C
</li>
<li>
Chris Maden
, Exemplary Technologies
</li>
<li>
Jonathan Marsh
, Microsoft
</li>
<li>
Alex Milowski 
, Lexica
</li>
<li>
Boris Moore
, RivCom
</li>
<li>
Steve Muench
, Oracle
</li>
<li>
Scott Parnell
, Xerox
</li>
<li>
Vincent Quint
, W3C
</li>
<li>
Dan Rapp
, Novell
</li>
<li>
Gregg Reynolds
, Datalogics
</li>
<li>
Jonathan Robie
, Software AG
</li>
<li>
Mark Scardina
, Oracle
</li>
<li>
Henry Thompson
, University of Edinburgh
</li>
<li>
Philip Wadler
, Bell Labs
</li>
<li>
Norman Walsh
, Arbortext
</li>
<li>
Sanjiva Weerawarana
, IBM
</li>
<li>
Steve Zilles
, Adobe
 (<i>Co-Chair</i>) 
</li>
</ul>

</div>

<div class="div1">

<h2><a name="N14079"></a>G Changes from XSLT 1.0 (Non-Normative)</h2>

<p>The following are the changes since XSLT 1.0:</p>

<ul>

<li><p>The result tree fragment data-type has been
eliminated. Variable-binding elements with content now construct
node-sets (see <a href="#variable-values"><b>11.2 Values of Variables and Parameters</b></a>).</p></li>

<li><p>Instead of the allowing the output method complete freedom to
add namespace nodes, a process of namespace fixup is applied to the
result tree before it is output; this same namespace fixup process is
also applied to documents constructed variable-binding elements with
content (see <a href="#namespace-fixup"><b>3.5 Namespace Fixup</b></a>).</p></li>

<li><p>Support for XML Base has been added (see <a href="#base-uri"><b>3.2 Base URI</b></a>).</p></li>

<li><p>Multiple output documents can be created using the
<code>xsl:document</code> element (see <a href="#multiple-output"><b>16.5 Multiple Output Documents</b></a>).  For consistency with
<code>xsl:document</code>, the attributes on <code>xsl:output</code>
are now interpreted as attribute value templates.</p></li>

<li><p>An <code>xsl:apply-imports</code> element is allowed to have
parameters (see <a href="#apply-imports"><b>5.6 Overriding Template Rules</b></a> and <a href="#with-param"><b>11.6 Passing Parameters to Templates</b></a>).</p></li>

<li><p>Extension functions can be defined using the
<code>xsl:script</code> function (see <a href="#define-extension-functions"><b>14.4 Defining Extension Functions</b></a>).</p></li>

<li><p>Extension functions are allowed to return
"external" objects, which do not have any of the builtin
XPath types.</p></li>

</ul>

<p>Reported <a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</a>
have also been fixed.</p>

</div>

</div>
</body></html>
