<!-- http://www.w3.org/TR/xquery-30/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--{xml-fix} XSLT Processor: SAXON 9.3.0.5 from Saxonica SAXON EE 9.3.0.5--><!--This document was created at 20140407 1702-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQuery 3.0: An XML Query Language</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"//www.w3.org/StyleSheets/TR/W3C-REC.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery 3.0: An XML Query
Language</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation
08 April 2014</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/REC-xquery-30-20140408/">http://www.w3.org/TR/2014/REC-xquery-30-20140408/</a></dd>
<dt>Latest version of XQuery 3.0:</dt>
<dd><a href=
"http://www.w3.org/TR/xquery-30/">http://www.w3.org/TR/xquery-30/</a></dd>
<dt>Previous version of XQuery 3.0:</dt>
<dd><span class="xquery"><a href=
"http://www.w3.org/TR/2013/PR-xquery-30-20131022/">http://www.w3.org/TR/2013/PR-xquery-30-20131022/</a>,
<a href=
"http://www.w3.org/TR/2013/WD-xquery-30-20130723/">http://www.w3.org/TR/2013/WD-xquery-30-20130723/</a>,
<a href=
"http://www.w3.org/TR/2013/CR-xquery-30-20130108/">http://www.w3.org/TR/2013/CR-xquery-30-20130108/</a>,
<a href=
"http://www.w3.org/TR/2011/WD-xquery-30-20111213/">http://www.w3.org/TR/2011/WD-xquery-30-20111213/</a>,
<a href=
"http://www.w3.org/TR/2011/WD-xquery-30-20110614/">http://www.w3.org/TR/2011/WD-xquery-30-20110614/</a>,
<a href=
"http://www.w3.org/TR/2009/WD-xquery-11-20091215/">http://www.w3.org/TR/2009/WD-xquery-11-20091215/</a>,
<a href=
"http://www.w3.org/TR/2008/WD-xquery-11-20081203/">http://www.w3.org/TR/2008/WD-xquery-11-20081203/</a>,
<a href=
"http://www.w3.org/TR/2008/WD-xquery-11-20080711/">http://www.w3.org/TR/2008/WD-xquery-11-20080711/</a></span></dd>
<dt>Most recent version of XQuery 3:</dt>
<dd><a href=
"http://www.w3.org/TR/xquery-3/">http://www.w3.org/TR/xquery-3/</a></dd>
<dt>Most recent Recommendation of XQuery:</dt>
<dd><a href=
"http://www.w3.org/TR/2010/REC-xquery-20101214/">http://www.w3.org/TR/2010/REC-xquery-20101214/</a></dd>
<dt>Editors:</dt>
<dd>Jonathan Robie, <span>EMC Corporation</span> <a href=
"mailto:jonathan.robie@emc.com">&lt;jonathan.robie@emc.com&gt;</a></dd>
<dd>Don Chamberlin <a href=
"mailto:dchamber@us.ibm.com">&lt;dchamber@us.ibm.com&gt;</a></dd>
<dd>Michael Dyck, Invited Expert <a href=
"mailto:jmdyck@ibiblio.org">&lt;jmdyck@ibiblio.org&gt;</a></dd>
<dd><span><a href="http://john.snelson.org.uk">John
Snelson</a></span> , MarkLogic Corporation <a href=
"mailto:john.snelson@marklogic.com">&lt;john.snelson@marklogic.com&gt;</a></dd>
</dl>
<p>Please check the <a href=
"http://www.w3.org/XML/2014/qt-errata/xquery-30-errata.html"><strong>
errata</strong></a> for any errors or issues reported since
publication.</p>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-30">
<strong>translations</strong></a>.</p>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2014/REC-xquery-30-20140408/xquery-30.xml">XML</a>
and&#160;<a href=
"http://www.w3.org/TR/2014/REC-xquery-30-20140408/xquery-30-diff.html">Change
markings relative to previous edition</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2014&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href=
"http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p class="xquery">XML is a versatile markup language, capable of
labeling the information content of diverse data sources including
structured and semi-structured documents, relational databases, and
object repositories. A query language that uses the structure of
XML intelligently can express queries across all these kinds of
data, whether physically stored in XML or viewed as XML via
middleware. This specification describes a query language called
XQuery, which is designed to be broadly applicable across many
types of XML data sources.</p>
<p class="xquery">XQuery 3.0 is an extended version of the XQuery
1.0 Recommendation published on 23 January 2007. A list of changes
made since XQuery 1.0 can be found in <a href=
"#id-revision-log"><b>J Change Log</b></a>. Here are some of the
new features in XQuery 3.0:</p>
<ol class="enumar">
<li>
<p><code>group by</code> clause in FLWOR Expressions (<a href=
"#id-group-by"><b>3.10.7 Group By Clause</b></a>).</p>
</li>
<li>
<p><code>tumbling window</code> and <code>sliding window</code> in
FLWOR Expressions (<a href="#id-windows"><b>3.10.4 Window
Clause</b></a>).</p>
</li>
<li>
<p><code>count</code> clause in FLWOR Expressions (<a href=
"#id-count"><b>3.10.6 Count Clause</b></a>).</p>
</li>
<li>
<p><code>allowing empty</code> in <a href=
"#id-xquery-for-clause"><b>3.10.2 For Clause</b></a>, for
functionality similar to outer joins in SQL.</p>
</li>
<li>
<p><code>try</code>/<code>catch</code> expressions (<a href=
"#id-try-catch"><b>3.15 Try/Catch Expressions</b></a>).</p>
</li>
<li>
<p>Dynamic function <span>call</span> (<a href=
"#id-dynamic-function-invocation"><b>3.2.2 Dynamic Function
Call</b></a> ).</p>
</li>
<li>
<p>Inline function <span>expression</span>s (<a href=
"#id-inline-func"><b>3.1.7 Inline Function
Expressions</b></a>).</p>
</li>
<li>
<p>Private functions (<a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>).</p>
</li>
<li>
<p>Switch expressions (<a href="#id-switch"><b>3.13 Switch
Expression</b></a>).</p>
</li>
<li>
<p>Computed namespace constructors (<a href=
"#id-computed-namespaces"><b>3.9.3.7 Computed Namespace
Constructors</b></a>).</p>
</li>
<li>
<p>Output declarations (<a href="#id-serialization"><b>2.2.4
Serialization</b></a>).</p>
</li>
<li>
<p>Annotations (<a href="#id-annotations"><b>4.15
Annotations</b></a>).</p>
</li>
<li>
<p><a title="function assertion" href=
"#dt-function-assertion">Function assertions</a> in <a href=
"#doc-xquery30-FunctionTest">function tests</a>.</p>
</li>
<li>
<p>A string concatenation operator (<a href=
"#id-string-concat-expr"><b>3.6 String Concatenation
Expressions</b></a>).</p>
</li>
<li>
<p>A mapping operator (<a href="#id-map-operator"><b>3.17 Simple
map operator (!)</b></a>).</p>
</li>
</ol>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is one document in a set of six documents that have been
progressed to Recommendation together (XQuery 3.0, XQueryX 3.0,
XPath 3.0, Data Model 3.0, Functions and Operators 3.0, and
Serialization 3.0).</p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
of the W3C. It was developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a>, which
is part of the <a href="http://www.w3.org/XML/Activity">XML
Activity</a>.</p>
<p>This Recommendation of XQuery 3.0 represents the second version
of <a href="http://www.w3.org/TR/2010/REC-xquery-20101214/">a
previous W3C Recommendation</a>.</p>
<p class="xquery">A Test Suite has been created for this document.
Implementors are encouraged to run this test suite and report their
results. The Test Suite can be found at <a href=
"http://dev.w3.org/2011/QT3-test-suite/">http://dev.w3.org/2011/QT3-test-suite/</a>.
An <a href=
"http://dev.w3.org/2011/QT3-test-suite/ReportingResults/">implementation
report</a> is available.</p>
<p>This document incorporates minor changes made against the
<a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsPR">Proposed
Recommendation</a> of 22 October 2013. Changes to this document
since the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsPR">Proposed
Recommendation</a> are detailed in <a href="#id-revision-log"><b>J
Change Log</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[XQuery30]” in
the subject line of your report, whether made in Bugzilla or in
email. Please use multiple Bugzilla entries (or, if necessary,
multiple email messages) if you have more than one comment to make.
Archives of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from
another document. W3C's role in making the Recommendation is to
draw attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the group; that page also includes instructions for
disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">Introduction</a><br />
2 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#context">Module Context and
Expression Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#id-processing-model">Processing Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#id-data-model-generation">Data Model Generation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#id-schema-import-processing">Schema Import Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#id-expression-processing">Expression Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1
<a href="#id-static-analysis">Static Analysis Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2
<a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#id-serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
"#id-consistency-constraints">Consistency Constraints</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#errors">Error
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#id-kinds-of-errors">Kinds of Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#id-identifying-errors">Identifying and Reporting Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#id-handling-dynamic">Handling Dynamic Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#id-errors-and-opt">Errors and Optimization</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#id-important-concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#id-document-order">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href=
"#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.5 <a href=
"#id-uri-literals">URI Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.6 <a href=
"#id-resolve-relative-uri">Resolving a Relative URI
Reference</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#id-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
"#id-predefined-types">Predefined Schema Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
"#id-namespace-sensitive">Namespace-sensitive Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
"#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4 <a href=
"#id-sequencetype-syntax">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5 <a href=
"#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.1
<a href="#id-matching-value">Matching a SequenceType and a
Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.2
<a href="#id-matching-item">Matching an ItemType and an
Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.3
<a href="#id-element-test">Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.4
<a href="#id-schema-element-test">Schema Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.5
<a href="#id-attribute-test">Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.6
<a href="#id-schema-attribute-test">Schema Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.7
<a href="#id-function-test">Function Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6 <a href=
"#id-sequencetype-subtype">SequenceType Subtype
Relationships</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6.1
<a href="#id-seqtype-subtype">The judgement subtype(A, B)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6.2
<a href="#id-itemtype-subtype">The judgement subtype-itemtype(Ai,
Bi)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6.3
<a href="#id-assertions-subtype">The judgement
subtype-assertions(AnnotationsA, AnnotationsB)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.7 <a href=
"#id-xs-error">xs:error</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#comments">Comments</a><br />
3 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;3.1 <a href=
"#id-primary-expressions">Primary Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
"#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
"#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href=
"#id-function-calls">Static Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.1
<a href="#id-eval-function-call">Evaluating Static and Dynamic
Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.2
<a href="#id-function-conversion-rules">Function Conversion
Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.3
<a href="#id-function-coercion">Function Coercion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.6 <a href=
"#id-named-function-ref">Named Function References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.7 <a href=
"#id-inline-func">Inline Function Expressions</a><br />
&#160;&#160;&#160;&#160;3.2 <a href=
"#id-postfix-expression">Postfix Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#id-filter-expression">Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#id-dynamic-function-invocation">Dynamic Function Call</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#id-path-expressions">Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
"#id-relative-path-expressions">Relative Path Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1.1
<a href="#id-path-operator">Path operator (/)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
"#id-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2.1
<a href="#axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2.2
<a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.3 <a href=
"#id-predicate">Predicates within Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.4 <a href=
"#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.5 <a href=
"#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;3.4 <a href=
"#id-sequence-expressions">Sequence Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.1 <a href=
"#construct_seq">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.2 <a href=
"#combining_seq">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#id-arithmetic">Arithmetic
Expressions</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#id-string-concat-expr">String
Concatenation Expressions</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#id-comparisons">Comparison
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.1 <a href=
"#id-value-comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.2 <a href=
"#id-general-comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.3 <a href=
"#id-node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;3.8 <a href=
"#id-logical-expressions">Logical Expressions</a><br />
&#160;&#160;&#160;&#160;3.9 <a href=
"#id-constructors">Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.1 <a href=
"#id-element-constructor">Direct Element Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.1.1
<a href="#id-attributes">Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.1.2
<a href="#id-namespaces">Namespace Declaration Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.1.3
<a href="#id-content">Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.1.4
<a href="#id-whitespace">Boundary Whitespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.2 <a href=
"#id-otherConstructors">Other Direct Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3 <a href=
"#id-computedConstructors">Computed Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.1
<a href="#id-computedElements">Computed Element
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.2
<a href="#id-computedAttributes">Computed Attribute
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.3
<a href="#id-documentConstructors">Document Node
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.4
<a href="#id-textConstructors">Text Node Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.5
<a href="#id-computed-pis">Computed Processing Instruction
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.6
<a href="#id-computed-comments">Computed Comment
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.3.7
<a href="#id-computed-namespaces">Computed Namespace
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.9.4 <a href=
"#id-ns-nodes-on-elements">In-scope Namespaces of a Constructed
Element</a><br />
&#160;&#160;&#160;&#160;3.10 <a href="#id-flwor-expressions">FLWOR
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
"#id-binding-rules">Variable Bindings</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
"#id-xquery-for-clause">For Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href=
"#id-xquery-let-clause">Let Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a href=
"#id-windows">Window Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4.1
<a href="#id-tumbling-windows">Tumbling Windows</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4.2
<a href="#id-sliding-windows">Sliding Windows</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4.3
<a href="#id-effects-of-window-clauses">Effects of Window Clauses
on the Tuple Stream</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a href=
"#id-where">Where Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.6 <a href=
"#id-count">Count Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.7 <a href=
"#id-group-by">Group By Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.8 <a href=
"#id-order-by-clause">Order By Clause</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.9 <a href=
"#id-return-clause">Return Clause</a><br />
&#160;&#160;&#160;&#160;3.11 <a href=
"#id-unordered-expressions">Ordered and Unordered
Expressions</a><br />
&#160;&#160;&#160;&#160;3.12 <a href="#id-conditionals">Conditional
Expressions</a><br />
&#160;&#160;&#160;&#160;3.13 <a href="#id-switch">Switch
Expression</a><br />
&#160;&#160;&#160;&#160;3.14 <a href=
"#id-quantified-expressions">Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;3.15 <a href="#id-try-catch">Try/Catch
Expressions</a><br />
&#160;&#160;&#160;&#160;3.16 <a href=
"#id-expressions-on-datatypes">Expressions on
SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.1 <a href=
"#id-instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.2 <a href=
"#id-typeswitch">Typeswitch</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.3 <a href=
"#id-cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.4 <a href=
"#id-castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.5 <a href=
"#id-constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.16.6 <a href=
"#id-treat">Treat</a><br />
&#160;&#160;&#160;&#160;3.17 <a href="#id-map-operator">Simple map
operator (!)</a><br />
&#160;&#160;&#160;&#160;3.18 <a href="#id-validate">Validate
Expressions</a><br />
&#160;&#160;&#160;&#160;3.19 <a href=
"#id-extension-expressions">Extension Expressions</a><br />
4 <a href="#id-query-prolog">Modules and Prologs</a><br />
&#160;&#160;&#160;&#160;4.1 <a href=
"#id-version-declaration">Version Declaration</a><br />
&#160;&#160;&#160;&#160;4.2 <a href="#id-module-declaration">Module
Declaration</a><br />
&#160;&#160;&#160;&#160;4.3 <a href=
"#id-boundary-space-decls">Boundary-space Declaration</a><br />
&#160;&#160;&#160;&#160;4.4 <a href=
"#id-default-collation-declaration">Default Collation
Declaration</a><br />
&#160;&#160;&#160;&#160;4.5 <a href="#id-base-uri-decl">Base URI
Declaration</a><br />
&#160;&#160;&#160;&#160;4.6 <a href=
"#id-construction-declaration">Construction Declaration</a><br />
&#160;&#160;&#160;&#160;4.7 <a href=
"#id-default-ordering-decl">Ordering Mode Declaration</a><br />
&#160;&#160;&#160;&#160;4.8 <a href="#id-empty-order-decl">Empty
Order Declaration</a><br />
&#160;&#160;&#160;&#160;4.9 <a href=
"#id-copy-namespaces-decl">Copy-Namespaces Declaration</a><br />
&#160;&#160;&#160;&#160;4.10 <a href=
"#id-decimal-format-decl">Decimal Format Declaration</a><br />
&#160;&#160;&#160;&#160;4.11 <a href="#id-schema-import">Schema
Import</a><br />
&#160;&#160;&#160;&#160;4.12 <a href="#id-module-import">Module
Import</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.1 <a href=
"#id-module-handling-module-uris">The Target Namespace of a
Module</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.2 <a href=
"#id-module-handling-multiple-same">Multiple Modules with the same
Target Namespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.3 <a href=
"#id-module-handling-location-uris">Location URIs</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.4 <a href=
"#id-module-handling-cycles">Cycles</a><br />
&#160;&#160;&#160;&#160;4.13 <a href=
"#id-namespace-declaration">Namespace Declaration</a><br />
&#160;&#160;&#160;&#160;4.14 <a href=
"#id-default-namespace">Default Namespace Declaration</a><br />
&#160;&#160;&#160;&#160;4.15 <a href=
"#id-annotations">Annotations</a><br />
&#160;&#160;&#160;&#160;4.16 <a href=
"#id-variable-declarations">Variable Declaration</a><br />
&#160;&#160;&#160;&#160;4.17 <a href=
"#id-context-item-declarations">Context Item Declaration</a><br />
&#160;&#160;&#160;&#160;4.18 <a href="#FunctionDeclns">Function
Declaration</a><br />
&#160;&#160;&#160;&#160;4.19 <a href=
"#id-option-declaration">Option Declaration</a><br />
5 <a href="#id-xquery-conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;5.1 <a href=
"#id-minimal-conformance">Minimal Conformance</a><br />
&#160;&#160;&#160;&#160;5.2 <a href=
"#id-conform-optional-features">Optional Features</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.3 <a href=
"#id-schema-aware-feature">Schema Aware Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.4 <a href=
"#id-typed-data-feature">Typed Data Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.5 <a href=
"#id-static-typing-feature">Static Typing Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.6 <a href=
"#id-module-feature">Module Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.7 <a href=
"#id-serialization-feature">Serialization Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.8 <a href=
"#id-higher-order-function-feature">Higher-Order Function
Feature</a><br />
&#160;&#160;&#160;&#160;5.3 <a href=
"#id-data-model-conformance">Data Model Conformance</a><br />
&#160;&#160;&#160;&#160;5.4 <a href="#id-syntax-extensions">Syntax
Extensions</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XQuery 3.0 Grammar</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#id-grammar">EBNF</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href=
"#EBNFNotation">Notation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.2 <a href=
"#extra-grammatical-constraints">Extra-grammatical
Constraints</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.3 <a href=
"#notes-on-parsing">Grammar Notes</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#lexical-structure">Lexical
structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href=
"#terminal-symbols">Terminal Symbols</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href=
"#id-terminal-delimitation">Terminal Delimitation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3 <a href=
"#id-eol-handling">End-of-Line Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.1
<a href="#id-xml10-eol-handling">XML 1.0 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.2
<a href="#id-xml11-eol-handling">XML 1.1 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4 <a href=
"#whitespace-rules">Whitespace Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.1
<a href="#DefaultWhitespaceHandling">Default Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.2
<a href="#ExplicitWhitespaceHandling">Explicit Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;A.3 <a href=
"#id-reserved-fn-names">Reserved Function Names</a><br />
&#160;&#160;&#160;&#160;A.4 <a href=
"#id-precedence-order">Precedence Order (Non-Normative)</a><br />
B <a href="#id-type-promotion-and-operator-mapping">Type Promotion
and Operator Mapping</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type
Promotion</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator
Mapping</a><br />
C <a href="#id-xq-context-components">Context Components</a><br />
&#160;&#160;&#160;&#160;C.1 <a href=
"#id-xq-static-context-components">Static Context
Components</a><br />
&#160;&#160;&#160;&#160;C.2 <a href=
"#id-xq-evaluation-context-components">Dynamic Context
Components</a><br />
D <a href="#id-impl-defined-items">Implementation-Defined
Items</a><br />
E <a href="#id-references">References</a><br />
&#160;&#160;&#160;&#160;E.1 <a href=
"#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;E.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;E.3 <a href=
"#id-background-material">Background Material</a><br />
F <a href="#id-errors">Error Conditions</a><br />
G <a href="#id-mime-type">The application/xquery Media
Type</a><br />
&#160;&#160;&#160;&#160;G.1 <a href=
"#id-mime-type-intro">Introduction</a><br />
&#160;&#160;&#160;&#160;G.2 <a href=
"#id-registration-of-mime-type">Registration of MIME Media Type
application/xquery</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G.2.1 <a href=
"#id-interoperability-considerations">Interoperability
Considerations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G.2.2 <a href=
"#id-applications-of-media-type">Applications Using this Media
Type</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G.2.3 <a href=
"#id-file-extensions">File Extensions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G.2.4 <a href=
"#id-intended-usage">Intended Usage</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G.2.5 <a href=
"#id-author-change-controller">Author/Change Controller</a><br />
&#160;&#160;&#160;&#160;G.3 <a href=
"#xquery-mime-encoding">Encoding Considerations</a><br />
&#160;&#160;&#160;&#160;G.4 <a href=
"#xquery-mime-recognizing">Recognizing XQuery Files</a><br />
&#160;&#160;&#160;&#160;G.5 <a href=
"#id-charset-default-rules">Charset Default Rules</a><br />
&#160;&#160;&#160;&#160;G.6 <a href=
"#id-security-considerations">Security Considerations</a><br />
H <a href="#id-glossary">Glossary</a> (Non-Normative)<br />
I <a href="#id-example-applications">Example Applications</a>
(Non-Normative)<br />
&#160;&#160;&#160;&#160;I.1 <a href="#id-joins">Joins</a><br />
&#160;&#160;&#160;&#160;I.2 <a href=
"#id-queries-on-sequence">Queries on Sequence</a><br />
&#160;&#160;&#160;&#160;I.3 <a href=
"#id-recursive-transformations">Recursive Transformations</a><br />
&#160;&#160;&#160;&#160;I.4 <a href="#id-select-distinct">Selecting
Distinct Combinations</a><br />
J <a href="#id-revision-log">Change Log</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href=
"#id-incompatibilities">Incompatibilities</a><br />
&#160;&#160;&#160;&#160;J.2 <a href=
"#id-changes-this-draft">Changes introduced during the Proposed
Recommendation period:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.1 <a href=
"#id-changes-this-draft-substantive">Substantive Changes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.2 <a href=
"#id-changes-this-draft-editorial">Editorial Changes</a><br />
&#160;&#160;&#160;&#160;J.3 <a href="#id-changes-PR">Changes
introduced during the Candidate Recommendation period:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.3.1 <a href=
"#id-changes-PR-substantive">Substantive Changes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.3.2 <a href=
"#id-changes-PR-editorial">Editorial Changes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.3.3 <a href=
"#id-changes-this-draft-not-implemented">Resolutions that are no
longer relevant.</a><br />
&#160;&#160;&#160;&#160;J.4 <a href="#id-changes-CR">Changes
introduced in the Candidate Recommendation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.4.1 <a href=
"#id-changes-CR-substantive">Substantive Changes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.4.2 <a href=
"#id-changes-CR-editorial">Editorial Changes</a><br />
&#160;&#160;&#160;&#160;J.5 <a href=
"#id-changes-prior-drafts">Changes introduced in prior Working
Drafts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.5.1 <a href=
"#id-changes-prior-drafts-substantive">Substantive
Changes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.5.2 <a href=
"#id-changes-prior-drafts-editorial">Editorial
Changes</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="id-introduction" id="id-introduction"></a>1
Introduction</h2>
<p class="xquery">As increasing amounts of information are stored,
exchanged, and presented using XML, the ability to intelligently
query XML data sources becomes increasingly important. One of the
great strengths of XML is its flexibility in representing many
different kinds of information from diverse sources. To exploit
this flexibility, an XML query language must provide features for
retrieving and interpreting information from these diverse
sources.</p>
<p class="xquery">XQuery is designed to meet the requirements
identified by the W3C XML Query Working Group <a href=
"#xquery-30-requirements">[XQuery 3.0 Requirements]</a> and the use
cases in <a href="#UseCases">[XML Query Use Cases]</a>. It is
designed to be a language in which queries are concise and easily
understood. It is also flexible enough to query a broad spectrum of
XML information sources, including both databases and documents.
The Query Working Group has identified a requirement for both a
non-XML query syntax and an XML-based query syntax. XQuery is
designed to meet the first of these requirements. XQuery is derived
from an XML query language called Quilt <a href=
"#Quilt">[Quilt]</a>, which in turn borrowed features from several
other languages, including XPath 1.0 <a href="#xpath">[XML Path
Language (XPath) Version 1.0]</a>, XQL <a href="#XQL">[XQL]</a>,
XML-QL <a href="#XML-QL">[XML-QL]</a>, SQL <a href=
"#SQL">[SQL]</a>, and OQL <a href="#ODMG">[ODMG]</a>.</p>
<p>[<a name="dt-datamodel" id="dt-datamodel" title=
"data model">Definition</a>: XQuery 3.0 operates on the abstract,
logical structure of an XML document, rather than its surface
syntax. This logical structure, known as the <b>data model</b>, is
defined in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a>.]</p>
<p>XQuery Version 3.0 is an extension of XPath Version 3.0. In
general, any expression that is syntactically valid and executes
successfully in both XPath 3.0 and XQuery 3.0 will return the same
result in both languages. There are a few exceptions to this
rule:</p>
<ul>
<li>
<p>Because XQuery expands <span class="xquery"><a title=
"predefined entity reference" href=
"#dt-predefined-entity-reference">predefined entity references</a>
and <a title="character reference" href=
"#dt-character-reference">character references</a></span> and XPath
does not, expressions containing these produce different results in
the two languages. For instance, the value of the string literal
<code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and
<code>&amp;amp;</code> in XPath. (XPath is often embedded in other
languages, which may expand predefined entity references or
character references before the XPath expression is evaluated.)</p>
</li>
<li>
<p>If XPath 1.0 compatibility mode is enabled, XPath behaves
differently from XQuery in a number of ways, <span class=
"xquery">which are discussed in <a href="#xpath-30">[XML Path
Language (XPath) 3.0]</a>.</span></p>
</li>
</ul>
<p>Because these languages are so closely related, their grammars
and language descriptions are generated from a common source to
ensure consistency, and the editors of these specifications work
together closely.</p>
<p>XQuery 3.0 also depends on and is closely related to the
following specifications:</p>
<ul>
<li>
<p><a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a> defines the data model that underlies all XQuery 3.0
expressions.</p>
</li>
<li>
<p>The type system of XQuery 3.0 is based on XML Schema. It is
implementation-defined whether the type system is based on <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.</p>
</li>
<li>
<p>The built-in function library and the operators supported by
XQuery 3.0 are defined in <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>.</p>
</li>
<li>
<p><span>XQuery also has an XML-based syntax, which</span> is
described in <a href="#xqueryx-30">[XQueryX 3.0]</a>.</p>
</li>
</ul>
<p class="xquery">[<a name="dt-xquery-30-processor" id=
"dt-xquery-30-processor" title=
"XQuery 3.0 Processor">Definition</a>: An <b>XQuery 3.0
Processor</b> processes a query according to the XQuery 3.0
specification. ] [<a name="dt-xquery-10-processor" id=
"dt-xquery-10-processor" title=
"XQuery 1.0 Processor">Definition</a>: An <b>XQuery 1.0
Processor</b> processes a query according to the XQuery 1.0
specification. ]</p>
<p class="path">[<a name="dt-xpath-30-processor" id=
"dt-xpath-30-processor" title="XPath 3.0 Processor">Definition</a>:
An <b>XPath 3.0 Processor</b> processes a query according to the
XPath 3.0 specification.] [<a name="dt-xpath-20-processor" id=
"dt-xpath-20-processor" title="XPath 2.0 Processor">Definition</a>:
An <b>XPath 2.0 Processor</b> processes a query according to the
XPath 2.0 specification.] [<a name="dt-xpath-10-processor" id=
"dt-xpath-10-processor" title="XPath 1.0 Processor">Definition</a>:
An <b>XPath 1.0 Processor</b> processes a query according to the
XPath 1.0 specification.]</p>
<p>This document specifies a grammar for XQuery 3.0, using the same
basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless
otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical
structure</b></a>), whitespace is not significant in <span class=
"xquery">queries</span>. Grammar productions are introduced
together with the features that they describe, and a complete
grammar is also presented in the appendix [<a href="#nt-bnf"><b>A
XQuery 3.0 Grammar</b></a>]. The appendix is the normative
version.</p>
<p>In the grammar productions in this document, named symbols are
underlined and literal text is enclosed in double quotes. For
example, the following productions describe the syntax of a
<span>static</span> function call:</p>
<h5><a name="d2e531" id="d2e531"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e532.doc-xquery30-FunctionCall" id=
"noid_d3e532.doc-xquery30-FunctionCall"></a>[133]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a> <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e533.doc-xquery30-ArgumentList" id=
"noid_d3e533.doc-xquery30-ArgumentList"></a>[121]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xquery30-Argument">Argument</a> (","
<a href="#doc-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>The productions should be read as follows: A <span>static</span>
function call consists of an <a href=
"#doc-xquery30-EQName">EQName</a> followed by an <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a>. The argument list
consists of an opening parenthesis, an optional list of one or more
arguments (separated by commas), and a closing parenthesis.</p>
<p>This document normatively defines the static and dynamic
semantics of XQuery 3.0. In this document, examples and material
labeled as "Note" are provided for explanatory purposes and are not
normative.</p>
<p>Certain aspects of language processing are described in this
specification as <b>implementation-defined</b> or
<b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>Implementation-defined</b> indicates an aspect that may differ
between implementations, but must be specified by the implementor
for each particular implementation.]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.]</p>
</li>
</ul>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>2 Basics</h2>
<p>The basic building block of XQuery 3.0 is the <b>expression</b>,
which is a string of <a href="#Unicode">[Unicode]</a> characters;
the version of Unicode to be used is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. The
language provides several kinds of expressions which may be
constructed from keywords, symbols, and operands. In general, the
operands of an expression are other expressions. XQuery 3.0 allows
expressions to be nested with full generality. <span class=
"xquery">(However, unlike a pure functional language, it does not
allow variable substitution if the variable declaration contains
construction of new nodes.)</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification contains no assumptions or requirements
regarding the character set encoding of strings of <a href=
"#Unicode">[Unicode]</a> characters.</p>
</div>
<p>Like XML, XQuery 3.0 is a case-sensitive language. Keywords in
XQuery 3.0 use lower-case characters and are not reserved—that is,
names in XQuery 3.0 expressions are allowed to be the same as
language keywords, except for certain unprefixed function-names
listed in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function
Names</b></a>.</p>
<p>[<a name="dt-value" id="dt-value" title="value">Definition</a>:
In the <a title="data model" href="#dt-datamodel">data model</a>, a
<b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.] [<a name="dt-sequence" id=
"dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is
an ordered collection of zero or more <a title="item" href=
"#dt-item">items</a>.] [<a name="dt-item" id="dt-item" title=
"item">Definition</a>: An <b>item</b> is either an <a title=
"atomic value" href="#dt-atomic-value">atomic value</a>, a
<a title="node" href="#dt-node">node</a>, or a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>.]
[<a name="dt-atomic-value" id="dt-atomic-value" title=
"atomic value">Definition</a>: An <b>atomic value</b> is a value in
the value space of an <b>atomic type</b>, as defined in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.] [<a name="dt-node" id="dt-node" title=
"node">Definition</a>: A <b>node</b> is an instance of one of the
<b>node kinds</b> defined in <a href="#xpath-datamodel-30">[XQuery
and XPath Data Model (XDM) 3.0]</a>.] Each node has a unique
<b>node identity</b>, a <b>typed value</b>, and a <b>string
value</b>. In addition, some nodes have a <b>name</b>. The <b>typed
value</b> of a node is a sequence of zero or more atomic values.
The <b>string value</b> of a node is a value of type
<code>xs:string</code>. The <b>name</b> of a node is a value of
type <code>xs:QName</code>.</p>
<p>[<a name="dt-singleton" id="dt-singleton" title=
"singleton">Definition</a>: A sequence containing exactly one item
is called a <b>singleton</b>.] An item is identical to a singleton
sequence containing that item. Sequences are never nested—for
example, combining the values 1, (2, 3), and ( ) into a single
sequence results in the sequence (1, 2, 3). [<a name=
"dt-empty-sequence" id="dt-empty-sequence" title=
"empty sequence">Definition</a>: A sequence containing zero items
is called an <b>empty sequence</b>.]</p>
<p>[<a name="dt-data-model-instance" id="dt-data-model-instance"
title="XDM instance">Definition</a>: The term <b>XDM instance</b>
is used, synonymously with the term <a title="value" href=
"#dt-value">value</a>, to denote an unconstrained <a title=
"sequence" href="#dt-sequence">sequence</a> of <a title="item"
href="#dt-item">items</a> in the <a title="data model" href=
"#dt-datamodel">data model</a>.]</p>
<p>In the XQuery 3.0 grammar, most names are specified using the
<a href="#doc-xquery30-EQName">EQName</a> production, which allows
<a title="lexical QName" href="#dt-qname">lexical QNames</a>, and
also allows a namespace URI to be specified as a literal:</p>
<h5><a name="d2e753" id="d2e753"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-EQName" id=
"doc-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a> | <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-QName" id=
"doc-xquery30-QName"></a>[212]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-QName">QName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e736.doc-xquery30-NCName" id=
"noid_d3e736.doc-xquery30-NCName"></a>[213]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-URILiteral" id=
"doc-xquery30-URILiteral"></a>[195]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-URIQualifiedName" id=
"doc-xquery30-URIQualifiedName"></a>[201]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xquery30-NCName">NCName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-BracedURILiteral" id=
"doc-xquery30-BracedURILiteral"></a>[202]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BracedURILiteral">BracedURILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" (<a href=
"#doc-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | [^&amp;{}])*
"}"</code></td>
</tr>
</tbody>
</table>
<p>Names in XQuery 3.0 can be bound to namespaces, and are based on
the syntax and semantics defined in <a href="#XMLNAMES">[XML
Names]</a>. [<a name="dt-qname" id="dt-qname" title=
"lexical QName">Definition</a>: A <b>lexical QName</b> is a name
that conforms to the syntax of <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a>.]
A <a title="lexical QName" href="#dt-qname">lexical QName</a>
consists of an optional namespace prefix and a local name. If the
namespace prefix is present, it is separated from the local name by
a colon. A <a title="lexical QName" href="#dt-qname">lexical
QName</a> with a prefix can be converted into an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> by
resolving its namespace prefix to a namespace URI, using the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. The
semantics of a <a title="lexical QName" href="#dt-qname">lexical
QName</a> without a prefix depend on the expression in which it is
found.</p>
<p>[<a name="dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName">Definition</a>: An <b>expanded QName</b> consists
of an optional namespace URI and a local name. An expanded QName
also retains its original namespace prefix (if any), to facilitate
casting the expanded QName into a string.] Two <a title=
"expanded QName" href="#dt-expanded-qname">expanded QNames</a> are
equal if their namespace URIs are equal and their local names are
equal (even if their namespace prefixes are not equal). Namespace
URIs and local names are compared on a codepoint basis, without
further normalization.</p>
<p>The <a href="#doc-xquery30-EQName">EQName</a> production allows
expanded QNames to be specified using either a <a href=
"#doc-xquery30-QName">QName</a> or a <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a>, which allows
the namespace URI to be specified as a literal. The namespace URI
value is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. It is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>] if
the <span>namespace URI</span> for an EQName is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<p>Here are some examples of <a href=
"#doc-xquery30-EQName">EQName</a>s:</p>
<ul>
<li>
<p><code>pi</code> is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> without a namespace prefix.</p>
</li>
<li>
<p><code>math:pi</code> is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> with a namespace prefix.</p>
</li>
<li>
<p><code>Q{http://www.w3.org/2005/xpath-functions/math}pi</code>
specifies the namespace URI using a <a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a>; it is not a
<a title="lexical QName" href="#dt-qname">lexical QName</a>.</p>
</li>
</ul>
<p class="xquery">Certain namespace prefixes are predeclared by
XQuery and bound to fixed namespace URIs. These namespace prefixes
are as follows:</p>
<ul>
<li>
<p><code>xml = http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>local =
http://www.w3.org/2005/xquery-local-functions</code> (see <a href=
"#FunctionDeclns"><b>4.18 Function Declaration</b></a>.)</p>
</li>
</ul>
<p class="xquery">In addition to the prefixes in the above list,
this document uses the prefix <code>err</code> to represent the
namespace URI <code>http://www.w3.org/2005/xqt-errors</code> (see
<a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting
Errors</b></a>). This namespace prefix is not predeclared and its
use in this document is not normative. It also uses the namespace
URI <code>http://www.w3.org/2012/xquery</code> for which no prefix
is used in this document, <span>which is reserved for use in this
specification. It is currently used for annotations and option
declarations that are defined by the XML Query Working
Group.</span></p>
<p>Element nodes have a property called <b>in-scope namespaces</b>.
[<a name="dt-in-scope-namespaces" id="dt-in-scope-namespaces"
title="in-scope namespaces">Definition</a>: The <b>in-scope
namespaces</b> property of an element node is a set of namespace
bindings, each of which associates a namespace prefix with a URI.]
For a given element, one namespace binding may have an empty
prefix; the URI of this namespace binding is the default namespace
within the scope of the element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>,
the in-scope namespaces of an element node are represented by a
collection of <b>namespace nodes</b> arranged on a <b>namespace
axis</b>, which is optional and deprecated in <a href=
"#xpath-30">[XML Path Language (XPath) 3.0]</a>. XQuery does not
support the namespace axis and does not represent namespace
bindings in the form of nodes.</p>
<p>However, where other specifications such as <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery Serialization
3.0]</a> refer to namespace nodes, these nodes may be synthesized
from the in-scope namespaces of an element node by interpreting
each namespace binding as a namespace node. An application that
needs to create a set of namespace nodes to represent these
bindings can do so using the following code.</p>
<div class="exampleInner">
<pre>
in-scope-prefixes($e) ! namespace {namespace-uri-for-prefix($e,.)} {.}
</pre></div>
</div>
<p>[<a name="dt-URI" id="dt-URI" title="URI">Definition</a>: Within
this specification, the term <b>URI</b> refers to a Universal
Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a>
and extended in <a href="#RFC3987">[RFC3987]</a> with the new name
<b>IRI</b>.] The term URI has been retained in preference to IRI to
avoid introducing new names for concepts such as "Base URI" that
are defined or referenced across the whole family of XML
specifications.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In most contexts, processors are not required to raise errors if
a URI is not lexically valid according to <a href=
"#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>. See
<a href="#id-uri-literals"><b>2.4.5 URI Literals</b></a>
<span class="xquery">and <a href="#id-namespaces"><b>3.9.1.2
Namespace Declaration Attributes</b></a></span> for details.</p>
</div>
<div class="div2">
<h3><a name="context" id="context"></a>2.1 <span class=
"xquery">Module Context and</span> Expression Context</h3>
<p>[<a name="dt-expression-context" id="dt-expression-context"
title="expression context">Definition</a>: The <b>expression
context</b> for a given expression consists of all the information
that can affect the result of the expression.]</p>
<p class="xquery">[<a name="dt-module-context" id=
"dt-module-context" title="module context">Definition</a>: The
<b>module context</b> for a given module consists of all the
information that is accessible to top-level expressions in the
module.] The context of a top-level expression is defined based on
the context of the module in which it is defined: the context of
the <a href="#doc-xquery30-QueryBody">QueryBody</a> is the context
of the main module, and the context for evaluating a function body
or for a variable's initializing expression is defined based on the
context of the module in which the function or variable is
defined.</p>
<p>This information is organized into two categories called the
<a title="static context" href="#dt-static-context">static
context</a> and the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a>.</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>2.1.1 Static
Context</h4>
<p>[<a name="dt-static-context" id="dt-static-context" title=
"static context">Definition</a>: The <b>static context</b> of an
expression is the information that is available during static
analysis of the expression, prior to its evaluation.] This
information can be used to decide whether the expression contains a
<a title="static error" href="#dt-static-error">static
error</a>.</p>
<p>The individual components of the <a title="static context" href=
"#dt-static-context">static context</a> are <span>described</span>
below. <span class="xquery">Rules governing the initialization
<span>and alteration</span> of these components can be found in
<a href="#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a>.</span></p>
<ul>
<li>
<p>[<a name="dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode">Definition</a>: <b>XPath 1.0
compatibility mode.</b> <span class="xquery">This component must be
set by all host languages that include XPath 3.0 as a subset,
indicating whether rules for compatibility with XPath 1.0 are in
effect. XQuery sets the value of this component to
<code>false</code>.</span> ]</p>
</li>
<li>
<p>[<a name="dt-static-namespaces" id="dt-static-namespaces" title=
"statically known namespaces">Definition</a>: <b>Statically known
namespaces.</b> This is a <span>mapping from prefix to namespace
URI that defines</span> all the namespaces that are known during
static processing of a given expression.] The URI value is
whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. Note the
difference between <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a>, which is a
dynamic property of an element node, and <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, which is a
static property of an expression.</p>
<p class="xquery">Some namespaces are predefined; additional
namespaces can be added to the statically known namespaces by
<a title="namespace declaration" href=
"#dt-namespace-declaration">namespace declarations</a>,
<span><a title="schema import" href="#dt-schema-import">schema
imports</a>, or <a title="module import" href=
"#dt-module-import">module imports</a> in a <a title="Prolog" href=
"#dt-prolog">Prolog</a>, by a <a title="module declaration" href=
"#dt-module-declaration">module declaration</a></span> , and by
<a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attributes</a> in
<a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructors</a>.</p>
</li>
<li>
<p>[<a name="dt-def-elemtype-ns" id="dt-def-elemtype-ns" title=
"default element/type namespace">Definition</a>: <b>Default
element/type namespace.</b> This is a namespace URI or <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where an element or type name is expected.]
The URI value is whitespace normalized according to the rules for
the <code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</li>
<li>
<p>[<a name="dt-def-fn-ns" id="dt-def-fn-ns" title=
"default function namespace">Definition</a>: <b>Default function
namespace.</b> This is a namespace URI or <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where a function name is expected.] The URI
value is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</li>
<li>
<p>[<a name="dt-issd" id="dt-issd" title=
"in-scope schema definitions">Definition</a>: <b>In-scope schema
definitions.</b> This is a generic term for all the element
declarations, attribute declarations, and schema type definitions
that are in scope during <span>static analysis</span> of an
expression.] It includes the following three parts:</p>
<ul>
<li>
<p>[<a name="dt-is-types" id="dt-is-types" title=
"in-scope schema type">Definition</a>: <b>In-scope schema
types.</b> Each schema type definition is identified either by an
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a <b>named type</b>) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
<span class="xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope schema types also include all type definitions found in
imported schemas.</span> ]</p>
</li>
<li>
<p>[<a name="dt-is-elems" id="dt-is-elems" title=
"in-scope element declarations">Definition</a>: <b>In-scope element
declarations.</b> Each element declaration is identified either by
an <a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a top-level element declaration) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). <span class=
"xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope element declarations include all element declarations
found in imported schemas.</span> ] An element declaration includes
information about the element's <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> affiliation.</p>
<p>[<a name="dt-substitution-group" id="dt-substitution-group"
title="substitution group">Definition</a>: <b>Substitution
groups</b> are defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> and <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1.
Informally, the substitution group headed by a given element
(called the <b>head element</b>) consists of the set of elements
that can be substituted for the head element without affecting the
outcome of schema validation.]</p>
</li>
<li>
<p>[<a name="dt-is-attrs" id="dt-is-attrs" title=
"in-scope attribute declarations">Definition</a>: <b>In-scope
attribute declarations.</b> Each attribute declaration is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level attribute
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration).
<span class="xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope attribute declarations include all attribute declarations
found in imported schemas.</span> ]</p>
</li>
</ul>
</li>
<li>
<p>[<a name="dt-in-scope-variables" id="dt-in-scope-variables"
title="in-scope variables">Definition</a>: <b>In-scope
variables.</b> This is a <span>mapping from <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> to
type.</span> It defines the set of variables that are available for
reference within an expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the
variable, and the type is the <a title="static type" href=
"#dt-static-type">static type</a> of the variable.]</p>
<p><span class="xquery">Variable declarations in a <a title=
"Prolog" href="#dt-prolog">Prolog</a> are added to <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a>.</span> <span>An expression that binds a variable
extends the <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a>, within the scope
of the variable, with the variable and its type.</span> Within the
body of an <a title="inline function expression" href=
"#dt-inline-func">inline function <span>expression</span></a>
<span class="xquery">or <a title="user-defined function" href=
"#dt-udf">user-defined function</a></span> , the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> are extended by the names and types of the
<b>function parameters</b>.</p>
<p class="xquery">The static type of a variable may either be
declared in a query or inferred by static type inference as
discussed in <a href="#id-static-analysis"><b>2.2.3.1 Static
Analysis Phase</b></a>.</p>
</li>
<li>
<p>[<a name="dt-context-item-static-type" id=
"dt-context-item-static-type" title=
"context item static type">Definition</a>: <b>Context item static
type.</b> This component defines the <a title="static type" href=
"#dt-static-type">static type</a> of the context item within the
scope of a given expression.]</p>
</li>
<li>
<p>[<a name="dt-known-func-signatures" id=
"dt-known-func-signatures" title=
"statically known function signatures">Definition</a>:
<b>Statically known function signatures.</b> This is a mapping from
(expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-signature">function
signature</a><sup><small>DM30</small></sup>. ] The entries in this
mapping define the set of <b>statically known functions</b> — those
functions that are available to be called from a <a title=
"static function call" href="#dt-static-function-call">static
function call</a>, or referenced from a <a title=
"named function reference" href="#dt-named-function-ref">named
function reference</a>. Each such function is uniquely identified
by its <a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> and arity (number of parameters). Given a statically
known function's expanded QName and arity, this component supplies
the function's <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-signature">signature</a><sup><small>DM30</small></sup>,
which specifies various static properties of the function,
including types<span class="xquery">and annotations</span>.</p>
<p>The <span>statically known</span> function signatures include
the signatures of functions from a variety of sources, including
built-in functions described in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>, <span class="xquery">functions declared in the current
module (see <a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>), module imports (see <a href=
"#id-module-import"><b>4.12 Module Import</b></a>), <a title=
"constructor function" href="#dt-constructor-function">constructor
functions</a> (see <a href="#id-constructor-functions"><b>3.16.5
Constructor Functions</b></a>), and functions provided by an
implementation or via an implementation-defined API (see <a href=
"#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a>)</span>. <span class="xquery">It is a <a title=
"static error" href="#dt-static-error">static error</a> [<a href=
"#ERRXQST0034" title="err:XQST0034">err:XQST0034</a>] if two such
functions have the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and the same arity (even if
the signatures are consistent).</span></p>
</li>
<li>
<p>[<a name="dt-static-collations" id="dt-static-collations" title=
"statically known collations">Definition</a>: <b>Statically known
collations.</b> This is an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>
<span>mapping from URI to collation.</span> It defines the names of
the collations that are available for use in processing
<span class="xquery">queries and</span> expressions.] [<a name=
"dt-collation" id="dt-collation" title="collation">Definition</a>:
A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.]</p>
</li>
<li>
<p>[<a name="dt-def-collation" id="dt-def-collation" title=
"default collation">Definition</a>: <b>Default collation.</b> This
identifies one of the collations in <a title=
"statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.]</p>
</li>
<li>
<p>[<a name="dt-construction-mode" id="dt-construction-mode" title=
"construction mode">Definition</a>: <b>Construction mode.</b> The
construction mode governs the behavior of element and document node
constructors. If construction mode is <code>preserve</code>, the
type of a constructed element node is <code>xs:anyType</code>, and
all attribute and element nodes copied during node construction
retain their original types. If construction mode is
<code>strip</code>, the type of a constructed element node is
<code>xs:untyped</code>; all element nodes copied during node
construction receive the type <code>xs:untyped</code>, and all
attribute nodes copied during node construction receive the type
<code>xs:untypedAtomic</code>.]</p>
</li>
<li>
<p>[<a name="dt-ordering-mode" id="dt-ordering-mode" title=
"ordering mode">Definition</a>: <b>Ordering mode.</b> Ordering
mode, which has the value <code>ordered</code> or
<code>unordered</code>, affects the ordering of the result sequence
returned by certain <span>expressions, as discussed in <a href=
"#id-unordered-expressions"><b>3.11 Ordered and Unordered
Expressions</b></a>.</span> ]</p>
</li>
<li>
<p>[<a name="dt-default-empty-order" id="dt-default-empty-order"
title="default order for empty sequences">Definition</a>:
<b>Default order for empty sequences.</b> This component controls
the processing of empty sequences and <code>NaN</code> values as
ordering keys in an <code>order by</code> clause in a FLWOR
expression, as described in <a href="#id-order-by-clause"><b>3.10.8
Order By Clause</b></a>.] Its value may be <code>greatest</code> or
<code>least</code>.</p>
</li>
<li>
<p>[<a name="dt-boundary-space-policy" id=
"dt-boundary-space-policy" title=
"boundary-space policy">Definition</a>: <b>Boundary-space
policy.</b> This component controls the processing of <a title=
"boundary whitespace" href="#dt-boundary-whitespace">boundary
whitespace</a> by <a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructors</a>, as
described in <a href="#id-whitespace"><b>3.9.1.4 Boundary
Whitespace</b></a>.] Its value may be <code>preserve</code> or
<code>strip</code>.</p>
</li>
<li>
<p>[<a name="dt-copy-namespaces-mode" id="dt-copy-namespaces-mode"
title="copy-namespaces mode">Definition</a>: <b>Copy-namespaces
mode.</b> This component controls the namespace bindings that are
assigned when an existing element node is copied by an element
constructor, as described in <a href=
"#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>. Its value consists of two parts:
<code>preserve</code> or <code>no-preserve</code>, and
<code>inherit</code> or <code>no-inherit</code>.]</p>
</li>
<li>
<p>[<a name="dt-static-base-uri" id="dt-static-base-uri" title=
"Static Base URI">Definition</a>: <b>Static Base URI.</b> This is
an absolute URI, used to resolve <span class="xquery">relative URIs
both during static analysis and during dynamic evaluation.</span> ]
<span class="xquery">All expressions within a module have the same
static base URI. The Static Base URI can be set using a <a title=
"base URI declaration" href="#dt-base-uri-decl">base URI
declaration</a>.</span> The Static Base URI is available during
dynamic evaluation by use of the <code>fn:static-base-uri</code>
function, and is used implicitly during dynamic evaluation by
functions such as <code>fn:doc</code>. Relative URI references are
resolved as described in <a href=
"#id-resolve-relative-uri"><b>2.4.6 Resolving a Relative URI
Reference</b></a>.</p>
<p class="xquery">If the value of the Static Base URI is based on
the location of the query module (in the terminology of <a href=
"#RFC3986">[RFC3986]</a>, the URI used to retrieve the
encapsulating entity), then the implementation <strong>may</strong>
use different values for the Static Base URI during static analysis
and during dynamic evaluation. This might be necessary, for
example, if a query consisting of several modules is compiled, and
the resulting object code is distributed to a different location
for execution. It would then be inappropriate to use the same
location when resolving <code>import module</code> declarations as
when retrieving source documents using the <code>fn:doc</code>
function. If an implementation uses different values for the Static
Base URI during static analysis and during dynamic evaluation, then
it is implementation-defined which of the two values is used for
particular operations that rely on the Static Base URI; for
example, it is implementation-defined which value is used for
resolving collation URIs.</p>
</li>
<li>
<p>[<a name="dt-known-docs" id="dt-known-docs" title=
"statically known documents">Definition</a>: <b>Statically known
documents.</b> This is a mapping from strings to types. The string
represents the absolute URI of a resource that is potentially
available using the <code>fn:doc</code> function. The type is the
<a title="static type" href="#dt-static-type">static type</a> of a
call to <code>fn:doc</code> with the given URI as its literal
argument. ] If the argument to <code>fn:doc</code> is a string
literal that is not present in <b>statically known documents</b>,
then the <a title="static type" href="#dt-static-type">static
type</a> of <code>fn:doc</code> is
<code>document-node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known documents</b> is to
provide static type information, not to determine which documents
are available. A URI need not be found in the <b>statically known
documents</b> to be accessed using <code>fn:doc</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-collections" id="dt-known-collections" title=
"statically known collections">Definition</a>: <b>Statically known
collections.</b> This is a mapping from strings to types. The
string represents the absolute URI of a resource that is
potentially available using the <code>fn:collection</code>
function. The type is the type of the sequence of nodes that would
result from calling the <code>fn:collection</code> function with
this URI as its argument.] If the argument to
<code>fn:collection</code> is a string literal that is not present
in <b>statically known collections</b>, then the <a title=
"static type" href="#dt-static-type">static type</a> of
<code>fn:collection</code> is <code>node()*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known collections</b> is to
provide static type information, not to determine which collections
are available. A URI need not be found in the <b>statically known
collections</b> to be accessed using
<code>fn:collection</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-default-collection" id=
"dt-known-default-collection" title=
"statically known default collection type">Definition</a>:
<b>Statically known default collection type.</b> This is the type
of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.] Unless
initialized to some other value by an implementation, the value of
<b>statically known default collection type</b> is
<code>node()*</code>.</p>
</li>
<li>
<p>[<a name="dt-static-decimal-formats" id=
"dt-static-decimal-formats" title=
"statically known decimal formats">Definition</a>: <b>Statically
known decimal formats.</b> This is <span>a mapping from QName to
decimal format, with one default format that has no visible
name.</span> Each format is used for serializing decimal numbers
using <code>fn:format-number()</code>.]</p>
<p><span>Each decimal format contains three sets of properties,
which</span> control the interpretation of characters in the
picture string supplied to the <code>fn:format-number</code>
function, and also specify characters that may appear in the result
of formatting the number.</p>
<p>The following attributes specify characters used to format the
number per se:</p>
<ul>
<li>
<p>[<a name="id-static-decimal-separator" id=
"id-static-decimal-separator" title=
"decimal-separator">Definition</a>: <b>decimal-separator</b>
specifies the character used for the decimal-separator-symbol; the
default value is the period character (.)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-grouping-separator" id=
"id-static-decimal-format-grouping-separator" title=
"grouping-separator">Definition</a>: <b>grouping-separator</b>
specifies the character used for the grouping-separator-symbol,
which is typically used as a thousands separator; the default value
is the comma character (,)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-percent-sign" id=
"id-static-decimal-format-percent-sign" title=
"percent-sign">Definition</a>: <b>percent</b> specifies the
character used for the percent-symbol; the default value is the
percent character (%)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-per-mille-sign" id=
"id-static-decimal-format-per-mille-sign" title=
"per-mille-sign">Definition</a>: <b>per-mille</b> specifies the
character used for the per-mille-symbol; the default value is the
Unicode per-mille character (#x2030)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-zero-digit" id=
"id-static-decimal-format-zero-digit" title=
"zero-digit">Definition</a>: <b>zero-digit</b> specifies the
character used for the zero-digit-symbol; the default value is the
digit zero (0). This character must be a digit (category Nd in the
Unicode property database), and it must have the numeric value
zero. This attribute implicitly defines the Unicode character that
is used to represent each of the values 0 to 9 in the final result
string: Unicode is organized so that each set of decimal digits
forms a contiguous block of characters in numerical sequence.]</p>
</li>
</ul>
<p>The following attributes control the interpretation of
characters in the picture string supplied to the format-number
function. In each case the value must be a single character.</p>
<ul>
<li>
<p>[<a name="id-static-decimal-format-digit-sign" id=
"id-static-decimal-format-digit-sign" title=
"digit-sign">Definition</a>: <b>digit-sign</b> specifies the
character used for the digit-sign in the picture string; the
default value is the number sign character (#)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-pattern-separator-sign" id=
"id-static-decimal-format-pattern-separator-sign" title=
"pattern-separator-sign">Definition</a>: <b>pattern-separator</b>
specifies the character used for the pattern-separator-symbol,
which separates positive and negative sub-pictures in a picture
string; the default value is the semi-colon character (;)]</p>
</li>
</ul>
<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>
<ul>
<li>
<p>[<a name="id-static-decimal-format-infinity" id=
"id-static-decimal-format-infinity" title=
"infinity">Definition</a>: <b>infinity</b> specifies the string
used for the infinity-symbol; the default value is the string
"Infinity"]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-NaN" id=
"id-static-decimal-format-NaN" title="NaN">Definition</a>:
<b>NaN</b> specifies the string used for the NaN-symbol, which is
used to represent the value NaN (not-a-number); the default value
is the string "NaN"]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-minus-sign" id=
"id-static-decimal-format-minus-sign" title=
"minus-sign">Definition</a>: <b>minus-sign</b> specifies the
character used for the minus-sign-symbol; the default value is the
hyphen-minus character (-, #x2D). The value must be a single
character.]</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>2.1.2 Dynamic
Context</h4>
<p>[<a name="dt-dynamic-context" id="dt-dynamic-context" title=
"dynamic context">Definition</a>: The <b>dynamic context</b> of an
expression is defined as information that is available at the time
the expression is evaluated.] If evaluation of an expression relies
on some part of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> that <span>is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup></span>
, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
<p>The individual components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> are
<span>described</span> below. <span class="xquery">Rules governing
the initialization and alteration of these components can be found
in <a href="#id-xq-evaluation-context-components"><b>C.2 Dynamic
Context Components</b></a>.</span></p>
<p>The <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> consists of all the
components of the <a title="static context" href=
"#dt-static-context">static context</a>, and the additional
components listed below.</p>
<p>[<a name="dt-focus" id="dt-focus" title="focus">Definition</a>:
The first three components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (context item, context
position, and context size) are called the <b>focus</b> of the
expression. ] The focus enables the processor to keep track of
which items are being processed by the expression. <span>If any
component in the focus is defined, all components of the focus are
defined.</span> [<a name="dt-singleton-focus" id=
"dt-singleton-focus" title="singleton focus">Definition</a>: A
<b>singleton focus</b> is a focus that refers to a single item; in
a singleton focus, context item is set to the item, context
position = 1 and context size = 1.]</p>
<p>Certain language constructs, notably the <a title=
"path expression" href="#dt-path-expression">path operator</a>
<code>E1/E2</code>, <span>the <a title="path expression" href=
"#dt-path-expression">simple mapping operator</a>,</span> and the
<a title="" href="#dt-predicate">predicate</a> <code>E1[E2]</code>,
create a new focus for the evaluation of a sub-expression. In these
constructs, <code>E2</code> is evaluated once for each item in the
sequence that results from evaluating <code>E1</code>. Each time
<code>E2</code> is evaluated, it is evaluated with a different
focus. The focus for evaluating <code>E2</code> is referred to
below as the <b>inner focus</b>, while the focus for evaluating
<code>E1</code> is referred to as the <b>outer focus</b>. The inner
focus exists only while <code>E2</code> is being evaluated. When
this evaluation is complete, evaluation of the containing
expression continues with its original focus unchanged.</p>
<ul>
<li>
<p>[<a name="dt-context-item" id="dt-context-item" title=
"context item">Definition</a>: The <b>context item</b> is the
<a title="item" href="#dt-item">item</a> currently being
processed.] [<a name="dt-context-node" id="dt-context-node" title=
"context node">Definition</a>: When the context item is a node, it
can also be referred to as the <b>context node</b>.] The context
item is returned by an expression consisting of a single dot
(<code>.</code>). When an expression <code>E1/E2</code> or
<code>E1[E2]</code> is evaluated, each item in the sequence
obtained by evaluating <code>E1</code> becomes the context item in
the inner focus for an evaluation of <code>E2</code>.</p>
<p>[<a name="dt-initial-context-item" id="dt-initial-context-item"
title="initial context item">Definition</a>: The <b>initial context
item</b> is a context item that an implementation can set before
processing a query begins. The query body and the prolog of every
module in a query share the same initial context item.]</p>
</li>
<li>
<p>[<a name="dt-context-position" id="dt-context-position" title=
"context position">Definition</a>: The <b>context position</b> is
the position of the context item within the sequence of items
currently being processed.] It changes whenever the context item
changes. When the focus is defined, the value of the context
position is an integer greater than zero. The context position is
returned by the expression <code>fn:position()</code>. When an
expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated,
the context position in the inner focus for an evaluation of
<code>E2</code> is the position of the context item in the sequence
obtained by evaluating <code>E1</code>. The position of the first
item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p>
</li>
<li>
<p>[<a name="dt-context-size" id="dt-context-size" title=
"context size">Definition</a>: The <b>context size</b> is the
number of items in the sequence of items currently being
processed.] Its value is always an integer greater than zero. The
context size is returned by the expression <code>fn:last()</code>.
When an expression <code>E1/E2</code> or <code>E1[E2]</code> is
evaluated, the context size in the inner focus for an evaluation of
<code>E2</code> is the number of items in the sequence obtained by
evaluating <code>E1</code>.</p>
</li>
<li>
<p>[<a name="dt-variable-values" id="dt-variable-values" title=
"variable values">Definition</a>: <b>Variable values</b>. This is a
<span>mapping from <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> to value.</span> It
contains the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> as the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> for the expression. The
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> is the name of the variable and the value is the dynamic
value of the variable, which includes its <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>.]</p>
</li>
<li>
<p>[<a name="dt-named-functions" id="dt-named-functions" title=
"named functions">Definition</a>: <b>Named functions</b>. This is a
mapping from (expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>.
] It supplies a function for each signature in <a title=
"statically known function signatures" href=
"#dt-known-func-signatures">statically known function
signatures</a> and may supply other functions (see <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>). Named functions can include functions with
implementation-dependent implementations; these functions do not
have a static context or a dynamic context of their own.</p>
</li>
<li>
<p>[<a name="dt-date-time" id="dt-date-time" title=
"current dateTime">Definition</a>: <b>Current dateTime.</b> This
information represents an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xquery">a
query</span>, and includes an explicit timezone. It can be
retrieved by the <code>fn:current-dateTime</code> function. If
invoked multiple times during the execution of <span class=
"xquery">a query</span>, this function always returns the same
result.]</p>
</li>
<li>
<p>[<a name="dt-timezone" id="dt-timezone" title=
"implicit timezone">Definition</a>: <b>Implicit timezone.</b> This
is the timezone to be used when a date, time, or dateTime value
that does not have a timezone is used in a comparison or arithmetic
operation. The implicit timezone is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> for the range of valid values of a timezone.]</p>
</li>
<li>
<p>[<a name="dt-default-language" id="dt-default-language" title=
"default language">Definition</a>: <b>Default language.</b> This is
the natural language used when creating human-readable output (for
example, by the functions <code>fn:format-date</code> and
<code>fn:format-integer</code>) if no other language is requested.
The value is a language code as defined by the type
<code>xs:language</code>.]</p>
</li>
<li>
<p>[<a name="dt-default-calendar" id="dt-default-calendar" title=
"default calendar">Definition</a>: <b>Default calendar.</b> This is
the calendar used when formatting dates in human-readable output
(for example, by the functions <code>fn:format-date</code> and
<code>fn:format-dateTime</code>) if no other calendar is requested.
The value is a string.]</p>
</li>
<li>
<p>[<a name="dt-default-place" id="dt-default-place" title=
"default place">Definition</a>: <b>Default place.</b> This is a
geographical location used to identify the place where events
happened (or will happen) when formatting dates and times using
functions such as <code>fn:format-date</code> and
<code>fn:format-dateTime</code>, if no other place is specified. It
is used when translating timezone offsets to civil timezone names,
and when using calendars where the translation from ISO dates/times
to a local representation is dependent on geographical location.
Possible representations of this information are an ISO country
code or an Olson timezone name, but implementations are free to use
other representations from which the above information can be
derived.]</p>
</li>
<li>
<p>[<a name="dt-available-docs" id="dt-available-docs" title=
"available documents">Definition</a>: <b>Available documents.</b>
This is a mapping of strings to document nodes. Each string
represents the absolute URI of a resource. The document node is the
root of a tree that represents that resource using the <a title=
"data model" href="#dt-datamodel">data model</a>. The document node
is returned by the <code>fn:doc</code> function when applied to
that URI.] The set of available documents is not limited to the set
of <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, and it may be
empty.</p>
<p>If there are one or more URIs in <a title="available documents"
href="#dt-available-docs">available documents</a> that map to a
document node <code>D</code>, then the document-uri property of
<code>D</code> must either be absent, or must be one of these
URIs.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that given a document node <code>$N</code>, the
result of <code>fn:doc(fn:document-uri($N)) is $N</code> will
always be <code>true</code>, unless
<code>fn:document-uri($N)</code> is an empty sequence.</p>
</div>
</li>
<li>
<p>[<a name="dt-available-text-resources" id=
"dt-available-text-resources" title=
"available text resources">Definition</a>: <b>Available text
resources</b>. This is a mapping of strings to text resources. Each
string represents the absolute URI of a resource. The resource is
returned by the <code>fn:unparsed-text</code> function when applied
to that URI.] The set of available text resources is not limited to
the set of <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, and it may be
empty.</p>
</li>
<li>
<p>[<a name="dt-available-collections" id=
"dt-available-collections" title=
"available node collections">Definition</a>: <b>Available node
collections.</b> This is a mapping of strings to sequences of
nodes. Each string represents the absolute URI of a resource. The
sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument. ] The set of available node collections is not
limited to the set of <a title="statically known collections" href=
"#dt-known-collections">statically known collections</a>, and it
may be empty.</p>
<p>For every document node <code>D</code> that is in the target of
a mapping in <a title="available node collections" href=
"#dt-available-collections">available node collections</a>, or that
is the root of a tree containing such a node, the document-uri
property of <code>D</code> must either be absent, or must be a URI
<code>U</code> such that <a title="available documents" href=
"#dt-available-docs">available documents</a> contains a mapping
from <code>U</code> to <code>D</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that for any document node <code>$N</code> retrieved
using the <code>fn:collection</code> function, either directly or
by navigating to the root of a node that was returned, the result
of <code>fn:doc(fn:document-uri($N)) is $N</code> will always be
<code>true</code>, unless <code>fn:document-uri($N)</code> is an
empty sequence. This implies a requirement for the
<code>fn:doc</code> and <code>fn:collection</code> functions to be
consistent in their effect. If the implementation uses catalogs or
user-supplied URI resolvers to dereference URIs supplied to the
<code>fn:doc</code> function, the implementation of the
<code>fn:collection</code> function must take these mechanisms into
account. For example, an implementation might achieve this by
mapping the collection URI to a set of document URIs, which are
then resolved using the same catalog or URI resolver that is used
by the <code>fn:doc</code> function.</p>
</div>
</li>
<li>
<p>[<a name="dt-default-collection" id="dt-default-collection"
title="default node collection">Definition</a>: <b>Default node
collection.</b> This is the sequence of nodes that would result
from calling the <code>fn:collection</code> function with no
arguments.] The value of <b>default collection</b> may be
initialized by the implementation.</p>
</li>
<li>
<p>[<a name="dt-available-resource-collections" id=
"dt-available-resource-collections" title=
"available resource collections">Definition</a>: <b>Available
resource collections.</b> This is a mapping of strings to sequences
of URIs. The string represents the absolute URI of a resource which
can be interpreted as an aggregation of a number of individual
resources each of which has its own URI. The sequence of URIs
represents the result of the <code>fn:uri-collection</code>
function when that URI is supplied as the argument. ] There is no
implication that the URIs in this sequence can be successfully
dereferenced, or that the resources they refer to have any
particular media type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation <strong>may</strong> maintain some consistent
relationship between the available node collections and the
available resource collections, for example by ensuring that the
result of <code>fn:uri-collection(X)!fn:doc(.)</code> is the same
as the result of <code>fn:collection(X)</code>. However, this is
not required. The <code>fn:uri-collection</code> function is more
general than <code>fn:collection</code> in that it allows access to
resources other than XML documents; at the same time,
<code>fn:collection</code> allows access to nodes that might lack
individual URIs, for example nodes corresponding to XML fragments
stored in the rows of a relational database.</p>
</div>
</li>
<li>
<p>[<a name="dt-default-resource-collection" id=
"dt-default-resource-collection" title=
"default resource collection">Definition</a>: <b>Default resource
collection.</b> This is the sequence of URIs that would result from
calling the <code>fn:uri-collection</code> function with no
arguments.] The value of <b>default resource collection</b> may be
initialized by the implementation.</p>
</li>
<li>
<p>[<a name="dt-environment-variables" id=
"dt-environment-variables" title=
"environment variables">Definition</a>: <b>Environment
variables.</b> This is a <span>mapping from names to values.</span>
Both the names and the values are strings. The names are compared
using an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collation,
and are unique under this collation. The set of environment
variables is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> and
<strong>may</strong> be empty.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A possible implementation is to provide the set of POSIX
environment variables (or their equivalent on other operating
systems) appropriate to the process in which the <span class=
"xquery">query is initiated</span>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>2.2
Processing Model</h3>
<p>XQuery 3.0 is defined in terms of the <a title="data model"
href="#dt-datamodel">data model</a> and the <a title=
"expression context" href="#dt-expression-context">expression
context</a>.</p>
<img src="ProcMod-XQuery.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>Figure 1 provides a schematic overview of the processing steps
that are discussed in detail below. Some of these steps are
completely outside the domain of XQuery 3.0; in Figure 1, these are
depicted outside the line that represents the boundaries of the
language, an area labeled <b>external processing</b>. The external
processing domain includes generation of an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a> that represents the
data to be queried (see <a href=
"#id-data-model-generation"><b>2.2.1 Data Model
Generation</b></a>), schema import processing (see <a href=
"#id-schema-import-processing"><b>2.2.2 Schema Import
Processing</b></a>) and serialization <span class="xquery">(see
<a href="#id-serialization"><b>2.2.4 Serialization</b></a>)</span>.
The area inside the boundaries of the language is known as the
<span class="xquery"><b>query processing domain</b></span> , which
includes the static analysis and dynamic evaluation phases (see
<a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>). Consistency constraints on the <span class=
"xquery">query</span> processing domain are defined in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>.</p>
<div class="div3">
<h4><a name="id-data-model-generation" id=
"id-data-model-generation"></a>2.2.1 Data Model Generation</h4>
<p>Before <span class="xquery">a query</span> can be processed, its
input data must be represented as an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>. This process occurs
outside the domain of XQuery 3.0, which is why Figure 1 represents
it in the external processing domain. Here are some steps by which
an XML document might be converted to an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a>:</p>
<ol class="enumar">
<li>
<p>A document may be parsed using an XML parser that generates an
<b>XML Information Set</b> (see <a href="#XINFO">[XML
Infoset]</a>). The parsed document may then be validated against
one or more schemas. This process, which is described in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>, results in an abstract information structure
called the <b>Post-Schema Validation Infoset</b> (PSVI). If a
document has no associated schema, its Information Set is
preserved. (See DM1 in Fig. 1.)</p>
</li>
<li>
<p>The Information Set or PSVI may be transformed into an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> by a
process described in <a href="#xpath-datamodel-30">[XQuery and
XPath Data Model (XDM) 3.0]</a>. (See DM2 in Fig. 1.)</p>
</li>
</ol>
<p>The above steps provide an example of how an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>
might be constructed. An XDM instance might also be synthesized
directly from a relational database, or constructed in some other
way (see DM3 in Fig. 1.) XQuery 3.0 is defined in terms of the
<a title="data model" href="#dt-datamodel">data model</a>, but it
does not place any constraints on how XDM instances are
constructed.</p>
<p>[<a name="dt-type-annotation" id="dt-type-annotation" title=
"type annotation">Definition</a>: Each element node and attribute
node in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> has a <b>type
annotation</b> ( <span>described</span> in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>.
) The type annotation of a node is a <span>reference to an XML
Schema type.</span> ] <span>The <code>type-name</code> of a node is
the name of the type referenced by its <a title="type annotation"
href="#dt-type-annotation">type annotation</a>.</span> If the
<a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a> was derived from a validated XML document as described
in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#const-psvi">Section 3.3
Construction from a PSVI</a> <sup><small>DM30</small></sup>, the
type annotations of the element and attribute nodes are derived
from schema validation. XQuery 3.0 does not provide a way to
directly access the type annotation of an element or attribute
node.</p>
<p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as
might occur in a schemaless document) is given the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>.</p>
<p>The value of an element is represented by the children of the
element node, which may include text nodes and other element nodes.
The <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node indicates how the values in its
child text nodes are to be interpreted. An element that has not
been validated (such as might occur in a schemaless document) is
annotated with the schema type <code>xs:untyped</code>. An element
that has been validated and found to be partially valid is
annotated with the schema type <code>xs:anyType</code>. If an
element node is annotated as <code>xs:untyped</code>, all its
descendant element nodes are also annotated as
<code>xs:untyped</code>. However, if an element node is annotated
as <code>xs:anyType</code>, some of its descendant element nodes
may have a more specific <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</div>
<div class="div3">
<h4><a name="id-schema-import-processing" id=
"id-schema-import-processing"></a>2.2.2 Schema Import
Processing</h4>
<p class="xquery">The <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> in the <a title=
"static context" href="#dt-static-context">static context</a> may
be extracted from actual XML schemas (see step SI1 in Figure 1) or
may be generated by some other mechanism (see step SI2 in Figure
1). In either case, the result must satisfy the consistency
constraints defined in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-expression-processing" id=
"id-expression-processing"></a>2.2.3 Expression Processing</h4>
<p>XQuery 3.0 defines two phases of processing called the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> and the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1).
During the static analysis phase, <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
During the dynamic evaluation phase, only <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a> or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
These kinds of errors are defined in <a href=
"#id-kinds-of-errors"><b>2.3.1 Kinds of Errors</b></a>.</p>
<p>Within each phase, an implementation is free to use any strategy
or algorithm whose result conforms to the specifications in this
document.</p>
<div class="div4">
<h5><a name="id-static-analysis" id=
"id-static-analysis"></a>2.2.3.1 Static Analysis Phase</h5>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: The <b>static analysis
phase</b> depends on the expression itself and on the <a title=
"static context" href="#dt-static-context">static context</a>. The
<b>static analysis phase</b> does not depend on input data (other
than schemas).]</p>
<p>During the static analysis phase, the <span class=
"xquery">query</span> is parsed into an internal representation
called the <b>operation tree</b> (step SQ1 in Figure 1). A parse
error is raised as a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>]. The <a title="static context"
href="#dt-static-context">static context</a> is initialized by the
implementation (step SQ2). <span class="xquery">The <a title=
"static context" href="#dt-static-context">static context</a> is
then changed and augmented based on information in the
<b>prolog</b> (step SQ3). If the <a title="schema aware feature"
href="#dt-schema-aware-feature">Schema Aware Feature</a> is
supported, the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> are populated with
information from imported schemas. If the <a title="module feature"
href="#dt-module-feature">Module Feature</a> is supported, the
static context is extended with function declarations and variable
declarations from imported modules.</span> The <a title=
"static context" href="#dt-static-context">static context</a> is
used to resolve schema type names, function names, namespace
prefixes, and variable names (step SQ4). If a name of one of these
kinds in the <b>operation tree</b> is not found in the <a title=
"static context" href="#dt-static-context">static context</a>, a
<a title="static error" href="#dt-static-error">static error</a>
([<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] or
[<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]) is
raised (however, see exceptions to this rule in <a href=
"#id-element-test"><b>2.5.5.3 Element Test</b></a> and <a href=
"#id-attribute-test"><b>2.5.5.5 Attribute Test</b></a>.)</p>
<p>The <b>operation tree</b> is then <b>normalized</b> by making
explicit the implicit operations such as <a title="atomization"
href="#dt-atomization">atomization</a> and extraction of <a title=
"effective boolean value" href="#dt-ebv">Effective Boolean
Values</a> (step SQ5).</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, a processor may
perform type analysis. The effect of type analysis is to assign a
<a title="static type" href="#dt-static-type">static type</a> to
each expression in the operation tree. [<a name="dt-static-type"
id="dt-static-type" title="static type">Definition</a>: The
<b>static type</b> of an expression is the best inference that the
processor is able to make statically about the type of the result
of the expression.] This specification does not define the rules
for type analysis nor the static types that are assigned to
particular expressions: the only constraint is that the inferred
type must match all possible values that the expression is capable
of returning.</p>
<p>Examples of inferred static types might be:</p>
<ul>
<li>
<p>For the expression <code>concat(a,b)</code> the inferred static
type is <code>xs:string</code></p>
</li>
<li>
<p>For the expression <code>$a = $v</code> the inferred static type
is <code>xs:boolean</code></p>
</li>
<li>
<p>For the expression <code>$s[exp]</code> the inferred static type
has the same item type as the static type of <code>$s</code>, but a
cardinality that allows the empty sequence even if the static type
of <code>$s</code> does not allow an empty sequence.</p>
</li>
<li>
<p>The inferred static type of the expression <code>data($x)</code>
(whether written explicitly or inserted into the operation tree in
places where atomization is implicit) depends on the inferred
static type of <code>$x</code>: for example, if <code>$x</code> has
type <code>element(*, xs:integer)</code> then <code>data($x)</code>
has static type <code>xs:integer</code>.</p>
</li>
</ul>
<p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing
were published normatively in <a href="#xquery-semantics">[XQuery
1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were
allowed to refine these rules to infer a more precise type where
possible. In XQuery 3.0 and XPath 3.0, the rules for static type
inferencing are entirely implementation-defined.</p>
<p>Every kind of expression also imposes requirements on the type
of its operands. For example, with the expression
<code>substring($a, $b, $c)</code>, <code>$a</code> must be of type
<code>xs:string</code> (or something that can be converted to
<code>xs:string</code> by the function calling rules), while
<code>$b</code> and <code>$c</code> must be of type
<code>xs:double</code>.</p>
<p>If the Static Typing Feature is in effect, a processor must
raise a type error during static analysis if the inferred static
type of an expression is not subsumed by the required type of the
context where the expression is used. For example, the call of
substring above would cause a type error if the inferred static
type of <code>$a</code> is <code>xs:integer</code>; equally, a type
error would be reported during static analysis if the inferred
static type is <code>xs:anyAtomicType</code>.</p>
<p>If the Static Typing Feature is not in effect, a processor may
raise a type error during static analysis only if the inferred
static type of an expression has no overlap (intersection) with the
required type: so for the first argument of substring, the
processor may raise an error if the inferred type is
<code>xs:integer</code>, but not if it is
<code>xs:anyAtomicType</code>. Alternatively, if the Static Typing
Feature is not in effect, the processor may defer all type checking
until the dynamic evaluation phase.</p>
</div>
<div class="div4">
<h5><a name="id-dynamic-evaluation" id=
"id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase</h5>
<p>[<a name="dt-dynamic-evaluation" id="dt-dynamic-evaluation"
title="dynamic evaluation phase">Definition</a>: The <b>dynamic
evaluation phase</b> is the phase during which the value of an
expression is computed.] It occurs after completion of the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>.</p>
<p>The dynamic evaluation phase can occur only if no errors were
detected during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. If the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a> is in effect, all <a title="type error" href=
"#dt-type-error">type errors</a> are detected during static
analysis and serve to inhibit the dynamic evaluation phase.</p>
<p>The dynamic evaluation phase depends on the <b>operation
tree</b> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn
draws information from the external environment (step DQ3) and the
<a title="static context" href="#dt-static-context">static
context</a> (step DQ2). The dynamic evaluation phase may create new
data-model values (step DQ4) and it may extend the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
(step DQ5)—for example, by binding values to variables.</p>
<p>[<a name="dt-dynamic-type" id="dt-dynamic-type" title=
"dynamic type">Definition</a>: A <b>dynamic type</b> is associated
with each value as it is computed. The dynamic type of a value may
be more specific than the <a title="static type" href=
"#dt-static-type">static type</a> of the expression that computed
it (for example, the static type of an expression might be
<code>xs:integer*</code>, denoting a sequence of zero or more
integers, but at evaluation time its value may have the dynamic
type <code>xs:integer</code>, denoting exactly one integer.)]</p>
<p>If an operand of an expression is found to have a <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not
appropriate for that operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Even though static typing can catch many <a title="type error"
href="#dt-type-error">type errors</a> before an expression is
executed, it is possible for an expression to raise an error during
evaluation that was not detected by static analysis. For example,
an expression may contain a cast of a string into an integer, which
is statically valid. However, if the actual value of the string at
run time cannot be cast into an integer, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> will result. Similarly,
an expression may apply an arithmetic operator to a value whose
<a title="static type" href="#dt-static-type">static type</a> is
<code>xs:untypedAtomic</code>. This is not a <a title=
"static error" href="#dt-static-error">static error</a>, but at run
time, if the value cannot be successfully cast to a <a title=
"numeric" href="#dt-numeric">numeric</a> type, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> will be
raised.</p>
<p>When the <a title="static typing feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is in effect,
it is also possible for static analysis of an expression to raise a
<a title="type error" href="#dt-type-error">type error</a>, even
though execution of the expression on certain inputs would be
successful. For example, an expression might contain a function
that requires an element as its parameter, and the static analysis
phase might infer the <a title="static type" href=
"#dt-static-type">static type</a> of the function parameter to be
an optional element. This case is treated as a <a title=
"type error" href="#dt-type-error">type error</a> and inhibits
evaluation, even though the function call would have been
successful for input data in which the optional element is
present.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization" id="id-serialization"></a>2.2.4
Serialization</h4>
<p>[<a name="dt-serialization" id="dt-serialization" title=
"serialization">Definition</a>: <b>Serialization</b> is the process
of converting an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> to a sequence of octets
(step DM4 in Figure 1.)<span>, as described in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery Serialization
3.0]</a>.</span> ]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This definition of serialization is the definition used in this
specification. Any form of serialization that is not based on
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization 3.0]</a> is outside the scope of the XQuery 3.0
specification.</p>
</div>
<p class="xquery">An XQuery implementation is not required to
provide a serialization interface. For example, an implementation
may provide only a DOM interface (see <a href="#DOM">[Document
Object Model]</a>) or an interface based on an event stream.</p>
<p class="xquery"><a href="#xslt-xquery-serialization-30">[XSLT and
XQuery Serialization 3.0]</a> defines a set of <b>serialization
parameters</b> that govern the serialization process. If an XQuery
implementation provides a serialization interface, it may support
(and may expose to users) any of the serialization parameters
listed (with default values) in <a href=
"#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a>. <span>If an implementation does not support one
of these parameters, it must ignore it without raising an
error.</span></p>
<p class="xquery">[<a name="dt-output-declaration" id=
"dt-output-declaration" title="output declaration">Definition</a>:
An <b>output declaration</b> is an option declaration in the
namespace "http://www.w3.org/2010/xslt-xquery-serialization"; it is
used to declare serialization parameters.] <span>Except for
<code>parameter-document</code>, each option corresponds to a
serialization parameter element defined in <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-schema">
Section B Schema for Serialization Parameters</a>
<sup><small>SER30</small></sup>. The name of each option is the
same as the name of the corresponding serialization parameter
element, and the values permitted for each option are the same as
the values allowed in the serialization parameter element. There is
no output declaration for <code>use-character-maps</code>, it can
be set only by means of a parameter document.</span> When the
application requests serialization of the output, the processor may
use these parameters to control the way in which the serialization
takes place. Processors may also allow external mechanisms for
specifying serialization parameters, which may or may not override
serialization parameters specified in the query prolog.</p>
<p><span>The following example illustrates the use of declaration
options.</span></p>
<div class="exampleOuter">
<div class="exampleInner">
<pre>
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method   "xml";
declare option output:encoding "iso-8859-1";
declare option output:indent   "yes";
declare option output:parameter-document "file:///home/me/serialization-parameters.xml";
</pre></div>
</div>
<p class="xquery">An <b>output declaration</b> may appear only in a
main module; it is a static error [<a href="#ERRXQST0108" title=
"err:XQST0108">err:XQST0108</a>] if an output declaration appears
in a <a title="library module" href="#dt-library-module">library
module</a>. It is a static error [<a href="#ERRXQST0110" title=
"err:XQST0110">err:XQST0110</a>] if the same serialization
parameter is declared more than once. It is a <a title=
"static error" href="#dt-static-error">static error</a> [<a href=
"#ERRXQST0109" title="err:XQST0109">err:XQST0109</a>] if the local
name of an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code>
namespace is not one of the serialization parameter names listed in
<a href="#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a> or <code>parameter-document</code>, <span>or if
the name of an output declaration is
<code>use-character-maps</code></span> . The default value for the
<code>method</code> parameter is <code>"xml"</code>. An
implementation may define additional <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>
serialization parameters in its own namespaces.</p>
<p class="xquery">If the local name of an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code>
namespace is <code>parameter-document</code>, the value of the
output declaration is treated as a URI literal. The value is a
location hint, and identifies an XDM instance in an
implementation-defined way. If a processor is performing
serialization, it is a static error [<a href="#ERRXQST0119" title=
"err:XQST0119">err:XQST0119</a>] if the implementation is not able
to process the value of the <code>output:parameter-document</code>
declaration to produce an XDM instance.</p>
<p class="xquery">If a processor is performing serialization, the
XDM instance identified by an
<code>output:parameter-document</code> output declaration specifies
the values of serialization parameters in the manner defined by
<a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">
Section 3.1 Setting Serialization Parameters by Means of a Data
Model Instance</a> <sup><small>SER30</small></sup>. It is a static
error [<a href="#ERRXQST0115" title=
"err:XQST0115">err:XQST0115</a>] if this yields a serialization
error. The value of any other output declaration overrides any
value that might have been specified for the same serialization
parameter using an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code>
namespace with the local name parameter-document declaration.</p>
<p class="xquery">A serialization parameter that is not applicable
to the chosen output method must be ignored, except that if its
value is not a valid value for that parameter, an error may be
raised.</p>
<p class="xquery">A processor that is performing serialization must
raise a serialization error if the values of any serialization
parameters <span>that it supports</span> (other than any that are
ignored under the previous paragraph) are incorrect.</p>
<p class="xquery">A processor that is not performing serialization
may report errors if any serialization parameters are incorrect, or
may ignore such parameters.</p>
<p class="xquery">Specifying serialization parameters in a query
does not by itself demand that the output be serialized. It merely
defines the desired form of the serialized output for use in
situations where the processor has been asked to perform
serialization.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a title="data model" href="#dt-datamodel">data model</a>
permits an element node to have fewer <a title=
"in-scope namespaces" href="#dt-in-scope-namespaces">in-scope
namespaces</a> than its parent. Correct serialization of such an
element node would require "undeclaration" of namespaces, which is
a feature of <a href="#XMLNAMES11">[XML Names 1.1]</a>. An
implementation that does not support <a href="#XMLNAMES11">[XML
Names 1.1]</a> is permitted to serialize such an element without
"undeclaration" of namespaces, which effectively causes the element
to inherit the in-scope namespaces of its parent.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-consistency-constraints" id=
"id-consistency-constraints"></a>2.2.5 Consistency Constraints</h4>
<p>In order for XQuery 3.0 to be well defined, the input <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>, the
<a title="static context" href="#dt-static-context">static
context</a>, and the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> must be mutually
consistent. The consistency constraints listed below are
prerequisites for correct functioning of an XQuery 3.0
implementation. Enforcement of these consistency constraints is
beyond the scope of this specification. This specification does not
define the result of <span class="xquery">a query</span> under any
condition in which one or more of these constraints is not
satisfied.</p>
<ul>
<li>
<p>For every node that has a type annotation, if that type
annotation is found in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a> (ISSD), then its
definition in the ISSD must be equivalent to its definition in the
<span>type annotation</span> .</p>
</li>
<li>
<p>Every element name, attribute name, or schema type name
referenced in <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> or <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> must be in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, unless it is an element name referenced as part of
an <a href="#doc-xquery30-ElementTest">ElementTest</a> or an
attribute name referenced as part of an <a href=
"#doc-xquery30-AttributeTest">AttributeTest</a>.</p>
</li>
<li>
<p>Any reference to a global element, attribute, or type name in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> must have a corresponding element, attribute
or type definition in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a>.</p>
</li>
<li>
<p>For each mapping of a string to a document node in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, if there exists a mapping of the same string to a
document type in <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, the document node
must match the document type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>For each mapping of a string to a sequence of nodes in <a title=
"available node collections" href=
"#dt-available-collections">available node collections</a>, if
there exists a mapping of the same string to a type in <a title=
"statically known collections" href=
"#dt-known-collections">statically known collections</a>, the
sequence of nodes must match the type, using the matching rules in
<a href="#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The sequence of nodes in the <a title="default node collection"
href="#dt-default-collection">default collection</a> must match the
<a title="statically known default collection type" href=
"#dt-known-default-collection">statically known default collection
type</a>, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The value of the <a title="context item" href=
"#dt-context-item">context item</a> must match the <a title=
"context item static type" href=
"#dt-context-item-static-type">context item static type</a>, using
the matching rules in <a href="#id-sequencetype-matching"><b>2.5.5
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each (variable, type) pair in <a title="in-scope variables"
href="#dt-in-scope-variables">in-scope variables</a> and the
corresponding (variable, value) pair in <a title="variable values"
href="#dt-variable-values">variable values</a> such that the
variable names are equal, the value must match the type, using the
matching rules in <a href="#id-sequencetype-matching"><b>2.5.5
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each variable declared as external, if the variable
declaration does not include a <a href=
"#doc-xquery30-VarDefaultValue">VarDefaultValue</a>, the external
environment must provide a value for the variable.</p>
<p>For each variable declared as external for which the external
environment provides a value: If the variable declaration includes
a declared type, the value provided by the external environment
must match the declared type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
If the variable declaration does not include a declared type, the
external environment must provide a type to accompany the value
provided, using the same matching rules.</p>
</li>
<li>
<p>For each function declared as external: the
<span>function's</span> <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">implementation</a><sup><small>DM30</small></sup>
must either return a value that matches the declared result type,
using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>,
or raise an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> error.</p>
</li>
<li>
<p>For a given query, define a <b>participating ISSD</b> as the
<a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> of a module that is used in evaluating the
query. If two participating ISSDs contain a definition for the same
schema type, element name, or attribute name, the definitions must
be equivalent in both ISSDs. <span>In this context, equivalence
means that validating an instance against type <em>T</em> in one
ISSD will always have the same effect as validating the same
instance against type <em>T</em> in the other ISSD (that is, it
will produce the same PSVI, insofar as the PSVI is used during
subsequent processing). This means, for example, that the
membership of the substitution group of an element declaration in
one ISSD must be the same as that of the corresponding element
declaration in the other ISSD; that the set of types derived by
extension from a given type must be the same; and that in the
presence of a strict or lax wildcard, the set of global element (or
attribute) declarations capable of matching the wildcard must be
the same.</span></p>
</li>
<li>
<p>In the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, the prefix
<code>xml</code> must not be bound to any namespace URI other than
<code>http://www.w3.org/XML/1998/namespace</code>, and no prefix
other than <code>xml</code> may be bound to this namespace URI. The
prefix <code>xmlns</code> must not be bound to any namespace URI,
and no prefix may be bound to the namespace URI
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>For each <code>(expanded QName, arity) -&gt; FunctionTest</code>
entry in <a title="statically known function signatures" href=
"#dt-known-func-signatures">statically known function
signatures</a>, there must exist an <code>(expanded QName, arity)
-&gt; function</code> entry in <a title="named functions" href=
"#dt-named-functions">named functions</a> such that the function's
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-signature">signature</a><sup><small>DM30</small></sup>
is <code>FunctionTest</code>.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.3 Error Handling</h3>
<div class="div3">
<h4><a name="id-kinds-of-errors" id="id-kinds-of-errors"></a>2.3.1
Kinds of Errors</h4>
<p>As described in <a href="#id-expression-processing"><b>2.2.3
Expression Processing</b></a>, XQuery 3.0 defines a <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>, which does not depend on input data, and a <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, which does depend on input data. Errors may
be raised during each phase.</p>
<p>[<a name="dt-static-error" id="dt-static-error" title=
"static error">Definition</a>: An error that <span>can</span> be
detected during the static analysis phase<span>, and is not a type
error,</span> is a <b>static error</b>.] A syntax error is an
example of a <a title="static error" href="#dt-static-error">static
error</a>.</p>
<p>[<a name="dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error">Definition</a>: A <b>dynamic error</b> is an error
that must be detected during the dynamic evaluation phase and may
be detected during the static analysis phase. Numeric overflow is
an example of a dynamic error. ]</p>
<p>[<a name="dt-type-error" id="dt-type-error" title=
"type error">Definition</a>: A <b>type error</b> may be raised
during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"static type" href="#dt-static-type">static type</a> of an
expression does not match the expected type of the context in which
the expression occurs. During the dynamic evaluation phase, a
<a title="type error" href="#dt-type-error">type error</a> occurs
when the <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> of a value does not match the expected type of the context
in which the value occurs.]</p>
<p>The outcome of the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a> is either success
or one or more <a title="type error" href="#dt-type-error">type
errors</a>, <a title="static error" href="#dt-static-error">static
errors</a>, or statically-detected <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a>. The result of the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a> is either a result value, a <a title=
"type error" href="#dt-type-error">type error</a>, or a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>If more than one error is present, or if an error condition
comes within the scope of more than one error defined in this
specification, then any non-empty subset of these errors may be
reported.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a> is in effect and the <a title="static type"
href="#dt-static-type">static type</a> assigned to an expression
other than <code>()</code> or <code>data(())</code> is
<code>empty-sequence()</code>, a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0005" title="err:XPST0005">err:XPST0005</a>]. This catches
cases in which a query refers to an element or attribute that is
not present in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>, possibly because of a
spelling error.</p>
<p>Independently of whether the <a title="static typing feature"
href="#dt-static-typing-feature">Static Typing Feature</a> is in
effect, if an implementation can determine during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> that <span class="xquery">a <a href=
"#doc-xquery30-QueryBody">QueryBody</a></span> , if evaluated,
would necessarily raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> or that an expression, if
evaluated, would necessarily raise a <a title="type error" href=
"#dt-type-error">type error</a>, the implementation may (but is not
required to) report that error during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>.</p>
<p>An implementation can raise a dynamic error for a <span class=
"xquery"><a href="#doc-xquery30-QueryBody">QueryBody</a></span>
statically only if the query can never execute without raising that
error, as in the following example:</p>
<div class="exampleInner">
<pre>
error()
</pre></div>
<p>The following example contains a type error, which can be
reported statically even if the implementation can not prove that
the expression will actually be evaluated.</p>
<div class="exampleInner">
<pre>
if (empty($arg))
then
  "cat" * 2
else
  0
</pre></div>
<p>[<a name="dt-warning" id="dt-warning" title=
"warning">Definition</a>: In addition to <a title="static error"
href="#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XQuery 3.0
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.]</p>
<p>In addition to the errors defined in this specification, an
implementation may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> for a reason beyond the scope
of this specification. For example, limitations may exist on the
maximum numbers or sizes of various objects. <span>An error must be
raised if such a limitation is exceeded [<a href="#ERRXPDY0130"
title="err:XPDY0130">err:XPDY0130</a>].</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Any limits on primitives defined by the XML and XSD
specifications that differ from what these specifications state are
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, and must
be documented. See <a href="#id-data-model-conformance"><b>5.3 Data
Model Conformance</b></a>. [<a href="#ERRXPDY0130" title=
"err:XPDY0130">err:XPDY0130</a>] should not be raised for
these.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-identifying-errors" id=
"id-identifying-errors"></a>2.3.2 Identifying and Reporting
Errors</h4>
<p>The errors defined in this specification are identified by
QNames that have the form <code>err:XXYYnnnn</code>, where:</p>
<ul>
<li>
<p><code>err</code> denotes the namespace for XPath and XQuery
errors, <code>http://www.w3.org/2005/xqt-errors</code>. This
binding of the namespace prefix <code>err</code> is used for
convenience in this document, and is not normative.</p>
</li>
<li>
<p><code>XX</code> denotes the language in which the error is
defined, using the following encoding:</p>
<ul>
<li>
<p><code>XP</code> denotes an error defined by XPath. Such an error
may also occur XQuery since XQuery includes XPath as a subset.</p>
</li>
<li>
<p><code>XQ</code> denotes an error defined by XQuery (or an error
originally defined by XQuery and later added to XPath).</p>
</li>
</ul>
</li>
<li>
<p><code>YY</code> denotes the error category, using the following
encoding:</p>
<ul>
<li>
<p><code>ST</code> denotes a static error.</p>
</li>
<li>
<p><code>DY</code> denotes a dynamic error.</p>
</li>
<li>
<p><code>TY</code> denotes a type error.</p>
</li>
</ul>
</li>
<li>
<p><code>nnnn</code> is a unique numeric code.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The namespace URI for XPath and XQuery errors is not expected to
change from one version of <span class="xquery">XQuery</span> to
another. However, the contents of this namespace may be extended to
include additional error definitions.</p>
</div>
<p>The method by which an XQuery 3.0 processor reports error
information to the external environment is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>An error can be represented by a URI reference that is derived
from the error QName as follows: an error with namespace URI
<em><code>NS</code></em> and local part <em><code>LP</code></em>
can be represented as the URI reference <em><code>NS</code></em>
<code>#</code> <em><code>LP</code></em> . For example, an error
whose QName is <code>err:XPST0017</code> could be represented as
<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Along with a code identifying an error, implementations may wish
to return additional information, such as the location of the error
or the processing phase in which it was detected. If an
implementation chooses to do so, then the mechanism that it uses to
return this information is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-handling-dynamic" id=
"id-handling-dynamic"></a>2.3.3 Handling Dynamic Errors</h4>
<p>Except as noted in this document, if any operand of an
expression raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>, the expression also raises a
<a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>. If an expression can return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error <span>(see <a href="#id-errors-and-opt"><b>2.3.4
Errors and Optimization</b></a>)</span>. For example, the logical
expression <code>expr1 and expr2</code> may return the value
<code>false</code> if either operand returns <code>false</code>, or
may raise a dynamic error if either operand raises a dynamic
error.</p>
<p>If more than one operand of an expression raises an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:</p>
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
<p>both the sub-expressions <code>($x div $y)</code> and
<code>xs:decimal($z)</code> may raise an error. The implementation
may choose which error is raised by the "<code>+</code>"
expression. Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>
<p>[<a name="dt-error-value" id="dt-error-value" title=
"error value">Definition</a>: In addition to its identifying QName,
a dynamic error may also carry a descriptive string and one or more
additional values called <b>error values</b>.] An implementation
may provide a mechanism whereby an application-defined error
handler can process error values and produce diagnostic
messages<span>. XQuery 3.0 provides standard error handling via
<a href="http://www.w3.org/TR/xquery-30/#id-try-catch">Section 3.15
Try/Catch Expressions</a> <sup><small>XQ30</small></sup></span>
.</p>
<p>A dynamic error may be raised by a <a title="built-in function"
href="#dt-built-in-function">built-in function</a> or operator. For
example, the <code>div</code> operator raises an error if its
operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators
are defined in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>.</p>
<p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which <span>always</span> raises
<span>a dynamic</span> error and never returns a value. This
function is defined in <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>. For example, the following
function call raises a dynamic error, providing a QName that
identifies the error, a descriptive string, and a diagnostic value
(assuming that the prefix <code>app</code> is bound to a namespace
containing application-defined error codes):</p>
<div class="exampleInner">
<pre>
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</pre></div>
</div>
<div class="div3">
<h4><a name="id-errors-and-opt" id="id-errors-and-opt"></a>2.3.4
Errors and Optimization</h4>
<p>Because different implementations may choose to evaluate or
optimize an expression in different ways, certain aspects of
raising <a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a> are <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>, as
described in this section.</p>
<p>An implementation is always free to evaluate the operands of an
operator in any order.</p>
<p>In some cases, a processor can determine the result of an
expression without accessing all the data that would be implied by
the formal expression semantics. For example, the formal
description of <a title="filter expression" href=
"#dt-filter-expression">filter expressions</a> suggests that
<code>$s[1]</code> should be evaluated by examining all the items
in sequence <code>$s</code>, and selecting all those that satisfy
the predicate <code>position()=1</code>. In practice, many
implementations will recognize that they can evaluate this
expression by taking the first item in the sequence and then
exiting. If <code>$s</code> is defined by an expression such as
<code>//book[author eq 'Berners-Lee']</code>, then this strategy
may avoid a complete scan of a large document and may therefore
greatly improve performance. However, a consequence of this
strategy is that a dynamic error or type error that would be
detected if the expression semantics were followed literally might
not be detected at all if the evaluation exits early. In this
example, such an error might occur if there is a <code>book</code>
element in the input data with more than one <code>author</code>
subelement.</p>
<p>The extent to which a processor may optimize its access to data,
at the cost of not raising errors, is defined by the following
rules.</p>
<p>Consider an expression <em>Q</em> that has an operand
(sub-expression) <em>E</em>. In general the value of <em>E</em> is
a sequence. At an intermediate stage during evaluation of the
sequence, some of its items will be known and others will be
unknown. If, at such an intermediate stage of evaluation, a
processor is able to establish that there are only two possible
outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or
an error, then the processor may deliver the result <em>V</em>
without evaluating further items in the operand <em>E</em>. For
this purpose, two values are considered to represent the same
outcome if their items are pairwise the same, where nodes are the
same if they have the same identity, and values are the same if
they are equal and have exactly the same type.</p>
<p>There is an exception to this rule: If a processor evaluates an
operand <em>E</em> (wholly or in part), then it is required to
establish that the actual value of the operand <em>E</em> does not
violate any constraints on its cardinality. For example, the
expression <code>$e eq 0</code> results in a type error if the
value of <code>$e</code> contains two or more items. A processor is
not allowed to decide, after evaluating the first item in the value
of <code>$e</code> and finding it equal to zero, that the only
possible outcomes are the value <code>true</code> or a type error
caused by the cardinality violation. It must establish that the
value of <code>$e</code> contains no more than one item.</p>
<p>These rules apply to all the operands of an expression
considered in combination: thus if an expression has two operands
<em>E1</em> and <em>E2</em>, it may be evaluated using any samples
of the respective sequences that satisfy the above rules.</p>
<p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and
<em>B</em> is an operand of <em>C</em>, then the processor needs to
evaluate only a sufficient sample of <em>B</em> to determine the
value of <em>C</em>, and needs to evaluate only a sufficient sample
of <em>A</em> to determine this sample of <em>B</em>.</p>
<p>The effect of these rules is that the processor is free to stop
examining further items in a sequence as soon as it can establish
that further items would not affect the result except possibly by
causing an error. For example, the processor may return
<code>true</code> as the result of the expression <code>S1 =
S2</code> as soon as it finds a pair of equal values from the two
sequences.</p>
<p>Another consequence of these rules is that where none of the
items in a sequence contributes to the result of an expression, the
processor is not obliged to evaluate any part of the sequence.
Again, however, the processor cannot dispense with a required
cardinality check: if an empty sequence is not permitted in the
relevant context, then the processor must ensure that the operand
is not an empty sequence.</p>
<p>Examples:</p>
<ul>
<li>
<p>If an implementation can find (for example, by using an index)
that at least one item returned by <code>$expr1</code> in the
following example has the value <code>47</code>, it is allowed to
return <code>true</code> as the result of the <code>some</code>
expression, without searching for another item returned by
<code>$expr1</code> that would raise an error if it were
evaluated.</p>
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</li>
<li>
<p>In the following example, if an implementation can find (for
example, by using an index) the <code>product</code> element-nodes
that have an <code>id</code> child with the value <code>47</code>,
it is allowed to return these nodes as the result of the <a title=
"path expression" href="#dt-path-expression">path expression</a>,
without searching for another <code>product</code> node that would
raise an error because it has an <code>id</code> child whose value
is not an integer.</p>
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</li>
</ul>
<p>For a variety of reasons, including optimization,
implementations may rewrite expressions into a different form.
There are a number of rules that limit the extent of this
freedom:</p>
<ul>
<li>
<p>Other than the raising or not raising of errors, the result of
evaluating a rewritten expression must conform to the semantics
defined in this specification for the original expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This allows an implementation to return a result in cases where
the original expression would have raised an error, or to raise an
error in cases where the original expression would have returned a
result. The main cases where this is likely to arise in practice
are (a) where a rewrite changes the order of evaluation, such that
a subexpression causing an error is evaluated when the expression
is written one way and is not evaluated when the expression is
written a different way, and (b) where intermediate results of the
evaluation cause overflow or other out-of-range conditions.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule does not mean that the result of the expression will
always be the same in non-error cases as if it had not been
rewritten, because there are many cases where the result of an
expression is to some degree <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> or
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</li>
<li>
<p>Conditional and typeswitch expressions must not raise a dynamic
error in respect of subexpressions occurring in a branch that is
not selected, and must not return the value delivered by a branch
unless that branch is selected. Thus, the following example must
not raise a dynamic error if the document <code>abc.xml</code> does
not exist:</p>
<div class="exampleInner">
<pre>
if (doc-available('abc.xml')) then doc('abc.xml') else ()
</pre></div>
</li>
<li>
<p>As stated earlier, an expression must not be rewritten to
dispense with a required cardinality check: for example,
<code>string-length(//title)</code> must raise an error if the
document contains more than one title element.</p>
</li>
<li>
<p>Expressions must not be rewritten in such a way as to create or
remove static errors. The static errors in this specification are
defined for the original expression, and must be preserved if the
expression is rewritten.</p>
</li>
</ul>
<p>Expression rewrite is illustrated by the following examples.</p>
<ul>
<li>
<p>Consider the expression <code>//part[color eq "Red"]</code>. An
implementation might choose to rewrite this expression as
<code>//part[color = "Red"][color eq "Red"]</code>. The
implementation might then process the expression as follows: First
process the "<code>=</code>" predicate by probing an index on parts
by color to quickly find all the parts that have a Red color; then
process the "<code>eq</code>" predicate by checking each of these
parts to make sure it has only a single color. The result would be
as follows:</p>
<ul>
<li>
<p>Parts that have exactly one color that is Red are returned.</p>
</li>
<li>
<p>If some part has color Red together with some other color, an
error is raised.</p>
</li>
<li>
<p>The existence of some part that has no color Red but has
multiple non-Red colors does not trigger an error.</p>
</li>
</ul>
</li>
<li>
<p>The expression in the following example cannot raise a casting
error if it is evaluated exactly as written (i.e., left to right).
Since neither predicate depends on the context position, an
implementation might choose to reorder the predicates to achieve
better performance (for example, by taking advantage of an index).
This reordering could cause the expression to raise an error.</p>
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
<p>To avoid unexpected errors caused by expression rewrite, tests
that are designed to prevent dynamic errors should be expressed
using conditional <span class="xquery">or
<code>typeswitch</code></span> expressions. For example, the above
expression can be written as follows:</p>
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>2.4 Concepts</h3>
<p>This section explains some concepts that are important to the
processing of XQuery 3.0 expressions.</p>
<div class="div3">
<h4><a name="id-document-order" id="id-document-order"></a>2.4.1
Document Order</h4>
<p>An ordering called <b>document order</b> is defined among all
the nodes accessible during processing of a given <span class=
"xquery">query</span>, which may consist of one or more
<b>trees</b> (documents or fragments). Document order is defined in
<a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a>, and its definition is repeated here for convenience.
Document order is a total ordering, although the relative order of
some nodes is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.
[<a name="dt-document-order" id="dt-document-order" title=
"document order">Definition</a>: Informally, <b>document order</b>
is the order in which nodes appear in the XML serialization of a
document.] [<a name="stable" id="stable" title=
"stable">Definition</a>: Document order is <b>stable</b>, which
means that the relative order of two nodes will not change during
the processing of a given <span class="xquery">query</span>, even
if this order is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.]
[<a name="dt-reverse-document-order" id="dt-reverse-document-order"
title="reverse document order">Definition</a>: The node ordering
that is the reverse of document order is called <b>reverse document
order</b>.]</p>
<p>Within a tree, document order satisfies the following
constraints:</p>
<ol class="enumar">
<li>
<p>The root node is the first node.</p>
</li>
<li>
<p>Every node occurs before all of its children and
descendants.</p>
</li>
<li>
<p>Attribute nodes immediately follow the element node with which
they are associated. The relative order of attribute nodes is
stable but <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p>
</li>
<li>
<p>Children and descendants occur before following siblings.</p>
</li>
</ol>
<p>The relative order of nodes in distinct trees is stable but
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>,
subject to the following constraint: If any node in a given tree T1
is before any node in a different tree T2, then all nodes in tree
T1 are before all nodes in tree T2.</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>2.4.2
Atomization</h4>
<p>The semantics of some XQuery 3.0 operators depend on a process
called <a title="atomization" href=
"#dt-atomization">atomization</a>. Atomization is applied to a
value when the value is used in a context in which a sequence of
atomic values is required. The result of atomization is either a
sequence of atomic values or a <a title="type error" href=
"#dt-type-error">type error</a> [err:FOTY0012]. [<a name=
"dt-atomization" id="dt-atomization" title=
"atomization">Definition</a>: <b>Atomization</b> of a sequence is
defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.]</p>
<p>The semantics of <code>fn:data</code> are repeated here for
convenience. The result of <code>fn:data</code> is the sequence of
atomic values produced by applying the following rules to each item
in the input sequence:</p>
<ul>
<li>
<p>If the item is an atomic value, it is returned.</p>
</li>
<li>
<p>If the item is a node, its <a title="typed value" href=
"#dt-typed-value">typed value</a> is returned ([err:FOTY0012] is
raised if the node has no typed value.)</p>
</li>
<li>
<p>If the item is a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
[err:FOTY0012] is raised.</p>
</li>
</ul>
<p>Atomization is used in processing the following types of
expressions:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Comparison expressions</p>
</li>
<li>
<p>Function calls and returns</p>
</li>
<li>
<p>Cast expressions</p>
</li>
<li>
<p>Constructor expressions for various kinds of nodes</p>
</li>
<li>
<p><code>order by</code> clauses in FLWOR expressions</p>
</li>
<li>
<p><code>group by</code> clauses in FLWOR expressions</p>
</li>
<li>
<p>Switch expressions</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>2.4.3 Effective Boolean
Value</h4>
<p>Under certain circumstances (listed below), it is necessary to
find the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of a value. [<a name="dt-ebv"
id="dt-ebv" title="effective boolean value">Definition</a>: The
<b>effective boolean value</b> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>.]</p>
<p>The dynamic semantics of <code>fn:boolean</code> are repeated
here for convenience:</p>
<ol class="enumar">
<li>
<p>If its operand is an empty sequence, <code>fn:boolean</code>
returns <code>false</code>.</p>
</li>
<li>
<p>If its operand is a sequence whose first item is a node,
<code>fn:boolean</code> returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:boolean</code>
or derived from <code>xs:boolean</code>, <code>fn:boolean</code>
returns the value of its operand unchanged.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:string</code>,
<code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type
derived from one of these, <code>fn:boolean</code> returns
<code>false</code> if the operand value has zero length; otherwise
it returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of any <a title="numeric" href=
"#dt-numeric">numeric</a> type or derived from a numeric type,
<code>fn:boolean</code> returns <code>false</code> if the operand
value is <code>NaN</code> or is numerically equal to zero;
otherwise it returns <code>true</code>.</p>
</li>
<li>
<p>In all other cases, <code>fn:boolean</code> raises a type error
[err:FORG0006].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of a sequence that contains at least one node and
at least one atomic value is <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> in
regions of a query where <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is
<code>unordered</code>.</p>
</div>
<p>The <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of a sequence is computed implicitly during
processing of the following types of expressions:</p>
<ul>
<li>
<p>Logical expressions (<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p>The <code>fn:not</code> function</p>
</li>
<li>
<p>The <code>where</code> clause of a FLWOR expression</p>
</li>
<li>
<p>Certain types of <a title="" href=
"#dt-predicate">predicates</a>, such as <code>a[b]</code></p>
</li>
<li>
<p>Conditional expressions (<code>if</code>)</p>
</li>
<li>
<p>Quantified expressions (<code>some</code>,
<code>every</code>)</p>
</li>
<li>
<p><a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> and
<a href="#doc-xquery30-WindowEndCondition">WindowEndCondition</a>
in <code>window</code> clauses.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The definition of <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> is <em>not</em> used when
casting a value to the type <code>xs:boolean</code>, for example in
a <code>cast</code> expression or when passing a value to a
function whose expected parameter is of type
<code>xs:boolean</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>2.4.4
Input Sources</h4>
<p>XQuery 3.0 has a set of functions that provide access to input
data. These functions are of particular importance because they
provide a way in which an expression can reference a document or a
collection of documents. The input functions are described
informally here; they are defined in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
<p>An expression can access input data either by calling one of the
input functions or by referencing some part of the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
that is initialized by the external environment, such as a
<a title="variable values" href="#dt-variable-values">variable</a>
or <a title="context item" href="#dt-context-item">context
item</a>.</p>
<p>The input functions supported by XQuery 3.0 are as follows:</p>
<ul>
<li>
<p>The <code>fn:doc</code> function takes a string containing a
URI. If that URI is associated with a document in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, <code>fn:doc</code> returns a document node whose
content is the <a title="data model" href="#dt-datamodel">data
model</a> representation of the given document; otherwise it raises
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>.</p>
</li>
<li>
<p>The <code>fn:unparsed-text</code> function takes a string
containing a URI, which must identify a resource that can be read
as text; otherwise it raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</li>
<li>
<p>The <code>fn:environment-variable</code> and
<code>fn:available-environment-variables</code> identify
environment variables that are available in the dynamic
context.</p>
</li>
<li>
<p>The <code>fn:collection</code> function with one argument takes
a string containing a URI. If that URI is associated with a
collection in <a title="available node collections" href=
"#dt-available-collections">available node collections</a>,
<code>fn:collection</code> returns the data model representation of
that collection; otherwise it raises a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>. A collection may be any
sequence of nodes. For example, the expression
<code>fn:collection("http://example.org")//customer</code>
identifies all the <code>customer</code> elements that are
descendants of nodes found in the collection whose URI is
<code>http://example.org</code>.</p>
</li>
<li>
<p>The <code>fn:collection</code> function with zero arguments
returns the <a title="default node collection" href=
"#dt-default-collection">default collection</a>, an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
sequence of nodes.</p>
</li>
<li>
<p>The <code>fn:uri-collection</code> function returns a sequence
of <code>xs:anyURI</code> values representing the URIs in a
resource collection.</p>
</li>
<li>
<p>The <code>fn:uri-collection</code> function with zero arguments
returns the URIs in the <a title="default resource collection"
href="#dt-default-resource-collection">default resource
collection</a>.</p>
</li>
</ul>
<p>These input functions are all specified in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>, which specifies error conditions and other details not
described here.</p>
</div>
<div class="div3">
<h4><a name="id-uri-literals" id="id-uri-literals"></a>2.4.5 URI
Literals</h4>
<p>XQuery 3.0 requires a statically known, valid URI in
<span class="xquery">a <a href=
"#doc-xquery30-URILiteral">URILiteral</a> or</span> a <a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a>. An
implementation may raise a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0046" title=
"err:XQST0046">err:XQST0046</a>] if the value of <span class=
"xquery">a URI Literal or</span> a Braced URI Literal is of nonzero
length and is <span>neither an absolute URI nor a relative
URI</span>.</p>
<p class="xquery">As in a string literal, any <a title=
"predefined entity reference" href=
"#dt-predefined-entity-reference">predefined entity reference</a>
(such as <code>&amp;amp;</code>), <a title="character reference"
href="#dt-character-reference">character reference</a> (such as
<code>&amp;#x2022;</code>), or <a href=
"#doc-xquery30-EscapeQuot">EscapeQuot</a> or <a href=
"#doc-xquery30-EscapeApos">EscapeApos</a> (for example,
<code>""</code>) is replaced by its appropriate expansion. Certain
characters, notably the ampersand, can only be represented using a
<a title="predefined entity reference" href=
"#dt-predefined-entity-reference">predefined entity reference</a>
or a <a title="character reference" href=
"#dt-character-reference">character reference</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>xs:anyURI</code> type is designed to anticipate the
introduction of Internationalized Resource Identifiers (IRI's) as
defined in <a href="#RFC3987">[RFC3987]</a>.</p>
</div>
<p>Whitespace is normalized using the whitespace normalization
rules of <code>fn:normalize-space</code>. If the result of
whitespace normalization contains only whitespace, the
corresponding URI consists of the empty string. <span class=
"xquery">Whitespace normalization is done after the expansion of
<a title="character reference" href=
"#dt-character-reference">character references</a>, so writing a
newline (for example) as <code>&amp;#xA;</code> does not prevent
its being normalized to a space character.</span></p>
<p>A Braced URI Literal or URI Literal is not subjected to
percent-encoding or decoding as defined in <a href=
"#RFC3986">[RFC3986]</a>.</p>
</div>
<div class="div3">
<h4><a name="id-resolve-relative-uri" id=
"id-resolve-relative-uri"></a>2.4.6 Resolving a Relative URI
Reference</h4>
<p>[<a name="dt-resolve-relative-uri" id="dt-resolve-relative-uri"
title="resolve">Definition</a>: To <b>resolve a relative URI</b>
<code>$rel</code> against a base URI <code>$base</code> is to
expand it to an absolute URI, as if by calling the function
<code>fn:resolve-uri($rel, $base)</code>.] During static analysis,
the base URI is the Static Base URI. During dynamic evaluation, the
base URI used to resolve a relative URI reference depends on the
semantics of the expression.</p>
<p>Any process that attempts to <a title="resolve" href=
"#dt-resolve-relative-uri">resolve URI</a> against a base URI, or
to dereference the URI, may apply percent-encoding or decoding as
defined in the relevant RFCs.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-types" id="id-types"></a>2.5 Types</h3>
<p>The type system of XQuery 3.0 is based on <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.</p>
<p>[<a name="dt-sequence-type" id="dt-sequence-type" title=
"sequence type">Definition</a>: A <b>sequence type</b> is a type
that can be expressed using the <a href=
"#doc-xquery30-SequenceType">SequenceType</a> syntax. Sequence
types are used whenever it is necessary to refer to a type in an
XQuery 3.0 expression. The term <b>sequence type</b> suggests that
this syntax is used to describe the type of an XQuery 3.0 value,
which is always a sequence.]</p>
<p>[<a name="dt-schema-type" id="dt-schema-type" title=
"schema type">Definition</a>: A <b>schema type</b> is a type that
is (or could be) defined using the facilities of <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> (including the built-in types of <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>).] A schema type can be used as a type annotation
on an element or attribute node (unless it is a non-instantiable
type such as <code>xs:NOTATION</code> or
<code>xs:anyAtomicType</code>, in which case its derived types can
be so used). Every schema type is either a <b>complex type</b> or a
<b>simple type</b>; simple types are further subdivided into
<b>list types</b>, <b>union types</b>, and <b>atomic types</b> (see
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> for definitions and
explanations of these terms.)</p>
<p>[<a name="dt-generalized-atomic-type" id=
"dt-generalized-atomic-type" title=
"generalized atomic type">Definition</a>: A <b>generalized atomic
type</b> is a type which is either (a) an atomic type or (b) a
<span><a title="pure union type" href="#dt-pure-union-type">pure
union type</a></span> ].</p>
<p>[<a name="dt-pure-union-type" id="dt-pure-union-type" title=
"pure union type">Definition</a>: A <b>pure union type</b> is an
XML Schema union type that satisfies the following constraints: (1)
<code>{variety}</code> is <code>union</code>, (2) the
<code>{facets}</code> property is empty, (3) no type in the
transitive membership of the union type has <code>{variety}</code>
<code>list</code>, and (4) no type in the transitive membership of
the union type is a type with <code>{variety}</code>
<code>union</code> having a non-empty <code>{facets}</code>
property].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The definition of <a title="pure union type" href=
"#dt-pure-union-type">pure union type</a> excludes union types
derived by non-trivial restriction from other union types, as well
as union types that include list types in their membership. Pure
union types have the property that every instance of an atomic type
defined as one of the member types of the union is also a valid
instance of the union type.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The current (second) edition of XML Schema 1.0 contains an error
in respect of the substitutability of a union type by one of its
members: it fails to recognize that this is unsafe if the union is
derived by restriction from another union.</p>
<p>This problem is fixed in XSD 1.1, but the effect of the
resolution is that an atomic value labeled with an atomic type
cannot be treated as being substitutable for a union type without
explicit validation. This specification therefore allows union
types to be used as item types only if they are defined directly as
the union of a number of atomic types.</p>
</div>
<p><a title="generalized atomic type" href=
"#dt-generalized-atomic-type">Generalized atomic types</a>
represent the intersection between the categories of <a title=
"sequence type" href="#dt-sequence-type">sequence type</a> and
<a title="schema type" href="#dt-schema-type">schema type</a>. A
generalized atomic type, such as <code>xs:integer</code> or
<code>my:hatsize</code>, is both a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> and a <a title="schema type"
href="#dt-schema-type">schema type</a>.</p>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>2.5.1 Predefined Schema Types</h4>
<p>The schema types defined in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>
are summarized below.</p>
<p class="xquery">The <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a> in the <a title=
"static context" href="#dt-static-context">static context</a> are
initialized with certain predefined schema types, including the
built-in schema types in the namespace
<code>http://www.w3.org/2001/XMLSchema</code>, which has the
predefined namespace prefix <code>xs</code>. The schema types in
this namespace are defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> and
augmented by additional types defined in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>.
Element and attribute declarations in the <code>xs</code> namespace
are not implicitly included in the static context. The schema types
defined in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a> are summarized below.</p>
<ol class="enumar">
<li>
<p>[<a name="dt-untyped" id="dt-untyped" title=
"xs:untyped">Definition</a>: <code>xs:untyped</code> is used as the
<a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node that has not been validated, or
has been validated in <code>skip</code> mode.] No predefined schema
types are derived from <code>xs:untyped</code>.</p>
</li>
<li>
<p>[<a name="dt-untypedAtomic" id="dt-untypedAtomic" title=
"xs:untypedAtomic">Definition</a>: <code>xs:untypedAtomic</code> is
an atomic type that is used to denote untyped atomic data, such as
text that has not been assigned a more specific type.] An attribute
that has been validated in <code>skip</code> mode is represented in
the <a title="data model" href="#dt-datamodel">data model</a> by an
attribute node with the <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>. No predefined schema types are
derived from <code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>[<a name="dt-dayTimeDuration" id="dt-dayTimeDuration" title=
"xs:dayTimeDuration">Definition</a>:
<code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.]</p>
</li>
<li>
<p>[<a name="dt-yearMonthDuration" id="dt-yearMonthDuration" title=
"xs:yearMonthDuration">Definition</a>:
<code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.]</p>
</li>
<li>
<p>[<a name="dt-anyAtomicType" id="dt-anyAtomicType" title=
"xs:anyAtomicType">Definition</a>: <code>xs:anyAtomicType</code> is
an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is <code>xs:anySimpleType</code>
from which all simple types, including atomic, list, and union
types, are derived. All primitive atomic types, such as
<code>xs:decimal</code> and <code>xs:string</code>, have
<code>xs:anyAtomicType</code> as their base type.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyAtomicType</code> will not appear as the type of an
actual value in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>.</p>
</div>
</li>
<li>
<p>[<a name="dt-xs-error" id="dt-xs-error" title=
"xs:error">Definition</a>: <code>xs:error</code> is a simple type
with no value space, defined in <a href="#XMLSchema11">[XML Schema
1.1]</a>. In implementations that support XML Schema 1.1, it can be
used in the <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType
Syntax</b></a> to raise errors.]</p>
</li>
</ol>
<p>The relationships among the schema types in the <code>xs</code>
namespace are illustrated in Figure 2. A more complete description
of the XQuery 3.0 type hierarchy can be found in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>Figure 2: Hierarchy of Schema Types used in XQuery 3.0.</p>
</div>
<div class="div3">
<h4><a name="id-namespace-sensitive" id=
"id-namespace-sensitive"></a>2.5.2 Namespace-sensitive Types</h4>
<p>[<a name="dt-namespace-sensitive" id="dt-namespace-sensitive"
title="namespace-sensitive">Definition</a>: The
<b>namespace-sensitive</b> types are <code>xs:QName</code>,
<code>xs:NOTATION</code>, types derived by restriction from
<code>xs:QName</code> or <code>xs:NOTATION</code>, list types that
have a namespace-sensitive item type, and union types with a
namespace-sensitive type in their transitive membership.]</p>
<p>It is not possible to preserve the type of a <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> value without
also preserving the namespace binding that defines the meaning of
each namespace prefix used in the value. Therefore, XQuery 3.0
defines some error conditions that occur only with <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> values. For
instance, <span>casting to a <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> type raises a
<a title="type error" href="#dt-type-error">type error</a>
<span><code>[err:FONS0004]</code></span> if the namespace bindings
for the result cannot be determined.</span></p>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>2.5.3 Typed
Value and String Value</h4>
<p>Every node has a <b>typed value</b> and a <b>string value</b>
<span>, except for nodes whose value is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</span>
[<a name="dt-typed-value" id="dt-typed-value" title=
"typed value">Definition</a>: The <b>typed value</b> of a node is a
sequence of atomic values and can be extracted by applying the
<code>fn:data</code> function to the node.] [<a name=
"dt-string-value" id="dt-string-value" title=
"string value">Definition</a>: The <b>string value</b> of a node is
a string and can be extracted by applying the
<code>fn:string</code> function to the node.] Definitions of
<code>fn:data</code> and <code>fn:string</code> can be found in
<a href="#xpath-functions-30">[XQuery and XPath Functions and
Operators 3.0]</a>.</p>
<p>An implementation may store both the <a title="typed value"
href="#dt-typed-value">typed value</a> and the <a title=
"string value" href="#dt-string-value">string value</a> of a node,
or it may store only one of these and derive the other as needed.
The string value of a node must be a valid lexical representation
of the typed value of the node, but the node is not required to
preserve the string representation from the original source
document. For example, if the typed value of a node is the
<code>xs:integer</code> value <code>30</code>, its string value
might be "<code>30</code>" or "<code>0030</code>".</p>
<p class="xquery">The <a title="typed value" href=
"#dt-typed-value">typed value</a>, <a title="string value" href=
"#dt-string-value">string value</a>, and <a title="type annotation"
href="#dt-type-annotation">type annotation</a> of a node are
closely related, and are defined by rules found in the following
locations:</p>
<ul>
<li>
<p>If the node was created by mapping from an Infoset or PSVI, see
rules in <a href="#xpath-datamodel-30">[XQuery and XPath Data Model
(XDM) 3.0]</a>.</p>
</li>
<li>
<p>If the node was created by an XQuery node constructor, see rules
in <a href="#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>, <a href="#id-computedElements"><b>3.9.3.1
Computed Element Constructors</b></a>, or <a href=
"#id-computedAttributes"><b>3.9.3.2 Computed Attribute
Constructors</b></a>.</p>
</li>
<li>
<p>If the node was created by a <code>validate</code> expression,
see rules in <a href="#id-validate"><b>3.18 Validate
Expressions</b></a>.</p>
</li>
</ul>
<p>As a convenience to the reader, the relationship between
<a title="typed value" href="#dt-typed-value">typed value</a> and
<a title="string value" href="#dt-string-value">string value</a>
for various kinds of nodes is summarized and illustrated by
examples below.</p>
<ol class="enumar">
<li>
<p>For text and document nodes, the typed value of the node is the
same as its string value, as an instance of the type
<code>xs:untypedAtomic</code>. The string value of a document node
is formed by concatenating the string values of all its descendant
text nodes, in <a title="document order" href=
"#dt-document-order">document order</a>.</p>
</li>
<li>
<p>The typed value of a comment or processing instruction node is
the same as its string value. It is an instance of the type
<code>xs:string</code>.</p>
</li>
<li>
<p>The typed value of an attribute node with the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is
the same as its string value, as an instance of
<code>xs:untypedAtomic</code>. The typed value of an attribute node
with any other type annotation is derived from its string value and
type annotation using the lexical-to-value-space mapping defined in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> Part 2 for the relevant
type.</p>
<p>Example: A1 is an attribute having string value
<code>"3.14E-2"</code> and type annotation <code>xs:double</code>.
The typed value of A1 is the <code>xs:double</code> value whose
lexical representation is <code>3.14E-2</code>.</p>
<p>Example: A2 is an attribute with type annotation
<code>xs:IDREFS</code>, which is a list datatype whose item type is
the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type
(such as <code>xs:IDREFS</code>), its typed value is treated as a
sequence of the <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> from
which it is derived (such as <code>xs:IDREF</code>).</p>
</li>
<li>
<p>For an element node, the relationship between typed value and
string value depends on the node's <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>, as follows:</p>
<ol class="enumla">
<li>
<p>If the type annotation is <code>xs:untyped</code> or
<code>xs:anySimpleType</code> or denotes a complex type with mixed
content (including <code>xs:anyType</code>), then the typed value
of the node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>. However, if the <code>nilled</code>
property of the node is <code>true</code>, then its typed value is
the empty sequence.</p>
<p>Example: E1 is an element node having type annotation
<code>xs:untyped</code> and string value "<code>1999-05-31</code>".
The typed value of E1 is "<code>1999-05-31</code>", as an instance
of <code>xs:untypedAtomic</code>.</p>
<p>Example: E2 is an element node with the type annotation
<code>formula</code>, which is a complex type with mixed content.
The content of E2 consists of the character "<code>H</code>", a
child element named <code>subscript</code> with string value
"<code>2</code>", and the character "<code>O</code>". The typed
value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If the type annotation denotes a simple type or a complex type
with simple content, then the typed value of the node is derived
from its string value and its type annotation in a way that is
consistent with schema validation. However, if the
<code>nilled</code> property of the node is <code>true</code>, then
its typed value is the empty sequence.</p>
<p>Example: E3 is an element node with the type annotation
<code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>.
The string value of E3 is "<code>74.95</code>". The typed value of
E3 is <code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p>
<p>Example: E4 is an element node with the type annotation
<code>hatsizelist</code>, which is a simple type derived from the
atomic type <code>hatsize</code>, which in turn is derived from
<code>xs:integer</code>. The string value of E4 is "<code>7 8
9</code>". The typed value of E4 is a sequence of three values
(<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p>
<p>Example: E5 is an element node with the type annotation
<code>my:integer-or-string</code> which is a union type with member
types <code>xs:integer</code> and <code>xs:string</code>. The
string value of E5 is "<code>47</code>". The typed value of E5 is
<code>47</code> as an <code>xs:integer</code>, since
<code>xs:integer</code> is the member type that validated the
content of E5. In general, when the type annotation of a node is a
union type, the typed value of the node will be an instance of one
of the member types of the union.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an implementation stores only the string value of a node, and
the type annotation of the node is a union type, the implementation
must be able to deliver the typed value of the node as an instance
of the appropriate member type.</p>
</div>
</li>
<li>
<p>If the type annotation denotes a complex type with empty
content, then the typed value of the node is the empty sequence and
its string value is the zero-length string.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with element-only
content, then the typed value of the node is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
The <code>fn:data</code> function raises a <a title="type error"
href="#dt-type-error">type error</a> <code>[err:FOTY0012]</code>
when applied to such a node. The string value of such a node is
equal to the concatenated string values of all its text node
descendants, in document order.</p>
<p>Example: E6 is an element node with the type annotation
<code>weather</code>, which is a complex type whose content type
specifies <code>element-only</code>. E6 has two child elements
named <code>temperature</code> and <code>precipitation</code>. The
typed value of E6 is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>,
and the <code>fn:data</code> function applied to E6 raises an
error.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-sequencetype-syntax" id=
"id-sequencetype-syntax"></a>2.5.4 SequenceType Syntax</h4>
<p>Whenever it is necessary to refer to a type in an XQuery 3.0
expression, the <a href=
"#doc-xquery30-SequenceType">SequenceType</a> syntax is used.</p>
<h5><a name="d2e5670" id="d2e5670"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SequenceType" id=
"doc-xquery30-SequenceType"></a>[168]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xquery30-ItemType">ItemType</a> <a href=
"#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ItemType" id=
"doc-xquery30-ItemType"></a>[170]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#doc-xquery30-FunctionTest">FunctionTest</a> |
<a href="#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> |
<a href=
"#doc-xquery30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OccurrenceIndicator" id=
"doc-xquery30-OccurrenceIndicator"></a>[169]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AtomicOrUnionType" id=
"doc-xquery30-AtomicOrUnionType"></a>[171]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-KindTest" id=
"doc-xquery30-KindTest"></a>[172]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xquery30-ElementTest">ElementTest</a><br />
| <a href="#doc-xquery30-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xquery30-PITest">PITest</a><br />
| <a href="#doc-xquery30-CommentTest">CommentTest</a><br />
| <a href="#doc-xquery30-TextTest">TextTest</a><br />
| <a href=
"#doc-xquery30-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#doc-xquery30-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DocumentTest" id=
"doc-xquery30-DocumentTest"></a>[174]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xquery30-ElementTest">ElementTest</a> | <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5606.doc-xquery30-ElementTest" id=
"noid_d3e5606.doc-xquery30-ElementTest"></a>[183]&#160;&#160;&#160;</td>
<td><code>ElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#doc-xquery30-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5607.doc-xquery30-SchemaElementTest" id=
"noid_d3e5607.doc-xquery30-SchemaElementTest"></a>[185]&#160;&#160;&#160;</td>
<td><code>SchemaElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xquery30-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5608.doc-xquery30-ElementDeclaration" id=
"noid_d3e5608.doc-xquery30-ElementDeclaration"></a>[186]&#160;&#160;&#160;</td>
<td><code>ElementDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5609.doc-xquery30-AttributeTest" id=
"noid_d3e5609.doc-xquery30-AttributeTest"></a>[179]&#160;&#160;&#160;</td>
<td><code>AttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xquery30-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5611.doc-xquery30-SchemaAttributeTest" id=
"noid_d3e5611.doc-xquery30-SchemaAttributeTest"></a>[181]&#160;&#160;&#160;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xquery30-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5612.doc-xquery30-AttributeDeclaration" id=
"noid_d3e5612.doc-xquery30-AttributeDeclaration"></a>[182]&#160;&#160;&#160;</td>
<td><code>AttributeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5613.doc-xquery30-ElementNameOrWildcard" id=
"noid_d3e5613.doc-xquery30-ElementNameOrWildcard"></a>[184]&#160;&#160;&#160;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ElementName" id=
"doc-xquery30-ElementName"></a>[188]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5615.doc-xquery30-AttribNameOrWildcard" id=
"noid_d3e5615.doc-xquery30-AttribNameOrWildcard"></a>[180]&#160;&#160;&#160;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AttributeName" id=
"doc-xquery30-AttributeName"></a>[187]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TypeName" id=
"doc-xquery30-TypeName"></a>[190]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PITest" id=
"doc-xquery30-PITest"></a>[178]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery30-NCName">NCName</a> | <a href=
"#doc-xquery30-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CommentTest" id=
"doc-xquery30-CommentTest"></a>[176]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NamespaceNodeTest" id=
"doc-xquery30-NamespaceNodeTest"></a>[177]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TextTest" id=
"doc-xquery30-TextTest"></a>[175]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AnyKindTest" id=
"doc-xquery30-AnyKindTest"></a>[173]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5624.doc-xquery30-FunctionTest" id=
"noid_d3e5624.doc-xquery30-FunctionTest"></a>[191]&#160;&#160;&#160;</td>
<td><code>FunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Annotation">Annotation</a>*
(<a href="#doc-xquery30-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5625.doc-xquery30-AnyFunctionTest" id=
"noid_d3e5625.doc-xquery30-AnyFunctionTest"></a>[192]&#160;&#160;&#160;</td>
<td><code>AnyFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5626.doc-xquery30-TypedFunctionTest" id=
"noid_d3e5626.doc-xquery30-TypedFunctionTest"></a>[193]&#160;&#160;&#160;</td>
<td><code>TypedFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#doc-xquery30-SequenceType">SequenceType</a> ("," <a href=
"#doc-xquery30-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ParenthesizedItemType" id=
"doc-xquery30-ParenthesizedItemType"></a>[194]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xquery30-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
</table>
<p>With the exception of the special type
<code>empty-sequence()</code>, a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> consists of an <b>item
type</b> that constrains the type of each item in the sequence, and
a <b>cardinality</b> that constrains the number of items in the
sequence. Apart from the item type <code>item()</code>, which
permits any kind of item, item types divide into <b>node types</b>
(such as <code>element()</code>), <b>generalized atomic types</b>
(such as <code>xs:integer</code>) and function types (such as
function() as item()*).</p>
<p><a title="lexical QName" href="#dt-qname">Lexical QNames</a>
appearing in a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> have their prefixes expanded
to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> and (where
applicable) the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> . Equality
of QNames is defined by the <code>eq</code> operator.</p>
<p>Item types representing element and attribute nodes may specify
the required <a title="type annotation" href=
"#dt-type-annotation">type annotations</a> of those nodes, in the
form of a <a title="schema type" href="#dt-schema-type">schema
type</a>. Thus the item type <code>element(*, us:address)</code>
denotes any element node whose type annotation is (or is derived
from) the schema type named <code>us:address</code>.</p>
<p>The occurrence indicators '+', '*', and '?' bind to the last
<a href="#doc-xquery30-ItemType">ItemType</a> in the <a href=
"#doc-xquery30-SequenceType">SequenceType</a>, as described in
<a href=
"#parse-note-occurrence-indicators">occurrence-indicators</a>
constraint.</p>
<p>Here are some examples of <a title="sequence type" href=
"#dt-sequence-type">sequence types</a> that might be used in XQuery
3.0:</p>
<ul>
<li>
<p><code>xs:date</code> refers to the built-in atomic schema type
named <code>xs:date</code></p>
</li>
<li>
<p><code>attribute()?</code> refers to an optional attribute
node</p>
</li>
<li>
<p><code>element()</code> refers to any element node</p>
</li>
<li>
<p><code>element(po:shipto, po:address)</code> refers to an element
node that has the name <code>po:shipto</code> and has the type
annotation <code>po:address</code> (or a schema type derived from
<code>po:address</code>)</p>
</li>
<li>
<p><code>element(*, po:address)</code> refers to an element node of
any name that has the type annotation <code>po:address</code> (or a
type derived from <code>po:address</code>)</p>
</li>
<li>
<p><code>element(customer)</code> refers to an element node named
<code>customer</code> with any type annotation</p>
</li>
<li>
<p><code>schema-element(customer)</code> refers to an element node
whose name is <code>customer</code> (or is in the substitution
group headed by <code>customer</code>) and whose type annotation
matches the schema type declared for a <code>customer</code>
element in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a></p>
</li>
<li>
<p><code>node()*</code> refers to a sequence of zero or more nodes
of any kind</p>
</li>
<li>
<p><code>item()+</code> refers to a sequence of one or more
<a title="item" href="#dt-item">items</a></p>
</li>
<li>
<p><code>function(*)</code> refers to any <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>,
regardless of arity or type</p>
</li>
<li>
<p><code>function(node()) as xs:string*</code> refers to a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
that takes a single argument whose value is a single node, and
returns a sequence of zero or more xs:string values</p>
</li>
<li>
<p><code>(function(node()) as xs:string)*</code> refers to a
sequence of zero or more <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">functions</a><sup><small>DM30</small></sup>,
each of which takes a single argument whose value is a single node,
and returns as its result a single xs:string value</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>2.5.5 SequenceType Matching</h4>
<p>[<a name="dt-sequencetype-matching" id=
"dt-sequencetype-matching" title=
"SequenceType matching">Definition</a>: <b>SequenceType
matching</b> compares the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a value with an expected
<a title="sequence type" href="#dt-sequence-type">sequence
type</a>. ] For example, an <code>instance of</code> expression
returns <code>true</code> if the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a given value matches a
given <a title="sequence type" href="#dt-sequence-type">sequence
type</a>, or <code>false</code> if it does not.</p>
<p>An XQuery 3.0 implementation must be able to determine
relationships among the types in type annotations in an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> and
the types in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> (ISSD). <span class=
"xquery">An XQuery 3.0 implementation must be able to determine
relationships among the types in ISSDs used in different modules of
the same query.</span></p>
<p>[<a name="dt-subtype-substitution" id="dt-subtype-substitution"
title="subtype substitution">Definition</a>: The use of a value
whose <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> is derived from an expected type is known as <b>subtype
substitution</b>.] Subtype substitution does not change the actual
type of a value. For example, if an <code>xs:integer</code> value
is used where an <code>xs:decimal</code> value is expected, the
value retains its type as <code>xs:integer</code>.</p>
<p>The definition of <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> relies on a
pseudo-function named <code>derives-from(</code> <em>AT</em>,
<em>ET</em> <code>)</code>, which takes an actual simple or complex
schema type <em>AT</em> and an expected simple or complex schema
type <em>ET</em>, and either returns a boolean value or raises a
<a title="type error" href="#dt-type-error">type error</a>
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
<span>This function is defined as follows:</span></p>
<ul>
<li>
<p><code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> raises a type error [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>] if <em>ET</em> is not present in
<span>the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> (ISSD).</span></p>
</li>
<li>
<p><code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> returns <code>true</code> <span>if any of the
following conditions applies:</span></p>
<ul>
<li>
<p><em>AT</em> is <em>ET</em></p>
</li>
<li>
<p><em>ET</em> is the base type of <em>AT</em></p>
</li>
<li>
<p><em>ET</em> is a pure union type of which <em>AT</em> is a
member type</p>
</li>
<li>
<p>There is a type <em>MT</em> such that <code>derives-from(</code>
<em>AT</em>, <em>MT</em> <code>)</code> and
<code>derives-from(</code> <em>MT</em>, <em>ET</em>
<code>)</code></p>
</li>
</ul>
</li>
<li>
<p>Otherwise, <code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> returns <code>false</code></p>
</li>
</ul>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> are given
below, with examples (the examples are for purposes of
illustration, and do not cover all possible cases).</p>
<div class="div4">
<h5><a name="id-matching-value" id="id-matching-value"></a>2.5.5.1
Matching a SequenceType and a Value</h5>
<ul>
<li>
<p>The <a title="sequence type" href="#dt-sequence-type">sequence
type</a> <code>empty-sequence()</code> matches a value that is the
empty sequence.</p>
</li>
<li>
<p>An <a href="#doc-xquery30-ItemType">ItemType</a> with no
<a href="#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>
matches any value that contains exactly one item if the <a href=
"#doc-xquery30-ItemType">ItemType</a> matches that item (see
<a href="#id-matching-item"><b>2.5.5.2 Matching an ItemType and an
Item</b></a>).</p>
</li>
<li>
<p>An <a href="#doc-xquery30-ItemType">ItemType</a> with an
<a href="#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>
matches a value if the number of items in the value matches the
<a href="#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>
and the <a href="#doc-xquery30-ItemType">ItemType</a> matches each
of the items in the value.</p>
</li>
</ul>
<p>An <a href=
"#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>
specifies the number of items in a sequence, as follows:</p>
<ul>
<li>
<p><code>?</code> matches zero or one items</p>
</li>
<li>
<p><code>*</code> matches zero or more items</p>
</li>
<li>
<p><code>+</code> matches one or more items</p>
</li>
</ul>
<p>As a consequence of these rules, any <a title="sequence type"
href="#dt-sequence-type">sequence type</a> whose <a href=
"#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a> is
<code>*</code> or <code>?</code> matches a value that is an empty
sequence.</p>
</div>
<div class="div4">
<h5><a name="id-matching-item" id="id-matching-item"></a>2.5.5.2
Matching an ItemType and an Item</h5>
<ul>
<li>
<p>An <a href="#doc-xquery30-ItemType">ItemType</a> consisting
simply of an EQName is interpreted as an <a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a>. The
expected type <em>AtomicOrUnionType</em> matches an atomic value
whose actual type is <em>AT</em> if <code>derives-from(</code>
<em>AT, AtomicOrUnionType</em> <code>)</code> is
<code>true</code>.</p>
<p>The name of an <a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> has its
prefix expanded to a namespace URI by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. If the
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of an <a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> is not
defined as a <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, a <a title="static error" href="#dt-static-error">static
error</a> is raised [<a href="#ERRXPST0051" title=
"err:XPST0051">err:XPST0051</a>].</p>
<p>Example: The <a href="#doc-xquery30-ItemType">ItemType</a>
<code>xs:decimal</code> matches any value of type
<code>xs:decimal</code>. It also matches any value of type
<code>shoesize</code>, if <code>shoesize</code> is an atomic type
derived by restriction from <code>xs:decimal</code>.</p>
<p>Example: Suppose <a href="#doc-xquery30-ItemType">ItemType</a>
<code>dress-size</code> is a union type that allows either
<code>xs:decimal</code> values for numeric sizes (e.g. 4, 6, 10,
12), or one of an enumerated set of <code>xs:strings</code> (e.g.
"small", "medium", "large"). The <a href=
"#doc-xquery30-ItemType">ItemType</a> <code>dress-size</code>
matches any of these values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names of non-atomic types such as <code>xs:IDREFS</code> are
not accepted in this context, but can often be replaced by a
<a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> with an
occurrence indicator, such as <code>xs:IDREF+</code>.</p>
</div>
</li>
<li>
<p><code>item()</code> matches any single <a title="item" href=
"#dt-item">item</a>.</p>
<p>Example: <code>item()</code> matches the atomic value
<code>1</code>, the element <code>&lt;a/&gt;</code>, or the
function <code>fn:concat#3</code>.</p>
</li>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>processing-instruction()</code> matches any
processing-instruction node.</p>
</li>
<li>
<p><code>processing-instruction(</code> <em>N</em> <code>)</code>
matches any processing-instruction node whose PITarget is equal to
<code>fn:normalize-space(N)</code>. If
<code>fn:normalize-space(N)</code> is not in the lexical space of
NCName, a type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]</p>
<p>Example: <code>processing-instruction(xml-stylesheet)</code>
matches any processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p>
<p>For backward compatibility with XPath 1.0, the PITarget of a
processing instruction may also be expressed as a string literal,
as in this example:
<code>processing-instruction("xml-stylesheet")</code>.</p>
<p>If the specified PITarget is not a syntactically valid NCName, a
type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(</code> <em>E</em> <code>)</code> matches
any document node that contains exactly one element node,
optionally accompanied by one or more comment and processing
instruction nodes, if <em>E</em> is an <a href=
"#doc-xquery30-ElementTest">ElementTest</a> or <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a> that
matches the element node (see <a href="#id-element-test"><b>2.5.5.3
Element Test</b></a> and <a href=
"#id-schema-element-test"><b>2.5.5.4 Schema Element
Test</b></a>).</p>
<p>Example: <code>document-node(element(book))</code> matches a
document node containing exactly one element node that is matched
by the ElementTest <code>element(book)</code>.</p>
</li>
<li>
<p>A <a href=
"#doc-xquery30-ParenthesizedItemType">ParenthesizedItemType</a>
matches an item if and only if the item matches the <a href=
"#doc-xquery30-ItemType">ItemType</a> that is in parentheses.</p>
</li>
<li>
<p>An <a href="#doc-xquery30-ItemType">ItemType</a> that is an
<a href="#doc-xquery30-ElementTest">ElementTest</a>, <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a>, <a href=
"#doc-xquery30-AttributeTest">AttributeTest</a>, <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a>, or
<a href="#doc-xquery30-FunctionTest">FunctionTest</a> matches an
item as described in the following sections.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-element-test" id="id-element-test"></a>2.5.5.3
Element Test</h5>
<h5><a name="d2e6870" id="d2e6870"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ElementTest" id=
"doc-xquery30-ElementTest"></a>[183]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#doc-xquery30-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ElementNameOrWildcard" id=
"doc-xquery30-ElementNameOrWildcard"></a>[184]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e6550.doc-xquery30-ElementName" id=
"noid_d3e6550.doc-xquery30-ElementName"></a>[188]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e6551.doc-xquery30-TypeName" id=
"noid_d3e6551.doc-xquery30-TypeName"></a>[190]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>An <a href="#doc-xquery30-ElementTest">ElementTest</a> is used
to match an element node by its name and/or <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
<p>The <a href="#doc-xquery30-ElementName">ElementName</a> and
<a href="#doc-xquery30-TypeName">TypeName</a> of an <a href=
"#doc-xquery30-ElementTest">ElementTest</a> have their prefixes
expanded to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
<a href="#doc-xquery30-ElementName">ElementName</a> need not be
present in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, but the <a href=
"#doc-xquery30-TypeName">TypeName</a> must be present in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>]. Note that <a title=
"substitution group" href="#dt-substitution-group">substitution
groups</a> do not affect the semantics of <a href=
"#doc-xquery30-ElementTest">ElementTest</a>.</p>
<p>An <a href="#doc-xquery30-ElementTest">ElementTest</a> may take
any of the following forms:</p>
<ol class="enumar">
<li>
<p><code>element()</code> and <code>element(*)</code> match any
single element node, regardless of its name or type annotation.</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xquery30-ElementName">ElementName</a> <code>)</code> matches
any element node whose name is <a href=
"#doc-xquery30-ElementName">ElementName</a>, regardless of its type
annotation or <code>nilled</code> property.</p>
<p>Example: <code>element(person)</code> matches any element node
whose name is <code>person</code>.</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xquery30-ElementName">ElementName</a> <code>,</code> <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> matches an
element node whose name is <a href=
"#doc-xquery30-ElementName">ElementName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node, and the <code>nilled</code> property of the node is
<code>false</code>.</p>
<p>Example: <code>element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xquery30-ElementName">ElementName</a>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>?)</code> matches an
element node whose name is <a href=
"#doc-xquery30-ElementName">ElementName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node. The <code>nilled</code> property of the node may be
either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(person, surgeon?)</code> matches a nilled
or non-nilled element node whose name is <code>person</code> and
whose type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> matches an
element node regardless of its name, if <code>derives-from(</code>
<em>AT</em>, <a href="#doc-xquery30-TypeName">TypeName</a>
<code>)</code> is <code>true</code>, where <em>AT</em> is the type
annotation of the element node, and the <code>nilled</code>
property of the node is <code>false</code>.</p>
<p>Example: <code>element(*, surgeon)</code> matches any non-nilled
element node whose type annotation is <code>surgeon</code> (or is
derived from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>?)</code> matches an
element node regardless of its name, if <code>derives-from(</code>
<em>AT</em>, <a href="#doc-xquery30-TypeName">TypeName</a>
<code>)</code> is <code>true</code>, where <em>AT</em> is the type
annotation of the element node. The <code>nilled</code> property of
the node may be either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(*, surgeon?)</code> matches any nilled or
non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>),
regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-element-test" id=
"id-schema-element-test"></a>2.5.5.4 Schema Element Test</h5>
<h5><a name="d2e7220" id="d2e7220"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SchemaElementTest" id=
"doc-xquery30-SchemaElementTest"></a>[185]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xquery30-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ElementDeclaration" id=
"doc-xquery30-ElementDeclaration"></a>[186]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e6869.doc-xquery30-ElementName" id=
"noid_d3e6869.doc-xquery30-ElementName"></a>[188]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a> matches an
element node against a corresponding element declaration found in
the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>.</p>
<p>The <a href="#doc-xquery30-ElementName">ElementName</a> of a
<a href="#doc-xquery30-SchemaElementTest">SchemaElementTest</a> has
its prefixes expanded to a namespace URI by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. If the
<a href="#doc-xquery30-ElementName">ElementName</a> specified in
the <a href="#doc-xquery30-SchemaElementTest">SchemaElementTest</a>
is not found in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a> matches a
candidate element node if all of the following conditions are
satisfied:</p>
<ol class="enumar">
<li>
<p>Either:</p>
<ol class="enumla">
<li>
<p>The name <em>N</em> of the candidate node matches the specified
<a href="#doc-xquery30-ElementName">ElementName</a>, or</p>
</li>
<li>
<p>The name <em>N</em> of the candidate node matches the name of an
element declaration that is a member of the actual substitution
group headed by the declaration of element <a href=
"#doc-xquery30-ElementName">ElementName</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term "actual substitution group" is defined in <a href=
"#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group
of an element declaration <em>H</em> includes those element
declarations <em>P</em> that are declared to have <em>H</em> as
their direct or indirect substitution group head, provided that
<em>P</em> is not declared as abstract, and that <em>P</em> is
validly substitutable for <em>H</em>, which means that there must
be no blocking constraints that prevent substitution.</p>
</div>
</li>
<li>
<p>The schema element declaration named <em>N</em> is not
abstract.</p>
</li>
<li>
<p><code>derives-from( AT, ET )</code> is true, where <em>AT</em>
is the type annotation of the candidate node and <em>ET</em> is the
schema type declared in the schema element declaration named
<em>N</em>.</p>
</li>
<li>
<p>If the schema element declaration named <em>N</em> is not
nillable, then the nilled property of the candidate node is
false.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a>
<code>schema-element(customer)</code> matches a candidate element
node <span>in the following two situations:</span></p>
<ol class="enumar">
<li>
<p>customer is a top-level element declaration in the in-scope
element declarations; the name of the candidate node is customer;
the element declaration of customer is not abstract; the type
annotation of the candidate node is the same as or derived from the
schema type declared in the customer element declaration; and
either the candidate node is not nilled, or customer is declared to
be nillable.</p>
</li>
<li>
<p>customer is a top-level element declaration in the in-scope
element declarations; the name of the candidate node is client;
client is an actual (non-abstract and non-blocked) member of the
substitution group of customer; the type annotation of the
candidate node is the same as or derived from the schema type
declared for the client element; and either the candidate node is
not nilled, or client is declared to be nillable.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-attribute-test" id="id-attribute-test"></a>2.5.5.5
Attribute Test</h5>
<h5><a name="d2e7488" id="d2e7488"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AttributeTest" id=
"doc-xquery30-AttributeTest"></a>[179]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xquery30-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AttribNameOrWildcard" id=
"doc-xquery30-AttribNameOrWildcard"></a>[180]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e7116.doc-xquery30-AttributeName" id=
"noid_d3e7116.doc-xquery30-AttributeName"></a>[187]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e7117.doc-xquery30-TypeName" id=
"noid_d3e7117.doc-xquery30-TypeName"></a>[190]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>An <a href="#doc-xquery30-AttributeTest">AttributeTest</a> is
used to match an attribute node by its name and/or <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
<p>The <a href="#doc-xquery30-AttributeName">AttributeName</a> and
<a href="#doc-xquery30-TypeName">TypeName</a> of an <a href=
"#doc-xquery30-AttributeTest">AttributeTest</a> have their prefixes
expanded to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If
unprefixed, the <a href=
"#doc-xquery30-AttributeName">AttributeName</a> is in no namespace,
but an unprefixed <a href="#doc-xquery30-TypeName">TypeName</a> is
in the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
<a href="#doc-xquery30-AttributeName">AttributeName</a> need not be
present in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, but the
<a href="#doc-xquery30-TypeName">TypeName</a> must be present in
the <a title="in-scope schema type" href="#dt-is-types">in-scope
schema types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>].</p>
<p>An <a href="#doc-xquery30-AttributeTest">AttributeTest</a> may
take any of the following forms:</p>
<ol class="enumar">
<li>
<p><code>attribute()</code> and <code>attribute(*)</code> match any
single attribute node, regardless of its name or type
annotation.</p>
</li>
<li>
<p><code>attribute(</code> <a href=
"#doc-xquery30-AttributeName">AttributeName</a> <code>)</code>
matches any attribute node whose name is <a href=
"#doc-xquery30-AttributeName">AttributeName</a>, regardless of its
type annotation.</p>
<p>Example: <code>attribute(price)</code> matches any attribute
node whose name is <code>price</code>.</p>
</li>
<li>
<p><code>attribute(</code> <a href=
"#doc-xquery30-AttributeName">AttributeName</a>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> matches an
attribute node whose name is <a href=
"#doc-xquery30-AttributeName">AttributeName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is <code>currency</code> (or is derived from
<code>currency</code>).</p>
</li>
<li>
<p><code>attribute(*,</code> <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> matches an
attribute node regardless of its name, if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xquery30-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(*, currency)</code> matches any
attribute node whose type annotation is <code>currency</code> (or
is derived from <code>currency</code>), regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-attribute-test" id=
"id-schema-attribute-test"></a>2.5.5.6 Schema Attribute Test</h5>
<h5><a name="d2e7706" id="d2e7706"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SchemaAttributeTest" id=
"doc-xquery30-SchemaAttributeTest"></a>[181]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xquery30-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AttributeDeclaration" id=
"doc-xquery30-AttributeDeclaration"></a>[182]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e7303.doc-xquery30-AttributeName" id=
"noid_d3e7303.doc-xquery30-AttributeName"></a>[187]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a> matches
an attribute node against a corresponding attribute declaration
found in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>.</p>
<p>The <a href="#doc-xquery30-AttributeName">AttributeName</a> of a
<a href="#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a>
has its prefixes expanded to a namespace URI by means of the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If
unprefixed, an <a href=
"#doc-xquery30-AttributeName">AttributeName</a> is in no namespace.
If the <a href="#doc-xquery30-AttributeName">AttributeName</a>
specified in the <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a> is not
found in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a> matches
a candidate attribute node if both of the following conditions are
satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href=
"#doc-xquery30-AttributeName">AttributeName</a>.</p>
</li>
<li>
<p><code>derives-from(</code> <em>AT, ET</em> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
candidate node and <em>ET</em> is the schema type declared for
attribute <a href="#doc-xquery30-AttributeName">AttributeName</a>
in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a>
<code>schema-attribute(color)</code> matches a candidate attribute
node if <code>color</code> is a top-level attribute declaration in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, the name of the
candidate node is <code>color</code>, and the type annotation of
the candidate node is the same as or derived from the schema type
declared for the <code>color</code> attribute.</p>
</div>
<div class="div4">
<h5><a name="id-function-test" id="id-function-test"></a>2.5.5.7
Function Test</h5>
<h5><a name="d2e7833" id="d2e7833"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FunctionTest" id=
"doc-xquery30-FunctionTest"></a>[191]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FunctionTest">FunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Annotation">Annotation</a>*
(<a href="#doc-xquery30-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AnyFunctionTest" id=
"doc-xquery30-AnyFunctionTest"></a>[192]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AnyFunctionTest">AnyFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TypedFunctionTest" id=
"doc-xquery30-TypedFunctionTest"></a>[193]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypedFunctionTest">TypedFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#doc-xquery30-SequenceType">SequenceType</a> ("," <a href=
"#doc-xquery30-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href="#doc-xquery30-FunctionTest">FunctionTest</a> matches
a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>,
potentially also checking its <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-signature">function
signature</a><sup><small>DM30</small></sup> <span class=
"xquery">and annotations (see <a href="#id-annotations"><b>4.15
Annotations</b></a>)</span>. An <a href=
"#doc-xquery30-AnyFunctionTest">AnyFunctionTest</a> matches any
item that is a function. A <a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a> matches an
item if it is a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
and the function's type signature (as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#function-items">Section
2.8.1 Functions</a> <sup><small>DM30</small></sup>) is a <a title=
"subtype" href="#dt-subtype">subtype</a> of the <a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a>.</p>
<p>Here are some examples of <a href=
"#doc-xquery30-FunctionTest">FunctionTest</a>s:</p>
<ol class="enumar">
<li>
<p><code>function(*)</code> matches any <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>.</p>
</li>
<li>
<p><code>%assertion function(*)</code> matches any <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
if the implementation-defined function assertion
<code>%assertion</code> is satisfied.</p>
</li>
<li>
<p><code>function(int, int) as int</code> matches any <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
with the function signature <code>function(int, int) as
int</code>.</p>
</li>
<li>
<p><code>%assertion function(int, int) as int</code> matches any
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
with the function signature <code>function(int, int) as int</code>
if the implementation-defined function assertion
<code>%assertion</code> is satisfied.</p>
</li>
</ol>
<p id="id-function-assertion" class="xquery">[<a name=
"dt-function-assertion" id="dt-function-assertion" title=
"function assertion">Definition</a>: A <b>function assertion</b> is
a predicate that restricts the set of functions matched by a
FunctionTest. It uses the same syntax as <a href=
"#id-annotations"><b>4.15 Annotations</b></a>.] XQuery 3.0 does not
currently define any function assertions, but future versions may.
Other specifications in the XQuery family may also use function
assertions in the future.</p>
<p class="xquery">Implementations are free to define their own
function assertions, whose behavior is completely
implementation-defined. Implementations may also provide a way for
users to create their own function assertions.</p>
<p class="xquery">An implementation may raise
implementation-defined errors or warnings for function assertions,
e.g. if the parameters are not correct for a given assertion. If a
function assertion is not recognized by an implementation, it is
ignored, and has no effect on the semantics of the function
test.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation is free to raise warnings for function
assertions that it does not recognize.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although function assertions use the same syntax as annotations,
they are not directly related to annotations. If an implementation
defines the annotation <code>blue</code> and uses it in function
declarations, there is no guarantee that it will also define a
function assertion <code>blue</code>, or that a function assertion
named <code>blue</code> matches a function declared with the
annotation <code>blue</code>. Of course, an implementation that
does so may be more intuitive to users.</p>
</div>
<p class="xquery">Implementations must not define function
assertions in the following reserved namespaces; it is an error for
users to create function assertions in the following reserved
namespaces [<a href="#ERRXQST0045" title=
"err:XQST0045">err:XQST0045</a>]:</p>
<ul>
<li>
<p>http://www.w3.org/XML/1998/namespace</p>
</li>
<li>
<p>http://www.w3.org/2001/XMLSchema</p>
</li>
<li>
<p>http://www.w3.org/2001/XMLSchema-instance</p>
</li>
<li>
<p>http://www.w3.org/2005/xpath-functions</p>
</li>
<li>
<p>http://www.w3.org/2005/xpath-functions/math</p>
</li>
<li>
<p>http://www.w3.org/2012/xquery</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-sequencetype-subtype" id=
"id-sequencetype-subtype"></a>2.5.6 SequenceType Subtype
Relationships</h4>
<p>Given two <a title="sequence type" href=
"#dt-sequence-type">sequence types</a>, it is possible to determine
if one is a subtype of the other. [<a name="dt-subtype" id=
"dt-subtype" title="subtype">Definition</a>: A <a title=
"sequence type" href="#dt-sequence-type">sequence type</a>
<code>A</code> is a <b>subtype</b> of a sequence type
<code>B</code> if the judgement <code>subtype(A, B)</code> is
true.] When the judgement <code>subtype(A, B)</code> is true, it is
always the case that for any value <code>V</code>, <code>(V
instance of A)</code> implies <code>(V instance of B)</code>.</p>
<div class="div4">
<h5><a name="id-seqtype-subtype" id=
"id-seqtype-subtype"></a>2.5.6.1 The judgement <code>subtype(A,
B)</code></h5>
<p>The judgement <code>subtype(A, B)</code> determines if the
<a title="sequence type" href="#dt-sequence-type">sequence type</a>
<code>A</code> is a <a title="subtype" href=
"#dt-subtype">subtype</a> of the sequence type <code>B</code>.
<code>A</code> can either be <code>empty-sequence()</code> <span>,
<code>xs:error</code>,</span> or an <a href=
"#doc-xquery30-ItemType">ItemType</a>, <code>Ai</code>, possibly
followed by an occurrence indicator. Similarly <code>B</code> can
either be <code>empty-sequence()</code> <span>,
<code>xs:error</code>,</span> or an <a href=
"#doc-xquery30-ItemType">ItemType</a>, <code>Bi</code>, possibly
followed by an occurrence indicator. The result of the
<code>subtype(A, B)</code> judgement can be determined from the
table below, which makes use of the auxiliary judgement
<code>subtype-itemtype(Ai, Bi)</code> defined in <a href=
"#id-itemtype-subtype"><b>2.5.6.2 The judgement
subtype-itemtype(Ai, Bi)</b></a> .</p>
<table border="1" summary="Special characters">
<tbody>
<tr>
<th rowspan="2" colspan="2"></th>
<th colspan="6"><a title="sequence type" href=
"#dt-sequence-type">Sequence type</a> <code>B</code></th>
</tr>
<tr>
<th colspan="1"><code>empty-sequence()</code></th>
<th colspan="1"><code>Bi?</code></th>
<th colspan="1"><code>Bi*</code></th>
<th colspan="1"><code>Bi</code></th>
<th colspan="1"><code>Bi+</code></th>
<td>xs:error</td>
</tr>
<tr>
<th rowspan="6" colspan="1"><a title="sequence type" href=
"#dt-sequence-type">Sequence type</a> <code>A</code></th>
<th colspan="1"><code>empty-sequence()</code></th>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai?</code></th>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai*</code></th>
<td>false</td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai</code></th>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai+</code></th>
<td>false</td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>xs:error</code></th>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><code>xs:error+</code> is treated the same way as
<code>xs:error</code> in the above table. <code>xs:error?</code>
and <code>xs:error*</code> are treated the same way as
<code>empty-sequence()</code>.</p>
</div>
<div class="div4">
<h5><a name="id-itemtype-subtype" id=
"id-itemtype-subtype"></a>2.5.6.2 The judgement
<code>subtype-itemtype(Ai, Bi)</code></h5>
<p>The judgement <code>subtype-itemtype(Ai, Bi)</code> determines
if the <a href="#doc-xquery30-ItemType">ItemType</a>
<code>Ai</code> is a <a title="subtype" href=
"#dt-subtype">subtype</a> of the ItemType <code>Bi</code>.
<code>Ai</code> is a subtype of <code>Bi</code> if and only if at
least one of the following conditions applies:</p>
<ol class="enumar">
<li>
<p><code>Ai</code> and <code>Bi</code> are <a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionTypes</a>, and
<code>derives-from(Ai, Bi)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Ai</code> is a pure union type, and every type
<code>t</code> in the transitive membership of <code>Ai</code>
satisfies <code>subtype-itemType(t, Bi)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>xs:error</code> and <code>Bi</code> is
a <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a>.</p>
</li>
<li>
<p><code>Bi</code> is <code>item()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>node()</code>, and <code>Ai</code> is a
<a href="#doc-xquery30-KindTest">KindTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is <code>text()</code> and <code>Ai</code> is
also <code>text()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>comment()</code> and <code>Ai</code> is
also <code>comment()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>namespace-node()</code> and
<code>Ai</code> is also <code>namespace-node()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>processing-instruction()</code> and
<code>Ai</code> is either <code>processing-instruction()</code> or
<code>processing-instruction(N)</code> for any name N.</p>
</li>
<li>
<p><code>Bi</code> is <code>processing-instruction(Bn)</code>, and
<code>Ai</code> is also
<code>processing-instruction(Bn)</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>document-node()</code> and
<code>Ai</code> is either <code>document-node()</code> or
<code>document-node(E)</code> for any <a href=
"#doc-xquery30-ElementTest">ElementTest</a> E.</p>
</li>
<li>
<p><code>Bi</code> is <code>document-node(Be)</code> and
<code>Ai</code> is <code>document-node(Ae)</code>, and
<code>subtype-itemtype(Ae, Be)</code>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>element()</code> or
<code>element(*)</code>, and <code>Ai</code> is an <a href=
"#doc-xquery30-ElementTest">ElementTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>element(Bn)</code> or
<code>element(Bn, xs:anyType?)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>, and
<code>Ai</code> is either <code>element(An)</code>, or
<code>element(An, T?)</code> for any type T.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(Bn, Bt)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is <code>element(An, At)</code>, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(Bn, Bt?)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is either <code>element(An, At)</code> or
<code>element(An, At?)</code>, and <code>derives-from(At,
Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(*, Bt)</code>, <code>Ai</code>
is either <code>element(*, At)</code> or <code>element(N,
At)</code> for any name N, and <code>derives-from(At, Bt)</code>
returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(*, Bt?)</code>, <code>Ai</code>
is either <code>element(*, At)</code>, <code>element(*,
At?)</code>, <code>element(N, At)</code>, or <code>element(N,
At?)</code> for any name N, and <code>derives-from(At, Bt)</code>
returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>schema-element(Bn)</code>,
<code>Ai</code> is <code>schema-element(An)</code>, and every
element declaration that is an actual member of the substitution
group of <code>An</code> is also an actual member of the
substitution group of <code>Bn</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The fact that <code>P</code> is a member of the substitution
group of <code>Q</code> does not mean that every element
declaration in the substitution group of <code>P</code> is also in
the substitution group of <code>Q</code>. For example,
<code>Q</code> might block substitution of elements whose type is
derived by extension, while <code>P</code> does not.</p>
</div>
</li>
<li>
<p><code>Bi</code> is either <code>attribute()</code> or
<code>attribute(*)</code>, and <code>Ai</code> is an <a href=
"#doc-xquery30-AttributeTest">AttributeTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>attribute(Bn)</code> or
<code>attribute(Bn, xs:anyType)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>, and
<code>Ai</code> is either <code>attribute(An)</code>, or
<code>attribute(An, T)</code> for any type T.</p>
</li>
<li>
<p><code>Bi</code> is <code>attribute(Bn, Bt)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is <code>attribute(An, At)</code>, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>attribute(*, Bt)</code>,
<code>Ai</code> is either <code>attribute(*, At)</code>, or
<code>attribute(N, At)</code> for any name N, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>schema-attribute(Bn)</code>, the
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of <code>An</code> equals the <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
and <code>Ai</code> is <code>schema-attribute(An)</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code><span class=
"xquery">[AnnotationsB]</span> function(*)</code> <span class=
"xquery">, <code>Ai</code> is a <a href=
"#doc-xquery30-FunctionTest">FunctionTest</a> with annotations
<code>[AnnotationsA]</code>, and
<code>subtype-assertions(AnnotationsA, AnnotationsB)</code> <span>,
where <code>[AnnotationsB]</code> and <code>[AnnotationsA]</code>
are optional lists of one or more annotations</span></span> .</p>
</li>
<li>
<p><code>Bi</code> is <code><span class=
"xquery">AnnotationsB</span> function(Ba_1, Ba_2, ... Ba_N) as
Br</code>, <code>Ai</code> is <code><span class=
"xquery">AnnotationsA</span> function(Aa_1, Aa_2, ... Aa_M) as
Ar</code>, where <span class="xquery"><code>[AnnotationsB]</code>
and <code>[AnnotationsA]</code> are optional lists of one or more
annotations</span>; <code>N</code> (arity of Bi) equals
<code>M</code> (arity of Ai); <code>subtype(Ar, Br)</code>; for
values of <code>I</code> between 1 and <code>N</code>,
<code>subtype(Ba_I, Aa_I)</code> <span class="xquery">; and
<code>subtype-assertions(AnnotationsA, AnnotationsB)</code></span>
.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Function return types are covariant because this rule invokes
subtype(Ar, Br) for return types. Function arguments are
contravariant because this rule invokes subtype(Ba_I, Aa_I) for
arguments.</p>
</div>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-assertions-subtype" id=
"id-assertions-subtype"></a>2.5.6.3 The judgement
<code>subtype-assertions(AnnotationsA, AnnotationsB)</code></h5>
<p>The judgement <code>subtype-assertions(AnnotationsA,
AnnotationsB)</code> determines if <code>AnnotationsA</code> is a
subtype of <code>AnnotationsB</code>, where
<code>AnnotationsA</code> and <code>AnnotationsB</code> are
annotation lists from two FunctionTests. It is defined to ignore
<span>function</span> assertions in namespaces not understood by
the XQuery implementation. For assertions that are understood,
their effect on the result of <code>subtype-assertions()</code> is
implementation defined.</p>
<p>The following examples are some possible ways to define
<code>subtype-assertions()</code> for some implementation defined
assertions in the <code>local</code> namespace. These examples
assume that some implementation uses annotations to label functions
as deterministic or nondeterministic, and treats deterministic
functions as a subset of nondeterministic functions. In this
implementation, nondeterministic functions are not a subset of
deterministic functions.</p>
<ul>
<li>
<p>AnnotationsA is</p>
<div class="exampleInner">
<pre>
%local:inline
</pre></div>
<p>It has no influence on the outcome of
<code>subtype-assertions()</code>.</p>
</li>
<li>
<p>AnnotationsA is</p>
<div class="exampleInner">
<pre>
%local:deterministic
</pre></div>
<p>AnnotationsB is</p>
<div class="exampleInner">
<pre>
%local:nondeterministic
</pre></div>
<p>Since deterministic functions are a subset of nondeterministic
functions, <code>subtype-assertions()</code> is true.</p>
</li>
<li>
<p>AnnotationsA contains</p>
<div class="exampleInner">
<pre>
%local:nondeterministic
</pre></div>
<p>AnnotationsB is empty. If FunctionTests without the
<code>%local:nondeterministic</code> annotation only match
deterministic functions, <code>subtype-assertions()</code> must be
false.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-xs-error" id="id-xs-error"></a>2.5.7 xs:error</h4>
<p>The type <code>xs:error</code> has an empty value space; it
never appears as a dynamic type or as the content type of a dynamic
element or attribute type. <code>xs:error</code> offers an
alternative way of raising errors, in addition to fn:error.</p>
<p>A cast to <code>xs:error</code> raises an error or returns the
empty sequence. Promotion to <code>xs:error</code> is not possible.
Neither <code>xs:error</code> nor <code>xs:error+</code> can ever
match a value. <code>xs:error</code> is a subtype of all simple
types, and a supertype only of itself. <code>xs:error?</code> and
<code>xs:error*</code> are identical to empty-sequence(). A
variable binding with a type declaration xs:error always raises a
type error. .</p>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>2.6 Comments</h3>
<h5><a name="d2e9240" id="d2e9240"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Comment" id=
"doc-xquery30-Comment"></a>[209]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#doc-xquery30-CommentContents">CommentContents</a> | <a href=
"#doc-xquery30-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CommentContents" id=
"doc-xquery30-CommentContents"></a>[217]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>Comments may be used to provide <span>information relevant to
programmers who read</span> <span class="xquery">a query, either in
the <a title="Prolog" href="#dt-prolog">Prolog</a> or in the
<a title="query body" href="#dt-queryBody">Query Body</a></span> .
Comments are lexical constructs only, and do not affect
<span class="xquery">query</span> processing.</p>
<p>Comments are strings, delimited by the symbols <code>(:</code>
and <code>:)</code>. Comments may be nested.</p>
<p>A comment may be used anywhere <a title="ignorable whitespace"
href="#IgnorableWhitespace">ignorable whitespace</a> is allowed
(see <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default
Whitespace Handling</b></a>).</p>
<p>The following is an example of a comment:</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>3
Expressions</h2>
<p>This section discusses each of the basic kinds of expression.
Each kind of expression has a name such as <code>PathExpr</code>,
which is introduced on the left side of the grammar production that
defines the expression. Since XQuery 3.0 is a composable language,
each kind of expression is defined in terms of other expressions
whose operators have a higher precedence. In this way, the
precedence of operators is represented explicitly in the
grammar.</p>
<p>The order in which expressions are discussed in this document
does not reflect the order of operator precedence. In general, this
document introduces the simplest kinds of expressions first,
followed by more complex expressions. For the complete grammar, see
Appendix [<a href="#nt-bnf"><b>A XQuery 3.0 Grammar</b></a>].</p>
<p><span class="xquery">[<a name="dt-query" id="dt-query" title=
"query">Definition</a>: A <b>query</b> consists of one or more
<a title="module" href="#dt-module">modules</a>.] If a query is
executable, one of its modules has a <a title="query body" href=
"#dt-queryBody">Query Body</a> containing an expression whose value
is the result of the query. An expression is represented in the
XQuery grammar by the symbol <a href=
"#doc-xquery30-Expr">Expr</a>.</span></p>
<h5><a name="d2e9332" id="d2e9332"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Expr" id=
"doc-xquery30-Expr"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery30-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ExprSingle" id=
"doc-xquery30-ExprSingle"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FLWORExpr">FLWORExpr</a><br />
| <a href="#doc-xquery30-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xquery30-SwitchExpr">SwitchExpr</a><br />
| <a href="#doc-xquery30-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#doc-xquery30-IfExpr">IfExpr</a><br />
| <a href="#doc-xquery30-TryCatchExpr">TryCatchExpr</a><br />
| <a href="#doc-xquery30-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p>The XQuery 3.0 operator that has lowest precedence is the
<a title="comma operator" href="#dt-comma-operator">comma
operator</a>, which is used to combine two operands to form a
sequence. As shown in the grammar, a general expression (<a href=
"#doc-xquery30-Expr">Expr</a>) can consist of multiple <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> operands, separated by
commas. The name <a href="#doc-xquery30-ExprSingle">ExprSingle</a>
denotes an expression that does not contain a top-level <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>
(despite its name, an <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> may evaluate to a
sequence containing more than one item.)</p>
<p>The symbol <a href="#doc-xquery30-ExprSingle">ExprSingle</a> is
used in various places in the grammar where an expression is not
allowed to contain a top-level comma. For example, each of the
arguments of a function call must be an <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a>, because commas are used
to separate the arguments of a function call.</p>
<p>After the comma, the expressions that have next lowest
precedence are <span class="xquery"><a href=
"#doc-xquery30-FLWORExpr">FLWORExpr</a>,</span> <a href=
"#doc-xquery30-QuantifiedExpr">QuantifiedExpr</a>, <span class=
"xquery"><a href="#doc-xquery30-SwitchExpr">SwitchExpr</a>,
<a href="#doc-xquery30-TypeswitchExpr">TypeswitchExpr</a>,</span>
<a href="#doc-xquery30-IfExpr">IfExpr</a>, <span class=
"xquery"><a href=
"#doc-xquery30-TryCatchExpr">TryCatchExpr</a>,</span> and <a href=
"#doc-xquery30-OrExpr">OrExpr</a>. Each of these expressions is
described in a separate section of this document.</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>3.1 Primary Expressions</h3>
<p>[<a name="dt-primary-expression" id="dt-primary-expression"
title="primary expression">Definition</a>: <b>Primary
expressions</b> are the basic primitives of the language. They
include literals, variable references, context item expressions,
<span class="xquery">constructors,</span> and function calls. A
primary expression may also be created by enclosing any expression
in parentheses, which is sometimes helpful in controlling the
precedence of operators.] <span class="xquery">Constructors are
described in <a href="#id-constructors"><b>3.9
Constructors</b></a>.</span></p>
<h5><a name="d2e9466" id="d2e9466"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PrimaryExpr" id=
"doc-xquery30-PrimaryExpr"></a>[124]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Literal">Literal</a><br />
| <a href="#doc-xquery30-VarRef">VarRef</a><br />
| <a href=
"#doc-xquery30-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#doc-xquery30-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#doc-xquery30-FunctionCall">FunctionCall</a><br />
| <a href="#doc-xquery30-OrderedExpr">OrderedExpr</a><br />
| <a href="#doc-xquery30-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#doc-xquery30-Constructor">Constructor</a><br />
| <a href=
"#doc-xquery30-FunctionItemExpr">FunctionItemExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FunctionItemExpr" id=
"doc-xquery30-FunctionItemExpr"></a>[163]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FunctionItemExpr">FunctionItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#doc-xquery30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>3.1.1 Literals</h4>
<p>[<a name="dt-literal" id="dt-literal" title=
"literal">Definition</a>: A <b>literal</b> is a direct syntactic
representation of an atomic value.] XQuery 3.0 supports two kinds
of literals: numeric literals and string literals.</p>
<h5><a name="d2e9540" id="d2e9540"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Literal" id=
"doc-xquery30-Literal"></a>[125]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NumericLiteral">NumericLiteral</a>
| <a href=
"#doc-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NumericLiteral" id=
"doc-xquery30-NumericLiteral"></a>[126]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-IntegerLiteral">IntegerLiteral</a>
| <a href="#doc-xquery30-DecimalLiteral">DecimalLiteral</a> |
<a href="#doc-xquery30-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-IntegerLiteral" id=
"doc-xquery30-IntegerLiteral"></a>[197]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DecimalLiteral" id=
"doc-xquery30-DecimalLiteral"></a>[198]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xquery30-Digits">Digits</a>) |
(<a href="#doc-xquery30-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DoubleLiteral" id=
"doc-xquery30-DoubleLiteral"></a>[199]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xquery30-Digits">Digits</a>) |
(<a href="#doc-xquery30-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#doc-xquery30-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-StringLiteral" id=
"doc-xquery30-StringLiteral"></a>[200]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href=
"#doc-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#doc-xquery30-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') | ("'"
(<a href=
"#doc-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#doc-xquery30-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PredefinedEntityRef" id=
"doc-xquery30-PredefinedEntityRef"></a>[203]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-EscapeQuot" id=
"doc-xquery30-EscapeQuot"></a>[204]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-EscapeApos" id=
"doc-xquery30-EscapeApos"></a>[205]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Digits" id=
"doc-xquery30-Digits"></a>[216]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p>The value of a <b>numeric literal</b> containing no
"<code>.</code>" and no <code>e</code> or <code>E</code> character
is an atomic value of type <code>xs:integer</code>. The value of a
numeric literal containing "<code>.</code>" but no <code>e</code>
or <code>E</code> character is an atomic value of type
<code>xs:decimal</code>. The value of a numeric literal containing
an <code>e</code> or <code>E</code> character is an atomic value of
type <code>xs:double</code>. The value of the numeric literal is
determined by casting it to the appropriate type according to the
rules for casting from <code>xs:untypedAtomic</code> to a numeric
type as specified in <a href=
"http://www.w3.org/TR/xpath-functions-30/#casting-from-strings">Section
18.2 Casting from xs:string and xs:untypedAtomic</a>
<sup><small>FO30</small></sup>.</p>
<p id="id-string-literal">The value of a <b>string literal</b> is
an atomic value whose type is <code>xs:string</code> and whose
value is the string denoted by the characters between the
delimiting apostrophes or quotation marks. If the literal is
delimited by apostrophes, two adjacent apostrophes within the
literal are interpreted as a single apostrophe. Similarly, if the
literal is delimited by quotation marks, two adjacent quotation
marks within the literal are interpreted as one quotation mark.</p>
<p class="xquery">A string literal may contain a <b>predefined
entity reference</b>. [<a name="dt-predefined-entity-reference" id=
"dt-predefined-entity-reference" title=
"predefined entity reference">Definition</a>: A <b>predefined
entity reference</b> is a short sequence of characters, beginning
with an ampersand, that represents a single character that might
otherwise have syntactic significance.] Each predefined entity
reference is replaced by the character it represents when the
string literal is processed. The predefined entity references
recognized by XQuery are as follows:</p>
<table width="60%" border="1" class="xquery" summary=
"Special characters">
<tbody>
<tr>
<td align="center">Entity Reference</td>
<td align="center">Character Represented</td>
</tr>
<tr>
<td align="center"><code>&amp;lt;</code></td>
<td align="center"><code>&lt;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;gt;</code></td>
<td align="center"><code>&gt;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;amp;</code></td>
<td align="center"><code>&amp;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;quot;</code></td>
<td align="center"><code>"</code></td>
</tr>
<tr>
<td align="center"><code>&amp;apos;</code></td>
<td align="center"><code>'</code></td>
</tr>
</tbody>
</table>
<p class="xquery">A string literal may also contain a <b>character
reference</b>. [<a name="dt-character-reference" id=
"dt-character-reference" title=
"character reference">Definition</a>: A <b>character reference</b>
is an XML-style reference to a <a href="#Unicode">[Unicode]</a>
character, identified by its decimal or hexadecimal codepoint.] For
example, the Euro symbol (€) can be represented by the character
reference <code>&amp;#8364;</code>. Character references are
normatively defined in Section 4.1 of the XML specification (it is
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> whether the
rules in <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML
1.1]</a> apply.) A <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0090" title=
"err:XQST0090">err:XQST0090</a>] is raised if a character reference
does not identify a valid character in the version of XML that is
in use.</p>
<p>Here are some examples of literal expressions:</p>
<ul>
<li>
<p><code>"12.5"</code> denotes the string containing the characters
'1', '2', '.', and '5'.</p>
</li>
<li>
<p><code>12</code> denotes the <code>xs:integer</code> value
twelve.</p>
</li>
<li>
<p><code>12.5</code> denotes the <code>xs:decimal</code> value
twelve and one half.</p>
</li>
<li>
<p><code>125E2</code> denotes the <code>xs:double</code> value
twelve thousand, five hundred.</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code> denotes a string
containing two quotation marks and one apostrophe.</p>
</li>
<li>
<p><code>"Ben &amp;amp; Jerry&amp;apos;s"</code> denotes the
<code>xs:string</code> value "<code>Ben &amp; Jerry's</code>".</p>
</li>
<li>
<p><code>"&amp;#8364;99.50"</code> denotes the
<code>xs:string</code> value "<code>€99.50</code>".</p>
</li>
</ul>
<p>The <code>xs:boolean</code> values <code>true</code> and
<code>false</code> can be constructed by calls to the <a title=
"built-in function" href="#dt-built-in-function">built-in
functions</a> <code>fn:true()</code> and <code>fn:false()</code>,
respectively.</p>
<p>Values of other atomic types can be constructed by calling the
<a title="constructor function" href=
"#dt-constructor-function">constructor function</a> for the given
type. The constructor functions for XML Schema built-in types are
defined in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>. In general, the name of a
constructor function for a given type is the same as the name of
the type (including its namespace). For example:</p>
<ul>
<li>
<p><code>xs:integer("12")</code> returns the integer value
twelve.</p>
</li>
<li>
<p><code>xs:date("2001-08-25")</code> returns an item whose type is
<code>xs:date</code> and whose value represents the date 25th
August 2001.</p>
</li>
<li>
<p><code>xs:dayTimeDuration("PT5H")</code> returns an item whose
type is <code>xs:dayTimeDuration</code> and whose value represents
a duration of five hours.</p>
</li>
</ul>
<p>Constructor functions can also be used to create special values
that have no literal representation, as in the following
examples:</p>
<ul>
<li>
<p><code>xs:float("NaN")</code> returns the special floating-point
value, "Not a Number."</p>
</li>
<li>
<p><code>xs:double("INF")</code> returns the special
double-precision value, "positive infinity."</p>
</li>
</ul>
<p>Constructor functions are available for all <a title=
"generalized atomic type" href=
"#dt-generalized-atomic-type">Generalized atomic types</a>,
including union types. For example, if <code>my:dt</code> is a
user-defined union type whose member types are
<code>xs:date</code>, <code>xs:time</code>, and
<code>xs:dateTime</code>, then the expression
<code>my:dt("2011-01-10")</code> creates an atomic value of type
<code>xs:date</code>. The rules follow XML Schema validation rules
for union types: the effect is to choose the first member type that
accepts the given string in its lexical space.</p>
<p>It is also possible to construct values of various types by
using a <code>cast</code> expression. For example:</p>
<ul>
<li>
<p><code>9 cast as hatsize</code> returns the atomic value
<code>9</code> whose type is <code>hatsize</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>3.1.2 Variable
References</h4>
<h5><a name="d2e9980" id="d2e9980"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VarRef" id=
"doc-xquery30-VarRef"></a>[127]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VarName" id=
"doc-xquery30-VarName"></a>[128]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-variable-reference" id="dt-variable-reference"
title="variable reference">Definition</a>: A <b>variable
reference</b> is an EQName preceded by a $-sign.] An unprefixed
variable reference is in no namespace. <span>Two variable
references are equivalent if their <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> are equal (as defined by
the <code>eq</code> operator).</span> The scope of a variable
binding is defined separately for each kind of expression that can
bind variables.</p>
<p>Every variable reference must match a name in the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a>.</p>
<p>Every variable binding has a static scope. The scope defines
where references to the variable can validly occur. It is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] to
reference a variable that is not in scope. If a variable is bound
in the <a title="static context" href="#dt-static-context">static
context</a> for an expression, that variable is in scope for the
entire expression <span>except where it is occluded by another
binding that uses the same name within that scope</span>.</p>
<p class="xquery">A reference to a variable that was declared
<code>external</code>, but was not bound to a value by the external
environment, raises a dynamic error [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
<p>At evaluation time, the value of a variable reference is the
value to which the relevant variable is bound.</p>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>3.1.3 Parenthesized Expressions</h4>
<h5><a name="d2e10099" id="d2e10099"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ParenthesizedExpr" id=
"doc-xquery30-ParenthesizedExpr"></a>[129]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xquery30-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
</table>
<p>Parentheses may be used to override the precedence rules. For
example, the expression <code>(2 + 4) * 5</code> evaluates to
thirty, since the parenthesized expression <code>(2 + 4)</code> is
evaluated first and its result is multiplied by five. Without
parentheses, the expression <code>2 + 4 * 5</code> evaluates to
twenty-two, because the multiplication operator has higher
precedence than the addition operator.</p>
<p>Empty parentheses are used to denote an empty sequence, as
described in <a href="#construct_seq"><b>3.4.1 Constructing
Sequences</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>3.1.4 Context Item Expression</h4>
<h5><a name="d2e10127" id="d2e10127"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ContextItemExpr" id=
"doc-xquery30-ContextItemExpr"></a>[130]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p>A <b>context item expression</b> evaluates to the <a title=
"context item" href="#dt-context-item">context item</a>, which may
be either a node (as in the expression
<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>),
or an atomic value or function (as in the expression <code>(1 to
100)[. mod 5 eq 0]</code>).</p>
<p>If the <a title="context item" href="#dt-context-item">context
item</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>,
a context item expression raises a dynamic error [<a href=
"#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</p>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>3.1.5
<span>Static</span> Function Calls</h4>
<p>[<a name="dt-built-in-function" id="dt-built-in-function" title=
"built-in function">Definition</a>: The <b>built-in functions</b>
supported by XQuery 3.0 are defined in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.] <span class="xquery">Additional functions may be
declared in a <a title="Prolog" href="#dt-prolog">Prolog</a>,
imported from a <a title="library module" href=
"#dt-library-module">library module</a>, or provided by the
external environment as part of the <a title="static context" href=
"#dt-static-context">static context</a>.</span></p>
<h5><a name="d2e10191" id="d2e10191"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FunctionCall" id=
"doc-xquery30-FunctionCall"></a>[133]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a> <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9492.doc-xquery30-ArgumentList" id=
"noid_d3e9492.doc-xquery30-ArgumentList"></a>[121]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xquery30-Argument">Argument</a> (","
<a href="#doc-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Argument" id=
"doc-xquery30-Argument"></a>[134]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Argument">Argument</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a> |
<a href=
"#doc-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ArgumentPlaceholder" id=
"doc-xquery30-ArgumentPlaceholder"></a>[135]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-static-function-call" id="dt-static-function-call"
title="static function call">Definition</a>: A
<b><span>static</span> function call</b> consists of an EQName
followed by a parenthesized list of zero or more arguments.]
[<a name="dt-arg-expr" id="dt-arg-expr" title=
"argument expression">Definition</a>: An argument to a function
call is either an <b>argument expression</b> or an
ArgumentPlaceholder ("?").] If the EQName in a <span>static</span>
function call <span>is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> that</span> has no namespace prefix,
it is considered to be in the <a title="default function namespace"
href="#dt-def-fn-ns">default function namespace.</a></p>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and number of arguments in
a <span>static</span> function call do not match the name and arity
of a <a title="statically known function signatures" href=
"#dt-known-func-signatures">function signature</a> in the <a title=
"static context" href="#dt-static-context">static context</a>, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXPST0017" title=
"err:XPST0017">err:XPST0017</a>].</p>
<p>[<a name="dt-partial-function-application" id=
"dt-partial-function-application" title=
"partial function application">Definition</a>: A <span>static or
<a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic</a></span> function call
is a <b>partial function application</b> if one or more arguments
is an ArgumentPlaceholder. ]</p>
<p>Evaluation of function calls is described in <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a> .</p>
<p>Since the arguments of a function call are separated by commas,
any <a title="argument expression" href="#dt-arg-expr">argument
expression</a> that contains a top-level <a title="comma operator"
href="#dt-comma-operator">comma operator</a> must be enclosed in
parentheses. Here are some illustrative examples of
<span>static</span> function calls:</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2, 3)</code> denotes a
<span>static</span> function call with three arguments.</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2), 3)</code> denotes a
<span>static</span> function call with two arguments, the first of
which is a sequence of two values.</p>
</li>
<li>
<p><code>my:two-argument-function(1, ())</code> denotes a
<span>static</span> function call with two arguments, the second of
which is an empty sequence.</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2, 3))</code> denotes a
<span>static</span> function call with one argument that is a
sequence of three values.</p>
</li>
<li>
<p><code>my:one-argument-function(( ))</code> denotes a
<span>static</span> function call with one argument that is an
empty sequence.</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code> denotes a
<span>static</span> function call with zero arguments.</p>
</li>
</ul>
<div class="div4">
<h5><a name="id-eval-function-call" id=
"id-eval-function-call"></a>3.1.5.1 Evaluating <span>Static and
Dynamic</span> Function Calls</h5>
<p>When a static or dynamic function call <var>FC</var> is
evaluated with respect to <span>a static context <var>SC</var>
and</span> a dynamic context <var>DC</var>, the result is obtained
as follows:</p>
<ol class="enumar">
<li>
<p>[<a name="dt-argumentlist-arity" id="dt-argumentlist-arity"
title="arity">Definition</a>: The number of <code>Argument</code>s
in an <code>ArgumentList</code> is its <b>arity</b>. ]</p>
</li>
<li>
<p>The function to be called or partially applied (call it
<var>F</var>) is obtained as follows:</p>
<ol class="enumla">
<li>
<p>If <var>FC</var> is a static function call: Using the expanded
QName corresponding to <var>FC</var>'s <code>EQName</code>, and the
arity of <var>FC</var>'s <code>ArgumentList</code>, the
corresponding function is looked up in the <a title=
"named functions" href="#dt-named-functions">named functions</a>
component of <var>DC</var>. Let <var>F</var> denote the function
obtained.</p>
</li>
<li>
<p>If <var>FC</var> is a dynamic function call: <var>FC</var>'s
base expression is evaluated with respect to <span><var>SC</var>
and</span> <var>DC</var>. If this yields a sequence consisting of a
single function with the same arity as the arity of the
<code>ArgumentList</code>, let <var>F</var> denote that function.
Otherwise, a type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
<li>
<p>[<a name="dt-arg-value" id="dt-arg-value" title=
"argument value">Definition</a>: <a title="argument expression"
href="#dt-arg-expr">Argument expressions</a> are evaluated
<span>with respect to <var>DC</var></span> , producing <b>argument
values</b>.] The order of argument evaluation is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> and a
function need not evaluate an argument if the function can evaluate
its body without evaluating that argument.</p>
</li>
<li>
<p>Each argument value is converted <span>to the corresponding
parameter type in <var>F</var>'s signature</span> by applying the
<a title="function conversion rules" href=
"#dt-function-conversion">function conversion rules</a>,
<span>resulting in a <b>converted argument value</b>.</span></p>
</li>
<li>
<p>The remainder depends on whether or not <var>FC</var> is a
<a title="partial function application" href=
"#dt-partial-function-application">partial function
application</a>.</p>
<ol class="enumla">
<li>
<p>If <var>FC</var> is a partial function application:</p>
<ol class="enumlr">
<li>
<p>[<a name="dt-fixed-position" id="dt-fixed-position" title=
"fixed position">Definition</a>: In a partial function application,
a <b>fixed position</b> is an argument/parameter position for which
the <code>ArgumentList</code> has an argument expression (as
opposed to an <code>ArgumentPlaceholder</code>). ] (Note that a
partial function application need not have any fixed
positions.)</p>
</li>
<li>
<p>A <span>new</span> function is returned <span>(as the value of
<var>FC</var>),</span> with the following properties (as defined in
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#function-items">Section
2.8.1 Functions</a> <sup><small>DM30</small></sup>):</p>
<ul>
<li>
<p><span><b>name</b>:</span> <span>Absent.</span></p>
</li>
<li>
<p><b>parameter names</b>: The parameter names of <var>F</var>,
removing the parameter names at the fixed positions. (So the
function's arity is the arity of F minus the number of fixed
positions.)</p>
</li>
<li>
<p><span><b>signature</b>:</span> <span>The signature of
<var>F</var>, removing the parameter type at each of the fixed
positions.</span></p>
</li>
<li>
<p><span><b>implementation</b>:</span> <span>The implementation of
<var>F</var> <span>, associated with the same contexts as in
<var>F</var>. If these contexts are absent in <var>F</var>, it is
associated with <var>SC</var> and <var>DC</var>.</span></span></p>
</li>
<li>
<p><span><b>nonlocal variable bindings</b>:</span> <span>The
nonlocal variable bindings of <var>F</var>, plus, for each fixed
position, a binding of the converted argument value to the
corresponding parameter name.</span></p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>If <var>FC</var> is not a partial function application:</p>
<ol class="enumlr">
<li>
<p>If <var>F</var>'s implementation is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> (e.g.,
it is a built-in function or external function , or a partial
application of such a function):</p>
<ul>
<li>
<p><var>F</var>'s implementation is invoked with the converted
argument values <span>using the contexts it is associated with in
<var>F</var>. If these contexts are absent in <var>F</var>, it is
associated with <var>SC</var> and <var>DC</var>.</span></p>
</li>
<li>
<p>The result is either an instance of <var>F</var>'s return type
or a dynamic error. This result is then the result of evaluating
<var>FC</var>.</p>
</li>
<li>
<p>Errors raised by built-in functions are defined in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
</li>
<li>
<p>Errors raised by external functions are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> (see
<a href="#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>).</p>
</li>
</ul>
</li>
<li>
<p>If <var>F</var>'s implementation is a
<code>FunctionBody</code>:</p>
<ol class="enumua">
<li>
<p>The <code>FunctionBody</code> is evaluated. The dynamic context
for this evaluation is obtained by taking the dynamic context of
the <span class="xquery">module</span> that contains the
<code>FunctionBody</code>, and making the following changes:</p>
<ul>
<li>
<p>The <a title="focus" href="#dt-focus">focus</a> (context item,
context position, and context size) is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</p>
</li>
<li>
<p>In the <a title="variable values" href=
"#dt-variable-values">variable values</a> component of the dynamic
context, each converted argument value is bound to the
corresponding parameter name.</p>
<p>When <span>this is done,</span> the <span>converted</span>
argument value retains its most specific <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>, even though this type may
be derived from the type of the formal parameter. For example, a
function with a parameter <code>$p</code> of type
<code>xs:decimal</code> can be invoked with an argument of type
<code>xs:integer</code>, which is derived from
<code>xs:decimal</code>. During the processing of this function
<span>call</span>, the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of <code>$p</code> inside the
body of the function is considered to be
<code>xs:integer</code>.</p>
</li>
<li>
<p>F's nonlocal variable bindings are also added to the <a title=
"variable values" href="#dt-variable-values">variable values</a>.
(Note that the names of the nonlocal variables are by definition
disjoint from the parameter names, so there can be no
conflict.)</p>
</li>
</ul>
</li>
<li>
<p>The value returned by evaluating the function body is then
converted to the declared return type of <var>F</var> by applying
the <a title="function conversion rules" href=
"#dt-function-conversion">function conversion rules</a>. The result
is then the result of evaluating <var>FC</var>.</p>
<p><span>As with argument values,</span> the value returned by a
function retains its most specific type, which may be derived from
the declared return type of <var>F</var>. For example, a function
that has a declared return type of <code>xs:decimal</code> may in
fact return a value of dynamic type <code>xs:integer</code>.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-function-conversion-rules" id=
"id-function-conversion-rules"></a>3.1.5.2 Function Conversion
Rules</h5>
<p>[<a name="dt-function-conversion" id="dt-function-conversion"
title="function conversion rules">Definition</a>: The <b>function
conversion rules</b> are used to convert an argument value
<span class="xquery">or a return value</span> to its expected type;
that is, to the declared type of the function <span class=
"xquery">parameter or return.</span> ] The expected type is
expressed as a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>. The function conversion
rules are applied to a given value as follows:</p>
<ul>
<li>
<p>If the expected type is a sequence of a <a title=
"generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> (possibly
with an occurrence indicator <code>*</code>, <code>+</code>, or
<code>?</code>), the following conversions are applied:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the given value, resulting in a sequence of atomic
values.</p>
</li>
<li>
<p>Each item in the atomic sequence that is of type
<code>xs:untypedAtomic</code> is cast to the expected
<span>generalized</span> atomic type. For <a title=
"built-in function" href="#dt-built-in-function">built-in
functions</a> where the expected type is specified as <a title=
"numeric" href="#dt-numeric">numeric</a>, arguments of type
<code>xs:untypedAtomic</code> are cast to <code>xs:double</code>.
<span>If the item is of type <code>xs:untypedAtomic</code> and the
expected type is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is
raised.</span></p>
</li>
<li>
<p>For each <a title="numeric" href="#dt-numeric">numeric</a> item
in the atomic sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
numeric promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
<li>
<p>For each item of type <code>xs:anyURI</code> in the atomic
sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
URI promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
</ol>
</li>
<li>
<p>If the expected type is a <a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a> (possibly
with an occurrence indicator <code>*</code>, <code>+</code>, or
<code>?</code>), <a title="function coercion" href=
"#dt-function-item-coercion">function coercion</a> is applied to
each function in the given value.</p>
</li>
<li>
<p>If, after the above conversions, the resulting value does not
match the expected type according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
<span class="xquery">If the function call takes place in a
<a title="module" href="#dt-module">module</a> other than the
<a title="module" href="#dt-module">module</a> in which the
function is defined, this rule must be satisfied in both the module
where the function is called and the module where the function is
defined (the test is repeated because the two modules may have
different <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>.)</span> Note that the
rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a> permit a
value of a derived type to be substituted for a value of its base
type.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-function-coercion" id=
"id-function-coercion"></a>3.1.5.3 Function Coercion</h5>
<p>Function coercion is a transformation applied to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">functions</a><sup><small>DM30</small></sup>
during application of the <a title="function conversion rules"
href="#dt-function-conversion">function conversion rules</a>.
[<a name="dt-function-item-coercion" id="dt-function-item-coercion"
title="function coercion">Definition</a>: <b>Function coercion</b>
wraps a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
in a new function with signature the same as the expected type.
This effectively delays the checking of the argument and return
types until the function is invoked.]</p>
<p>Function coercion is only defined to operate on <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">functions</a><sup><small>DM30</small></sup>.
Given a function <span><var>F</var></span> , <span>and an expected
function type</span>, function coercion <span>proceeds as follows:
If <var>F</var> and the expected type have different arity, a type
error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]. Otherwise, coercion</span>
returns a new function with the following properties (as defined in
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#function-items">Section
2.8.1 Functions</a> <sup><small>DM30</small></sup>):</p>
<ul>
<li>
<p><span><b>name</b>:</span> The name of <span><var>F</var></span>
.</p>
</li>
<li>
<p><b>parameter names</b>: The parameter names of <var>F</var>.</p>
</li>
<li>
<p><span><b>signature</b>:</span> <span><code>Annotations</code> is
set to the annotations of <var>F</var>.
<code>TypedFunctionTest</code> is set to the expected
type.</span></p>
</li>
<li>
<p><span><b>implementation</b>:</span> <span>In effect, a
<code>FunctionBody</code> that calls <var>F</var>, passing it the
parameters of this new function, in order.</span></p>
</li>
<li>
<p><span><b>nonlocal variable bindings</b>:</span> <span>An empty
mapping.</span></p>
</li>
</ul>
<p>If the result of invoking the new function would necessarily
result in a type error, that error may be raised during function
coercion. It is implementation dependent whether this happens or
not.</p>
<p>These rules have the following consequences:</p>
<ul>
<li>
<p>SequenceType matching of the function's arguments and result are
delayed until that function is invoked.</p>
</li>
<li>
<p>The function conversion rules applied to the function's
arguments and result are defined by the SequenceType it has most
recently been coerced to. Additional function conversion rules
could apply when the wrapped function is invoked.</p>
</li>
<li>
<p>If an implementation has static type information about a
function, that can be used to type check the function's argument
and return types during static analysis.</p>
</li>
</ul>
<p>For instance, consider the following query:</p>
<div class="exampleInner">
<pre>
declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()*
{
  $s[$p(.)]
};

let $f := function($a) { starts-with($a, "E") }
return
  local:filter(("Ethel", "Enid", "Gertrude"), $f)
      
</pre></div>
<p>The function <code>$f</code> has a static type of
<code>function(item()*) as item()*</code>. When the
<code>local:filter()</code> function is called, the following
occurs to the function:</p>
<ol class="enumar">
<li>
<p>The function conversion rules result in applying function
coercion to <code>$f</code> , wrapping $f in a new function ($p)
with the signature <code>function(xs:string) as
xs:boolean</code>.</p>
</li>
<li>
<p>$p is matched against the SequenceType of
<code>function(xs:string) as xs:boolean</code>, and succeeds.</p>
</li>
<li>
<p>When $p is invoked inside the predicate, function conversion and
SequenceType matching rules are applied to the context item
argument, resulting in an <code>xs:string</code> value or a type
error.</p>
</li>
<li>
<p>$f is invoked with the <code>xs:string</code>, which returns an
<code>xs:boolean</code>.</p>
</li>
<li>
<p>$p applies function conversion rules to the result sequence from
$f, which already matches its declared return type of
<code>xs:boolean</code>.</p>
</li>
<li>
<p>The <code>xs:boolean</code> is returned as the result of $p.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the semantics of function coercion are specified in
terms of wrapping the functions, static typing will often be able
to reduce the number of places where this is actually
necessary.</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-named-function-ref" id=
"id-named-function-ref"></a>3.1.6 <span>Named Function
References</span></h4>
<h5><a name="d2e11586" id="d2e11586"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NamedFunctionRef" id=
"doc-xquery30-NamedFunctionRef"></a>[164]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NamedFunctionRef">NamedFunctionRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a> "#" <a href=
"#doc-xquery30-IntegerLiteral">IntegerLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e10853.doc-xquery30-EQName" id=
"noid_d3e10853.doc-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a> | <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-named-function-ref" id="dt-named-function-ref"
title="named function reference">Definition</a>: A <b><span>named
function reference</span></b> <span>denotes</span> a <a title=
"named function" href="#dt-named-func">named function</a>.]
[<a name="dt-named-func" id="dt-named-func" title=
"named function">Definition</a>: A <b>named function</b> is a
function defined in the static context for the <span class=
"xquery">query</span>. To uniquely identify a particular named
function, both its name as an <span>expanded</span> QName and its
arity are required.]</p>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> that has no namespace prefix, it is
considered to be in the default function namespace.</p>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and arity in a <span>named
function reference</span> do not match the name and arity of a
function signature in the static context, a static error is raised
[<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p>
<p>The value of a <code>NamedFunctionRef</code> is the function
obtained by looking up the expanded QName and arity in the
<a title="named functions" href="#dt-named-functions">named
functions</a> component of the dynamic context.</p>
<p>Furthermore, if the function referenced by a
<code>NamedFunctionRef</code> has an implementation-dependent
implementation, then the implementation of the function returned by
the <code>NamedFunctionRef</code> is associated with the static
context of this <code>NamedFunctionRef</code> expression and to the
dynamic context in which it is currently being evaluated.</p>
<p>Certain functions in the <a href="#xpath-functions-30">[XQuery
and XPath Functions and Operators 3.0]</a> specification are
defined to be polymorphic. These are denoted as accepting
parameters of "numeric" type, or returning "numeric" type. Here
"numeric" is a pseudonym for the four primitive numeric types
xs:decimal, xs:integer, xs:float, and xs:double. For the purposes
of <span>named function references</span>, these functions are
regarded as taking arguments and producing results of type
xs:anyAtomicType, with a type error raised at runtime if the
argument value provided is not of the correct numeric type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above way of modeling polymorphic functions is semantically
backwards compatible with <span class="xquery">XQuery 1.0</span>.
An implementation that supports static typing can choose to model
the types of these functions more accurately if desired.</p>
</div>
<p>The following are examples of <span>named function
references</span>:</p>
<ul>
<li>
<p><code>fn:abs#1</code> references the fn:abs function which takes
a single argument.</p>
</li>
<li>
<p><code>fn:concat#5</code> references the fn:concat function which
takes 5 arguments.</p>
</li>
<li>
<p><code>local:myfunc#2</code> references a function named
local:myfunc which takes 2 arguments.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-inline-func" id="id-inline-func"></a>3.1.7 Inline
Function <span>Expression</span>s</h4>
<h5><a name="d2e11925" id="d2e11925"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-InlineFunctionExpr" id=
"doc-xquery30-InlineFunctionExpr"></a>[165]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Annotation">Annotation</a>*
"function" "(" <a href="#doc-xquery30-ParamList">ParamList</a>? ")"
("as" <a href="#doc-xquery30-SequenceType">SequenceType</a>)?
<a href="#doc-xquery30-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-inline-func" id="dt-inline-func" title=
"inline function expression">Definition</a>: An <b>inline function
expression</b> creates an anonymous <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
defined directly in the inline function expression itself.] An
inline function <span>expression</span> specifies the names and
SequenceTypes of the parameters to the function, the SequenceType
of the result, and the body of the function.</p>
<p>If a function parameter is declared using a name but no type,
its default type is item()*. If the result type is omitted from an
inline function expression, its default result type is item()*.</p>
<p>The parameters of an inline function expression are considered
to be variables whose scope is the function body. It is a static
error [<a href="#ERRXQST0039" title=
"err:XQST0039">err:XQST0039</a>] for an inline function expression
to have more than one parameter with the same name.</p>
<p class="xquery">An inline function <span>expression</span> may
have annotations. XQuery 3.0 does not define annotations that apply
to inline function <span>expression</span>s, in particular it is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXQST0125" title="err:XQST0125">err:XQST0125</a>] if
an inline function <span>expression</span> is annotated as
<code>%public</code> or <code>%private</code>. An implementation
can define annotations, in its own namespace, to support
functionality beyond the scope of this specification.</p>
<p>The static context for the function body is inherited from the
location of the inline function expression, with the exception of
the static type of the context item which is initially <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</p>
<p>The variables in scope for the function body include all
variables representing the function parameters, as well as all
variables that are in scope for the inline function expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Function parameter names can mask variables that would otherwise
be in scope for the function body.</p>
</div>
<p>The result of an inline function <span>expression</span> is a
single function with the following properties (as defined in
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#function-items">Section
2.8.1 Functions</a> <sup><small>DM30</small></sup>):</p>
<ul>
<li>
<p><span><b>name</b>:</span> <span>Absent.</span></p>
</li>
<li>
<p><b>parameter names</b>: The parameter names in the
<code>InlineFunctionExpr</code>'s <code>ParamList</code>.</p>
</li>
<li>
<p><span><b>signature</b>:</span> <span>A <code>FunctionTest</code>
constructed from the <span class="xquery"><code>Annotation</code>s
and</span> <code>SequenceType</code>s in the
<code>InlineFunctionExpr</code>.</span></p>
</li>
<li>
<p><span><b>implementation</b>:</span> <span>The
<code>InlineFunctionExpr</code>'s
<code>FunctionBody</code>.</span></p>
</li>
<li>
<p><span><b>nonlocal variable bindings</b>:</span> <span>For each
nonlocal variable, a binding of it to its value in the <a title=
"variable values" href="#dt-variable-values">variable values</a>
component of the dynamic context of the
<code>InlineFunctionExpr</code>.</span></p>
</li>
</ul>
<p>The following are examples of some inline function
<span>expression</span>s:</p>
<ul>
<li>
<p>This example creates a function that takes no arguments and
returns a sequence of the first 6 primes:</p>
<div class="exampleInner">
<pre>
function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }
</pre></div>
</li>
<li>
<p>This example creates a function that takes two xs:double
arguments and returns their product:</p>
<div class="exampleInner">
<pre>
function($a as xs:double, $b as xs:double) as xs:double { $a * $b }
</pre></div>
</li>
<li>
<p>This example creates a function that returns its item()*
argument:</p>
<div class="exampleInner">
<pre>
function($a) { $a }
</pre></div>
</li>
<li>
<p>This example creates a sequence of functions each of which
returns a different node from the default collection.</p>
<div class="exampleInner">
<pre>
collection()/(let $a := . return function() { $a })
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-postfix-expression" id=
"id-postfix-expression"></a>3.2 Postfix Expressions</h3>
<h5><a name="d2e12156" id="d2e12156"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PostfixExpr" id=
"doc-xquery30-PostfixExpr"></a>[120]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PostfixExpr">PostfixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xquery30-Predicate">Predicate</a> | <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11387.doc-xquery30-Predicate" id=
"noid_d3e11387.doc-xquery30-Predicate"></a>[123]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xquery30-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11388.doc-xquery30-ArgumentList" id=
"noid_d3e11388.doc-xquery30-ArgumentList"></a>[121]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xquery30-Argument">Argument</a> (","
<a href="#doc-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-filter-expression" id="dt-filter-expression" title=
"filter expression">Definition</a>: An expression followed by a
predicate (that is, <code>E1[E2]</code>) is referred to as a
<b>filter expression</b>: its effect is to return those items from
the value of <code>E1</code> that satisfy the predicate in E2.]
Filter expressions are described in <a href=
"#id-filter-expression"><b>3.2.1 Filter Expressions</b></a></p>
<p>An expression (other than a raw EQName) followed by an argument
list in parentheses (that is, <code>E1(E2, E3, ...)</code>) is
referred to as a <a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic function
<span>call</span></a> . Its effect is to evaluate <code>E1</code>
to obtain a function, and then call that function, with
<code>E2</code>, <code>E3</code>, <code>...</code> as arguments.
Dynamic function <span>calls</span> are described in <a href=
"#id-dynamic-function-invocation"><b>3.2.2 Dynamic Function
Call</b></a> .</p>
<div class="div3">
<h4><a name="id-filter-expression" id=
"id-filter-expression"></a>3.2.1 Filter Expressions</h4>
<h5><a name="d2e12255" id="d2e12255"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11455.doc-xquery30-PostfixExpr" id=
"noid_d3e11455.doc-xquery30-PostfixExpr"></a>[120]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xquery30-Predicate">Predicate</a> | <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Predicate" id=
"doc-xquery30-Predicate"></a>[123]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xquery30-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>A filter expression consists of a base expression followed by a
predicate, which is an expression written in square brackets. The
result of the filter expression consists of the items returned by
the base expression, filtered by applying the predicate to each
item in turn. The ordering of the items returned by a filter
expression is the same as their order in the result of the primary
expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Where the expression before the square brackets is a <a href=
"#doc-xquery30-ReverseStep">ReverseStep</a> or <a href=
"#doc-xquery30-ForwardStep">ForwardStep</a>, the expression is
technically not a filter expression but an <a href=
"#doc-xquery30-AxisStep">AxisStep</a>. There are minor differences
in the semantics: see <a href="#id-predicate"><b>3.3.3 Predicates
within Steps</b></a></p>
</div>
<p>Here are some examples of filter expressions:</p>
<ul>
<li>
<p>Given a sequence of products in a variable, return only those
products whose price is greater than 100.</p>
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</li>
<li>
<p>List all the integers from 1 to 100 that are divisible by 5.
(See <a href="#construct_seq"><b>3.4.1 Constructing
Sequences</b></a> for an explanation of the <code>to</code>
operator.)</p>
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</li>
<li>
<p>The result of the following expression is the integer 25:</p>
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</li>
<li>
<p>The following example returns the fifth through ninth items in
the sequence bound to variable <code>$orders</code>.</p>
<div class="exampleInner">
<pre>
$orders[fn:position() = (5 to 9)]
</pre></div>
</li>
<li>
<p>The following example illustrates the use of a filter expression
as a <a title="step" href="#dt-step">step</a> in a <a title=
"path expression" href="#dt-path-expression">path expression</a>.
It returns the last chapter or appendix within the book bound to
variable <code>$book</code>:</p>
<div class="exampleInner">
<pre>
$book/(chapter | appendix)[fn:last()]
</pre></div>
</li>
</ul>
<p>For each item in the input sequence, the predicate expression is
evaluated using an <b>inner focus</b>, defined as follows: The
context item is the item currently being tested against the
predicate. The context size is the number of items in the input
sequence. The context position is the position of the context item
within the input sequence.</p>
<p>For each item in the input sequence, the result of the predicate
expression is coerced to an <code>xs:boolean</code> value, called
the <b>predicate truth value</b>, as described below. Those items
for which the predicate truth value is <code>true</code> are
retained, and those for which the predicate truth value is
<code>false</code> are discarded.</p>
<p>The predicate truth value is derived by applying the following
rules, in order:</p>
<ol class="enumar">
<li>
<p>If the value of the predicate expression is a <a title=
"singleton" href="#dt-singleton">singleton</a> atomic value of a
<a title="numeric" href="#dt-numeric">numeric</a> type or derived
from a <a title="numeric" href="#dt-numeric">numeric</a> type, the
predicate truth value is <code>true</code> if the value of the
predicate expression is equal (by the <code>eq</code> operator) to
the <b>context position</b>, and is <code>false</code> otherwise.
[<a name="dt-numeric-predicate" id="dt-numeric-predicate" title=
"numeric predicate">Definition</a>: A predicate whose predicate
expression returns a numeric type is called a <b>numeric
predicate</b>.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In a region of a query where <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>unordered</code>,
the result of a numeric predicate is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> , as
explained in <a href="#id-unordered-expressions"><b>3.11 Ordered
and Unordered Expressions</b></a>.</p>
</div>
</li>
<li>
<p>Otherwise, the predicate truth value is the <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of the predicate expression.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-dynamic-function-invocation" id=
"id-dynamic-function-invocation"></a>3.2.2 Dynamic Function
<span>Call</span></h4>
<h5><a name="d2e12419" id="d2e12419"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11599.doc-xquery30-PostfixExpr" id=
"noid_d3e11599.doc-xquery30-PostfixExpr"></a>[120]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xquery30-Predicate">Predicate</a> | <a href=
"#doc-xquery30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ArgumentList" id=
"doc-xquery30-ArgumentList"></a>[121]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ArgumentList">ArgumentList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xquery30-Argument">Argument</a> (","
<a href="#doc-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11601.doc-xquery30-Argument" id=
"noid_d3e11601.doc-xquery30-Argument"></a>[134]&#160;&#160;&#160;</td>
<td><code>Argument</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a> |
<a href=
"#doc-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11602.doc-xquery30-ArgumentPlaceholder" id=
"noid_d3e11602.doc-xquery30-ArgumentPlaceholder"></a>[135]&#160;&#160;&#160;</td>
<td><code>ArgumentPlaceholder</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-dynamic-function-invocation" id=
"dt-dynamic-function-invocation" title=
"dynamic function call">Definition</a>: A <b>dynamic function
<span>call</span></b> consists of a <span>base expression</span>
that returns the function and a parenthesized list of zero or more
arguments (<a title="argument expression" href=
"#dt-arg-expr">argument expressions</a> or
ArgumentPlaceholders).]</p>
<p>A dynamic function call is evaluated as described in <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a> .</p>
<p>The following are examples of some dynamic function
<span>calls</span>:</p>
<ul>
<li>
<p>This example invokes the function contained in $f, passing the
arguments 2 and 3:</p>
<div class="exampleInner">
<pre>
$f(2, 3)
</pre></div>
</li>
<li>
<p>This example fetches the second item from sequence $f, treats it
as a function and invokes it, passing an <code>xs:string</code>
argument:</p>
<div class="exampleInner">
<pre>
$f[2]("Hi there")
</pre></div>
</li>
<li>
<p>This example invokes the function $f passing no arguments, and
filters the result with a positional predicate:</p>
<div class="exampleInner">
<pre>
$f()[2]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>3.3
Path Expressions</h3>
<h5><a name="d2e12558" id="d2e12558"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PathExpr" id=
"doc-xquery30-PathExpr"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#doc-xquery30-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xquery30-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xquery30-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11702.doc-xquery30-RelativePathExpr" id=
"noid_d3e11702.doc-xquery30-RelativePathExpr"></a>[108]&#160;&#160;&#160;</td>
<td><code>RelativePathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-StepExpr">StepExpr</a> (("/" |
"//") <a href="#doc-xquery30-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-path-expression" id="dt-path-expression" title=
"path expression">Definition</a>: A <b>path expression</b> can be
used to locate nodes within trees. A path expression consists of a
series of one or more <a title="step" href="#dt-step">steps</a>,
separated by "<code>/</code>" or "<code>//</code>", and optionally
beginning with "<code>/</code>" or "<code>//</code>".] An initial
"<code>/</code>" or "<code>//</code>" is an abbreviation for one or
more initial steps that are implicitly added to the beginning of
the path expression, as described below.</p>
<p>A path expression consisting of a single step is evaluated as
described in <a href="#id-steps"><b>3.3.2 Steps</b></a>.</p>
<p>A "<code>/</code>" at the beginning of a path expression is an
abbreviation for the initial step
<code><span>(fn:root(self::node()) treat as
document-node())</span>/</code> (however, if the "<code>/</code>"
is the entire path expression, the trailing "<code>/</code>" is
omitted from the expansion.) The effect of this initial step is to
begin the path at the root node of the tree that contains the
context node. If the context item is not a node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. At
evaluation time, if the root node above the context node is not a
document node, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
<p>A "<code>//</code>" at the beginning of a path expression is an
abbreviation for the initial steps
<code><span>(fn:root(self::node()) treat as
document-node())</span>/descendant-or-self::node()/</code>
(however, "<code>//</code>" by itself is not a valid path
expression [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>].) The effect of these initial
steps is to establish an initial node sequence that contains the
root of the tree in which the context node is found, plus all nodes
descended from this root. This node sequence is used as the input
to subsequent steps in the path expression. If the context item is
not a node, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. At evaluation time, if the root
node above the context node is not a document node, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised [<a href="#ERRXPDY0050" title=
"err:XPDY0050">err:XPDY0050</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The descendants of a node do not include attribute nodes.</p>
</div>
<div class="div3">
<h4><a name="id-relative-path-expressions" id=
"id-relative-path-expressions"></a>3.3.1 Relative Path
Expressions</h4>
<h5><a name="d2e12684" id="d2e12684"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-RelativePathExpr" id=
"doc-xquery30-RelativePathExpr"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-StepExpr">StepExpr</a> (("/" |
"//") <a href="#doc-xquery30-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>Relative path expressions are binary operators on step
expressions, which are named <code>E1</code> and <code>E2</code> in
this section.</p>
<p>Each non-initial occurrence of "<code>//</code>" in a path
expression is expanded as described in <a href="#abbrev"><b>3.3.5
Abbreviated Syntax</b></a>, leaving a sequence of steps separated
by "<code>/</code>" . This sequence of steps is then evaluated from
left to right. Each item produced by the evaluation of
<code>E1</code> is used as the <a title="context item" href=
"#dt-context-item">context item</a> to evaluate <code>E2</code>;
the sequences resulting from all the evaluations of <code>E2</code>
are combined to produce a result.</p>
<p>The following example illustrates the use of relative path
expressions.</p>
<div class="exampleOuter">
<ul>
<li>
<p><code>child::div1/child::para</code></p>
<p>Selects the <code>para</code> element children of the
<code>div1</code> element children of the context node; that is,
the <code>para</code> element grandchildren of the context node
that have <code>div1</code> parents.</p>
</li>
</ul>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since each step in a path provides context nodes for the
following step, in effect, only the last step in a path is allowed
to return a sequence of non-nodes.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">The "<code>/</code>" character can be used
either as a complete path expression or as the beginning of a
longer path expression such as "<code>/*</code>". Also,
"<code>*</code>" is both the multiply operator and a wildcard in
path expressions. This can cause parsing difficulties when
"<code>/</code>" appears on the left-hand side of "<code>*</code>".
This is resolved using the <a href=
"#parse-note-leading-lone-slash">leading-lone-slash</a> constraint.
For example, "<code>/*</code>" and "<code>/ *</code>" are valid
path expressions containing wildcards, but "<code>/*5</code>" and
"<code>/ * 5</code>" raise syntax errors. Parentheses must be used
when "<code>/</code>" is used on the left-hand side of an operator,
as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>"
raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid
expression. The expression "<code>4 + /</code>" is also valid,
because <code>/</code> does not occur on the left-hand side of the
operator.</p>
<p>Similarly, in the expression <code>/ union /*</code>, "union" is
interpreted as an element name rather than an operator. For it to
be parsed as an operator, the expression should be written
<code>(/) union /*</code>.</p>
</div>
<div class="div4">
<h5><a name="id-path-operator" id="id-path-operator"></a>3.3.1.1
Path operator (<code>/</code>)</h5>
<p>The path operator "/" is used to build expressions for locating
nodes within trees. Its left-hand side expression must return a
sequence of nodes. <span>The operator</span> returns either a
sequence of nodes, in which case it additionally performs document
ordering and duplicate elimination, or a sequence of non-nodes.</p>
<p>Each operation <code>E1/E2</code> is evaluated as follows:
Expression <code>E1</code> is evaluated, and if the result is not a
(possibly empty) sequence <code>S</code> of nodes, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0019" title="err:XPTY0019">err:XPTY0019</a>].
Each node in <code>S</code> then serves in turn to provide an inner
focus (the node as the context item, its position in <code>S</code>
as the context position, the length of <code>S</code> as the
context size) for an evaluation of <code>E2</code>, as described in
<a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The
sequences resulting from all the evaluations of <code>E2</code> are
combined as follows:</p>
<ol class="enumar">
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of nodes, these sequences are combined, and
duplicate nodes are eliminated based on node identity. <span class=
"xquery">If ordering mode is ordered, the resulting node sequence
is returned in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it is returned
in <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</span></p>
</li>
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of non-nodes, these sequences are concatenated and
returned. <span class="xquery">If <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the
returned sequence preserves the orderings within and among the
subsequences generated by the evaluations of <code>E2</code>;
otherwise the order of the returned sequence is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</span></p>
</li>
<li>
<p>If the multiple evaluations of <code>E2</code> return at least
one node and at least one non-node, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0018"
title="err:XPTY0018">err:XPTY0018</a>].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The semantics of the path operator can also be defined using the
simple mapping operator as follows (forming the union with an empty
sequence <code>($R | ())</code> has the effect of eliminating
duplicates and sorting nodes into document order):</p>
<div class="exampleInner">
<pre>
E1/E2 ::= let $R := E1!E2
  return
    if (every $r in $R satisfies $r instance of node())
    then ($R|())
    else if (every $r in $R satisfies not($r instance of node()))
    then $R
    else error()
</pre></div>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-steps" id="id-steps"></a>3.3.2 Steps</h4>
<h5><a name="d2e12932" id="d2e12932"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-StepExpr" id=
"doc-xquery30-StepExpr"></a>[109]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PostfixExpr">PostfixExpr</a> |
<a href="#doc-xquery30-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e12039.doc-xquery30-AxisStep" id=
"noid_d3e12039.doc-xquery30-AxisStep"></a>[110]&#160;&#160;&#160;</td>
<td><code>AxisStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery30-ReverseStep">ReverseStep</a> |
<a href="#doc-xquery30-ForwardStep">ForwardStep</a>) <a href=
"#doc-xquery30-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ForwardStep" id=
"doc-xquery30-ForwardStep"></a>[111]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery30-ForwardAxis">ForwardAxis</a>
<a href="#doc-xquery30-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ReverseStep" id=
"doc-xquery30-ReverseStep"></a>[114]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery30-ReverseAxis">ReverseAxis</a>
<a href="#doc-xquery30-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e12042.doc-xquery30-PredicateList" id=
"noid_d3e12042.doc-xquery30-PredicateList"></a>[122]&#160;&#160;&#160;</td>
<td><code>PredicateList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-step" id="dt-step" title="step">Definition</a>: A
<b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=""
href="#dt-predicate">predicates</a>. The value of the step consists
of those items that satisfy the predicates, working from left to
right. A step may be either an <a title="axis step" href=
"#dt-axis-step">axis step</a> or a postfix expression.] Postfix
expressions are described in <a href=
"#id-postfix-expression"><b>3.2 Postfix Expressions</b></a>.</p>
<p>[<a name="dt-axis-step" id="dt-axis-step" title=
"axis step">Definition</a>: An <b>axis step</b> returns a sequence
of nodes that are reachable from the context node via a specified
axis. Such a step has two parts: an <b>axis</b>, which defines the
"direction of movement" for the step, and a <a title="node test"
href="#dt-node-test">node test</a>, which selects nodes based on
their kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] If the context item is
a node, an axis step returns a sequence of zero or more nodes;
otherwise, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. <span class="xquery">If <a title=
"ordering mode" href="#dt-ordering-mode">ordering mode</a> is
<code>ordered</code>, the resulting node sequence is returned in
<a title="document order" href="#dt-document-order">document
order</a>; otherwise it is returned in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</span> An axis step may be either a <b>forward step</b> or a
<b>reverse step</b>, followed by zero or more <a title="" href=
"#dt-predicate">predicates</a>.</p>
<p>In the <b>abbreviated syntax</b> for a step, the axis can be
omitted and other shorthand notations can be used as described in
<a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.</p>
<p>The unabbreviated syntax for an axis step consists of the axis
name and node test separated by a double colon. The result of the
step consists of the nodes reachable from the context node via the
specified axis that have the node kind, name, and/or <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
specified by the node test. For example, the step
<code>child::para</code> selects the <code>para</code> element
children of the context node: <code>child</code> is the name of the
axis, and <code>para</code> is the name of the element nodes to be
selected on this axis. The available axes are described in <a href=
"#axes"><b>3.3.2.1 Axes</b></a>. The available node tests are
described in <a href="#node-tests"><b>3.3.2.2 Node Tests</b></a>.
Examples of steps are provided in <a href="#unabbrev"><b>3.3.4
Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.3.5
Abbreviated Syntax</b></a>.</p>
<div class="div4">
<h5><a name="axes" id="axes"></a>3.3.2.1 Axes</h5>
<h5><a name="d2e13097" id="d2e13097"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ForwardAxis" id=
"doc-xquery30-ForwardAxis"></a>[112]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ReverseAxis" id=
"doc-xquery30-ReverseAxis"></a>[115]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p class="xquery">XQuery supports the following axes:</p>
<ul>
<li>
<p>The <code>child</code> axis contains the children of the context
node, which are the nodes returned by the <code>dm:children</code>
accessor in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only document nodes and element nodes have children. If the
context node is any other kind of node, or if the context node is
an empty document or element node, then the child axis is an empty
sequence. The children of a document node or element node may be
element, processing instruction, comment, or text nodes. Attribute
and document nodes can never appear as children.</p>
</div>
</li>
<li>
<p>the <code>descendant</code> axis is defined as the transitive
closure of the child axis; it contains the descendants of the
context node (the children, the children of the children, and so
on)</p>
</li>
<li>
<p>the <code>parent</code> axis contains the sequence returned by
the <code>dm:parent</code> accessor in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>,
which returns the parent of the context node, or an empty sequence
if the context node has no parent</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An attribute node may have an element node as its parent, even
though the attribute node is not a child of the element node.</p>
</div>
</li>
<li>
<p>the <code>ancestor</code> axis is defined as the transitive
closure of the parent axis; it contains the ancestors of the
context node (the parent, the parent of the parent, and so on)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ancestor axis includes the root node of the tree in which
the context node is found, unless the context node is the root
node.</p>
</div>
</li>
<li>
<p>the <code>following-sibling</code> axis contains the context
node's following siblings, those children of the context node's
parent that occur after the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute node, the
<code>following-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>preceding-sibling</code> axis contains the context
node's preceding siblings, those children of the context node's
parent that occur before the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute node, the
<code>preceding-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>following</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not descendants of the context node, and occur after the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>preceding</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not ancestors of the context node, and occur before the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>attribute</code> axis contains the attributes of the
context node, which are the nodes returned by the
<code>dm:attributes</code> accessor in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>;
the axis will be empty unless the context node is an element</p>
</li>
<li>
<p>the <code>self</code> axis contains just the context node
itself</p>
</li>
<li>
<p>the <code>descendant-or-self</code> axis contains the context
node and the descendants of the context node</p>
</li>
<li>
<p>the <code>ancestor-or-self</code> axis contains the context node
and the ancestors of the context node; thus, the ancestor-or-self
axis will always include the root node</p>
</li>
</ul>
<p>Axes can be categorized as <b>forward axes</b> and <b>reverse
axes</b>. An axis that only ever contains the context node or nodes
that are after the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a forward axis. An axis
that only ever contains the context node or nodes that are before
the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a reverse axis.</p>
<p>The <code>parent</code>, <code>ancestor</code>,
<code>ancestor-or-self</code>, <code>preceding</code>, and
<code>preceding-sibling</code> axes are reverse axes; all other
axes are forward axes. The <code>ancestor</code>,
<code>descendant</code>, <code>following</code>,
<code>preceding</code> and <code>self</code> axes partition a
document (ignoring attribute nodes): they do not overlap and
together they contain all the nodes in the document.</p>
<p>[<a name="dt-principal-node-kind" id="dt-principal-node-kind"
title="principal node kind">Definition</a>: Every axis has a
<b>principal node kind</b>. If an axis can contain elements, then
the principal node kind is element; otherwise, it is the kind of
nodes that the axis can contain.] Thus:</p>
<ul>
<li>
<p>For the attribute axis, the principal node kind is
attribute.</p>
</li>
<li>
<p>For all other axes, the principal node kind is element.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>3.3.2.2 Node
Tests</h5>
<p>[<a name="dt-node-test" id="dt-node-test" title=
"node test">Definition</a>: A <b>node test</b> is a condition on
the name, kind (element, attribute, text, document, comment, or
processing instruction), and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a> of a node. A node test
determines which nodes contained by an axis are selected by a
<a title="step" href="#dt-step">step</a>.]</p>
<h5><a name="d2e13335" id="d2e13335"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NodeTest" id=
"doc-xquery30-NodeTest"></a>[117]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-KindTest">KindTest</a> | <a href=
"#doc-xquery30-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NameTest" id=
"doc-xquery30-NameTest"></a>[118]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a> | <a href=
"#doc-xquery30-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Wildcard" id=
"doc-xquery30-Wildcard"></a>[119]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery30-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery30-NCName">NCName</a>)<br />
| (<a href="#doc-xquery30-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e12359.doc-xquery30-EQName" id=
"noid_d3e12359.doc-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a> | <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-name-test" id="dt-name-test" title=
"name test">Definition</a>: A node test that consists only of an
EQName or a Wildcard is called a <b>name test</b>.] A name test is
true if and only if the <b>kind</b> of the node is the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> for the step axis and the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the node is equal (as
defined by the <code>eq</code> operator) to the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a>
specified by the name test. For example, <code>child::para</code>
selects the <code>para</code> element children of the context node;
if the context node has no <code>para</code> children, it selects
an empty set of nodes. <code>attribute::abc:href</code> selects the
attribute of the context node with the QName <code>abc:href</code>;
if the context node has no such attribute, it selects an empty set
of nodes.</p>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a>, it is resolved into an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> using
the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
expression context. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>] if the QName has a prefix that
does not correspond to any statically known namespace. An
unprefixed QName, when used as a name test on an axis whose
<a title="principal node kind" href=
"#dt-principal-node-kind">principal node kind</a> is element, has
the namespace URI of the <a title="default element/type namespace"
href="#dt-def-elemtype-ns">default element/type namespace</a> in
the expression context; otherwise, it has no namespace URI.</p>
<p>A name test is not satisfied by an element node whose name does
not match the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the name test, even if
it is in a <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> whose head is the
named element.</p>
<p>A node test <code>*</code> is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis. For example, <code>child::*</code> will
select all element children of the context node, and
<code>attribute::*</code> will select all attributes of the context
node.</p>
<p>A node test can have the form <code>NCName:*</code>. In this
case, the prefix is expanded in the same way as with a <a title=
"lexical QName" href="#dt-qname">lexical QName</a>, using the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
<a title="static context" href="#dt-static-context">static
context</a>. If the prefix is not found in the statically known
namespaces, a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>]. The node
test is true for any node of the <a title="principal node kind"
href="#dt-principal-node-kind">principal node kind</a> of the step
axis whose <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> has the namespace URI to
which the prefix is bound, regardless of the local part of the
name.</p>
<p>A node test can contain a BracedURILiteral, e.g.
<code>Q{http://example.com/msg}*</code> Such a node test is true
for any node of the principal node kind of the step axis whose
expanded QName has the namespace URI specified in the
BracedURILiteral, regardless of the local part of the name.</p>
<p>A node test can also have the form <code>*:NCName</code>. In
this case, the node test is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis whose local name matches the given
NCName, regardless of its namespace or lack of a namespace.</p>
<p>[<a name="dt-kind-test" id="dt-kind-test" title=
"kind test">Definition</a>: An alternative form of a node test
called a <b>kind test</b> can select nodes based on their kind,
name, and <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] The syntax and
semantics of a kind test are described in <a href=
"#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a> and
<a href="#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>. When a kind test is used in a <a title=
"node test" href="#dt-node-test">node test</a>, only those nodes on
the designated axis that match the kind test are selected. Shown
below are several examples of kind tests that might be used in path
expressions:</p>
<ul>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>element()</code> matches any element node.</p>
</li>
<li>
<p><code>schema-element(person)</code> matches any element node
whose name is <code>person</code> (or is in the <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> headed by <code>person</code>), and whose type annotation
is the same as (or is derived from) the declared type of the
<code>person</code> element in the <a title=
"in-scope element declarations" href="#dt-is-elems">in-scope
element declarations</a>.</p>
</li>
<li>
<p><code>element(person)</code> matches any element node whose name
is <code>person</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>element(person, surgeon)</code> matches any non-nilled
element node whose name is <code>person</code>, and whose type
annotation is <code>surgeon</code> or is derived from
<code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*, surgeon)</code> matches any non-nilled element
node whose type annotation is <code>surgeon</code> (or is derived
from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>attribute()</code> matches any attribute node.</p>
</li>
<li>
<p><code>attribute(price)</code> matches any attribute whose name
is <code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*, xs:decimal)</code> matches any attribute
whose type annotation is <code>xs:decimal</code> (or is derived
from <code>xs:decimal</code>), regardless of its name.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(element(book))</code> matches any document
node whose content consists of a single element node that satisfies
the <a title="kind test" href="#dt-kind-test">kind test</a>
<code>element(book)</code>, interleaved with zero or more comments
and processing instructions.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-predicate" id="id-predicate"></a>3.3.3 Predicates
within Steps</h4>
<h5><a name="d2e13671" id="d2e13671"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AxisStep" id=
"doc-xquery30-AxisStep"></a>[110]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery30-ReverseStep">ReverseStep</a> |
<a href="#doc-xquery30-ForwardStep">ForwardStep</a>) <a href=
"#doc-xquery30-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PredicateList" id=
"doc-xquery30-PredicateList"></a>[122]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e12644.doc-xquery30-Predicate" id=
"noid_d3e12644.doc-xquery30-Predicate"></a>[123]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xquery30-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p id="dt-predicate">A predicate within a Step has similar syntax
and semantics to a predicate within a <a title="" href=
"#id-filter-expression">filter expression</a>. The only difference
is in the way the context position is set for evaluation of the
predicate.</p>
<p>For the purpose of evaluating the context position within a
predicate, the input sequence is considered to be sorted as
follows: into document order if the predicate is in a forward-axis
step, into reverse document order if the predicate is in a
reverse-axis step, or in its original order if the predicate is not
in a step.</p>
<p>Here are some examples of <a title="axis step" href=
"#dt-axis-step">axis steps</a> that contain predicates:</p>
<ul>
<li>
<p>This example selects the second <code>chapter</code> element
that is a child of the context node:</p>
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</li>
<li>
<p>This example selects all the descendants of the context node
that are elements named <code>"toy"</code> and whose
<code>color</code> attribute has the value <code>"red"</code>:</p>
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</li>
<li>
<p>This example selects all the <code>employee</code> children of
the context node that have both a <code>secretary</code> child
element and an <code>assistant</code> child element:</p>
<div class="exampleInner">
<pre>
child::employee[secretary][assistant]
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When using <a title="" href="#dt-predicate">predicates</a> with
a sequence of nodes selected using a <b>reverse axis</b>, it is
important to remember that the context positions for such a
sequence are assigned in <a title="reverse document order" href=
"#dt-reverse-document-order">reverse document order</a>. For
example, <code>preceding::foo[1]</code> returns the first
qualifying <code>foo</code> element in <a title=
"reverse document order" href="#dt-reverse-document-order">reverse
document order</a>, because the predicate is part of an <a title=
"axis step" href="#dt-axis-step">axis step</a> using a reverse
axis. By contrast, <code>(preceding::foo)[1]</code> returns the
first qualifying <code>foo</code> element in <a title=
"document order" href="#dt-document-order">document order</a>,
because the parentheses cause <code>(preceding::foo)</code> to be
parsed as a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a> in which context
positions are assigned in document order. Similarly,
<code>ancestor::*[1]</code> returns the nearest ancestor element,
because the <code>ancestor</code> axis is a reverse axis, whereas
<code>(ancestor::*)[1]</code> returns the root element (first
ancestor in document order).</p>
<p>The fact that a reverse-axis step assigns context positions in
reverse document order for the purpose of evaluating predicates
does not alter the fact that the final result of the step
<span class="xquery">(when in ordered mode)</span> is always in
document order.</p>
</div>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>3.3.4 Unabbreviated
Syntax</h4>
<p>This section provides a number of examples of path expressions
in which the axis is explicitly specified in each <a title="step"
href="#dt-step">step</a>. The syntax used in these examples is
called the <b>unabbreviated syntax</b>. In many common cases, it is
possible to write path expressions more concisely using an
<b>abbreviated syntax</b>, as explained in <a href=
"#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.</p>
<ul>
<li>
<p><code>child::para</code> selects the <code>para</code> element
children of the context node</p>
</li>
<li>
<p><code>child::*</code> selects all element children of the
context node</p>
</li>
<li>
<p><code>child::text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>child::node()</code> selects all the children of the
context node. Note that no attribute nodes are returned, because
attributes are not children.</p>
</li>
<li>
<p><code>attribute::name</code> selects the <code>name</code>
attribute of the context node</p>
</li>
<li>
<p><code>attribute::*</code> selects all the attributes of the
context node</p>
</li>
<li>
<p><code>parent::node()</code> selects the parent of the context
node. If the context node is an attribute node, this expression
returns the element node (if any) to which the attribute node is
attached.</p>
</li>
<li>
<p><code>descendant::para</code> selects the <code>para</code>
element descendants of the context node</p>
</li>
<li>
<p><code>ancestor::div</code> selects all <code>div</code>
ancestors of the context node</p>
</li>
<li>
<p><code>ancestor-or-self::div</code> selects the <code>div</code>
ancestors of the context node and, if the context node is a
<code>div</code> element, the context node as well</p>
</li>
<li>
<p><code>descendant-or-self::para</code> selects the
<code>para</code> element descendants of the context node and, if
the context node is a <code>para</code> element, the context node
as well</p>
</li>
<li>
<p><code>self::para</code> selects the context node if it is a
<code>para</code> element, and otherwise returns an empty
sequence</p>
</li>
<li>
<p><code>child::chapter/descendant::para</code> selects the
<code>para</code> element descendants of the <code>chapter</code>
element children of the context node</p>
</li>
<li>
<p><code>child::*/child::para</code> selects all <code>para</code>
grandchildren of the context node</p>
</li>
<li>
<p><code>/</code> selects the root of the tree that contains the
context node, but raises a dynamic error if this root is not a
document node</p>
</li>
<li>
<p><code>/descendant::para</code> selects all the <code>para</code>
elements in the same document as the context node</p>
</li>
<li>
<p><code>/descendant::list/child::member</code> selects all the
<code>member</code> elements that have a <code>list</code> parent
and that are in the same document as the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = 1]</code> selects the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()]</code> selects the
last <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()-1]</code> selects
the last but one <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() &gt; 1]</code> selects all the
<code>para</code> children of the context node other than the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() = 1]</code>
selects the next <code>chapter</code> sibling of the context
node</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() = 1]</code>
selects the previous <code>chapter</code> sibling of the context
node</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() = 42]</code> selects the
forty-second <code>figure</code> element in the document containing
the context node</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() = 2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>child::para[attribute::type eq "warning"]</code> selects
all <code>para</code> children of the context node that have a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[attribute::type eq 'warning'][fn:position() =
5]</code> selects the fifth <code>para</code> child of the context
node that has a <code>type</code> attribute with value
<code>warning</code></p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type eq
"warning"]</code> selects the fifth <code>para</code> child of the
context node if that child has a <code>type</code> attribute with
value <code>warning</code></p>
</li>
<li>
<p><code>child::chapter[child::title = 'Introduction']</code>
selects the <code>chapter</code> children of the context node that
have one or more <code>title</code> children whose <a title=
"typed value" href="#dt-typed-value">typed value</a> is equal to
the string <code>Introduction</code></p>
</li>
<li>
<p><code>child::chapter[child::title]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix]</code> selects
the <code>chapter</code> and <code>appendix</code> children of the
context node</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code> selects the last <code>chapter</code> or
<code>appendix</code> child of the context node</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>3.3.5 Abbreviated Syntax</h4>
<h5><a name="d2e14157" id="d2e14157"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AbbrevForwardStep" id=
"doc-xquery30-AbbrevForwardStep"></a>[113]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#doc-xquery30-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AbbrevReverseStep" id=
"doc-xquery30-AbbrevReverseStep"></a>[116]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>The abbreviated syntax permits the following abbreviations:</p>
<ol class="enumar">
<li>
<p>The attribute axis <code>attribute::</code> can be abbreviated
by <code>@</code>. For example, a path expression
<code>para[@type="warning"]</code> is short for
<code>child::para[attribute::type="warning"]</code> and so selects
<code>para</code> children with a <code>type</code> attribute with
value equal to <code>warning</code>.</p>
</li>
<li>
<p>If the axis name is omitted from an <a title="axis step" href=
"#dt-axis-step">axis step</a>, the default axis is
<code>child</code>, with two exceptions: if the <span><a href=
"#doc-xquery30-NodeTest">NodeTest</a> in an</span> axis step
contains an <a href="#doc-xquery30-AttributeTest">AttributeTest</a>
or <a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a> then
the default axis is <code>attribute</code>; if the <span><a href=
"#doc-xquery30-NodeTest">NodeTest</a> in an</span> axis step
<span>is a <a href=
"#doc-xquery30-NamespaceNodeTest">NamespaceNodeTest</a> then a
static error is raised [<a href="#ERRXQST0134" title=
"err:XQST0134">err:XQST0134</a>]</span> .</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In an implementation that does not support the namespace axis,
an attempt to access it always raises an error. Thus, an XQuery
implementation will always raise an error in this case, since
XQuery does not support the namespace axis. The namespace axis is
deprecated <span>as of</span> XPath 2.0, but required in some
languages that use XPath, including XSLT.</p>
</div>
<p>For example, the path expression <code>section/para</code> is an
abbreviation for <code>child::section/child::para</code>, and the
path expression <code>section/@id</code> is an abbreviation for
<code>child::section/attribute::id</code>. Similarly,
<code>section/attribute(id)</code> is an abbreviation for
<code>child::section/attribute::attribute(id)</code>. Note that the
latter expression contains both an axis specification and a
<a title="node test" href="#dt-node-test">node test</a>.</p>
</li>
<li>
<p>Each non-initial occurrence of <code>//</code> is effectively
replaced by <code>/descendant-or-self::node()/</code> during
processing of a path expression. For example,
<code>div1//para</code> is short for
<code>child::div1/descendant-or-self::node()/child::para</code> and
so will select all <code>para</code> descendants of
<code>div1</code> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The path expression <code>//para[1]</code> does <em>not</em>
mean the same as the path expression
<code>/descendant::para[1]</code>. The latter selects the first
descendant <code>para</code> element; the former selects all
descendant <code>para</code> elements that are the first
<code>para</code> children of their respective parents.</p>
</div>
</li>
<li>
<p>A step consisting of <code>..</code> is short for
<code>parent::node()</code>. For example, <code>../title</code> is
short for <code>parent::node()/child::title</code> and so will
select the <code>title</code> children of the parent of the context
node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The expression <code>.</code>, known as a <b>context item
expression</b>, is a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a>, and is described
in <a href="#id-context-item-expression"><b>3.1.4 Context Item
Expression</b></a>.</p>
</div>
</li>
</ol>
<p>Here are some examples of path expressions that use the
abbreviated syntax:</p>
<ul>
<li>
<p><code>para</code> selects the <code>para</code> element children
of the context node</p>
</li>
<li>
<p><code>*</code> selects all element children of the context
node</p>
</li>
<li>
<p><code>text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>@name</code> selects the <code>name</code> attribute of
the context node</p>
</li>
<li>
<p><code>@*</code> selects all the attributes of the context
node</p>
</li>
<li>
<p><code>para[1]</code> selects the first <code>para</code> child
of the context node</p>
</li>
<li>
<p><code>para[fn:last()]</code> selects the last <code>para</code>
child of the context node</p>
</li>
<li>
<p><code>*/para</code> selects all <code>para</code> grandchildren
of the context node</p>
</li>
<li>
<p><code>/book/chapter[5]/section[2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>chapter//para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the
context node</p>
</li>
<li>
<p><code>//para</code> selects all the <code>para</code>
descendants of the root document node and thus selects all
<code>para</code> elements in the same document as the context
node</p>
</li>
<li>
<p><code>//@version</code> selects all the <code>version</code>
attribute nodes that are in the same document as the context
node</p>
</li>
<li>
<p><code>//list/member</code> selects all the <code>member</code>
elements in the same document as the context node that have a
<code>list</code> parent</p>
</li>
<li>
<p><code>.//para</code> selects the <code>para</code> element
descendants of the context node</p>
</li>
<li>
<p><code>..</code> selects the parent of the context node</p>
</li>
<li>
<p><code>../@lang</code> selects the <code>lang</code> attribute of
the parent of the context node</p>
</li>
<li>
<p><code>para[@type="warning"]</code> selects all <code>para</code>
children of the context node that have a <code>type</code>
attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[@type="warning"][5]</code> selects the fifth
<code>para</code> child of the context node that has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[5][@type="warning"]</code> selects the fifth
<code>para</code> child of the context node if that child has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>chapter[title="Introduction"]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <a title="typed value" href=
"#dt-typed-value">typed value</a> is equal to the string
<code>Introduction</code></p>
</li>
<li>
<p><code>chapter[title]</code> selects the <code>chapter</code>
children of the context node that have one or more
<code>title</code> children</p>
</li>
<li>
<p><code>employee[@secretary and @assistant]</code> selects all the
<code>employee</code> children of the context node that have both a
<code>secretary</code> attribute and an <code>assistant</code>
attribute</p>
</li>
<li>
<p><code>book/(chapter|appendix)/section</code> selects every
<code>section</code> element that has a parent that is either a
<code>chapter</code> or an <code>appendix</code> element, that in
turn is a child of a <code>book</code> element that is a child of
the context node.</p>
</li>
<li>
<p>If <code>E</code> is any expression that returns a sequence of
nodes, then the expression <code>E/.</code> returns the same nodes
in <a title="document order" href="#dt-document-order">document
order</a>, with duplicates eliminated based on node identity.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>3.4 Sequence Expressions</h3>
<p>XQuery 3.0 supports operators to construct, filter, and combine
<a title="sequence" href="#dt-sequence">sequences</a> of <a title=
"item" href="#dt-item">items</a>. Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>,
and <code>( )</code> into a single sequence results in the sequence
<code>(1, 2, 3)</code>.</p>
<div class="div3">
<h4><a name="construct_seq" id="construct_seq"></a>3.4.1
Constructing Sequences</h4>
<h5><a name="d2e14656" id="d2e14656"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e13589.doc-xquery30-Expr" id=
"noid_d3e13589.doc-xquery30-Expr"></a>[39]&#160;&#160;&#160;</td>
<td><code>Expr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery30-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-RangeExpr" id=
"doc-xquery30-RangeExpr"></a>[87]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#doc-xquery30-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-comma-operator" id="dt-comma-operator" title=
"comma operator">Definition</a>: One way to construct a sequence is
by using the <b>comma operator</b>, which evaluates each of its
operands and concatenates the resulting sequences, in order, into a
single result sequence.] Empty parentheses can be used to denote an
empty sequence.</p>
<p>A sequence may contain duplicate <a title="item" href=
"#dt-item">items</a>, but a sequence is never an item in another
sequence. When a new sequence is created by concatenating two or
more input sequences, the new sequence contains all the items of
the input sequences and its length is the sum of the lengths of the
input sequences.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In places where the grammar calls for <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a>, such as the arguments of
a function call, any expression that contains a top-level comma
operator must be enclosed in parentheses.</p>
</div>
<p>Here are some examples of expressions that construct
sequences:</p>
<ul>
<li>
<p>The result of this expression is a sequence of five
integers:</p>
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</li>
<li>
<p>This expression combines four sequences of length one, two,
zero, and two, respectively, into a single sequence of length five.
The result of this expression is the sequence <code>10, 1, 2, 3,
4</code>.</p>
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</li>
<li>
<p>The result of this expression is a sequence containing all
<code>salary</code> children of the context node followed by all
<code>bonus</code> children.</p>
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</li>
<li>
<p>Assuming that <code>$price</code> is bound to the value
<code>10.50</code>, the result of this expression is the sequence
<code>10.50, 10.50</code>.</p>
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</li>
</ul>
<p>A <b>range expression</b> can be used to construct a sequence of
consecutive integers. Each of the operands of the <code>to</code>
operator is converted as though it was an argument of a function
with the expected parameter type <code>xs:integer?</code>. If
either operand is an empty sequence, or if the integer derived from
the first operand is greater than the integer derived from the
second operand, the result of the range expression is an empty
sequence. If the two operands convert to the same integer, the
result of the range expression is that integer. Otherwise, the
result is a sequence containing the two integer operands and every
integer between the two operands, in increasing order.</p>
<ul>
<li>
<p>This example uses a range expression as one operand in
constructing a sequence. It evaluates to the sequence <code>10, 1,
2, 3, 4</code>.</p>
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</li>
<li>
<p>This example constructs a sequence of length one containing the
single integer <code>10</code>.</p>
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</li>
<li>
<p>The result of this example is a sequence of length zero.</p>
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</li>
<li>
<p>This example uses the <code>fn:reverse</code> function to
construct a sequence of six integers in decreasing order. It
evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p>
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="combining_seq" id="combining_seq"></a>3.4.2 Combining
Node Sequences</h4>
<h5><a name="d2e14787" id="d2e14787"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-UnionExpr" id=
"doc-xquery30-UnionExpr"></a>[90]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#doc-xquery30-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-IntersectExceptExpr" id=
"doc-xquery30-IntersectExceptExpr"></a>[91]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#doc-xquery30-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XQuery 3.0 provides the following operators for combining
sequences of nodes:</p>
<ul>
<li>
<p>The <code>union</code> and <code>|</code> operators are
equivalent. They take two node sequences as operands and return a
sequence containing all the nodes that occur in either of the
operands.</p>
</li>
<li>
<p>The <code>intersect</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in both operands.</p>
</li>
<li>
<p>The <code>except</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in the first operand but not in the second operand.</p>
</li>
</ul>
<p>All these operators eliminate duplicate nodes from their result
sequences based on node identity. <span class="xquery">If <a title=
"ordering mode" href="#dt-ordering-mode">ordering mode</a> is
<code>ordered</code>, the resulting sequence is returned in
<a title="document order" href="#dt-document-order">document
order</a>; otherwise it is returned in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</span></p>
<p>If an operand of <code>union</code>, <code>intersect</code>, or
<code>except</code> contains an item that is not a node, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<p>If an IntersectExceptExpr contains more than two
InstanceofExprs, they are grouped from left to right. With a
UnionExpr, it makes no difference how operands are grouped, the
results are the same.</p>
<div class="exampleOuter">
<p>Here are some examples of expressions that combine sequences.
Assume the existence of three element nodes that we will refer to
by symbolic names A, B, and C. <span class="xquery">Assume that
<a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>
is <code>ordered</code>.</span> Assume that the variables
<code>$seq1</code>, <code>$seq2</code> and <code>$seq3</code> are
bound to the following sequences of these nodes:</p>
<ul>
<li>
<p><code>$seq1</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq2</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq3</code> is bound to (B, C)</p>
</li>
</ul>
<p>Then:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B,
C).</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code> evaluates to the sequence
containing B only.</p>
</li>
<li>
<p><code>$seq1 except $seq2</code> evaluates to the empty
sequence.</p>
</li>
<li>
<p><code>$seq2 except $seq3</code> evaluates to the sequence
containing A only.</p>
</li>
</ul>
</div>
<p>In addition to the sequence operators described here, <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of
items in a sequence, and for removing duplicate items from a
sequence.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-arithmetic" id="id-arithmetic"></a>3.5 Arithmetic
Expressions</h3>
<p>XQuery 3.0 provides arithmetic operators for addition,
subtraction, multiplication, division, and modulus, in their usual
binary and unary forms.</p>
<h5><a name="d2e14958" id="d2e14958"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AdditiveExpr" id=
"doc-xquery30-AdditiveExpr"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#doc-xquery30-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-MultiplicativeExpr" id=
"doc-xquery30-MultiplicativeExpr"></a>[89]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xquery30-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-UnaryExpr" id=
"doc-xquery30-UnaryExpr"></a>[96]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#doc-xquery30-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ValueExpr" id=
"doc-xquery30-ValueExpr"></a>[97]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ValidateExpr">ValidateExpr</a> |
<a href="#doc-xquery30-ExtensionExpr">ExtensionExpr</a> | <a href=
"#doc-xquery30-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
</table>
<p>A subtraction operator must be preceded by whitespace if it
could otherwise be interpreted as part of the previous token. For
example, <code>a-b</code> will be interpreted as a name, but
<code>a - b</code> and <code>a -b</code> will be interpreted as
arithmetic expressions. (See <a href="#whitespace-rules"><b>A.2.4
Whitespace Rules</b></a> for further details on whitespace
handling.)</p>
<p>If an AdditiveExpr contains more than two MultiplicativeExprs,
they are grouped from left to right. So, for instance,</p>
<div class="exampleInner">
<pre>
A - B + C - D
</pre></div>
<p>is equivalent to</p>
<div class="exampleInner">
<pre>
((A - B) + C) - D
</pre></div>
<p>Similarly, the operands of a MultiplicativeExpr are grouped from
left to right.</p>
<p>The first step in evaluating an arithmetic expression is to
evaluate its operands. The order in which the operands are
evaluated is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p><span class="xquery">Each</span> operand is evaluated by
applying the following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
arithmetic expression is an empty sequence, and the implementation
need not evaluate the other operand or apply the operator. However,
an implementation may choose to evaluate the other operand in order
to determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:double</code>. If the cast fails, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised. [err:FORG0001]</p>
</li>
</ol>
<p>After evaluation of the operands, if the types of the operands
are a valid combination for the given arithmetic operator, the
operator is applied to the operands, resulting in an atomic value
or a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> (for example, an error might result from dividing by
zero.) The combinations of atomic types that are accepted by the
various arithmetic operators, and their respective result types,
are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination, including the
dynamic errors that can be raised by the operator. The definitions
of the operator functions are found in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>XQuery 3.0 supports two division operators named
<code>div</code> and <code>idiv</code>. Each of these operators
accepts two operands of any <a title="numeric" href=
"#dt-numeric">numeric</a> type. As described in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>, <code>$arg1 idiv $arg2</code> is equivalent to
<code>($arg1 div $arg2) cast as xs:integer?</code> except for error
cases.</p>
<p>Here are some examples of arithmetic expressions:</p>
<ul>
<li>
<p>The first expression below returns the <code>xs:decimal</code>
value <code>-1.5</code>, and the second expression returns the
<code>xs:integer</code> value <code>-1</code>:</p>
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</li>
<li>
<p>Subtraction of two date values results in a value of type
<code>xs:dayTimeDuration</code>:</p>
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</li>
<li>
<p>This example illustrates the difference between a subtraction
operator and a hyphen:</p>
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</li>
<li>
<p>Unary operators have higher precedence than binary operators,
subject of course to the use of parentheses. Therefore, the
following two examples have different meanings:</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops">Multiple consecutive unary
arithmetic operators are permitted by XQuery 3.0 for compatibility
with <a href="#xpath">[XML Path Language (XPath) Version
1.0]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-string-concat-expr" id=
"id-string-concat-expr"></a>3.6 String Concatenation
Expressions</h3>
<h5><a name="d2e15156" id="d2e15156"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-StringConcatExpr" id=
"doc-xquery30-StringConcatExpr"></a>[86]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringConcatExpr">StringConcatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-RangeExpr">RangeExpr</a> ( "||"
<a href="#doc-xquery30-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>String concatenation expressions allow the string
representations of values to be concatenated. In XQuery 3.0,
<code>$a || $b</code> is equivalent to <code>fn:concat($a,
$b)</code>. The following expression evaluates to the string
<code>concatenate</code>:</p>
<div class="exampleInner">
<pre>
"con" || "cat" || "enate"
</pre></div>
</div>
<div class="div2">
<h3><a name="id-comparisons" id="id-comparisons"></a>3.7 Comparison
Expressions</h3>
<p>Comparison expressions allow two values to be compared. XQuery
3.0 provides three kinds of comparison expressions, called value
comparisons, general comparisons, and node comparisons.</p>
<h5><a name="d2e15187" id="d2e15187"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ComparisonExpr" id=
"doc-xquery30-ComparisonExpr"></a>[85]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-StringConcatExpr">StringConcatExpr</a> ( (<a href=
"#doc-xquery30-ValueComp">ValueComp</a><br />
| <a href="#doc-xquery30-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xquery30-NodeComp">NodeComp</a>) <a href=
"#doc-xquery30-StringConcatExpr">StringConcatExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ValueComp" id=
"doc-xquery30-ValueComp"></a>[99]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-GeneralComp" id=
"doc-xquery30-GeneralComp"></a>[98]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NodeComp" id=
"doc-xquery30-NodeComp"></a>[100]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-value-comparisons" id=
"id-value-comparisons"></a>3.7.1 Value Comparisons</h4>
<p>The value comparison operators are <code>eq</code>,
<code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>,
and <code>ge</code>. Value comparisons are used for comparing
single values.</p>
<p>The first step in evaluating a value comparison is to evaluate
its operands. The order in which the operands are evaluated is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. Each
operand is evaluated by applying the following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
value comparison is an empty sequence, and the implementation need
not evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this rule is to make value comparisons
transitive. Users should be aware that the general comparison
operators have a different rule for casting of
<code>xs:untypedAtomic</code> operands. Users should also be aware
that transitivity of value comparisons may be compromised by loss
of precision during type conversion (for example, two
<code>xs:integer</code> values that differ slightly may both be
considered equal to the same <code>xs:float</code> value because
<code>xs:float</code> has less precision than
<code>xs:integer</code>).</p>
</div>
</li>
</ol>
<p>Next, if possible, the two operands are converted to their least
common type by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, if the operands are of type
<code>hatsize</code> (derived from <code>xs:integer</code>) and
<code>shoesize</code> (derived from <code>xs:float</code>), their
least common type is <code>xs:float</code>.</p>
<p>Finally, if the types of the operands are a valid combination
for the given operator, the operator is applied to the operands.
The combinations of atomic types that are accepted by the various
value comparison operators, and their respective result types, are
listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination. The
definitions of the operator functions are found in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
<p>Informally, if both atomized operands consist of exactly one
atomic value, then the result of the comparison is
<code>true</code> if the value of the first operand is (equal, not
equal, less than, less than or equal, greater than, greater than or
equal) to the value of the second operand; otherwise the result of
the comparison is <code>false</code>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Here are some examples of value comparisons:</p>
<ul>
<li>
<p>The following comparison atomizes the node(s) that are returned
by the expression <code>$book/author</code>. The comparison is true
only if the result of atomization is the value "Kennedy" as an
instance of <code>xs:string</code> or
<code>xs:untypedAtomic</code>. If the result of atomization is an
empty sequence, the result of the comparison is an empty sequence.
If the result of atomization is a sequence containing more than one
value, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</li>
<li>
<p>The following <a title="path expression" href=
"#dt-path-expression">path expression</a> contains a predicate that
selects products whose weight is greater than 100. For any product
that does not have a <code>weight</code> subelement, the value of
the predicate is the empty sequence, and the product is not
selected. This example assumes that <code>weight</code> is a
validated element with a numeric type.</p>
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</li>
<li>
<p>The following comparisons are true because, in each case, the
two constructed nodes have the same value after atomization, even
though they have different identities and/or names:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;
</pre></div>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;
</pre></div>
</li>
<li>
<p>The following comparison is true if <code>my:hatsize</code> and
<code>my:shoesize</code> are both user-defined types that are
derived by restriction from a primitive <a title="numeric" href=
"#dt-numeric">numeric</a> type:</p>
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</li>
<li>
<p>The following comparison is true. The <code>eq</code> operator
compares two QNames by performing codepoint-comparisons of their
namespace URIs and their local names, ignoring their namespace
prefixes.</p>
<div class="exampleInner">
<pre>
fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-general-comparisons" id=
"id-general-comparisons"></a>3.7.2 General Comparisons</h4>
<p>The general comparison operators are <code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, and <code>&gt;=</code>. General comparisons are
existentially quantified comparisons that may be applied to operand
sequences of any length. The result of a general comparison that
does not raise an error is always <code>true</code> or
<code>false</code>.</p>
<p><span class="xquery">A</span> general comparison is evaluated by
applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to each operand. After atomization, each operand is a
sequence of atomic values.</p>
</li>
<li>
<p>The result of the comparison is <code>true</code> if and only if
there is a pair of atomic values, one in the first operand sequence
and the other in the second operand sequence, that have the
required <b>magnitude relationship</b>. Otherwise the result of the
comparison is <code>false</code>. The <b>magnitude relationship</b>
between two atomic values is determined by applying the following
rules. If a <code>cast</code> operation called for by these rules
is not successful, a dynamic error is raised. [err:FORG0001]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of these rules is to preserve compatibility with
XPath 1.0, in which (for example) <code>x &lt; 17</code> is a
numeric comparison if <code>x</code> is an untyped value. Users
should be aware that the value comparison operators have different
rules for casting of <code>xs:untypedAtomic</code> operands.</p>
</div>
<ol class="enumla">
<li>
<p>If both atomic values are instances of
<code>xs:untypedAtomic</code>, then the values are cast to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>If exactly one of the atomic values is an instance of
<code>xs:untypedAtomic</code>, it is cast to a type depending on
the other value's dynamic type T according to the following rules,
in which V denotes the value to be cast:</p>
<ol class="enumlr">
<li>
<p>If T is a numeric type or is derived from a numeric type, then V
is cast to <code>xs:double</code>.</p>
</li>
<li>
<p>If T is <code>xs:dayTimeDuration</code> or is derived from
<code>xs:dayTimeDuration</code>, then V is cast to
<code>xs:dayTimeDuration</code>.</p>
</li>
<li>
<p>If T is <code>xs:yearMonthDuration</code> or is derived from
<code>xs:yearMonthDuration</code>, then V is cast to
<code>xs:yearMonthDuration</code>.</p>
</li>
<li>
<p>In all other cases, V is cast to the primitive base type of
T.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The special treatment of the duration types is required to avoid
errors that may arise when comparing the primitive type
<code>xs:duration</code> with any duration type.</p>
</div>
</li>
<li>
<p>After performing the conversions described above, the atomic
values are compared using one of the value comparison operators
<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>,
<code>gt</code>, or <code>ge</code>, depending on whether the
general comparison operator was <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if and only if the result of this value comparison
is <code>true</code>.</p>
</li>
</ol>
</li>
</ol>
<p>When evaluating a general comparison in which either operand is
a sequence of items, an implementation may return <code>true</code>
as soon as it finds an item in the first operand and an item in the
second operand that have the required <b>magnitude
relationship</b>. Similarly, a general comparison may raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
as soon as it encounters an error in evaluating either operand, or
in comparing a pair of items from the two operands. As a result of
these rules, the result of a general comparison is not
deterministic in the presence of errors.</p>
<p>Here are some examples of general comparisons:</p>
<ul>
<li>
<p>The following comparison is true if the <a title="typed value"
href="#dt-typed-value">typed value</a> of any <code>author</code>
subelement of <code>$book1</code> is "Kennedy" as an instance of
<code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</li>
<li>
<p>The following example contains three general comparisons. The
value of the first two comparisons is <code>true</code>, and the
value of the third comparison is <code>false</code>. This example
illustrates the fact that general comparisons are not
transitive.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>The following example contains two general comparisons, both of
which are <code>true</code>. This example illustrates the fact that
the <code>=</code> and <code>!=</code> operators are not inverses
of each other.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p>Suppose that <code>$a</code>, <code>$b</code>, and
<code>$c</code> are bound to element nodes with type annotation
<code>xs:untypedAtomic</code>, with <a title="string value" href=
"#dt-string-value">string values</a> "<code>1</code>",
"<code>2</code>", and "<code>2.0</code>" respectively. Then
<code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>,
because <code>$b</code> and <code>$c</code> are compared as
strings. However, <code>($a, $b) = ($c, 2.0)</code> returns
<code>true</code>, because <code>$b</code> and <code>2.0</code> are
compared as numbers.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-node-comparisons" id=
"id-node-comparisons"></a>3.7.3 Node Comparisons</h4>
<p>Node comparisons are used to compare two nodes, by their
identity or by their <a title="document order" href=
"#dt-document-order">document order</a>. The result of a node
comparison is defined by the following rules:</p>
<ol class="enumar">
<li>
<p>The operands of a node comparison are evaluated in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</p>
</li>
<li>
<p>If either operand is an empty sequence, the result of the
comparison is an empty sequence, and the implementation need not
evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>Each operand must be either a single node or an empty sequence;
otherwise a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>A comparison with the <code>is</code> operator is
<code>true</code> if the two operand nodes have the same identity,
and are thus the same node; otherwise it is <code>false</code>. See
<a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a> for a definition of node identity.</p>
</li>
<li>
<p>A comparison with the <code>&lt;&lt;</code> operator returns
<code>true</code> if the left operand node precedes the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
<li>
<p>A comparison with the <code>&gt;&gt;</code> operator returns
<code>true</code> if the left operand node follows the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
</ol>
<p>Here are some examples of node comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if the left and right
sides each evaluate to exactly the same single node:</p>
<div class="exampleInner">
<pre>
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</pre></div>
</li>
<li>
<p>The following comparison is false because each constructed node
has its own identity:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;
</pre></div>
</li>
<li>
<p>The following comparison is true only if the node identified by
the left side occurs before the node identified by the right side
in document order:</p>
<div class="exampleInner">
<pre>
/transactions/purchase[parcel="28-451"]
   &lt;&lt; /transactions/sale[parcel="33-870"]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>3.8 Logical Expressions</h3>
<p>A <b>logical expression</b> is either an <b>and-expression</b>
or an <b>or-expression</b>. If a logical expression does not raise
an error, its value is always one of the boolean values
<code>true</code> or <code>false</code>.</p>
<h5><a name="d2e15816" id="d2e15816"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrExpr" id=
"doc-xquery30-OrExpr"></a>[83]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AndExpr">AndExpr</a> ( "or"
<a href="#doc-xquery30-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AndExpr" id=
"doc-xquery30-AndExpr"></a>[84]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#doc-xquery30-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p>The first step in evaluating a logical expression is to find the
<a title="effective boolean value" href="#dt-ebv">effective boolean
value</a> of each of its operands (see <a href="#id-ebv"><b>2.4.3
Effective Boolean Value</b></a>).</p>
<p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><span class="xquery">either <code>false</code> or
error</span></td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td>error</td>
<td><span class="xquery">either <code>false</code> or
error</span></td>
<td>error</td>
</tr>
</tbody>
</table>
<p>The value of an or-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><span class="xquery">either <code>true</code> or
error</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td><span class="xquery">either <code>true</code> or
error</span></td>
<td>error</td>
<td>error</td>
</tr>
</tbody>
</table>
<p><span class="xquery">The order in which the operands of a
logical expression are evaluated is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. The
tables above are defined in such a way that</span> an or-expression
can return <code>true</code> if the first expression evaluated is
true, and it can raise an error if evaluation of the first
expression raises an error. Similarly, an and-expression can return
<code>false</code> if the first expression evaluated is false, and
it can raise an error if evaluation of the first expression raises
an error. As a result of these rules, a logical expression is not
deterministic in the presence of errors, as illustrated in the
examples below.</p>
<p>Here are some examples of logical expressions:</p>
<ul>
<li>
<p>The following expressions return <code>true</code>:</p>
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</li>
<li>
<p>The following expression may return either <code>false</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>:</p>
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>The following expression may return either <code>true</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>:</p>
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>The following expression must raise a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</li>
</ul>
<p>In addition to and- and or-expressions, XQuery 3.0 provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value. The <code>fn:not</code>
function is defined in <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>. The <code>fn:not</code>
function reduces its parameter to an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a>. It then returns <code>true</code> if the effective
boolean value of its parameter is <code>false</code>, and
<code>false</code> if the effective boolean value of its parameter
is <code>true</code>. If an error is encountered in finding the
effective boolean value of its operand, <code>fn:not</code> raises
the same error.</p>
</div>
<div class="div2">
<h3><a name="id-constructors" id="id-constructors"></a>3.9
Constructors</h3>
<p>XQuery provides constructors that can create XML structures
within a query. Constructors are provided for element, attribute,
document, text, comment, and processing instruction nodes. Two
kinds of constructors are provided: <b>direct constructors</b>,
which use an XML-like notation, and <b>computed constructors</b>,
which use a notation based on enclosed expressions.</p>
<h5><a name="d2e16136" id="d2e16136"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Constructor" id=
"doc-xquery30-Constructor"></a>[136]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Constructor">Constructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#doc-xquery30-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirectConstructor" id=
"doc-xquery30-DirectConstructor"></a>[137]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirectConstructor">DirectConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#doc-xquery30-DirCommentConstructor">DirCommentConstructor</a><br />

| <a href=
"#doc-xquery30-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirElemConstructor" id=
"doc-xquery30-DirElemConstructor"></a>[138]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirElemConstructor">DirElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;" <a href="#doc-xquery30-QName">QName</a> <a href=
"#doc-xquery30-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#doc-xquery30-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#doc-xquery30-QName">QName</a> <a href=
"#prod-xquery30-S">S</a>? "&gt;"))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirElemContent" id=
"doc-xquery30-DirElemContent"></a>[143]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirElemContent">DirElemContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href="#doc-xquery30-CDataSection">CDataSection</a><br />
| <a href="#doc-xquery30-CommonContent">CommonContent</a><br />
| <a href=
"#doc-xquery30-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ElementContentChar" id=
"doc-xquery30-ElementContentChar"></a>[206]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementContentChar">ElementContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
[{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CommonContent" id=
"doc-xquery30-CommonContent"></a>[144]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CommonContent">CommonContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | "{{" | "}}" |
<a href="#doc-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CDataSection" id=
"doc-xquery30-CDataSection"></a>[149]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CDataSection">CDataSection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;![CDATA[" <a href=
"#doc-xquery30-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CDataSectionContents" id=
"doc-xquery30-CDataSectionContents"></a>[150]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CDataSectionContents">CDataSectionContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char*
']]&gt;' Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirAttributeList" id=
"doc-xquery30-DirAttributeList"></a>[139]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirAttributeList">DirAttributeList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-S">S</a> (<a href=
"#doc-xquery30-QName">QName</a> <a href="#prod-xquery30-S">S</a>?
"=" <a href="#prod-xquery30-S">S</a>? <a href=
"#doc-xquery30-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirAttributeValue" id=
"doc-xquery30-DirAttributeValue"></a>[140]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirAttributeValue">DirAttributeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#doc-xquery30-EscapeQuot">EscapeQuot</a> |
<a href=
"#doc-xquery30-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#doc-xquery30-EscapeApos">EscapeApos</a> |
<a href="#doc-xquery30-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-QuotAttrValueContent" id=
"doc-xquery30-QuotAttrValueContent"></a>[141]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QuotAttrValueContent">QuotAttrValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href=
"#doc-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AposAttrValueContent" id=
"doc-xquery30-AposAttrValueContent"></a>[142]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AposAttrValueContent">AposAttrValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href=
"#doc-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-QuotAttrContentChar" id=
"doc-xquery30-QuotAttrContentChar"></a>[207]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QuotAttrContentChar">QuotAttrContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
["{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AposAttrContentChar" id=
"doc-xquery30-AposAttrContentChar"></a>[208]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AposAttrContentChar">AposAttrContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
['{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e14938.doc-xquery30-EscapeQuot" id=
"noid_d3e14938.doc-xquery30-EscapeQuot"></a>[204]&#160;&#160;&#160;</td>
<td><code>EscapeQuot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e14939.doc-xquery30-EscapeApos" id=
"noid_d3e14939.doc-xquery30-EscapeApos"></a>[205]&#160;&#160;&#160;</td>
<td><code>EscapeApos</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-EnclosedExpr" id=
"doc-xquery30-EnclosedExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#doc-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
</table>
<p>This section contains a conceptual description of the semantics
of various kinds of constructor expressions. An XQuery
implementation is free to use any implementation technique that
produces the same result as the processing steps described in this
section.</p>
<div class="div3">
<h4><a name="id-element-constructor" id=
"id-element-constructor"></a>3.9.1 Direct Element Constructors</h4>
<p>An <b>element constructor</b> creates an element node. [<a name=
"dt-direct-elem-const" id="dt-direct-elem-const" title=
"direct element constructor">Definition</a>: A <b>direct element
constructor</b> is a form of element constructor in which the name
of the constructed element is a constant.] Direct element
constructors are based on standard XML notation. For example, the
following expression is a direct element constructor that creates a
<code>book</code> element containing an attribute and some nested
elements:</p>
<div class="exampleInner">
<pre>
&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</pre></div>
<p>If the element name in a direct element constructor has a
namespace prefix, the namespace prefix is resolved to a namespace
URI using the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If the
element name has no namespace prefix, it is implicitly qualified by
the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. Note that
both the statically known namespaces and the default element/type
namespace may be affected by <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attributes</a>
found inside the element constructor. The namespace prefix of the
element name is retained after expansion of the <a title=
"lexical QName" href="#dt-qname">lexical QName</a> , as described
in <a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a>. The resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> becomes the
<code>node-name</code> property of the constructed element
node.</p>
<p>In a direct element constructor, the name used in the end tag
must exactly match the name used in the corresponding start tag,
including its prefix or absence of a prefix [<a href="#ERRXQST0118"
title="err:XQST0118">err:XQST0118</a>].</p>
<p>In a direct element constructor, curly braces { } delimit
<b>enclosed expressions</b>, distinguishing them from literal text.
Enclosed expressions are evaluated and replaced by their value, as
illustrated by the following example:</p>
<div class="exampleInner">
<pre>
&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;
</pre></div>
<p>The above query might generate the following result (whitespace
has been added for readability to this result and other result
examples in this document):</p>
<div class="exampleInner">
<pre>
&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;
</pre></div>
<p>Since XQuery uses curly braces to denote enclosed expressions,
some convention is needed to denote a curly brace used as an
ordinary character. For this purpose, a pair of identical curly
brace characters within the content of an element or attribute are
interpreted by XQuery as a single curly brace character (that is,
the pair "<code>{{</code>" represents the character
"<code>{</code>" and the pair "<code>}}</code>" represents the
character "<code>}</code>".) Alternatively, the <a title=
"character reference" href="#dt-character-reference">character
references</a> <code>&amp;#x7b;</code> and <code>&amp;#x7d;</code>
can be used to denote curly brace characters. A single left curly
brace ("<code>{</code>") is interpreted as the beginning delimiter
for an enclosed expression. A single right curly brace
("<code>}</code>") without a matching left curly brace is treated
as a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>].</p>
<p>The result of an element constructor is a new element node, with
its own node identity. All the attribute and descendant nodes of
the new element node are also new nodes with their own identities,
even if they are copies of existing nodes.</p>
<div class="div4">
<h5><a name="id-attributes" id="id-attributes"></a>3.9.1.1
Attributes</h5>
<p>The start tag of a direct element constructor may contain one or
more attributes. As in XML, each attribute is specified by a name
and a value. In a direct element constructor, the name of each
attribute is specified by a constant <a title="lexical QName" href=
"#dt-qname">lexical QName</a>, and the value of the attribute is
specified by a string of characters enclosed in single or double
quotes. As in the main content of the element constructor, an
attribute value may contain expressions enclosed in curly braces,
which are evaluated and replaced by their value during processing
of the element constructor.</p>
<p>Each attribute in a direct element constructor creates a new
attribute node, with its own node identity, whose parent is the
constructed element node. However, note that <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attributes</a> (see
<a href="#id-namespaces"><b>3.9.1.2 Namespace Declaration
Attributes</b></a>) do not create attribute nodes.</p>
<p>If an attribute name has a namespace prefix, the prefix is
resolved to a namespace URI using the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If the
attribute name has no namespace prefix, the attribute is in no
namespace. Note that the statically known namespaces used in
resolving an attribute name may be affected by <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attributes</a> that
are found inside the same element constructor. The namespace prefix
of the attribute name is retained after expansion of the <a title=
"lexical QName" href="#dt-qname">lexical QName</a>, as described in
<a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a>. The resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> becomes the
<code>node-name</code> property of the constructed attribute
node.</p>
<p>If the attributes in a direct element constructor do not have
distinct <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> as their respective
<code>node-name</code> properties, a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXQST0040" title="err:XQST0040">err:XQST0040</a>].</p>
<p>Conceptually, an attribute (other than a namespace declaration
attribute) in a direct element constructor is processed by the
following steps:</p>
<ol class="enumar">
<li>
<p>Each consecutive sequence of literal characters in the attribute
content is processed as a string literal containing those
characters, with the following exceptions:</p>
<ol class="enumla">
<li>
<p>Each occurrence of two consecutive <code>{</code> characters is
replaced by a single <code>{</code> character.</p>
</li>
<li>
<p>Each occurrence of two consecutive <code>}</code> characters is
replaced by a single <code>}</code> character.</p>
</li>
<li>
<p>Each occurrence of <a href=
"#doc-xquery30-EscapeQuot">EscapeQuot</a> is replaced by a single
<code>"</code> character.</p>
</li>
<li>
<p>Each occurrence of <a href=
"#doc-xquery30-EscapeApos">EscapeApos</a> is replaced by a single
<code>'</code> character.</p>
</li>
</ol>
<p>Attribute value normalization is then applied to normalize
whitespace and expand <a title="character reference" href=
"#dt-character-reference">character references</a> and <a title=
"predefined entity reference" href=
"#dt-predefined-entity-reference">predefined entity references</a>.
<span>The rules for attribute value normalization are the rules
from Section 3.3.3 of [XML 1.0] or Section 3.3.3 of [XML 1.1] (it
is implementation-defined which version is used). The rules are
applied as though the type of the attribute were CDATA (leading and
trailing whitespace characters are not stripped.)</span></p>
</li>
<li>
<p>Each enclosed expression is converted to a string as
follows:</p>
<ol class="enumla">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the enclosed expression, converting it to a
sequence of atomic values.</p>
</li>
<li>
<p>If the result of atomization is an empty sequence, the result is
the zero-length string. Otherwise, each atomic value in the
atomized sequence is cast into a string.</p>
</li>
<li>
<p>The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair.</p>
</li>
</ol>
</li>
<li>
<p>Adjacent strings resulting from the above steps are concatenated
with no intervening blanks. The resulting string becomes the
<code>string-value</code> property of the attribute node. The
attribute node is given a <a title="type annotation" href=
"#dt-type-annotation">type annotation</a> of
<code>xs:untypedAtomic</code> (this type annotation may change if
the parent element is validated). The <code>typed-value</code>
property of the attribute node is the same as its
<code>string-value</code>, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>The <code>parent</code> property of the attribute node is set to
the element node constructed by the direct element constructor that
contains this attribute.</p>
</li>
<li>
<p>If the attribute name is <code>xml:id</code>, then
<code>xml:id</code> processing is performed as defined in <a href=
"#XMLID">[XML ID]</a>. This ensures that the attribute has the type
<code>xs:ID</code> and that its value is properly normalized. If an
error is encountered during <code>xml:id</code> processing, an
implementation may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091"
title="err:XQDY0091">err:XQDY0091</a>].</p>
</li>
<li>
<p>If the attribute name is <code>xml:id</code>, the
<code>is-id</code> property of the resulting attribute node is set
to <code>true</code>; otherwise the <code>is-id</code> property is
set to <code>false</code>. The <code>is-idrefs</code> property of
the attribute node is unconditionally set to
<code>false</code>.</p>
</li>
</ol>
<ul>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="7"/&gt;
</pre></div>
<p>The string value of the <code>size</code> attribute is
"<code>7</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="{7}"/&gt;
</pre></div>
<p>The string value of the <code>size</code> attribute is
"<code>7</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="{()}"/&gt;
</pre></div>
<p>The string value of the <code>size</code> attribute is the
zero-length string.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;
</pre></div>
<p>The string value of the <code>ref</code> attribute is "<code>[1
5 6 7 9]</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="As big as {$hat/@size}"/&gt;
</pre></div>
<p>The string value of the <code>size</code> attribute is the
string "<code>As big as</code> ", concatenated with the string
value of the node denoted by the expression
<code>$hat/@size</code>.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-namespaces" id="id-namespaces"></a>3.9.1.2
Namespace Declaration Attributes</h5>
<p>The names of a constructed element and its attributes may be
<a title="lexical QName" href="#dt-qname">lexical QNames</a> that
include <b>namespace prefixes</b>. Namespace prefixes can be bound
to namespaces in the <a title="Prolog" href="#dt-prolog">Prolog</a>
or by <b>namespace declaration attributes</b>. It is a <a title=
"static error" href="#dt-static-error">static error</a> to use a
namespace prefix that has not been bound to a namespace [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p>
<p>[<a name="dt-namespace-decl-attr" id="dt-namespace-decl-attr"
title="namespace declaration attribute">Definition</a>: A
<b>namespace declaration attribute</b> is used inside a direct
element constructor. Its purpose is to bind a namespace prefix or
to set the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> for the
constructed element node, including its attributes.] Syntactically,
a namespace declaration attribute has the form of an attribute with
namespace prefix <code>xmlns</code>, or with name
<code>xmlns</code> and no namespace prefix. All the namespace
declaration attributes of a given element must have distinct names
[<a href="#ERRXQST0071" title="err:XQST0071">err:XQST0071</a>].
Each namespace declaration attribute is processed as follows:</p>
<ul>
<li>
<p>The value of the namespace declaration attribute (a <a href=
"#doc-xquery30-DirAttributeValue">DirAttributeValue</a>) is
processed as follows. If the <a href=
"#doc-xquery30-DirAttributeValue">DirAttributeValue</a> contains an
<a href="#doc-xquery30-EnclosedExpr">EnclosedExpr</a>, a static
error is raised [<a href="#ERRXQST0022" title=
"err:XQST0022">err:XQST0022</a>]. Otherwise, it is processed as
described in rule 1 of <a href="#id-attributes"><b>3.9.1.1
Attributes</b></a>. An implementation may raise a static error
[<a href="#ERRXQST0046" title="err:XQST0046">err:XQST0046</a>] if
the resulting value is of nonzero length and is <span>neither an
absolute URI nor a relative URI</span>. The resulting value is used
as the namespace URI in the following rules.</p>
</li>
<li>
<p>If the prefix of the attribute name is <code>xmlns</code>, then
the local part of the attribute name is interpreted as a namespace
prefix. This prefix and the namespace URI are added to the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> of the
constructor expression (overriding any existing binding of the
given prefix), and are also added as a namespace binding to the
<a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of the
constructed element. If the namespace URI is a zero-length string
and the implementation supports <a href="#XMLNAMES11">[XML Names
1.1]</a>, any existing namespace binding for the given prefix is
removed from the <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of the
constructed element and from the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> of the
constructor expression. If the namespace URI is a zero-length
string and the implementation does not support <a href=
"#XMLNAMES11">[XML Names 1.1]</a>, a static error is raised
[<a href="#ERRXQST0085" title="err:XQST0085">err:XQST0085</a>]. It
is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> whether an
implementation supports <a href="#XMLNAMES">[XML Names]</a> or
<a href="#XMLNAMES11">[XML Names 1.1]</a>.</p>
</li>
<li>
<p>If the name of the namespace declaration attribute is
<code>xmlns</code> with no prefix, then the namespace URI specifies
the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> of the
constructor expression (overriding any existing default), and is
added (with no prefix) to the <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of the
constructed element (overriding any existing namespace binding with
no prefix). If the namespace URI is a zero-length string, the
<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> of the
constructor expression is set to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>,
and any no-prefix namespace binding is removed from the <a title=
"in-scope namespaces" href="#dt-in-scope-namespaces">in-scope
namespaces</a> of the constructed element.</p>
</li>
<li>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXQST0070" title=
"err:XQST0070">err:XQST0070</a>] if a namespace declaration
attribute attempts to do any of the following:</p>
<ul>
<li>
<p>Bind the prefix <code>xml</code> to some namespace URI other
than <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind a prefix other than <code>xml</code> to the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind the prefix <code>xmlns</code> to any namespace URI.</p>
</li>
<li>
<p>Bind a prefix to the namespace URI
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
</ul>
</li>
</ul>
<p>A namespace declaration attribute does not cause an attribute
node to be created.</p>
<p>The following examples illustrate namespace declaration
attributes:</p>
<ul>
<li>
<p>In this element constructor, a namespace declaration attribute
is used to set the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> to
<code>http://example.org/animals</code>:</p>
<div class="exampleInner">
<pre>
&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;
</pre></div>
</li>
<li>
<p>In this element constructor, namespace declaration attributes
are used to bind the namespace prefixes <code>metric</code> and
<code>english</code>:</p>
<div class="exampleInner">
<pre>
&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-content" id="id-content"></a>3.9.1.3 Content</h5>
<p>The part of a direct element constructor between the start tag
and the end tag is called the <b>content</b> of the element
constructor. This content may consist of text characters (parsed as
<a href="#doc-xquery30-ElementContentChar">ElementContentChar</a>),
nested direct constructors, <a href=
"#doc-xquery30-CDataSection">CDataSections</a>, character and
<a title="predefined entity reference" href=
"#dt-predefined-entity-reference">predefined entity references</a>,
and expressions enclosed in curly braces. In general, the value of
an enclosed expression may be any sequence of nodes and/or atomic
values. Enclosed expressions can be used in the content of an
element constructor to compute both the content and the attributes
of the constructed node.</p>
<p>Conceptually, the content of an element constructor is processed
as follows:</p>
<ol class="enumar">
<li>
<p>The content is evaluated to produce a sequence of nodes called
the <b>content sequence</b>, as follows:</p>
<ol class="enumla">
<li>
<p>If the <a title="boundary-space policy" href=
"#dt-boundary-space-policy">boundary-space policy</a> in the
<a title="static context" href="#dt-static-context">static
context</a> is <code>strip</code>, <a title="boundary whitespace"
href="#dt-boundary-whitespace">boundary whitespace</a> is
identified and deleted (see <a href="#id-whitespace"><b>3.9.1.4
Boundary Whitespace</b></a> for a definition of boundary
whitespace.)</p>
</li>
<li>
<p><a title="predefined entity reference" href=
"#dt-predefined-entity-reference">Predefined entity references</a>
and <a title="character reference" href=
"#dt-character-reference">character references</a> are expanded
into their referenced strings, as described in <a href=
"#id-literals"><b>3.1.1 Literals</b></a>. Characters inside a
<a href="#doc-xquery30-CDataSection">CDataSection</a>, including
special characters such as <code>&lt;</code> and
<code>&amp;</code>, are treated as literal characters rather than
as markup characters (except for the sequence <code>]]&gt;</code>,
which terminates the CDataSection).</p>
</li>
<li>
<p>Each consecutive sequence of literal characters evaluates to a
single text node containing the characters.</p>
</li>
<li>
<p>Each nested direct constructor is evaluated according to the
rules in <a href="#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a> or <a href="#id-otherConstructors"><b>3.9.2
Other Direct Constructors</b></a>, resulting in a new element,
comment, or processing instruction node. Then:</p>
<ol class="enumlr">
<li>
<p>The <code>parent</code> property of the resulting node is then
set to the newly constructed element node.</p>
</li>
<li>
<p>The <code>base-uri</code> property of the resulting node, and of
each of its descendants, is set to be the same as that of its new
parent, unless it (the child node) has an <code>xml:base</code>
attribute, in which case its <code>base-uri</code> property is set
to the value of that attribute, <a title="resolve" href=
"#dt-resolve-relative-uri">resolved (if it is relative)</a> against
the <code>base-uri</code> property of its new parent node.</p>
</li>
</ol>
</li>
<li>
<p>Enclosed expressions are evaluated as follows:</p>
<ol class="enumlr">
<li>
<p>If an enclosed expression returns a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>,
a type error is raised [<a href="#ERRXQTY0105" title=
"err:XQTY0105">err:XQTY0105</a>].</p>
</li>
<li>
<p>For each adjacent sequence of one or more atomic values returned
by an enclosed expression, a new text node is constructed,
containing the result of casting each atomic value to a string,
with a single space character inserted between adjacent values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The insertion of blank characters between adjacent values
applies even if one or both of the values is a zero-length
string.</p>
</div>
</li>
<li>
<p>For each node returned by an enclosed expression, a new copy is
made of the given node and all nodes that have the given node as an
ancestor, collectively referred to as <b>copied nodes</b>. The
properties of the copied nodes are as follows:</p>
<ol class="enumua">
<li>
<p>Each copied node receives a new node identity.</p>
</li>
<li>
<p>The <code>parent</code>, <code>children</code>, and
<code>attributes</code> properties of the copied nodes are set so
as to preserve their inter-node relationships. For the topmost node
(the node directly returned by the enclosed expression), the
<code>parent</code> property is set to the node constructed by this
constructor.</p>
</li>
<li>
<p>If <a title="construction mode" href=
"#dt-construction-mode">construction mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a> is
<code>strip</code>:</p>
<ol class="enumur">
<li>
<p>If the copied node is an element node, its <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> is
set to <code>xs:untyped</code>. Its <code>nilled</code>,
<code>is-id</code>, and <code>is-idrefs</code> properties are set
to <code>false</code>.</p>
</li>
<li>
<p>If the copied node is an attribute node, its
<code>type-name</code> property is set to
<code>xs:untypedAtomic</code>. Its <code>is-idrefs</code> property
is set to <code>false</code>. Its <code>is-id</code> property is
set to <code>true</code> if the qualified name of the attribute
node is <code>xml:id</code>; otherwise it is set to
<code>false</code>.</p>
</li>
<li>
<p>The <code>string-value</code> of each copied element and
attribute node remains unchanged, and its <code>typed-value</code>
becomes equal to its <code>string-value</code> as an instance of
<code>xs:untypedAtomic</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations that store only the <a title="typed value" href=
"#dt-typed-value">typed value</a> of a node are required at this
point to convert the typed value to a string form.</p>
</div>
</li>
</ol>
<p>On the other hand, if <a title="construction mode" href=
"#dt-construction-mode">construction mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a> is
<code>preserve</code>, the <code>type-name</code>,
<code>nilled</code>, <code>string-value</code>,
<code>typed-value</code>, <code>is-id</code>, and
<code>is-idrefs</code> properties of the copied nodes are
preserved.</p>
</li>
<li>
<p>The <code>in-scope-namespaces</code> property of a copied
element node is determined by the following rules. In applying
these rules, the default namespace or absence of a default
namespace is treated like any other namespace binding:</p>
<ol class="enumur">
<li>
<p>If <a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies
<code>preserve</code>, all in-scope-namespaces of the original
element are retained in the new copy. If <a title=
"copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies
<code>no-preserve</code>, the new copy retains only those in-scope
namespaces of the original element that are used in the names of
the element and its attributes.</p>
</li>
<li>
<p>If <a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies
<code>inherit</code>, the copied node inherits all the in-scope
namespaces of the constructed node, augmented and overridden by the
in-scope namespaces of the original element that were preserved by
the preceding rule. If <a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies
<code>no-inherit</code>, the copied node does not inherit any
in-scope namespaces from the constructed node.</p>
</li>
</ol>
</li>
<li>
<p>An enclosed expression in the content of an element constructor
may cause one or more existing nodes to be copied. Type error
[<a href="#ERRXQTY0086" title="err:XQTY0086">err:XQTY0086</a>] is
raised in the following cases:</p>
<ol class="enumur">
<li>
<p>An element node is copied, and the <a title="typed value" href=
"#dt-typed-value">typed value</a> of the element node or one of its
attributes is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, and <a title=
"construction mode" href="#dt-construction-mode">construction
mode</a> is <code>preserve</code>, and <a title=
"copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> is
<code>no-preserve</code>.</p>
</li>
<li>
<p>An attribute node is copied but its parent element node is not
copied, and the <a title="typed value" href="#dt-typed-value">typed
value</a> of the copied attribute node is <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, and <a title=
"construction mode" href="#dt-construction-mode">construction
mode</a> is <code>preserve</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The rationale for error [<a href="#ERRXQTY0086" title=
"err:XQTY0086">err:XQTY0086</a>] is as follows: It is not possible
to preserve the type of a QName without also preserving the
namespace binding that defines the prefix of the QName.</p>
</div>
</li>
<li>
<p>When an element or processing instruction node is copied, its
<code>base-uri</code> property is set to be the same as that of its
new parent, with the following exception: if a copied element node
has an <code>xml:base</code> attribute, its <code>base-uri</code>
property is set to the value of that attribute, <a title="resolve"
href="#dt-resolve-relative-uri">resolved (if it is relative)</a>
against the <code>base-uri</code> property of the new parent
node.</p>
</li>
<li>
<p>All other properties of the copied nodes are preserved.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>If the content sequence contains a document node, the document
node is replaced in the content sequence by its children.</p>
</li>
<li>
<p>Adjacent text nodes in the content sequence are merged into a
single text node by concatenating their contents, with no
intervening blanks. After concatenation, any text node whose
content is a zero-length string is deleted from the content
sequence.</p>
</li>
<li>
<p>If the content sequence contains an attribute node or a
namespace node following a node that is not an attribute node or a
namespace node, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXQTY0024" title=
"err:XQTY0024">err:XQTY0024</a>].</p>
</li>
<li>
<p>The properties of the newly constructed element node are
determined as follows:</p>
<ol class="enumla">
<li>
<p><code>node-name</code> is the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> resulting from resolving
the element name in the start tag, including its original namespace
prefix (if any), as described in <a href=
"#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>.</p>
</li>
<li>
<p><code>parent</code> is set to empty.</p>
</li>
<li>
<p><code>attributes</code> consist of all the attributes specified
in the start tag as described in <a href=
"#id-attributes"><b>3.9.1.1 Attributes</b></a>, together with all
the attribute nodes in the content sequence, in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> order.
Note that the <code>parent</code> property of each of these
attribute nodes has been set to the newly constructed element node.
If two or more attributes have the same <code>node-name</code>, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
is raised [<a href="#ERRXQDY0025" title=
"err:XQDY0025">err:XQDY0025</a>]. If an attribute named
<code>xml:space</code> has a value other than <code>preserve</code>
or <code>default</code>, a dynamic error may be raised [<a href=
"#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p>
</li>
<li>
<p><code>children</code> consist of all the element, text, comment,
and processing instruction nodes in the content sequence. Note that
the <code>parent</code> property of each of these nodes has been
set to the newly constructed element node.</p>
</li>
<li>
<p><code>base-uri</code> is set to the following value:</p>
<ol class="enumlr">
<li>
<p>If the constructed node has an attribute named
<code>xml:base</code>, then the value of this attribute, <a title=
"resolve" href="#dt-resolve-relative-uri">resolved (if it is
relative)</a> against the <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>, as described in <a href=
"#id-resolve-relative-uri"><b>2.4.6 Resolving a Relative URI
Reference</b></a>.</span></p>
</li>
<li>
<p>Otherwise, <span>the <a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>.</span></p>
</li>
</ol>
</li>
<li>
<p><code>in-scope-namespaces</code> consist of all the namespace
bindings resulting from namespace declaration attributes as
described in <a href="#id-namespaces"><b>3.9.1.2 Namespace
Declaration Attributes</b></a>, and possibly additional namespace
bindings as described in <a href=
"#id-ns-nodes-on-elements"><b>3.9.4 In-scope Namespaces of a
Constructed Element</b></a>.</p>
</li>
<li>
<p>The <code>nilled</code> property is <code>false</code>.</p>
</li>
<li>
<p>The <code>string-value</code> property is equal to the
concatenated contents of the text-node descendants in document
order. If there are no text-node descendants, the
<code>string-value</code> property is a zero-length string.</p>
</li>
<li>
<p>The <code>typed-value</code> property is equal to the
<code>string-value</code> property, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If <a title="construction mode" href=
"#dt-construction-mode">construction mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a> is
<code>strip</code>, the <code>type-name</code> property is
<code>xs:untyped</code>. On the other hand, if construction mode is
<code>preserve</code>, the <code>type-name</code> property is
<code>xs:anyType</code>.</p>
</li>
<li>
<p>The <code>is-id</code> and <code>is-idrefs</code> properties are
set to <code>false</code>.</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{1}&lt;/a&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>1</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{1, 2, 3}&lt;/a&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>1 2 3</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;c&gt;{1}{2}{3}&lt;/c&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>123</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;b&gt;{1, "2", "3"}&lt;/b&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>1 2 3</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>I saw 8 cats.</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;
</pre></div>
<p>The constructed element node has one child, a text node
containing the value "<code>I saw 8 cats.</code>".</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;
</pre></div>
<p>The constructed element node has three children: a text node
containing "<code>I saw</code> ", a child element node named
<code>howmany</code>, and a text node containing "
<code>cats.</code>". The child element node in turn has a single
text node child containing the value "<code>8</code>".</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-whitespace" id="id-whitespace"></a>3.9.1.4 Boundary
Whitespace</h5>
<p>In a direct element constructor, whitespace characters may
appear in the content of the constructed element. In some cases,
enclosed expressions and/or nested elements may be separated only
by whitespace characters. For example, in the expression below, the
end-tag <code>&lt;/title&gt;</code> and the start-tag
<code>&lt;author&gt;</code> are separated by a newline character
and four space characters:</p>
<div class="exampleInner">
<pre>
&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</pre></div>
<p>[<a name="dt-boundary-whitespace" id="dt-boundary-whitespace"
title="boundary whitespace">Definition</a>: <b>Boundary
whitespace</b> is a sequence of consecutive whitespace characters
within the content of a <a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructor</a>, that is
delimited at each end either by the start or end of the content, or
by a <a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a>, or by an
<a href="#doc-xquery30-EnclosedExpr">EnclosedExpr</a>. For this
purpose, characters generated by <a title="character reference"
href="#dt-character-reference">character references</a> such as
<code>&amp;#x20;</code> or by <a href=
"#doc-xquery30-CDataSection">CDataSections</a> are not considered
to be whitespace characters.]</p>
<p>The <a title="boundary-space policy" href=
"#dt-boundary-space-policy">boundary-space policy</a> in the
<a title="static context" href="#dt-static-context">static
context</a> controls whether boundary whitespace is preserved by
element constructors. If boundary-space policy is
<code>strip</code>, boundary whitespace is not considered
significant and is discarded. On the other hand, if boundary-space
policy is <code>preserve</code>, boundary whitespace is considered
significant and is preserved.</p>
<ul>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;cat&gt;
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt;
&lt;/cat&gt;
</pre></div>
<p>The constructed <code>cat</code> element node has two child
element nodes named <code>breed</code> and <code>color</code>.
Whitespace surrounding the child elements will be stripped away by
the element constructor if boundary-space policy is
<code>strip</code>.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;  {"abc"}  &lt;/a&gt;
</pre></div>
<p>If boundary-space policy is <code>strip</code>, this example is
equivalent to <code>&lt;a&gt;abc&lt;/a&gt;</code>. However, if
boundary-space policy is <code>preserve</code>, this example is
equivalent to
<code>&lt;a&gt;&#160;&#160;abc&#160;&#160;&lt;/a&gt;</code>.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt; z {"abc"}&lt;/a&gt;
</pre></div>
<p>Since the whitespace surrounding the <code>z</code> is not
boundary whitespace, it is always preserved. This example is
equivalent to <code>&lt;a&gt;&#160;z&#160;abc&lt;/a&gt;</code>.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;
</pre></div>
<p>This example is equivalent to
<code>&lt;a&gt;&#160;abc&lt;/a&gt;</code>, regardless of the
boundary-space policy, because the space generated by the <a title=
"character reference" href="#dt-character-reference">character
reference</a> is not treated as a whitespace character.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{"  "}&lt;/a&gt;
</pre></div>
<p>This example constructs an element containing two space
characters, regardless of the boundary-space policy, because
whitespace inside an enclosed expression is never considered to be
boundary whitespace.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Element constructors treat attributes named
<code>xml:space</code> as ordinary attributes. An
<code>xml:space</code> attribute does not affect the handling of
whitespace by an element constructor.</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-otherConstructors" id=
"id-otherConstructors"></a>3.9.2 Other Direct Constructors</h4>
<p>XQuery allows an expression to generate a processing instruction
node or a comment node. This can be accomplished by using a
<b>direct processing instruction constructor</b> or a <b>direct
comment constructor</b>. In each case, the syntax of the
constructor expression is based on the syntax of a similar
construct in XML.</p>
<h5><a name="d2e17754" id="d2e17754"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirPIConstructor" id=
"doc-xquery30-DirPIConstructor"></a>[147]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirPIConstructor">DirPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;?" <a href="#prod-xquery30-PITarget">PITarget</a>
(<a href="#prod-xquery30-S">S</a> <a href=
"#doc-xquery30-DirPIContents">DirPIContents</a>)?
"?&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirPIContents" id=
"doc-xquery30-DirPIContents"></a>[148]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirPIContents">DirPIContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirCommentConstructor" id=
"doc-xquery30-DirCommentConstructor"></a>[145]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirCommentConstructor">DirCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;!--" <a href=
"#doc-xquery30-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DirCommentContents" id=
"doc-xquery30-DirCommentContents"></a>[146]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirCommentContents">DirCommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href="#prod-xquery30-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery30-Char">Char</a> - '-')))*</code></td>
</tr>
</tbody>
</table>
<p>A direct processing instruction constructor creates a processing
instruction node whose <code>target</code> property is <a href=
"#prod-xquery30-PITarget">PITarget</a> and whose
<code>content</code> property is <a href=
"#doc-xquery30-DirPIContents">DirPIContents</a>. The
<code>base-uri</code> property of the node is empty. The
<code>parent</code> property of the node is empty.</p>
<p>The <a href="#prod-xquery30-PITarget">PITarget</a> of a
processing instruction must not consist of the characters "XML" in
any combination of upper and lower case. The <a href=
"#doc-xquery30-DirPIContents">DirPIContents</a> of a processing
instruction must not contain the string "<code>?&gt;</code>".</p>
<p>The following example illustrates a direct processing
instruction constructor:</p>
<div class="exampleInner">
<pre>
&lt;?format role="output" ?&gt;
</pre></div>
<p>A direct comment constructor creates a comment node whose
<code>content</code> property is <a href=
"#doc-xquery30-DirCommentContents">DirCommentContents</a>. Its
<code>parent</code> property is empty.</p>
<p>The <a href=
"#doc-xquery30-DirCommentContents">DirCommentContents</a> of a
comment must not contain two consecutive hyphens or end with a
hyphen. These rules are syntactically enforced by the grammar shown
above.</p>
<p>The following example illustrates a direct comment
constructor:</p>
<div class="exampleInner">
<pre>
&lt;!-- Tags are ignored in the following section --&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A direct comment constructor is different from a <a href=
"#doc-xquery30-Comment">comment</a>, since a direct comment
constructor actually constructs a comment node, whereas a <a href=
"#doc-xquery30-Comment">comment</a> is simply used in documenting a
query and is not evaluated.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-computedConstructors" id=
"id-computedConstructors"></a>3.9.3 Computed Constructors</h4>
<h5><a name="d2e17867" id="d2e17867"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ComputedConstructor" id=
"doc-xquery30-ComputedConstructor"></a>[151]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ComputedConstructor">ComputedConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#doc-xquery30-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#doc-xquery30-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#doc-xquery30-CompNamespaceConstructor">CompNamespaceConstructor</a><br />

| <a href=
"#doc-xquery30-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#doc-xquery30-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#doc-xquery30-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
</table>
<p>An alternative way to create nodes is by using a <b>computed
constructor</b>. A computed constructor begins with a keyword that
identifies the type of node to be created: <code>element</code>,
<code>attribute</code>, <code>document</code>, <code>text</code>,
<code>processing-instruction</code>, <code>comment</code>, or
<code>namespace</code>.</p>
<p>For those kinds of nodes that have names (element, attribute,
and processing instruction nodes), the keyword that specifies the
node kind is followed by the name of the node to be created. This
name may be specified either as an EQName or as an expression
enclosed in braces. [<a name="dt-name-expression" id=
"dt-name-expression" title="name expression">Definition</a>: When
an expression is used to specify the name of a constructed node,
that expression is called the <b>name expression</b> of the
constructor.]</p>
<p>[<a name="dt-content-expression" id="dt-content-expression"
title="content expression">Definition</a>: The final part of a
computed constructor is an expression enclosed in braces, called
the <b>content expression</b> of the constructor, that generates
the content of the node.]</p>
<p>The following example illustrates the use of computed element
and attribute constructors in a simple case where the names of the
constructed nodes are constants. This example generates exactly the
same result as the first example in <a href=
"#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>:</p>
<div class="exampleInner">
<pre>
element book {
   attribute isbn {"isbn-0060229357" },
   element title { "Harold and the Purple Crayon"},
   element author {
      element first { "Crockett" },
      element last {"Johnson" }
   }
}
</pre></div>
<div class="div4">
<h5><a name="id-computedElements" id=
"id-computedElements"></a>3.9.3.1 Computed Element
Constructors</h5>
<h5><a name="d2e17961" id="d2e17961"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompElemConstructor" id=
"doc-xquery30-CompElemConstructor"></a>[153]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompElemConstructor">CompElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (<a href="#doc-xquery30-EQName">EQName</a> |
("{" <a href="#doc-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery30-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e16478.doc-xquery30-EQName" id=
"noid_d3e16478.doc-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a> | <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ContentExpr" id=
"doc-xquery30-ContentExpr"></a>[154]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ContentExpr">ContentExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-computed-elem-const" id="dt-computed-elem-const"
title="computed element constructor">Definition</a>: A <b>computed
element constructor</b> creates an element node, allowing both the
name and the content of the node to be computed.]</p>
<p>If the keyword <code>element</code> is followed by an EQName, it
is expanded to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> as follows: if the EQName
has a <span>BracedURILiteral</span> it is expanded using the
specified URI; if the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> with a namespace prefix it is
expanded using the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>; if the
EQName is a <a title="lexical QName" href="#dt-qname">lexical
QName</a> without a prefix it is implicitly qualified by the
<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is used as the
<code>node-name</code> property of the constructed element node. If
expansion of the QName is not successful, a <a title="static error"
href="#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p>
<p>If the keyword <code>element</code> is followed by a <a title=
"name expression" href="#dt-name-expression">name expression</a>,
the name expression is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the <a title="name expression" href=
"#dt-name-expression">name expression</a>. If the result of
atomization is not a single atomic value of type
<code>xs:QName</code>, <code>xs:string</code>, or
<code>xs:untypedAtomic</code>, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized value of the <a title="name expression" href=
"#dt-name-expression">name expression</a> is of type
<code>xs:QName</code>, that <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is used as the
<code>node-name</code> property of the constructed element,
retaining the prefix part of the QName.</p>
</li>
<li>
<p>If the atomized value of the <a title="name expression" href=
"#dt-name-expression">name expression</a> is of type
<code>xs:string</code> or <code>xs:untypedAtomic</code>, that value
is converted to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a>. If the string value
contains a namespace prefix, that prefix is <a title="resolve"
href="#dt-resolve-relative-uri">resolved to a namespace URI</a>
using the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If the
string value contains no namespace prefix, it is treated as a local
name in the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is used as the
<code>node-name</code> property of the constructed element,
retaining the prefix part of the QName. If conversion of the
atomized <a title="name expression" href="#dt-name-expression">name
expression</a> to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is not successful, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
is raised [<a href="#ERRXQDY0074" title=
"err:XQDY0074">err:XQDY0074</a>].</p>
</li>
</ol>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXQDY0096" title=
"err:XQDY0096">err:XQDY0096</a>] if the node-name of the
constructed element node has any of the following properties:</p>
<ul>
<li>
<p>Its namespace prefix is <code>xmlns</code>.</p>
</li>
<li>
<p>Its namespace URI is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Its namespace prefix is <code>xml</code> and its namespace URI
is not <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Its namespace prefix is other than <code>xml</code> and its
namespace URI is
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
</ul>
<p>The <a title="content expression" href=
"#dt-content-expression">content expression</a> of a computed
element constructor (if present) is processed in exactly the same
way as an enclosed expression in the content of a <a title=
"direct element constructor" href="#dt-direct-elem-const">direct
element constructor</a>, as described in Step 1e of <a href=
"#id-content"><b>3.9.1.3 Content</b></a>. The result of processing
the content expression is a sequence of nodes called the <b>content
sequence</b>. If the <a title="content expression" href=
"#dt-content-expression">content expression</a> is absent, the
content sequence is an empty sequence.</p>
<p>Processing of the computed element constructor proceeds as
follows:</p>
<ol class="enumar">
<li>
<p>If the content sequence contains a document node, the document
node is replaced in the content sequence by its children.</p>
</li>
<li>
<p>Adjacent text nodes in the content sequence are merged into a
single text node by concatenating their contents, with no
intervening blanks. After concatenation, any text node whose
content is a zero-length string is deleted from the content
sequence.</p>
</li>
<li>
<p>If the content sequence contains an attribute node or a
namespace node following a node that is not an attribute node or a
namespace node, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXQTY0024" title=
"err:XQTY0024">err:XQTY0024</a>].</p>
</li>
<li>
<p>The properties of the newly constructed element node are
determined as follows:</p>
<ol class="enumla">
<li>
<p><code>node-name</code> is the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> resulting from processing
the specified <a title="lexical QName" href="#dt-qname">lexical
QName</a> or <a title="name expression" href=
"#dt-name-expression">name expression</a>, as described above.</p>
</li>
<li>
<p><code>parent</code> is empty.</p>
</li>
<li>
<p><code>attributes</code> consist of all the attribute nodes in
the content sequence, in <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> order.
Note that the <code>parent</code> property of each of these
attribute nodes has been set to the newly constructed element node.
If two or more attributes have the same <code>node-name</code>, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
is raised [<a href="#ERRXQDY0025" title=
"err:XQDY0025">err:XQDY0025</a>]. If an attribute named
<code>xml:space</code> has a value other than <code>preserve</code>
or <code>default</code>, a dynamic error may be raised [<a href=
"#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p>
</li>
<li>
<p><code>children</code> consist of all the element, text, comment,
and processing instruction nodes in the content sequence. Note that
the <code>parent</code> property of each of these nodes has been
set to the newly constructed element node.</p>
</li>
<li>
<p><code>base-uri</code> is set to the following value:</p>
<ol class="enumlr">
<li>
<p>If the constructed node has an attribute named
<code>xml:base</code>, then the value of this attribute, <a title=
"resolve" href="#dt-resolve-relative-uri">resolved (if it is
relative)</a> against the <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>, as described in <a href=
"#id-resolve-relative-uri"><b>2.4.6 Resolving a Relative URI
Reference</b></a></span> .</p>
</li>
<li>
<p>Otherwise, <span>the <a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>.</span></p>
</li>
</ol>
</li>
<li>
<p><code>in-scope-namespaces</code> are computed as described in
<a href="#id-ns-nodes-on-elements"><b>3.9.4 In-scope Namespaces of
a Constructed Element</b></a>.</p>
</li>
<li>
<p>The <code>nilled</code> property is <code>false</code>.</p>
</li>
<li>
<p>The <code>string-value</code> property is equal to the
concatenated contents of the text-node descendants in document
order.</p>
</li>
<li>
<p>The <code>typed-value</code> property is equal to the
<code>string-value</code> property, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If <a title="construction mode" href=
"#dt-construction-mode">construction mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a> is
<code>strip</code>, the <code>type-name</code> property is
<code>xs:untyped</code>. On the other hand, if construction mode is
<code>preserve</code>, the <code>type-name</code> property is
<code>xs:anyType</code>.</p>
</li>
<li>
<p>The <code>is-id</code> and <code>is-idrefs</code> properties are
set to <code>false</code>.</p>
</li>
</ol>
</li>
</ol>
<p>A computed element constructor might be used to make a modified
copy of an existing element. For example, if the variable
<code>$e</code> is bound to an element with <a title="numeric"
href="#dt-numeric">numeric</a> content, the following constructor
might be used to create a new element with the same name and
attributes as <code>$e</code> and with numeric content equal to
twice the value of <code>$e</code>:</p>
<div class="exampleInner">
<pre>
element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}
</pre></div>
<p>In this example, if <code>$e</code> is bound by the expression
<code>let $e := &lt;length
units="inches"&gt;{5}&lt;/length&gt;</code>, then the result of the
example expression is the element <code>&lt;length
units="inches"&gt;10&lt;/length&gt;</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of the expression <code>fn:node-name($e)</code> is
<code>xs:QName?</code>, denoting zero or one QName. Therefore, if
the <a title="static typing feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is in effect,
the above example raises a static type error, since the name
expression in a computed element constructor is required to return
exactly one string or QName. In order to avoid the static type
error, the name expression <code>fn:node-name($e)</code> could be
rewritten as <code>fn:exactly-one(fn:node-name($e))</code>. If the
<a title="static typing feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is not in
effect, the example can be successfully evaluated as written,
provided that <code>$e</code> is bound to exactly one element node
with numeric content.</p>
</div>
<p>One important purpose of computed constructors is to allow the
name of a node to be computed. We will illustrate this feature by
an expression that translates the name of an element from one
language to another. Suppose that the variable <code>$dict</code>
is bound to a <code>dictionary</code> element containing a sequence
of <code>entry</code> elements, each of which encodes translations
for a specific word. Here is an example entry that encodes the
German and Italian variants of the word "address":</p>
<div class="exampleInner">
<pre>
&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt;
</pre></div>
<p>Suppose further that the variable <code>$e</code> is bound to
the following element:</p>
<div class="exampleInner">
<pre>
&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;
</pre></div>
<p>Then the following expression generates a new element in which
the name of <code>$e</code> has been translated into Italian and
the content of <code>$e</code> (including its attributes, if any)
has been preserved. The first enclosed expression after the
<code>element</code> keyword generates the name of the element, and
the second enclosed expression generates the content and
attributes:</p>
<div class="exampleInner">
<pre>
  element
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}
</pre></div>
<p>The result of this expression is as follows:</p>
<div class="exampleInner">
<pre>
&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As in the previous example, if the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a> is in effect, the enclosed expression that
computes the element name in the above computed element constructor
must be wrapped in a call to the <code>fn:exactly-one</code>
function in order to avoid a static type error.</p>
</div>
<p>Additional examples of computed element constructors can be
found in <a href="#id-recursive-transformations"><b>I.3 Recursive
Transformations</b></a>.</p>
</div>
<div class="div4">
<h5><a name="id-computedAttributes" id=
"id-computedAttributes"></a>3.9.3.2 Computed Attribute
Constructors</h5>
<h5><a name="d2e18515" id="d2e18515"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompAttrConstructor" id=
"doc-xquery30-CompAttrConstructor"></a>[155]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompAttrConstructor">CompAttrConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (<a href="#doc-xquery30-EQName">EQName</a> |
("{" <a href="#doc-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e17002.doc-xquery30-EQName" id=
"noid_d3e17002.doc-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a> | <a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<p>A computed attribute constructor creates a new attribute node,
with its own node identity.</p>
<p>Attributes have no default namespace. The rules that expand
attribute names create an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> prefix
if an attribute name has a namespace URI but no prefix is
provided.</p>
<p>If the keyword <code>attribute</code> is followed by an EQName,
it is expanded to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> as follows:</p>
<ul>
<li>
<p>If the EQName has a <span>BracedURILiteral</span> it is expanded
using the specified URI to create an <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a>; the name of the
attribute is constructed using the namespace URI and local name of
the expanded QName and an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
prefix.</p>
</li>
<li>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> with a namespace prefix it is
expanded using the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
</li>
<li>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> without a prefix, the expanded QName
is in no namespace.</p>
</li>
</ul>
<p>The resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (including its prefix) is
used as the <code>node-name</code> property of the constructed
attribute node. If expansion of the QName is not successful, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>].</p>
<p>If the keyword <code>attribute</code> is followed by a <a title=
"name expression" href="#dt-name-expression">name expression</a>,
the name expression is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the result of the <a title="name expression" href=
"#dt-name-expression">name expression</a>. If the result of
<a title="atomization" href="#dt-atomization">atomization</a> is
not a single atomic value of type <code>xs:QName</code>,
<code>xs:string</code>, or <code>xs:untypedAtomic</code>, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized value of the <a title="name expression" href=
"#dt-name-expression">name expression</a> is of type
<code>xs:QName</code>:</p>
<ol class="enumla">
<li>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> returned by the atomized
name expression has a namespace URI but has no prefix, it is given
an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
prefix.</p>
</li>
<li>
<p>The resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (including its prefix) is
used as the <code>node-name</code> property of the constructed
attribute node.</p>
</li>
</ol>
</li>
<li>
<p>If the atomized value of the <a title="name expression" href=
"#dt-name-expression">name expression</a> is of type
<code>xs:string</code> or <code>xs:untypedAtomic</code>, that value
is converted to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a>. If the string value
contains a namespace prefix, that prefix is resolved to a namespace
URI using the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If the
string value contains no namespace prefix, it is treated as a local
name in no namespace. The resulting <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (including its prefix) is
used as the <code>node-name</code> property of the constructed
attribute. If conversion of the atomized <a title="name expression"
href="#dt-name-expression">name expression</a> to an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> is
not successful, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p>
</li>
</ol>
<p>A <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXQDY0044" title=
"err:XQDY0044">err:XQDY0044</a>] if the node-name of the
constructed attribute node has any of the following properties:</p>
<ul>
<li>
<p>Its namespace prefix is <code>xmlns</code>.</p>
</li>
<li>
<p>It has no namespace prefix and its local name is
<code>xmlns</code>.</p>
</li>
<li>
<p>Its namespace URI is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Its namespace prefix is <code>xml</code> and its namespace URI
is not <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Its namespace prefix is other than <code>xml</code> and its
namespace URI is
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
</ul>
<p>The <a title="content expression" href=
"#dt-content-expression">content expression</a> of a computed
attribute constructor is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the result of the <a title="content expression" href=
"#dt-content-expression">content expression</a>, converting it to a
sequence of atomic values. (If the <a title="content expression"
href="#dt-content-expression">content expression</a> is absent, the
result of this step is an empty sequence.)</p>
</li>
<li>
<p>If the result of atomization is an empty sequence, the value of
the attribute is the zero-length string. Otherwise, each atomic
value in the atomized sequence is cast into a string.</p>
</li>
<li>
<p>The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair. The resulting string becomes the
<code>string-value</code> property of the new attribute node. The
<a title="type annotation" href="#dt-type-annotation">type
annotation</a> (<code>type-name</code> property) of the new
attribute node is <code>xs:untypedAtomic</code>. The
<code>typed-value</code> property of the attribute node is the same
as its <code>string-value</code>, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>The <code>parent</code> property of the attribute node is set to
empty.</p>
</li>
<li>
<p>If the attribute name is <code>xml:id</code>, then
<code>xml:id</code> processing is performed as defined in <a href=
"#XMLID">[XML ID]</a>. This ensures that the attribute node has the
type <code>xs:ID</code> and that its value is properly normalized.
If an error is encountered during <code>xml:id</code> processing,
an implementation may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091"
title="err:XQDY0091">err:XQDY0091</a>].</p>
</li>
<li>
<p>If the attribute name is <code>xml:id</code>, the
<code>is-id</code> property of the resulting attribute node is set
to <code>true</code>; otherwise the <code>is-id</code> property is
set to <code>false</code>. The <code>is-idrefs</code> property of
the attribute node is unconditionally set to
<code>false</code>.</p>
</li>
<li>
<p>If the attribute name is <code>xml:space</code> and the
attribute value is other than <code>preserve</code> or
<code>default</code>, a dynamic error may be raised [<a href=
"#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p>
</li>
</ol>
<ul>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
attribute size {4 + 3}
</pre></div>
<p>The <a title="string value" href="#dt-string-value">string
value</a> of the <code>size</code> attribute is "<code>7</code>"
and its type is <code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
attribute
   { if ($sex = "M") then "husband" else "wife" }
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }
</pre></div>
<p>The name of the constructed attribute is either
<code>husband</code> or <code>wife</code>. Its <a title=
"string value" href="#dt-string-value">string value</a> is
"<code>Hello 1 2 3 Goodbye</code>".</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-documentConstructors" id=
"id-documentConstructors"></a>3.9.3.3 Document Node
Constructors</h5>
<h5><a name="d2e18907" id="d2e18907"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompDocConstructor" id=
"doc-xquery30-CompDocConstructor"></a>[152]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompDocConstructor">CompDocConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#doc-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>All document node constructors are computed constructors. The
result of a document node constructor is a new document node, with
its own node identity.</p>
<p>A document node constructor is useful when the result of a query
is to be a document in its own right. The following example
illustrates a query that returns an XML document containing a root
element named <code>author-list</code>:</p>
<div class="exampleInner">
<pre>
document
  {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
  }
</pre></div>
<p>The <a title="content expression" href=
"#dt-content-expression">content expression</a> of a document node
constructor is processed in exactly the same way as an enclosed
expression in the content of a <a title=
"direct element constructor" href="#dt-direct-elem-const">direct
element constructor</a>, as described in Step 1e of <a href=
"#id-content"><b>3.9.1.3 Content</b></a>. The result of processing
the content expression is a sequence of nodes called the <b>content
sequence</b>. Processing of the document node constructor then
proceeds as follows:</p>
<ol class="enumar">
<li>
<p>If the content sequence contains a document node, the document
node is replaced in the content sequence by its children.</p>
</li>
<li>
<p>Adjacent text nodes in the content sequence are merged into a
single text node by concatenating their contents, with no
intervening blanks. After concatenation, any text node whose
content is a zero-length string is deleted from the content
sequence.</p>
</li>
<li>
<p>If the content sequence contains an attribute node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the content sequence contains a namespace node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>The properties of the newly constructed document node are
determined as follows:</p>
<ol class="enumla">
<li>
<p><code>base-uri</code> is <span>set to the <a title=
"Static Base URI" href="#dt-static-base-uri">Static Base
URI</a>.</span></p>
</li>
<li>
<p><code>children</code> consist of all the element, text, comment,
and processing instruction nodes in the content sequence. Note that
the <code>parent</code> property of each of these nodes has been
set to the newly constructed document node.</p>
</li>
<li>
<p>The <code>unparsed-entities</code> and <code>document-uri</code>
properties are empty.</p>
</li>
<li>
<p>The <code>string-value</code> property is equal to the
concatenated contents of the text-node descendants in document
order.</p>
</li>
<li>
<p>The <code>typed-value</code> property is equal to the
<code>string-value</code> property, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
</ol>
</li>
</ol>
<p>No validation is performed on the constructed document node. The
<a href="#XML">[XML 1.0]</a> rules that govern the structure of an
XML document (for example, the document node must have exactly one
child that is an element node) are not enforced by the XQuery
document node constructor.</p>
</div>
<div class="div4">
<h5><a name="id-textConstructors" id=
"id-textConstructors"></a>3.9.3.4 Text Node Constructors</h5>
<h5><a name="d2e19033" id="d2e19033"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompTextConstructor" id=
"doc-xquery30-CompTextConstructor"></a>[160]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompTextConstructor">CompTextConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#doc-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>All text node constructors are computed constructors. The result
of a text node constructor is a new text node, with its own node
identity.</p>
<p>The <a title="content expression" href=
"#dt-content-expression">content expression</a> of a text node
constructor is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the <a title="content expression" href=
"#dt-content-expression">content expression</a>, converting it to a
sequence of atomic values.</p>
</li>
<li>
<p>If the result of atomization is an empty sequence, no text node
is constructed. Otherwise, each atomic value in the atomized
sequence is cast into a string.</p>
</li>
<li>
<p>The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair. The resulting string becomes the
<code>content</code> property of the constructed text node.</p>
</li>
</ol>
<p>The <code>parent</code> property of the constructed text node is
set to empty.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is possible for a text node constructor to construct a text
node containing a zero-length string. However, if used in the
content of a constructed element or document node, such a text node
will be deleted or merged with another text node.</p>
</div>
<p>The following example illustrates a text node constructor:</p>
<div class="exampleInner">
<pre>
text {"Hello"}
</pre></div>
</div>
<div class="div4">
<h5><a name="id-computed-pis" id="id-computed-pis"></a>3.9.3.5
Computed Processing Instruction Constructors</h5>
<h5><a name="d2e19085" id="d2e19085"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompPIConstructor" id=
"doc-xquery30-CompPIConstructor"></a>[162]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompPIConstructor">CompPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery30-NCName">NCName</a> | ("{" <a href=
"#doc-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p>A computed processing instruction constructor (<a href=
"#doc-xquery30-CompPIConstructor">CompPIConstructor</a>) constructs
a new processing instruction node with its own node identity.</p>
<p>If the keyword <code>processing-instruction</code> is followed
by an NCName, that NCName is used as the <code>target</code>
property of the constructed node. If the keyword
<code>processing-instruction</code> is followed by a <a title=
"name expression" href="#dt-name-expression">name expression</a>,
the name expression is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the <a title="name expression" href=
"#dt-name-expression">name expression</a>. If the result of
<a title="atomization" href="#dt-atomization">atomization</a> is
not a single atomic value of type <code>xs:NCName</code>,
<code>xs:string</code>, or <code>xs:untypedAtomic</code>, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized value of the <a title="name expression" href=
"#dt-name-expression">name expression</a> is of type
<code>xs:string</code> or <code>xs:untypedAtomic</code>, that value
is cast to the type <code>xs:NCName</code>. If the value cannot be
cast to <code>xs:NCName</code>, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXQDY0041" title="err:XQDY0041">err:XQDY0041</a>].</p>
</li>
<li>
<p>The resulting NCName is then used as the <code>target</code>
property of the newly constructed processing instruction node.
However, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised if the NCName is
equal to "<code>XML</code>" (in any combination of upper and lower
case) [<a href="#ERRXQDY0064" title=
"err:XQDY0064">err:XQDY0064</a>].</p>
</li>
</ol>
<p>The <a title="content expression" href=
"#dt-content-expression">content expression</a> of a computed
processing instruction constructor is processed as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the <a title="content expression" href=
"#dt-content-expression">content expression</a>, converting it to a
sequence of atomic values. (If the <a title="content expression"
href="#dt-content-expression">content expression</a> is absent, the
result of this step is an empty sequence.)</p>
</li>
<li>
<p>If the result of atomization is an empty sequence, it is
replaced by a zero-length string. Otherwise, each atomic value in
the atomized sequence is cast into a string. If any of the
resulting strings contains the string "<code>?&gt;</code>", a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
[<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is
raised.</p>
</li>
<li>
<p>The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair. Leading whitespace is removed
from the resulting string. The resulting string then becomes the
<code>content</code> property of the constructed processing
instruction node.</p>
</li>
</ol>
<p>The remaining properties of the new processing instruction node
are determined as follows:</p>
<ol class="enumar">
<li>
<p>The <code>parent</code> property is empty.</p>
</li>
<li>
<p>The <code>base-uri</code> property is empty.</p>
</li>
</ol>
<p>The following example illustrates a computed processing
instruction constructor:</p>
<div class="exampleInner">
<pre>
let $target := "audio-output",
    $content := "beep"
return processing-instruction {$target} {$content}
</pre></div>
<p>The processing instruction node constructed by this example
might be serialized as follows:</p>
<div class="exampleInner">
<pre>
&lt;?audio-output beep?&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="id-computed-comments" id=
"id-computed-comments"></a>3.9.3.6 Computed Comment
Constructors</h5>
<h5><a name="d2e19248" id="d2e19248"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompCommentConstructor" id=
"doc-xquery30-CompCommentConstructor"></a>[161]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompCommentConstructor">CompCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#doc-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>A computed comment constructor (<a href=
"#doc-xquery30-CompCommentConstructor">CompCommentConstructor</a>)
constructs a new comment node with its own node identity. The
<a title="content expression" href="#dt-content-expression">content
expression</a> of a computed comment constructor is processed as
follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the value of the <a title="content expression" href=
"#dt-content-expression">content expression</a>, converting it to a
sequence of atomic values.</p>
</li>
<li>
<p>If the result of atomization is an empty sequence, it is
replaced by a zero-length string. Otherwise, each atomic value in
the atomized sequence is cast into a string.</p>
</li>
<li>
<p>The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair. The resulting string becomes the
<code>content</code> property of the constructed comment node.</p>
</li>
<li>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0072"
title="err:XQDY0072">err:XQDY0072</a>] if the result of the
<a title="content expression" href="#dt-content-expression">content
expression</a> of a computed comment constructor contains two
adjacent hyphens or ends with a hyphen.</p>
</li>
</ol>
<p>The <code>parent</code> property of the constructed comment node
is set to empty.</p>
<p>The following example illustrates a computed comment
constructor:</p>
<div class="exampleInner">
<pre>
let $homebase := "Houston"
return comment {fn:concat($homebase, ", we have a problem.")}
</pre></div>
<p>The comment node constructed by this example might be serialized
as follows:</p>
<div class="exampleInner">
<pre>
&lt;!--Houston, we have a problem.--&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="id-computed-namespaces" id=
"id-computed-namespaces"></a>3.9.3.7 Computed Namespace
Constructors</h5>
<h5><a name="d2e19312" id="d2e19312"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CompNamespaceConstructor" id=
"doc-xquery30-CompNamespaceConstructor"></a>[156]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" (<a href="#prod-xquery30-Prefix">Prefix</a> |
("{" <a href="#doc-xquery30-PrefixExpr">PrefixExpr</a> "}")) "{"
<a href="#doc-xquery30-URIExpr">URIExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PrefixExpr" id=
"doc-xquery30-PrefixExpr"></a>[158]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PrefixExpr">PrefixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-URIExpr" id=
"doc-xquery30-URIExpr"></a>[159]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-URIExpr">URIExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>A computed namespace constructor creates a new namespace node,
with its own node identity. The parent of the newly created
namespace node is empty.</p>
<p>If the constructor specifies a <code>Prefix</code>, it is used
as the prefix for the namespace node.</p>
<p>If the constructor specifies a <code>PrefixExpr</code>, the
prefix expression is evaluated as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the result of the <code>PrefixExpr</code>.</p>
</li>
<li>
<p>If the result of <a title="atomization" href=
"#dt-atomization">atomization</a> is an empty sequence or a single
atomic value of type <code>xs:string</code> or
<code>xs:untypedAtomic</code>, then the following rules are applied
in order:</p>
<ol class="enumla">
<li>
<p>If the result is castable to <code>xs:NCName</code>, then it is
used as the local name of the newly constructed namespace node.
(The local name of a namespace node represents the prefix part of
the namespace binding.)</p>
</li>
<li>
<p>If the result is the empty sequence or a zero-length
<code>xs:string</code> or <code>xs:untypedAtomic</code> value, the
new namespace node has no name (such a namespace node represents a
binding for the default namespace).</p>
</li>
<li>
<p>Otherwise, a dynamic error is raised [<a href="#ERRXQDY0074"
title="err:XQDY0074">err:XQDY0074</a>].</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is not an empty sequence or a
single atomic value of type <code>xs:string</code> or
<code>xs:untypedAtomic</code>, a type error is raised [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
<p>The <code>URIExpr</code> is evaluated, and the result is cast to
<code>xs:anyURI</code> to create the <code>URI</code> property for
the newly created node. <span>An implementation may raise a dynamic
error [<a href="#ERRXQDY0074" title=
"err:XQDY0074">err:XQDY0074</a>] if the <code>URIExpr</code> of a
computed namespace constructor is not a valid instance of
<code>xs:anyURI</code>.</span></p>
<p>An error [<a href="#ERRXQDY0101" title=
"err:XQDY0101">err:XQDY0101</a>] is raised if a computed namespace
constructor attempts to do any of the following:</p>
<ul>
<li>
<p>Bind the prefix <code>xml</code> to some namespace URI other
than <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind a prefix other than <code>xml</code> to the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind the prefix <code>xmlns</code> to any namespace URI.</p>
</li>
<li>
<p>Bind a prefix to the namespace URI
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Bind any prefix (including the empty prefix) to a zero-length
namespace URI.</p>
</li>
</ul>
<p>By itself, a computed namespace constructor has no effect on
in-scope namespaces, but if an element constructor's content
sequence contains a namespace node, the namespace binding it
represents is added to the element's <a title="in-scope namespaces"
href="#dt-in-scope-namespaces">in-scope namespaces</a>.</p>
<p>A computed namespace constructor has no effect on the statically
known namespaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The newly created namespace node has all properties defined for
a namespace node in the data model. Like all nodes, it has
identity. Like all nodes which do not share a common parent, the
relative order of these nodes is implementation dependent. As
defined in the data model, the name of the node is the prefix, and
the string value of the node is the URI.</p>
</div>
<p>Examples:</p>
<ul>
<li>
<p>A computed namespace constructor with a prefix:</p>
<div class="exampleInner">
<pre>
namespace a {"http://a.example.com" }
</pre></div>
</li>
<li>
<p>A computed namespace constructor with a prefix expression:</p>
<div class="exampleInner">
<pre>
namespace {"a"} {"http://a.example.com" }
</pre></div>
</li>
<li>
<p>A computed namespace constructor with an empty prefix:</p>
<div class="exampleInner">
<pre>
namespace { "" } {"http://a.example.com" }
</pre></div>
</li>
</ul>
<p>Computed namespace constructors are generally used to add to the
in-scope namespaces of elements created with element
constructors:</p>
<div class="exampleInner">
<pre>
&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; {
  namespace xs {"http://www.w3.org/2001/XMLSchema"},
  attribute xsi:type {"xs:integer"},
  23
}&lt;/age&gt;
</pre></div>
<p>In the above example, note that the <code>xsi</code> namespace
binding is created for the element because it is used in an
attribute name. The attribute's content is simply character data,
and has no effect on namespace bindings. The computed namespace
constructor ensures that the <code>xs</code> binding is
created.</p>
<p>Computed namespace constructors have no effect on the statically
known namespaces. If the prefix a is not already defined in the
statically known namespaces, the following expression results in a
static error [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>].</p>
<div class="exampleInner">
<pre>
&lt;a:form&gt;
 {
  namespace a { "http://a.example.com" }
 }
&lt;/a:form&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-ns-nodes-on-elements" id=
"id-ns-nodes-on-elements"></a>3.9.4 In-scope Namespaces of a
Constructed Element</h4>
<p>An element node constructed by a direct or computed element
constructor has an <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> property that
consists of a set of <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">namespace bindings</a>. The in-scope
namespaces of an element node may affect the way the node is
serialized (see <a href="#id-serialization"><b>2.2.4
Serialization</b></a>), and may also affect the behavior of certain
functions that operate on nodes, such as <code>fn:name</code>. Note
the difference between <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a>, which is a
dynamic property of an element node, and <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, which is a
static property of an expression. Also note that one of the
namespace bindings in the in-scope namespaces may have no prefix
(denoting the default namespace for the given element). The
in-scope namespaces of a constructed element node consist of the
following namespace bindings:</p>
<ul>
<li>
<p>A namespace binding is created for each namespace declared in
the current element constructor by a <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a>.</p>
</li>
<li>
<p>A namespace binding is created for each namespace node in the
content sequence of the current element constructor.</p>
</li>
<li>
<p>A namespace binding is created for each namespace that is
declared in a <a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a> of an
enclosing <a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructor</a> and not
overridden by the current element constructor or an intermediate
constructor.</p>
</li>
<li>
<p>A namespace binding is always created to bind the prefix
<code>xml</code> to the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>For each prefix used in the name of the constructed element or
in the names of its attributes, a namespace binding must exist. If
a namespace binding does not already exist for one of these
prefixes, a new namespace binding is created for it. If this would
result in a conflict, because it would require two different
bindings of the same prefix, then the prefix used in the node name
is changed to an arbitrary <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
prefix that does not cause such a conflict, and a namespace binding
is created for this new prefix. If there is an in-scope default
namespace, then a binding is created between the empty prefix and
that URI.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">Copy-namespaces mode</a> does not affect
the namespace bindings of a newly constructed element node. It
applies only to existing nodes that are copied by a constructor
expression.</p>
</div>
<p>In an element constructor, if two or more namespace bindings in
the in-scope bindings would have the same prefix, then an error is
raised if they have different URIs [<a href="#ERRXQDY0102" title=
"err:XQDY0102">err:XQDY0102</a>]; if they would have the same
prefix and URI, duplicate bindings are ignored. <span>If the name
of an element in an element constructor is in no namespace,
creating a default namespace for that element using a computed
namespace constructor is an error [<a href="#ERRXQDY0102" title=
"err:XQDY0102">err:XQDY0102</a>]. For instance, the following
computed constructor raises an error because the element's name is
not in a namespace, but a default namespace is defined.</span></p>
<div class="exampleInner">
<pre>
element e { namespace {''} {'u'} }
</pre></div>
<p>The following query <span>illustrates the in-scope namespaces of
a constructed element:</span></p>
<div class="exampleInner">
<pre>
declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</pre></div>
<p>The <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of the resulting
<code>p:a</code> element consists of the following namespace
bindings:</p>
<ul>
<li>
<p><code>p = "http://example.com/ns/p"</code></p>
</li>
<li>
<p><code>q = "http://example.com/ns/q"</code></p>
</li>
<li>
<p><code>r = "http://example.com/ns/r"</code></p>
</li>
<li>
<p><code>xml = "http://www.w3.org/XML/1998/namespace"</code></p>
</li>
</ul>
<p>The namespace bindings for <code>p</code> and <code>q</code> are
added to the result element because their respective namespaces are
used in the names of the element and its attributes. The namespace
binding <code>r="http://example.com/ns/r"</code> is added to the
in-scope namespaces of the constructed element because it is
defined by a <a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a>, even
though it is not used in a name.</p>
<p>No namespace binding corresponding to
<code>f="http://example.com/ns/f"</code> is created, because the
namespace prefix <code>f</code> appears only in the query prolog
and is not used in an element or attribute name of the constructed
node. This namespace binding does not appear in the query result,
even though it is present in the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> and is
available for use during processing of the query.</p>
<p>Note that the following constructed element, if nested within a
<code>validate</code> expression, cannot be validated:</p>
<div class="exampleInner">
<pre>
&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;
</pre></div>
<p>The constructed element will have namespace bindings for the
prefixes <code>xsi</code> (because it is used in a name) and
<code>xml</code> (because it is defined for every constructed
element node). During validation of the constructed element, the
validator will be unable to interpret the namespace prefix
<code>xs</code> because it is has no namespace binding. Validation
of this constructed element could be made possible by providing a
<a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a>, as
in the following example:</p>
<div class="exampleInner">
<pre>
&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-flwor-expressions" id=
"id-flwor-expressions"></a>3.10 FLWOR Expressions</h3>
<p>XQuery provides a versatile expression called a FLWOR expression
that may contain multiple clauses. The FLWOR expression can be used
for many purposes, including iterating over sequences, joining
multiple documents, and performing grouping and aggregation. The
name FLWOR, pronounced "flower", is suggested by the keywords
<code>for</code>, <code>let</code>, <code>where</code>, <code>order
by</code>, and <code>return</code>, which introduce some of the
clauses used in FLWOR expressions (but this is not a complete list
of such clauses.)</p>
<p>The complete syntax of a FLWOR expression is shown here, and
relevant parts of the syntax are repeated in subsequent sections of
this document.</p>
<h5><a name="d2e19739" id="d2e19739"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FLWORExpr" id=
"doc-xquery30-FLWORExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FLWORExpr">FLWORExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-InitialClause">InitialClause</a>
<a href="#doc-xquery30-IntermediateClause">IntermediateClause</a>*
<a href="#doc-xquery30-ReturnClause">ReturnClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-InitialClause" id=
"doc-xquery30-InitialClause"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InitialClause">InitialClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ForClause">ForClause</a> |
<a href="#doc-xquery30-LetClause">LetClause</a> | <a href=
"#doc-xquery30-WindowClause">WindowClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-IntermediateClause" id=
"doc-xquery30-IntermediateClause"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntermediateClause">IntermediateClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-InitialClause">InitialClause</a> |
<a href="#doc-xquery30-WhereClause">WhereClause</a> | <a href=
"#doc-xquery30-GroupByClause">GroupByClause</a> | <a href=
"#doc-xquery30-OrderByClause">OrderByClause</a> | <a href=
"#doc-xquery30-CountClause">CountClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ForClause" id=
"doc-xquery30-ForClause"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href="#prod-xquery30-ForBinding">ForBinding</a>
("," <a href=
"#prod-xquery30-ForBinding">ForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18145.doc-xquery30-ForBinding" id=
"noid_d3e18145.doc-xquery30-ForBinding"></a>[45]&#160;&#160;&#160;</td>
<td><code>ForBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? <a href=
"#doc-xquery30-AllowingEmpty">AllowingEmpty</a>? <a href=
"#doc-xquery30-PositionalVar">PositionalVar</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-LetClause" id=
"doc-xquery30-LetClause"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href="#prod-xquery30-LetBinding">LetBinding</a>
("," <a href=
"#prod-xquery30-LetBinding">LetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18147.doc-xquery30-LetBinding" id=
"noid_d3e18147.doc-xquery30-LetBinding"></a>[49]&#160;&#160;&#160;</td>
<td><code>LetBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TypeDeclaration" id=
"doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AllowingEmpty" id=
"doc-xquery30-AllowingEmpty"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AllowingEmpty">AllowingEmpty</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"allowing" "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PositionalVar" id=
"doc-xquery30-PositionalVar"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PositionalVar">PositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-WindowClause" id=
"doc-xquery30-WindowClause"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-WindowClause">WindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" (<a href=
"#doc-xquery30-TumblingWindowClause">TumblingWindowClause</a> |
<a href=
"#doc-xquery30-SlidingWindowClause">SlidingWindowClause</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TumblingWindowClause" id=
"doc-xquery30-TumblingWindowClause"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TumblingWindowClause">TumblingWindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"tumbling" "window" "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SlidingWindowClause" id=
"doc-xquery30-SlidingWindowClause"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SlidingWindowClause">SlidingWindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sliding" "window" "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-WindowStartCondition" id=
"doc-xquery30-WindowStartCondition"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-WindowStartCondition">WindowStartCondition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"start" <a href="#doc-xquery30-WindowVars">WindowVars</a>
"when" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-WindowEndCondition" id=
"doc-xquery30-WindowEndCondition"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"only"? "end" <a href=
"#doc-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-WindowVars" id=
"doc-xquery30-WindowVars"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-WindowVars">WindowVars</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" <a href=
"#doc-xquery30-CurrentItem">CurrentItem</a>)? <a href=
"#doc-xquery30-PositionalVar">PositionalVar</a>? ("previous" "$"
<a href="#doc-xquery30-PreviousItem">PreviousItem</a>)? ("next" "$"
<a href="#doc-xquery30-NextItem">NextItem</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CurrentItem" id=
"doc-xquery30-CurrentItem"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CurrentItem">CurrentItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PreviousItem" id=
"doc-xquery30-PreviousItem"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PreviousItem">PreviousItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NextItem" id=
"doc-xquery30-NextItem"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NextItem">NextItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CountClause" id=
"doc-xquery30-CountClause"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CountClause">CountClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"count" "$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-WhereClause" id=
"doc-xquery30-WhereClause"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-WhereClause">WhereClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"where" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-GroupByClause" id=
"doc-xquery30-GroupByClause"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupByClause">GroupByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"group" "by" <a href=
"#doc-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-GroupingSpecList" id=
"doc-xquery30-GroupingSpecList"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-GroupingSpec">GroupingSpec</a>
("," <a href=
"#doc-xquery30-GroupingSpec">GroupingSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-GroupingSpec" id=
"doc-xquery30-GroupingSpec"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupingSpec">GroupingSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupingVariable">GroupingVariable</a> (<a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a>)? ("collation" <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-GroupingVariable" id=
"doc-xquery30-GroupingVariable"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupingVariable">GroupingVariable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderByClause" id=
"doc-xquery30-OrderByClause"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderByClause">OrderByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#doc-xquery30-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderSpecList" id=
"doc-xquery30-OrderSpecList"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderSpecList">OrderSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-OrderSpec">OrderSpec</a> (","
<a href="#doc-xquery30-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderSpec" id=
"doc-xquery30-OrderSpec"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderSpec">OrderSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a>
<a href="#doc-xquery30-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderModifier" id=
"doc-xquery30-OrderModifier"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderModifier">OrderModifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ReturnClause" id=
"doc-xquery30-ReturnClause"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ReturnClause">ReturnClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"return" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The semantics of FLWOR expressions are based on a concept called
a <b>tuple stream</b>. [<a name="id-tuple-stream-foobar" id=
"id-tuple-stream-foobar" title="tuple stream">Definition</a>: A
<b>tuple stream</b> is an ordered sequence of zero or more
<b>tuples</b>.] [<a name="id-tuple-foobar" id="id-tuple-foobar"
title="tuple">Definition</a>: A <b>tuple</b> is a set of zero or
more named variables, each of which is bound to a value that is an
<a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a>.] Each tuple stream is homogeneous in the sense that
all its tuples contain variables with the same names and the same
<a title="static type" href="#dt-static-type">static types</a>. The
following example illustrates a tuple stream consisting of four
tuples, each containing three variables named <code>$x</code>,
<code>$y</code>, and <code>$z</code>:</p>
<div class="exampleInner">
<pre>
($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;)
($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;)
($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;)
($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this section, tuple streams are represented as shown in the
above example. Each tuple is on a separate line and is enclosed in
parentheses, and the variable bindings inside each tuple are
separated by commas. This notation does not represent XQuery
syntax, but is simply a representation of a tuple stream for the
purpose of defining the semantics of FLWOR expressions.</p>
</div>
<p>Tuples and tuple streams are not part of the <a title=
"data model" href="#dt-datamodel">data model</a>. They exist only
as conceptual intermediate results during the processing of a FLWOR
expression.</p>
<p>Conceptually, the <span>first</span> clause generates a tuple
stream. Each clause <span>between the first clause and the return
clause</span> takes the tuple stream generated by the previous
clause as input and generates a (possibly different) tuple stream
as output. The <span>return</span> clause takes a tuple stream as
input and, for each tuple in this tuple stream, generates an
<a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a>; the final result of the FLWOR expression is the
ordered concatenation of these <a title="XDM instance" href=
"#dt-data-model-instance">XDM instances</a>.</p>
<p>The initial clause in a FLWOR expression may be a
<code>for</code>, <code>let</code>, <span>or</span>
<code>window</code> clause. Intermediate clauses may be
<code>for</code>, <code>let</code>, <code>window</code>,
<code>count</code>, <code>where</code>, <code>group by</code>, or
<code>order by</code> clauses. These intermediate clauses may be
repeated as many times as desired, in any order. The final clause
of the FLWOR expression must be a <code>return</code> clause. The
semantics of the various clauses are described in the following
sections.</p>
<div class="div3">
<h4><a name="id-binding-rules" id="id-binding-rules"></a>3.10.1
Variable Bindings</h4>
<p>The following clauses in FLWOR expressions bind values to
variables: <code>for</code>, <code>let</code>, <code>window</code>,
<code>count</code>, and <code>group by</code>. <span>The binding of
variables for <code>for</code>, <code>let</code>, <span>and</span>
<code>count</code> is governed by the following rules (<span>the
binding of variables in <code>group by</code> is discussed in
<a href="#id-group-by"><b>3.10.7 Group By Clause</b></a>,</span>
the binding of variables in <code>window</code> clauses is
discussed in <a href="#id-windows"><b>3.10.4 Window
Clause</b></a>):</span></p>
<ol class="enumar">
<li>
<p>The scope of a bound variable includes all subexpressions of the
containing FLWOR that appear after the variable binding. The scope
does not include the expression to which the variable is bound. The
following code fragment, containing two <code>let</code> clauses,
illustrates how variable bindings may reference variables that were
bound in earlier clauses, or in earlier bindings in the same
clause:</p>
<div class="exampleInner">
<pre>
let $x := 47, $y := f($x)
let $z := g($x, $y)
</pre></div>
</li>
<li>
<p>A given variable may be bound more than once in a FLWOR
expression, or even within one clause of a FLWOR expression. In
such a case, each new binding occludes the previous one, which
becomes inaccessible in the remainder of the FLWOR expression.</p>
</li>
<li>
<p>[<a name="dt-type-declaration" id="dt-type-declaration" title=
"type declaration">Definition</a>: A variable binding may be
accompanied by a <b>type declaration</b>, which consists of the
keyword <code>as</code> followed by the static type of the
variable, declared using the syntax in <a href=
"#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a>.] At
run time, if the value bound to the variable does not match the
declared type according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. For
example, the following <code>let</code> clause raises a <a title=
"type error" href="#dt-type-error">type error</a> because the
variable <code>$salary</code> has a type declaration that is not
satisfied by the value that is bound to it:</p>
<div class="exampleInner">
<pre>
let $salary as xs:decimal :=  "cat"
</pre></div>
</li>
<li>
<p>[<a name="dt-binding-sequence" id="dt-binding-sequence" title=
"binding sequence">Definition</a>: In a <code>for</code> clause or
<code>window</code> clause, when an expression is preceded by the
keyword <code>in</code>, the value of that expression is called a
<b>binding sequence</b>.] The <code>for</code> and
<code>window</code> clauses iterate over their binding sequences,
producing multiple bindings for one or more variables. Details on
how binding sequences are used in <code>for</code> and
<code>window</code> clauses are described in the following
sections.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-xquery-for-clause" id=
"id-xquery-for-clause"></a>3.10.2 For Clause</h4>
<h5><a name="d2e20346" id="d2e20346"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18433.doc-xquery30-ForClause" id=
"noid_d3e18433.doc-xquery30-ForClause"></a>[44]&#160;&#160;&#160;</td>
<td><code>ForClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href="#prod-xquery30-ForBinding">ForBinding</a>
("," <a href=
"#prod-xquery30-ForBinding">ForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18434.doc-xquery30-ForBinding" id=
"noid_d3e18434.doc-xquery30-ForBinding"></a>[45]&#160;&#160;&#160;</td>
<td><code>ForBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? <a href=
"#doc-xquery30-AllowingEmpty">AllowingEmpty</a>? <a href=
"#doc-xquery30-PositionalVar">PositionalVar</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18435.doc-xquery30-TypeDeclaration" id=
"noid_d3e18435.doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18436.doc-xquery30-AllowingEmpty" id=
"noid_d3e18436.doc-xquery30-AllowingEmpty"></a>[46]&#160;&#160;&#160;</td>
<td><code>AllowingEmpty</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"allowing" "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18437.doc-xquery30-PositionalVar" id=
"noid_d3e18437.doc-xquery30-PositionalVar"></a>[47]&#160;&#160;&#160;</td>
<td><code>PositionalVar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
</table>
<p>A <code>for</code> clause is used for iteration. Each variable
in a <code>for</code> clause iterates over a sequence and is bound
in turn to each item in the sequence.</p>
<p>If a <code>for</code> clause contains multiple variables, it is
semantically equivalent to multiple <code>for</code> clauses, each
containing one of the variables in the original <code>for</code>
clause.</p>
<p>Example:</p>
<ul>
<li>
<p>The clause</p>
<div class="exampleInner">
<pre>
for $x in $expr1, $y in $expr2
</pre></div>
<p>is semantically equivalent to:</p>
<div class="exampleInner">
<pre>
for $x in $expr1
for $y in $expr2
</pre></div>
</li>
</ul>
<p>In the remainder of this section, we define the semantics of a
<code>for</code> clause containing a single variable and an
associated expression (following the keyword <code>in</code>) whose
value is called the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> for that variable.</p>
<p>If a single-variable <code>for</code> clause is the initial
clause in a FLWOR expression, it iterates over its <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, binding the variable to each item in turn. The
resulting sequence of variable bindings becomes the initial tuple
stream that serves as input to the next clause of the FLWOR
expression. If <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the
order of tuples in the tuple stream preserves the order of the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a>; otherwise the order of the tuple stream is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>If the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> contains no items, the
output tuple stream depends on whether <code>allowing empty</code>
is specified. If <code>allowing empty</code> is specified, the
output tuple stream consists of one tuple in which the variable is
bound to an empty sequence. If <code>allowing empty</code> is not
specified, the output tuple stream consists of zero tuples.</p>
<p>The following examples illustrates tuple streams that are
generated by initial <code>for</code> clauses:</p>
<ul>
<li>
<p>Initial clause:</p>
<div class="exampleInner">
<pre>
for $x in (100, 200, 300)
</pre></div>
<p>or (equivalently):</p>
<div class="exampleInner">
<pre>
for $x allowing empty in (100, 200, 300)
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($x = 100)
($x = 200)
($x = 300)
</pre></div>
</li>
<li>
<p>Initial clause:</p>
<div class="exampleInner">
<pre>
for $x in ()
</pre></div>
<p>Output tuple stream contains no tuples.</p>
</li>
<li>
<p>Initial clause:</p>
<div class="exampleInner">
<pre>
for $x allowing empty in ()
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($x = ())
</pre></div>
</li>
</ul>
<p>[<a name="dt-positional-variable" id="dt-positional-variable"
title="positional variable">Definition</a>: A <b>positional
variable</b> is a variable that is preceded by the keyword
<code>at</code>.] A positional variable may be associated with a
variable that is bound in a <code>for</code> clause. In this case,
as the main variable iterates over the items in its <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, the positional variable iterates over the integers
that represent the ordinal numbers of these items in the <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, starting with one. Each tuple in the output tuple
stream contains bindings for both the main variable and the
positional variable. If the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> is empty and
<code>allowing empty</code> is specified, the positional variable
in the output tuple is bound to the integer zero. Positional
variables always have the implied type <code>xs:integer</code>. The
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of a positional variable must be distinct from the
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of the main variable with which it is associated
[<a href="#ERRXQST0089" title="err:XQST0089">err:XQST0089</a>].</p>
<p>The following examples illustrate how a positional variable
would have affected the results of the previous examples that
generated tuples:</p>
<ul>
<li>
<p>Initial clause:</p>
<div class="exampleInner">
<pre>
for $x at $i in (100, 200, 300)
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($x = 100, $i = 1)
($x = 200, $i = 2)
($x = 300, $i = 3)
</pre></div>
</li>
<li>
<p>Initial clause:</p>
<div class="exampleInner">
<pre>
for $x allowing empty at $i in ()
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($x = (), $i = 0)
</pre></div>
</li>
</ul>
<p>If a single-variable <code>for</code> clause is an intermediate
clause in a FLWOR expression, its <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> is evaluated for each
input tuple, given the bindings in that input tuple. Each input
tuple generates zero or more tuples in the output tuple stream.
Each of these output tuples consists of the original variable
bindings of the input tuple plus a binding of the new variable to
one of the items in its <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> is conceptually
evaluated independently for each input tuple, an optimized
implementation may sometimes be able to avoid re-evaluating the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> if it can show that the variables that the <a title=
"binding sequence" href="#dt-binding-sequence">binding sequence</a>
depends on have the same values as in a previous evaluation.</p>
</div>
<p>For a given input tuple, if the <a title="binding sequence"
href="#dt-binding-sequence">binding sequence</a> for the new
variable in the <code>for</code> clause contains no items, the
result depends on whether <code>allowing empty</code> is specified.
If <code>allowing empty</code> is specified, the input tuple
generates one output tuple, with the original variable bindings
plus a binding of the new variable to an empty sequence. If
<code>allowing empty</code> is not specified, the input tuple
generates zero output tuples (it is not represented in the output
tuple stream.)</p>
<p>If the new variable introduced by a <code>for</code> clause has
an associated <a title="positional variable" href=
"#dt-positional-variable">positional variable</a>, the output
tuples generated by the <code>for</code> clause also contain
bindings for the <a title="positional variable" href=
"#dt-positional-variable">positional variable</a>. In this case, as
the new variable is bound to each item in its <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, the <a title="positional variable" href=
"#dt-positional-variable">positional variable</a> is bound to the
ordinal position of that item within the <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, starting with one. Note that, since the <a title=
"positional variable" href="#dt-positional-variable">positional
variable</a> represents a position within a <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, the output tuples corresponding to each input tuple
are independently numbered, starting with one. For a given input
tuple, if the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> is empty and
<code>allowing empty</code> is specified, the <a title=
"positional variable" href="#dt-positional-variable">positional
variable</a> in the output tuple is bound to the integer zero.</p>
<p>If <a title="ordering mode" href="#dt-ordering-mode">ordering
mode</a> is <code>ordered</code>, the tuples in the output tuple
stream are ordered primarily by the order of the input tuples from
which they are derived, and secondarily by the order of the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> for the new variable; otherwise the order of the
output tuple stream is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>The following examples illustrates the effects of intermediate
<code>for</code> clauses:</p>
<ul>
<li>
<p>Input tuple stream:</p>
<div class="exampleInner">
<pre>
($x = 1)
($x = 2)
($x = 3)
($x = 4)
</pre></div>
<p>Intermediate <code>for</code> clause:</p>
<div class="exampleInner">
<pre>
for $y in ($x to 3)
</pre></div>
<p>Output tuple stream (assuming <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p>
<div class="exampleInner">
<pre>
($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this example, there is no output tuple that corresponds to
the input tuple <code>($x = 4)</code> because, when the
<code>for</code> clause is evaluated with the bindings in this
input tuple, the resulting <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> for <code>$y</code> is
empty.</p>
</div>
</li>
<li>
<p>This example shows how the previous example would have been
affected by a <a title="positional variable" href=
"#dt-positional-variable">positional variable</a> (assuming the
same input tuple stream):</p>
<div class="exampleInner">
<pre>
for $y at $j in ($x to 3)
</pre></div>
<p>Output tuple stream (assuming <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p>
<div class="exampleInner">
<pre>
($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
</pre></div>
</li>
<li>
<p>This example shows how the previous example would have been
affected by <code>allowing empty</code>. Note that <code>allowing
empty</code> causes the input tuple <code>($x = 4)</code> to be
represented in the output tuple stream, even though the <a title=
"binding sequence" href="#dt-binding-sequence">binding sequence</a>
for <code>$y</code> contains no items for this input tuple. This
example illustrates that <code>allowing empty</code> in a
<code>for</code> clause serves a purpose similar to that of an
"outer join" in a relational database query. (Assume the same input
tuple stream as in the previous example.)</p>
<div class="exampleInner">
<pre>
for $y allowing empty at $j in ($x to 3)
</pre></div>
<p>Output tuple stream (assuming <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p>
<div class="exampleInner">
<pre>
($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
($x = 4, $y = (), $j = 0)
</pre></div>
</li>
<li>
<p>This example shows how a <code>for</code> clause that binds two
variables is semantically equivalent to two <code>for</code>
clauses that bind one variable each. We assume that this
<code>for</code> clause occurs at the beginning of a FLWOR
expression. It is equivalent to an initial single-variable
<code>for</code> clause that provides an input tuple stream to an
intermediate single-variable <code>for</code> clause.</p>
<div class="exampleInner">
<pre>
for $x in (1, 2, 3, 4), $y in ($x to 3)
</pre></div>
<p>Output tuple stream (assuming <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p>
<div class="exampleInner">
<pre>
($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
</pre></div>
</li>
</ul>
<p>In the above examples, if <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> had been
<code>unordered</code>, the output tuple streams would have
consisted of the same tuples, with the same values for the
<a title="positional variable" href=
"#dt-positional-variable">positional variables</a>, but the
ordering of the tuples would have been <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>A <code>for</code> clause may contain one or more <a title=
"type declaration" href="#dt-type-declaration">type
declarations</a>, identified by the keyword <code>as</code>. The
semantics of <a title="type declaration" href=
"#dt-type-declaration">type declarations</a> are defined in
<a href="#id-binding-rules"><b>3.10.1 Variable
Bindings</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-xquery-let-clause" id=
"id-xquery-let-clause"></a>3.10.3 Let Clause</h4>
<h5><a name="d2e20828" id="d2e20828"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18868.doc-xquery30-LetClause" id=
"noid_d3e18868.doc-xquery30-LetClause"></a>[48]&#160;&#160;&#160;</td>
<td><code>LetClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href="#prod-xquery30-LetBinding">LetBinding</a>
("," <a href=
"#prod-xquery30-LetBinding">LetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18869.doc-xquery30-LetBinding" id=
"noid_d3e18869.doc-xquery30-LetBinding"></a>[49]&#160;&#160;&#160;</td>
<td><code>LetBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18870.doc-xquery30-TypeDeclaration" id=
"noid_d3e18870.doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>The purpose of a <code>let</code> clause is to bind values to
one or more variables. Each variable is bound to the result of
evaluating an expression.</p>
<p>If a <code>let</code> clause contains multiple variables, it is
semantically equivalent to multiple <code>let</code> clauses, each
containing a single variable. For example, the clause</p>
<div class="exampleInner">
<pre>
let $x := $expr1, $y := $expr2
</pre></div>
<p>is semantically equivalent to the following sequence of
clauses:</p>
<div class="exampleInner">
<pre>
let $x := $expr1
let $y := $expr2
</pre></div>
<p>In the remainder of this section, we define the semantics of a
<code>let</code> clause containing a single variable <em>V</em> and
an associated expression <em>E</em>.</p>
<p>If a single-variable <code>let</code> clause is the initial
clause in a FLWOR expression, it simply binds the variable
<em>V</em> to the result of the expression <em>E</em>. The result
of the <code>let</code> clause is a tuple stream consisting of one
tuple with a single binding that binds <em>V</em> to the result of
<em>E</em>. This tuple stream serves as input to the next clause in
the FLWOR expression.</p>
<p>If a single-variable <code>let</code> clause is an intermediate
clause in a FLWOR expression, it adds a new binding for variable
<em>V</em> to each tuple in the input tuple stream. For each input
tuple, the value bound to <em>V</em> is the result of evaluating
expression <em>E</em>, given the bindings that are already present
in that input tuple. The resulting tuples become the output tuple
stream of the <code>let</code> clause.</p>
<p>The number of tuples in the output tuple stream of an
intermediate <code>let</code> clause is the same as the number of
tuples in the input tuple stream. The number of bindings in the
output tuples is one more than the number of bindings in the input
tuples, unless the input tuples already contain bindings for
<em>V</em>; in this case, the new binding for <em>V</em> occludes
(replaces) the earlier binding for <em>V</em>, and the number of
bindings is unchanged.</p>
<p>A <code>let</code> clause may contain one or more <a title=
"type declaration" href="#dt-type-declaration">type
declarations</a>, identified by the keyword <code>as</code>. The
semantics of type declarations are defined in <a href=
"#id-binding-rules"><b>3.10.1 Variable Bindings</b></a>.</p>
<p>The following code fragment illustrates how a <code>for</code>
clause and a <code>let</code> clause can be used together. The
<code>for</code> clause produces an initial tuple stream containing
a binding for variable <code>$d</code> to each department number
found in a given input document. The <code>let</code> clause adds
an additional binding to each tuple, binding variable
<code>$e</code> to a sequence of employees whose department number
matches the value of <code>$d</code> in that tuple.</p>
<div class="exampleInner">
<pre>
for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno eq $d]
</pre></div>
</div>
<div class="div3">
<h4><a name="id-windows" id="id-windows"></a>3.10.4 Window
Clause</h4>
<h5><a name="d2e20988" id="d2e20988"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18998.doc-xquery30-WindowClause" id=
"noid_d3e18998.doc-xquery30-WindowClause"></a>[50]&#160;&#160;&#160;</td>
<td><code>WindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" (<a href=
"#doc-xquery30-TumblingWindowClause">TumblingWindowClause</a> |
<a href=
"#doc-xquery30-SlidingWindowClause">SlidingWindowClause</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e18999.doc-xquery30-TumblingWindowClause" id=
"noid_d3e18999.doc-xquery30-TumblingWindowClause"></a>[51]&#160;&#160;&#160;</td>
<td><code>TumblingWindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"tumbling" "window" "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19000.doc-xquery30-SlidingWindowClause" id=
"noid_d3e19000.doc-xquery30-SlidingWindowClause"></a>[52]&#160;&#160;&#160;</td>
<td><code>SlidingWindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sliding" "window" "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19001.doc-xquery30-WindowStartCondition" id=
"noid_d3e19001.doc-xquery30-WindowStartCondition"></a>[53]&#160;&#160;&#160;</td>
<td><code>WindowStartCondition</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"start" <a href="#doc-xquery30-WindowVars">WindowVars</a>
"when" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19002.doc-xquery30-WindowEndCondition" id=
"noid_d3e19002.doc-xquery30-WindowEndCondition"></a>[54]&#160;&#160;&#160;</td>
<td><code>WindowEndCondition</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"only"? "end" <a href=
"#doc-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19003.doc-xquery30-WindowVars" id=
"noid_d3e19003.doc-xquery30-WindowVars"></a>[55]&#160;&#160;&#160;</td>
<td><code>WindowVars</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" <a href=
"#doc-xquery30-CurrentItem">CurrentItem</a>)? <a href=
"#doc-xquery30-PositionalVar">PositionalVar</a>? ("previous" "$"
<a href="#doc-xquery30-PreviousItem">PreviousItem</a>)? ("next" "$"
<a href="#doc-xquery30-NextItem">NextItem</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19004.doc-xquery30-CurrentItem" id=
"noid_d3e19004.doc-xquery30-CurrentItem"></a>[56]&#160;&#160;&#160;</td>
<td><code>CurrentItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19005.doc-xquery30-PositionalVar" id=
"noid_d3e19005.doc-xquery30-PositionalVar"></a>[47]&#160;&#160;&#160;</td>
<td><code>PositionalVar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19006.doc-xquery30-PreviousItem" id=
"noid_d3e19006.doc-xquery30-PreviousItem"></a>[57]&#160;&#160;&#160;</td>
<td><code>PreviousItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19007.doc-xquery30-NextItem" id=
"noid_d3e19007.doc-xquery30-NextItem"></a>[58]&#160;&#160;&#160;</td>
<td><code>NextItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>Like a <code>for</code> clause, a <code>window</code> clause
iterates over its <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> and generates a
sequence of tuples. In the case of a <code>window</code> clause,
each tuple represents a window. [<a name="dt-window" id="dt-window"
title="window">Definition</a>: A <b>window</b> is a sequence of
consecutive items drawn from the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>.] Each window is
represented by at least one and at most nine bound variables. The
variables have user-specified names, but their roles are as
follows:</p>
<ul>
<li>
<p><em>Window-variable:</em> Bound to the sequence of items from
the <a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> that comprise the window.</p>
</li>
<li>
<p><em>Start-item:</em> (Optional) Bound to the first item in the
window.</p>
</li>
<li>
<p><em>Start-item-position:</em> (Optional) Bound to the ordinal
position of the first window item in the <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>. <em>Start-item-position</em> is a <a title=
"positional variable" href="#dt-positional-variable">positional
variable</a>; hence, its type is <code>xs:integer</code></p>
</li>
<li>
<p><em>Start-previous-item:</em> (Optional) Bound to the item in
the <a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> that precedes the first item in the window (empty
sequence if none).</p>
</li>
<li>
<p><em>Start-next-item:</em> (Optional) Bound to the item in the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> that follows the first item in the window (empty
sequence if none).</p>
</li>
<li>
<p><em>End-item:</em> (Optional) Bound to the last item in the
window.</p>
</li>
<li>
<p><em>End-item-position:</em> (Optional) Bound to the ordinal
position of the last window item in the <a title="binding sequence"
href="#dt-binding-sequence">binding sequence</a>.
<em>End-item-position</em> is a <a title="positional variable"
href="#dt-positional-variable">positional variable</a>; hence, its
type is <code>xs:integer</code></p>
</li>
<li>
<p><em>End-previous-item:</em> (Optional) Bound to the item in the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> that precedes the last item in the window (empty
sequence if none).</p>
</li>
<li>
<p><em>End-next-item:</em> (Optional) Bound to the item in the
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> that follows the last item in the window (empty
sequence if none).</p>
</li>
</ul>
<p>All variables in a <code>window</code> clause must have distinct
names; otherwise a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXQST0103" title="err:XQST0103">err:XQST0103</a>].</p>
<p>The following is an example of a <code>window</code> clause that
binds nine variables to the roles listed above. In this example,
the variables are named <code>$w</code>, <code>$s</code>,
<code>$spos</code>, <code>$sprev</code>, <code>$snext</code>,
<code>$e</code>, <code>$epos</code>, <code>$eprev</code>, and
<code>$enext</code> respectively. A <code>window</code> clause
always binds the window variable, but typically binds only a subset
of the other variables.</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10)
    start $s at $spos previous $sprev next $snext when true() 
    end $e at $epos previous $eprev next $enext when true()
</pre></div>
<p>Windows are created by iterating over the items in the <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>, in order, identifying the start item and the end item
of each window by evaluating the <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> and
the <a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a>. Each of
these conditions is satisfied if the <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of the expression following the <code>when</code> keyword
is <code>true</code>. The start item of the window is an item that
satisfies the <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> (see
<a href="#id-tumbling-windows"><b>3.10.4.1 Tumbling Windows</b></a>
and <a href="#id-sliding-windows"><b>3.10.4.2 Sliding
Windows</b></a> for a more complete explanation.) The end item of
the window is the first item in the <a title="binding sequence"
href="#dt-binding-sequence">binding sequence</a>, beginning with
the start item, that satisfies the <a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a> (again,
see <a href="#id-tumbling-windows"><b>3.10.4.1 Tumbling
Windows</b></a> and <a href="#id-sliding-windows"><b>3.10.4.2
Sliding Windows</b></a> for more details.) Each window contains its
start item, its end item, and all items that occur between them in
the <a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a>. If the end item is the start item, then the window
contains only one item. If a start item is identified, but no
following item in the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> satisfies the <a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a>, then the
<code>only</code> keyword determines whether a window is generated:
if <code>only end</code> is specified, then no window is generated;
otherwise, the end item is set to the last item in the <a title=
"binding sequence" href="#dt-binding-sequence">binding sequence</a>
and a window is generated.</p>
<p>In the above example, the <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> and
<a href="#doc-xquery30-WindowEndCondition">WindowEndCondition</a>
are both <code>true</code> , which causes each <span>item</span> in
the <a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> to be in a separate window. Typically, the <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> and
<a href="#doc-xquery30-WindowEndCondition">WindowEndCondition</a>
are expressed in terms of bound variables. For example, the
following <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> might
be used to start a new window for every item in the <a title=
"binding sequence" href="#dt-binding-sequence">binding sequence</a>
that is larger than both the previous item and the following
item:</p>
<div class="exampleInner">
<pre>
start $s previous $sprev next $snext
   when $s &gt; $sprev and $s &gt; $snext
</pre></div>
<p>The scoping rules for the variables bound by a
<code>window</code> clause are as follows:</p>
<ul>
<li>
<p>In the <code>when</code>-expression of the <a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a>, the
following variables (identified here by their roles) are in scope
(if bound): <em>start-item, start-item-position,
start-previous-item, start-next-item.</em></p>
</li>
<li>
<p>In the <code>when</code>-expression of the <a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a>, the
following variables (identified here by their roles) are in scope
(if bound): <em>start-item, start-item-position,
start-previous-item, start-next-item, end-item, end-item-position,
end-previous-item, end-next-item.</em></p>
</li>
<li>
<p>In the clauses of the FLWOR expression that follow the
<code>window</code> clause, all nine of the variables bound by the
<code>window</code> clause (including <em>window-variable</em>) are
in scope (if bound).</p>
</li>
</ul>
<p>In a <code>window</code> clause, the keyword
<code>tumbling</code> or <code>sliding</code> determines the way in
which the starting item of each window is identified, as explained
in the following sections.</p>
<div class="div4">
<h5><a name="id-tumbling-windows" id=
"id-tumbling-windows"></a>3.10.4.1 Tumbling Windows</h5>
<p>If the window type is <code>tumbling</code>, then windows never
overlap. The search for the start of the first window begins at the
beginning of the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>. After each window is
generated, the search for the start of the next window begins with
the item in the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> that occurs after the
ending item of the last generated window. Thus, no item that occurs
in one window can occur in another window drawn from the same
<a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a> <span>(unless the sequence contains the same item more
than once)</span>. In a tumbling window clause, the
<code>end</code> clause is optional; if it is omitted, the
<code>start</code> clause is applied to identify all potential
starting items in the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>, and a window is
constructed for each starting item, including all items from that
starting item up to the item before the next window's starting
item, or the end of the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>, whichever comes
first.</p>
<p>The following examples illustrate the use of tumbling
windows.</p>
<ul>
<li>
<p>Show non-overlapping windows of three items.</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
</pre></div>
</li>
<li>
<p>Show averages of non-overlapping three-item windows.</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return avg($w)
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
4 10
</pre></div>
</li>
<li>
<p>Show first and last items in each window of three items.</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start $first at $s when fn:true()
    only end $last at $e when $e - $s eq 2
return &lt;window&gt;{ $first, $last }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 6&lt;/window&gt;
&lt;window&gt;8 12&lt;/window&gt;
</pre></div>
</li>
<li>
<p>Show non-overlapping windows of up to three items (illustrates
<code>end</code> clause without the <code>only</code> keyword).</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;
</pre></div>
</li>
<li>
<p>Show non-overlapping windows of up to three items (illustrates
use of <code>start</code> without explicit <code>end</code>).</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when $s mod 3 = 1
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;
</pre></div>
</li>
<li>
<p>Show non-overlapping sequences starting with a number divisible
by 3.</p>
<div class="exampleInner">
<pre>
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start $first when $first mod 3 = 0
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;12 14&lt;/window&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-sliding-windows" id=
"id-sliding-windows"></a>3.10.4.2 Sliding Windows</h5>
<p>If the window type is <code>sliding window</code>, then windows
may overlap. Every item in the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a> that satisfies the
<a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a> is
the starting item of a new window. Thus, a given item may be found
in multiple windows drawn from the same <a title="binding sequence"
href="#dt-binding-sequence">binding sequence</a>.</p>
<p>The following examples illustrate the use of sliding
windows.</p>
<ul>
<li>
<p>Show windows of three items.</p>
<div class="exampleInner">
<pre>
for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;
</pre></div>
</li>
<li>
<p>Show moving averages of three items.</p>
<div class="exampleInner">
<pre>
for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return avg($w)
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
4 6 8 10 12
</pre></div>
</li>
<li>
<p>Show overlapping windows of up to three items (illustrates
<code>end</code> clause without the <code>only</code> keyword).</p>
<div class="exampleInner">
<pre>
for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;
</pre></div>
<p>Result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;
&lt;window&gt;12 14&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-effects-of-window-clauses" id=
"id-effects-of-window-clauses"></a>3.10.4.3 Effects of Window
Clauses on the Tuple Stream</h5>
<p>The effects of a <code>window</code> clause on the tuple stream
are similar to the effects of a <code>for</code> clause. As
described in <a href="#id-windows"><b>3.10.4 Window Clause</b></a>,
a <code>window</code> clause generates zero or more windows, each
of which is represented by at least one and at most nine bound
variables.</p>
<p>If the <code>window</code> clause is the initial clause in a
FLWOR expression, the bound variables that describe each window
become an output tuple. These tuples form the initial tuple stream
that serves as input to the next clause of the FLWOR expression. If
<a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>
is <code>ordered</code>, the order of tuples in the tuple stream is
the order in which their start items appear in the <a title=
"binding sequence" href="#dt-binding-sequence">binding
sequence</a>; otherwise the order of the tuple stream is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. The
cardinality of the tuple stream is equal to the number of
windows.</p>
<p>If a <code>window</code> clause is an intermediate clause in a
FLWOR expression, each input tuple generates zero or more output
tuples, each consisting of the original bound variables of the
input tuple plus the new bound variables that represent one of the
generated windows. For each tuple <em>T</em> in the input tuple
stream, the output tuple stream will contain <em>N<sub>T</sub></em>
tuples, where <em>N<sub>T</sub></em> is the number of windows
generated by the <code>window</code> clause, given the bindings in
the input tuple <em>T</em>. Input tuples for which no windows are
generated are not represented in the output tuple stream. If
<a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>
is <code>ordered</code>, the order of tuples in the output stream
is determined primarily by the order of the input tuples from which
they were derived, and secondarily by the order in which their
start items appear in the <a title="binding sequence" href=
"#dt-binding-sequence">binding sequence</a>. If <a title=
"ordering mode" href="#dt-ordering-mode">ordering mode</a> is
<code>unordered</code>, the order of tuples in the output stream is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>The following example illustrates a <code>window</code> clause
that is the initial clause in a FLWOR expression. The example is
based on input data that consists of a sequence of closing stock
prices for a specific company. For this example we assume the
following input data (assume that the <code>price</code> elements
have a validated type of <code>xs:decimal</code>):</p>
<div class="exampleInner">
<pre>
&lt;stock&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt;
&lt;/stock&gt;
</pre></div>
<p>A user wishes to find "run-ups," which are defined as sequences
of dates that begin with a "low" and end with a "high" price (that
is, the stock price begins to rise on the first day of the run-up,
and continues to rise or remain even through the last day of the
run-up.) The following query uses a tumbling window to find run-ups
in the input data:</p>
<div class="exampleInner">
<pre>
for tumbling window $w in //closing
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
   &lt;run-up&gt;
      &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt;
      &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt;
      &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt;
      &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt;
   &lt;/run-up&gt;
</pre></div>
<p>For our sample input data, this <code>tumbling window</code>
clause generates a tuple stream consisting of two tuples, each
representing a window and containing five bound variables named
<code>$w</code>, <code>$first</code>, <code>$second</code>,
<code>$last</code>, and <code>$beyond</code>. The
<code>return</code> clause is evaluated for each of these tuples,
generating the following query result:</p>
<div class="exampleInner">
<pre>
&lt;run-up&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;102&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;
</pre></div>
<p>The following example illustrates a <code>window</code> clause
that is an intermediate clause in a FLWOR expression. In this
example, the input data contains closing stock prices for several
different companies, each identified by a three-letter symbol. We
assume the following input data (again assuming that the type of
the <code>price</code> element is <code>xs:decimal</code>):</p>
<div class="exampleInner">
<pre>
&lt;stocks&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;057&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;054&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;056&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;052&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;055&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;059&lt;/price&gt; &lt;/closing&gt;
&lt;/stocks&gt;
</pre></div>
<p>As in the previous example, we want to find "run-ups," which are
defined as sequences of dates that begin with a "low" and end with
a "high" price for a specific company. In this example, however,
the input data consists of stock prices for multiple companies.
Therefore it is necessary to isolate the stock prices of each
company before forming windows. This can be accomplished by an
initial <code>for</code> and <code>let</code> clause, followed by a
<code>window</code> clause, as follows:</p>
<div class="exampleInner">
<pre>
for $symbol in fn:distinct-values(//symbol)
let $closings := //closing[symbol = $symbol]
for tumbling window $w in $closings
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
   &lt;run-up symbol="{$symbol}"&gt;
      &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt;
      &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt;
      &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt;
      &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt;
   &lt;/run-up&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the above example, the <code>for</code> and <code>let</code>
clauses could be rewritten as follows:</p>
<div class="exampleInner">
<pre>
for $closings in //closing
let $symbol := $closings/symbol
group by $symbol
</pre></div>
<p>The <code>group by</code> clause is described in <a href=
"#id-group-by"><b>3.10.7 Group By Clause</b></a>.</p>
</div>
<p>The <code>for</code> and <code>let</code> clauses in this query
generate an initial tuple stream consisting of two tuples. In the
first tuple, <code>$symbol</code> is bound to "ABC" and
<code>$closings</code> is bound to the sequence of
<code>closing</code> elements for company ABC. In the second tuple,
<code>$symbol</code> is bound to "DEF" and <code>$closings</code>
is bound to the sequence of <code>closing</code> elements for
company DEF.</p>
<p>The <code>window</code> clause operates on this initial tuple
stream, generating two windows for the first tuple and two windows
for the second tuple. The result is a tuple stream consisting of
four tuples, each with the following bound variables:
<code>$symbol</code>, <code>$closings</code>, <code>$w</code>,
<code>$first</code>, <code>$second</code>, <code>$last</code>, and
<code>$beyond</code>. The <code>return</code> clause is then
evaluated for each of these tuples, generating the following query
result:</p>
<div class="exampleInner">
<pre>
&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;054&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-03&lt;/end-date&gt;
   &lt;end-price&gt;056&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;start-price&gt;052&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;059&lt;/end-price&gt;
&lt;/run-up&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-where" id="id-where"></a>3.10.5 Where Clause</h4>
<h5><a name="d2e21811" id="d2e21811"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19709.doc-xquery30-WhereClause" id=
"noid_d3e19709.doc-xquery30-WhereClause"></a>[60]&#160;&#160;&#160;</td>
<td><code>WhereClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"where" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <code>where</code> clause serves as a filter for the tuples in
its input tuple stream. The expression in the <code>where</code>
clause, called the <b>where-expression</b>, is evaluated once for
each of these tuples. If the <a title="effective boolean value"
href="#dt-ebv">effective boolean value</a> of the where-expression
is <code>true</code>, the tuple is retained in the output tuple
stream; otherwise the tuple is discarded.</p>
<p>Examples:</p>
<ul>
<li>
<p>This example illustrates the effect of a <code>where</code>
clause on a tuple stream:</p>
<p>Input tuple stream:</p>
<div class="exampleInner">
<pre>
($a = 5, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)
</pre></div>
<p><code>where</code> clause:</p>
<div class="exampleInner">
<pre>
where $a &gt; $b
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($a = 91, $b = 42)
($a = 85, $b = 63)
</pre></div>
</li>
<li>
<p>The following query illustrates how a <code>where</code> clause
might be used with a <a title="positional variable" href=
"#dt-positional-variable">positional variable</a> to perform
sampling on an input sequence. The query returns one value out of
each one hundred input values.</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $x at $i in $inputvalues
where $i mod 100 = 0
return $x</span>
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-count" id="id-count"></a>3.10.6 Count Clause</h4>
<h5><a name="d2e21877" id="d2e21877"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19768.doc-xquery30-CountClause" id=
"noid_d3e19768.doc-xquery30-CountClause"></a>[59]&#160;&#160;&#160;</td>
<td><code>CountClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"count" "$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
</table>
<p>The purpose of a <code>count</code> clause is to enhance the
tuple stream with a new variable that is bound, in each tuple, to
the ordinal position of that tuple in the tuple stream. The name of
the new variable is specified in the <code>count</code> clause.</p>
<p>The output tuple stream of a <code>count</code> clause is the
same as its input tuple stream, with each tuple enhanced by one
additional variable that is bound to the ordinal position of that
tuple in the tuple stream. However, if the name of the new variable
is the same as the name of an existing variable in the input tuple
stream, the new variable occludes (replaces) the existing variable
of the same name, and the number of bound variables in each tuple
is unchanged.</p>
<p>The following examples illustrate uses of the <code>count</code>
clause:</p>
<ul>
<li>
<p>This example illustrates the effect of a <code>count</code>
clause on an input tuple stream:</p>
<p>Input tuple stream:</p>
<div class="exampleInner">
<pre>
($name = "Bob", $age = 21)
($name = "Carol", $age = 19)
($name = "Ted", $age = 20)
($name = "Alice", $age = 22)
</pre></div>
<p><code>count</code> clause:</p>
<div class="exampleInner">
<pre>
count $counter
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($name = "Bob", $age = 21, $counter = 1)
($name = "Carol", $age = 19, $counter = 2)
($name = "Ted", $age = 20, $counter = 3)
($name = "Alice", $age = 22, $counter = 4)
</pre></div>
</li>
<li>
<p>This example illustrates how a counter might be used to filter
the result of a query. The query ranks products in order by
decreasing sales, and returns the three products with the highest
sales. Assume that the variable <code>$products</code> is bound to
a sequence of <code>product</code> elements, each of which has
<code>name</code> and <code>sales</code> child-elements.</p>
<div class="exampleInner">
<pre>
for $p in $products
order by $p/sales descending
count $rank
where $rank &lt;= 3
return
   &lt;product rank="{$rank}"&gt;
      {$p/name, $p/sales}
   &lt;/product&gt;
</pre></div>
<p>The result of this query has the following structure:</p>
<div class="exampleInner">
<pre>
&lt;product rank="1"&gt;
   &lt;name&gt;Toaster&lt;/name&gt;
   &lt;sales&gt;968&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="2"&gt;
   &lt;name&gt;Blender&lt;/name&gt;
   &lt;sales&gt;520&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="3"&gt;
   &lt;name&gt;Can Opener&lt;/name&gt;
   &lt;sales&gt;475&lt;/sales&gt;
&lt;/product&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-group-by" id="id-group-by"></a>3.10.7 Group By
Clause</h4>
<h5><a name="d2e21951" id="d2e21951"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19835.doc-xquery30-GroupByClause" id=
"noid_d3e19835.doc-xquery30-GroupByClause"></a>[61]&#160;&#160;&#160;</td>
<td><code>GroupByClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"group" "by" <a href=
"#doc-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19836.doc-xquery30-GroupingSpecList" id=
"noid_d3e19836.doc-xquery30-GroupingSpecList"></a>[62]&#160;&#160;&#160;</td>
<td><code>GroupingSpecList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-GroupingSpec">GroupingSpec</a>
("," <a href=
"#doc-xquery30-GroupingSpec">GroupingSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19837.doc-xquery30-GroupingSpec" id=
"noid_d3e19837.doc-xquery30-GroupingSpec"></a>[63]&#160;&#160;&#160;</td>
<td><code>GroupingSpec</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupingVariable">GroupingVariable</a> (<a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a>)? ("collation" <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e19838.doc-xquery30-GroupingVariable" id=
"noid_d3e19838.doc-xquery30-GroupingVariable"></a>[64]&#160;&#160;&#160;</td>
<td><code>GroupingVariable</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#doc-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
</table>
<p>A <code>group by</code> clause generates an output tuple stream
in which each tuple represents a group of tuples from the input
tuple stream <span>that have equivalent grouping keys</span>. We
will refer to the tuples in the input tuple stream as
<b>pre-grouping tuples</b>, and the tuples in the output tuple
stream as <b>post-grouping tuples</b>.</p>
<p>The <code>group by</code> clause assigns each pre-grouping tuple
to a group, and generates one post-grouping tuple for each group.
<span>In the post-grouping tuple for a group, each grouping key is
represented by a variable that was specified in a <a href=
"#doc-xquery30-GroupingSpec">GroupingSpec</a>, and every variable
that appears in the pre-grouping tuples that were assigned to that
group is represented by a variable of the same name, bound to a
sequence of all values bound to the variable in any of these
pre-grouping tuples.</span> Subsequent clauses in the FLWOR
expression see only the variable bindings in the post-grouping
tuples; they no longer have access to the variable bindings in the
pre-grouping tuples. <span>The number of post-grouping tuples is
less than or equal to the number of pre-grouping tuples</span>.</p>
<p>A <code>group by</code> clause contains one or more <a href=
"#doc-xquery30-GroupingSpec">grouping specifications</a>, as shown
in the grammar. [<a name="dt-grouping-variable" id=
"dt-grouping-variable" title="grouping variable">Definition</a>:
Each grouping specification specifies one <a href=
"#doc-xquery30-GroupingVariable">grouping variable</a>, which
refers to variable bindings in the pre-grouping tuples. The values
of the grouping variables are used to assign pre-grouping tuples to
groups.] Each grouping specification may optionally provide an
expression to which its grouping variable is bound. If no
expression is provided, the grouping variable name must be equal
(by the <code>eq</code> operator on <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a>) to the name of a variable
in the input tuple stream, and it refers to that variable;
otherwise a <a title="static error" href="#dt-static-error">static
error</a> is raised [<a href="#ERRXQST0094" title=
"err:XQST0094">err:XQST0094</a>]. For each grouping specification
that contains a binding expression, a <code>let</code> binding is
created in the pre-grouping tuples, and the grouping variable
refers to that <code>let</code> binding. For example, the
clause:</p>
<div class="exampleInner">
<pre>
group by $g1, $g2 := $expr1, $g3 := $expr2 collation "Spanish"
</pre></div>
<p>is semantically equivalent to the following sequence of
clauses:</p>
<div class="exampleInner">
<pre>
let $g2 := $expr1
let $g3 := $expr2
group by $g1, $g2, $g3 collation "Spanish"
</pre></div>
<p>The process of group formation proceeds as follows:</p>
<ol class="enumar">
<li>
<p>[<a name="dt-grouping-key" id="dt-grouping-key" title=
"grouping key">Definition</a>: The atomized value of a <a title=
"grouping variable" href="#dt-grouping-variable">grouping
variable</a> is called a <b>grouping key</b>.] For each
pre-grouping tuple, the <a title="grouping key" href=
"#dt-grouping-key">grouping keys</a> are created by <a title=
"atomization" href="#dt-atomization">atomizing</a> the values of
the <a title="grouping variable" href=
"#dt-grouping-variable">grouping variables</a> (in the
post-grouping tuples, each grouping variable is set to the value of
the corresponding grouping key, as discussed below). If the value
of any <a title="grouping variable" href=
"#dt-grouping-variable">grouping variable</a> consists of more than
one item, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]. <span>If a type declaration is
present and the resulting atomized value is not an instance of the
specified type, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</span></p>
</li>
<li>
<p>The input tuple stream is partitioned into groups of tuples
whose grouping keys are <a title="equivalent grouping keys" href=
"#dt-equivalent-grouping-keys">equivalent</a>. [<a name=
"dt-equivalent-grouping-keys" id="dt-equivalent-grouping-keys"
title="equivalent grouping keys">Definition</a>: Two tuples
<var>T1</var> and <var>T2</var> have <b>equivalent grouping
keys</b> if and only if, for each grouping variable <var>GV</var>,
the atomized value of <var>GV</var> in <var>T1</var> is deep-equal
to the atomized value of <var>GV</var> in <var>T2</var>, as defined
by applying the function <code>fn:deep-equal</code> using the
appropriate collation.] If these values are of different numeric
types, and differ from each other by small amounts, then the
deep-equal relationship is not transitive, because of rounding
effects occurring during type promotion. When comparing three
values <code>A</code>, <code>B</code>, and <code>C</code> such that
<code>A eq B</code>, <code>B eq C</code>, but <code>A ne C</code>,
then the number of items in the result of the function (as well as
the choice of which items are returned) is <a title=
"implementation dependent" href="#dt-implementation-dependent"></a>
subject only to the constraints that (a) no two items in the result
sequence compare equal to each other, and (b) every input item that
does not appear in the result sequence compares equal to some item
that does appear in the result sequence. See <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-distinct-values">Section
14.2.1 fn:distinct-values</a> <sup><small>FO30</small></sup> for
further discussion of this issue in a different context.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The atomized grouping key will always be either an empty
sequence or a single atomic value. Defining equivalence by
reference to the <code>fn:deep-equal</code> function ensures that
the empty sequence is equivalent only to the empty sequence, that
<code>NaN</code> is equivalent to <code>NaN</code>, that
untypedAtomic values are compared as strings, and that values for
which the <code>eq</code> operator is not defined are considered
non-equivalent.</p>
</div>
</li>
<li>
<p>The appropriate collation for comparing two grouping keys is the
collation specified in the pertinent <a href=
"#doc-xquery30-GroupingSpec">GroupingSpec</a> if present, or the
default collation from the static context otherwise. If the
collation is specified by a relative URI, that relative URI is
<a title="resolve" href="#dt-resolve-relative-uri">resolved to an
absolute URI</a> using the <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>.</span> If the specified
collation is not found in statically known collations, a static
error is raised [<a href="#ERRXQST0076" title=
"err:XQST0076">err:XQST0076</a>].</p>
</li>
</ol>
<p>Each group of tuples produced by the above process results in
one post-grouping tuple. The pre-grouping tuples from which the
group is derived have <em>equivalent</em> <a title="grouping key"
href="#dt-grouping-key">grouping keys</a>, but these keys are not
necessarily identical (for example, the strings "Frog" and "frog"
might be <em>equivalent</em> according to the collation in use.) In
the post-grouping tuple, each <a title="grouping variable" href=
"#dt-grouping-variable">grouping variable</a> is bound to the value
of <span>the corresponding grouping key</span>.</p>
<p>In the post-grouping tuple generated for a given group, each
non-grouping variable is bound to a sequence containing the
concatenated values of that variable in all the pre-grouping tuples
that were assigned to that group. If <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the
values derived from individual tuples are concatenated in a way
that preserves the order of the pre-grouping tuple stream;
otherwise the ordering of these values is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This behavior may be surprising to SQL programmers, since SQL
reduces the equivalent of a non-grouping variable to one
representative value. Consider the following query:</p>
<div class="exampleInner">
<pre>
let $x := 64000
for $c in //customer
where $c/salary &gt; $x
group by $d := $c/department
return
&lt;department name="{$d}"&gt;
   Number of employees earning more than ${$x} is {count($c)}
&lt;/department&gt;
</pre></div>
<p>If there are three qualifying customers in the sales department
this evaluates to:</p>
<div class="exampleInner">
<pre>

&lt;department name="sales"&gt;
  Number of employees earning more than $64000 64000 64000 is 3
&lt;/department&gt;
</pre></div>
<p>In XQuery, each group is a sequence of items that match the
group by criteria—in a tree-structured language like XQuery, this
is convenient, because further structures can be built based on the
items in this sequence. Because there are three items in the group,
<code>$x</code> evaluates to a sequence of three items. To reduce
this to one item, use <code>fn:distinct-values()</code>:</p>
<div class="exampleInner">
<pre>
let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary &gt; $x
group by $d
return
 &lt;department name="{$d}"&gt;
  Number of employees earning more than ${distinct-values($x)} is {count($c)}
 &lt;/department&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In general, the <a title="static type" href=
"#dt-static-type">static type</a> of a variable in a post-grouping
tuple is different from the <a title="static type" href=
"#dt-static-type">static type</a> of the variable with the same
name in the pre-grouping tuples.</p>
</div>
<p>The order in which tuples appear in the post-grouping tuple
stream is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An <code>order by</code> clause can be used to impose a
value-based ordering on the post-grouping tuple stream. Similarly,
if it is desired to impose a value-based ordering within a group
(i.e., on the sequence of items bound to a non-grouping variable),
this can be accomplished by a nested FLWOR expression that iterates
over these items and applies an <code>order by</code> clause. In
some cases, a value-based ordering within groups can be
accomplished by applying an <code>order by</code> clause on a
non-grouping variable before applying the <code>group by</code>
clause.</p>
</div>
<p>A <code>group by</code> clause rebinds all the variables in the
input tuple stream. The scopes of these variables are not affected
by the <code>group by</code> clause, but in post-grouping tuples
the values of the variables represent group properties rather than
properties of individual pre-grouping tuples.</p>
<p>Examples:</p>
<ul>
<li>
<p>This example illustrates the effect of a <code>group by</code>
clause on a tuple stream.</p>
<p>Input tuple stream:</p>
<div class="exampleInner">
<pre>
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)
</pre></div>
<p><code>group by</code> clause:</p>
<div class="exampleInner">
<pre>
group by $storeno
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($storeno = S101, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;/itemno&gt;))
($storeno = S102, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))
</pre></div>
</li>
</ul>
<ul>
<li>
<p>This example and the ones that follow are based on two separate
sequences of elements, named <code>$sales</code> and
<code>$products</code>. We assume that the variable
<code>$sales</code> is bound to a sequence of elements with the
following structure:</p>
<div class="exampleInner">
<pre>
&lt;sales&gt;
   &lt;storeno&gt;S101&lt;/storeno&gt;
   &lt;itemno&gt;P78395&lt;/itemno&gt;
   &lt;qty&gt;125&lt;/qty&gt;
&lt;/sales&gt;
</pre></div>
<p>We also assume that the variable <code>$products</code> is bound
to a sequence of elements with the following structure:</p>
<div class="exampleInner">
<pre>
&lt;product&gt;
   &lt;itemno&gt;P78395&lt;/itemno&gt;
   &lt;price&gt;25.00&lt;/price&gt;
   &lt;category&gt;Men's Wear&lt;/category&gt;
&lt;/product&gt;
</pre></div>
<p>The simplest kind of grouping query has a single <a title=
"grouping variable" href="#dt-grouping-variable">grouping
variable</a>. The query in this example finds the total quantity of
items sold by each store:</p>
<div class="exampleInner">
<pre>
for $s in $sales
let $storeno := $s/storeno
group by $storeno
return &lt;store number="{$storeno}" total-qty="{sum($s/qty)}"/&gt;
</pre></div>
<p>The result of this query is a sequence of elements with the
following structure:</p>
<div class="exampleInner">
<pre>
&lt;store number="S101" total-qty="1550" /&gt;
&lt;store number="S102" total-qty="2125" /&gt;
</pre></div>
</li>
<li>
<p>In a more realistic example, a user might be interested in the
total revenue generated by each store for each product category.
Revenue depends on both the quantity sold of various items and the
price of each item. The following query joins the two input
sequences and groups the resulting tuples by two <a title=
"grouping variable" href="#dt-grouping-variable">grouping
variables</a>:</p>
<div class="exampleInner">
<pre>
for $s in $sales,
    $p in $products[itemno = $s/itemno]
let $revenue := $s/qty * $p/price
group by $storeno := $s/storeno, 
    $category := $p/category
return
    &lt;summary storeno="{$storeno}"
              category="{$category}"
              revenue="{sum($revenue)}"/&gt;
</pre></div>
<p>The result of this query is a sequence of elements with the
following structure:</p>
<div class="exampleInner">
<pre>
&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt;
&lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt;
&lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt;
&lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt;
&lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;
</pre></div>
</li>
<li>
<p>The result of the previous example was a "flat" list of
elements. A user might prefer the query result to be presented in
the form of a hierarchical report, grouped primarily by store (in
order by store number) and secondarily by product category. Within
each store, the user might want to see only those product
categories whose total revenue exceeds $10,000, presented in
descending order by their total revenue. This report is generated
by the following query:</p>
<div class="exampleInner">
<pre>
for $s1 in $sales
let $storeno := $s1/storeno
group by $storeno
order by $storeno
return
  &lt;store storeno="{$storeno}"&gt;
    {for $s2 in $s1,
         $p in $products[itemno = $s2/itemno]
     let $category := $p/category,
         $revenue := $s2/qty * $p/price
     group by $category
     let $group-revenue := sum($revenue)
     where $group-revenue &gt; 10000
     order by $group-revenue descending
     return &lt;category name="{$category}" revenue="{$group-revenue}"/&gt;
    }
  &lt;/store&gt;
</pre></div>
<p>The result of this example query has the following
structure:</p>
<div class="exampleInner">
<pre>
&lt;store storeno="S101"&gt;
   &lt;category name="Men's Wear" revenue="10185"/&gt;
&lt;/store&gt;
&lt;store storeno="S102"&gt;
   &lt;category name="Jewelry" revenue="30750"/&gt;
   &lt;category name="Appliances" revenue="22650"/&gt;
&lt;/store&gt;
</pre></div>
</li>
<li>
<p>The following example illustrates how to avoid a possible
pitfall in writing grouping queries.</p>
<p>In each post-grouping tuple, all variables except for the
grouping variable are bound to sequences of items derived from all
the pre-grouping tuples from which the group was formed. For
instance, in the following query, <code>$high-price</code> is bound
to a sequence of items in the post-grouping tuple.</p>
<div class="exampleInner">
<pre>
let $high-price := 1000
for $p in $products[price &gt; $high-price]
let $category := $p/category
group by $category
return
   &lt;category name="{$category}"&gt;
      {fn:count($p)} products have price greater than {$high-price}.
   &lt;/category&gt;
</pre></div>
<p>If three products in the "Men's Wear" category have prices
greater than 1000, the result of this query might look (in part)
like this:</p>
<div class="exampleInner">
<pre>
&lt;category name="Men's Wear"&gt;
   3 products have price greater than 1000 1000 1000.
&lt;/category&gt;
</pre></div>
<p>The repetition of "1000" in this query result is due to the fact
that <code>$high-price</code> is not a <a title="grouping variable"
href="#dt-grouping-variable">grouping variable</a>. One way to
avoid this repetition is to move the binding of
<code>$high-price</code> to an outer-level FLWOR expression, as
follows:</p>
<div class="exampleInner">
<pre>
let $high-price := 1000
return
   for $p in $products[price &gt; $high-price]
   let $category := $p/category
   group by $category
   return
      &lt;category name="{$category}"&gt;
         {fn:count($p)} products have price greater than {$high-price}.
      &lt;/category&gt;
</pre></div>
<p>The result of the revised query might contain the following
element:</p>
<div class="exampleInner">
<pre>
&lt;category name="Men's Wear"&gt;
   3 products have price greater than 1000.
&lt;/category&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-order-by-clause" id="id-order-by-clause"></a>3.10.8
Order By Clause</h4>
<h5><a name="d2e22411" id="d2e22411"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e20255.doc-xquery30-OrderByClause" id=
"noid_d3e20255.doc-xquery30-OrderByClause"></a>[65]&#160;&#160;&#160;</td>
<td><code>OrderByClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#doc-xquery30-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e20256.doc-xquery30-OrderSpecList" id=
"noid_d3e20256.doc-xquery30-OrderSpecList"></a>[66]&#160;&#160;&#160;</td>
<td><code>OrderSpecList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-OrderSpec">OrderSpec</a> (","
<a href="#doc-xquery30-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e20257.doc-xquery30-OrderSpec" id=
"noid_d3e20257.doc-xquery30-OrderSpec"></a>[67]&#160;&#160;&#160;</td>
<td><code>OrderSpec</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ExprSingle">ExprSingle</a>
<a href="#doc-xquery30-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e20258.doc-xquery30-OrderModifier" id=
"noid_d3e20258.doc-xquery30-OrderModifier"></a>[68]&#160;&#160;&#160;</td>
<td><code>OrderModifier</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
</table>
<p>The purpose of an <code>order by</code> clause is to impose a
value-based ordering on the tuples in the tuple stream. The output
tuple stream of the <code>order by</code> clause contains the same
tuples as its input tuple stream, but the tuples may be in a
different order.</p>
<p>An <code>order by</code> clause contains one or more ordering
specifications, called <a href=
"#doc-xquery30-OrderSpec">orderspecs</a>, as shown in the grammar.
For each tuple in the input tuple stream, the orderspecs are
evaluated, using the variable bindings in that tuple. The relative
order of two tuples is determined by comparing the values of their
orderspecs, working from left to right until a pair of unequal
values is encountered. If an orderspec specifies a <a title=
"collation" href="#dt-collation">collation</a>, that collation is
used in comparing values of type <code>xs:string</code>,
<code>xs:anyURI</code>, or types derived from them (otherwise, the
<a title="default collation" href="#dt-def-collation">default
collation</a> is used in comparing values of these types). If an
orderspec specifies a collation by a relative URI, that relative
URI is <a title="resolve" href="#dt-resolve-relative-uri">resolved
to an absolute URI</a> using the <span><a title="Static Base URI"
href="#dt-static-base-uri">Static Base URI</a>.</span> If an
orderspec specifies a collation that is not found in <a title=
"statically known collations" href=
"#dt-static-collations">statically known collations</a>, an error
is raised [<a href="#ERRXQST0076" title=
"err:XQST0076">err:XQST0076</a>].</p>
<p>The process of evaluating and comparing the orderspecs is based
on the following rules:</p>
<ul>
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the result of the expression in each orderspec. If the
result of atomization is neither a single atomic value nor an empty
sequence, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the value of an orderspec has the <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>
<code>xs:untypedAtomic</code> (such as character data in a
schemaless document), it is cast to the type
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Consistently treating untyped values as strings enables the
sorting process to begin without complete knowledge of the types of
all the values to be sorted.</p>
</div>
</li>
<li>
<p>All the non-empty orderspec values must be convertible to a
common type by <a title="subtype substitution" href=
"#dt-subtype-substitution">subtype substitution</a> and/or
<a title="type promotion" href="#dt-type-promotion">type
promotion</a>. The ordering is performed in the least common type
that has a <code>gt</code> operator. If two or more non-empty
orderspec values are not convertible to a common type that has a
<code>gt</code> operator, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>].</p>
<ul>
<li>
<p>Example: The orderspec values include a value of type
<code>hatsize</code>, which is derived from
<code>xs:integer</code>, and a value of type <code>shoesize</code>,
which is derived from <code>xs:decimal</code>. The least common
type reachable by subtype substitution and type promotion is
<code>xs:decimal</code>.</p>
</li>
<li>
<p>Example: The orderspec values include a value of type
<code>xs:string</code> and a value of type <code>xs:anyURI</code>.
The least common type reachable by subtype substitution and type
promotion is <code>xs:string</code>.</p>
</li>
</ul>
</li>
</ul>
<p>For the purpose of determining their relative position in the
ordering sequence, the <em>greater-than</em> relationship between
two orderspec values <em>W</em> and <em>V</em> is defined as
follows:</p>
<ul>
<li>
<p>When the orderspec specifies <code>empty least</code>, the
following rules are applied in order:</p>
<ol class="enumar">
<li>
<p>If <em>V</em> is an empty sequence and <em>W</em> is not an
empty sequence, then <em>W</em> <em>greater-than</em> <em>V</em> is
true.</p>
</li>
<li>
<p>If <em>V</em> is <code>NaN</code> and <em>W</em> is neither
<code>NaN</code> nor an empty sequence, then <em>W</em>
<em>greater-than</em> <em>V</em> is true.</p>
</li>
<li>
<p>If a specific collation <em>C</em> is specified, and <em>V</em>
and <em>W</em> are both of type <code>xs:string</code> or are
convertible to <code>xs:string</code> by <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a> and/or <a title="type promotion" href=
"#dt-type-promotion">type promotion</a>, then:</p>
<p>If <code>fn:compare(V, W, C)</code> is less than zero, then
<em>W</em> <em>greater-than</em> <em>V</em> is true; otherwise
<em>W</em> <em>greater-than</em> <em>V</em> is false.</p>
</li>
<li>
<p>If none of the above rules apply, then:</p>
<p>If <code>W gt V</code> is true, then <em>W</em>
<em>greater-than</em> <em>V</em> is true; otherwise <em>W</em>
<em>greater-than</em> <em>V</em> is false.</p>
</li>
</ol>
</li>
<li>
<p>When the orderspec specifies <code>empty greatest</code>, the
following rules are applied in order:</p>
<ol class="enumar">
<li>
<p>If <em>W</em> is an empty sequence and <em>V</em> is not an
empty sequence, then <em>W</em> <em>greater-than</em> <em>V</em> is
true.</p>
</li>
<li>
<p>If <em>W</em> is <code>NaN</code> and <em>V</em> is neither
<code>NaN</code> nor an empty sequence, then <em>W</em>
<em>greater-than</em> <em>V</em> is true.</p>
</li>
<li>
<p>If a specific collation <em>C</em> is specified, and <em>V</em>
and <em>W</em> are both of type <code>xs:string</code> or are
convertible to <code>xs:string</code> by <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a> and/or <a title="type promotion" href=
"#dt-type-promotion">type promotion</a>, then:</p>
<p>If <code>fn:compare(V, W, C)</code> is less than zero, then
<em>W</em> <em>greater-than</em> <em>V</em> is true; otherwise
<em>W</em> <em>greater-than</em> <em>V</em> is false.</p>
</li>
<li>
<p>If none of the above rules apply, then:</p>
<p>If <code>W gt V</code> is true, then <em>W</em>
<em>greater-than</em> <em>V</em> is true; otherwise <em>W</em>
<em>greater-than</em> <em>V</em> is false.</p>
</li>
</ol>
</li>
<li>
<p>When the orderspec specifies neither <code>empty least</code>
nor <code>empty greatest</code>, the <a title=
"default order for empty sequences" href=
"#dt-default-empty-order">default order for empty sequences</a> in
the <a title="static context" href="#dt-static-context">static
context</a> determines whether the rules for <code>empty
least</code> or <code>empty greatest</code> are used.</p>
</li>
</ul>
<p>If <em>T1</em> and <em>T2</em> are two tuples in the input tuple
stream, and <em>V1</em> and <em>V2</em> are the first pair of
values encountered when evaluating their orderspecs from left to
right for which one value is <em>greater-than</em> the other (as
defined above), then:</p>
<ol class="enumar">
<li>
<p>If <em>V1</em> is <em>greater-than</em> <em>V2:</em> If the
orderspec specifies <code>descending</code>, then <em>T1</em>
precedes <em>T2</em> in the output tuple stream; otherwise,
<em>T2</em> precedes <em>T1</em> in the output tuple stream.</p>
</li>
<li>
<p>If <em>V2</em> is <em>greater-than</em> <em>V1</em>: If the
orderspec specifies <code>descending</code>, then <em>T2</em>
precedes <em>T1</em> in the output tuple stream; otherwise,
<em>T1</em> precedes <em>T2</em> in the output tuple stream.</p>
</li>
</ol>
<p>If neither <em>V1</em> nor <em>V2</em> is <em>greater-than</em>
the other for any pair of orderspecs for tuples <em>T1</em> and
<em>T2</em>, the following rules apply.</p>
<ol class="enumar">
<li>
<p>If <code>stable</code> is specified, the original order of
<em>T1</em> and <em>T2</em> is preserved in the output tuple
stream.</p>
</li>
<li>
<p>If <code>stable</code> is not specified, the order of
<em>T1</em> and <em>T2</em> in the output tuple stream is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If two orderspecs return the special floating-point values
positive and negative zero, neither of these values is
<em>greater-than</em> the other, since <code>+0.0 gt -0.0</code>
and <code>-0.0 gt +0.0</code> are both <code>false</code>.</p>
</div>
<p>Examples:</p>
<ul>
<li>
<p>This example illustrates the effect of an <code>order by</code>
clause on a tuple stream. The keyword <code>stable</code> indicates
that, when two tuples have equal sort keys, their order in the
input tuple stream is preserved.</p>
<p>Input tuple stream:</p>
<div class="exampleInner">
<pre>
($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "KLM030", $make = "Dodge", $value = () )
</pre></div>
<p><code>order by</code> clause:</p>
<div class="exampleInner">
<pre>
stable order by $make,
   $value descending empty least
</pre></div>
<p>Output tuple stream:</p>
<div class="exampleInner">
<pre>
($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "KLM030", $make = "Dodge", $value = () )
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)
</pre></div>
</li>
<li>
<p>The following example shows how an <code>order by</code> clause
can be used to sort the result of a query, even if the sort key is
not included in the query result. This query returns employee names
in descending order by salary, without returning the actual
salaries:</p>
<div class="exampleInner">
<pre>
for $e in $employees
order by $e/salary descending
return $e/name
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since the <code>order by</code> clause in a FLWOR expression is
the only facility provided by XQuery for specifying a value
ordering, a FLWOR expression must be used in some queries where
iteration would not otherwise be necessary. For example, a list of
books with price less than 100 might be obtained by a simple
<a title="path expression" href="#dt-path-expression">path
expression</a> such as <code>$books/book[price &lt; 100]</code>.
But if these books are to be returned in alphabetic order by title,
the query must be expressed as follows:</p>
<div class="exampleInner">
<pre>
for $b in $books/book[price &lt; 100]
order by $b/title
return $b
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-return-clause" id="id-return-clause"></a>3.10.9
Return Clause</h4>
<h5><a name="d2e23053" id="d2e23053"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e20863.doc-xquery30-ReturnClause" id=
"noid_d3e20863.doc-xquery30-ReturnClause"></a>[69]&#160;&#160;&#160;</td>
<td><code>ReturnClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"return" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The <code>return</code> clause is the final clause of a FLWOR
expression. The <code>return</code> clause is evaluated once for
each tuple in its input tuple stream, using the variable bindings
in the respective tuples, in the order in which these tuples appear
in the input tuple stream. The results of these evaluations are
concatenated, as if by the <a title="comma operator" href=
"#dt-comma-operator">comma operator</a>, to form the result of the
FLWOR expression.</p>
<p>The following example illustrates a FLWOR expression containing
several clauses. The <code>for</code> clause iterates over all the
departments in an input document named <code>depts.xml</code>,
binding the variable <code>$d</code> to each department in turn.
For each binding of <code>$d</code>, the <code>let</code> clause
binds variable <code>$e</code> to all the employees in the given
department, selected from another input document named
<code>emps.xml</code> (the relationship between employees and
departments is represented by matching their <code>deptno</code>
values). Each tuple in the resulting tuple stream contains a pair
of bindings for <code>$d</code> and <code>$e</code>
(<code>$d</code> is bound to a department and <code>$e</code> is
bound to a set of employees in that department). The
<code>where</code> clause filters the tuple stream, retaining only
those tuples that represent departments having at least ten
employees. The <code>order by</code> clause orders the surviving
tuples in descending order by the average salary of the employees
in the department. The <code>return</code> clause constructs a new
<code>big-dept</code> element for each surviving tuple, containing
the department number, headcount, and average salary.</p>
<div class="exampleInner">
<pre>
for $d in fn:doc("depts.xml")//dept
let $e := fn:doc("emps.xml")//emp[deptno eq $d/deptno]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d/deptno,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Notes:</b></p>
<ul>
<li>
<p>The order in which items appear in the result of a FLWOR
expression depends on the ordering of the input tuple stream to the
<code>return</code> clause, which in turn is influenced by
<code>order by</code> clauses and by <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a>. For example, consider the
following query, which is based on the same two input documents as
the previous example:</p>
<div class="exampleInner">
<pre>
for $d in fn:doc("depts.xml")//dept
order by $d/deptno
for $e in fn:doc("emps.xml")//emp[deptno eq $d/deptno]
return
   &lt;assignment&gt;
      {$d/deptno, $e/name}
   &lt;/assignment&gt;
</pre></div>
<p>The result of this query is a sequence of
<code>assignment</code> elements, each containing a
<code>deptno</code> element and a <code>name</code> element. The
sequence will be ordered primarily by the <code>deptno</code>
values because of the <code>order by</code> clause. If <a title=
"ordering mode" href="#dt-ordering-mode">ordering mode</a> is
<code>ordered</code>, subsequences of <code>assignment</code>
elements with equal <code>deptno</code> values will be ordered by
the document order of their <code>name</code> elements within the
<code>emps.xml</code> document; otherwise the ordering of these
subsequences will be <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Parentheses are helpful in <code>return</code> clauses that
contain comma operators, since FLWOR expressions have a higher
precedence than the comma operator. For example, the following
query raises an error because after the comma, <code>$j</code> is
no longer within the FLWOR expression, and is an undefined
variable:</p>
<div class="exampleInner">
<pre>
let $i := 5,
    $j := 20 * $i
return $i, $j
</pre></div>
<p>Parentheses can be used to bring <code>$j</code> into the
<code>return</code> clause of the FLWOR expression, as the
programmer probably intended:</p>
<div class="exampleInner">
<pre>
let $i := 5,
    $j := 20 * $i
return ($i, $j)
</pre></div>
</li>
</ul>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-unordered-expressions" id=
"id-unordered-expressions"></a>3.11 Ordered and Unordered
Expressions</h3>
<h5><a name="d2e23208" id="d2e23208"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderedExpr" id=
"doc-xquery30-OrderedExpr"></a>[131]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderedExpr">OrderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#doc-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-UnorderedExpr" id=
"doc-xquery30-UnorderedExpr"></a>[132]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-UnorderedExpr">UnorderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#doc-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>The purpose of <code>ordered</code> and <code>unordered</code>
expressions is to set the <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a> to
<code>ordered</code> or <code>unordered</code> for a certain region
in a query. The specified ordering mode applies to the expression
nested inside the curly braces. For expressions where the ordering
of the result is not significant, a performance advantage may be
realized by setting the ordering mode to <code>unordered</code>,
thereby granting the system flexibility to return the result in the
order that it finds most efficient.</p>
<p><a title="ordering mode" href="#dt-ordering-mode">Ordering
mode</a> affects the behavior of <a title="path expression" href=
"#dt-path-expression">path expressions</a> that include a
"<code>/</code>" or "<code>//</code>" operator or an <a title=
"axis step" href="#dt-axis-step">axis step</a>; <code>union</code>,
<code>intersect</code>, and <code>except</code> expressions; the
<code>fn:id</code>, <span><code>fn:element-with-id</code>,</span>
and <code>fn:idref</code> functions; and certain clauses within a
FLWOR expression. If ordering mode is <code>ordered</code>, node
sequences returned by path expressions, <code>union</code>,
<code>intersect</code>, and <code>except</code> expressions, and
the <code>fn:id</code> and <code>fn:idref</code> functions are in
<a title="document order" href="#dt-document-order">document
order</a>; otherwise the order of these return sequences is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. The
effect of ordering mode on FLWOR expressions is described in
<a href="#id-xquery-for-clause"><b>3.10.2 For Clause</b></a>,
<a href="#id-effects-of-window-clauses"><b>3.10.4.3 Effects of
Window Clauses on the Tuple Stream</b></a>, and <a href=
"#id-group-by"><b>3.10.7 Group By Clause</b></a>. Ordering mode has
no effect on duplicate elimination.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In a region of a query where ordering mode is
<code>unordered</code>, the result of an expression is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> if the
expression invokes certain functions that are affected by the
ordering of node sequences. These functions include
<code>fn:position</code>, <code>fn:last</code>,
<code>fn:index-of</code>, <code>fn:insert-before</code>,
<code>fn:remove</code>, <code>fn:reverse</code>, and
<code>fn:subsequence</code>. <span>The functions
<code>fn:boolean</code> and <code>fn:not</code> are <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> if
ordering mode is <code>unordered</code> and the argument contains
at least one node and at least one atomic value (see <a href=
"#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>).</span> Also,
within a <a title="path expression" href="#dt-path-expression">path
expression</a> in an unordered region, <a title="numeric predicate"
href="#dt-numeric-predicate">numeric predicates</a> are <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. For
example, in an ordered region, the path expression
<code>(//a/b)[5]</code> will return the fifth qualifying
<code>b</code>-element in <a title="document order" href=
"#dt-document-order">document order</a>. In an unordered region,
the same expression will return an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
qualifying <code>b</code>-element.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>fn:id</code> and <code>fn:idref</code> functions are
described in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a> as returning their results in
<a title="document order" href="#dt-document-order">document
order</a>. Since ordering mode is a feature of XQuery, relaxation
of the ordering requirement for function results when ordering mode
is <code>unordered</code> is a feature of XQuery rather than of the
functions themselves.</p>
</div>
<p>The use of an <code>unordered</code> expression is illustrated
by the following example, which joins together two documents named
<code>parts.xml</code> and <code>suppliers.xml</code>. The example
returns the part numbers of red parts, paired with the supplier
numbers of suppliers who supply these parts. If an
<code>unordered</code> expression were not used, the resulting list
of (part number, supplier number) pairs would be required to have
an ordering that is controlled primarily by the <a title=
"document order" href="#dt-document-order">document order</a> of
<code>parts.xml</code> and secondarily by the <a title=
"document order" href="#dt-document-order">document order</a> of
<code>suppliers.xml</code>. However, this might not be the most
efficient way to process the query if the ordering of the result is
not important. An XQuery implementation might be able to process
the query more efficiently by using an index to find the red parts,
or by using <code>suppliers.xml</code> rather than
<code>parts.xml</code> to control the primary ordering of the
result. The <code>unordered</code> expression gives the query
evaluator freedom to make these kinds of optimizations.</p>
<div class="exampleInner">
<pre>
unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}
</pre></div>
<p>In addition to <code>ordered</code> and <code>unordered</code>
expressions, XQuery provides a function named
<code>fn:unordered</code> that operates on any sequence of items
and returns the same sequence in an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> order. A
call to the <code>fn:unordered</code> function may be thought of as
giving permission for the argument expression to be materialized in
whatever order the system finds most efficient. The
<code>fn:unordered</code> function relaxes ordering only for the
sequence that is its immediate operand, whereas an
<code>unordered</code> expression sets the <a title="ordering mode"
href="#dt-ordering-mode">ordering mode</a> for its operand
expression and all nested expressions.</p>
</div>
<div class="div2">
<h3><a name="id-conditionals" id="id-conditionals"></a>3.12
Conditional Expressions</h3>
<p>XQuery 3.0 supports a conditional expression based on the
keywords <code>if</code>, <code>then</code>, and
<code>else</code>.</p>
<h5><a name="d2e23494" id="d2e23494"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-IfExpr" id=
"doc-xquery30-IfExpr"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xquery30-Expr">Expr</a> ")" "then"
<a href="#doc-xquery30-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The expression following the <code>if</code> keyword is called
the <b>test expression</b>, and the expressions following the
<code>then</code> and <code>else</code> keywords are called the
<b>then-expression</b> and <b>else-expression</b>,
respectively.</p>
<p>The first step in processing a conditional expression is to find
the <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of the test expression, as defined in <a href=
"#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.</p>
<p>The value of a conditional expression is defined as follows: If
the effective boolean value of the test expression is
<code>true</code>, the value of the then-expression is returned. If
the effective boolean value of the test expression is
<code>false</code>, the value of the else-expression is
returned.</p>
<p>Conditional expressions have a special rule for propagating
<a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a>. If the effective value of the test expression is
<code>true</code>, the conditional expression ignores (does not
raise) any dynamic errors encountered in the else-expression. In
this case, since the else-expression can have no observable effect,
it need not be evaluated. Similarly, if the effective value of the
test expression is <code>false</code>, the conditional expression
ignores any <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> encountered in the
then-expression, and the then-expression need not be evaluated.</p>
<p>Here are some examples of conditional expressions:</p>
<ul>
<li>
<p>In this example, the test expression is a comparison
expression:</p>
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost)
  then $widget1
  else $widget2
</pre></div>
</li>
<li>
<p>In this example, the test expression tests for the existence of
an attribute named <code>discounted</code>, independently of its
value:</p>
<div class="exampleInner">
<pre>
if ($part/@discounted)
  then $part/wholesale
  else $part/retail
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-switch" id="id-switch"></a>3.13 Switch
Expression</h3>
<h5><a name="d2e23579" id="d2e23579"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SwitchExpr" id=
"doc-xquery30-SwitchExpr"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SwitchExpr">SwitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"switch" "(" <a href="#doc-xquery30-Expr">Expr</a> ")"
<a href="#doc-xquery30-SwitchCaseClause">SwitchCaseClause</a>+
"default" "return" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SwitchCaseClause" id=
"doc-xquery30-SwitchCaseClause"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SwitchCaseClause">SwitchCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" <a href=
"#doc-xquery30-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return"
<a href="#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SwitchCaseOperand" id=
"doc-xquery30-SwitchCaseOperand"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SwitchCaseOperand">SwitchCaseOperand</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The <b>switch expression</b> chooses one of several expressions
to evaluate based on the input value.</p>
<p>In a <code>switch</code> expression, the <code>switch</code>
keyword is followed by an expression enclosed in parentheses,
called the <b>switch operand expression</b>. This is the expression
whose value is being compared. The remainder of the
<code>switch</code> expression consists of one or more
<code>case</code> clauses, with one or more <code>case operand
expressions</code> each, and a <code>default</code> clause.</p>
<p>The first step in evaluating a switch expression is to apply
atomization to the value of the switch operand expression. If the
result is a sequence of length greater than one, a type error is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<p>The resulting value is matched against each <a href=
"#doc-xquery30-SwitchCaseOperand">SwitchCaseOperand</a> in turn
until a match is found or the list is exhausted. The matching is
performed as follows:</p>
<ol class="enumar">
<li>
<p>The <a href=
"#doc-xquery30-SwitchCaseOperand">SwitchCaseOperand</a> is
evaluated.</p>
</li>
<li>
<p>The resulting value is atomized.</p>
</li>
<li>
<p>If the atomized sequence has length greater than one, a type
error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>The atomized value of the switch operand expression is compared
with the atomized value of the <a href=
"#doc-xquery30-SwitchCaseOperand">SwitchCaseOperand</a> using the
<code>fn:deep-equal</code> function, with the default collation
from the static context.</p>
</li>
</ol>
<p>[<a name="id-effective-case-switch-expression" id=
"id-effective-case-switch-expression" title=
"effective case">Definition</a>: The <b>effective case</b> of a
switch expression is the first case clause that matches, using the
rules given above, or the default clause if no such case clause
exists.] The value of the switch expression is the value of the
return expression in the effective case.</p>
<p>Switch expressions have rules regarding the propagation of
dynamic errors that take precedence over the general rules given in
<a href="#id-errors-and-opt"><b>2.3.4 Errors and
Optimization</b></a>. The return clauses of a switch expression
must not raise any dynamic errors except in the effective case.
Dynamic errors raised in the operand expressions of the switch or
the case clauses are propagated; however, an implementation must
not raise dynamic errors in the operand expressions of case clauses
that occur after the effective case. An implementation is permitted
to raise dynamic errors in the operand expressions of case clauses
that occur before the effective case, but not required to do
so.</p>
<p>The following example shows how a switch expression might be
used:</p>
<div class="exampleInner">
<pre>
switch ($animal)
   case "Cow" return "Moo"
   case "Cat" return "Meow"
   case "Duck" return "Quack"
   default return "What's that odd noise?"
 
</pre></div>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>3.14 Quantified Expressions</h3>
<p>Quantified expressions support existential and universal
quantification. The value of a quantified expression is always
<code>true</code> or <code>false</code>.</p>
<h5><a name="d2e23703" id="d2e23703"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-QuantifiedExpr" id=
"doc-xquery30-QuantifiedExpr"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e21450.doc-xquery30-TypeDeclaration" id=
"noid_d3e21450.doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>quantified expression</b> begins with a <b>quantifier</b>,
which is the keyword <code>some</code> or <code>every</code>,
followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test
expression. Each in-clause associates a variable with an expression
that returns a sequence of items, called the binding sequence for
that variable. The in-clauses generate tuples of variable bindings,
including a tuple for each combination of items in the binding
sequences of the respective variables. Conceptually, the test
expression is evaluated for each tuple of variable bindings.
Results depend on the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of the test expressions, as
defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean
Value</b></a>. The value of the quantified expression is defined by
the following rules:</p>
<ol class="enumar">
<li>
<p>If the quantifier is <code>some</code>, the quantified
expression is <code>true</code> if at least one evaluation of the
test expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>false</code>.</p>
</li>
<li>
<p>If the quantifier is <code>every</code>, the quantified
expression is <code>true</code> if every evaluation of the test
expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>true</code>.</p>
</li>
</ol>
<p>The scope of a variable bound in a quantified expression
comprises all subexpressions of the quantified expression that
appear after the variable binding. The scope does not include the
expression to which the variable is bound.</p>
<p class="xquery">Each variable bound in an in-clause of a
quantified expression may have an optional <a href=
"#doc-xquery30-TypeDeclaration">type declaration</a>. If the type
of a value bound to the variable does not match the declared type
according to the rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>The order in which test expressions are evaluated for the
various binding tuples is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. If the
quantifier is <code>some</code>, an implementation may return
<code>true</code> as soon as it finds one binding tuple for which
the test expression has an <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of <code>true</code>, and it
may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> as soon as it finds one
binding tuple for which the test expression raises an error.
Similarly, if the quantifier is <code>every</code>, an
implementation may return <code>false</code> as soon as it finds
one binding tuple for which the test expression has an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of <code>false</code>, and it may raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon
as it finds one binding tuple for which the test expression raises
an error. As a result of these rules, the value of a quantified
expression is not deterministic in the presence of errors, as
illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ul>
<li>
<p>This expression is <code>true</code> if every <code>part</code>
element has a <code>discounted</code> attribute (regardless of the
values of these attributes):</p>
<div class="exampleInner">
<pre>
every $part in /parts/part satisfies $part/@discounted
</pre></div>
</li>
<li>
<p>This expression is <code>true</code> if at least one
<code>employee</code> element satisfies the given comparison
expression:</p>
<div class="exampleInner">
<pre>
some $emp in /emps/employee satisfies
     ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</li>
<li>
<p>In the following examples, each quantified expression evaluates
its test expression over nine tuples of variable bindings, formed
from the Cartesian product of the sequences <code>(1, 2, 3)</code>
and <code>(2, 3, 4)</code>. The expression beginning with
<code>some</code> evaluates to <code>true</code>, and the
expression beginning with <code>every</code> evaluates to
<code>false</code>.</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4
</pre></div>
<div class="exampleInner">
<pre>
every $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4
</pre></div>
</li>
<li>
<p>This quantified expression may either return <code>true</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>true</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>This quantified expression may either return <code>false</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>false</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>This quantified expression contains a <a href=
"#doc-xquery30-TypeDeclaration">type declaration</a> that is not
satisfied by every item in the test expression. If the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a> is implemented, this expression raises a
<a title="type error" href="#dt-type-error">type error</a> during
the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. Otherwise, the
expression may either return <code>true</code> or raise a <a title=
"type error" href="#dt-type-error">type error</a> during the
<a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>.</p>
<div class="exampleInner">
<pre>
some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-try-catch" id="id-try-catch"></a>3.15 Try/Catch
Expressions</h3>
<p>The try/catch expression provides error handling for dynamic
errors and type errors raised during dynamic evaluation, including
errors raised by the XQuery implementation and errors explicitly
raised in a query using the <code>fn:error()</code> function.</p>
<h5><a name="d2e23983" id="d2e23983"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TryCatchExpr" id=
"doc-xquery30-TryCatchExpr"></a>[78]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TryCatchExpr">TryCatchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-TryClause">TryClause</a> <a href=
"#doc-xquery30-CatchClause">CatchClause</a>+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TryClause" id=
"doc-xquery30-TryClause"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TryClause">TryClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"try" "{" <a href=
"#doc-xquery30-TryTargetExpr">TryTargetExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TryTargetExpr" id=
"doc-xquery30-TryTargetExpr"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TryTargetExpr">TryTargetExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CatchClause" id=
"doc-xquery30-CatchClause"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CatchClause">CatchClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"catch" <a href=
"#doc-xquery30-CatchErrorList">CatchErrorList</a> "{" <a href=
"#doc-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CatchErrorList" id=
"doc-xquery30-CatchErrorList"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CatchErrorList">CatchErrorList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NameTest">NameTest</a> ("|"
<a href="#doc-xquery30-NameTest">NameTest</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A try/catch expression catches <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> and <a title="type error"
href="#dt-type-error">type errors</a> raised by the evaluation of
the target expression of the <code>try</code> clause. If the target
expression does not raise a dynamic error or a type error, the
result of the try/catch expression is the result of the target
expression.</p>
<p>If the target expression raises a dynamic error or a type error,
the result of the try/catch expression is obtained by evaluating
the first <code>catch</code> clause that "matches" the error value,
as described below. <span>If no catch clause "matches" the error
value, then the try/catch expression raises the error that was
raised by the target expression.</span> A <code>catch</code> clause
with one or more NameTests matches any error whose error code
matches one of these NameTests. For instance, if the error code is
<code>err:FOER0000</code>, then it matches a <code>catch</code>
clause whose ErrorList is <code>err:FOER0000 | err:FOER0001</code>.
Wildcards may be used in NameTests; thus, the error code
<code>err:FOER0000</code> also matches a <code>catch</code> clause
whose ErrorList is <code>err:*</code> or <code>*:FOER0000</code> or
<code>*</code>.</p>
<p>Within the scope of the <code>catch</code> clause, a number of
variables are implicitly declared, giving information about the
error that occurred. These variables are initialized as described
in the following table:</p>
<table border="1" cellpadding="5">
<thead>
<tr>
<th align="left" colspan="1">Variable</th>
<th align="left" colspan="1">Type</th>
<th align="left" colspan="1">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">err:code</td>
<td valign="top">xs:QName</td>
<td valign="top">The error code</td>
</tr>
<tr>
<td valign="top">err:description</td>
<td valign="top">xs:string<span>?</span></td>
<td valign="top">A description of the error condition; <span>an
empty sequence if no description is available (for example, if the
<code>error</code> function was called with one
argument)</span>.</td>
</tr>
<tr>
<td valign="top">err:value</td>
<td valign="top">item()*</td>
<td valign="top">Value associated with the error. For an error
raised by calling the <code>error</code> function, this is the
value of the third argument (if supplied).</td>
</tr>
<tr>
<td valign="top">err:module</td>
<td valign="top">xs:string?</td>
<td valign="top">The URI (or system ID) of the module containing
the <span>expression</span> where the error occurred, or an empty
sequence if the information is not available.</td>
</tr>
<tr>
<td valign="top">err:line-number</td>
<td valign="top">xs:integer?</td>
<td valign="top">The line number within the stylesheet module of
the instruction where the error occurred, or an empty sequence if
the information is not available. The value <strong>may</strong> be
approximate.</td>
</tr>
<tr>
<td valign="top">err:column-number</td>
<td valign="top">xs:integer?</td>
<td valign="top">The column number within the stylesheet module of
the instruction where the error occurred, or an empty sequence if
the information is not available. The value <strong>may</strong> be
approximate.</td>
</tr>
<tr>
<td valign="top">err:additional</td>
<td valign="top">item()*</td>
<td valign="top"><a title="implementation defined" href=
"#dt-implementation-defined">Implementation-defined</a>. This
variable must be bound so that a query can reference it without
raising an error. The purpose of this variable is to allow
implementations to provide any additional information that might be
useful.</td>
</tr>
</tbody>
</table>
<p>Try/catch expressions have a special rule for propagating
dynamic errors. The try/catch expression ignores any dynamic errors
encountered in catch clauses other than the first catch clause that
matches an error raised by the try clause, and these catch clause
expressions need not be evaluated.</p>
<p>Static errors are not caught by the try/catch expression.</p>
<p>If a function call occurs within a <code>try</code> clause,
errors raised by evaluating the corresponding function are caught
by the try/catch expression. If a variable reference is used in a
<code>try</code> clause, errors raised by binding a value to the
variable are not caught unless the binding expression occurs within
the <code>try</code> clause.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The presence of a try/catch expression does not prevent an
implementation from using a lazy evaluation strategy, nor does it
prevent an optimizer performing expression rewrites. However, if
the evaluation of an expression inside a try/catch is rewritten or
deferred in this way, it must take its try/catch context with it.
Similarly, expressions that were written outside the try/catch
expression may be evaluated inside the try/catch, but only if they
retain their original try/catch behavior. The presence of a
try/catch does not change the rules that allow the processor to
evaluate expressions in such a way that may avoid the detection of
some errors.</p>
</div>
<p>Here are some examples of try/catch expressions.</p>
<ul>
<li>
<p>A try/catch expression without a CatchErrorList catches any
error:</p>
<div class="exampleInner">
<pre>
try {
    $x cast as xs:integer
}
catch * {
    0
}
</pre></div>
</li>
<li>
<p>The CatchErrorList in this try/catch expression specifies that
only <code>err:FORG0001</code> is caught:</p>
<div class="exampleInner">
<pre>
try {
    $x cast as xs:integer
}
catch err:FORG0001 {
    0
}
</pre></div>
</li>
<li>
<p>The CatchErrorList in this try/catch expression specifies that
errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are
caught:</p>
<div class="exampleInner">
<pre>
try {
    $x cast as xs:integer
}
catch err:FORG0001 | err:XPTY0004 {
    0
}
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some implementations, <code>err:XPTY0004</code> is detected
during static evaluation; it can only be caught if it is raised
during dynamic evaluation.</p>
</div>
</li>
<li>
<p>This try/catch expression shows how to return information about
the error using implicitly defined error variables. Since the
CatchErrorList is a wildcard, it catches any error:</p>
<div class="exampleInner">
<pre>
try {
    fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
}
catch * {
    $err:code, $err:value, " module: ",
    $err:module, "(", $err:line-number, ",", $err:column-number, ")"
}
</pre></div>
</li>
<li>
<p>Errors raised by using the result of a try/catch expression are
not caught, since they are outside the scope of the
<code>try</code> expression.</p>
<div class="exampleInner">
<pre>
declare function local:thrice($x as xs:integer) as xs:integer
{
    3*$x
};

local:thrice(try { "oops" } catch * { 3 } )
</pre></div>
<p>In this example, the try block succeeds, returning the string
"oops", which is not a valid argument to the function.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-expressions-on-datatypes" id=
"id-expressions-on-datatypes"></a>3.16 Expressions on
SequenceTypes</h3>
<p><span class="xquery">In addition to their use in function
parameters and results,</span> <a title="sequence type" href=
"#dt-sequence-type">sequence types</a> are used in <code>instance
of</code>, <span class="xquery"><code>typeswitch</code>,</span>
<code>cast</code>, <code>castable</code>, and <code>treat</code>
expressions.</p>
<div class="div3">
<h4><a name="id-instance-of" id="id-instance-of"></a>3.16.1
Instance Of</h4>
<h5><a name="d2e24275" id="d2e24275"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-InstanceofExpr" id=
"doc-xquery30-InstanceofExpr"></a>[92]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#doc-xquery30-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>The boolean operator <code>instance of</code> returns
<code>true</code> if the value of its first operand matches the
<a href="#doc-xquery30-SequenceType">SequenceType</a> in its second
operand, according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>; otherwise it
returns <code>false</code>. For example:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>This example returns <code>true</code> because the given value
is an instance of the given type.</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>This example returns <code>true</code> because the given value
is an integer literal, and <code>xs:integer</code> is derived by
restriction from <code>xs:decimal</code>.</p>
</li>
<li>
<p><code>&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code></p>
<p>This example returns <code>false</code> because the given value
is an element rather than an integer.</p>
</li>
<li>
<p><code>(5, 6) instance of xs:integer+</code></p>
<p>This example returns <code>true</code> because the given
sequence contains two integers, and is a valid instance of the
specified type.</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>This example returns <code>true</code> if the context item is an
element node or <code>false</code> if the context item is defined
but is not an element node. If the context item is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>,
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-typeswitch" id="id-typeswitch"></a>3.16.2
Typeswitch</h4>
<h5><a name="d2e24384" id="d2e24384"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TypeswitchExpr" id=
"doc-xquery30-TypeswitchExpr"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypeswitchExpr">TypeswitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#doc-xquery30-Expr">Expr</a>
")" <a href="#doc-xquery30-CaseClause">CaseClause</a>+ "default"
("$" <a href="#doc-xquery30-VarName">VarName</a>)? "return"
<a href="#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CaseClause" id=
"doc-xquery30-CaseClause"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CaseClause">CaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" ("$" <a href="#doc-xquery30-VarName">VarName</a>
"as")? <a href=
"#doc-xquery30-SequenceTypeUnion">SequenceTypeUnion</a> "return"
<a href="#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SequenceTypeUnion" id=
"doc-xquery30-SequenceTypeUnion"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SequenceTypeUnion">SequenceTypeUnion</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-SequenceType">SequenceType</a>
("|" <a href=
"#doc-xquery30-SequenceType">SequenceType</a>)*</code></td>
</tr>
</tbody>
</table>
<p class="xquery">The <b>typeswitch</b> expression chooses one of
several expressions to evaluate based on the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of an input
value.</p>
<p class="xquery">In a <code>typeswitch</code> expression, the
<code>typeswitch</code> keyword is followed by an expression
enclosed in parentheses, called the <b>operand expression</b>. This
is the expression whose type is being tested. The remainder of the
<code>typeswitch</code> expression consists of one or more
<code>case</code> clauses and a <code>default</code> clause.</p>
<p class="xquery">Each <code>case</code> clause specifies one or
more <a href="#doc-xquery30-SequenceType">SequenceType</a>s
followed by a <code>return</code> expression. [<a name=
"dt-effective-case" id="dt-effective-case" title=
"effective case">Definition</a>: The <b>effective case</b> in a
<code>typeswitch</code> expression is the first <code>case</code>
clause in which the value of the operand expression matches a
<a href="#doc-xquery30-SequenceType">SequenceType</a> in the
<a href="#doc-xquery30-SequenceType">SequenceTypeUnion</a> of the
<code>case</code> clause, using the rules of <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>. ] The value
of the <code>typeswitch</code> expression is the value of the
<code>return</code> expression in the effective case. If the value
of the operand expression does not match any <a href=
"#doc-xquery30-SequenceType">SequenceType</a> named in a
<code>case</code> clause, the value of the <code>typeswitch</code>
expression is the value of the <code>return</code> expression in
the <code>default</code> clause.</p>
<p>In a <code>case</code> or <code>default</code> clause, if the
value to be returned depends on the value of the operand
expression, the clause must specify a variable name. Within the
<code>return</code> expression of the <code>case</code> or
<code>default</code> clause, this variable name is bound to the
value of the operand expression. Inside a <code>case</code> clause,
the <a title="static type" href="#dt-static-type">static type</a>
of the variable is the union of the <a href=
"#doc-xquery30-SequenceType">SequenceType</a>s named in the
<a href="#doc-xquery30-SequenceType">SequenceTypeUnion</a>. Inside
a <code>default</code> clause, the static type of the variable is
the same as the static type of the operand expression. If the value
to be returned by a <code>case</code> or <code>default</code>
clause does not depend on the value of the operand expression, the
clause need not specify a variable.</p>
<p>The scope of a variable binding in a <code>case</code> or
<code>default</code> clause comprises that clause. It is not an
error for more than one <code>case</code> or <code>default</code>
clause in the same <code>typeswitch</code> expression to bind
variables with the same name.</p>
<p>A special rule applies to propagation of <a title=
"dynamic error" href="#dt-dynamic-error">dynamic errors</a> by
<code>typeswitch</code> expressions. A <code>typeswitch</code>
expression ignores (does not raise) any dynamic errors encountered
in <code>case</code> clauses other than the <a title=
"effective case" href="#dt-effective-case">effective case</a>.
Dynamic errors encountered in the <code>default</code> clause are
raised only if there is no <a title="effective case" href=
"#dt-effective-case">effective case</a>. An implementation is
permitted to raise dynamic errors in the operand expressions of
case clauses that occur before the <a title="effective case" href=
"#dt-effective-case">effective case</a>, but not required to do
so.</p>
<p class="xquery">The following example shows how a
<code>typeswitch</code> expression might be used to process an
expression in a way that depends on its <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>.</p>
<div class="exampleInner">
<pre>
typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"
</pre></div>
<p>The following example shows a union of sequence types in a
single case:</p>
<div class="exampleInner">
<pre>
typeswitch($customer/billing-address)
   case $a as element(*, USAddress)
            | element(*, AustraliaAddress)
            | element(*, MexicoAddress)
     return $a/state
   case $a as element(*, CanadaAddress)
     return $a/province
   case $a as element(*, JapanAddress)
     return $a/prefecture
   default
     return "unknown"
</pre></div>
</div>
<div class="div3">
<h4><a name="id-cast" id="id-cast"></a>3.16.3 Cast</h4>
<h5><a name="d2e24617" id="d2e24617"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CastExpr" id=
"doc-xquery30-CastExpr"></a>[95]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SingleType" id=
"doc-xquery30-SingleType"></a>[166]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SimpleTypeName">SimpleTypeName</a> "?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e22239.doc-xquery30-AtomicOrUnionType" id=
"noid_d3e22239.doc-xquery30-AtomicOrUnionType"></a>[171]&#160;&#160;&#160;</td>
<td><code>AtomicOrUnionType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>Occasionally it is necessary to convert a value to a specific
datatype. For this purpose, XQuery 3.0 provides a <code>cast</code>
expression that creates a new value of a specific type based on an
existing value. A <code>cast</code> expression takes two operands:
an <b>input expression</b> and a <b>target type</b>. The type of
the <span>atomized value of the</span> input expression is called
the <b>input type</b>. <span>The SimpleTypeName must be the name of
a type defined in the <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a>, and <span>it must be a
simple type</span> [<a href="#ERRXQST0052" title=
"err:XQST0052">err:XQST0052</a>].</span> In addition, the target
type cannot be <code>xs:NOTATION</code> <span>,
<code>xs:anySimpleType</code>,</span> or
<code>xs:anyAtomicType</code> [<a href="#ERRXPST0080" title=
"err:XPST0080">err:XPST0080</a>]. The optional occurrence indicator
"<code>?</code>" denotes that an empty sequence is permitted. If
the target type <span>is a lexical QName that</span> has no
namespace prefix, it is considered to be in the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a>.</p>
<p>Casting a node to <code>xs:QName</code> <span>can cause
surprises because it uses</span> the static context of the cast
expression to provide the namespace bindings for this operation.
Instead <span>of casting to <code>xs:QName</code>, it is generally
preferable to</span> use the <code>fn:QName</code> function, which
allows the namespace context to be taken from the document
containing the QName.</p>
<p>The semantics of the <code>cast</code> expression are as
follows:</p>
<ol class="enumar">
<li>
<p>The input expression is evaluated.</p>
</li>
<li>
<p>The result of the first step is <a title="atomization" href=
"#dt-atomization">atomized</a>.</p>
</li>
<li>
<p>If the result of atomization is a sequence of more than one
atomic value, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the result of atomization is an empty sequence:</p>
<ol class="enumla">
<li>
<p>If <code>?</code> is specified after the target type, the result
of the <code>cast</code> expression is an empty sequence.</p>
</li>
<li>
<p>If <code>?</code> is not specified after the target type, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is a single atomic value, the
result of the cast expression depends on the input type and the
target type. In general, the cast expression attempts to create a
new value of the target type based on the input value. Only certain
combinations of input type and target type are supported. A summary
of the rules are listed below—the normative definition of these
rules is given in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>. For the purpose of these rules,
an implementation may determine that one type is derived by
restriction from another type either by examining the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a> or by using an alternative, <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism such as a data dictionary.</p>
<ol class="enumla">
<li>
<p><code>cast</code> is supported for the combinations of input
type and target type listed in <a href=
"http://www.w3.org/TR/xpath-functions-30/#casting-from-primitive-to-primitive">
Section 18.1 Casting from primitive types to primitive types</a>
<sup><small>FO30</small></sup>. For each of these combinations,
both the input type and the target type are primitive <a title=
"schema type" href="#dt-schema-type">schema types</a>. For example,
a value of type <code>xs:string</code> can be cast into the schema
type <code>xs:decimal</code>. For each of these built-in
combinations, the semantics of casting are specified in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported if the input type is a
non-primitive atomic type that is derived by restriction from the
target type. In this case, the input value is mapped into the value
space of the target type, unchanged except for its type. For
example, if <code>shoesize</code> is derived by restriction from
<code>xs:integer</code>, a value of type <code>shoesize</code> can
be cast into the schema type <code>xs:integer</code>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type and the input type is
<code>xs:string</code> or <code>xs:untypedAtomic</code>. The input
value is first converted to a value in the lexical space of the
target type by applying the whitespace normalization rules for the
target type (as defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>). The
lexical value is then converted to the value space of the target
type using the schema-defined rules for the target type. If the
input value fails to satisfy some facet of the target type, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
may be raised as specified in <a href="#xpath-functions-30">[XQuery
and XPath Functions and Operators 3.0]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported to any target type if the input
type is <code>xs:string</code> or <code>xs:untypedAtomic</code>.
The target type may be an atomic type, a union type, or a list
type. The semantics are based on the rules for validation in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a>.</p>
<p>The effect of casting a string <var>S</var> to a simple type
<var>T</var> is the same as constructing an element or attribute
node whose string value is <var>S</var>, validating it using
<var>T</var> as the governing type, and atomizing the resulting
node. The result may be a single atomic value or (if list types are
involved) a sequence of zero or more atomic values.</p>
<p>If the target type is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, then the
namespace bindings in the static context will be used to resolve
any namespace prefix found in the supplied string.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type that is derived by restriction from the
input type. The input value must satisfy all the facets of the
target type (in the case of the pattern facet, this is checked by
generating a string representation of the input value, using the
rules for casting to <code>xs:string</code>). The resulting value
is the same as the input value, but with a different <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p>
</li>
<li>
<p>If a primitive type P1 can be cast into a primitive type P2,
then any type derived by restriction from P1 can be cast into any
type derived by restriction from P2, provided that the facets of
the target type are satisfied. First the input value is cast to P1
using rule (b) above. Next, the value of type P1 is cast to the
type P2, using rule (a) above. Finally, the value of type P2 is
cast to the target type, using rule (d) above.</p>
</li>
<li>
<p>For any combination of input type and target type that is not in
the above list, a <code>cast</code> expression raises a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
</ol>
<p>If casting from the input type to the target type is supported
but nevertheless it is not possible to cast the input value into
the value space of the target type, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> is raised.
[err:FORG0001] This includes the case when any facet of the target
type is not satisfied. For example, the expression
<code>"2003-02-31" cast as xs:date</code> would raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="div3">
<h4><a name="id-castable" id="id-castable"></a>3.16.4 Castable</h4>
<h5><a name="d2e24954" id="d2e24954"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CastableExpr" id=
"doc-xquery30-CastableExpr"></a>[94]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-CastExpr">CastExpr</a> (
"castable" "as" <a href="#doc-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e22551.doc-xquery30-SingleType" id=
"noid_d3e22551.doc-xquery30-SingleType"></a>[166]&#160;&#160;&#160;</td>
<td><code>SingleType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SimpleTypeName">SimpleTypeName</a> "?"?</code></td>
</tr>
</tbody>
</table>
<p>XQuery 3.0 provides an expression that tests whether a given
value is castable into a given target type. <span>The
SimpleTypeName must be the name of a type defined in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, and the type must be <code>simple</code> [<a href=
"#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>].</span> In
addition, the target type cannot be <code>xs:NOTATION</code>
<span><code>xs:anySimpleType</code>,</span> or
<code>xs:anyAtomicType</code> [<a href="#ERRXPST0080" title=
"err:XPST0080">err:XPST0080</a>]. The optional occurrence indicator
"<code>?</code>" denotes that an empty sequence is permitted.</p>
<p>The expression <code>E castable as T</code> returns
<code>true</code> if the result of evaluating <code>E</code> can be
successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. If evaluation of <code>E</code> fails with a
dynamic error, the <code>castable</code> expression as a whole
fails. The <code>castable</code> expression can be used as a
<a title="" href="#dt-predicate">predicate</a> to avoid errors at
evaluation time. It can also be used to select an appropriate type
for processing of a given value, as illustrated in the following
example:</p>
<div class="exampleInner">
<pre>
if ($x castable as hatsize)
   then $x cast as hatsize
   else if ($x castable as IQ)
   then $x cast as IQ
   else $x cast as xs:string
</pre></div>
</div>
<div class="div3">
<h4><a name="id-constructor-functions" id=
"id-constructor-functions"></a>3.16.5 Constructor Functions</h4>
<p>For every <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> (except <code>xs:NOTATION</code> and
<code>xs:anyAtomicType</code>, which are not instantiable), a
<b>constructor function</b> is implicitly defined. In each case,
the name of the constructor function is the same as the name of its
target type (including namespace). The signature of the constructor
function for type <em>T</em> is as follows:</p>
<div class="exampleInner">
<pre>
T($arg as xs:anyAtomicType?) as T?
</pre></div>
<p>[<a name="dt-constructor-function" id="dt-constructor-function"
title="constructor function">Definition</a>: The <b>constructor
function</b> for a given type is used to convert instances of other
atomic types into the given type. The semantics of the constructor
function call <code>T($arg)</code> are defined to be equivalent to
the expression <code>(($arg) cast as T?)</code>.]</p>
<p>The following examples illustrate the use of constructor
functions:</p>
<ul>
<li>
<p>This example is equivalent to <code>("2000-01-01" cast as
xs:date?)</code>.</p>
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</li>
<li>
<p>This example is equivalent to <code>(($floatvalue * 0.2E-5) cast
as xs:decimal?)</code>.</p>
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</li>
<li>
<p>This example returns an <code>xs:dayTimeDuration</code> value
equal to 21 days. It is equivalent to <code>("P21D" cast as
xs:dayTimeDuration?)</code>.</p>
<div class="exampleInner">
<pre>
xs:dayTimeDuration("P21D")
</pre></div>
</li>
<li>
<p>If <code>usa:zipcode</code> is a user-defined atomic type in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, then the following expression is equivalent to the
expression <code>("12345" cast as usa:zipcode?)</code>.</p>
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An instance of an atomic type that is not in a namespace can be
constructed in either of the following ways:</p>
<ul>
<li>
<p>By using a <code>cast</code> expression, if the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
<span class="xquery">(See <a href="#id-default-namespace"><b>4.14
Default Namespace Declaration</b></a> for how to undeclare the
<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type
namespace</a>).</span></p>
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</li>
<li>
<p>By using a constructor function, if the <a title=
"default function namespace" href="#dt-def-fn-ns">default function
namespace</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
<span class="xquery">(See <a href="#id-default-namespace"><b>4.14
Default Namespace Declaration</b></a> for how to undeclare the
<a title="default function namespace" href="#dt-def-fn-ns">default
function namespace</a>).</span></p>
<div class="exampleInner">
<pre>
apple(17)
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-treat" id="id-treat"></a>3.16.6 Treat</h4>
<h5><a name="d2e25188" id="d2e25188"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-TreatExpr" id=
"doc-xquery30-TreatExpr"></a>[93]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xquery30-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>XQuery 3.0 provides an expression called <code>treat</code> that
can be used to modify the <a title="static type" href=
"#dt-static-type">static type</a> of its operand.</p>
<p>Like <code>cast</code>, the <code>treat</code> expression takes
two operands: an expression and a <a href=
"#doc-xquery30-SequenceType">SequenceType</a>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> or
value of its operand. Instead, the purpose of <code>treat</code> is
to ensure that an expression has an expected dynamic type at
evaluation time.</p>
<p>The semantics of <em><code>expr1</code></em> <code>treat
as</code> <em><code>type1</code></em> are as follows:</p>
<ul>
<li>
<p>During static analysis:</p>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of the <code>treat</code> expression is
<em><code>type1</code></em> . This enables the expression to be
used as an argument of a function that requires a parameter of
<em><code>type1</code></em> .</p>
</li>
<li>
<p>During expression evaluation:</p>
<p>If <em><code>expr1</code></em> matches
<em><code>type1</code></em> , using the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>, the
<code>treat</code> expression returns the value of
<em><code>expr1</code></em> ; otherwise, it raises a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>
[<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>]. If
the value of <em><code>expr1</code></em> is returned, its identity
is preserved. The <code>treat</code> expression ensures that the
value of its expression operand conforms to the expected type at
run-time.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of <code>$myaddress</code> may be <code>element(*,
Address)</code>, a less specific type than <code>element(*,
USAddress)</code>. However, at run-time, the value of
<code>$myaddress</code> must match the type <code>element(*,
USAddress)</code> using rules for <a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType matching</a>;
otherwise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-map-operator" id="id-map-operator"></a>3.17 Simple
map operator (<code>!</code>)</h3>
<h5><a name="d2e25358" id="d2e25358"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SimpleMapExpr" id=
"doc-xquery30-SimpleMapExpr"></a>[106]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SimpleMapExpr">SimpleMapExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PathExpr">PathExpr</a> ("!"
<a href="#doc-xquery30-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>The simple map operator "<code>!</code>" is used for simple
mappings. Both its left-hand side expression and its
right-hand-side expression may return a mixed sequence of nodes and
non-nodes.</p>
<p>Each operation <code>E1!E2</code> is evaluated as follows:
Expression <code>E1</code> is evaluated to a sequence
<code>S</code>. Each item in <code>S</code> then serves in turn to
provide an inner focus (the item as the context item, its position
in <code>S</code> as the context position, the length of
<code>S</code> as the context size) for an evaluation of
<code>E2</code> in the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a>. The sequences resulting
from all the evaluations of <code>E2</code> are combined as
follows: Every evaluation of <code>E2</code> returns a (possibly
empty) sequence of items. These sequences are concatenated and
returned. If ordering mode is ordered, the returned sequence
preserves the orderings within and among the subsequences generated
by the evaluations of <code>E2</code>; otherwise the order of the
returned sequence is implementation-dependent.</p>
<p>Simple map operators have functionality similar to <a href=
"#id-path-operator"><b>3.3.1.1 Path operator (/)</b></a>. The
following table summarizes the differences between these two
operators</p>
<table border="1">
<thead>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Path operator (<code>E1 / E2</code>)</th>
<th colspan="1">Simple map operator (<code>E1 ! E2</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1">E1</th>
<td>Any sequence of nodes</td>
<td>Any sequence of items</td>
</tr>
<tr>
<th colspan="1">E2</th>
<td>Either a sequence of nodes or a sequence of non-node items</td>
<td>A sequence of items</td>
</tr>
<tr>
<th colspan="1">Additional processing</th>
<td>Duplicate elimination and document ordering</td>
<td>Simple sequence concatenation</td>
</tr>
</tbody>
</table>
<p>The following examples illustrate the use of simple map
operators combined with path expressions.</p>
<div class="exampleOuter">
<ul>
<li>
<p><code>child::div1 / child::para / string() ! concat("id-",
.)</code></p>
<p>Selects the <code>para</code> element children of the
<code>div1</code> element children of the context node; that is,
the <code>para</code> element grandchildren of the context node
that have <code>div1</code> parents. It then outputs the strings
obtained by prepending <code>"id-"</code> to each of the string
values of these grandchildren.</p>
</li>
<li>
<p><code>$emp ! (@first, @middle, @last)</code></p>
<p>Returns the values of the attributes <code>first</code>,
<code>middle</code>, and <code>last</code> for element
<code>$emp</code>, in the order given. (The <code>/</code> operator
here returns the attributes in an unpredictable order.)</p>
</li>
<li>
<p><code>$docs ! ( //employee)</code></p>
<p>Returns all the employees within all the documents identified by
the variable docs, in document order within each document, but
retaining the order of documents.</p>
</li>
<li>
<p><code>avg( //employee / salary ! translate(., '$', '') !
number(.))</code></p>
<p>Returns the average salary of the employees, having converted
the salary to a number by removing any <code>$</code> sign and then
converting to a number. (The second occurrence of <code>!</code>
could not be written as <code>/</code> because the left-hand
operand of <code>/</code> cannot be an atomic value.)</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-validate" id="id-validate"></a>3.18 Validate
Expressions</h3>
<h5><a name="d2e25534" id="d2e25534"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ValidateExpr" id=
"doc-xquery30-ValidateExpr"></a>[101]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ValidateExpr">ValidateExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" (<a href=
"#doc-xquery30-ValidationMode">ValidationMode</a> | ("type"
<a href="#doc-xquery30-TypeName">TypeName</a>))? "{" <a href=
"#doc-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ValidationMode" id=
"doc-xquery30-ValidationMode"></a>[102]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ValidationMode">ValidationMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
</table>
<p>A <code>validate</code> expression can be used to validate a
document node or an element node with respect to the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, using the schema validation process defined in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a>. If the operand of a
<code>validate</code> expression does not evaluate to exactly one
document or element node, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0030"
title="err:XQTY0030">err:XQTY0030</a>]. In this specification, the
node that is the operand of a <code>validate</code> expression is
called the <b>operand node</b>.</p>
<p>A <code>validate</code> expression returns a new node with its
own identity and with no parent. The new node and its descendants
are given <a title="type annotation" href=
"#dt-type-annotation">type annotation</a> that are generated by
applying a validation process to the operand node. In some cases,
default values may also be generated by the validation process.</p>
<p>A <code>validate</code> expression may optionally specify a
<a href="#doc-xquery30-ValidationMode">validation mode</a>. The
default <a href="#doc-xquery30-ValidationMode">validation mode</a>
<span>(applicable when no type name is provided)</span> is
<code>strict</code>.</p>
<p>A <code>validate</code> expression may optionally specify a
<a href="#doc-xquery30-TypeName">TypeName</a>. This type name must
be found in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>; if it is not, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0104" title=
"err:XQST0104">err:XQST0104</a>]. If the type name is unprefixed,
it is interpreted as a name in the default namespace for elements
and types.</p>
<p>The result of a <code>validate</code> expression is defined by
the following rules.</p>
<ol class="enumar">
<li>
<p>If the operand node is a document node, its children must
consist of exactly one element node and zero or more comment and
processing instruction nodes, in any order; otherwise, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>
[<a href="#ERRXQDY0061" title="err:XQDY0061">err:XQDY0061</a>] is
raised.</p>
</li>
<li>
<p>The operand node is converted to an XML Information Set
(<a href="#XINFO">[XML Infoset]</a>) according to the "Infoset
Mapping" rules defined in <a href="#xpath-datamodel-30">[XQuery and
XPath Data Model (XDM) 3.0]</a>. Note that this process discards
any existing <a title="type annotation" href=
"#dt-type-annotation">type annotations</a>. <span>Validity
assessment is carried out on the root element information item of
the resulting Infoset, using the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a> as the effective schema. The process of validation
applies recursively to contained elements and attributes to the
extent required by the effective schema.</span></p>
</li>
<li>
<p>If a type name is provided, <span>and the type name is
<code>xs:untyped</code>, all elements receive the type annotation
<code>xs:untyped</code>, and all attributes receive the type
annotation <code>xs:untypedAtomic</code>. If the type name is
<code>xs:untypedAtomic</code>, the node receives the type
annotation xs:untypedAtomic; a type error [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>] is raised if the node has
element children</span>. Otherwise, schema-validity assessment is
carried out according to the rules defined in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> Part 1, section 3.3.4 "Element Declaration
Validation Rules", "Validation Rule: Schema-Validity Assessment
(Element)", clauses 1.2 and 2, using this type definition as the
"processor-stipulated type definition" for validation.</p>
</li>
<li>
<p><span>When no type name is provided:</span></p>
<ol class="enumla">
<li>
<p>If <a href="#doc-xquery30-ValidationMode">validation mode</a> is
<code>strict</code>, then there must be a top-level element
declaration in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a> that matches the
root element information item in the Infoset, and schema-validity
assessment is carried out using that declaration in accordance with
<a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2,
"Assessing Schema-Validity", item 2, or <a href="#XMLSchema11">[XML
Schema 1.1]</a> Part 1, section 5.2, "Assessing Schema-Validity",
"element-driven validation". If there is no such element
declaration, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXQDY0084" title="err:XQDY0084">err:XQDY0084</a>].</p>
</li>
<li>
<p>If <a href="#doc-xquery30-ValidationMode">validation mode</a> is
<code>lax</code>, then schema-validity assessment is carried out in
accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1,
section 5.2, "Assessing Schema-Validity", item 3, or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, "Assessing
Schema-Validity", "lax wildcard validation".</p>
<p>If <a href="#doc-xquery30-ValidationMode">validation mode</a> is
<code>lax</code> and the root element information item has neither
a top-level element declaration nor an <code>xsi:type</code>
attribute, <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> defines the recursive checking
of children and attributes as optional. During processing of an
XQuery <code>validate</code> expression, this recursive checking is
required.</p>
</li>
<li>
<p>If the operand node is an element node, the validation rules
named "Validation Root Valid (ID/IDREF)" are not applied. This
means that document-level constraints relating to uniqueness and
referential integrity are not enforced.</p>
</li>
<li>
<p>There is no check that the document contains unparsed entities
whose names match the values of nodes of type
<code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Validity assessment is affected by the presence or absence of
<code>xsi:type</code> attributes on the elements being validated,
and may generate new information items such as default
attributes.</p>
</div>
</li>
<li>
<p><span>The outcome of the validation expression depends on
the</span> <code>validity</code> property of the root element
information item in the PSVI that results from the validation
process.</p>
<ol class="enumla">
<li>
<p>If the <code>validity</code> property of the root element
information item is <code>valid</code>, or if <a href=
"#doc-xquery30-ValidationMode">validation mode</a> is
<code>lax</code> and the <code>validity</code> property of the root
element information item is <code>notKnown</code>, the PSVI is
converted back into an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> as described in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>
Section 3.3, "Construction from a PSVI". The resulting node (a new
node of the same kind as the operand node) is returned as the
result of the <code>validate</code> expression.</p>
</li>
<li>
<p>Otherwise, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXQDY0027" title="err:XQDY0027">err:XQDY0027</a>].</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of these rules is as follows, where <span>the
<em>validated element</em> means either the operand node or (if the
operand node is a document node) its element child.</span>:</p>
<ul>
<li>
<p>If <a href="#doc-xquery30-ValidationMode">validation mode</a> is
<code>strict</code>, the validated element must have a top-level
element declaration in the effective schema, and must conform to
this declaration.</p>
</li>
<li>
<p>If <a href="#doc-xquery30-ValidationMode">validation mode</a> is
<code>lax</code>, the validated element must conform to its
top-level element declaration if such a declaration exists in the
effective schema. If <a href=
"#doc-xquery30-ValidationMode">validation mode</a> is
<code>lax</code> and there is no top-level element declaration for
the element, and the element has an <code>xsi:type</code>
attribute, then the <code>xsi:type</code> attribute must name a
top-level type definition in the effective schema, and the element
must conform to that type.</p>
</li>
<li>
<p><span>If a type name is specified in the validate expression, no
attempt is made to locate an element declaration matching the name
of the validated element; the element can have any name, and its
content is validated against the named type.</span></p>
</li>
</ul>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>During conversion of the PSVI into an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a> after validation,
any element information items whose validity property is
<code>notKnown</code> are converted into element nodes with
<a title="type annotation" href="#dt-type-annotation">type
annotation</a> <code>xs:anyType</code>, and any attribute
information items whose validity property is <code>notKnown</code>
are converted into attribute nodes with <a title="type annotation"
href="#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>, as described in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#PSVI2NodeTypes">Section
3.3.1.1 Element and Attribute Node Types</a>
<sup><small>DM30</small></sup>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-extension-expressions" id=
"id-extension-expressions"></a>3.19 Extension Expressions</h3>
<p>[<a name="dt-extension-expression" id="dt-extension-expression"
title="extension expression">Definition</a>: An <b>extension
expression</b> is an expression whose semantics are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.] Typically
a particular extension will be recognized by some implementations
and not by others. The syntax is designed so that extension
expressions can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that
do not recognize a particular extension.</p>
<h5><a name="d2e25905" id="d2e25905"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ExtensionExpr" id=
"doc-xquery30-ExtensionExpr"></a>[103]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExtensionExpr">ExtensionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Pragma">Pragma</a>+ "{" <a href=
"#doc-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Pragma" id=
"doc-xquery30-Pragma"></a>[104]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Pragma">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xquery30-S">S</a>? <a href=
"#doc-xquery30-EQName">EQName</a> (<a href="#prod-xquery30-S">S</a>
<a href="#doc-xquery30-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PragmaContents" id=
"doc-xquery30-PragmaContents"></a>[105]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PragmaContents">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
</table>
<p>An extension expression consists of one or more <b>pragmas</b>,
followed by an expression enclosed in curly braces. [<a name=
"dt-pragma" id="dt-pragma" title="pragma">Definition</a>: A
<b>pragma</b> is denoted by the delimiters <code>(#</code> and
<code>#)</code>, and consists of an identifying EQName followed by
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> content.]
The content of a pragma may consist of any string of characters
that does not contain the ending delimiter <code>#)</code>. If the
EQName of a pragma is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a>, it must resolve to a namespace URI
and local name, using the <a title="statically known namespaces"
href="#dt-static-namespaces">statically known namespaces</a>
[<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since there is no default namespace for pragmas, a pragma's
EQName must provide a <span><a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a></span> or a
namespace prefix.</p>
</div>
<p>Each implementation recognizes an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs used to denote pragmas.</p>
<p>If the namespace URI of a pragma's <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> is not recognized by
the implementation as a pragma namespace, then the pragma is
ignored. If all the pragmas in an <a href=
"#doc-xquery30-ExtensionExpr">ExtensionExpr</a> are ignored, then
the value of the <a href=
"#doc-xquery30-ExtensionExpr">ExtensionExpr</a> is the value of the
expression enclosed in curly braces; if this expression is absent,
then a <a title="static error" href="#dt-static-error">static
error</a> is raised [<a href="#ERRXQST0079" title=
"err:XQST0079">err:XQST0079</a>].</p>
<p>If an implementation recognizes the namespace of one or more
pragmas in an <a href=
"#doc-xquery30-ExtensionExpr">ExtensionExpr</a>, then the value of
the <a href="#doc-xquery30-ExtensionExpr">ExtensionExpr</a>,
including its error behavior, is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>. For
example, an implementation that recognizes the namespace of a
pragma's <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a>, but does not recognize the
local part of the name, might choose either to raise an error or to
ignore the pragma.</p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXQST0013" title=
"err:XQST0013">err:XQST0013</a>] if an implementation recognizes a
pragma but determines that its content is invalid.</p>
<p>If an implementation recognizes a pragma, it must report any
static errors in the following expression even if it will not
evaluate that expression (however, static type errors are raised
only if the <a title="static typing feature" href=
"#dt-static-typing-feature">Static Typing Feature</a> is in
effect.)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The following examples illustrate three ways in which extension
expressions might be used.</p>
<ul>
<li>
<p>A pragma can be used to furnish a hint for how to evaluate the
following expression, without actually changing the result. For
example:</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</pre></div>
<p>An implementation that recognizes the <code>exq:use-index</code>
pragma might use an index to evaluate the expression that follows.
An implementation that does not recognize this pragma would
evaluate the expression in its normal way.</p>
</li>
<li>
<p>A pragma might be used to modify the semantics of the following
expression in ways that would not (in the absence of the pragma) be
conformant with this specification. For example, a pragma might be
used to permit comparison of <code>xs:duration</code> values using
implementation-defined semantics (this would normally be an error).
Such changes to the language semantics must be scoped to the
expression contained within the curly braces following the
pragma.</p>
</li>
<li>
<p>A pragma might contain syntactic constructs that are evaluated
in place of the following expression. In this case, the following
expression itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</pre></div>
<p>Here an implementation that recognizes the pragma will return
the result of evaluating the proprietary syntax <code>exq:distinct
//city by @country</code>, while an implementation that does not
recognize the pragma will instead return the result of the
expression <code>//city[not(@country =
preceding::city/@country)]</code>. If no fallback expression is
required, or if none is feasible, then the expression between the
curly braces may be omitted, in which case implementations that do
not recognize the pragma will raise a <a title="static error" href=
"#dt-static-error">static error</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-query-prolog" id="id-query-prolog"></a>4 Modules
and Prologs</h2>
<h5><a name="d2e26076" id="d2e26076"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Module" id=
"doc-xquery30-Module"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Module">Module</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-VersionDecl">VersionDecl</a>?
(<a href="#doc-xquery30-LibraryModule">LibraryModule</a> | <a href=
"#doc-xquery30-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-MainModule" id=
"doc-xquery30-MainModule"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-MainModule">MainModule</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Prolog">Prolog</a> <a href=
"#doc-xquery30-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-LibraryModule" id=
"doc-xquery30-LibraryModule"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-LibraryModule">LibraryModule</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ModuleDecl">ModuleDecl</a>
<a href="#doc-xquery30-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Prolog" id=
"doc-xquery30-Prolog"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Prolog">Prolog</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href=
"#doc-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#doc-xquery30-Setter">Setter</a> | <a href=
"#doc-xquery30-NamespaceDecl">NamespaceDecl</a> | <a href=
"#doc-xquery30-Import">Import</a>) <a href=
"#doc-xquery30-Separator">Separator</a>)* ((<a href=
"#prod-xquery30-ContextItemDecl">ContextItemDecl</a> | <a href=
"#doc-xquery30-AnnotatedDecl">AnnotatedDecl</a> | <a href=
"#doc-xquery30-OptionDecl">OptionDecl</a>) <a href=
"#doc-xquery30-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Setter" id=
"doc-xquery30-Setter"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Setter">Setter</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#doc-xquery30-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#doc-xquery30-BaseURIDecl">BaseURIDecl</a> | <a href=
"#doc-xquery30-ConstructionDecl">ConstructionDecl</a> | <a href=
"#doc-xquery30-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#doc-xquery30-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#doc-xquery30-CopyNamespacesDecl">CopyNamespacesDecl</a> |
<a href="#doc-xquery30-DecimalFormatDecl">DecimalFormatDecl</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Import" id=
"doc-xquery30-Import"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Import">Import</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-SchemaImport">SchemaImport</a> |
<a href="#doc-xquery30-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Separator" id=
"doc-xquery30-Separator"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Separator">Separator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-QueryBody" id=
"doc-xquery30-QueryBody"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QueryBody">QueryBody</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>A query can be assembled from one or more fragments called
<b>modules</b>. [<a name="dt-module" id="dt-module" title=
"module">Definition</a>: A <b>module</b> is a fragment of XQuery
code that conforms to the <a href="#doc-xquery30-Module">Module</a>
grammar and can independently undergo the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> described in <a href="#id-expression-processing"><b>2.2.3
Expression Processing</b></a>. Each module is either a <a title=
"main module" href="#dt-main-module">main module</a> or a <a title=
"library module" href="#dt-library-module">library module</a>.]</p>
<p>[<a name="dt-main-module" id="dt-main-module" title=
"main module">Definition</a>: A <b>main module</b> consists of a
<a title="Prolog" href="#dt-prolog">Prolog</a> followed by a
<a title="query body" href="#dt-queryBody">Query Body</a>.] A query
has exactly one main module. In a main module, the <a title=
"query body" href="#dt-queryBody">Query Body</a> can be evaluated.
<span>It is evaluated with respect to the static and dynamic
contexts of the main module in which it is found, and its value is
the result of the query.</span></p>
<p>[<a name="dt-library-module" id="dt-library-module" title=
"library module">Definition</a>: A module that does not contain a
<a title="query body" href="#dt-queryBody">Query Body</a> is called
a <b>library module</b>. A library module consists of a <a title=
"module declaration" href="#dt-module-declaration">module
declaration</a> followed by a <a title="Prolog" href=
"#dt-prolog">Prolog</a>.] A library module cannot be evaluated
directly; instead, it provides function and variable declarations
that can be imported into other modules.</p>
<p>The XQuery syntax does not allow a <a title="module" href=
"#dt-module">module</a> to contain both a <a title=
"module declaration" href="#dt-module-declaration">module
declaration</a> and a <a title="query body" href=
"#dt-queryBody">Query Body</a>.</p>
<p>[<a name="dt-prolog" id="dt-prolog" title=
"Prolog">Definition</a>: A <b>Prolog</b> is a series of
declarations and imports that define the processing environment for
the <a title="module" href="#dt-module">module</a> that contains
the Prolog.] Each declaration or import is followed by a semicolon.
A Prolog is organized into two parts.</p>
<p>The first part of the Prolog consists of setters, imports,
namespace declarations, and default namespace declarations.
[<a name="dt-setter" id="dt-setter" title="setter">Definition</a>:
<b>Setters</b> are declarations that set the value of some property
that affects query processing, such as construction mode, ordering
mode, or default collation.] Namespace declarations and default
namespace declarations affect the interpretation of <a title=
"lexical QName" href="#dt-qname">lexical QNames</a> within the
query. Imports are used to import definitions from schemas and
modules. [<a name="dt-target-namespace" id="dt-target-namespace"
title="target namespace">Definition</a>: <span>The <b>target
namespace</b> of a module is the namespace of the objects (such as
elements or functions) that it defines.</span> ]</p>
<p>The second part of the Prolog consists of declarations of
variables, functions, and options. These declarations appear at the
end of the Prolog because they may be affected by declarations and
imports in the first part of the Prolog.</p>
<p>[<a name="dt-queryBody" id="dt-queryBody" title=
"query body">Definition</a>: The <b>Query Body</b>, if present,
consists of an expression that defines the result of the query.]
Evaluation of expressions is described in <a href=
"#id-expressions"><b>3 Expressions</b></a>. A module can be
evaluated only if it has a Query Body.</p>
<div class="div2">
<h3><a name="id-version-declaration" id=
"id-version-declaration"></a>4.1 Version Declaration</h3>
<h5><a name="d2e26330" id="d2e26330"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VersionDecl" id=
"doc-xquery30-VersionDecl"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-VersionDecl">VersionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"xquery" (("encoding" <a href=
"#doc-xquery30-StringLiteral">StringLiteral</a>) | ("version"
<a href="#doc-xquery30-StringLiteral">StringLiteral</a> ("encoding"
<a href="#doc-xquery30-StringLiteral">StringLiteral</a>)?))
<a href="#doc-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-version-declaration" id="dt-version-declaration"
title="version declaration">Definition</a>: A <b>version
declaration</b> can identify the applicable XQuery syntax and
semantics for a <a title="module" href="#dt-module">module</a>, as
well as its encoding.] The version number "1.0" indicates the
intent that the module be processed by an <a title=
"XQuery 1.0 Processor" href="#dt-xquery-10-processor">XQuery 1.0
processor</a>; the version number "3.0" indicates the intent that
the module be processed by an <a title="XQuery 3.0 Processor" href=
"#dt-xquery-30-processor">XQuery 3.0 processor</a>. If the version
declaration is not present or the version is not included in the
declaration, an XQuery 3.0 processor assumes a version of "3.0". If
an XQuery 3.0 processor processes a module labeled with a version
of "1.0", it must do one of the following:</p>
<ul>
<li>
<p>Process the module using the specification of the XQuery version
identified in the version declaration.</p>
</li>
<li>
<p>Process the module using the specification of XQuery 3.0.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation may issue a warning in this case.</p>
</div>
</li>
<li>
<p>Raise a static error [<a href="#ERRXQST0031" title=
"err:XQST0031">err:XQST0031</a>]</p>
</li>
</ul>
<p>A processor may raise an error [<a href="#ERRXQST0034" title=
"err:XQST0034">err:XQST0034</a>] if the modules of a query do not
have the same version number.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In general, this should be done only if a processor is not able
to evaluate such a query.</p>
</div>
<p>[<a name="dt-encoding-declaration" id="dt-encoding-declaration"
title="encoding declaration">Definition</a>: If present, a version
declaration may optionally include an <b>encoding declaration</b>.
The value of the string literal following the keyword
<code>encoding</code> is an encoding name, and must conform to the
definition of <code>EncName</code> specified in <a href="#XML">[XML
1.0]</a> [<a href="#ERRXQST0087" title=
"err:XQST0087">err:XQST0087</a>]. The purpose of an encoding
declaration is to allow the writer of a query to provide a string
that indicates how the query is encoded, such as
"<code>UTF-8</code>", "<code>UTF-16</code>", or
"<code>US-ASCII</code>".] Since the encoding of a query may change
as the query moves from one environment to another, there can be no
guarantee that the encoding declaration is correct.</p>
<p>The handling of an encoding declaration is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. If an
implementation has <em>a priori</em> knowledge of the encoding of a
query, it may use this knowledge and disregard the encoding
declaration. The semantics of a query are not affected by the
presence or absence of an encoding declaration.</p>
<p>If a version declaration is present, no <a href=
"#doc-xquery30-Comment">Comment</a> may occur before the end of the
version declaration. If such a <a href=
"#doc-xquery30-Comment">Comment</a> is present, the result is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> <span>;
an implementation may raise an implementation-dependent static
error, or ignore the comment</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of a Comment before the end of a version declaration
is implementation-dependent because it may suppress query
processing by interfering with detection of the encoding
declaration.</p>
</div>
<p>The following examples illustrate version declarations:</p>
<div class="exampleInner">
<pre>
xquery version "1.0";
</pre></div>
<div class="exampleInner">
<pre>
xquery version "3.0" encoding "utf-8";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-module-declaration" id=
"id-module-declaration"></a>4.2 Module Declaration</h3>
<h5><a name="d2e26453" id="d2e26453"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ModuleDecl" id=
"doc-xquery30-ModuleDecl"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ModuleDecl">ModuleDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#doc-xquery30-URILiteral">URILiteral</a> <a href=
"#doc-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-module-declaration" id="dt-module-declaration"
title="module declaration">Definition</a>: A <b>module
declaration</b> serves to identify a <a title="module" href=
"#dt-module">module</a> as a <a title="library module" href=
"#dt-library-module">library module</a>. A module declaration
begins with the keyword <code>module</code> and contains a
namespace prefix and a <a href=
"#doc-xquery30-URILiteral">URILiteral</a>.] The URILiteral must be
of nonzero length [<a href="#ERRXQST0088" title=
"err:XQST0088">err:XQST0088</a>]. The URILiteral identifies the
<a title="target namespace" href="#dt-target-namespace">target
namespace</a> of the library module, which is the namespace for all
variables and functions exported by the library module. The name of
every variable and function declared in a library module must have
a namespace URI that is the same as the target namespace of the
module; otherwise a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXQST0048" title="err:XQST0048">err:XQST0048</a>]. <span>The
(prefix,URI) pair is added to the set of <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</span></p>
<p>The namespace prefix specified in a module declaration must not
be <code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070"
title="err:XQST0070">err:XQST0070</a>], and must not be the same as
any namespace prefix bound in the same module by a <a title=
"schema import" href="#dt-schema-import">schema import</a>, by a
<a title="namespace declaration" href=
"#dt-namespace-declaration">namespace declaration</a>, or by a
<a title="module import" href="#dt-module-import">module import</a>
with a different target namespace [<a href="#ERRXQST0033" title=
"err:XQST0033">err:XQST0033</a>].</p>
<p>Any <a title="module" href="#dt-module">module</a> may import
one or more library modules by means of a <a title="module import"
href="#dt-module-import">module import</a> that specifies the
target namespace of the library modules to be imported. When a
module imports one or more library modules, the variables and
functions declared in the imported modules are added to the
<a title="static context" href="#dt-static-context">static
context</a> and (where applicable) to the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a> of
the importing module.</p>
<p>The following is an example of a module declaration:</p>
<div class="exampleInner">
<pre>
module namespace gis = "http://example.org/gis-functions";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-boundary-space-decls" id=
"id-boundary-space-decls"></a>4.3 Boundary-space Declaration</h3>
<h5><a name="d2e26552" id="d2e26552"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-BoundarySpaceDecl" id=
"doc-xquery30-BoundarySpaceDecl"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BoundarySpaceDecl">BoundarySpaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-boundary-space-decl" id="dt-boundary-space-decl"
title="boundary-space declaration">Definition</a>: A
<b>boundary-space declaration</b> sets the <a title=
"boundary-space policy" href=
"#dt-boundary-space-policy">boundary-space policy</a> in the
<a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.
Boundary-space policy controls whether <a title=
"boundary whitespace" href="#dt-boundary-whitespace">boundary
whitespace</a> is preserved by element constructors during
processing of the query.] If boundary-space policy is
<code>preserve</code>, boundary whitespace is preserved. If
boundary-space policy is <code>strip</code>, boundary whitespace is
stripped (deleted). A further discussion of whitespace in
constructed elements can be found in <a href=
"#id-whitespace"><b>3.9.1.4 Boundary Whitespace</b></a>.</p>
<p>The following example illustrates a boundary-space
declaration:</p>
<div class="exampleInner">
<pre>
declare boundary-space preserve;
</pre></div>
<p>If a Prolog contains more than one boundary-space declaration, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0068" title=
"err:XQST0068">err:XQST0068</a>].</p>
</div>
<div class="div2">
<h3><a name="id-default-collation-declaration" id=
"id-default-collation-declaration"></a>4.4 Default Collation
Declaration</h3>
<h5><a name="d2e26599" id="d2e26599"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DefaultCollationDecl" id=
"doc-xquery30-DefaultCollationDecl"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DefaultCollationDecl">DefaultCollationDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#doc-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-default-collation-decl" id=
"dt-default-collation-decl" title=
"default collation declaration">Definition</a>: A <b>default
collation declaration</b> sets the value of the <a title=
"default collation" href="#dt-def-collation">default collation</a>
in the <a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.] The
default collation is the collation that is used by functions and
operators that require a collation if no other collation is
specified. For example, the <code>gt</code> operator on strings is
defined by a call to the <code>fn:compare</code> function, which
takes an optional collation parameter. Since the <code>gt</code>
operator does not specify a collation, the <code>fn:compare</code>
function implements <code>gt</code> by using the default
collation.</p>
<p>If neither the implementation nor the Prolog specifies a default
collation, the Unicode codepoint collation
(<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
is used.</p>
<p>The following example illustrates a default collation
declaration:</p>
<div class="exampleInner">
<pre>
declare default collation
  "http://example.org/languages/Icelandic";
</pre></div>
<p>If a default collation declaration specifies a collation by a
relative URI, that relative URI is <a title="resolve" href=
"#dt-resolve-relative-uri">resolved to an absolute URI</a> using
the <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a>.</span> If a Prolog
contains more than one default collation declaration, or the value
specified by a default collation declaration (after resolution of a
relative URI, if necessary) is not present in <a title=
"statically known collations" href=
"#dt-static-collations">statically known collations</a>, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0038" title=
"err:XQST0038">err:XQST0038</a>].</p>
</div>
<div class="div2">
<h3><a name="id-base-uri-decl" id="id-base-uri-decl"></a>4.5 Base
URI Declaration</h3>
<h5><a name="d2e26675" id="d2e26675"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-BaseURIDecl" id=
"doc-xquery30-BaseURIDecl"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BaseURIDecl">BaseURIDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#doc-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-base-uri-decl" id="dt-base-uri-decl" title=
"base URI declaration">Definition</a>: A <b>base URI
declaration</b> specifies the <span><a title="Static Base URI"
href="#dt-static-base-uri">Static Base URI</a> property. The
<a title="Static Base URI" href="#dt-static-base-uri">Static Base
URI</a> property is used when resolving relative URI
references.</span> ] <span>For example, the <a title=
"Static Base URI" href="#dt-static-base-uri">Static Base URI</a>
property is used when resolving relative references for <a title=
"module import" href="#dt-module-import">module import</a> and for
the <code>fn:doc</code> function.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As discussed in the definition of <a title="Static Base URI"
href="#dt-static-base-uri">Static Base URI</a>, if there is no base
URI declaration, or if the value of the declaration is a relative
URI reference, then the value of the Static Base URI may depend on
the location of the query, and it is permissible for this to vary
between the static analysis phase and the dynamic evaluation
phase.</p>
</div>
<p>The following is an example of a base URI declaration:</p>
<div class="exampleInner">
<pre>
declare base-uri "http://example.org";
</pre></div>
<p>If a Prolog contains more than one base URI declaration, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0032" title=
"err:XQST0032">err:XQST0032</a>].</p>
<p>In the terminology of <a href="#RFC3986">[RFC3986]</a> Section
5.1, the URILiteral of the base URI declaration is considered to be
a "base URI embedded in content". If no base URI declaration is
present, <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a> property</span> is
established according to the principles outlined in <a href=
"#RFC3986">[RFC3986]</a> Section 5.1—that is, it defaults first to
the base URI of the encapsulating entity, then to the URI used to
retrieve the entity, and finally to an implementation-defined
default. If the URILiteral in the base URI declaration is a
relative URI, then it is made absolute by resolving it with respect
to this same hierarchy. For example, if the URILiteral in the base
URI declaration is <code>../data/</code>, and the query is
contained in a file whose URI is
<code>file:///C:/temp/queries/query.xq</code>, then the
<span><a title="Static Base URI" href="#dt-static-base-uri">Static
Base URI</a> property</span> is
<code>file:///C:/temp/data/</code>.</p>
<p>It is not intrinsically an error if this process fails to
establish an absolute base URI; however, the <span><a title=
"Static Base URI" href="#dt-static-base-uri">Static Base URI</a>
property</span> is then <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>
[<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>].
When the <span><a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a> property</span> is
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>,
any attempt to use its value to <a title="resolve" href=
"#dt-resolve-relative-uri">resolve a relative URI reference</a>
will result in an error [<a href="#ERRXPST0001" title=
"err:XPST0001">err:XPST0001</a>].</p>
</div>
<div class="div2">
<h3><a name="id-construction-declaration" id=
"id-construction-declaration"></a>4.6 Construction Declaration</h3>
<h5><a name="d2e26856" id="d2e26856"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ConstructionDecl" id=
"doc-xquery30-ConstructionDecl"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ConstructionDecl">ConstructionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-construction-decl" id="dt-construction-decl" title=
"construction declaration">Definition</a>: A <b>construction
declaration</b> sets the <a title="construction mode" href=
"#dt-construction-mode">construction mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a>,
overriding any implementation-defined default.] The construction
mode governs the behavior of element and document node
constructors. If construction mode is <code>preserve</code>, the
type of a constructed element node is <code>xs:anyType</code>, and
all attribute and element nodes copied during node construction
retain their original types. If construction mode is
<code>strip</code>, the type of a constructed element node is
<code>xs:untyped</code>; all element nodes copied during node
construction receive the type <code>xs:untyped</code>, and all
attribute nodes copied during node construction receive the type
<code>xs:untypedAtomic</code>.</p>
<p>The following example illustrates a construction
declaration:</p>
<div class="exampleInner">
<pre>
declare construction strip;
</pre></div>
<p>If a Prolog specifies more than one construction declaration, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0067" title=
"err:XQST0067">err:XQST0067</a>].</p>
</div>
<div class="div2">
<h3><a name="id-default-ordering-decl" id=
"id-default-ordering-decl"></a>4.7 Ordering Mode Declaration</h3>
<h5><a name="d2e26911" id="d2e26911"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OrderingModeDecl" id=
"doc-xquery30-OrderingModeDecl"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OrderingModeDecl">OrderingModeDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ordering-mode-decl" id="dt-ordering-mode-decl"
title="ordering mode declaration">Definition</a>: An <b>ordering
mode declaration</b> sets the <a title="ordering mode" href=
"#dt-ordering-mode">ordering mode</a> in the <a title=
"static context" href="#dt-static-context">static context</a>,
overriding any implementation-defined default.] This ordering mode
applies to all expressions in a <a title="module" href=
"#dt-module">module</a> (including both the <a title="Prolog" href=
"#dt-prolog">Prolog</a> and the <a title="query body" href=
"#dt-queryBody">Query Body</a>, if any), unless overridden by an
<code>ordered</code> or <code>unordered</code> expression.</p>
<p>The following example illustrates an ordering mode
declaration:</p>
<div class="exampleInner">
<pre>
declare ordering unordered;
</pre></div>
<p>If a Prolog contains more than one ordering mode declaration, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0065" title=
"err:XQST0065">err:XQST0065</a>].</p>
</div>
<div class="div2">
<h3><a name="id-empty-order-decl" id="id-empty-order-decl"></a>4.8
Empty Order Declaration</h3>
<h5><a name="d2e27014" id="d2e27014"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-EmptyOrderDecl" id=
"doc-xquery30-EmptyOrderDecl"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EmptyOrderDecl">EmptyOrderDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-empty-order-decl" id="dt-empty-order-decl" title=
"empty order declaration">Definition</a>: An <b>empty order
declaration</b> sets the <a title=
"default order for empty sequences" href=
"#dt-default-empty-order">default order for empty sequences</a> in
the <a title="static context" href="#dt-static-context">static
context,</a> overriding any implementation-defined default. This
declaration controls the processing of empty sequences and
<code>NaN</code> values as ordering keys in an <code>order
by</code> clause in a FLWOR expression.] An individual <code>order
by</code> clause may override the default order for empty sequences
by specifying <code>empty greatest</code> or <code>empty
least</code>.</p>
<p>The following example illustrates an empty order
declaration:</p>
<div class="exampleInner">
<pre>
declare default order empty least;
</pre></div>
<p>If a Prolog contains more than one empty order declaration, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXQST0069" title=
"err:XQST0069">err:XQST0069</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is important to distinguish an <a title=
"empty order declaration" href="#dt-empty-order-decl">empty order
declaration</a> from an <a title="ordering mode declaration" href=
"#dt-ordering-mode-decl">ordering mode declaration</a>. An
<a title="empty order declaration" href=
"#dt-empty-order-decl">empty order declaration</a> applies only
when an <code>order by</code> clause is present, and specifies how
empty sequences are treated by the <code>order by</code> clause
(unless overridden). An <a title="ordering mode declaration" href=
"#dt-ordering-mode-decl">ordering mode declaration</a>, on the
other hand, applies only in the absence of an <code>order by</code>
clause.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-copy-namespaces-decl" id=
"id-copy-namespaces-decl"></a>4.9 Copy-Namespaces Declaration</h3>
<h5><a name="d2e27090" id="d2e27090"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-CopyNamespacesDecl" id=
"doc-xquery30-CopyNamespacesDecl"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#doc-xquery30-PreserveMode">PreserveMode</a> "," <a href=
"#doc-xquery30-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PreserveMode" id=
"doc-xquery30-PreserveMode"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PreserveMode">PreserveMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-InheritMode" id=
"doc-xquery30-InheritMode"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InheritMode">InheritMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-copy-namespaces-decl" id="dt-copy-namespaces-decl"
title="copy-namespaces declaration">Definition</a>: A
<b>copy-namespaces declaration</b> sets the value of <a title=
"copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> in the
<a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.
Copy-namespaces mode controls the namespace bindings that are
assigned when an existing element node is copied by an element
constructor or document constructor.] Handling of namespace
bindings by element constructors is described in <a href=
"#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>.</p>
<p>The following example illustrates a copy-namespaces
declaration:</p>
<div class="exampleInner">
<pre>
declare copy-namespaces preserve, no-inherit;
</pre></div>
<p>If a Prolog contains more than one copy-namespaces declaration,
a <a title="static error" href="#dt-static-error">static error</a>
is raised [<a href="#ERRXQST0055" title=
"err:XQST0055">err:XQST0055</a>].</p>
</div>
<div class="div2">
<h3><a name="id-decimal-format-decl" id=
"id-decimal-format-decl"></a>4.10 Decimal Format Declaration</h3>
<h5><a name="d2e27144" id="d2e27144"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DecimalFormatDecl" id=
"doc-xquery30-DecimalFormatDecl"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DecimalFormatDecl">DecimalFormatDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" (("decimal-format" <a href=
"#doc-xquery30-EQName">EQName</a>) | ("default" "decimal-format"))
(<a href="#doc-xquery30-DFPropertyName">DFPropertyName</a> "="
<a href=
"#doc-xquery30-StringLiteral">StringLiteral</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DFPropertyName" id=
"doc-xquery30-DFPropertyName"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DFPropertyName">DFPropertyName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"decimal-separator" | "grouping-separator" | "infinity" |
"minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" |
"digit" | "pattern-separator"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-decimal-format-decl" id="dt-decimal-format-decl"
title="decimal-format declaration">Definition</a>: A <b>decimal
format declaration</b> adds a decimal format to the <a title=
"statically known decimal formats" href=
"#dt-static-decimal-formats">statically known decimal formats</a>,
which define the properties used to format numbers using the
<code>fn:format-number()</code> function], as described in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>. The mapping between these properties and the equivalent
<code>fn:format-number()</code> properties is discussed in
<a title="statically known decimal formats" href=
"#dt-static-decimal-formats">statically known decimal formats</a>,
which also specifies the defaults for each value. If a format
declares no properties, default values are used for all
properties.</p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> for a query prolog to contain two decimal format
declarations with the same name, or to contain two default decimal
format declarations [<a href="#ERRXQST0111" title=
"err:XQST0111">err:XQST0111</a>]. It is a <a title="static error"
href="#dt-static-error">static error</a> for a decimal format
declaration to define the same property more than once [<a href=
"#ERRXQST0114" title="err:XQST0114">err:XQST0114</a>]. It is a
<a title="static error" href="#dt-static-error">static error</a>
for a decimal format declaration to specify a value that is not
valid for a given property, as described in <a title=
"statically known decimal formats" href=
"#dt-static-decimal-formats">statically known decimal formats</a>
[<a href="#ERRXQST0097" title="err:XQST0097">err:XQST0097</a>]. It
is a <a title="static error" href="#dt-static-error">static
error</a> if, for any named or unnamed decimal format, the
properties representing characters used in a picture string do not
have distinct values [<a href="#ERRXQST0098" title=
"err:XQST0098">err:XQST0098</a>]. The following properties
represent characters used in a picture string: <a title=
"decimal-separator" href=
"#id-static-decimal-separator">decimal-separator-sign</a>,
<a title="grouping-separator" href=
"#id-static-decimal-format-grouping-separator">grouping-separator</a>,
<a title="percent-sign" href=
"#id-static-decimal-format-percent-sign">percent-sign</a>,
<a title="per-mille-sign" href=
"#id-static-decimal-format-per-mille-sign">per-mille-sign</a>,
<a title="zero-digit" href=
"#id-static-decimal-format-zero-digit">zero-digit</a>, <a title=
"digit-sign" href=
"#id-static-decimal-format-digit-sign">digit-sign</a>, and
<a title="pattern-separator-sign" href=
"#id-static-decimal-format-pattern-separator-sign">pattern-separator-sign</a>
.</p>
<div class="exampleOuter">
<p>The following query formats numbers using two different decimal
format declarations:</p>
<div class="exampleInner">
<pre>
declare decimal-format local:de decimal-separator = "," grouping-separator = ".";
declare decimal-format local:en decimal-separator = "." grouping-separator = ",";

let $numbers := (1234.567, 789, 1234567.765)
for $i in $numbers
return (
  format-number($i, "#.###,##", "local:de"),
  format-number($i, "#,###.##", "local:en")
)
</pre></div>
<p>The output of this query is:</p>
<div class="exampleInner">
<pre>
1.234,57 1,234.57 789 789 1.234.567,76 1,234,567.76
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-schema-import" id="id-schema-import"></a>4.11
Schema Import</h3>
<h5><a name="d2e27248" id="d2e27248"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SchemaImport" id=
"doc-xquery30-SchemaImport"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SchemaImport">SchemaImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#doc-xquery30-SchemaPrefix">SchemaPrefix</a>? <a href=
"#doc-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-SchemaPrefix" id=
"doc-xquery30-SchemaPrefix"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SchemaPrefix">SchemaPrefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xquery30-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-schema-import" id="dt-schema-import" title=
"schema import">Definition</a>: A <b>schema import</b> imports the
element declarations, attribute declarations, and type definitions
from a schema into the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>. <span>For each
<span>named</span> user-defined <span>simple type</span> in the
schema, schema import also adds a corresponding <a title=
"constructor function" href="#dt-constructor-function">constructor
function</a>.</span> ] The schema to be imported is identified by
its <a title="target namespace" href="#dt-target-namespace">target
namespace</a>. The schema import may bind a namespace prefix to the
target namespace of the imported schema, <span>adding the (prefix,
URI) pair to the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>,</span> or
it may declare that target namespace to be the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a>. The schema import may also provide
optional hints for locating the schema.</p>
<p>The namespace prefix specified in a schema import must not be
<code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070"
title="err:XQST0070">err:XQST0070</a>], and must not be the same as
any namespace prefix bound in the same module by another schema
import, a <a title="module import" href="#dt-module-import">module
import</a>, a <a title="namespace declaration" href=
"#dt-namespace-declaration">namespace declaration</a>, or a
<a title="module import" href="#dt-module-import">module
declaration</a> [<a href="#ERRXQST0033" title=
"err:XQST0033">err:XQST0033</a>].</p>
<p>The first <a href="#doc-xquery30-URILiteral">URILiteral</a> in a
schema import specifies the target namespace of the schema to be
imported. The URILiterals that follow the <code>at</code> keyword
are optional location hints, and can be interpreted or disregarded
in an implementation-dependent way. Multiple location hints might
be used to indicate more than one possible place to look for the
schema or multiple physical resources to be assembled to form the
schema.</p>
<p>A schema import that specifies a zero-length string as target
namespace is considered to import a schema that has no target
namespace. Such a schema import must not bind a namespace prefix
[<a href="#ERRXQST0057" title="err:XQST0057">err:XQST0057</a>], but
it may set the default element/type namespace to a zero-length
string (representing "no namespace"), thus enabling the definitions
in the imported namespace to be referenced. If the default
element/type namespace is not set to "no namespace", there is no
way to reference the definitions in an imported schema that has no
target namespace.</p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXQST0058" title=
"err:XQST0058">err:XQST0058</a>] if more than one schema import in
the same <a title="Prolog" href="#dt-prolog">Prolog</a> specifies
the same target namespace. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0059" title=
"err:XQST0059">err:XQST0059</a>] if the implementation is not able
to process a schema import by finding a valid schema with the
specified target namespace. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0035" title=
"err:XQST0035">err:XQST0035</a>] if multiple imported schemas, or
multiple physical resources within one schema, contain definitions
for the same name in the same symbol space (for example, two
definitions for the same element name, even if the definitions are
consistent). However, it is not an error to import the schema with
target namespace <code>http://www.w3.org/2001/XMLSchema</code>
(predeclared prefix <code>xs</code>), even though the built-in
types defined in this schema are implicitly included in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types.</a></p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXQST0012" title=
"err:XQST0012">err:XQST0012</a>] if the set of definitions
contained in all schemas imported by a Prolog do not satisfy the
conditions for schema validity specified in Sections 3 and 5 of
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> Part 1--i.e., each definition
must be valid, complete, and unique.</p>
<p>The following example imports a schema, specifying both its
target namespace and its location, and binding the prefix
<code>soap</code> to the target namespace:</p>
<div class="exampleInner">
<pre>
import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";
</pre></div>
<p>The following example imports a schema by specifying only its
target namespace, and makes it the default element/type
namespace:</p>
<div class="exampleInner">
<pre>
import schema default element namespace "http://example.org/abc";
</pre></div>
<p>The following example imports a schema that has no target
namespace, providing a location hint, and sets the default
element/type namespace to "no namespace" so that the definitions in
the imported schema can be referenced:</p>
<div class="exampleInner">
<pre>
import schema default element namespace ""
at "http://example.org/xyz.xsd";
</pre></div>
<p>The following example imports a schema that has no target
namespace and sets the default element/type namespace to "no
namespace". Since no location hint is provided, it is up to the
implementation to find the schema to be imported.</p>
<div class="exampleInner">
<pre>
import schema default element namespace "";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-module-import" id="id-module-import"></a>4.12
Module Import</h3>
<h5><a name="d2e27412" id="d2e27412"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ModuleImport" id=
"doc-xquery30-ModuleImport"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ModuleImport">ModuleImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=")? <a href=
"#doc-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-module-import" id="dt-module-import" title=
"module import">Definition</a>: A <b>module import</b> imports the
<span>public variable declarations and public function
declarations</span> from one or more <a title="library module"
href="#dt-library-module">library modules</a> into the <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> and <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> of the importing
<a title="module" href="#dt-module">module</a>.] Each module import
names a <a title="target namespace" href=
"#dt-target-namespace">target namespace</a> and imports an
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
modules that share this target namespace. The module import may
bind a namespace prefix to the target namespace, <span>adding the
(prefix, URI) pair to the <a title="statically known namespaces"
href="#dt-static-namespaces">statically known
namespaces</a>,</span> and it may provide optional hints for
locating the modules to be imported.</p>
<p>If a module <code>A</code> imports module <code>B</code>, the
static context of module <code>A</code> will contain the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a> and <a title="statically known function signatures"
href="#dt-known-func-signatures">statically known function
signatures</a> of module <code>B</code>, and the dynamic context of
module <code>A</code> will contain the <a title="variable values"
href="#dt-variable-values">variable values</a> and <a title=
"named functions" href="#dt-named-functions">named functions</a> of
module <code>B</code>, with the exception of non-public functions
and variables, and of the functions and variables not declared
directly in <code>B</code>.</p>
<p>The following example illustrates a module import:</p>
<div class="exampleInner">
<pre>
import module namespace gis="http://example.org/gis-functions";
</pre></div>
<p>If a query imports the same module via multiple paths, only one
instance of the module is imported. Because only one instance of a
module is imported, there is only one instance of each variable
declared in a module<span>'s prolog</span>.</p>
<p>A module may import its own target namespace (this is
interpreted as importing an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
other modules that share its target namespace.)</p>
<p>The namespace prefix specified in a module import must not be
<code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070"
title="err:XQST0070">err:XQST0070</a>], and must not be the same as
any namespace prefix bound in the same module by another module
import, a <a title="schema import" href="#dt-schema-import">schema
import</a>, a <a title="namespace declaration" href=
"#dt-namespace-declaration">namespace declaration</a>, or a
<a title="module declaration" href="#dt-module-declaration">module
declaration</a> with a different target namespace [<a href=
"#ERRXQST0033" title="err:XQST0033">err:XQST0033</a>].</p>
<p>The first <a href="#doc-xquery30-URILiteral">URILiteral</a> in a
module import must be of nonzero length [<a href="#ERRXQST0088"
title="err:XQST0088">err:XQST0088</a>], and specifies the target
namespace of the modules to be imported. The URILiterals that
follow the <code>at</code> keyword are optional location hints, and
can be interpreted or disregarded in an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXQST0047" title=
"err:XQST0047">err:XQST0047</a>] if more than one module import in
a <a title="Prolog" href="#dt-prolog">Prolog</a> specifies the same
target namespace. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0059" title=
"err:XQST0059">err:XQST0059</a>] if the implementation is not able
to process a module import by finding a valid module definition
with the specified target namespace. It is a <a title=
"static error" href="#dt-static-error">static error</a> if
<span>two or more variables declared or imported by a <a title=
"module" href="#dt-module">module</a> have equal <a title=
"expanded QName" href="#dt-expanded-qname">expanded QNames</a> (as
defined by the <code>eq</code> operator)</span> [<a href=
"#ERRXQST0049" title="err:XQST0049">err:XQST0049</a>].</p>
<p>Each <a title="module" href="#dt-module">module</a> has its own
<a title="static context" href="#dt-static-context">static
context</a>. A <a title="module import" href=
"#dt-module-import">module import</a> imports only functions and
variable declarations; it does not import other objects from the
imported modules, such as <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a> or <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. Module
imports are not transitive—that is, importing a module provides
access only to function and variable declarations contained
directly in the imported module. For example, if module A imports
module B, and module B imports module C, module A does not have
access to the functions and variables declared in module C.</p>
<div class="exampleOuter">
<div class="exampleHeader"><a name="d2e27716" id=
"d2e27716"></a>Example: Schema Information and Module Import</div>
<p>A module import does not import schema definitions from the
imported module. In the following query, the type geometry:triangle
is not defined, even if it is known in the imported module, so the
variable declaration raises an error [<a href="#ERRXPST0051" title=
"err:XPST0051">err:XPST0051</a>]:</p>
<div class="exampleInner">
<pre>
(: Error - geometry:triangle is not defined :)
import module namespace geo = "http://example.org/geo-functions";
declare variable $t as geometry:triangle := geo:make-triangle();

$t
</pre></div>
<p>Without the type declaration for the variable, the variable
declaration succeeds:</p>
<div class="exampleInner">
<pre>
import module namespace geo = "http://example.org/geo-functions";
declare variable $t := geo:make-triangle();

$t
</pre></div>
<p>Importing the schema that defines the type of the variable, the
variable declaration succeeds:</p>
<div class="exampleInner">
<pre>
import schema namespace geometry = "http://example.org/geo-schema-declarations";
import module namespace geo = "http://example.org/geo-functions";
declare variable $t as geometry:triangle := geo:make-triangle();

$t
</pre></div>
</div>
<div class="div3">
<h4><a name="id-module-handling-module-uris" id=
"id-module-handling-module-uris"></a>4.12.1 <span>The Target
Namespace of a Module</span></h4>
<p><span>The target namespace of a module</span> should be treated
in the same way as other namespace URIs.</p>
<p>To maximize interoperability, query authors should use a string
that is a valid absolute IRI.</p>
<p>Implementions must accept any string of Unicode characters.
<span>target namespace</span> URIs are compared using the Unicode
codepoint collation rather than any concept of semantic
equivalence.</p>
<p>Implementations may provide mechanisms allowing the <span>target
namespace</span> URI to be used as input to a process that delivers
the module as a resource, for example a catalog, module repository,
or URI resolver. For interoperability, such mechanisms should not
prevent the user from choosing an arbitrary URI for naming a
module.</p>
<p>Similarly, implementations may perform syntactic transformations
on the <span>target namespace</span> URI to obtain the names of
related resources, for example to implement a convention relating
the name or location of compiled code to the <span>target
namespace</span> URI; but again, such mechanisms should not prevent
the user from choosing an arbitrary <span>target namespace</span>
URI.</p>
<p>As with other namespace URIs, it is common practice to use
<span>target namespace</span> URIs whose scheme is "http" and whose
authority part uses a DNS domain name under the control of the
user.</p>
<p>The specifications allow, and some users might consider it good
practice, for the <span>target namespace</span> URI of a function
library to be the same as the namespace URI of the XML vocabulary
manipulated by the functions in that library.</p>
</div>
<div class="div3">
<h4><a name="id-module-handling-multiple-same" id=
"id-module-handling-multiple-same"></a>4.12.2 Multiple Modules with
the same <span>Target Namespace</span></h4>
<p>Several different modules with the same <span>target
namespace</span> can be used in the same query. The names of public
variables and public functions must be unique within the
<span><a title="module context" href="#dt-module-context">module
contexts</a> of a</span> query: that is, if two modules with the
same <span>target namespace</span> URI are used in the same query,
the names of <span>the</span> public variables and functions
<span>in their module contexts</span> must not overlap.</p>
<p>If one module contains an "import module" declaration <span>with
the target namespace</span> <code>M</code>, then all public
variables and public functions <span>in the contexts of</span>
modules whose <span>target namespace</span> is <code>M</code> must
be accessible in the importing module, regardless whether the
participation of the imported module was directly due to this
"import module" declaration.</p>
</div>
<div class="div3">
<h4><a name="id-module-handling-location-uris" id=
"id-module-handling-location-uris"></a>4.12.3 Location URIs</h4>
<p>The term "location URIs" refers to the URIs in the "at" clause
of an "import module" declaration.</p>
<p>Products should (by default or at user option) take account of
all the location URIs in an "import module" declaration, treating
each location URI as a reference to a module with the specified
<span>target namespace</span> URI. Location URIs should be made
absolute with respect to the static base URI of the module
containing the "import module" declaration where they appear. The
mapping from location URIs to module source code or compiled code
MAY be done in any way convenient to the implementation. If
possible given the product's architecture, security requirements,
etc, the product should allow this to fetch the source code of the
module to use the standard web mechanisms for dereferencing URIs in
standard schemes such as the "http" URI scheme.</p>
<p>When the same absolutized location URI is used more than once,
either in the same "import module" declaration or in different
"import module" declarations within the same query, a single copy
of the resource containing the module is loaded. When different
absolutized location URIs are used, each results in a single module
being loaded, unless the implementation is able to determine that
the different URIs are references to the same resource. No error
due to duplicate variable or functions names should arise from the
same module being imported more than once, so long as the absolute
location URI is the same in each case.</p>
<p>Implementations must report a static error if a location URI
cannot be resolved after all available recovery strategies have
been exhausted.</p>
</div>
<div class="div3">
<h4><a name="id-module-handling-cycles" id=
"id-module-handling-cycles"></a>4.12.4 Cycles</h4>
<p><span>Implementations must resolve cycles in the import
graph,</span> either at the level of <span>target namespace</span>
URIs or at the level of location URIs, <span>and ensure that each
module is imported only once</span>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-namespace-declaration" id=
"id-namespace-declaration"></a>4.13 Namespace Declaration</h3>
<h5><a name="d2e27935" id="d2e27935"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-NamespaceDecl" id=
"doc-xquery30-NamespaceDecl"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NamespaceDecl">NamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#doc-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-namespace-declaration" id=
"dt-namespace-declaration" title=
"namespace declaration">Definition</a>: A <b>namespace
declaration</b> declares a namespace prefix and associates it with
a namespace URI, adding the (prefix, URI) pair to the set of
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.] The
namespace declaration is in scope throughout the query in which it
is declared, unless it is overridden by a <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a> in a
<a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructor</a>.</p>
<p>If the URILiteral part of a namespace declaration is a
zero-length string, any existing namespace binding for the given
prefix is removed from the <a title="statically known namespaces"
href="#dt-static-namespaces">statically known namespaces</a>. This
feature provides a way to remove predeclared namespace prefixes
such as <code>local</code>.</p>
<p>The following query illustrates a namespace declaration:</p>
<div class="exampleInner">
<pre>
declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;
</pre></div>
<p>In the query result, the newly created node is in the namespace
associated with the namespace URI
<code>http://example.org</code>.</p>
<p>The namespace prefix specified in a namespace declaration must
not be <code>xml</code> or <code>xmlns</code> [<a href=
"#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]. The
namespace URI specified in a namespace declaration must not be
<code>http://www.w3.org/XML/1998/namespace</code> or
<code>http://www.w3.org/2000/xmlns/</code> [<a href="#ERRXQST0070"
title="err:XQST0070">err:XQST0070</a>]. The namespace prefix
specified in a namespace declaration must not be the same as any
namespace prefix bound in the same module by a <a title=
"module import" href="#dt-module-import">module import</a>,
<a title="schema import" href="#dt-schema-import">schema
import</a>, <a title="module import" href=
"#dt-module-import">module declaration</a>, or another namespace
declaration [<a href="#ERRXQST0033" title=
"err:XQST0033">err:XQST0033</a>].</p>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>] if an expression contains a
<a title="lexical QName" href="#dt-qname">lexical QName</a> with a
namespace prefix that is not in the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
<p>XQuery has several predeclared namespace prefixes that are
present in the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> before each
query is processed. These prefixes may be used without an explicit
declaration. They may be overridden by <a title=
"namespace declaration" href="#dt-namespace-declaration">namespace
declarations</a> in a <a title="Prolog" href=
"#dt-prolog">Prolog</a> or by <a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attributes</a> on
constructed elements (however, the prefix <code>xml</code> must not
be redeclared, and no other prefix may be bound to the namespace
URI associated with the prefix <code>xml</code> [<a href=
"#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]). The
predeclared namespace prefixes are as follows:</p>
<ul>
<li>
<p><code>xml = http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>local =
http://www.w3.org/2005/xquery-local-functions</code> (see <a href=
"#FunctionDeclns"><b>4.18 Function Declaration</b></a>.)</p>
</li>
</ul>
<p>Additional predeclared namespace prefixes may be added to the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> by an
implementation.</p>
<p>When element or attribute names are compared, they are
considered identical if the local parts and namespace URIs match on
a codepoint basis. Namespace prefixes need not be identical for two
names to match, as illustrated by the following example:</p>
<div class="exampleInner">
<pre>
declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing
</pre></div>
<p>Although the namespace prefixes <code>xx</code> and
<code>foo</code> differ, both are bound to the namespace URI
<code>http://example.org</code>. Since <code>xx:bing</code> and
<code>foo:bing</code> have the same local name and the same
namespace URI, they match. The output of the above query is as
follows.</p>
<div class="exampleInner">
<pre>
&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="id-default-namespace" id=
"id-default-namespace"></a>4.14 Default Namespace Declaration</h3>
<h5><a name="d2e28114" id="d2e28114"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-DefaultNamespaceDecl" id=
"doc-xquery30-DefaultNamespaceDecl"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#doc-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Default namespace declarations</b> can be used in a <a title=
"Prolog" href="#dt-prolog">Prolog</a> to facilitate the use of
unprefixed QNames.</p>
<p>The namespace URI specified in a default namespace declaration
must not be <code>http://www.w3.org/XML/1998/namespace</code> or
<code>http://www.w3.org/2000/xmlns/</code> [<a href="#ERRXQST0070"
title="err:XQST0070">err:XQST0070</a>].</p>
<p>The following kinds of default namespace declarations are
supported:</p>
<ul>
<li>
<p>A <b>default element/type namespace declaration</b> declares a
namespace URI that is associated with unprefixed names of elements
and types. This declaration is recorded as the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a> in the <a title="static context" href=
"#dt-static-context">static context</a>. A <a title="Prolog" href=
"#dt-prolog">Prolog</a> may contain at most one default
element/type namespace declaration [<a href="#ERRXQST0066" title=
"err:XQST0066">err:XQST0066</a>]. If the <a href=
"#doc-xquery30-URILiteral">URILiteral</a> in a default element/type
namespace declaration is a zero-length string, the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a> is undeclared (set to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>),
and unprefixed names of elements and types are considered to be in
no namespace. The following example illustrates the declaration of
a default namespace for elements and types:</p>
<div class="exampleInner">
<pre>
declare default element namespace "http://example.org/names";
</pre></div>
<p>A default element/type namespace declaration may be overridden
by a <a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a> in a
<a title="direct element constructor" href=
"#dt-direct-elem-const">direct element constructor</a>.</p>
<p>If no default element/type namespace declaration is present,
unprefixed element and type names are in no namespace (however, an
implementation may define a different default as specified in
<a href="#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a>.)</p>
</li>
<li>
<p>A <b>default function namespace declaration</b> declares a
namespace URI that is associated with unprefixed function names in
<span>static</span> function calls and function declarations. This
declaration is recorded as the <a title=
"default function namespace" href="#dt-def-fn-ns">default function
namespace</a> in the <a title="static context" href=
"#dt-static-context">static context</a>. A <a title="Prolog" href=
"#dt-prolog">Prolog</a> may contain at most one default function
namespace declaration [<a href="#ERRXQST0066" title=
"err:XQST0066">err:XQST0066</a>]. If the StringLiteral in a default
function namespace declaration is a zero-length string, the default
function namespace is undeclared (set to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>).
In that case, any functions that are associated with a namespace
can be called only by using an explicit namespace prefix.</p>
<p>If no default function namespace declaration is present, the
default function namespace is the namespace of XPath/XQuery
functions, <code>http://www.w3.org/2005/xpath-functions</code>
(however, an implementation may define a different default as
specified in <a href="#id-xq-static-context-components"><b>C.1
Static Context Components</b></a>.)</p>
<p>The following example illustrates the declaration of a default
function namespace:</p>
<div class="exampleInner">
<pre>
declare default function namespace "http://www.w3.org/2005/xpath-functions/math";
</pre></div>
<p>The effect of declaring a default function namespace is that all
functions in the default function namespace, including
implicitly-declared <a title="constructor function" href=
"#dt-constructor-function">constructor functions</a>, can be
invoked without specifying a namespace prefix. When a
<span>static</span> function call uses a function name with no
prefix, the local name of the function must match a function
(including implicitly-declared <a title="constructor function"
href="#dt-constructor-function">constructor functions</a>) in the
default function namespace [<a href="#ERRXPST0017" title=
"err:XPST0017">err:XPST0017</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only <a title="constructor function" href=
"#dt-constructor-function">constructor functions</a> can be in no
namespace.</p>
</div>
</li>
</ul>
<p>Unprefixed attribute names and variable names are in no
namespace.</p>
</div>
<div class="div2">
<h3><a name="id-annotations" id="id-annotations"></a>4.15
Annotations</h3>
<h5><a name="d2e28246" id="d2e28246"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-AnnotatedDecl" id=
"doc-xquery30-AnnotatedDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AnnotatedDecl">AnnotatedDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" <a href=
"#doc-xquery30-Annotation">Annotation</a>* (<a href=
"#doc-xquery30-VarDecl">VarDecl</a> | <a href=
"#doc-xquery30-FunctionDecl">FunctionDecl</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e25492.doc-xquery30-InlineFunctionExpr" id=
"noid_d3e25492.doc-xquery30-InlineFunctionExpr"></a>[165]&#160;&#160;&#160;</td>
<td><code>InlineFunctionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Annotation">Annotation</a>*
"function" "(" <a href="#doc-xquery30-ParamList">ParamList</a>? ")"
("as" <a href="#doc-xquery30-SequenceType">SequenceType</a>)?
<a href="#doc-xquery30-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Annotation" id=
"doc-xquery30-Annotation"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Annotation">Annotation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"%" <a href="#doc-xquery30-EQName">EQName</a> ("("
<a href="#doc-xquery30-Literal">Literal</a> ("," <a href=
"#doc-xquery30-Literal">Literal</a>)* ")")?</code></td>
</tr>
</tbody>
</table>
<p>XQuery uses annotations to declare properties associated with
functions <span>(inline or declared in the prolog)</span> and
variables. For instance, a function may be declared
<code>%public</code> <span>or</span> <code>%private</code> . The
semantics associated with these properties are described in
<a href="#FunctionDeclns"><b>4.18 Function Declaration</b></a>.</p>
<p>Annotations are <code>(QName, value)</code> pairs. If the EQName
of the annotation is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a>, the prefix of the QName is resolved
using the statically known namespaces; if no prefix is present,
<span>the name is in the <code>http://www.w3.org/2012/xquery</code>
namespace.</span></p>
<p><span class="xquery">Implementations may define further
annotations, whose behaviour is implementation-defined. For
instance, if the <code>eg</code> prefix is bound to a namespace
associated with a particular implementation, it could define an
annotation like <code>eg:sequential</code>. Implementations must
not define annotations in the following reserved namespaces;
it</span> is an error for users to create annotations in the
following reserved namespaces [<a href="#ERRXQST0045" title=
"err:XQST0045">err:XQST0045</a>]:</p>
<ul>
<li>
<p>http://www.w3.org/XML/1998/namespace</p>
</li>
<li>
<p>http://www.w3.org/2001/XMLSchema</p>
</li>
<li>
<p>http://www.w3.org/2001/XMLSchema-instance</p>
</li>
<li>
<p>http://www.w3.org/2005/xpath-functions</p>
</li>
<li>
<p>http://www.w3.org/2005/xpath-functions/math</p>
</li>
<li>
<p>http://www.w3.org/2012/xquery</p>
</li>
</ul>
<p>An annotation can provide values explicitly using a
parenthesized list of <a title="" href="#id-literals">literals</a>.
For instance, the annotation
<code>%java:method("java.lang.Math.sin")</code> sets the value of
the <code>java:method</code> annotation to the string value
<code>java.lang.Math.sin</code>.</p>
</div>
<div class="div2">
<h3><a name="id-variable-declarations" id=
"id-variable-declarations"></a>4.16 Variable Declaration</h3>
<h5><a name="d2e28407" id="d2e28407"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e25610.doc-xquery30-AnnotatedDecl" id=
"noid_d3e25610.doc-xquery30-AnnotatedDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code>AnnotatedDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" <a href=
"#doc-xquery30-Annotation">Annotation</a>* (<a href=
"#doc-xquery30-VarDecl">VarDecl</a> | <a href=
"#doc-xquery30-FunctionDecl">FunctionDecl</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e25611.doc-xquery30-Annotation" id=
"noid_d3e25611.doc-xquery30-Annotation"></a>[27]&#160;&#160;&#160;</td>
<td><code>Annotation</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"%" <a href="#doc-xquery30-EQName">EQName</a> ("("
<a href="#doc-xquery30-Literal">Literal</a> ("," <a href=
"#doc-xquery30-Literal">Literal</a>)* ")")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VarDecl" id=
"doc-xquery30-VarDecl"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-VarDecl">VarDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"variable" "$" <a href=
"#doc-xquery30-VarName">VarName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>? ((":="
<a href="#doc-xquery30-VarValue">VarValue</a>) | ("external" (":="
<a href=
"#doc-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e25613.doc-xquery30-VarName" id=
"noid_d3e25613.doc-xquery30-VarName"></a>[128]&#160;&#160;&#160;</td>
<td><code>VarName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e25614.doc-xquery30-TypeDeclaration" id=
"noid_d3e25614.doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VarValue" id=
"doc-xquery30-VarValue"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-VarValue">VarValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-VarDefaultValue" id=
"doc-xquery30-VarDefaultValue"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-VarDefaultValue">VarDefaultValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>variable declaration</b> adds the <a title="static type"
href="#dt-static-type">static type</a> of a variable to the
<a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a>, and may also add a
value for the variable to the <a title="variable values" href=
"#dt-variable-values">variable values</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A <b>variable declaration</b> always refers to a declaration of
a variable in a Prolog. The binding of a variable to a value in a
query expression, such as a FLWOR expression, is known as a
<b>variable binding</b>, and does not make the variable visible to
an importing module.</p>
</div>
<p>During static analysis, a variable declaration causes a pair
<code>(expanded QName N, type T)</code> to be added to the
<a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a>. The expanded QName
N is the <code>VarName</code>. If N is equal (as defined by the eq
operator) to the expanded QName of another variable in in-scope
variables, a <a title="static error" href="#dt-static-error">static
error</a> is raised [<a href="#ERRXQST0049" title=
"err:XQST0049">err:XQST0049</a>].</p>
<p>All variable names declared in a library module must (when
expanded) be in the target namespace of the library module
[<a href="#ERRXQST0048" title="err:XQST0048">err:XQST0048</a>]. A
variable declaration may use annotations to specify that the
variable is <code>%private</code> or <code>%public</code> (which is
the default). [<a name="dt-private-variable" id=
"dt-private-variable" title="private variable">Definition</a>: A
<b>private variable</b> is a variable with a <code>%private</code>
annotation. A private variable is hidden from <a title=
"module import" href="#dt-module-import">module import</a>, which
can not import it into the <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> of another module.]
[<a name="dt-public-variable" id="dt-public-variable" title=
"public variable">Definition</a>: A <b>public variable</b> is a
variable without a <code>%private</code> annotation. A public
variable is accessible to <a title="module import" href=
"#dt-module-import">module import</a>, which can import it into the
<a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> of another module.
<span>Using <code>%public</code> and <code>%private</code>
annotations in a main module is not an error, but it does not
affect module imports, since a main module cannot be
imported.</span> It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0116" title=
"err:XQST0116">err:XQST0116</a>] <span>if a variable declaration
contains both a <code>%private</code> and a <code>%public</code>
annotation, more than one <code>%private</code> annotation, or more
than one <code>%public</code> annotation.</span> ]</p>
<p>Variable names that have no namespace prefix are in no
namespace. Variable declarations that have no namespace prefix may
appear only in a main module.</p>
<p>Here are some examples of variable declarations:</p>
<ul>
<li>
<p>The following declaration specifies both the type and the value
of a variable. This declaration causes the type
<code>xs:integer</code> to be associated with variable
<code>$x</code> in the <a title="static context" href=
"#dt-static-context">static context</a>, and the value
<code>7</code> to be associated with variable <code>$x</code> in
the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a>.</p>
<div class="exampleInner">
<pre>
declare variable $x as xs:integer := 7;
</pre></div>
</li>
<li>
<p>The following declaration specifies a value but not a type. The
<a title="static type" href="#dt-static-type">static type</a> of
the variable is inferred from the static type of its value. In this
case, the variable <code>$x</code> has a static type of
<code>xs:decimal</code>, inferred from its value which is 7.5.</p>
<div class="exampleInner">
<pre>
declare variable $x := 7.5;
</pre></div>
</li>
<li>
<p>The following declaration specifies a type but not a value. The
keyword <code>external</code> indicates that the value of the
variable will be provided by the external environment. At
evaluation time, if the variable <code>$x</code> in the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
does not have a value of type <code>xs:integer</code>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised.</p>
<div class="exampleInner">
<pre>
declare variable $x as xs:integer external;
</pre></div>
</li>
<li>
<p>The following declaration specifies neither a type nor a value.
It simply declares that the query depends on the existence of a
variable named <code>$x</code>, whose type and value will be
provided by the external environment. During query analysis, the
type of <code>$x</code> is considered to be <code>item()*</code>.
During query evaluation, the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> must include a type and a
value for <code>$x</code>, and its value must be compatible with
its type.</p>
<div class="exampleInner">
<pre>
declare variable $x external;
</pre></div>
</li>
<li>
<p>The following declaration, which might appear in a library
module, declares a variable whose name includes a namespace
prefix:</p>
<div class="exampleInner">
<pre>
declare variable $sasl:username as xs:string := "jonathan@example.com";
</pre></div>
</li>
<li>
<p>This is an example of an external variable declaration that
provides a <code>VarDefaultValue</code>:</p>
<div class="exampleInner">
<pre>
declare variable $x as xs:integer external := 47;
</pre></div>
</li>
</ul>
<p>The syntax for variable declarations allows annotations, but
XQuery 3.0 does not define annotations that apply to variable
declarations. An implementation can provide annotations it needs.
For instance, an implemenation that supports volatile external
variables might allow them to be declared using an annotation:</p>
<div class="exampleInner">
<pre>
declare %eg:volatile variable $time as xs:time external;
</pre></div>
<p>The type of the declared variable is as follows:</p>
<ul>
<li>
<p>If <code>TypeDeclaration</code> is present, then the
<code>SequenceType</code> in the <code>TypeDeclaration</code>;
otherwise</p>
</li>
<li>
<p>If the Static Typing Feature is in effect and
<code>VarValue</code> is present, then the static type inferred
from static analysis of the expression <code>VarValue</code>;</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Type inference might not be computable until after the check for
circular dependencies, described below, is complete.</p>
</div>
</li>
<li>
<p>Otherwise, <code>item()*</code>.</p>
</li>
</ul>
<p>[<a name="dt-initializing-expression" id=
"dt-initializing-expression" title=
"initializing expression">Definition</a>: If a variable declaration
includes an expression (<code>VarValue</code> or
<code>VarDefaultValue</code>), the expression is called an
<b>initializing expression.</b> The static context for an
initializing expression includes all functions, variables, and
namespaces that are declared or imported anywhere in the Prolog,
other than the variable being declared.]</p>
<p>In a module's dynamic context, a variable value (or the context
item) may <a title="depends on" href="#dt-depends-on">depend on</a>
another variable value (or the context item). [<a name=
"dt-depends-on" id="dt-depends-on" title=
"depends on">Definition</a>: A variable value (or the context item)
<b>depends on</b> another variable value (or the context item) if,
during the evaluation of the initializing expression of the former,
the latter is accessed through the module context.]</p>
<p>In the following example, the value of variable <code>$a</code>
<a title="depends on" href="#dt-depends-on">depends on</a> the
value of variable <code>$b</code> because the evaluation of $a's
initializing expression accesses the value of $b during the
evaluation of <code>local:f()</code>.</p>
<div class="exampleInner">
<pre>
declare variable $a := local:f();
declare variable $b := 1;
declare function local:f() { $b };
</pre></div>
<p>A directed graph can be built with all variable values and the
context item as nodes, and with the <a title="depends on" href=
"#dt-depends-on">depend on</a> relation as edges. This graph must
not contain cycles, as it makes the population of the dynamic
context impossible. If it is discovered, during static analysis or
during dynamic evaluation, that such a cycle exists, error
[<a href="#ERRXQDY0054" title="err:XQDY0054">err:XQDY0054</a>] must
be raised.</p>
<p>During query evaluation, each variable declaration causes a pair
<code>(expanded QName N, value V)</code> to be added to the
<a title="variable values" href="#dt-variable-values">variable
values</a>. The expanded QName N is the <code>VarName</code>. The
value V is as follows:</p>
<ul>
<li>
<p>If <code>VarValue</code> is specified, then V is the result of
evaluating <code>VarValue</code> as described below.</p>
</li>
<li>
<p>If <code>external</code> is specified, then:</p>
<ul>
<li>
<p>if a value is provided for the variable by the external
environment, then V is that value. The means by which typed values
of external variables are provided by the external environment is
implementation-defined.</p>
</li>
<li>
<p>if no value is provided for the variable by the external
environment, and <code>VarDefaultValue</code> is specified, then V
is the result of evaluating <code>VarDefaultValue</code> as
described below.</p>
</li>
<li>
<p>If no value is provided for the variable by the external
environment, and <code>VarDefaultValue</code> is not specified,
then a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
<p>It is implementation-dependent whether this error is raised if
the evaluation of the query does not reference the value of the
variable.</p>
</li>
</ul>
</li>
</ul>
<p>In all cases the value V must match the type T according to the
rules for SequenceType matching; otherwise a <a title="type error"
href="#dt-type-error">type error</a> is raised [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>If <code>VarValue</code> or <code>VarDefaultValue</code> is
evaluated, <span>the static and dynamic contexts for the evaluation
are the current module's static and dynamic context.</span></p>
</div>
<div class="div2">
<h3><a name="id-context-item-declarations" id=
"id-context-item-declarations"></a>4.17 Context Item
Declaration</h3>
<h5><a name="d2e29000" id="d2e29000"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e26133.doc-xquery30-ContextItemDecl" id=
"noid_d3e26133.doc-xquery30-ContextItemDecl"></a>[31]&#160;&#160;&#160;</td>
<td><code>ContextItemDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "context" "item" ("as" <a href=
"#doc-xquery30-ItemType">ItemType</a>)? ((":=" <a href=
"#doc-xquery30-VarValue">VarValue</a>) | ("external" (":=" <a href=
"#doc-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
</table>
<p>A context item declaration allows a query to specify the
<a title="static type" href="#dt-static-type">static type</a>,
value, or default value for the <a title="initial context item"
href="#dt-initial-context-item">initial context item</a>.</p>
<p><span>Only the main module can set the value of the <a title=
"initial context item" href="#dt-initial-context-item">initial
context item</a>.</span> In a library module, a context item
declaration <span>must be external, and</span> specifies only the
static type. Specifying a <a href=
"#doc-xquery30-VarValue">VarValue</a> or <a href=
"#doc-xquery30-VarDefaultValue">VarDefaultValue</a> for a context
item declaration in a library module is a static error [<a href=
"#ERRXQST0113" title="err:XQST0113">err:XQST0113</a>].</p>
<p>In every module that does not contain a context item
declaration, the effect is as if the declaration</p>
<div class="exampleInner">
<pre>
declare context item as item() external;
</pre></div>
<p>appeared in that module.</p>
<p>During static analysis, the context item declaration has the
effect of setting the context item static type <code>T</code> in
the static context. The context item static type is set to
<code>ItemType</code> if specified, or to <code>item()</code>
otherwise.</p>
<p>If a module contains more than one context item declaration, a
static error is raised [<a href="#ERRXQST0099" title=
"err:XQST0099">err:XQST0099</a>].</p>
<p>The static context for an initializing expression includes all
functions, variables, and namespaces that are declared or imported
anywhere in the Prolog.</p>
<p>During query evaluation, a <a title="singleton focus" href=
"#dt-singleton-focus">singleton focus</a> is created in the dynamic
context for the evaluation of the <code>QueryBody</code> in the
main module, and for the initializing expression of every variable
declaration in every module, selecting the context item for the
singleton focus as follows:</p>
<ul>
<li>
<p>If <code>VarValue</code> is specified, then the result of
evaluating <code>VarValue</code> .</p>
</li>
<li>
<p>If <code>external</code> is specified, then:</p>
<ul>
<li>
<p>if a value is provided for the context item by the external
environment, then that value.</p>
<p>The means by which an external value is provided by the external
environment is implementation-defined.</p>
</li>
<li>
<p>if no value is provided for the context item by the external
environment, and <code>VarDefaultValue</code> is specified,
<span>then the result of evaluating <code>VarDefaultValue</code> as
described below.</span></p>
</li>
</ul>
</li>
</ul>
<p>In all cases where the context item has a value, that value must
match the type <code>T</code> according to the rules for
SequenceType matching; otherwise a type error is raised [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If more than
one module contains a context item declaration, the context item
must match the type declared in each one.</p>
<p>If <code>VarValue</code> or <code>VarDefaultValue</code> is
evaluated, the static and dynamic contexts for the evaluation are
the current module's static and dynamic context.</p>
<p>Here are some examples of context item declarations.</p>
<ul>
<li>
<p>Declare the type of the context item:</p>
<div class="exampleInner">
<pre>
declare namespace env="http://www.w3.org/2003/05/soap-envelope";
declare context item as element(env:Envelope) external;
</pre></div>
</li>
<li>
<p>Declare a default context item, which is a system log in a
default location. If the system log is in a different location, it
can be specified in the external environment:</p>
<div class="exampleInner">
<pre>
declare context item as element(sys:log) external := doc("/var/xlogs/sysevent.xml")/sys:log;
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="FunctionDeclns" id="FunctionDeclns"></a>4.18 Function
Declaration</h3>
<p>In addition to the built-in functions described in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>, XQuery allows users to declare functions of their own. A
function declaration specifies the name of the function, the names
and datatypes of the parameters, and the datatype of the result.
All datatypes are specified using the syntax described in <a href=
"#id-types"><b>2.5 Types</b></a>. A function declaration causes the
declared function to be added to the <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> <span>and the <a title="named functions" href=
"#dt-named-functions">named functions</a></span> of the <a title=
"module" href="#dt-module">module</a> in which it appears.</p>
<h5><a name="d2e29318" id="d2e29318"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e26438.doc-xquery30-AnnotatedDecl" id=
"noid_d3e26438.doc-xquery30-AnnotatedDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code>AnnotatedDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" <a href=
"#doc-xquery30-Annotation">Annotation</a>* (<a href=
"#doc-xquery30-VarDecl">VarDecl</a> | <a href=
"#doc-xquery30-FunctionDecl">FunctionDecl</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e26439.doc-xquery30-Annotation" id=
"noid_d3e26439.doc-xquery30-Annotation"></a>[27]&#160;&#160;&#160;</td>
<td><code>Annotation</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"%" <a href="#doc-xquery30-EQName">EQName</a> ("("
<a href="#doc-xquery30-Literal">Literal</a> ("," <a href=
"#doc-xquery30-Literal">Literal</a>)* ")")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FunctionDecl" id=
"doc-xquery30-FunctionDecl"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FunctionDecl">FunctionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" <a href="#doc-xquery30-EQName">EQName</a> "("
<a href="#doc-xquery30-ParamList">ParamList</a>? ")" ("as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a>)? (<a href=
"#doc-xquery30-FunctionBody">FunctionBody</a> |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ParamList" id=
"doc-xquery30-ParamList"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ParamList">ParamList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Param">Param</a> ("," <a href=
"#doc-xquery30-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Param" id=
"doc-xquery30-Param"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Param">Param</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xquery30-EQName">EQName</a> <a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FunctionBody" id=
"doc-xquery30-FunctionBody"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FunctionBody">FunctionBody</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e26444.doc-xquery30-TypeDeclaration" id=
"noid_d3e26444.doc-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>A function declaration specifies whether a function is <a title=
"user-defined function" href="#dt-udf">user-defined</a> or
<a title="external function" href=
"#dt-external-function">external</a>.</p>
<p>[<a name="dt-udf" id="dt-udf" title=
"user-defined function">Definition</a>: <b>User defined
functions</b> are functions that contain a <b>function body</b>,
which provides the implementation of the function as an XQuery
expression.] The <a title="static context" href=
"#dt-static-context">static context</a> for a function body
includes all functions, variables, and namespaces that are declared
or imported anywhere in the <a title="Prolog" href=
"#dt-prolog">Prolog</a>, including the function being declared.
<span>Its <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> component also
includes the parameters of the function being declared. However,
its <a title="context item static type" href=
"#dt-context-item-static-type">context item static type</a>
component is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</span></p>
<p>[<a name="dt-external-function" id="dt-external-function" title=
"external function">Definition</a>: <b>External functions</b> are
functions that are implemented outside the query environment.] For
example, an XQuery implementation might provide a set of external
functions in addition to the core function library described in
<a href="#xpath-functions-30">[XQuery and XPath Functions and
Operators 3.0]</a>. External functions are identified by the
keyword <code>external</code>. The purpose of a function
declaration for an external function is to declare the datatypes of
the function parameters and result, for use in type checking of the
query that contains or imports the function declaration.</p>
<p><span>A function declaration may use the <code>%private</code>
or <code>%public</code> annotations to specify that a function is
public or private; if neither of these annotations is used, the
function is public.</span> [<a name="dt-private-function" id=
"dt-private-function" title="private function">Definition</a>: A
<b>private function</b> is a function with a <code>%private</code>
annotation. A private function is hidden from <a title=
"module import" href="#dt-module-import">module import</a>, which
can not import it into the <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> of another module. ] [<a name="dt-public-function"
id="dt-public-function" title="public function">Definition</a>: A
<b>public function</b> is a function <span>without a
<code>%private</code> annotation</span>. A public function is
accessible to <a title="module import" href=
"#dt-module-import">module import</a>, which can import it into the
<a title="statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> of another module. ] <span>Using
<code>%public</code> and <code>%private</code> annotations in a
main module is not an error, but it does not affect module imports,
since a main module cannot be imported.</span> It is a <a title=
"static error" href="#dt-static-error">static error</a> [<a href=
"#ERRXQST0106" title="err:XQST0106">err:XQST0106</a>] <span>if a
function declaration contains both a <code>%private</code> and a
<code>%public</code> annotation, more than one
<code>%private</code> annotation, or more than one
<code>%public</code> annotation.</span></p>
<p>An XQuery implementation may provide a facility whereby external
functions can be implemented using a host programming language, but
it is not required to do so. If such a facility is provided, the
protocols by which parameters are passed to an external function,
and the result of the function is returned to the invoking query,
are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An XQuery
implementation may augment the type system of <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>
with additional types that are designed to facilitate exchange of
data with host programming languages, or it may provide mechanisms
for the user to define such types. For example, a type might be
provided that encapsulates an object returned by an external
function, such as an SQL database connection. These additional
types, if defined, are considered to be derived by restriction from
<code>xs:anyAtomicType</code>.</p>
<p>An implementation can define annotations, in its own namespace,
to support functionality beyond the scope of this specification.
For instance, an implementation that supports external Java
functions might use an annotation to associate a Java function with
an XQuery external function:</p>
<div class="exampleInner">
<pre>
declare %java:method("java.lang.StrictMath.copySign") function smath:copySign($magnitude, $sign) external;
</pre></div>
<p>Every <span>declared</span> function must be in a namespace;
that is, every declared function name must (when expanded) have a
non-null namespace URI [<a href="#ERRXQST0060" title=
"err:XQST0060">err:XQST0060</a>]. If the function name in a
function declaration has no namespace prefix, it is considered to
be in the <a title="default function namespace" href=
"#dt-def-fn-ns">default function namespace</a>. Every function name
declared in a <a title="library module" href=
"#dt-library-module">library module</a> must (when expanded) be in
the <a title="target namespace" href="#dt-target-namespace">target
namespace</a> of the library module [<a href="#ERRXQST0048" title=
"err:XQST0048">err:XQST0048</a>]. It is a <a title="static error"
href="#dt-static-error">static error</a> [<a href="#ERRXQST0045"
title="err:XQST0045">err:XQST0045</a>] if the function name in a
function declaration (when expanded) is in any of the following
namespaces:</p>
<ul>
<li>
<p><code>http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>http://www.w3.org/2005/xpath-functions/math</code></p>
</li>
<li>
<p><code>http://www.w3.org/2012/xquery</code></p>
</li>
</ul>
<p>In order to allow main modules to declare functions for local
use within the module without defining a new namespace, XQuery
predefines the namespace prefix <code>local</code> to the namespace
<code>http://www.w3.org/2005/xquery-local-functions</code>. It is
suggested (but not required) that this namespace be used for
defining local functions.</p>
<p>If a function parameter is declared using a name but no type,
its default type is <code>item()*</code>. If the result type is
omitted from a function declaration, its default result type is
<code>item()*</code>.</p>
<p>The parameters of a function declaration are considered to be
variables whose scope is the function body. It is an <a title=
"static error" href="#dt-static-error">static error</a> [<a href=
"#ERRXQST0039" title="err:XQST0039">err:XQST0039</a>] for a
function declaration to have more than one parameter with the same
name. The type of a function parameter can be any type that can be
expressed as a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>.</p>
<p>A <code>FunctionDecl</code> defines a function with the
following properties:</p>
<ul>
<li>
<p><b>name</b>: The <code>EQName</code> of the
<code>FunctionDecl</code>, expanded (if necessary) using the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> and
<a title="default function namespace" href="#dt-def-fn-ns">default
function namespace</a> of the module's static context.</p>
</li>
<li>
<p><b>parameter names</b>: The <code>EQName</code>s in the
<code>ParamList</code>, expanded (if necessary) using the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> of the
module's static context.</p>
</li>
<li>
<p><b>signature</b>: A <code>FunctionTest</code> built from the
<code>SequenceType</code>s (explicit or implicit) in the
<code>FunctionDecl</code> and its <code>ParamList</code>, and from
any <code>Annotation</code>s preceding the
<code>FunctionDecl</code>.</p>
</li>
<li>
<p><b>implementation</b>: If the function is declared external,
this property is implementation-dependent. Otherwise, this property
is the <code>FunctionDecl</code>'s <code>FunctionBody</code>.</p>
</li>
<li>
<p><b>nonlocal variable bindings</b>: <span>Empty.</span></p>
</li>
</ul>
<p>The following example illustrates the declaration and use of a
local function that accepts a sequence of <code>employee</code>
elements, summarizes them by department, and returns a sequence of
<code>dept</code> elements.</p>
<ul>
<li>
<p>Using a function, prepare a summary of employees that are
located in Denver.</p>
<div class="exampleInner">
<pre>
declare function local:summary($emps as element(employee)*)
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])
</pre></div>
</li>
</ul>
<p>A function declaration may be recursive—that is, it may
reference itself. Mutually recursive functions, whose bodies
reference each other, are also allowed. The following example
declares a recursive function that computes the maximum depth of a
node hierarchy, and calls the function to find the maximum depth of
a particular document. The function <code>local:depth</code> calls
the built-in functions <code>empty</code> and <code>max</code>,
which are in the default function namespace.</p>
<ul>
<li>
<p>Find the maximum depth of the document named
<code>partlist.xml</code>.</p>
<div class="exampleInner">
<pre>
declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-option-declaration" id=
"id-option-declaration"></a>4.19 Option Declaration</h3>
<p>[<a name="dt-option-declaration" id="dt-option-declaration"
title="option declaration">Definition</a>: An <b>option
declaration</b> declares an option that affects the behavior of a
particular implementation. Each option consists of an identifying
EQName and a StringLiteral.]</p>
<h5><a name="d2e29994" id="d2e29994"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-OptionDecl" id=
"doc-xquery30-OptionDecl"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-OptionDecl">OptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" <a href=
"#doc-xquery30-EQName">EQName</a> <a href=
"#doc-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p>Typically, a particular option will be recognized by some
implementations and not by others. The syntax is designed so that
option declarations can be successfully parsed by all
implementations.</p>
<p>If the EQName of an option is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> with a prefix, it must resolve to a
namespace URI and local name, using the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p>
<p>If the EQName of an option does not have a prefix, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> is in
the <code>http://www.w3.org/2012/xquery</code> namespace<span>,
which is reserved for option declarations defined by the XQuery
family of specifications</span>. <span>XQuery does not currently
define declaration options in this namespace.</span></p>
<p>Each implementation recognizes <span>the
<code>http://www.w3.org/2012/xquery</code> namespace URI and and
all options defined in this namespace in this specification. In
addition, each implementation recognizes</span> an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs <span>and an implementation-defined set of option
names defined in those namespaces</span>. If the namespace part of
an option declaration's name is not recognized, the option
declaration is ignored.</p>
<p>Otherwise, the effect of the option declaration, including its
error behavior, is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. For
example, if the local part of the QName is not recognized, or if
the StringLiteral does not conform to the rules defined by the
implementation for the particular option declaration, the
implementation may choose whether to raise an error, ignore the
option declaration, or take some other action.</p>
<p>Implementations may impose rules on where particular option
declarations may appear relative to variable declarations and
function declarations, and the interpretation of an option
declaration may depend on its position.</p>
<p>An option declaration must not be used to change the syntax
accepted by the processor, or to suppress the detection of
<a title="static error" href="#dt-static-error">static errors</a>.
However, it may be used without restriction to modify the semantics
of the query. The scope of the option declaration is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>—for
example, an option declaration might apply to the whole query, to
the current module, or to the immediately following function
declaration.</p>
<p>The following examples illustrate several possible uses for
option declarations:</p>
<ul>
<li>
<p>This option declaration might be used to specify how comments in
source documents returned by the <code>fn:doc()</code> function
should be handled:</p>
<div class="exampleInner">
<pre>
declare option exq:strip-comments "true";
</pre></div>
</li>
<li>
<p>This option declaration might be used to associate a namespace
used in function names with a Java class:</p>
<div class="exampleInner">
<pre>
declare namespace smath = "http://example.org/MathLibrary";
declare option exq:java-class "smath = java.lang.StrictMath";
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div1">
<h2><a name="id-xquery-conformance" id=
"id-xquery-conformance"></a>5 Conformance</h2>
<p>This section defines the conformance criteria for an XQuery
processor. In this section, the following terms are used to
indicate the requirement levels defined in <a href="#RFC2119">[RFC
2119]</a>. [<a name="must" id="must" title="must">Definition</a>:
<b>MUST</b> means that the item is an absolute requirement of the
specification.] [<a name="mustnot" id="mustnot" title=
"must not">Definition</a>: <b>MUST NOT</b> means that the item is
an absolute prohibition of the specification.] [<a name="may" id=
"may" title="may">Definition</a>: <b>MAY</b> means that an item is
truly optional.] [<a name="should" id="should" title=
"should">Definition</a>: <b>SHOULD</b> means that there may exist
valid reasons in particular circumstances to ignore a particular
item, but the full implications must be understood and carefully
weighed before choosing a different course.]</p>
<p>An XQuery processor that claims to conform to this specification
<a title="must" href="#must">MUST</a> include a claim of Minimal
Conformance as defined in <a href="#id-minimal-conformance"><b>5.1
Minimal Conformance</b></a>. In addition to a claim of Minimal
Conformance, it <a title="may" href="#may">MAY</a> claim
conformance to one or more optional features defined in <a href=
"#id-conform-optional-features"><b>5.2 Optional
Features</b></a>.</p>
<div class="div2">
<h3><a name="id-minimal-conformance" id=
"id-minimal-conformance"></a>5.1 Minimal Conformance</h3>
<p><span>An implementation that claims</span> <b>Minimal
Conformance</b> to this specification <a title="must" href=
"#must">MUST</a> <span>provide</span> all of the following
items:</p>
<ol class="enumar">
<li>
<p><span>An implementation of everything</span> specified in this
document except those features specified in <a href=
"#id-conform-optional-features"><b>5.2 Optional Features</b></a> to
be optional. If an implementation does not provide a given optional
feature, it <a title="must" href="#must">MUST</a> implement any
requirements specified in <a href=
"#id-conform-optional-features"><b>5.2 Optional Features</b></a>
for implementations that do not provide that feature.</p>
</li>
<li>
<p>A definition of every item specified to be <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, unless
that item is part of an optional feature that is not
<span>provided</span> by the implementation. A list of <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> items can
be found in <a href="#id-impl-defined-items"><b>D
Implementation-Defined Items</b></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations are not required to define items specified to be
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
</li>
<li>
<p><span>An implementation of</span> <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>,
as specified in <a href="#id-data-model-conformance"><b>5.3 Data
Model Conformance</b></a>, and a definition of every item specified
to be <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, unless
that item is part of an optional feature that is not
<span>provided</span> by the implementation.</p>
</li>
<li>
<p><span>An implementation of</span> all functions defined in
<a href="#xpath-functions-30">[XQuery and XPath Functions and
Operators 3.0]</a>, and a definition of every item specified to be
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, unless
that <span>function or</span> item is part of an optional feature
that is not <span>provided</span> by the implementation.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-conform-optional-features" id=
"id-conform-optional-features"></a>5.2 Optional Features</h3>
<p>The features discussed in this section are optional. An
implementation <a title="may" href="#may">MAY</a> claim conformance
to one or more of these features.</p>
<p>The description of each feature mentions any errors that may
occur if a query relies on a feature that is not present.</p>
<div class="div3">
<h4><a name="id-schema-aware-feature" id=
"id-schema-aware-feature"></a>5.2.3 Schema Aware Feature</h4>
<p>[<a name="dt-schema-aware-feature" id="dt-schema-aware-feature"
title="schema aware feature">Definition</a>: The <b>Schema Aware
Feature</b> permits the query Prolog to contain a <a title=
"schema import" href="#dt-schema-import">schema import</a>, and
permits a query to contain a <code>validate</code> expression (see
<a href="#id-validate"><b>3.18 Validate Expressions</b></a>). ]</p>
<p>If an XQuery implementation does not <span>provide</span> the
Schema Aware Feature, it <a title="must" href="#must">MUST</a>
raise a static error [<a href="#ERRXQST0009" title=
"err:XQST0009">err:XQST0009</a>] if it encounters a schema import,
and it <a title="must" href="#must">MUST</a> raise a static error
[<a href="#ERRXQST0075" title="err:XQST0075">err:XQST0075</a>] if
it encounters a <code>validate</code> expression.</p>
<p>If an implementation provides the Schema Aware Feature, it
<a title="must" href="#must">MUST</a> also provide the <a href=
"#id-typed-data-feature"><b>5.2.4 Typed Data Feature</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-typed-data-feature" id=
"id-typed-data-feature"></a>5.2.4 Typed Data Feature</h4>
<p>[<a name="dt-typed-data-feature" id="dt-typed-data-feature"
title="typed data feature">Definition</a>: The <b>Typed Data
Feature</b> permits an XDM instance to contain element node types
other than <code>xs:untyped</code> and attributes node types other
than <code>xs:untypedAtomic</code>.]</p>
<p>If an XQuery implementation does not provide the Typed Data
Feature, it <a title="must" href="#must">MUST</a> guarantee
that:</p>
<ol class="enumar">
<li>
<p>The XDM has the type <code>xs:untyped</code> for every element
node and <code>xs:untypedAtomic</code> for every attribute node,
including nodes created by the query.</p>
</li>
<li>
<p>Elements constructed by the query always have the type
<code>xs:untyped</code>; attributes constructed by the query always
have the type <code>xs:untypedAtomic</code>. (This is equivalent to
using <code>construction mode = strip</code>.)</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-static-typing-feature" id=
"id-static-typing-feature"></a>5.2.5 Static Typing Feature</h4>
<p>[<a name="dt-static-typing-feature" id=
"dt-static-typing-feature" title=
"static typing feature">Definition</a>: The <b>Static Typing
Feature</b> requires implementations to report all <a title=
"type error" href="#dt-type-error">type errors</a> during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>.]</p>
<p>If an implementation <span>provide</span>s the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a>, then it <a title="must" href="#must">MUST</a>
raise an error during static analysis whenever the inferred static
type of an expression is not subsumed by the required type for the
context in which it appears.</p>
<p>If an implementation does not <span>provide</span> the <a title=
"static typing feature" href="#dt-static-typing-feature">Static
Typing Feature</a>, then it <a title="may" href="#may">MAY</a>
report type errors during the static analysis phase only in cases
where the inferred static type and the required type have an empty
intersection (that is, where evaluation of the expression is
guaranteed to fail). It <a title="may" href="#may">MAY</a> defer
some or all type checking until the dynamic evaluation phase.</p>
</div>
<div class="div3">
<h4><a name="id-module-feature" id="id-module-feature"></a>5.2.6
Module Feature</h4>
<p>[<a name="dt-module-feature" id="dt-module-feature" title=
"module feature">Definition</a>: <span>The</span> <b>Module
Feature</b> allows a query Prolog to contain a <b>Module Import</b>
and allows <b>library modules</b> to be created.]</p>
<p><span>An</span> implementation that does not
<span>provide</span> the Module Feature <a title="must" href=
"#must">MUST</a> raise a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0016" title=
"err:XQST0016">err:XQST0016</a>] if it encounters a <a title=
"module declaration" href="#dt-module-declaration">module
declaration</a> or a <a title="module import" href=
"#dt-module-import">module import</a>. Since a <a title=
"module declaration" href="#dt-module-declaration">module
declaration</a> is required in a <a title="library module" href=
"#dt-library-module">library module</a>, the Module Feature is
required in order to create a <a title="library module" href=
"#dt-library-module">library module</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the absence of the Module Feature, each query consists of a
single <a title="main module" href="#dt-main-module">main
module</a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization-feature" id=
"id-serialization-feature"></a>5.2.7 Serialization Feature</h4>
<p>[<a name="dt-serialization-feature" id=
"dt-serialization-feature" title=
"serialization feature">Definition</a>: <span>The</span>
<b>Serialization Feature</b> provides means for serializing the
result of a query as specified in <a href=
"#id-serialization"><b>2.2.4 Serialization</b></a>.] A conforming
XQuery implementation that <span>provide</span>s the Serialization
Feature <a title="must" href="#must">MUST</a> conform to <a href=
"#id-serialization"><b>2.2.4 Serialization</b></a>. <span>An
implementation <a title="must" href="#must">MAY</a> provide other
forms of serialization, which do not conform to the Serialization
Feature, and are beyond the scope of this specification.</span></p>
<p>The means by which serialization is invoked is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>If an error is raised during the serialization process as
specified in <a href="#xslt-xquery-serialization-30">[XSLT and
XQuery Serialization 3.0]</a>, <span>an</span> implementation
<a title="must" href="#must">MUST</a> report the error to the
calling environment.</p>
<p><span>An</span> implementation that does not
<span>provide</span> the Serialization Feature <a title="must"
href="#must">MUST NOT</a> raise errors when reading an <a title=
"output declaration" href="#dt-output-declaration">output
declaration</a>, and <a title="must" href="#must">MUST</a>
implement <code>fn:serialize</code>; it <a title="may" href=
"#may">MAY</a>, however, raise an error when
<code>fn:serialize</code> is invoked, as specified in <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-serialize">Section
14.9.3 fn:serialize</a> <sup><small>FO30</small></sup>.
<span>an</span> implementation that does not <span>provide</span>
the Serialization Feature <a title="may" href="#may">MAY</a>
provide results of a query using a vendor-defined
serialization.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Some implementations return query results without serialization.
For instance, an implementation might provide results via an XML
API or a binary representation such as a persistent DOM.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-higher-order-function-feature" id=
"id-higher-order-function-feature"></a>5.2.8 Higher-Order Function
Feature</h4>
<p>[<a name="dt-higher-order-function-feature" id=
"dt-higher-order-function-feature" title=
"higher-order function feature">Definition</a>: The <b>Higher Order
Function Feature</b> allows an expression to evaluate to a
function, and allows dynamic function calls.]</p>
<p>An implementation that does not provide the Higher-Order
Function Feature <a title="must" href="#must">MUST</a> raise a
static error [<a href="#ERRXQST0129" title=
"err:XQST0129">err:XQST0129</a>] if it encounters a <a href=
"#doc-xquery30-FunctionTest">FunctionTest</a>, <a title=
"dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic function call</a>,
<a title="named function reference" href=
"#dt-named-function-ref">named function reference</a>, <a title=
"inline function expression" href="#dt-inline-func">inline function
expression</a>, or <a title="partial function application" href=
"#dt-partial-function-application">partial function
application</a>. Such an implementation <a title="may" href=
"#may">MAY</a> raise a type error [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>] if an expression evaluates to a
sequence that contains a function.</p>
<p>If an implementation provides the Higher-Order Function Feature,
then it must provide <code>fn:function-lookup</code>,
<code>fn:function-name</code>, <code>fn:function-arity</code>,
<code>fn:for-each</code>, <code>fn:filter</code>,
<code>fn:fold-left</code>, <code>fn:fold-right</code>, and
<code>fn:for-each-pair</code>. If an implementation does not
provide the Higher Order Function Feature, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>] if
any of these functions is present in a query.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-data-model-conformance" id=
"id-data-model-conformance"></a>5.3 Data Model Conformance</h3>
<p>All XQuery implementations process data represented in the
<a title="data model" href="#dt-datamodel">data model</a> as
specified in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a>. The data model specification relies on
languages such as XQuery to specify conformance criteria for the
data model in their respective environments, and suggests that the
following issues should be considered:</p>
<ol class="enumar">
<li>
<p><em>Support for normative construction from an infoset.</em>
<span>An</span> implementation <a title="may" href="#may">MAY</a>
choose to claim conformance to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#const-infoset">Section
3.2 Construction from an Infoset</a>
<sup><small>DM30</small></sup>, which defines a normative way to
construct an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> from an XML document
that is merely well-formed or is governed by a DTD.</p>
</li>
<li>
<p><em>Support for normative construction from a PSVI.</em>
<span>An</span> implementation <a title="may" href="#may">MAY</a>
choose to claim conformance to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#const-psvi">Section 3.3
Construction from a PSVI</a> <sup><small>DM30</small></sup>, which
defines a normative way to construct an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a> from an XML
document that is governed by a W3C XML Schema.</p>
</li>
<li>
<p><em>Support for versions of XML and XSD.</em> As stated in
<a href="#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a>, it is recommended (but not required) that the definitions
of primitives such as strings, characters, and names should be
taken from the latest applicable version of the base specifications
in which they are defined; it is implementation-defined which
definitions are used in cases where these differ.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For suggestions on processing XML 1.1 documents <span>with XSD
1.0</span>, see <a href="#xml11schema10">[XML 1.1 and Schema
1.0]</a>.</p>
</div>
</li>
<li>
<p><em>Ranges of data values.</em> In XQuery, the following limits
are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumla">
<li>
<p>For the <code>xs:decimal</code> type, the maximum number of
decimal digits (<code>totalDigits</code> facet) (must be at least
18).</p>
</li>
<li>
<p>For the types <code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <code>xs:gYear</code>, and
<code>xs:gYearMonth</code>: the maximum value of the year component
and the maximum number of fractional second digits (must be at
least 3).</p>
</li>
<li>
<p>For the <code>xs:duration type</code>: the maximum absolute
values of the years, months, days, hours, minutes, and seconds
components.</p>
</li>
<li>
<p>For the <code>xs:yearMonthDuration</code> type: the maximum
absolute value, expressed as an integer number of months.</p>
</li>
<li>
<p>For the <code>xs:dayTimeDuration</code> type: the maximum
absolute value, expressed as a decimal number of seconds.</p>
</li>
<li>
<p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
<code>xs:base64Binary</code>, <code>xs:QName</code>,
<code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived
from them: limitations (if any) imposed by the implementation on
lengths of values.</p>
</li>
</ol>
<p>The limits listed above need not be fixed, but may depend on
environmental factors such as system resources. For example, the
length of a value of type <code>xs:string</code> may be limited by
available memory.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For discussion of errors due to <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> limits,
see <a href="#id-kinds-of-errors"><b>2.3.1 Kinds of
Errors</b></a>.</p>
</div>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-syntax-extensions" id=
"id-syntax-extensions"></a>5.4 Syntax Extensions</h3>
<p>Any syntactic extensions to XQuery are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. The effect
of syntactic extensions, including their error behavior, is
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. Syntactic
extensions may be used without restriction to modify the semantics
of a XQuery expression.</p>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="nt-bnf" id="nt-bnf"></a>A XQuery 3.0 Grammar</h2>
<div class="div2">
<h3><a name="id-grammar" id="id-grammar"></a>A.1 EBNF</h3>
<p>The grammar of XQuery 3.0 uses the same simple Extended
Backus-Naur Form (EBNF) notation as <a href="#XML">[XML 1.0]</a>
with the following minor differences.</p>
<ul>
<li>
<p>All named symbols have a name that begins with an uppercase
letter.</p>
</li>
<li>
<p>It adds a notation for referring to productions in external
specs.</p>
</li>
<li>
<p>Comments or extra-grammatical constraints on grammar productions
are between '/*' and '*/' symbols.</p>
<ul>
<li>
<p>A 'xgc:' prefix is an extra-grammatical constraint, the details
of which are explained in <a href=
"#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical
Constraints</b></a></p>
</li>
<li>
<p>A 'ws:' prefix explains the whitespace rules for the production,
the details of which are explained in <a href=
"#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a></p>
</li>
<li>
<p>A 'gn:' prefix means a 'Grammar Note', and is meant as a
clarification for parsing rules, and is explained in <a href=
"#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>. These notes are
not normative.</p>
</li>
</ul>
</li>
</ul>
<p>The terminal symbols for this grammar include the quoted strings
used in the production rules below, and the terminal symbols
defined in section <a href="#terminal-symbols"><b>A.2.1 Terminal
Symbols</b></a>.</p>
<p>The EBNF notation is described in more detail in <a href=
"#EBNFNotation"><b>A.1.1 Notation</b></a>.</p>
<p>To increase readability, the EBNF in the main body of this
document omits some of these notational features. This appendix is
the normative version of the EBNF.</p>
<h5><a name="BNF-Grammar" id="BNF-Grammar"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Module" id=
"prod-xquery30-Module"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Module">Module</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-VersionDecl">VersionDecl</a>?
(<a href="#prod-xquery30-LibraryModule">LibraryModule</a> |
<a href="#prod-xquery30-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VersionDecl" id=
"prod-xquery30-VersionDecl"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-VersionDecl">VersionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"xquery" (("encoding" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>) | ("version"
<a href="#prod-xquery30-StringLiteral">StringLiteral</a>
("encoding" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)?)) <a href=
"#prod-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-MainModule" id=
"prod-xquery30-MainModule"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-MainModule">MainModule</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Prolog">Prolog</a> <a href=
"#prod-xquery30-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LibraryModule" id=
"prod-xquery30-LibraryModule"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-LibraryModule">LibraryModule</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ModuleDecl">ModuleDecl</a>
<a href="#prod-xquery30-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ModuleDecl" id=
"prod-xquery30-ModuleDecl"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ModuleDecl">ModuleDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> <a href=
"#prod-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Prolog" id=
"prod-xquery30-Prolog"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Prolog">Prolog</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href=
"#prod-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#prod-xquery30-Setter">Setter</a> | <a href=
"#prod-xquery30-NamespaceDecl">NamespaceDecl</a> | <a href=
"#prod-xquery30-Import">Import</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)* ((<a href=
"#prod-xquery30-ContextItemDecl">ContextItemDecl</a> | <a href=
"#prod-xquery30-AnnotatedDecl">AnnotatedDecl</a> | <a href=
"#prod-xquery30-OptionDecl">OptionDecl</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Separator" id=
"prod-xquery30-Separator"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Separator">Separator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Setter" id=
"prod-xquery30-Setter"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Setter">Setter</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#prod-xquery30-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#prod-xquery30-BaseURIDecl">BaseURIDecl</a> | <a href=
"#prod-xquery30-ConstructionDecl">ConstructionDecl</a> | <a href=
"#prod-xquery30-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#prod-xquery30-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#prod-xquery30-CopyNamespacesDecl">CopyNamespacesDecl</a> |
<a href=
"#prod-xquery30-DecimalFormatDecl">DecimalFormatDecl</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BoundarySpaceDecl" id=
"prod-xquery30-BoundarySpaceDecl"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-BoundarySpaceDecl">BoundarySpaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DefaultCollationDecl" id=
"prod-xquery30-DefaultCollationDecl"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DefaultCollationDecl">DefaultCollationDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BaseURIDecl" id=
"prod-xquery30-BaseURIDecl"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-BaseURIDecl">BaseURIDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ConstructionDecl" id=
"prod-xquery30-ConstructionDecl"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ConstructionDecl">ConstructionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderingModeDecl" id=
"prod-xquery30-OrderingModeDecl"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderingModeDecl">OrderingModeDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EmptyOrderDecl" id=
"prod-xquery30-EmptyOrderDecl"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-EmptyOrderDecl">EmptyOrderDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CopyNamespacesDecl" id=
"prod-xquery30-CopyNamespacesDecl"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#prod-xquery30-PreserveMode">PreserveMode</a> "," <a href=
"#prod-xquery30-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PreserveMode" id=
"prod-xquery30-PreserveMode"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PreserveMode">PreserveMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InheritMode" id=
"prod-xquery30-InheritMode"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-InheritMode">InheritMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DecimalFormatDecl" id=
"prod-xquery30-DecimalFormatDecl"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DecimalFormatDecl">DecimalFormatDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" (("decimal-format" <a href=
"#prod-xquery30-EQName">EQName</a>) | ("default" "decimal-format"))
(<a href="#prod-xquery30-DFPropertyName">DFPropertyName</a> "="
<a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DFPropertyName" id=
"prod-xquery30-DFPropertyName"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DFPropertyName">DFPropertyName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"decimal-separator" | "grouping-separator" | "infinity" |
"minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" |
"digit" | "pattern-separator"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Import" id=
"prod-xquery30-Import"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Import">Import</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-SchemaImport">SchemaImport</a> |
<a href="#prod-xquery30-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaImport" id=
"prod-xquery30-SchemaImport"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SchemaImport">SchemaImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#prod-xquery30-SchemaPrefix">SchemaPrefix</a>? <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaPrefix" id=
"prod-xquery30-SchemaPrefix"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SchemaPrefix">SchemaPrefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xquery30-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ModuleImport" id=
"prod-xquery30-ModuleImport"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ModuleImport">ModuleImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=")? <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamespaceDecl" id=
"prod-xquery30-NamespaceDecl"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-NamespaceDecl">NamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DefaultNamespaceDecl" id=
"prod-xquery30-DefaultNamespaceDecl"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnnotatedDecl" id=
"prod-xquery30-AnnotatedDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AnnotatedDecl">AnnotatedDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" <a href=
"#prod-xquery30-Annotation">Annotation</a>* (<a href=
"#prod-xquery30-VarDecl">VarDecl</a> | <a href=
"#prod-xquery30-FunctionDecl">FunctionDecl</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Annotation" id=
"prod-xquery30-Annotation"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Annotation">Annotation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"%" <a href="#prod-xquery30-EQName">EQName</a> ("("
<a href="#prod-xquery30-Literal">Literal</a> ("," <a href=
"#prod-xquery30-Literal">Literal</a>)* ")")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarDecl" id=
"prod-xquery30-VarDecl"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-VarDecl">VarDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"variable" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? ((":="
<a href="#prod-xquery30-VarValue">VarValue</a>) | ("external" (":="
<a href=
"#prod-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarValue" id=
"prod-xquery30-VarValue"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-VarValue">VarValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarDefaultValue" id=
"prod-xquery30-VarDefaultValue"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-VarDefaultValue">VarDefaultValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContextItemDecl" id=
"prod-xquery30-ContextItemDecl"></a>[31]&#160;&#160;&#160;</td>
<td><code>ContextItemDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "context" "item" ("as" <a href=
"#prod-xquery30-ItemType">ItemType</a>)? ((":=" <a href=
"#prod-xquery30-VarValue">VarValue</a>) | ("external" (":="
<a href="#prod-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionDecl" id=
"prod-xquery30-FunctionDecl"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FunctionDecl">FunctionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" <a href="#prod-xquery30-EQName">EQName</a> "("
<a href="#prod-xquery30-ParamList">ParamList</a>? ")" ("as"
<a href="#prod-xquery30-SequenceType">SequenceType</a>)? (<a href=
"#prod-xquery30-FunctionBody">FunctionBody</a> |
"external")</code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgc:
reserved-function-names</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParamList" id=
"prod-xquery30-ParamList"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ParamList">ParamList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Param">Param</a> ("," <a href=
"#prod-xquery30-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Param" id=
"prod-xquery30-Param"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Param">Param</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionBody" id=
"prod-xquery30-FunctionBody"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FunctionBody">FunctionBody</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EnclosedExpr" id=
"prod-xquery30-EnclosedExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OptionDecl" id=
"prod-xquery30-OptionDecl"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OptionDecl">OptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" <a href=
"#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QueryBody" id=
"prod-xquery30-QueryBody"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-QueryBody">QueryBody</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Expr" id=
"prod-xquery30-Expr"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a> (","
<a href="#prod-xquery30-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ExprSingle" id=
"prod-xquery30-ExprSingle"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FLWORExpr">FLWORExpr</a><br />
| <a href="#prod-xquery30-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xquery30-SwitchExpr">SwitchExpr</a><br />
| <a href="#prod-xquery30-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#prod-xquery30-IfExpr">IfExpr</a><br />
| <a href="#prod-xquery30-TryCatchExpr">TryCatchExpr</a><br />
| <a href="#prod-xquery30-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FLWORExpr" id=
"prod-xquery30-FLWORExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FLWORExpr">FLWORExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-InitialClause">InitialClause</a>
<a href="#prod-xquery30-IntermediateClause">IntermediateClause</a>*
<a href="#prod-xquery30-ReturnClause">ReturnClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InitialClause" id=
"prod-xquery30-InitialClause"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-InitialClause">InitialClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ForClause">ForClause</a> |
<a href="#prod-xquery30-LetClause">LetClause</a> | <a href=
"#prod-xquery30-WindowClause">WindowClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntermediateClause" id=
"prod-xquery30-IntermediateClause"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-IntermediateClause">IntermediateClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-InitialClause">InitialClause</a>
| <a href="#prod-xquery30-WhereClause">WhereClause</a> | <a href=
"#prod-xquery30-GroupByClause">GroupByClause</a> | <a href=
"#prod-xquery30-OrderByClause">OrderByClause</a> | <a href=
"#prod-xquery30-CountClause">CountClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForClause" id=
"prod-xquery30-ForClause"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href="#prod-xquery30-ForBinding">ForBinding</a>
("," <a href=
"#prod-xquery30-ForBinding">ForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForBinding" id=
"prod-xquery30-ForBinding"></a>[45]&#160;&#160;&#160;</td>
<td><code>ForBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? <a href=
"#prod-xquery30-AllowingEmpty">AllowingEmpty</a>? <a href=
"#prod-xquery30-PositionalVar">PositionalVar</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AllowingEmpty" id=
"prod-xquery30-AllowingEmpty"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AllowingEmpty">AllowingEmpty</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"allowing" "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PositionalVar" id=
"prod-xquery30-PositionalVar"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PositionalVar">PositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LetClause" id=
"prod-xquery30-LetClause"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href="#prod-xquery30-LetBinding">LetBinding</a>
("," <a href=
"#prod-xquery30-LetBinding">LetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LetBinding" id=
"prod-xquery30-LetBinding"></a>[49]&#160;&#160;&#160;</td>
<td><code>LetBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowClause" id=
"prod-xquery30-WindowClause"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-WindowClause">WindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" (<a href=
"#prod-xquery30-TumblingWindowClause">TumblingWindowClause</a> |
<a href=
"#prod-xquery30-SlidingWindowClause">SlidingWindowClause</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TumblingWindowClause" id=
"prod-xquery30-TumblingWindowClause"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TumblingWindowClause">TumblingWindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"tumbling" "window" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> <a href=
"#prod-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#prod-xquery30-WindowEndCondition">WindowEndCondition</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SlidingWindowClause" id=
"prod-xquery30-SlidingWindowClause"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SlidingWindowClause">SlidingWindowClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sliding" "window" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> <a href=
"#prod-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#prod-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowStartCondition" id=
"prod-xquery30-WindowStartCondition"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-WindowStartCondition">WindowStartCondition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"start" <a href=
"#prod-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowEndCondition" id=
"prod-xquery30-WindowEndCondition"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"only"? "end" <a href=
"#prod-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowVars" id=
"prod-xquery30-WindowVars"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-WindowVars">WindowVars</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" <a href=
"#prod-xquery30-CurrentItem">CurrentItem</a>)? <a href=
"#prod-xquery30-PositionalVar">PositionalVar</a>? ("previous" "$"
<a href="#prod-xquery30-PreviousItem">PreviousItem</a>)? ("next"
"$" <a href="#prod-xquery30-NextItem">NextItem</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CurrentItem" id=
"prod-xquery30-CurrentItem"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CurrentItem">CurrentItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PreviousItem" id=
"prod-xquery30-PreviousItem"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PreviousItem">PreviousItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NextItem" id=
"prod-xquery30-NextItem"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NextItem">NextItem</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CountClause" id=
"prod-xquery30-CountClause"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CountClause">CountClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"count" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WhereClause" id=
"prod-xquery30-WhereClause"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-WhereClause">WhereClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"where" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupByClause" id=
"prod-xquery30-GroupByClause"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupByClause">GroupByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"group" "by" <a href=
"#prod-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingSpecList" id=
"prod-xquery30-GroupingSpecList"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-GroupingSpec">GroupingSpec</a>
("," <a href=
"#prod-xquery30-GroupingSpec">GroupingSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingSpec" id=
"prod-xquery30-GroupingSpec"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupingSpec">GroupingSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupingVariable">GroupingVariable</a> (<a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a>)? ("collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingVariable" id=
"prod-xquery30-GroupingVariable"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GroupingVariable">GroupingVariable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderByClause" id=
"prod-xquery30-OrderByClause"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderByClause">OrderByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#prod-xquery30-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderSpecList" id=
"prod-xquery30-OrderSpecList"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderSpecList">OrderSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-OrderSpec">OrderSpec</a> (","
<a href="#prod-xquery30-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderSpec" id=
"prod-xquery30-OrderSpec"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderSpec">OrderSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a>
<a href=
"#prod-xquery30-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderModifier" id=
"prod-xquery30-OrderModifier"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderModifier">OrderModifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReturnClause" id=
"prod-xquery30-ReturnClause"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ReturnClause">ReturnClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"return" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuantifiedExpr" id=
"prod-xquery30-QuantifiedExpr"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchExpr" id=
"prod-xquery30-SwitchExpr"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SwitchExpr">SwitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"switch" "(" <a href="#prod-xquery30-Expr">Expr</a> ")"
<a href="#prod-xquery30-SwitchCaseClause">SwitchCaseClause</a>+
"default" "return" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchCaseClause" id=
"prod-xquery30-SwitchCaseClause"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SwitchCaseClause">SwitchCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" <a href=
"#prod-xquery30-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchCaseOperand" id=
"prod-xquery30-SwitchCaseOperand"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SwitchCaseOperand">SwitchCaseOperand</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeswitchExpr" id=
"prod-xquery30-TypeswitchExpr"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TypeswitchExpr">TypeswitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#prod-xquery30-Expr">Expr</a>
")" <a href="#prod-xquery30-CaseClause">CaseClause</a>+ "default"
("$" <a href="#prod-xquery30-VarName">VarName</a>)? "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CaseClause" id=
"prod-xquery30-CaseClause"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CaseClause">CaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" ("$" <a href="#prod-xquery30-VarName">VarName</a>
"as")? <a href=
"#prod-xquery30-SequenceTypeUnion">SequenceTypeUnion</a> "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SequenceTypeUnion" id=
"prod-xquery30-SequenceTypeUnion"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SequenceTypeUnion">SequenceTypeUnion</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-SequenceType">SequenceType</a>
("|" <a href=
"#prod-xquery30-SequenceType">SequenceType</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IfExpr" id=
"prod-xquery30-IfExpr"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xquery30-Expr">Expr</a> ")"
"then" <a href="#prod-xquery30-ExprSingle">ExprSingle</a> "else"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryCatchExpr" id=
"prod-xquery30-TryCatchExpr"></a>[78]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TryCatchExpr">TryCatchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-TryClause">TryClause</a> <a href=
"#prod-xquery30-CatchClause">CatchClause</a>+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryClause" id=
"prod-xquery30-TryClause"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TryClause">TryClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"try" "{" <a href=
"#prod-xquery30-TryTargetExpr">TryTargetExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryTargetExpr" id=
"prod-xquery30-TryTargetExpr"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TryTargetExpr">TryTargetExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CatchClause" id=
"prod-xquery30-CatchClause"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CatchClause">CatchClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"catch" <a href=
"#prod-xquery30-CatchErrorList">CatchErrorList</a> "{" <a href=
"#prod-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CatchErrorList" id=
"prod-xquery30-CatchErrorList"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CatchErrorList">CatchErrorList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-NameTest">NameTest</a> ("|"
<a href="#prod-xquery30-NameTest">NameTest</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrExpr" id=
"prod-xquery30-OrExpr"></a>[83]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AndExpr">AndExpr</a> ( "or"
<a href="#prod-xquery30-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AndExpr" id=
"prod-xquery30-AndExpr"></a>[84]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a> ( "and" <a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ComparisonExpr" id=
"prod-xquery30-ComparisonExpr"></a>[85]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringConcatExpr">StringConcatExpr</a> ( (<a href=
"#prod-xquery30-ValueComp">ValueComp</a><br />
| <a href="#prod-xquery30-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xquery30-NodeComp">NodeComp</a>) <a href=
"#prod-xquery30-StringConcatExpr">StringConcatExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StringConcatExpr" id=
"prod-xquery30-StringConcatExpr"></a>[86]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-StringConcatExpr">StringConcatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-RangeExpr">RangeExpr</a> ( "||"
<a href="#prod-xquery30-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-RangeExpr" id=
"prod-xquery30-RangeExpr"></a>[87]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AdditiveExpr" id=
"prod-xquery30-AdditiveExpr"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xquery30-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-MultiplicativeExpr" id=
"prod-xquery30-MultiplicativeExpr"></a>[89]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xquery30-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnionExpr" id=
"prod-xquery30-UnionExpr"></a>[90]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xquery30-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntersectExceptExpr" id=
"prod-xquery30-IntersectExceptExpr"></a>[91]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InstanceofExpr">InstanceofExpr</a> ( ("intersect" |
"except") <a href=
"#prod-xquery30-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InstanceofExpr" id=
"prod-xquery30-InstanceofExpr"></a>[92]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#prod-xquery30-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TreatExpr" id=
"prod-xquery30-TreatExpr"></a>[93]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xquery30-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CastableExpr" id=
"prod-xquery30-CastableExpr"></a>[94]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-CastExpr">CastExpr</a> (
"castable" "as" <a href="#prod-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CastExpr" id=
"prod-xquery30-CastExpr"></a>[95]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnaryExpr" id=
"prod-xquery30-UnaryExpr"></a>[96]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xquery30-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValueExpr" id=
"prod-xquery30-ValueExpr"></a>[97]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ValidateExpr">ValidateExpr</a> |
<a href="#prod-xquery30-ExtensionExpr">ExtensionExpr</a> | <a href=
"#prod-xquery30-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GeneralComp" id=
"prod-xquery30-GeneralComp"></a>[98]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValueComp" id=
"prod-xquery30-ValueComp"></a>[99]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NodeComp" id=
"prod-xquery30-NodeComp"></a>[100]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValidateExpr" id=
"prod-xquery30-ValidateExpr"></a>[101]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ValidateExpr">ValidateExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" (<a href=
"#prod-xquery30-ValidationMode">ValidationMode</a> | ("type"
<a href="#prod-xquery30-TypeName">TypeName</a>))? "{" <a href=
"#prod-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValidationMode" id=
"prod-xquery30-ValidationMode"></a>[102]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ValidationMode">ValidationMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ExtensionExpr" id=
"prod-xquery30-ExtensionExpr"></a>[103]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ExtensionExpr">ExtensionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Pragma">Pragma</a>+ "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Pragma" id=
"prod-xquery30-Pragma"></a>[104]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Pragma">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xquery30-S">S</a>? <a href=
"#prod-xquery30-EQName">EQName</a> (<a href=
"#prod-xquery30-S">S</a> <a href=
"#prod-xquery30-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PragmaContents" id=
"prod-xquery30-PragmaContents"></a>[105]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PragmaContents">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SimpleMapExpr" id=
"prod-xquery30-SimpleMapExpr"></a>[106]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SimpleMapExpr">SimpleMapExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PathExpr">PathExpr</a> ("!"
<a href="#prod-xquery30-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PathExpr" id=
"prod-xquery30-PathExpr"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">xgc:
leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-RelativePathExpr" id=
"prod-xquery30-RelativePathExpr"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-StepExpr">StepExpr</a> (("/" |
"//") <a href="#prod-xquery30-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StepExpr" id=
"prod-xquery30-StepExpr"></a>[109]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PostfixExpr">PostfixExpr</a> |
<a href="#prod-xquery30-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AxisStep" id=
"prod-xquery30-AxisStep"></a>[110]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ReverseStep">ReverseStep</a> |
<a href="#prod-xquery30-ForwardStep">ForwardStep</a>) <a href=
"#prod-xquery30-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForwardStep" id=
"prod-xquery30-ForwardStep"></a>[111]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ForwardAxis">ForwardAxis</a>
<a href="#prod-xquery30-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForwardAxis" id=
"prod-xquery30-ForwardAxis"></a>[112]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AbbrevForwardStep" id=
"prod-xquery30-AbbrevForwardStep"></a>[113]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xquery30-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReverseStep" id=
"prod-xquery30-ReverseStep"></a>[114]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ReverseAxis">ReverseAxis</a>
<a href="#prod-xquery30-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReverseAxis" id=
"prod-xquery30-ReverseAxis"></a>[115]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AbbrevReverseStep" id=
"prod-xquery30-AbbrevReverseStep"></a>[116]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NodeTest" id=
"prod-xquery30-NodeTest"></a>[117]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-KindTest">KindTest</a> | <a href=
"#prod-xquery30-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NameTest" id=
"prod-xquery30-NameTest"></a>[118]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> | <a href=
"#prod-xquery30-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Wildcard" id=
"prod-xquery30-Wildcard"></a>[119]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery30-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery30-NCName">NCName</a>)<br />
| (<a href="#prod-xquery30-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PostfixExpr" id=
"prod-xquery30-PostfixExpr"></a>[120]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PostfixExpr">PostfixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PrimaryExpr">PrimaryExpr</a>
(<a href="#prod-xquery30-Predicate">Predicate</a> | <a href=
"#prod-xquery30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ArgumentList" id=
"prod-xquery30-ArgumentList"></a>[121]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ArgumentList">ArgumentList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#prod-xquery30-Argument">Argument</a> (","
<a href="#prod-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PredicateList" id=
"prod-xquery30-PredicateList"></a>[122]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Predicate" id=
"prod-xquery30-Predicate"></a>[123]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xquery30-Expr">Expr</a>
"]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PrimaryExpr" id=
"prod-xquery30-PrimaryExpr"></a>[124]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Literal">Literal</a><br />
| <a href="#prod-xquery30-VarRef">VarRef</a><br />
| <a href=
"#prod-xquery30-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href=
"#prod-xquery30-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#prod-xquery30-FunctionCall">FunctionCall</a><br />
| <a href="#prod-xquery30-OrderedExpr">OrderedExpr</a><br />
| <a href="#prod-xquery30-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#prod-xquery30-Constructor">Constructor</a><br />
| <a href=
"#prod-xquery30-FunctionItemExpr">FunctionItemExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Literal" id=
"prod-xquery30-Literal"></a>[125]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NumericLiteral">NumericLiteral</a> | <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NumericLiteral" id=
"prod-xquery30-NumericLiteral"></a>[126]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a> | <a href=
"#prod-xquery30-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xquery30-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarRef" id=
"prod-xquery30-VarRef"></a>[127]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarName" id=
"prod-xquery30-VarName"></a>[128]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParenthesizedExpr" id=
"prod-xquery30-ParenthesizedExpr"></a>[129]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xquery30-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContextItemExpr" id=
"prod-xquery30-ContextItemExpr"></a>[130]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderedExpr" id=
"prod-xquery30-OrderedExpr"></a>[131]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OrderedExpr">OrderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnorderedExpr" id=
"prod-xquery30-UnorderedExpr"></a>[132]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-UnorderedExpr">UnorderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionCall" id=
"prod-xquery30-FunctionCall"></a>[133]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-ArgumentList">ArgumentList</a></code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgc:
reserved-function-names</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Argument" id=
"prod-xquery30-Argument"></a>[134]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Argument">Argument</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a> |
<a href=
"#prod-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ArgumentPlaceholder" id=
"prod-xquery30-ArgumentPlaceholder"></a>[135]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Constructor" id=
"prod-xquery30-Constructor"></a>[136]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-Constructor">Constructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#prod-xquery30-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirectConstructor" id=
"prod-xquery30-DirectConstructor"></a>[137]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#prod-xquery30-DirCommentConstructor">DirCommentConstructor</a><br />

| <a href=
"#prod-xquery30-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirElemConstructor" id=
"prod-xquery30-DirElemConstructor"></a>[138]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirElemConstructor">DirElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;" <a href="#prod-xquery30-QName">QName</a> <a href=
"#prod-xquery30-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#prod-xquery30-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#prod-xquery30-QName">QName</a> <a href=
"#prod-xquery30-S">S</a>? "&gt;"))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirAttributeList" id=
"prod-xquery30-DirAttributeList"></a>[139]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirAttributeList">DirAttributeList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-S">S</a> (<a href=
"#prod-xquery30-QName">QName</a> <a href="#prod-xquery30-S">S</a>?
"=" <a href="#prod-xquery30-S">S</a>? <a href=
"#prod-xquery30-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirAttributeValue" id=
"prod-xquery30-DirAttributeValue"></a>[140]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirAttributeValue">DirAttributeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xquery30-EscapeQuot">EscapeQuot</a>
| <a href=
"#prod-xquery30-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#prod-xquery30-EscapeApos">EscapeApos</a> |
<a href=
"#prod-xquery30-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuotAttrValueContent" id=
"prod-xquery30-QuotAttrValueContent"></a>[141]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-QuotAttrValueContent">QuotAttrValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href=
"#prod-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AposAttrValueContent" id=
"prod-xquery30-AposAttrValueContent"></a>[142]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AposAttrValueContent">AposAttrValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href=
"#prod-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirElemContent" id=
"prod-xquery30-DirElemContent"></a>[143]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirElemContent">DirElemContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href="#prod-xquery30-CDataSection">CDataSection</a><br />
| <a href="#prod-xquery30-CommonContent">CommonContent</a><br />
| <a href=
"#prod-xquery30-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommonContent" id=
"prod-xquery30-CommonContent"></a>[144]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CommonContent">CommonContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | "{{" | "}}" |
<a href="#prod-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirCommentConstructor" id=
"prod-xquery30-DirCommentConstructor"></a>[145]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirCommentConstructor">DirCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;!--" <a href=
"#prod-xquery30-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirCommentContents" id=
"prod-xquery30-DirCommentContents"></a>[146]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirCommentContents">DirCommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href="#prod-xquery30-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery30-Char">Char</a> - '-')))*</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirPIConstructor" id=
"prod-xquery30-DirPIConstructor"></a>[147]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirPIConstructor">DirPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;?" <a href="#prod-xquery30-PITarget">PITarget</a>
(<a href="#prod-xquery30-S">S</a> <a href=
"#prod-xquery30-DirPIContents">DirPIContents</a>)?
"?&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirPIContents" id=
"prod-xquery30-DirPIContents"></a>[148]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DirPIContents">DirPIContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CDataSection" id=
"prod-xquery30-CDataSection"></a>[149]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CDataSection">CDataSection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;![CDATA[" <a href=
"#prod-xquery30-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CDataSectionContents" id=
"prod-xquery30-CDataSectionContents"></a>[150]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CDataSectionContents">CDataSectionContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char*
']]&gt;' Char*))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ComputedConstructor" id=
"prod-xquery30-ComputedConstructor"></a>[151]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ComputedConstructor">ComputedConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#prod-xquery30-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#prod-xquery30-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#prod-xquery30-CompNamespaceConstructor">CompNamespaceConstructor</a><br />

| <a href=
"#prod-xquery30-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#prod-xquery30-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#prod-xquery30-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompDocConstructor" id=
"prod-xquery30-CompDocConstructor"></a>[152]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompDocConstructor">CompDocConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompElemConstructor" id=
"prod-xquery30-CompElemConstructor"></a>[153]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompElemConstructor">CompElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (<a href="#prod-xquery30-EQName">EQName</a> |
("{" <a href="#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContentExpr" id=
"prod-xquery30-ContentExpr"></a>[154]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ContentExpr">ContentExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompAttrConstructor" id=
"prod-xquery30-CompAttrConstructor"></a>[155]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompAttrConstructor">CompAttrConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (<a href="#prod-xquery30-EQName">EQName</a> |
("{" <a href="#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompNamespaceConstructor" id=
"prod-xquery30-CompNamespaceConstructor"></a>[156]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" (<a href="#prod-xquery30-Prefix">Prefix</a> |
("{" <a href="#prod-xquery30-PrefixExpr">PrefixExpr</a> "}")) "{"
<a href="#prod-xquery30-URIExpr">URIExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Prefix" id=
"prod-xquery30-Prefix"></a>[157]&#160;&#160;&#160;</td>
<td><code>Prefix</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-NCName">NCName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PrefixExpr" id=
"prod-xquery30-PrefixExpr"></a>[158]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PrefixExpr">PrefixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URIExpr" id=
"prod-xquery30-URIExpr"></a>[159]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-URIExpr">URIExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompTextConstructor" id=
"prod-xquery30-CompTextConstructor"></a>[160]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompTextConstructor">CompTextConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompCommentConstructor" id=
"prod-xquery30-CompCommentConstructor"></a>[161]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompCommentConstructor">CompCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompPIConstructor" id=
"prod-xquery30-CompPIConstructor"></a>[162]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CompPIConstructor">CompPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery30-NCName">NCName</a> | ("{" <a href=
"#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionItemExpr" id=
"prod-xquery30-FunctionItemExpr"></a>[163]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FunctionItemExpr">FunctionItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#prod-xquery30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamedFunctionRef" id=
"prod-xquery30-NamedFunctionRef"></a>[164]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-NamedFunctionRef">NamedFunctionRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> "#" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a></code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgc:
reserved-function-names</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InlineFunctionExpr" id=
"prod-xquery30-InlineFunctionExpr"></a>[165]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Annotation">Annotation</a>*
"function" "(" <a href="#prod-xquery30-ParamList">ParamList</a>?
")" ("as" <a href="#prod-xquery30-SequenceType">SequenceType</a>)?
<a href="#prod-xquery30-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SingleType" id=
"prod-xquery30-SingleType"></a>[166]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SimpleTypeName">SimpleTypeName</a> "?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeDeclaration" id=
"prod-xquery30-TypeDeclaration"></a>[167]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TypeDeclaration">TypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#prod-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SequenceType" id=
"prod-xquery30-SequenceType"></a>[168]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xquery30-ItemType">ItemType</a> <a href=
"#prod-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OccurrenceIndicator" id=
"prod-xquery30-OccurrenceIndicator"></a>[169]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <a href="#parse-note-occurrence-indicators">xgc:
occurrence-indicators</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ItemType" id=
"prod-xquery30-ItemType"></a>[170]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#prod-xquery30-FunctionTest">FunctionTest</a> |
<a href="#prod-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> |
<a href=
"#prod-xquery30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AtomicOrUnionType" id=
"prod-xquery30-AtomicOrUnionType"></a>[171]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-KindTest" id=
"prod-xquery30-KindTest"></a>[172]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xquery30-ElementTest">ElementTest</a><br />
| <a href="#prod-xquery30-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xquery30-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xquery30-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xquery30-PITest">PITest</a><br />
| <a href="#prod-xquery30-CommentTest">CommentTest</a><br />
| <a href="#prod-xquery30-TextTest">TextTest</a><br />
| <a href=
"#prod-xquery30-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#prod-xquery30-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnyKindTest" id=
"prod-xquery30-AnyKindTest"></a>[173]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DocumentTest" id=
"prod-xquery30-DocumentTest"></a>[174]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xquery30-ElementTest">ElementTest</a> | <a href=
"#prod-xquery30-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TextTest" id=
"prod-xquery30-TextTest"></a>[175]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommentTest" id=
"prod-xquery30-CommentTest"></a>[176]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamespaceNodeTest" id=
"prod-xquery30-NamespaceNodeTest"></a>[177]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PITest" id=
"prod-xquery30-PITest"></a>[178]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery30-NCName">NCName</a> | <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeTest" id=
"prod-xquery30-AttributeTest"></a>[179]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xquery30-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttribNameOrWildcard" id=
"prod-xquery30-AttribNameOrWildcard"></a>[180]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AttributeName">AttributeName</a>
| "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaAttributeTest" id=
"prod-xquery30-SchemaAttributeTest"></a>[181]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xquery30-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeDeclaration" id=
"prod-xquery30-AttributeDeclaration"></a>[182]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementTest" id=
"prod-xquery30-ElementTest"></a>[183]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#prod-xquery30-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementNameOrWildcard" id=
"prod-xquery30-ElementNameOrWildcard"></a>[184]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaElementTest" id=
"prod-xquery30-SchemaElementTest"></a>[185]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xquery30-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementDeclaration" id=
"prod-xquery30-ElementDeclaration"></a>[186]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeName" id=
"prod-xquery30-AttributeName"></a>[187]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementName" id=
"prod-xquery30-ElementName"></a>[188]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SimpleTypeName" id=
"prod-xquery30-SimpleTypeName"></a>[189]&#160;&#160;&#160;</td>
<td><code>SimpleTypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeName" id=
"prod-xquery30-TypeName"></a>[190]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionTest" id=
"prod-xquery30-FunctionTest"></a>[191]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FunctionTest">FunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Annotation">Annotation</a>*
(<a href="#prod-xquery30-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#prod-xquery30-TypedFunctionTest">TypedFunctionTest</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnyFunctionTest" id=
"prod-xquery30-AnyFunctionTest"></a>[192]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AnyFunctionTest">AnyFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypedFunctionTest" id=
"prod-xquery30-TypedFunctionTest"></a>[193]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-TypedFunctionTest">TypedFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#prod-xquery30-SequenceType">SequenceType</a> ("," <a href=
"#prod-xquery30-SequenceType">SequenceType</a>)*)? ")" "as"
<a href="#prod-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParenthesizedItemType" id=
"prod-xquery30-ParenthesizedItemType"></a>[194]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xquery30-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URILiteral" id=
"prod-xquery30-URILiteral"></a>[195]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EQName" id=
"prod-xquery30-EQName"></a>[196]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-EQName">EQName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-QName">QName</a> | <a href=
"#prod-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="EBNFNotation" id="EBNFNotation"></a>A.1.1
Notation</h4>
<p>The following definitions will be helpful in defining precisely
this exposition.</p>
<p>[<a name="symbol" id="symbol" title="symbol">Definition</a>:
Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
<p>]</p>
<p>[<a name="terminal" id="terminal" title=
"terminal">Definition</a>: A <b>terminal</b> is a symbol or string
or pattern that can appear in the right-hand side of a rule, but
never appears on the left-hand side in the main grammar, although
it may appear on the left-hand side of a rule in the grammar for
terminals.] The following constructs are used to match strings of
one or more characters in a terminal:</p>
<dl>
<dt class="label">[a-zA-Z]</dt>
<dd>
<p>matches any <a href="#prod-xquery30-Char">Char</a> with a value
in the range(s) indicated (inclusive).</p>
</dd>
<dt class="label">[abc]</dt>
<dd>
<p>matches any <a href="#prod-xquery30-Char">Char</a> with a value
among the characters enumerated.</p>
</dd>
<dt class="label">[^abc]</dt>
<dd>
<p>matches any <a href="#prod-xquery30-Char">Char</a> with a value
not among the characters given.</p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>matches the sequence of characters that appear inside the double
quotes.</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>matches the sequence of characters that appear inside the single
quotes.</p>
</dd>
<dt class="label">
[http://www.w3.org/TR/REC-example/#NT-Example]</dt>
<dd>
<p>matches any string matched by the production defined in the
external specification as per the provided reference.</p>
</dd>
</dl>
<p>Patterns (including the above constructs) can be combined with
grammatical operators to form more complex patterns, matching more
complex sets of character strings. In the examples that follow, A
and B represent (sub-)patterns.</p>
<dl>
<dt class="label">(A)</dt>
<dd>
<p><code>A</code> is treated as a unit and may be combined as
described in this list.</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>matches <code>A</code> followed by <code>B</code>. This operator
has higher precedence than alternation; thus <code>A B | C D</code>
is identical to <code>(A B) | (C D)</code>.</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p>matches <code>A</code> or <code>B</code> but not both.</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p>matches any string that matches <code>A</code> but does not
match <code>B</code>.</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p>matches one or more occurrences of <code>A</code>. Concatenation
has higher precedence than alternation; thus <code>A+ | B+</code>
is identical to <code>(A+) | (B+)</code>.</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p>matches zero or more occurrences of <code>A</code>.
Concatenation has higher precedence than alternation; thus <code>A*
| B*</code> is identical to <code>(A*) | (B*)</code></p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="extra-grammatical-constraints" id=
"extra-grammatical-constraints"></a>A.1.2 Extra-grammatical
Constraints</h4>
<p>This section contains constraints on the EBNF productions, which
are required to parse syntactically valid sentences. The notes
below are referenced from the right side of the production, with
the notation: <em>/* xgc: &lt;id&gt; */</em>.</p>
<div class="constraint">
<p class="prefix"><a name="parse-note-leading-lone-slash" id=
"parse-note-leading-lone-slash"></a><b>Constraint:
leading-lone-slash</b></p>
<p>A single slash may appear either as a complete path expression
or as the first part of a path expression in which it is followed
by a <a href="#doc-xquery30-RelativePathExpr">RelativePathExpr</a>.
In some cases, the next token after the slash is insufficient to
allow a parser to distinguish these two possibilities: the
<code>*</code> token and keywords like <code>union</code> could be
either an operator or a <a href=
"#doc-xquery30-NameTest">NameTest</a> <span class="xquery">, and
the <code>&lt;</code> token could be either an operator or the
start of a <a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a></span> .
For example, without lookahead the first part of the expression
<code>/ * 5</code> is easily taken to be a complete expression,
<code>/ *</code>, which has a very different interpretation (the
child nodes of <code>/</code>).</p>
<p>Therefore to reduce the need for lookahead, if the token
immediately following a slash can form the start of a <a href=
"#doc-xquery30-RelativePathExpr">RelativePathExpr</a>, then the
slash must be the beginning of a <a href=
"#doc-xquery30-PathExpr">PathExpr</a>, not the entirety of it.</p>
<p>A single slash may be used as the left-hand argument of an
operator by parenthesizing it: <code>(/) * 5</code>. The expression
<code>5 * /</code>, on the other hand, is syntactically valid
without parentheses.</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-xml-version" id=
"parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
<p>The version of XML and XML Names (e.g. <a href="#XML">[XML
1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href=
"#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names
1.1]</a>) is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. It is
recommended that the latest applicable version be used (even if it
is published later than this specification). The EBNF in this
specification links only to the 1.0 versions. Note also that these
external productions follow the whitespace rules of their
respective specifications, and not the rules of this specification,
in particular <a href="#DefaultWhitespaceHandling"><b>A.2.4.1
Default Whitespace Handling</b></a>. Thus <code>prefix :
localname</code> is not a syntactically valid <a title=
"lexical QName" href="#dt-qname">lexical QName</a> for purposes of
this specification, just as it is not permitted in a XML document.
Also, comments are not permissible on either side of the colon.
Also extra-grammatical constraints such as well-formedness
constraints must be taken into account.</p>
<p class="xquery">XML 1.0 and XML 1.1 differ in their handling of
C0 control characters (specifically #x1 through #x1F, excluding
#x9, #xA, and #xD) and C1 control characters (#x7F through #x9F).
In XML 1.0, these C0 characters are prohibited, and the C1
characters are permitted. In XML 1.1, both sets of control
characters are permitted, but only if written as character
references. It is RECOMMENDED that implementations should follow
the XML 1.1 rules in this respect; however, for backwards
compatibility with <span class="xquery">XQuery 1.0</span> ,
implementations MAY allow C1 control characters to be used
directly.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Direct use of C1 control characters often suggests a character
encoding error, such as using encoding CP-1252 and mislabeling it
as iso-8859-1.</p>
</div>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-reserved-function-names" id=
"parse-note-reserved-function-names"></a><b>Constraint:
reserved-function-names</b></p>
<p>Unprefixed function names spelled the same way as language
keywords could make the language harder to recognize. For instance,
<code>if(foo)</code> could be taken either as a <a href=
"#doc-xquery30-FunctionCall">FunctionCall</a> or as the beginning
of an <a href="#doc-xquery30-IfExpr">IfExpr</a>. Therefore, an
unprefixed function name must not be any of the names in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<p>A function named "if" can be called by binding its namespace to
a prefix and using the prefixed form: "library:if(foo)" instead of
"if(foo)".</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-occurrence-indicators" id=
"parse-note-occurrence-indicators"></a><b>Constraint:
occurrence-indicators</b></p>
<p>As written, the grammar in <a href="#nt-bnf"><b>A XQuery 3.0
Grammar</b></a> is ambiguous for some forms using the '+' and '*'
Kleene operators. The ambiguity is resolved as follows: these
operators are tightly bound to the <a href=
"#doc-xquery30-SequenceType">SequenceType</a> expression, and have
higher precedence than other uses of these symbols. Any occurrence
of '+' and '*', as well as '?', following a sequence type is
assumed to be an occurrence indicator, which binds to the last
<a href="#doc-xquery30-ItemType">ItemType</a> in the <a href=
"#doc-xquery30-SequenceType">SequenceType</a>.</p>
<p>Thus, <code>4 treat as item() + - 5</code> must be interpreted
as <code>(4 treat as item()+) - 5</code>, taking the '+' as an
OccurrenceIndicator and the '-' as a subtraction operator. To force
the interpretation of "+" as an addition operator (and the
corresponding interpretation of the "-" as a unary minus),
parentheses may be used: the form <code>(4 treat as item()) +
-5</code> surrounds the <a href=
"#doc-xquery30-SequenceType">SequenceType</a> expression with
parentheses and leads to the desired interpretation.</p>
<p><code>function () as xs:string *</code> is interpreted as
<code>function () as (xs:string *)</code>, not as <code>(function
() as xs:string) *</code>. Parentheses can be used as shown to
force the latter interpretation.</p>
<p>This rule has as a consequence that certain forms which would
otherwise be syntactically valid and unambiguous are not
recognized: in "4 treat as item() + 5", the "+" is taken as an
<a href=
"#doc-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>, and
not as an operator, which means this is not a syntactically valid
expression.</p>
</div>
</div>
<div class="div3">
<h4><a name="notes-on-parsing" id="notes-on-parsing"></a>A.1.3
Grammar Notes</h4>
<p>This section contains general notes on the EBNF productions,
which may be helpful in understanding how to interpret and
implement the EBNF. These notes are not normative. The notes below
are referenced from the right side of the production, with the
notation: <em>/* gn: &lt;id&gt; */</em>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<dl>
<dt class="label"><a name="parse-note-parens" id=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p>Look-ahead is required to distinguish <a href=
"#doc-xquery30-FunctionCall">FunctionCall</a> from a EQName or
keyword followed by a <span class="xquery"><a href=
"#doc-xquery30-Pragma">Pragma</a> or</span> <a href=
"#doc-xquery30-Comment">Comment</a>. For example: <code>address (:
this may be empty :)</code> may be mistaken for a call to a
function named "address" unless this lookahead is employed. Another
example is <code>for (: whom the bell :) $tolls in 3 return
$tolls</code>, where the keyword "for" must not be mistaken for a
function name.</p>
</dd>
<dt class="label"><a name="parse-note-comments" id=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>Comments are allowed everywhere that <a title=
"ignorable whitespace" href="#IgnorableWhitespace">ignorable
whitespace</a> is allowed, and the <a href=
"#doc-xquery30-Comment">Comment</a> symbol does not explicitly
appear on the right-hand side of the grammar (except in its own
production). See <a href="#DefaultWhitespaceHandling"><b>A.2.4.1
Default Whitespace Handling</b></a>. <span class="xquery">Note that
comments are not allowed in direct constructor content, though they
are allowed in nested <a href=
"#doc-xquery30-EnclosedExpr">EnclosedExprs</a>.</span></p>
<p>A comment can contain nested comments, as long as all "(:" and
":)" patterns are balanced, no matter where they occur within the
outer comment.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Lexical analysis may typically handle nested comments by
incrementing a counter for each "(:" pattern, and decrementing the
counter for each ":)" pattern. The comment does not terminate until
the counter is back to zero.</p>
</div>
<p>Some illustrative examples:</p>
<ul>
<li>
<p><code>(: commenting out a (: comment :) may be confusing, but
often helpful :)</code> is a syntactically valid Comment, since
balanced nesting of comments is allowed.</p>
</li>
<li>
<p><code>"this is just a string :)"</code> is a syntactically valid
expression. However, <code>(: "this is just a string :)" :)</code>
will cause a syntax error. Likewise, <code>"this is another string
(:"</code> is a syntactically valid expression, but <code>(: "this
is another string (:" :)</code> will cause a syntax error. It is a
limitation of nested comments that literal content can cause
unbalanced nesting of comments.</p>
</li>
<li>
<p><code>for (: set up loop :) $i in $x return $i</code> is
syntactically valid, ignoring the comment.</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of
xs:integer</code> is also syntactically valid.</p>
</li>
<li>
<p><code>&lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;</code> is
not syntactically valid.</p>
</li>
<li>
<p><code>&lt;eg&gt; (: an example:) &lt;/eg&gt;</code> is
syntactically valid, but the characters that look like a comment
are in fact literal element content.</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="lexical-structure" id="lexical-structure"></a>A.2
Lexical structure</h3>
<p>The terminal symbols assumed by the grammar above are described
in this section.</p>
<p>Quoted strings appearing in production rules are terminal
symbols.</p>
<p>Other terminal symbols are defined in <a href=
"#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.</p>
<p>Some productions are defined by reference to the XML and XML
Names specifications (e.g. <a href="#XML">[XML 1.0]</a> and
<a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML
1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> .
<span class="xquery">It is implementation-defined</span> which
version of these specifications is used; it is recommended that the
latest applicable version be used (even if it is published later
than this specification).</p>
<p>When tokenizing, the longest possible match that is
<span>consistent with the EBNF</span> is used.</p>
<p>All keywords are case sensitive. Keywords are not reserved—that
is, any <a title="lexical QName" href="#dt-qname">lexical QName</a>
may duplicate a keyword except as noted in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<div class="div3">
<h4><a name="terminal-symbols" id="terminal-symbols"></a>A.2.1
Terminal Symbols</h4>
<h5><a name="d2e34248" id="d2e34248"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntegerLiteral" id=
"prod-xquery30-IntegerLiteral"></a>[197]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DecimalLiteral" id=
"prod-xquery30-DecimalLiteral"></a>[198]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xquery30-Digits">Digits</a>) |
(<a href="#prod-xquery30-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DoubleLiteral" id=
"prod-xquery30-DoubleLiteral"></a>[199]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xquery30-Digits">Digits</a>) |
(<a href="#prod-xquery30-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#prod-xquery30-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StringLiteral" id=
"prod-xquery30-StringLiteral"></a>[200]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#prod-xquery30-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') |
("'" (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#prod-xquery30-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URIQualifiedName" id=
"prod-xquery30-URIQualifiedName"></a>[201]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xquery30-NCName">NCName</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BracedURILiteral" id=
"prod-xquery30-BracedURILiteral"></a>[202]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | [^&amp;{}])*
"}"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PredefinedEntityRef" id=
"prod-xquery30-PredefinedEntityRef"></a>[203]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PredefinedEntityRef">PredefinedEntityRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EscapeQuot" id=
"prod-xquery30-EscapeQuot"></a>[204]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EscapeApos" id=
"prod-xquery30-EscapeApos"></a>[205]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementContentChar" id=
"prod-xquery30-ElementContentChar"></a>[206]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ElementContentChar">ElementContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
[{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuotAttrContentChar" id=
"prod-xquery30-QuotAttrContentChar"></a>[207]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-QuotAttrContentChar">QuotAttrContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
["{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AposAttrContentChar" id=
"prod-xquery30-AposAttrContentChar"></a>[208]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-AposAttrContentChar">AposAttrContentChar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
['{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Comment" id=
"prod-xquery30-Comment"></a>[209]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xquery30-CommentContents">CommentContents</a> | <a href=
"#prod-xquery30-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PITarget" id=
"prod-xquery30-PITarget"></a>[210]&#160;&#160;&#160;</td>
<td><code>PITarget</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CharRef" id=
"prod-xquery30-CharRef"></a>[211]&#160;&#160;&#160;</td>
<td><code>CharRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QName" id=
"prod-xquery30-QName"></a>[212]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-QName">QName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NCName" id=
"prod-xquery30-NCName"></a>[213]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-S" id=
"prod-xquery30-S"></a>[214]&#160;&#160;&#160;</td>
<td><code>S</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Char" id=
"prod-xquery30-Char"></a>[215]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
</table>
<p>The following symbols are used only in the definition of
terminal symbols; they are not terminal symbols in the grammar of
<a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
<h5><a name="d2e34502" id="d2e34502"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Digits" id=
"prod-xquery30-Digits"></a>[216]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommentContents" id=
"prod-xquery30-CommentContents"></a>[217]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="id-terminal-delimitation" id=
"id-terminal-delimitation"></a>A.2.2 Terminal Delimitation</h4>
<p>XQuery 3.0 expressions consist of <a href=
"#terminal-symbols">terminal symbols</a> and <a title=
"symbol separators" href="#symbolseparators">symbol
separators</a>.</p>
<p>Terminal symbols that are not used exclusively in <a href=
"#ws-explicit">/* ws: explicit */</a> productions are of two kinds:
delimiting and non-delimiting.</p>
<p>[<a name="delimiting-token" id="delimiting-token" title=
"delimiting terminal symbol">Definition</a>: The <b>delimiting
terminal symbols</b> are: <a href="#prod-xquery30-S">S</a>, "!",
"!=", <a href="#prod-xquery30-StringLiteral">StringLiteral</a>,
"#", "#)", "$", "%", "(", "(#", ")", "*", "+", (comma), "-",
"--&gt;", (dot), "..", "/", "//", "/&gt;", (colon), "::", ":=",
(semi-colon), "&lt;", "&lt;!--", "&lt;![CDATA[", "&lt;/",
"&lt;&lt;", "&lt;=", "&lt;?", "=", "&gt;", "&gt;=", "&gt;&gt;",
"?", "?&gt;", "@", <a href=
"#prod-xquery30-BracedURILiteral">BracedURILiteral</a>, "[", "]",
"]]&gt;", "{", "|", "||", "}" ]</p>
<p>[<a name="non-delimiting-token" id="non-delimiting-token" title=
"non-delimiting terminal symbol">Definition</a>: The
<b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xquery30-URIQualifiedName">URIQualifiedName</a>, <a href=
"#prod-xquery30-NCName">NCName</a>, <a href=
"#prod-xquery30-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xquery30-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xquery30-QName">QName</a>, "NaN", "allowing", "ancestor",
"ancestor-or-self", "and", "as", "ascending", "at", "attribute",
"base-uri", "boundary-space", "by", "case", "cast", "castable",
"catch", "child", "collation", "comment", "construction",
"context", "copy-namespaces", "count", "decimal-format",
"decimal-separator", "declare", "default", "descendant",
"descendant-or-self", "descending", "digit", "div", "document",
"document-node", "element", "else", "empty", "empty-sequence",
"encoding", "end", "eq", "every", "except", "external",
"following", "following-sibling", "for", "function", "ge",
"greatest", "group", "grouping-separator", "gt", "idiv", "if",
"import", "in", "infinity", "inherit", "instance", "intersect",
"is", "item", "lax", "le", "least", "let", "lt", "minus-sign",
"mod", "module", "namespace", "namespace-node", "ne", "next",
"no-inherit", "no-preserve", "node", "of", "only", "option", "or",
"order", "ordered", "ordering", "parent", "pattern-separator",
"per-mille", "percent", "preceding", "preceding-sibling",
"preserve", "previous", "processing-instruction", "return",
"satisfies", "schema", "schema-attribute", "schema-element",
"self", "sliding", "some", "stable", "start", "strict", "strip",
"switch", "text", "then", "to", "treat", "try", "tumbling", "type",
"typeswitch", "union", "unordered", "validate", "variable",
"version", "when", "where", "window", "xquery", "zero-digit" ]</p>
<p>[<a name="symbolseparators" id="symbolseparators" title=
"symbol separators">Definition</a>: <a title="whitespace" href=
"#Whitespace">Whitespace</a> and <a href=
"#doc-xquery30-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgc: xml-version */</a>
annotation.]</p>
<p>It is customary to separate consecutive terminal symbols by
<a title="whitespace" href="#Whitespace">whitespace</a> and
<a href="#doc-xquery30-Comment">Comments</a>, but this is required
only when otherwise two non-delimiting symbols would be adjacent to
each other. There are two exceptions to this, that of "." and "-",
which do require a <a title="symbol separators" href=
"#symbolseparators">symbol separator</a> if they follow a QName or
NCName. Also, "." requires a separator if it precedes or follows a
numeric literal.</p>
</div>
<div class="div3">
<h4><a name="id-eol-handling" id="id-eol-handling"></a>A.2.3
End-of-Line Handling</h4>
<p class="xquery">Prior to parsing, the XQuery 3.0 processor must
normalize all line breaks. The rules for line breaking follow the
rules of <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML
1.1]</a>. It is implementation-defined which version is used.</p>
<div class="div4">
<h5><a name="id-xml10-eol-handling" id=
"id-xml10-eol-handling"></a>A.2.3.1 XML 1.0 End-of-Line
Handling</h5>
<p>For <a href="#XML">[XML 1.0]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-xml11-eol-handling" id=
"id-xml11-eol-handling"></a>A.2.3.2 XML 1.1 End-of-Line
Handling</h5>
<p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>the two-character sequence #xD #x85</p>
</li>
<li>
<p>the single character #x85</p>
</li>
<li>
<p>the single character #x2028</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA or
#x85.</p>
</li>
</ol>
<p class="xquery">The characters #x85 and #x2028 cannot be reliably
recognized and translated until the <a href=
"#doc-xquery30-VersionDecl">VersionDecl</a> declaration (if
present) has been read.</p>
</div>
</div>
<div class="div3">
<h4><a name="whitespace-rules" id="whitespace-rules"></a>A.2.4
Whitespace Rules</h4>
<div class="div4">
<h5><a name="DefaultWhitespaceHandling" id=
"DefaultWhitespaceHandling"></a>A.2.4.1 Default Whitespace
Handling</h5>
<p>[<a name="Whitespace" id="Whitespace" title=
"whitespace">Definition</a>: A <b>whitespace</b> character is any
of the characters defined by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.]</p>
<p>[<a name="IgnorableWhitespace" id="IgnorableWhitespace" title=
"ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b>
consists of any <a title="whitespace" href=
"#Whitespace">whitespace</a> characters that may occur between
<a title="terminal" href="#terminal">terminals</a>, unless these
characters occur in the context of a production marked with a
<a href="#ExplicitWhitespaceHandling">ws:explicit</a> annotation,
in which case they can occur only where explicitly specified (see
<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit
Whitespace Handling</b></a>).] Ignorable whitespace characters are
not significant to the semantics of an expression. Whitespace is
allowed before the first terminal and after the last terminal
<span class="xquery">of a module</span>. Whitespace is allowed
between any two <a title="terminal" href="#terminal">terminals</a>.
<a href="#doc-xquery30-Comment">Comments</a> may also act as
"whitespace" to prevent two adjacent terminals from being
recognized as one. Some illustrative examples are as follows:</p>
<ul>
<li>
<p><code>foo- foo</code> results in a syntax error. "foo-" would be
recognized as a QName.</p>
</li>
<li>
<p><code>foo -foo</code> is syntactically equivalent to <code>foo -
foo</code>, two QNames separated by a subtraction operator.</p>
</li>
<li>
<p><code>foo(: This is a comment :)- foo</code> is syntactically
equivalent to <code>foo - foo</code>. This is because the comment
prevents the two adjacent terminals from being recognized as
one.</p>
</li>
<li>
<p><code>foo-foo</code> is syntactically equivalent to single
QName. This is because "-" is a valid character in a QName. When
used as an operator after the characters of a name, the "-" must be
separated from the name, e.g. by using whitespace or
parentheses.</p>
</li>
<li>
<p><code>10div 3</code> results in a syntax error.</p>
</li>
<li>
<p><code>10 div3</code> also results in a syntax error.</p>
</li>
<li>
<p><code>10div3</code> also results in a syntax error.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="ExplicitWhitespaceHandling" id=
"ExplicitWhitespaceHandling"></a>A.2.4.2 Explicit Whitespace
Handling</h5>
<p>Explicit whitespace notation is specified with the EBNF
productions, when it is different from the default rules, using the
notation shown below. This notation is not inherited. In other
words, if an EBNF rule is marked as /* ws: explicit */, the
notation does not automatically apply to all the 'child' EBNF
productions of that rule.</p>
<dl>
<dt class="label"><a name="ws-explicit" id="ws-explicit"></a>ws:
explicit</dt>
<dd>
<p>/* ws: explicit */ means that the EBNF notation explicitly
notates, with <code>S</code> or otherwise, where <a title=
"whitespace" href="#Whitespace">whitespace characters</a> are
allowed. In productions with the /* ws: explicit */ annotation,
<a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace
Handling</b></a> does not apply. <a href=
"#doc-xquery30-Comment">Comments</a> are also not allowed in these
productions.</p>
</dd>
</dl>
<p id="ws-explicit-lex-states" class="xquery">For example,
whitespace is not freely allowed by the direct constructor
productions, but is specified explicitly in the grammar, in order
to be more consistent with XML.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-reserved-fn-names" id=
"id-reserved-fn-names"></a>A.3 Reserved Function Names</h3>
<p>The following names are not allowed as function names in an
unprefixed form because expression syntax takes precedence.</p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty-sequence</code></p>
</li>
<li>
<p><code>function</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>namespace-node</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>schema-attribute</code></p>
</li>
<li>
<p><code>schema-element</code></p>
</li>
<li>
<p><code>switch</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-precedence-order" id="id-precedence-order"></a>A.4
Precedence Order (Non-Normative)</h3>
<p>The grammar in <a href="#id-grammar"><b>A.1 EBNF</b></a>
normatively defines built-in precedence among the operators of
XQuery. These operators are summarized here to make clear the order
of their precedence from lowest to highest. The associativity
column indicates the order in which operators of equal precedence
in an expression are applied.</p>
<table border="1">
<tbody>
<tr>
<th colspan="1">#</th>
<th colspan="1">Operator</th>
<th colspan="1">Associativity</th>
</tr>
<tr>
<td>1</td>
<td><a href="#doc-xquery30-Expr">, (comma)</a></td>
<td>either</td>
</tr>
<tr>
<td>2</td>
<td><span class="xquery"><a href=
"#doc-xquery30-FLWORExpr">FLWOR</a>,</span> <a href=
"#doc-xquery30-QuantifiedExpr">some, every</a>, <span class=
"xquery"><a href="#doc-xquery30-SwitchExpr">switch</a>,</span>
<span class="xquery"><a href=
"#doc-xquery30-TypeswitchExpr">typeswitch</a>,</span> <span class=
"xquery"><a href="#doc-xquery30-TryCatchExpr">try</a>,</span>
<a href="#doc-xquery30-IfExpr">if</a></td>
<td>NA</td>
</tr>
<tr>
<td>3</td>
<td><a href="#doc-xquery30-OrExpr">or</a></td>
<td>either</td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xquery30-AndExpr">and</a></td>
<td>either</td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xquery30-ValueComp">eq, ne, lt, le, gt, ge</a>,
<a href="#doc-xquery30-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xquery30-NodeComp">is, &lt;&lt;,
&gt;&gt;</a></td>
<td>NA</td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xquery30-StringConcatExpr">||</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xquery30-RangeExpr">to</a></td>
<td>NA</td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xquery30-AdditiveExpr">+, - (binary)</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>9</td>
<td><a href="#doc-xquery30-MultiplicativeExpr">*, div, idiv,
mod</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xquery30-UnionExpr">union, |</a></td>
<td>either</td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xquery30-IntersectExceptExpr">intersect,
except</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xquery30-InstanceofExpr">instance of</a></td>
<td>NA</td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xquery30-TreatExpr">treat as</a></td>
<td>NA</td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xquery30-CastableExpr">castable as</a></td>
<td>NA</td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xquery30-CastExpr">cast as</a></td>
<td>NA</td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xquery30-UnaryExpr">-, + (unary)</a></td>
<td>right-to-left</td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xquery30-SimpleMapExpr">!</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>18</td>
<td><a href="#doc-xquery30-PathExpr">/, //</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>19</td>
<td><a href="#doc-xquery30-Predicate">[ ]</a></td>
<td>left-to-right</td>
</tr>
</tbody>
</table>
<p>In the "Associativity" column, "either" indicates that all the
operators at that level have the associative property (i.e.,
<code>(A op B) op C</code> is equivalent to <code>A op (B op
C)</code>), so their associativity is inconsequential. "NA" (not
applicable) indicates that the EBNF does not allow an expression
that directly contains multiple operators from that precedence
level, so the question of their associativity does not arise.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Parentheses can be used to override the operator precedence in
the usual way. Square brackets in an expression such as A[B] serve
two roles: they act as an operator causing B to be evaluated once
for each item in the value of A, and they act as parentheses
enclosing the expression B.</p>
<p class="xquery">Curly braces in an expression such as validate{E}
or ordered{E} perform a similar bracketing role to the parentheses
in a function call, but with the difference in most cases that E is
an Expr rather than ExprSingle, meaning that it can use the comma
operator.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-type-promotion-and-operator-mapping" id=
"id-type-promotion-and-operator-mapping"></a>B Type Promotion and
Operator Mapping</h2>
<div class="div2">
<h3><a name="promotion" id="promotion"></a>B.1 Type Promotion</h3>
<p>[<a name="dt-type-promotion" id="dt-type-promotion" title=
"type promotion">Definition</a>: Under certain circumstances, an
atomic value can be promoted from one type to another. <b>Type
promotion</b> is used in evaluating function calls (see <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a> )<span class="xquery">, <code>order
by</code> clauses (see <a href="#id-order-by-clause"><b>3.10.8
Order By Clause</b></a>),</span> and operators that accept numeric
or string operands (see <a href="#mapping"><b>B.2 Operator
Mapping</b></a>).] The following type promotions are permitted:</p>
<ol class="enumar">
<li>
<p>Numeric type promotion:</p>
<ol class="enumla">
<li>
<p>A value of type <code>xs:float</code> (or any type derived by
restriction from <code>xs:float</code>) can be promoted to the type
<code>xs:double</code>. The result is the <code>xs:double</code>
value that is the same as the original value.</p>
</li>
<li>
<p>A value of type <code>xs:decimal</code> (or any type derived by
restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>. The
result of this promotion is created by casting the original value
to the required type. This kind of promotion may cause loss of
precision.</p>
</li>
</ol>
</li>
<li>
<p>URI type promotion: A value of type <code>xs:anyURI</code> (or
any type derived by restriction from <code>xs:anyURI</code>) can be
promoted to the type <code>xs:string</code>. The result of this
promotion is created by casting the original value to the type
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since <code>xs:anyURI</code> values can be promoted to
<code>xs:string</code>, functions and operators that compare
strings using the <a title="default collation" href=
"#dt-def-collation">default collation</a> also compare
<code>xs:anyURI</code> values using the <a title=
"default collation" href="#dt-def-collation">default collation</a>.
This ensures that orderings that include strings,
<code>xs:anyURI</code> values, or any combination of the two types
are consistent and well-defined.</p>
</div>
</li>
</ol>
<p>Note that <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> is different from <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example:</p>
<ul>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:float</code> can be invoked with a value of type
<code>xs:decimal</code>. This is an example of <a title=
"type promotion" href="#dt-type-promotion">type promotion</a>. The
value is actually converted to the expected type. Within the body
of the function, <code>$p instance of xs:decimal</code> returns
<code>false</code>.</p>
</li>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:decimal</code> can be invoked with a value of type
<code>xs:integer</code>. This is an example of <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. The value retains its original type. Within the
body of the function, <code>$p instance of xs:integer</code>
returns <code>true</code>.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="mapping" id="mapping"></a>B.2 Operator Mapping</h3>
<p>The operator mapping tables in this section list the
combinations of types for which the various operators of XQuery 3.0
are defined. [<a name="dt-operator-function" id=
"dt-operator-function" title="operator function">Definition</a>:
For each operator and valid combination of operand types, the
operator mapping tables specify a result type and an <b>operator
function</b> that implements the semantics of the operator for the
given types.] The definitions of the operator functions are given
in <a href="#xpath-functions-30">[XQuery and XPath Functions and
Operators 3.0]</a>. The result of an operator may be the raising of
an error by its operator function, as defined in <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>. In some cases, the operator function does not implement
the full semantics of a given operator. For the definition of each
operator (including its behavior for empty sequences or sequences
of length greater than one), see the descriptive material in the
main part of this document.</p>
<p>The <code>and</code> and <code>or</code> operators are defined
directly in the main body of this document, and do not occur in the
operator mapping tables.</p>
<p>If an operator in the operator mapping tables expects an operand
of type <em>ET</em>, that operator can be applied to an operand of
type <em>AT</em> if type <em>AT</em> can be converted to type
<em>ET</em> by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, a table entry indicates that the
<code>gt</code> operator may be applied to two <code>xs:date</code>
operands, returning <code>xs:boolean</code>. Therefore, the
<code>gt</code> operator may also be applied to two (possibly
different) subtypes of <code>xs:date</code>, also returning
<code>xs:boolean</code>.</p>
<p>[<a name="dt-numeric" id="dt-numeric" title=
"numeric">Definition</a>: When referring to a type, the term
<b>numeric</b> denotes the types <code>xs:integer</code>,
<code>xs:decimal</code>, <code>xs:float</code>, and
<code>xs:double</code>.] An operator whose operands and result are
designated as <a title="numeric" href="#dt-numeric">numeric</a>
might be thought of as representing four operators, one for each of
the numeric types. For example, the numeric <code>+</code> operator
might be thought of as representing the following four
operators:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">Operator</td>
<td align="center">First operand type</td>
<td align="center">Second operand type</td>
<td align="center">Result type</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p>A numeric operator may be validly applied to an operand of type
<em>AT</em> if type <em>AT</em> can be converted to any of the four
numeric types by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. If the result type of an operator is listed as
numeric, it means "the first type in the ordered list
<code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into
which all operands can be converted by <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a> and <a title="type promotion" href=
"#dt-type-promotion">type promotion</a>." As an example, suppose
that the type <code>hatsize</code> is derived from
<code>xs:integer</code> and the type <code>shoesize</code> is
derived from <code>xs:float</code>. Then if the <code>+</code>
operator is invoked with operands of type <code>hatsize</code> and
<code>shoesize</code>, it returns a result of type
<code>xs:float</code>. Similarly, if <code>+</code> is invoked with
two operands of type <code>hatsize</code> it returns a result of
type <code>xs:integer</code>.</p>
<p>[<a name="dt-gregorian" id="dt-gregorian" title=
"Gregorian">Definition</a>: In the operator mapping tables, the
term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.] For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>
<table border="1" summary="Binary operators" class="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Type(A)</th>
<th colspan="1">Type(B)</th>
<th colspan="1">Function</th>
<th colspan="1">Result type</th>
</tr>
<tr>
<td>A + B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-add(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:dateTime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dateTime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-subtract(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:subtract-dates(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:subtract-dateTimes(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-multiply(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-integer-divide(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-divide(A, B)</td>
<td>numeric; but xs:decimal if both operands are xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A mod B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-mod(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A eq B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>op:duration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hexBinary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64Binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>fn:not(op:duration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hexBinary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64Binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer*</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
<tr>
<td>A || B</td>
<td>xs:anyAtomicType</td>
<td>xs:anyAtomicType</td>
<td>fn:concat(A, B)</td>
<td>xs:string</td>
</tr>
</tbody>
</table>
<table border="1" summary="Unary operators" class="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Operand type</th>
<th colspan="1">Function</th>
<th colspan="1">Result type</th>
</tr>
<tr>
<td>+ A</td>
<td>numeric</td>
<td>op:numeric-unary-plus(A)</td>
<td>numeric</td>
</tr>
<tr>
<td>- A</td>
<td>numeric</td>
<td>op:numeric-unary-minus(A)</td>
<td>numeric</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xq-context-components" id=
"id-xq-context-components"></a>C Context Components</h2>
<p>The tables in this section describe how values are assigned to
the various components of the static context and dynamic context,
and to the parameters that control the serialization process.</p>
<div class="div2">
<h3><a name="id-xq-static-context-components" id=
"id-xq-static-context-components"></a>C.1 Static Context
Components</h3>
<p>The following table describes the components of the <b>static
context</b>. The following aspects of each component are
described:</p>
<ul>
<li>
<p><em>Default initial value:</em> This is the initial value of the
component if it is not overridden or augmented by the
implementation or by a query.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by implementation:</em>
Indicates whether an XQuery implementation is allowed to replace
the default initial value of the component by a different,
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value
and/or to augment the default initial value by additional <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> values.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by prolog:</em> Indicates
whether there are prolog declarations that can replace and/or
augment the initial value provided by default or by the
implementation.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by expressions:</em>
Indicates whether there are expressions that can replace and/or
augment the value of the component for their subexpressions.</p>
</li>
<li>
<p><em>Consistency Rules:</em> Indicates rules that must be
observed in assigning values to the component. Additional
consistency rules may be found in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>.</p>
</li>
</ul>
<table width="100%" border="1" summary="Static Context Components"
class="small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th colspan="1">Component</th>
<th colspan="1">Default initial value</th>
<th colspan="1">Can be overwritten or augmented by
implementation?</th>
<th colspan="1">Can be overwritten or augmented by prolog?</th>
<th colspan="1">Can be overwritten or augmented by
expressions?</th>
<th colspan="1">Consistency rules</th>
</tr>
<tr>
<td>Statically known namespaces</td>
<td><code>fn</code>, <code>xml</code>, <code>xs</code>,
<code>xsi</code>, <code>local</code></td>
<td>overwriteable and augmentable (except for
<code>xml</code>)</td>
<td>overwriteable and augmentable by <a href=
"#id-namespace-declaration"><b>4.13 Namespace
Declaration</b></a></td>
<td>overwriteable and augmentable by element constructor</td>
<td>Only one namespace can be assigned to a given prefix per
lexical scope.</td>
</tr>
<tr>
<td>Default element/type namespace</td>
<td>no namespace</td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-default-namespace"><b>4.14
Default Namespace Declaration</b></a></td>
<td>overwriteable by element constructor</td>
<td>Only one default namespace per lexical scope.</td>
</tr>
<tr>
<td>In-scope variables</td>
<td>none</td>
<td>augmentable</td>
<td>overwriteable and augmentable by <a href=
"#id-variable-declarations"><b>4.16 Variable Declaration</b></a>
and <a href="#id-inline-func"><b>3.1.7 Inline Function
Expressions</b></a>, augmentable by <a href=
"#id-module-import"><b>4.12 Module Import</b></a></td>
<td>overwriteable and augmentable by variable-binding
expressions</td>
<td>Only one definition per variable per lexical scope.</td>
</tr>
<tr>
<td>Context item static type</td>
<td>item()</td>
<td>overwriteable</td>
<td>overwriteable by <a href=
"#id-context-item-declarations"><b>4.17 Context Item
Declaration</b></a></td>
<td>overwriteable by expresssions that set the context item</td>
<td>None.</td>
</tr>
<tr>
<td>Ordering mode</td>
<td><code>ordered</code></td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-default-ordering-decl"><b>4.7
Ordering Mode Declaration</b></a></td>
<td>overwriteable by expression</td>
<td>Value must be <code>ordered</code> or
<code>unordered</code>.</td>
</tr>
<tr>
<td>Default function namespace</td>
<td><code>fn</code></td>
<td>overwriteable (not recommended)</td>
<td>overwriteable by <a href="#id-default-namespace"><b>4.14
Default Namespace Declaration</b></a></td>
<td>no</td>
<td>None.</td>
</tr>
<tr>
<td>In-scope schema types</td>
<td>built-in types in <code>xs</code></td>
<td>augmentable</td>
<td>augmentable by <a href="#id-schema-import"><b>4.11 Schema
Import</b></a></td>
<td>no</td>
<td>Only one definition per global or local type.</td>
</tr>
<tr>
<td>In-scope element declarations</td>
<td>none</td>
<td>augmentable</td>
<td>augmentable by <a href="#id-schema-import"><b>4.11 Schema
Import</b></a></td>
<td>no</td>
<td>Only one definition per global or local element name.</td>
</tr>
<tr>
<td>In-scope attribute declarations</td>
<td>none</td>
<td>augmentable</td>
<td>augmentable by <a href="#id-schema-import"><b>4.11 Schema
Import</b></a></td>
<td>no</td>
<td>Only one definition per global or local attribute name.</td>
</tr>
<tr>
<td><span>Statically known</span> function signatures</td>
<td>functions in <code>fn</code> namespace, and constructors for
built-in <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic types</a></td>
<td>augmentable</td>
<td>augmentable by <a href="#id-module-import"><b>4.12 Module
Import</b></a> and by <a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>; augmentable by <a href=
"#id-schema-import"><b>4.11 Schema Import</b></a> (which adds
constructor functions for user-defined types)</td>
<td>no</td>
<td>Each function must have a unique <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> and number of
arguments.</td>
</tr>
<tr>
<td>Default collation</td>
<td>Unicode codepoint collation</td>
<td>overwriteable</td>
<td>overwriteable by <a href=
"#id-default-collation-declaration"><b>4.4 Default Collation
Declaration</b></a></td>
<td>no</td>
<td>None.</td>
</tr>
<tr>
<td>Construction mode</td>
<td><code>preserve</code></td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-construction-declaration"><b>4.6
Construction Declaration</b></a></td>
<td>no</td>
<td>Value must be <code>preserve</code> or <code>strip</code>.</td>
</tr>
<tr>
<td>Default order for empty sequences</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-empty-order-decl"><b>4.8 Empty
Order Declaration</b></a></td>
<td>no</td>
<td>Value must be <code>greatest</code> or <code>least</code>.</td>
</tr>
<tr>
<td>Boundary-space policy</td>
<td><code>strip</code></td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-boundary-space-decls"><b>4.3
Boundary-space Declaration</b></a></td>
<td>no</td>
<td>Value must be <code>preserve</code> or <code>strip</code>.</td>
</tr>
<tr>
<td>Copy-namespaces mode</td>
<td><code>inherit, preserve</code></td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-copy-namespaces-decl"><b>4.9
Copy-Namespaces Declaration</b></a></td>
<td>no</td>
<td>Value consists of <code>inherit</code> or
<code>no-inherit</code>, and <code>preserve</code> or
<code>no-preserve</code>.</td>
</tr>
<tr>
<td>Static Base URI</td>
<td>See rules in <a href="#id-base-uri-decl"><b>4.5 Base URI
Declaration</b></a></td>
<td>overwriteable</td>
<td>overwriteable by <a href="#id-base-uri-decl"><b>4.5 Base URI
Declaration</b></a></td>
<td>no</td>
<td>Value must be a valid lexical representation of the type
xs:anyURI.</td>
</tr>
<tr>
<td>Statically known decimal formats</td>
<td>the default (unnamed) decimal format, which has an
implementation-dependent value</td>
<td>augmentable</td>
<td>augmentable, using <a title="decimal-format declaration" href=
"#dt-decimal-format-decl">decimal format declarations</a></td>
<td>no</td>
<td>each QName uniquely identifies a decimal format</td>
</tr>
<tr>
<td>Statically known documents</td>
<td>none</td>
<td>augmentable</td>
<td>no</td>
<td>no</td>
<td>None.</td>
</tr>
<tr>
<td>Statically known collections</td>
<td>none</td>
<td>augmentable</td>
<td>no</td>
<td>no</td>
<td>None.</td>
</tr>
<tr>
<td>Statically known default collection type</td>
<td><code>node()*</code></td>
<td>overwriteable</td>
<td>no</td>
<td>no</td>
<td>None.</td>
</tr>
<tr>
<td>Statically known collations</td>
<td>only the default collation</td>
<td>augmentable</td>
<td>no</td>
<td>no</td>
<td>Each URI uniquely identifies a collation.</td>
</tr>
<tr>
<td>XPath 1.0 Compatibility Mode</td>
<td><code>false</code></td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>Must be <code>false</code>.</td>
</tr>
<tr>
<th colspan="6">Serialization Parameters</th>
</tr>
<tr>
<td>byte-order-mark</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>cdata-section-elements</td>
<td>empty</td>
<td>overwriteable and augmentable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>doctype-public</td>
<td>none</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>doctype-system</td>
<td>none</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>encoding</td>
<td>implementation-defined choice between "utf-8" and "utf-16"</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>escape-uri-attributes</td>
<td>(not applicable when method = xml)</td>
<td>overwriteable and augmentable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>html-version</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>include-content-type</td>
<td>(not applicable when method = xml)</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>indent</td>
<td>no</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>item-separator</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>media-type</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>method</td>
<td>xml</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>normalization-form</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>omit-xml-declaration</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>standalone</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>suppress-indentation</td>
<td>empty</td>
<td>overwriteable and augmentable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>undeclare-prefixes</td>
<td>no</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>use-character-maps</td>
<td>empty</td>
<td>overwriteable and augmentable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
<tr>
<td>version</td>
<td>implementation-defined</td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>no</td>
<td><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparam">Section
3 Serialization Parameters</a> <sup><small>SER30</small></sup></td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="id-xq-evaluation-context-components" id=
"id-xq-evaluation-context-components"></a>C.2 Dynamic Context
Components</h3>
<p>The following table describes the components of the <b>dynamic
context</b>. The following aspects of each component are
described:</p>
<ul>
<li>
<p><em>Default initial value:</em> This is the initial value of the
component if it is not overridden or augmented by the
implementation or by a query.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by implementation:</em>
Indicates whether an XQuery implementation is allowed to replace
the default initial value of the component by a different <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value
and/or to augment the default initial value by additional <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> values.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by prolog:</em> Indicates
whether there are prolog declarations that can replace and/or
augment the initial value provided by default or by the
implementation.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by expressions:</em>
Indicates whether there are expressions that can replace and/or
augment the value of the component for their subexpressions.</p>
</li>
<li>
<p><em>Consistency Rules:</em> Indicates rules that must be
observed in assigning values to the component. Additional
consistency rules may be found in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>.</p>
</li>
</ul>
<table width="100%" border="1" summary="Dynamic Context Components"
class="small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th colspan="1">Component</th>
<th colspan="1">Default initial value</th>
<th colspan="1">Can be overwritten or augmented by
implementation?</th>
<th colspan="1">Can be overwritten or augmented by prolog?</th>
<th colspan="1">Can be overwritten or augmented by
expressions?</th>
<th colspan="1">Consistency rules</th>
</tr>
<tr>
<td>Context item</td>
<td>the <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a></td>
<td>overwriteable</td>
<td>no, but the <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a> can be set in
the prolog using a <a href="#id-context-item-declarations"><b>4.17
Context Item Declaration</b></a></td>
<td>overwritten during evaluation of path expressions and
predicates</td>
<td>The query body and the prolog of every module in a query share
the same <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a>.</td>
</tr>
<tr>
<td>Context position</td>
<td>1 if the <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a> is set,
otherwise none</td>
<td>overwriteable</td>
<td>no</td>
<td>overwritten during evaluation of path expressions and
predicates</td>
<td>If context item is defined, context position must be &gt;0 and
&lt;= context size; else context position is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</td>
</tr>
<tr>
<td>Context size</td>
<td>1 if the <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a> is set,
otherwise none</td>
<td>overwriteable</td>
<td>no</td>
<td>overwritten during evaluation of path expressions and
predicates</td>
<td>If context item is defined, context size must be &gt;0; else
context size is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.</td>
</tr>
<tr>
<td>Variable values</td>
<td>none</td>
<td>augmentable</td>
<td>overwriteable and augmentable by <a href=
"#id-variable-declarations"><b>4.16 Variable Declaration</b></a>
and <a href="#id-inline-func"><b>3.1.7 Inline Function
Expressions</b></a>, augmentable by <a href=
"#id-module-import"><b>4.12 Module Import</b></a></td>
<td>overwriteable and augmentable by variable-binding
expressions</td>
<td>Names and values must be consistent with in-scope
variables.</td>
</tr>
<tr>
<td><span>Named functions</span></td>
<td>functions in <code>fn</code> namespace, and constructors for
built-in <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic types</a></td>
<td>augmentable</td>
<td>augmentable by <a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>, <a href="#id-module-import"><b>4.12 Module
Import</b></a>, and <a href="#id-schema-import"><b>4.11 Schema
Import</b></a> ( (which adds constructor functions for user-defined
types)</td>
<td>no</td>
<td>Must be consistent with <span>statically known</span> function
signatures</td>
</tr>
<tr>
<td>Current dateTime</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>Must include a timezone. Remains constant during evaluation of
a query.</td>
</tr>
<tr>
<td>Implicit timezone</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>Remains constant during evaluation of a query.</td>
</tr>
<tr>
<td>Available documents</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
<tr>
<td>Available text resources</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
<tr>
<td>Available node collections</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
<tr>
<td>Default node collection</td>
<td>none</td>
<td>overwriteable</td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
<tr>
<td>Available resource collections</td>
<td>none</td>
<td>must be initialized <span class="xquery">by
implementation</span></td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
<tr>
<td>Default resource collection</td>
<td>none</td>
<td>overwriteable</td>
<td>no</td>
<td>no</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-impl-defined-items" id=
"id-impl-defined-items"></a>D Implementation-Defined Items</h2>
<p>The following items in this specification are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumar">
<li>
<p>The version of Unicode that is used to construct
expressions.</p>
</li>
<li>
<p>The <a title="statically known collations" href=
"#dt-static-collations">statically-known collations</a>.</p>
</li>
<li>
<p>The <a title="implicit timezone" href="#dt-timezone">implicit
timezone</a>.</p>
</li>
<li>
<p>The circumstances in which <a title="warning" href=
"#dt-warning">warnings</a> are raised, and the ways in which
warnings are handled.</p>
</li>
<li>
<p>The method by which errors are reported to the external
processing environment.</p>
</li>
<li>
<p>Which version of XML and XML Names (e.g. <a href="#XML">[XML
1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or <a href=
"#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names
1.1]</a>) and which version of XML Schema (e.g. <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>) is used for the definitions of primitives such as
characters and names, and for the definitions of operations such as
normalization of line endings and normalization of whitespace in
attribute values. It is recommended that the latest applicable
version be used (even if it is published later than this
specification).</p>
</li>
<li>
<p>How XDM instances are created from sources other than an Infoset
or PSVI.</p>
</li>
<li>
<p>Any components of the <a title="static context" href=
"#dt-static-context">static context</a> or <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
that are overwritten or augmented by the implementation.</p>
</li>
<li>
<p>The default handling of empty sequences returned by an ordering
key (orderspec) in an <code>order by</code> clause (<code>empty
least</code> or <code>empty greatest</code>).</p>
</li>
<li>
<p>The names and semantics of any <a title="extension expression"
href="#dt-extension-expression">extension expressions</a>
(<a title="pragma" href="#dt-pragma">pragmas</a>) recognized by the
implementation.</p>
</li>
<li>
<p>The names and semantics of any <a title="option declaration"
href="#dt-option-declaration">option declarations</a> recognized by
the implementation.</p>
</li>
<li>
<p>Protocols (if any) by which parameters can be passed to an
external function, and the result of the function can returned to
the invoking query.</p>
</li>
<li>
<p>The process by which the specific modules to be imported by a
<a title="module import" href="#dt-module-import">module import</a>
are identified, if the <a title="module feature" href=
"#dt-module-feature">Module Feature</a> is supported (includes
processing of location hints, if any.)</p>
</li>
<li>
<p>The means by which serialization is invoked, if the <a title=
"serialization feature" href=
"#dt-serialization-feature">Serialization Feature</a> is
supported.</p>
</li>
<li>
<p>The default values for the <code>byte-order-mark</code>,
<code>encoding</code>, <code>media-type</code>,
<code>normalization-form</code>, <code>omit-xml-declaration</code>,
<code>standalone</code>, and <code>version</code> parameters, if
the <a title="serialization feature" href=
"#dt-serialization-feature">Serialization Feature</a> is
supported.</p>
</li>
<li>
<p>The result of an unsuccessful call to an external function (for
example, if the function implementation cannot be found or does not
return a value of the declared type).</p>
</li>
<li>
<p>Limits on ranges of values for various data types, as enumerated
in <a href="#id-data-model-conformance"><b>5.3 Data Model
Conformance</b></a>.</p>
</li>
<li>
<p>Syntactic extensions to XQuery, including both their syntax and
semantics, as discussed in <a href="#id-syntax-extensions"><b>5.4
Syntax Extensions</b></a>.</p>
</li>
<li>
<p>Whether the type system is based on <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. An
implementation that has based its type system on XML Schema 1.0 is
not required to support the use of the xs:dateTimeStamp constructor
or the use of xs:dateTimeStamp as TypeName in any expression.</p>
</li>
<li>
<p>The signatures of functions provided by the implementation or
via an implementation-defined API (see <a href=
"#static_context"><b>2.1.1 Static Context</b></a>).</p>
</li>
<li>
<p>Any <a title="environment variables" href=
"#dt-environment-variables">environment variables</a> provided by
the implementation.</p>
</li>
<li>
<p>Any rules used for static typing (see <a href=
"#id-static-analysis"><b>2.2.3.1 Static Analysis
Phase</b></a>).</p>
</li>
<li>
<p>Any serialization parameters provided by the implementation
<span class="xquery">(see <a href="#id-serialization"><b>2.2.4
Serialization</b></a>).</span>n</p>
</li>
<li>
<p>The means by which the location hint for a serialization
parameter document identifies the corresponding XDM instance (see
<a href="#id-serialization"><b>2.2.4 Serialization</b></a>).</p>
</li>
<li>
<p>What error, if any, is returned if an external function's
implementation does not return the declared result type (see
<a href="#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>).</p>
</li>
<li>
<p>Any annotations defined by the implementation, and their
associated behavior (see <a href="#id-annotations"><b>4.15
Annotations</b></a>).</p>
</li>
<li>
<p>Any <a title="function assertion" href=
"#dt-function-assertion">function asertions</a> defined by the
implementation.</p>
</li>
<li>
<p>The effect of function assertions understood by the
implementation on <a href="#id-assertions-subtype"><b>2.5.6.3 The
judgement subtype-assertions(AnnotationsA, AnnotationsB)</b></a>
.</p>
</li>
<li>
<p>Any implementation-defined variables defined by the
implementation. (see <a href="#id-variables"><b>3.1.2 Variable
References</b></a>).</p>
</li>
<li>
<p>The ordering associated with <code>fn:unordered</code> in the
implementation (see <a href="#id-unordered-expressions"><b>3.11
Ordered and Unordered Expressions</b></a>).</p>
</li>
<li>
<p>Any additional information provided for try/catch via the
<code>err:additional</code> variable (see <a href=
"#id-try-catch"><b>3.15 Try/Catch Expressions</b></a>).</p>
</li>
<li>
<p>The default boundary-space policy (see <a href=
"#id-boundary-space-decls"><b>4.3 Boundary-space
Declaration</b></a>).</p>
</li>
<li>
<p>The default collation (see <a href=
"#id-default-collation-declaration"><b>4.4 Default Collation
Declaration</b></a>).</p>
</li>
<li>
<p>The default base URI (see <a href="#id-base-uri-decl"><b>4.5
Base URI Declaration</b></a>).</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Additional <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> items are
listed in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a> and <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-references" id="id-references"></a>E
References</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 Normative References</h3>
<dl>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3986" id=
"RFC3986"></a>RFC3986</span></dt>
<dd>
<div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3987" id=
"RFC3987"></a>RFC3987</span></dt>
<dd>
<div>M. Duerst and M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
</dd>
<dt class="label"><span><a name="ISO10646" id=
"ISO10646"></a>ISO/IEC 10646</span></dt>
<dd>
<div>ISO (International Organization for Standardization).
<em>ISO/IEC 10646:2003. Information technology—Universal
Multiple-Octet Coded Character Set (UCS)</em>, as, from time to
time, amended, replaced by a new edition, or expanded by the
addition of new parts. [Geneva]: International Organization for
Standardization. (See <a href=
"http://www.iso.org">http://www.iso.org</a> for the latest
version.)</div>
</dd>
<dt class="label"><span><a name="Unicode" id=
"Unicode"></a>Unicode</span></dt>
<dd>
<div>The Unicode Consortium. <em>The Unicode Standard</em> Reading,
Mass.: Addison-Wesley, 2003, as updated from time to time by the
publication of new versions. See <a href=
"http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
for the latest version and additional information on versions of
the standard and of the Unicode Character Database. The version of
Unicode to be used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations are recommended to use the latest Unicode
version.</div>
</dd>
<dt class="label"><span><a name="XML" id="XML"></a>XML
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>.
The edition of XML 1.0 must be no earlier than the Third Edition;
the edition used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</div>
</dd>
<dt class="label"><span><a name="XML1.1" id="XML1.1"></a>XML
1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.1.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></div>
</dd>
<dt class="label"><span><a name="XMLBASE" id="XMLBASE"></a>XML
Base</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Base.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES" id="XMLNAMES"></a>XML
Names</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES11" id=
"XMLNAMES11"></a>XML Names 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div>
</dd>
<dt class="label"><span><a name="XMLID" id="XMLID"></a>XML
ID</span></dt>
<dd>
<div>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></div>
</dd>
<dt class="label"><span><a name="XMLSchema10" id=
"XMLSchema10"></a>XML Schema 1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2
(Second Edition)</em>. W3C Recommendation, 28 October 2004. See
<a href=
"http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
<a href=
"http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</div>
</dd>
<dt class="label"><span><a name="XMLSchema11" id=
"XMLSchema11"></a>XML Schema 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema, Parts 1, and
2</em>. W3C Recommendation 5 April 2012. See <a href=
"http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.</div>
</dd>
<dt class="label"><span><a name="xpath-datamodel-30" id=
"xpath-datamodel-30"></a>XQuery and XPath Data Model (XDM)
3.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-30/"><cite>XQuery and XPath
Data Model (XDM) 3.0</cite></a>, Norman Walsh, Anders Berglund,
John Snelson, Editors. World Wide Web Consortium, 08 April 2014.
This version is
http://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/. The
<a href="http://www.w3.org/TR/xpath-datamodel-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-30" id=
"xpath-functions-30"></a>XQuery and XPath Functions and Operators
3.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-30/"><cite>XQuery and XPath
Functions and Operators 3.0</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 08 April 2014. This version is
http://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/. The
<a href="http://www.w3.org/TR/xpath-functions-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-30/.</div>
</dd>
<dt class="label"><span><a name="xslt-xquery-serialization-30" id=
"xslt-xquery-serialization-30"></a>XSLT and XQuery Serialization
3.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/"><cite>XSLT and
XQuery Serialization 3.0</cite></a>, Henry Zongaro, Andrew Coleman,
Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xslt-xquery-serialization-30-20140408/.
The <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/">latest
version</a> is available at
http://www.w3.org/TR/xslt-xquery-serialization-30/.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 Non-normative References</h3>
<dl>
<dt class="label"><span class="xquery"><a name=
"xquery-30-requirements" id="xquery-30-requirements"></a>XQuery 3.0
Requirements</span></dt>
<dd>
<div class="xquery"><a href=
"http://www.w3.org/TR/xquery-30-requirements/"><cite>XQuery 3.0
Requirements</cite></a>, Daniel Engovatov, Jonathan Robie, Editors.
World Wide Web Consortium, 08 April 2014. This version is
http://www.w3.org/TR/2014/NOTE-xquery-30-requirements-20140408/.
The <a href="http://www.w3.org/TR/xquery-30-requirements/">latest
version</a> is available at
http://www.w3.org/TR/xquery-30-requirements/.</div>
</dd>
<dt class="label"><span class="xquery"><a name="xpath-30" id=
"xpath-30"></a>XML Path Language (XPath) 3.0</span></dt>
<dd>
<div class="xquery"><a href=
"http://www.w3.org/TR/xpath-30/"><cite>XML Path Language (XPath)
3.0</cite></a>, Jonathan Robie, Don Chamberlin, Michael Dyck, John
Snelson, Editors. World Wide Web Consortium, 08 April 2014. This
version is http://www.w3.org/TR/2014/REC-xpath-30-20140408/. The
<a href="http://www.w3.org/TR/xpath-30/">latest version</a> is
available at http://www.w3.org/TR/xpath-30/.</div>
</dd>
<dt class="label"><span><a name="xquery-semantics" id=
"xquery-semantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-semantics/"><cite>XQuery
1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>,
Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>,
Editors. World Wide Web Consortium, 14 December 2010. This version
is http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. The
<a href="http://www.w3.org/TR/xquery-semantics/">latest version</a>
is available at http://www.w3.org/TR/xquery-semantics/.</div>
</dd>
<dt class="label"><span class="xquery"><a name="xqueryx-30" id=
"xqueryx-30"></a>XQueryX 3.0</span></dt>
<dd>
<div class="xquery"><a href=
"http://www.w3.org/TR/xqueryx-30/"><cite>XQueryX 3.0</cite></a>,
Jim Melton, Editor. World Wide Web Consortium, 08 April 2014. This
version is http://www.w3.org/TR/2014/REC-xqueryx-30-20140408/. The
<a href="http://www.w3.org/TR/xqueryx-30/">latest version</a> is
available at http://www.w3.org/TR/xqueryx-30/.</div>
</dd>
<dt class="label"><span><a name="xslt-30" id="xslt-30"></a>XSL
Transformations (XSLT) Version 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt-30/"><cite>XSL
Transformations (XSLT) Version 3.0</cite></a>, Michael Kay, Editor.
World Wide Web Consortium, 12 December 2013. This version is
http://www.w3.org/TR/2013/WD-xslt-30-20131212/. The <a href=
"http://www.w3.org/TR/xslt-30/">latest version</a> is available at
http://www.w3.org/TR/xslt-30/.</div>
</dd>
<dt class="label"><span><a name="DOM" id="DOM"></a>Document Object
Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Document Object Model (DOM)
Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004.
See <a href=
"http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</div>
</dd>
<dt class="label"><span><a name="XINFO" id="XINFO"></a>XML
Infoset</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></div>
</dd>
<dt class="label"><span><a name="xpath" id="xpath"></a>XML Path
Language (XPath) Version 1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath"><cite>XML Path Language
(XPath) Version 1.0</cite></a>, James Clark and Steven DeRose,
Editors. World Wide Web Consortium, 16&#160;Nov&#160;1999. This
version is http://www.w3.org/TR/1999/REC-xpath-19991116. The
<a href="http://www.w3.org/TR/xpath">latest version</a> is
available at http://www.w3.org/TR/xpath.</div>
</dd>
<dt class="label"><span><a name="xpath20" id="xpath20"></a>XML Path
Language (XPath) Version 2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath20/"><cite>XML Path
Language (XPath) 2.0 (Second Edition)</cite></a>, Don Chamberlin,
Anders Berglund, Scott Boag, <em>et. al.</em>, Editors. World Wide
Web Consortium, 14 December 2010. This version is
http://www.w3.org/TR/2010/REC-xpath20-20101214/. The <a href=
"http://www.w3.org/TR/xpath20/">latest version</a> is available at
http://www.w3.org/TR/xpath20/.</div>
</dd>
<dt class="label"><span><a name="XPTR" id=
"XPTR"></a>XPointer</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Pointer Language
(XPointer).</em> W3C Last Call Working Draft 8 January 2001. See
<a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></div>
</dd>
<dt class="label"><span class="xquery"><a name="UseCases" id=
"UseCases"></a>XML Query Use Cases</span></dt>
<dd>
<div class="xquery">World Wide Web Consortium. <em>XML Query Use
Cases</em>. W3C Working Draft, 8 June 2006. See <a href=
"http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</a>.</div>
</dd>
<dt class="label"><span class="xquery"><a name="xml11schema10" id=
"xml11schema10"></a>XML 1.1 and Schema 1.0</span></dt>
<dd>
<div class="xquery">World Wide Web Consortium. <em>Processing XML
1.1 Documents with XML Schema 1.0 Processors</em>. W3C Working
Group Note, 11 May 2005. See <a href=
"http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</a>.</div>
</dd>
<dt class="label"><span class="xquery"><a name="RFC1738" id=
"RFC1738"></a>Uniform Resource Locators (URL)</span></dt>
<dd>
<div class="xquery">Internet Engineering Task Force (IETF).
<em>Uniform Resource Locators (URL)</em>. Request For Comment No.
1738, Dec. 1994. See <a href=
"http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a>.</div>
</dd>
<dt class="label"><span class="xquery"><a name="ODMG" id=
"ODMG"></a>ODMG</span></dt>
<dd>
<div class="xquery">Rick Cattell et al. <em>The Object Database
Standard: ODMG-93, Release 1.2</em>. Morgan Kaufmann Publishers,
San Francisco, 1996.</div>
</dd>
<dt class="label"><span class="xquery"><a name="Quilt" id=
"Quilt"></a>Quilt</span></dt>
<dd>
<div class="xquery">Don Chamberlin, Jonathan Robie, and Daniela
Florescu. <em>Quilt: an XML Query Language for Heterogeneous Data
Sources</em>. In <em>Lecture Notes in Computer Science</em>,
Springer-Verlag, Dec. 2000.</div>
</dd>
<dt class="label"><span class="xquery"><a name="XML-QL" id=
"XML-QL"></a>XML-QL</span></dt>
<dd>
<div class="xquery">Alin Deutsch, Mary Fernandez, Daniela Florescu,
Alon Levy, and Dan Suciu. <em>A Query Language for XML</em>.</div>
</dd>
<dt class="label"><span class="xquery"><a name="SQL" id=
"SQL"></a>SQL</span></dt>
<dd>
<div class="xquery">International Organization for Standardization
(ISO). <em>Information Technology — Database Language SQL</em>.
Standard No. ISO/IEC 9075:2011. (Available from American National
Standards Institute, New York, NY 10036, (212) 642-4900.)</div>
</dd>
<dt class="label"><span class="xquery"><a name="XQL" id=
"XQL"></a>XQL</span></dt>
<dd>
<div class="xquery">J. Robie, J. Lapp, D. Schach. <em>XML Query
Language (XQL)</em>. See <a href=
"http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-material" id=
"id-background-material"></a>E.3 Background Material</h3>
<dl>
<dt class="label"><span><a name="CHARMOD" id=
"CHARMOD"></a>Character Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Character Model for the World
Wide Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</div>
</dd>
<dt class="label"><span><a name="xslt" id="xslt"></a>XSL
Transformations (XSLT) Version 1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations
(XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web
Consortium, 16&#160;Nov&#160;1999. This version is
http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href=
"http://www.w3.org/TR/xslt">latest version</a> is available at
http://www.w3.org/TR/xslt.</div>
</dd>
<dt class="label"><span class="xquery"><a name="UseCaseQueries" id=
"UseCaseQueries"></a>Use Case Sample Queries</span></dt>
<dd>
<div class="xquery">Queries from the XQuery 1.0 Use Cases,
presented in a single file. See <a href=
"http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt">
http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt</a>.</div>
</dd>
<dt class="label"><span class="xquery"><a name="XQueryQueries" id=
"XQueryQueries"></a>XQuery Sample Queries</span></dt>
<dd>
<div class="xquery">Queries from this document, presented in a
single file. See <a href=
"http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt">
http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt</a>.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>F Error Conditions</h2>
<dl>
<dt><a name="ERRXPST0001" id="ERRXPST0001"></a>err:XPST0001</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if analysis of an expression relies on some component of
the <a title="static context" href="#dt-static-context">static
context</a> that <span>is <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup></span>
.</p>
</dd>
<dt><a name="ERRXPDY0002" id="ERRXPDY0002"></a>err:XPDY0002</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if evaluation of an
expression relies on some part of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> that <span>is
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup></span>
.</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression is not a valid instance of the grammar
defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, an expression is
found to have a <a title="static type" href=
"#dt-static-type">static type</a> that is not appropriate for the
context in which the expression occurs, or during the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a value does not match a
required type as specified by the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</dd>
<dt><a name="ERRXPST0005" id="ERRXPST0005"></a>err:XPST0005</dt>
<dd>
<p>During the analysis phase, it is a <a title="static error" href=
"#dt-static-error">static error</a> if the <a title="static type"
href="#dt-static-type">static type</a> assigned to an expression
other than the expression <code>()</code> or <code>data(())</code>
is <code>empty-sequence()</code>.</p>
</dd>
<dt><a name="ERRXPST0008" id="ERRXPST0008"></a>err:XPST0008</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression refers to an element name, attribute
name, schema type name, namespace prefix, or variable name that is
not defined in the <a title="static context" href=
"#dt-static-context">static context</a>, except for an ElementName
in an <a href="#doc-xquery30-ElementTest">ElementTest</a> or an
AttributeName in an <a href=
"#doc-xquery30-AttributeTest">AttributeTest</a>.</p>
</dd>
<dt><a name="ERRXQST0009" id="ERRXQST0009"></a>err:XQST0009</dt>
<dd>
<p>An implementation that does not support the Schema Aware Feature
must raise a <a title="static error" href="#dt-static-error">static
error</a> if a Prolog contains a schema import.</p>
</dd>
<dt><a name="ERRXQST0012" id="ERRXQST0012"></a>err:XQST0012</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the set of definitions contained in all schemas
imported by a Prolog do not satisfy the conditions for schema
validity specified in Sections 3 and 5 of Part 1 of <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> --i.e., each definition must be valid, complete,
and unique.</p>
</dd>
<dt><a name="ERRXQST0013" id="ERRXQST0013"></a>err:XQST0013</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an implementation recognizes a pragma but determines
that its content is invalid.</p>
</dd>
<dt><a name="ERRXQST0016" id="ERRXQST0016"></a>err:XQST0016</dt>
<dd>
<p>An implementation that does not support the Module Feature
raises a <a title="static error" href="#dt-static-error">static
error</a> if it encounters a <a title="module declaration" href=
"#dt-module-declaration">module declaration</a> or a <a title=
"module import" href="#dt-module-import">module import</a>.</p>
</dd>
<dt><a name="ERRXPST0017" id="ERRXPST0017"></a>err:XPST0017</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and number of arguments in
a <span>static</span> function call do not match the name and arity
of a <a title="statically known function signatures" href=
"#dt-known-func-signatures">function signature</a> in the <a title=
"static context" href="#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXPTY0018" id="ERRXPTY0018"></a>err:XPTY0018</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the result of a path operator contains both nodes and
non-nodes.</p>
</dd>
<dt><a name="ERRXPTY0019" id="ERRXPTY0019"></a>err:XPTY0019</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if <code>E1</code> in a path expression
<code>E1/E2</code> does not evaluate to a sequence of nodes.</p>
</dd>
<dt><a name="ERRXPTY0020" id="ERRXPTY0020"></a>err:XPTY0020</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, in an axis step, the context item is not a node.</p>
</dd>
<dt><a name="ERRXQST0022" id="ERRXQST0022"></a>err:XQST0022</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a <a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">namespace declaration attribute</a>
<span>contains an <a href=
"#doc-xquery30-EnclosedExpr">EnclosedExpr</a>.</span></p>
</dd>
<dt><a name="ERRXQTY0024" id="ERRXQTY0024"></a>err:XQTY0024</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the content sequence in an element constructor
contains an attribute node following a node that is not an
attribute node.</p>
</dd>
<dt><a name="ERRXQDY0025" id="ERRXQDY0025"></a>err:XQDY0025</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if any attribute of a
constructed element does not have a name that is distinct from the
names of all other attributes of the constructed element.</p>
</dd>
<dt><a name="ERRXQDY0026" id="ERRXQDY0026"></a>err:XQDY0026</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the result of the content
expression of a computed processing instruction constructor
contains the string "<code>?&gt;</code>".</p>
</dd>
<dt><a name="ERRXQDY0027" id="ERRXQDY0027"></a>err:XQDY0027</dt>
<dd>
<p>In a validate expression, it is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the root element
information item in the PSVI resulting from validation does not
have the expected validity property: <code>valid</code> if
validation mode is <code>strict</code>, or either
<code>valid</code> or <code>notKnown</code> if validation mode is
<code>lax</code>.</p>
</dd>
<dt><a name="ERRXQTY0030" id="ERRXQTY0030"></a>err:XQTY0030</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the argument of a <code>validate</code> expression
does not evaluate to exactly one document or element node.</p>
</dd>
<dt><a name="ERRXQST0031" id="ERRXQST0031"></a>err:XQST0031</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the version number specified in a version declaration
is not supported by the implementation.</p>
</dd>
<dt><a name="ERRXQST0032" id="ERRXQST0032"></a>err:XQST0032</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one <a title=
"base URI declaration" href="#dt-base-uri-decl">base URI
declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0033" id="ERRXQST0033"></a>err:XQST0033</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a module contains multiple bindings for the same
namespace prefix.</p>
</dd>
<dt><a name="ERRXQST0034" id="ERRXQST0034"></a>err:XQST0034</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if multiple functions declared <span class="xquery">or
imported by a <a title="module" href="#dt-module">module</a></span>
have the <span>same</span> number of arguments and their <a title=
"expanded QName" href="#dt-expanded-qname">expanded QNames</a> are
equal (as defined by the <code>eq</code> operator).</p>
</dd>
<dt><a name="ERRXQST0035" id="ERRXQST0035"></a>err:XQST0035</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> to import two schema components that both define the same
name in the same symbol space and in the same scope.</p>
</dd>
<dt><a name="ERRXQST0038" id="ERRXQST0038"></a>err:XQST0038</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a Prolog contains more than one <a title=
"default collation declaration" href=
"#dt-default-collation-decl">default collation declaration</a>, or
the value specified by a default collation declaration is not
present in <a title="statically known collations" href=
"#dt-static-collations">statically known collations</a>.</p>
</dd>
<dt><a name="ERRXQST0039" id="ERRXQST0039"></a>err:XQST0039</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> for <span class="xquery">a function declaration or</span>
<span>an inline function expression</span> to have more than one
parameter with the same name.</p>
</dd>
<dt><a name="ERRXQST0040" id="ERRXQST0040"></a>err:XQST0040</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the attributes specified by a direct element
constructor do not have distinct <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a>.</p>
</dd>
<dt><a name="ERRXQDY0041" id="ERRXQDY0041"></a>err:XQDY0041</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the value of the name
expression in a computed processing instruction constructor cannot
be cast to the type <code>xs:NCName</code>.</p>
</dd>
<dt><a name="ERRXQDY0044" id="ERRXQDY0044"></a>err:XQDY0044</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> the node-name of a node
constructed by a computed attribute constructor has any of the
following properties:</p>
<ul>
<li>
<p>Its namespace prefix is <code>xmlns</code>.</p>
</li>
<li>
<p>It has no namespace prefix and its local name is
<code>xmlns</code>.</p>
</li>
<li>
<p>Its namespace URI is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Its namespace prefix is <code>xml</code> and its namespace URI
is not <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Its namespace prefix is other than <code>xml</code> and its
namespace URI is
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
</ul>
</dd>
<dt><a name="ERRXQST0045" id="ERRXQST0045"></a>err:XQST0045</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if <span>the name of a function annotation or</span> the
function name in a function declaration is in one of the following
namespaces: <code>http://www.w3.org/XML/1998/namespace,
http://www.w3.org/2001/XMLSchema,
http://www.w3.org/2001/XMLSchema-instance,
http://www.w3.org/2005/xpath-functions</code>,
<code>http://www.w3.org/2005/xpath-functions/math</code>,
<code>http://www.w3.org/2012/xquery</code>.</p>
</dd>
<dt><a name="ERRXQST0046" id="ERRXQST0046"></a>err:XQST0046</dt>
<dd>
<p>An implementation <span class="xquery"><a title="may" href=
"#may">MAY</a></span> raise a <a title="static error" href=
"#dt-static-error">static error</a> if the value of <span class=
"xquery">a <a href="#doc-xquery30-URILiteral">URILiteral</a>
or</span> a <a href=
"#doc-xquery30-BracedURILiteral">BracedURILiteral</a> is of nonzero
length and is <span>neither an absolute URI nor a relative
URI</span>.</p>
</dd>
<dt><a name="ERRXQST0047" id="ERRXQST0047"></a>err:XQST0047</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if multiple module imports in the same Prolog specify the
same target namespace.</p>
</dd>
<dt><a name="ERRXQST0048" id="ERRXQST0048"></a>err:XQST0048</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a function or variable declared in a library module is
not in the target namespace of the library module.</p>
</dd>
<dt><a name="ERRXQST0049" id="ERRXQST0049"></a>err:XQST0049</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if two or more variables declared or imported by a
<a title="module" href="#dt-module">module</a> have equal <a title=
"expanded QName" href="#dt-expanded-qname">expanded QNames</a> (as
defined by the <code>eq</code> operator.)</p>
</dd>
<dt><a name="ERRXPDY0050" id="ERRXPDY0050"></a>err:XPDY0050</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of the
operand of a <code>treat</code> expression does not match the
<a title="sequence type" href="#dt-sequence-type">sequence type</a>
specified by the <code>treat</code> expression. This error might
also be raised by a path expression beginning with "<code>/</code>"
or "<code>//</code>" if the context node is not in a tree that is
rooted at a document node. This is because a leading
"<code>/</code>" or "<code>//</code>" in a path expression is an
abbreviation for an initial step that includes the clause
<code>treat as document-node()</code>.</p>
</dd>
<dt><a name="ERRXPST0051" id="ERRXPST0051"></a>err:XPST0051</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> for an <a href=
"#doc-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> in a
<a href="#doc-xquery30-SequenceType">SequenceType</a> is not
defined in the <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a> as a <a title=
"generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a>.</p>
</dd>
<dt><a name="ERRXQST0052" id="ERRXQST0052"></a>err:XQST0052</dt>
<dd>
<p>The type must be the name of a type defined in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, and the <code>{variety}</code> of the type must be
<code>simple</code>.</p>
</dd>
<dt><a name="ERRXQDY0054" id="ERRXQDY0054"></a>err:XQDY0054</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if a cycle is encountered in
the definition of a module's dynamic context components, for
example because of a cycle in variable declarations.</p>
</dd>
<dt><a name="ERRXQST0055" id="ERRXQST0055"></a>err:XQST0055</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a Prolog contains more than one <a title=
"copy-namespaces declaration" href=
"#dt-copy-namespaces-decl">copy-namespaces declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0057" id="ERRXQST0057"></a>err:XQST0057</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a schema import binds a namespace prefix but does not
specify a target namespace other than a zero-length string.</p>
</dd>
<dt><a name="ERRXQST0058" id="ERRXQST0058"></a>err:XQST0058</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if multiple schema imports specify the same target
namespace.</p>
</dd>
<dt><a name="ERRXQST0059" id="ERRXQST0059"></a>err:XQST0059</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an implementation is unable to process a schema or
module import by finding a schema or module with the specified
target namespace.</p>
</dd>
<dt><a name="ERRXQST0060" id="ERRXQST0060"></a>err:XQST0060</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the name of a function in a function declaration is
not in a namespace (<a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> has a null namespace
URI).</p>
</dd>
<dt><a name="ERRXQDY0061" id="ERRXQDY0061"></a>err:XQDY0061</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the operand of a validate
expression is a document node whose children do not consist of
exactly one element node and zero or more comment and processing
instruction nodes, in any order.</p>
</dd>
<dt><a name="ERRXQDY0064" id="ERRXQDY0064"></a>err:XQDY0064</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the value of the name
expression in a computed processing instruction constructor is
equal to "XML" (in any combination of upper and lower case).</p>
</dd>
<dt><a name="ERRXQST0065" id="ERRXQST0065"></a>err:XQST0065</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one <a title=
"ordering mode declaration" href="#dt-ordering-mode-decl">ordering
mode declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0066" id="ERRXQST0066"></a>err:XQST0066</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one default
element/type namespace declaration, or more than one default
function namespace declaration.</p>
</dd>
<dt><a name="ERRXQST0067" id="ERRXQST0067"></a>err:XQST0067</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one <a title=
"construction declaration" href=
"#dt-construction-decl">construction declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0068" id="ERRXQST0068"></a>err:XQST0068</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one <a title=
"boundary-space declaration" href=
"#dt-boundary-space-decl">boundary-space declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0069" id="ERRXQST0069"></a>err:XQST0069</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if a Prolog contains more than one <a title=
"empty order declaration" href="#dt-empty-order-decl">empty order
declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0070" id="ERRXQST0070"></a>err:XQST0070</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if one of the predefined prefixes
<code>xml</code> or <code>xmlns</code> appears in a namespace
declaration <span>or a default namespace declaration,</span> or if
any of the following conditions is statically detected in any
expression or declaration:</p>
<ul>
<li>
<p>The prefix <code>xml</code> is bound to some namespace URI other
than <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>A prefix other than <code>xml</code> is bound to the namespace
URI <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>The prefix <code>xmlns</code> is bound to any namespace URI.</p>
</li>
<li>
<p>A prefix other than <code>xmlns</code> is bound to the namespace
URI <code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
</ul>
</dd>
<dt><a name="ERRXQST0071" id="ERRXQST0071"></a>err:XQST0071</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if the namespace declaration attributes of a
direct element constructor do not have distinct names.</p>
</dd>
<dt><a name="ERRXQDY0072" id="ERRXQDY0072"></a>err:XQDY0072</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the result of the content
expression of a computed comment constructor contains two adjacent
hyphens or ends with a hyphen.</p>
</dd>
<dt><a name="ERRXQDY0074" id="ERRXQDY0074"></a>err:XQDY0074</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the value of the name
expression in a computed element or attribute constructor cannot be
converted to an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for example, because it
contains a namespace prefix not found in <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.)</p>
</dd>
<dt><a name="ERRXQST0075" id="ERRXQST0075"></a>err:XQST0075</dt>
<dd>
<p>An implementation that does not support the Validation Feature
must raise a <a title="static error" href="#dt-static-error">static
error</a> if it encounters a <code>validate</code> expression.</p>
</dd>
<dt><a name="ERRXQST0076" id="ERRXQST0076"></a>err:XQST0076</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a <code>collation</code> subclause in an <code>order
by</code> clause of a FLWOR expression does not identify a
collation that is present in <a title="statically known collations"
href="#dt-static-collations">statically known collations</a>.</p>
</dd>
<dt><a name="ERRXQST0079" id="ERRXQST0079"></a>err:XQST0079</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an extension expression contains neither a <a title=
"pragma" href="#dt-pragma">pragma</a> that is recognized by the
implementation nor an expression enclosed in curly braces.</p>
</dd>
<dt><a name="ERRXPST0080" id="ERRXPST0080"></a>err:XPST0080</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the target type of a <code>cast</code> or
<code>castable</code> expression is <code>xs:NOTATION</code>
<span><code>xs:anySimpleType</code>,</span> or
<code>xs:anyAtomicType</code>.</p>
</dd>
<dt><a name="ERRXPST0081" id="ERRXPST0081"></a>err:XPST0081</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a QName used in <span class="xquery">a query</span>
contains a namespace prefix that cannot be expanded into a
namespace URI by using the <a title="statically known namespaces"
href="#dt-static-namespaces">statically known namespaces</a>.</p>
</dd>
<dt><a name="ERRXQDY0084" id="ERRXQDY0084"></a>err:XQDY0084</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the element validated by a
<code>validate</code> statement does not have a top-level element
declaration in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, if validation
mode is <code>strict</code>.</p>
</dd>
<dt><a name="ERRXQST0085" id="ERRXQST0085"></a>err:XQST0085</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the namespace URI in a namespace declaration attribute
is a zero-length string, and the implementation does not support
<a href="#XMLNAMES11">[XML Names 1.1]</a>.</p>
</dd>
<dt><a name="ERRXQTY0086" id="ERRXQTY0086"></a>err:XQTY0086</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the typed value of a copied element or attribute node
is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> when <a title=
"construction mode" href="#dt-construction-mode">construction
mode</a> is <code>preserve</code> and <a title=
"copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> is
<code>no-preserve</code>.</p>
</dd>
<dt><a name="ERRXQST0087" id="ERRXQST0087"></a>err:XQST0087</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the encoding specified in a Version Declaration does
not conform to the definition of <code>EncName</code> specified in
<a href="#XML">[XML 1.0]</a>.</p>
</dd>
<dt><a name="ERRXQST0088" id="ERRXQST0088"></a>err:XQST0088</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the literal that specifies the target namespace in a
<a title="module import" href="#dt-module-import">module import</a>
or a <a title="module declaration" href=
"#dt-module-declaration">module declaration</a> is of zero
length.</p>
</dd>
<dt><a name="ERRXQST0089" id="ERRXQST0089"></a>err:XQST0089</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a variable bound in a <code>for</code> or
<code>window</code> clause of a FLWOR expression, and its
associated positional variable, do not have distinct names
(<a title="expanded QName" href="#dt-expanded-qname">expanded
QNames</a>).</p>
</dd>
<dt><a name="ERRXQST0090" id="ERRXQST0090"></a>err:XQST0090</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a <a title="character reference" href=
"#dt-character-reference">character reference</a> does not identify
a valid character in the version of XML that is in use.</p>
</dd>
<dt><a name="ERRXQDY0091" id="ERRXQDY0091"></a>err:XQDY0091</dt>
<dd>
<p>An implementation <a title="may" href="#may">MAY</a> raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if an <code>xml:id</code> error, as defined in <a href=
"#XMLID">[XML ID]</a>, is encountered during construction of an
attribute named <code>xml:id</code>.</p>
</dd>
<dt><a name="ERRXQDY0092" id="ERRXQDY0092"></a>err:XQDY0092</dt>
<dd>
<p>An implementation <a title="may" href="#may">MAY</a> raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a constructed attribute named <code>xml:space</code> has a value
other than <code>preserve</code> or <code>default</code>.</p>
</dd>
<dt><a name="ERRXQST0094" id="ERRXQST0094"></a>err:XQST0094</dt>
<dd>
<p>The name of each grouping variable must be equal (by the
<code>eq</code> operator on <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a>) to the name of a variable
in the input tuple stream.</p>
</dd>
<dt><a name="ERRXQDY0096" id="ERRXQDY0096"></a>err:XQDY0096</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> <span>if</span> the node-name
of a node constructed by a computed element constructor has any of
the following properties:</p>
<ul>
<li>
<p>Its namespace prefix is <code>xmlns</code>.</p>
</li>
<li>
<p>Its namespace URI is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Its namespace prefix is <code>xml</code> and its namespace URI
is not <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Its namespace prefix is other than <code>xml</code> and its
namespace URI is
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
</ul>
</dd>
<dt><a name="ERRXQST0097" id="ERRXQST0097"></a>err:XQST0097</dt>
<dd>
<p>It is a static error for a decimal-format to specify a value
that is not valid for a given property, as described in <a title=
"statically known decimal formats" href=
"#dt-static-decimal-formats">statically known decimal
formats</a></p>
</dd>
<dt><a name="ERRXQST0098" id="ERRXQST0098"></a>err:XQST0098</dt>
<dd>
<p>It is a static error if, for any named or unnamed decimal
format, the properties representing characters used in a picture
string do not each have distinct values. These properties are
<a title="decimal-separator" href=
"#id-static-decimal-separator">decimal-separator-sign</a>,
<a title="grouping-separator" href=
"#id-static-decimal-format-grouping-separator">grouping-separator</a>,
<a title="percent-sign" href=
"#id-static-decimal-format-percent-sign">percent-sign</a>,
<a title="per-mille-sign" href=
"#id-static-decimal-format-per-mille-sign">per-mille-sign</a>,
<a title="zero-digit" href=
"#id-static-decimal-format-zero-digit">zero-digit</a>, <a title=
"digit-sign" href=
"#id-static-decimal-format-digit-sign">digit-sign</a>, and
<a title="pattern-separator-sign" href=
"#id-static-decimal-format-pattern-separator-sign">pattern-separator-sign</a>.</p>
</dd>
<dt><a name="ERRXQST0099" id="ERRXQST0099"></a>err:XQST0099</dt>
<dd>
<p><span>No module</span> may contain more than one
ContextItemDecl.</p>
</dd>
<dt><a name="ERRXQDY0101" id="ERRXQDY0101"></a>err:XQDY0101</dt>
<dd>
<p>An error is raised if a computed namespace constructor attempts
to do any of the following:</p>
<ul>
<li>
<p>Bind the prefix <code>xml</code> to some namespace URI other
than <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind a prefix other than <code>xml</code> to the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>Bind the prefix <code>xmlns</code> to any namespace URI.</p>
</li>
<li>
<p>Bind a prefix to the namespace URI
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>Bind any prefix (including the empty prefix) to a zero-length
namespace URI.</p>
</li>
</ul>
</dd>
<dt><a name="ERRXQDY0102" id="ERRXQDY0102"></a>err:XQDY0102</dt>
<dd>
<p>In an element constructor, if two or more namespace bindings in
the in-scope bindings would have the same prefix, then an error is
raised if they have different URIs; if they would have the same
prefix and URI, duplicate bindings are ignored.</p>
<p>If the name of an element in an element constructor is in no
namespace, creating a default namespace for that element using a
computed namespace constructor is an error.</p>
</dd>
<dt><a name="ERRXQST0103" id="ERRXQST0103"></a>err:XQST0103</dt>
<dd>
<p>All variables in a <code>window</code> clause must have distinct
names.</p>
</dd>
<dt><a name="ERRXQST0104" id="ERRXQST0104"></a>err:XQST0104</dt>
<dd>
<p>A <a href="#doc-xquery30-TypeName">TypeName</a> that is
specified in a <code>validate</code> expression must be found in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a></p>
</dd>
<dt><a name="ERRXQTY0105" id="ERRXQTY0105"></a>err:XQTY0105</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the content sequence in an element constructor
contains a function .</p>
</dd>
<dt><a name="ERRXQST0106" id="ERRXQST0106"></a>err:XQST0106</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a function declaration contains both a
<code>%private</code> and a <code>%public</code> annotation.</p>
</dd>
<dt><a name="ERRXQST0108" id="ERRXQST0108"></a>err:XQST0108</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an <a title="output declaration" href=
"#dt-output-declaration">output declaration</a> occurs in a
<a title="library module" href="#dt-library-module">library
module</a>.</p>
</dd>
<dt><a name="ERRXQST0109" id="ERRXQST0109"></a>err:XQST0109</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the local name of an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code>
namespace is not one of the serialization parameter names listed in
<a href="#id-xq-static-context-components"><b>C.1 Static Context
Components</b></a>, <span>or if the name of an output declaration
is <code>use-character-maps</code></span> .</p>
</dd>
<dt><a name="ERRXQST0110" id="ERRXQST0110"></a>err:XQST0110</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the same serialization parameter is used more than
once in an <a title="output declaration" href=
"#dt-output-declaration">output declaration</a>.</p>
</dd>
<dt><a name="ERRXQST0111" id="ERRXQST0111"></a>err:XQST0111</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> for a query prolog to contain two decimal formats with
the same name, or to contain two default decimal formats.</p>
</dd>
<dt><a name="ERRXQST0113" id="ERRXQST0113"></a>err:XQST0113</dt>
<dd>
<p>Specifying a <a href="#doc-xquery30-VarValue">VarValue</a> or
<a href="#doc-xquery30-VarDefaultValue">VarDefaultValue</a> for a
context item declaration in a library module is a <a title=
"static error" href="#dt-static-error">static error</a>.</p>
</dd>
<dt><a name="ERRXQST0114" id="ERRXQST0114"></a>err:XQST0114</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> for a decimal format declaration to define the same
property more than once.</p>
</dd>
<dt><a name="ERRXQST0115" id="ERRXQST0115"></a>err:XQST0115</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the document specified by the option
"http://www.w3.org/2010/xslt-xquery-serialization":parameter-document
raises a serialization error.</p>
</dd>
<dt><a name="ERRXQST0116" id="ERRXQST0116"></a>err:XQST0116</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> <span>if a variable declaration contains both a
<code>%private</code> and a <code>%public</code> annotation, more
than one <code>%private</code> annotation, or more than one
<code>%public</code> annotation.</span></p>
</dd>
<dt><a name="ERRXPTY0117" id="ERRXPTY0117"></a>err:XPTY0117</dt>
<dd>
<p>In a cast expression, if an item is of type
<code>xs:untypedAtomic</code> and the expected type is <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is
raised.</p>
</dd>
<dt><a name="ERRXQST0118" id="ERRXQST0118"></a>err:XQST0118</dt>
<dd>
<p>In a direct element constructor, the name used in the end tag
must exactly match the name used in the corresponding start tag,
including its prefix or absence of a prefix.</p>
</dd>
<dt><a name="ERRXQST0119" id="ERRXQST0119"></a>err:XQST0119</dt>
<dd>
<p>It is a static error if the implementation is not able to
process the value of an <code>output:parameter-document</code>
declaration to produce an XDM instance.</p>
</dd>
<dt><a name="ERRXQST0125" id="ERRXQST0125"></a>err:XQST0125</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an inline function <span>expression</span> is
annotated as <code>%public</code> or <code>%private</code>.</p>
</dd>
<dt><a name="ERRXQST0129" id="ERRXQST0129"></a>err:XQST0129</dt>
<dd>
<p>An implementation that does not provide the Higher-Order
Function Feature <a title="must" href="#must">MUST</a> raise a
static error [<a href="#ERRXQST0129" title=
"err:XQST0129">err:XQST0129</a>] if it encounters a <a href=
"#doc-xquery30-FunctionTest">FunctionTest</a>, <a title=
"dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic function call</a>,
<a title="named function reference" href=
"#dt-named-function-ref">named function reference</a>, <a title=
"inline function expression" href="#dt-inline-func">inline function
expression</a>, or <a title="partial function application" href=
"#dt-partial-function-application">partial function
application</a>.</p>
</dd>
<dt><a name="ERRXPDY0130" id="ERRXPDY0130"></a>err:XPDY0130</dt>
<dd>
<p>An implementation-defined limit has been exceeded.</p>
</dd>
<dt><a name="ERRXPST0133" id="ERRXPST0133"></a>err:XPST0133</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXPST0133" title=
"err:XPST0133">err:XPST0133</a>] if the namespace URI for an EQName
is <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a name="ERRXQST0134" id="ERRXQST0134"></a>err:XQST0134</dt>
<dd>
<p>XQuery 3.0 does not support the namespace axis.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-mime-type" id="id-mime-type"></a>G The
<code>application/xquery</code> Media Type</h2>
<p>This Appendix specifies the media type for XQuery Version 1.0.
XQuery is a language for querying over collections of data from XML
data sources, as specified in the main body of this document. This
media type is being submitted to the IESG (Internet Engineering
Steering Group) for review, approval, and registration with IANA
(Internet Assigned Numbers Authority.)</p>
<div class="div2">
<h3><a name="id-mime-type-intro" id="id-mime-type-intro"></a>G.1
Introduction</h3>
<p>This document, found at <a href=
"http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>,
together with its normative references, defines the language XQuery
Version 1.0. This Appendix provides information about the
<code>application/xquery</code> media type, which is intended to be
used for transmitting queries written in the XQuery language.</p>
<p>This document was prepared by members of the W3C XML Query
Working Group. Please send comments to public-qt-comments@w3.org, a
public mailing list with archives at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</a>.</p>
</div>
<div class="div2">
<h3><a name="id-registration-of-mime-type" id=
"id-registration-of-mime-type"></a>G.2 Registration of MIME Media
Type <code>application/xquery</code></h3>
<p>MIME media type name: <code>application</code></p>
<p>MIME subtype name: <code>xquery</code></p>
<p>Required parameters: none</p>
<p>Optional parameters: none</p>
<p>The syntax of XQuery is expressed in Unicode but may be written
with any Unicode-compatible character encoding, including UTF-8 or
UTF-16, or transported as US-ASCII or ISO-8859-1 with Unicode
characters outside the range of the given encoding represented
using an XML-style <code>&amp;#xddd;</code> syntax.</p>
<div class="div3">
<h4><a name="id-interoperability-considerations" id=
"id-interoperability-considerations"></a>G.2.1 Interoperability
Considerations</h4>
<p>None known.</p>
</div>
<div class="div3">
<h4><a name="id-applications-of-media-type" id=
"id-applications-of-media-type"></a>G.2.2 Applications Using this
Media Type</h4>
<p>The public <a href="http://www.w3.org/XML/Query/">XQuery Web
page</a> lists more than two dozen implementations of the XQuery
language, both proprietary and open source.</p>
<p>This new media type is being registered to allow for deployment
of XQuery on the World Wide Web.</p>
</div>
<div class="div3">
<h4><a name="id-file-extensions" id="id-file-extensions"></a>G.2.3
File Extensions</h4>
<p>The most common file extensions in use for XQuery are
<code>.xq</code> and <code>.xquery</code>.</p>
<p>The appropriate Macintosh file type code is
<code>TEXT</code>.</p>
</div>
<div class="div3">
<h4><a name="id-intended-usage" id="id-intended-usage"></a>G.2.4
Intended Usage</h4>
<p>The intended usage of this media type is for interchange of
XQuery expressions.</p>
</div>
<div class="div3">
<h4><a name="id-author-change-controller" id=
"id-author-change-controller"></a>G.2.5 Author/Change
Controller</h4>
<p>XQuery was produced by, and is maintained by, the World Wide Web
Consortium's XML Query Working Group. The W3C has change control
over this specification.</p>
</div>
</div>
<div class="div2">
<h3><a name="xquery-mime-encoding" id=
"xquery-mime-encoding"></a>G.3 Encoding Considerations</h3>
<p>For use with transports that are not 8-bit clean,
quoted-printable encoding is recommended since the XQuery syntax
itself uses the US-ASCII-compatible subset of Unicode.</p>
<p>An XQuery document may contain an <a title=
"encoding declaration" href="#dt-encoding-declaration">encoding
declaration</a> as part of its <a title="version declaration" href=
"#dt-version-declaration">version declaration</a>:</p>
<div class="exampleInner">
<pre>
xquery version "1.0" encoding "utf-8";
</pre></div>
</div>
<div class="div2">
<h3><a name="xquery-mime-recognizing" id=
"xquery-mime-recognizing"></a>G.4 Recognizing XQuery Files</h3>
<p>An XQuery file may have the string <code>xquery version
"V.V"</code> near the beginning of the document, where
<code>"V.V"</code> is a version number. Currently the version
number, if present, must be <code>"1.0"</code>.</p>
</div>
<div class="div2">
<h3><a name="id-charset-default-rules" id=
"id-charset-default-rules"></a>G.5 Charset Default Rules</h3>
<p>XQuery documents use the Unicode character set and, by default,
the UTF-8 encoding.</p>
</div>
<div class="div2">
<h3><a name="id-security-considerations" id=
"id-security-considerations"></a>G.6 Security Considerations</h3>
<p>Queries written in XQuery may cause arbitrary URIs or IRIs to be
dereferenced. Therefore, the security issues of <a href=
"#RFC3987">[RFC3987]</a> Section 8 should be considered. In
addition, the contents of resources identified by
<code>file:</code> URIs can in some cases be accessed, processed
and returned as results. XQuery expressions can invoke any of the
functions defined in <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>. For example, the
<code>fn:doc()</code> and <code>fn:doc-available()</code> functions
allow local filesystem probes as well as access to any URI-defined
resource accessible from the system evaluating the XQuery
expression.</p>
<p>XQuery is a full declarative programming language, and supports
user-defined functions, external function libraries (modules)
referenced by URI, and system-specific "native" functions.</p>
<p>Arbitrary recursion is possible, as is arbitrarily large memory
usage, and implementations may place limits on CPU and memory
usage, as well as restricting access to system-defined
functions.</p>
<p>The XML Query Working group is working on a facility to allow
XQuery expressions to create and update persistent data. Untrusted
queries should not be given write access to data.</p>
<p>Furthermore, because the XQuery language permits extensions, it
is possible that <code>application/xquery</code> may describe
content that has security implications beyond those described
here.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-glossary" id="id-glossary"></a>H Glossary
(Non-Normative)</h2>
<dl>
<dt><a name="GLdt-gregorian" id="GLdt-gregorian"></a>Gregorian</dt>
<dd>
<p>In the operator mapping tables, the term <b>Gregorian</b> refers
to the types <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</p>
</dd>
<dt><a name="GLid-static-decimal-format-NaN" id=
"GLid-static-decimal-format-NaN"></a>NaN</dt>
<dd>
<p><b>NaN</b> specifies the string used for the NaN-symbol, which
is used to represent the value NaN (not-a-number); the default
value is the string "NaN"</p>
</dd>
<dt><a name="GLdt-prolog" id="GLdt-prolog"></a>Prolog</dt>
<dd>
<p>A <b>Prolog</b> is a series of declarations and imports that
define the processing environment for the <a title="module" href=
"#dt-module">module</a> that contains the Prolog.</p>
</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>
<p><b>SequenceType matching</b> compares the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
with an expected <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>.</p>
</dd>
<dt><a name="GLdt-static-base-uri" id=
"GLdt-static-base-uri"></a>Static Base URI</dt>
<dd>
<p><b>Static Base URI.</b> This is an absolute URI, used to resolve
<span class="xquery">relative URIs both during static analysis and
during dynamic evaluation.</span></p>
</dd>
<dt><a name="GLdt-URI" id="GLdt-URI"></a>URI</dt>
<dd>
<p>Within this specification, the term <b>URI</b> refers to a
Universal Resource Identifier as defined in <a href=
"#RFC3986">[RFC3986]</a> and extended in <a href=
"#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p>
</dd>
<dt><a name="GLdt-data-model-instance" id=
"GLdt-data-model-instance"></a>XDM instance</dt>
<dd>
<p>The term <b>XDM instance</b> is used, synonymously with the term
<a title="value" href="#dt-value">value</a>, to denote an
unconstrained <a title="sequence" href="#dt-sequence">sequence</a>
of <a title="item" href="#dt-item">items</a> in the <a title=
"data model" href="#dt-datamodel">data model</a>.</p>
</dd>
<dt><a name="GLdt-xpath-10-processor" id=
"GLdt-xpath-10-processor"></a>XPath 1.0 Processor</dt>
<dd>
<p>An <b>XPath 1.0 Processor</b> processes a query according to the
XPath 1.0 specification.</p>
</dd>
<dt><a name="GLdt-xpath-compat-mode" id=
"GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd>
<p><b>XPath 1.0 compatibility mode.</b> <span class="xquery">This
component must be set by all host languages that include XPath 3.0
as a subset, indicating whether rules for compatibility with XPath
1.0 are in effect. XQuery sets the value of this component to
<code>false</code>.</span></p>
</dd>
<dt><a name="GLdt-xpath-20-processor" id=
"GLdt-xpath-20-processor"></a>XPath 2.0 Processor</dt>
<dd>
<p>An <b>XPath 2.0 Processor</b> processes a query according to the
XPath 2.0 specification.</p>
</dd>
<dt><a name="GLdt-xpath-30-processor" id=
"GLdt-xpath-30-processor"></a>XPath 3.0 Processor</dt>
<dd>
<p>An <b>XPath 3.0 Processor</b> processes a query according to the
XPath 3.0 specification.</p>
</dd>
<dt><a name="GLdt-xquery-10-processor" id=
"GLdt-xquery-10-processor"></a>XQuery 1.0 Processor</dt>
<dd>
<p>An <b>XQuery 1.0 Processor</b> processes a query according to
the XQuery 1.0 specification.</p>
</dd>
<dt><a name="GLdt-xquery-30-processor" id=
"GLdt-xquery-30-processor"></a>XQuery 3.0 Processor</dt>
<dd>
<p>An <b>XQuery 3.0 Processor</b> processes a query according to
the XQuery 3.0 specification.</p>
</dd>
<dt><a name="GLdt-arg-expr" id="GLdt-arg-expr"></a>argument
expression</dt>
<dd>
<p>An argument to a function call is either an <b>argument
expression</b> or an ArgumentPlaceholder ("?").</p>
</dd>
<dt><a name="GLdt-arg-value" id="GLdt-arg-value"></a>argument
value</dt>
<dd>
<p><a title="argument expression" href="#dt-arg-expr">Argument
expressions</a> are evaluated <span>with respect to
<var>DC</var></span> , producing <b>argument values</b>.</p>
</dd>
<dt><a name="GLdt-argumentlist-arity" id=
"GLdt-argumentlist-arity"></a>arity</dt>
<dd>
<p>The number of <code>Argument</code>s in an
<code>ArgumentList</code> is its <b>arity</b>.</p>
</dd>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic
value</dt>
<dd>
<p>An <b>atomic value</b> is a value in the value space of an
<b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</dd>
<dt><a name="GLdt-atomization" id=
"GLdt-atomization"></a>atomization</dt>
<dd>
<p><b>Atomization</b> of a sequence is defined as the result of
invoking the <code>fn:data</code> function on the sequence, as
defined in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>.</p>
</dd>
<dt><a name="GLdt-available-docs" id=
"GLdt-available-docs"></a>available documents</dt>
<dd>
<p><b>Available documents.</b> This is a mapping of strings to
document nodes. Each string represents the absolute URI of a
resource. The document node is the root of a tree that represents
that resource using the <a title="data model" href=
"#dt-datamodel">data model</a>. The document node is returned by
the <code>fn:doc</code> function when applied to that URI.</p>
</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available node collections</dt>
<dd>
<p><b>Available node collections.</b> This is a mapping of strings
to sequences of nodes. Each string represents the absolute URI of a
resource. The sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument.</p>
</dd>
<dt><a name="GLdt-available-resource-collections" id=
"GLdt-available-resource-collections"></a>available resource
collections</dt>
<dd>
<p><b>Available resource collections.</b> This is a mapping of
strings to sequences of URIs. The string represents the absolute
URI of a resource which can be interpreted as an aggregation of a
number of individual resources each of which has its own URI. The
sequence of URIs represents the result of the
<code>fn:uri-collection</code> function when that URI is supplied
as the argument.</p>
</dd>
<dt><a name="GLdt-available-text-resources" id=
"GLdt-available-text-resources"></a>available text resources</dt>
<dd>
<p><b>Available text resources</b>. This is a mapping of strings to
text resources. Each string represents the absolute URI of a
resource. The resource is returned by the
<code>fn:unparsed-text</code> function when applied to that
URI.</p>
</dd>
<dt><a name="GLdt-axis-step" id="GLdt-axis-step"></a>axis step</dt>
<dd>
<p>An <b>axis step</b> returns a sequence of nodes that are
reachable from the context node via a specified axis. Such a step
has two parts: an <b>axis</b>, which defines the "direction of
movement" for the step, and a <a title="node test" href=
"#dt-node-test">node test</a>, which selects nodes based on their
kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</dd>
<dt><a name="GLdt-base-uri-decl" id="GLdt-base-uri-decl"></a>base
URI declaration</dt>
<dd>
<p>A <b>base URI declaration</b> specifies the <span><a title=
"Static Base URI" href="#dt-static-base-uri">Static Base URI</a>
property. The <a title="Static Base URI" href=
"#dt-static-base-uri">Static Base URI</a> property is used when
resolving relative URI references.</span></p>
</dd>
<dt><a name="GLdt-binding-sequence" id=
"GLdt-binding-sequence"></a>binding sequence</dt>
<dd>
<p>In a <code>for</code> clause or <code>window</code> clause, when
an expression is preceded by the keyword <code>in</code>, the value
of that expression is called a <b>binding sequence</b>.</p>
</dd>
<dt><a name="GLdt-boundary-whitespace" id=
"GLdt-boundary-whitespace"></a>boundary whitespace</dt>
<dd>
<p><b>Boundary whitespace</b> is a sequence of consecutive
whitespace characters within the content of a <a title=
"direct element constructor" href="#dt-direct-elem-const">direct
element constructor</a>, that is delimited at each end either by
the start or end of the content, or by a <a href=
"#doc-xquery30-DirectConstructor">DirectConstructor</a>, or by an
<a href="#doc-xquery30-EnclosedExpr">EnclosedExpr</a>. For this
purpose, characters generated by <a title="character reference"
href="#dt-character-reference">character references</a> such as
<code>&amp;#x20;</code> or by <a href=
"#doc-xquery30-CDataSection">CDataSections</a> are not considered
to be whitespace characters.</p>
</dd>
<dt><a name="GLdt-boundary-space-decl" id=
"GLdt-boundary-space-decl"></a>boundary-space declaration</dt>
<dd>
<p>A <b>boundary-space declaration</b> sets the <a title=
"boundary-space policy" href=
"#dt-boundary-space-policy">boundary-space policy</a> in the
<a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.
Boundary-space policy controls whether <a title=
"boundary whitespace" href="#dt-boundary-whitespace">boundary
whitespace</a> is preserved by element constructors during
processing of the query.</p>
</dd>
<dt><a name="GLdt-boundary-space-policy" id=
"GLdt-boundary-space-policy"></a>boundary-space policy</dt>
<dd>
<p><b>Boundary-space policy.</b> This component controls the
processing of <a title="boundary whitespace" href=
"#dt-boundary-whitespace">boundary whitespace</a> by <a title=
"direct element constructor" href="#dt-direct-elem-const">direct
element constructors</a>, as described in <a href=
"#id-whitespace"><b>3.9.1.4 Boundary Whitespace</b></a>.</p>
</dd>
<dt><a name="GLdt-built-in-function" id=
"GLdt-built-in-function"></a>built-in function</dt>
<dd>
<p>The <b>built-in functions</b> supported by XQuery 3.0 are
defined in <a href="#xpath-functions-30">[XQuery and XPath
Functions and Operators 3.0]</a>.</p>
</dd>
<dt><a name="GLdt-character-reference" id=
"GLdt-character-reference"></a>character reference</dt>
<dd>
<p>A <b>character reference</b> is an XML-style reference to a
<a href="#Unicode">[Unicode]</a> character, identified by its
decimal or hexadecimal codepoint.</p>
</dd>
<dt><a name="GLdt-collation" id="GLdt-collation"></a>collation</dt>
<dd>
<p>A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#xpath-functions-30">[XQuery and XPath Functions and Operators
3.0]</a>.</p>
</dd>
<dt><a name="GLdt-comma-operator" id=
"GLdt-comma-operator"></a>comma operator</dt>
<dd>
<p>One way to construct a sequence is by using the <b>comma
operator</b>, which evaluates each of its operands and concatenates
the resulting sequences, in order, into a single result
sequence.</p>
</dd>
<dt><a name="GLdt-computed-elem-const" id=
"GLdt-computed-elem-const"></a>computed element constructor</dt>
<dd>
<p>A <b>computed element constructor</b> creates an element node,
allowing both the name and the content of the node to be
computed.</p>
</dd>
<dt><a name="GLdt-construction-decl" id=
"GLdt-construction-decl"></a>construction declaration</dt>
<dd>
<p>A <b>construction declaration</b> sets the <a title=
"construction mode" href="#dt-construction-mode">construction
mode</a> in the <a title="static context" href=
"#dt-static-context">static context</a>, overriding any
implementation-defined default.</p>
</dd>
<dt><a name="GLdt-construction-mode" id=
"GLdt-construction-mode"></a>construction mode</dt>
<dd>
<p><b>Construction mode.</b> The construction mode governs the
behavior of element and document node constructors. If construction
mode is <code>preserve</code>, the type of a constructed element
node is <code>xs:anyType</code>, and all attribute and element
nodes copied during node construction retain their original types.
If construction mode is <code>strip</code>, the type of a
constructed element node is <code>xs:untyped</code>; all element
nodes copied during node construction receive the type
<code>xs:untyped</code>, and all attribute nodes copied during node
construction receive the type <code>xs:untypedAtomic</code>.</p>
</dd>
<dt><a name="GLdt-constructor-function" id=
"GLdt-constructor-function"></a>constructor function</dt>
<dd>
<p>The <b>constructor function</b> for a given type is used to
convert instances of other atomic types into the given type. The
semantics of the constructor function call <code>T($arg)</code> are
defined to be equivalent to the expression <code>(($arg) cast as
T?)</code>.</p>
</dd>
<dt><a name="GLdt-content-expression" id=
"GLdt-content-expression"></a>content expression</dt>
<dd>
<p>The final part of a computed constructor is an expression
enclosed in braces, called the <b>content expression</b> of the
constructor, that generates the content of the node.</p>
</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context
item</dt>
<dd>
<p>The <b>context item</b> is the <a title="item" href=
"#dt-item">item</a> currently being processed.</p>
</dd>
<dt><a name="GLdt-context-item-static-type" id=
"GLdt-context-item-static-type"></a>context item static type</dt>
<dd>
<p><b>Context item static type.</b> This component defines the
<a title="static type" href="#dt-static-type">static type</a> of
the context item within the scope of a given expression.</p>
</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context
node</dt>
<dd>
<p>When the context item is a node, it can also be referred to as
the <b>context node</b>.</p>
</dd>
<dt><a name="GLdt-context-position" id=
"GLdt-context-position"></a>context position</dt>
<dd>
<p>The <b>context position</b> is the position of the context item
within the sequence of items currently being processed.</p>
</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context
size</dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence
of items currently being processed.</p>
</dd>
<dt><a name="GLdt-copy-namespaces-decl" id=
"GLdt-copy-namespaces-decl"></a>copy-namespaces declaration</dt>
<dd>
<p>A <b>copy-namespaces declaration</b> sets the value of <a title=
"copy-namespaces mode" href=
"#dt-copy-namespaces-mode">copy-namespaces mode</a> in the
<a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.
Copy-namespaces mode controls the namespace bindings that are
assigned when an existing element node is copied by an element
constructor or document constructor.</p>
</dd>
<dt><a name="GLdt-copy-namespaces-mode" id=
"GLdt-copy-namespaces-mode"></a>copy-namespaces mode</dt>
<dd>
<p><b>Copy-namespaces mode.</b> This component controls the
namespace bindings that are assigned when an existing element node
is copied by an element constructor, as described in <a href=
"#id-element-constructor"><b>3.9.1 Direct Element
Constructors</b></a>. Its value consists of two parts:
<code>preserve</code> or <code>no-preserve</code>, and
<code>inherit</code> or <code>no-inherit</code>.</p>
</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current
dateTime</dt>
<dd>
<p><b>Current dateTime.</b> This information represents an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xquery">a
query</span>, and includes an explicit timezone. It can be
retrieved by the <code>fn:current-dateTime</code> function. If
invoked multiple times during the execution of <span class=
"xquery">a query</span>, this function always returns the same
result.</p>
</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
model</dt>
<dd>
<p>XQuery 3.0 operates on the abstract, logical structure of an XML
document, rather than its surface syntax. This logical structure,
known as the <b>data model</b>, is defined in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM)
3.0]</a>.</p>
</dd>
<dt><a name="GLdt-decimal-format-decl" id=
"GLdt-decimal-format-decl"></a>decimal-format declaration</dt>
<dd>
<p>A <b>decimal format declaration</b> adds a decimal format to the
<a title="statically known decimal formats" href=
"#dt-static-decimal-formats">statically known decimal formats</a>,
which define the properties used to format numbers using the
<code>fn:format-number()</code> function</p>
</dd>
<dt><a name="GLid-static-decimal-separator" id=
"GLid-static-decimal-separator"></a>decimal-separator</dt>
<dd>
<p><b>decimal-separator</b> specifies the character used for the
decimal-separator-symbol; the default value is the period character
(.)</p>
</dd>
<dt><a name="GLdt-default-calendar" id=
"GLdt-default-calendar"></a>default calendar</dt>
<dd>
<p><b>Default calendar.</b> This is the calendar used when
formatting dates in human-readable output (for example, by the
functions <code>fn:format-date</code> and
<code>fn:format-dateTime</code>) if no other calendar is requested.
The value is a string.</p>
</dd>
<dt><a name="GLdt-def-collation" id=
"GLdt-def-collation"></a>default collation</dt>
<dd>
<p><b>Default collation.</b> This identifies one of the collations
in <a title="statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.</p>
</dd>
<dt><a name="GLdt-default-collation-decl" id=
"GLdt-default-collation-decl"></a>default collation
declaration</dt>
<dd>
<p>A <b>default collation declaration</b> sets the value of the
<a title="default collation" href="#dt-def-collation">default
collation</a> in the <a title="static context" href=
"#dt-static-context">static context</a>, overriding any
implementation-defined default.</p>
</dd>
<dt><a name="GLdt-def-elemtype-ns" id=
"GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<p><b>Default element/type namespace.</b> This is a namespace URI
or <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where an element or type name is
expected.</p>
</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default
function namespace</dt>
<dd>
<p><b>Default function namespace.</b> This is a namespace URI or
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where a function name is expected.</p>
</dd>
<dt><a name="GLdt-default-language" id=
"GLdt-default-language"></a>default language</dt>
<dd>
<p><b>Default language.</b> This is the natural language used when
creating human-readable output (for example, by the functions
<code>fn:format-date</code> and <code>fn:format-integer</code>) if
no other language is requested. The value is a language code as
defined by the type <code>xs:language</code>.</p>
</dd>
<dt><a name="GLdt-default-collection" id=
"GLdt-default-collection"></a>default node collection</dt>
<dd>
<p><b>Default node collection.</b> This is the sequence of nodes
that would result from calling the <code>fn:collection</code>
function with no arguments.</p>
</dd>
<dt><a name="GLdt-default-empty-order" id=
"GLdt-default-empty-order"></a>default order for empty
sequences</dt>
<dd>
<p><b>Default order for empty sequences.</b> This component
controls the processing of empty sequences and <code>NaN</code>
values as ordering keys in an <code>order by</code> clause in a
FLWOR expression, as described in <a href=
"#id-order-by-clause"><b>3.10.8 Order By Clause</b></a>.</p>
</dd>
<dt><a name="GLdt-default-place" id=
"GLdt-default-place"></a>default place</dt>
<dd>
<p><b>Default place.</b> This is a geographical location used to
identify the place where events happened (or will happen) when
formatting dates and times using functions such as
<code>fn:format-date</code> and <code>fn:format-dateTime</code>, if
no other place is specified. It is used when translating timezone
offsets to civil timezone names, and when using calendars where the
translation from ISO dates/times to a local representation is
dependent on geographical location. Possible representations of
this information are an ISO country code or an Olson timezone name,
but implementations are free to use other representations from
which the above information can be derived.</p>
</dd>
<dt><a name="GLdt-default-resource-collection" id=
"GLdt-default-resource-collection"></a>default resource
collection</dt>
<dd>
<p><b>Default resource collection.</b> This is the sequence of URIs
that would result from calling the <code>fn:uri-collection</code>
function with no arguments.</p>
</dd>
<dt><a name="GLdelimiting-token" id=
"GLdelimiting-token"></a>delimiting terminal symbol</dt>
<dd>
<p>The <b>delimiting terminal symbols</b> are: <a href=
"#prod-xquery30-S">S</a>, "!", "!=", <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>, "#", "#)", "$",
"%", "(", "(#", ")", "*", "+", (comma), "-", "--&gt;", (dot), "..",
"/", "//", "/&gt;", (colon), "::", ":=", (semi-colon), "&lt;",
"&lt;!--", "&lt;![CDATA[", "&lt;/", "&lt;&lt;", "&lt;=", "&lt;?",
"=", "&gt;", "&gt;=", "&gt;&gt;", "?", "?&gt;", "@", <a href=
"#prod-xquery30-BracedURILiteral">BracedURILiteral</a>, "[", "]",
"]]&gt;", "{", "|", "||", "}"</p>
</dd>
<dt><a name="GLdt-depends-on" id="GLdt-depends-on"></a>depends
on</dt>
<dd>
<p>A variable value (or the context item) <b>depends on</b> another
variable value (or the context item) if, during the evaluation of
the initializing expression of the former, the latter is accessed
through the module context.</p>
</dd>
<dt><a name="GLid-static-decimal-format-digit-sign" id=
"GLid-static-decimal-format-digit-sign"></a>digit-sign</dt>
<dd>
<p><b>digit-sign</b> specifies the character used for the
digit-sign in the picture string; the default value is the number
sign character (#)</p>
</dd>
<dt><a name="GLdt-direct-elem-const" id=
"GLdt-direct-elem-const"></a>direct element constructor</dt>
<dd>
<p>A <b>direct element constructor</b> is a form of element
constructor in which the name of the constructed element is a
constant.</p>
</dd>
<dt><a name="GLdt-document-order" id=
"GLdt-document-order"></a>document order</dt>
<dd>
<p>Informally, <b>document order</b> is the order in which nodes
appear in the XML serialization of a document.</p>
</dd>
<dt><a name="GLdt-dynamic-context" id=
"GLdt-dynamic-context"></a>dynamic context</dt>
<dd>
<p>The <b>dynamic context</b> of an expression is defined as
information that is available at the time the expression is
evaluated.</p>
</dd>
<dt><a name="GLdt-dynamic-error" id=
"GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<p>A <b>dynamic error</b> is an error that must be detected during
the dynamic evaluation phase and may be detected during the static
analysis phase. Numeric overflow is an example of a dynamic
error.</p>
</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd>
<p>The <b>dynamic evaluation phase</b> is the phase during which
the value of an expression is computed.</p>
</dd>
<dt><a name="GLdt-dynamic-function-invocation" id=
"GLdt-dynamic-function-invocation"></a>dynamic function call</dt>
<dd>
<p>A <b>dynamic function <span>call</span></b> consists of a
<span>base expression</span> that returns the function and a
parenthesized list of zero or more arguments (<a title=
"argument expression" href="#dt-arg-expr">argument expressions</a>
or ArgumentPlaceholders).</p>
</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic
type</dt>
<dd>
<p>A <b>dynamic type</b> is associated with each value as it is
computed. The dynamic type of a value may be more specific than the
<a title="static type" href="#dt-static-type">static type</a> of
the expression that computed it (for example, the static type of an
expression might be <code>xs:integer*</code>, denoting a sequence
of zero or more integers, but at evaluation time its value may have
the dynamic type <code>xs:integer</code>, denoting exactly one
integer.)</p>
</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
value</dt>
<dd>
<p>The <b>effective boolean value</b> of a value is defined as the
result of applying the <code>fn:boolean</code> function to the
value, as defined in <a href="#xpath-functions-30">[XQuery and
XPath Functions and Operators 3.0]</a>.</p>
</dd>
<dt><a name="GLid-effective-case-switch-expression" id=
"GLid-effective-case-switch-expression"></a>effective case</dt>
<dd>
<p>The <b>effective case</b> of a switch expression is the first
case clause that matches, using the rules given above, or the
default clause if no such case clause exists.</p>
</dd>
<dt><a name="GLdt-effective-case" id=
"GLdt-effective-case"></a>effective case</dt>
<dd>
<p>The <b>effective case</b> in a <code>typeswitch</code>
expression is the first <code>case</code> clause in which the value
of the operand expression matches a <a href=
"#doc-xquery30-SequenceType">SequenceType</a> in the <a href=
"#doc-xquery30-SequenceType">SequenceTypeUnion</a> of the
<code>case</code> clause, using the rules of <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>.</p>
</dd>
<dt><a name="GLdt-empty-order-decl" id=
"GLdt-empty-order-decl"></a>empty order declaration</dt>
<dd>
<p>An <b>empty order declaration</b> sets the <a title=
"default order for empty sequences" href=
"#dt-default-empty-order">default order for empty sequences</a> in
the <a title="static context" href="#dt-static-context">static
context,</a> overriding any implementation-defined default. This
declaration controls the processing of empty sequences and
<code>NaN</code> values as ordering keys in an <code>order
by</code> clause in a FLWOR expression.</p>
</dd>
<dt><a name="GLdt-empty-sequence" id=
"GLdt-empty-sequence"></a>empty sequence</dt>
<dd>
<p>A sequence containing zero items is called an <b>empty
sequence</b>.</p>
</dd>
<dt><a name="GLdt-encoding-declaration" id=
"GLdt-encoding-declaration"></a>encoding declaration</dt>
<dd>
<p>If present, a version declaration may optionally include an
<b>encoding declaration</b>. The value of the string literal
following the keyword <code>encoding</code> is an encoding name,
and must conform to the definition of <code>EncName</code>
specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087"
title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding
declaration is to allow the writer of a query to provide a string
that indicates how the query is encoded, such as
"<code>UTF-8</code>", "<code>UTF-16</code>", or
"<code>US-ASCII</code>".</p>
</dd>
<dt><a name="GLdt-environment-variables" id=
"GLdt-environment-variables"></a>environment variables</dt>
<dd>
<p><b>Environment variables.</b> This is a <span>mapping from names
to values.</span> Both the names and the values are strings. The
names are compared using an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collation,
and are unique under this collation. The set of environment
variables is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> and
<strong>may</strong> be empty.</p>
</dd>
<dt><a name="GLdt-equivalent-grouping-keys" id=
"GLdt-equivalent-grouping-keys"></a>equivalent grouping keys</dt>
<dd>
<p>Two tuples <var>T1</var> and <var>T2</var> have <b>equivalent
grouping keys</b> if and only if, for each grouping variable
<var>GV</var>, the atomized value of <var>GV</var> in <var>T1</var>
is deep-equal to the atomized value of <var>GV</var> in
<var>T2</var>, as defined by applying the function
<code>fn:deep-equal</code> using the appropriate collation.</p>
</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error
value</dt>
<dd>
<p>In addition to its identifying QName, a dynamic error may also
carry a descriptive string and one or more additional values called
<b>error values</b>.</p>
</dd>
<dt><a name="GLdt-expanded-qname" id=
"GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<p>An <b>expanded QName</b> consists of an optional namespace URI
and a local name. An expanded QName also retains its original
namespace prefix (if any), to facilitate casting the expanded QName
into a string.</p>
</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>
<p>The <b>expression context</b> for a given expression consists of
all the information that can affect the result of the
expression.</p>
</dd>
<dt><a name="GLdt-extension-expression" id=
"GLdt-extension-expression"></a>extension expression</dt>
<dd>
<p>An <b>extension expression</b> is an expression whose semantics
are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLdt-external-function" id=
"GLdt-external-function"></a>external function</dt>
<dd>
<p><b>External functions</b> are functions that are implemented
outside the query environment.</p>
</dd>
<dt><a name="GLdt-filter-expression" id=
"GLdt-filter-expression"></a>filter expression</dt>
<dd>
<p>An expression followed by a predicate (that is,
<code>E1[E2]</code>) is referred to as a <b>filter expression</b>:
its effect is to return those items from the value of
<code>E1</code> that satisfy the predicate in E2.</p>
</dd>
<dt><a name="GLdt-fixed-position" id=
"GLdt-fixed-position"></a>fixed position</dt>
<dd>
<p>In a partial function application, a <b>fixed position</b> is an
argument/parameter position for which the <code>ArgumentList</code>
has an argument expression (as opposed to an
<code>ArgumentPlaceholder</code>).</p>
</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd>
<p>The first three components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> (context item,
context position, and context size) are called the <b>focus</b> of
the expression.</p>
</dd>
<dt><a name="GLdt-function-assertion" id=
"GLdt-function-assertion"></a>function assertion</dt>
<dd>
<p>A <b>function assertion</b> is a predicate that restricts the
set of functions matched by a FunctionTest. It uses the same syntax
as <a href="#id-annotations"><b>4.15 Annotations</b></a>.</p>
</dd>
<dt><a name="GLdt-function-item-coercion" id=
"GLdt-function-item-coercion"></a>function coercion</dt>
<dd>
<p><b>Function coercion</b> wraps a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
in a new function with signature the same as the expected type.
This effectively delays the checking of the argument and return
types until the function is invoked.</p>
</dd>
<dt><a name="GLdt-function-conversion" id=
"GLdt-function-conversion"></a>function conversion rules</dt>
<dd>
<p>The <b>function conversion rules</b> are used to convert an
argument value <span class="xquery">or a return value</span> to its
expected type; that is, to the declared type of the function
<span class="xquery">parameter or return.</span></p>
</dd>
<dt><a name="GLdt-generalized-atomic-type" id=
"GLdt-generalized-atomic-type"></a>generalized atomic type</dt>
<dd>
<p>A <b>generalized atomic type</b> is a type which is either (a)
an atomic type or (b) a <span><a title="pure union type" href=
"#dt-pure-union-type">pure union type</a></span></p>
</dd>
<dt><a name="GLdt-grouping-key" id="GLdt-grouping-key"></a>grouping
key</dt>
<dd>
<p>The atomized value of a <a title="grouping variable" href=
"#dt-grouping-variable">grouping variable</a> is called a
<b>grouping key</b>.</p>
</dd>
<dt><a name="GLdt-grouping-variable" id=
"GLdt-grouping-variable"></a>grouping variable</dt>
<dd>
<p>Each grouping specification specifies one <a href=
"#doc-xquery30-GroupingVariable">grouping variable</a>, which
refers to variable bindings in the pre-grouping tuples. The values
of the grouping variables are used to assign pre-grouping tuples to
groups.</p>
</dd>
<dt><a name="GLid-static-decimal-format-grouping-separator" id=
"GLid-static-decimal-format-grouping-separator"></a>grouping-separator</dt>
<dd>
<p><b>grouping-separator</b> specifies the character used for the
grouping-separator-symbol, which is typically used as a thousands
separator; the default value is the comma character (,)</p>
</dd>
<dt><a name="GLdt-higher-order-function-feature" id=
"GLdt-higher-order-function-feature"></a>higher-order function
feature</dt>
<dd>
<p>The <b>Higher Order Function Feature</b> allows an expression to
evaluate to a function, and allows dynamic function calls.</p>
</dd>
<dt><a name="GLIgnorableWhitespace" id=
"GLIgnorableWhitespace"></a>ignorable whitespace</dt>
<dd>
<p><b>Ignorable whitespace</b> consists of any <a title=
"whitespace" href="#Whitespace">whitespace</a> characters that may
occur between <a title="terminal" href="#terminal">terminals</a>,
unless these characters occur in the context of a production marked
with a <a href="#ExplicitWhitespaceHandling">ws:explicit</a>
annotation, in which case they can occur only where explicitly
specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
Explicit Whitespace Handling</b></a>).</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may
differ between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.</p>
</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may
differ between implementations, but must be specified by the
implementor for each particular implementation.</p>
</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
timezone</dt>
<dd>
<p><b>Implicit timezone.</b> This is the timezone to be used when a
date, time, or dateTime value that does not have a timezone is used
in a comparison or arithmetic operation. The implicit timezone is
an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> for the range of valid values of a timezone.</p>
</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
attribute declarations</dt>
<dd>
<p><b>In-scope attribute declarations.</b> Each attribute
declaration is identified either by an <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> (for a top-level
attribute declaration) or by an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration).
<span class="xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope attribute declarations include all attribute declarations
found in imported schemas.</span></p>
</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd>
<p><b>In-scope element declarations.</b> Each element declaration
is identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level element
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). <span class=
"xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope element declarations include all element declarations
found in imported schemas.</span></p>
</dd>
<dt><a name="GLdt-in-scope-namespaces" id=
"GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
<p>The <b>in-scope namespaces</b> property of an element node is a
set of namespace bindings, each of which associates a namespace
prefix with a URI.</p>
</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
definitions</dt>
<dd>
<p><b>In-scope schema definitions.</b> This is a generic term for
all the element declarations, attribute declarations, and schema
type definitions that are in scope during <span>static
analysis</span> of an expression.</p>
</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope schema
type</dt>
<dd>
<p><b>In-scope schema types.</b> Each schema type definition is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>)
or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
<span class="xquery">If the <a title="schema aware feature" href=
"#dt-schema-aware-feature">Schema Aware Feature</a> is supported,
in-scope schema types also include all type definitions found in
imported schemas.</span></p>
</dd>
<dt><a name="GLdt-in-scope-variables" id=
"GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd>
<p><b>In-scope variables.</b> This is a <span>mapping from
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> to type.</span> It defines the set of variables that are
available for reference within an expression. The <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> is
the name of the variable, and the type is the <a title=
"static type" href="#dt-static-type">static type</a> of the
variable.</p>
</dd>
<dt><a name="GLid-static-decimal-format-infinity" id=
"GLid-static-decimal-format-infinity"></a>infinity</dt>
<dd>
<p><b>infinity</b> specifies the string used for the
infinity-symbol; the default value is the string "Infinity"</p>
</dd>
<dt><a name="GLdt-initial-context-item" id=
"GLdt-initial-context-item"></a>initial context item</dt>
<dd>
<p>The <b>initial context item</b> is a context item that an
implementation can set before processing a query begins. The query
body and the prolog of every module in a query share the same
initial context item.</p>
</dd>
<dt><a name="GLdt-initializing-expression" id=
"GLdt-initializing-expression"></a>initializing expression</dt>
<dd>
<p>If a variable declaration includes an expression
(<code>VarValue</code> or <code>VarDefaultValue</code>), the
expression is called an <b>initializing expression.</b> The static
context for an initializing expression includes all functions,
variables, and namespaces that are declared or imported anywhere in
the Prolog, other than the variable being declared.</p>
</dd>
<dt><a name="GLdt-inline-func" id="GLdt-inline-func"></a>inline
function expression</dt>
<dd>
<p>An <b>inline function expression</b> creates an anonymous
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>
defined directly in the inline function expression itself.</p>
</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd>
<p>An <b>item</b> is either an <a title="atomic value" href=
"#dt-atomic-value">atomic value</a>, a <a title="node" href=
"#dt-node">node</a>, or a <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>.</p>
</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>
<p>An alternative form of a node test called a <b>kind test</b> can
select nodes based on their kind, name, and <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>lexical QName</dt>
<dd>
<p>A <b>lexical QName</b> is a name that conforms to the syntax of
<a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a>.</p>
</dd>
<dt><a name="GLdt-library-module" id=
"GLdt-library-module"></a>library module</dt>
<dd>
<p>A module that does not contain a <a title="query body" href=
"#dt-queryBody">Query Body</a> is called a <b>library module</b>. A
library module consists of a <a title="module declaration" href=
"#dt-module-declaration">module declaration</a> followed by a
<a title="Prolog" href="#dt-prolog">Prolog</a>.</p>
</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd>
<p>A <b>literal</b> is a direct syntactic representation of an
atomic value.</p>
</dd>
<dt><a name="GLdt-main-module" id="GLdt-main-module"></a>main
module</dt>
<dd>
<p>A <b>main module</b> consists of a <a title="Prolog" href=
"#dt-prolog">Prolog</a> followed by a <a title="query body" href=
"#dt-queryBody">Query Body</a>.</p>
</dd>
<dt><a name="GLmay" id="GLmay"></a>may</dt>
<dd>
<p><b>MAY</b> means that an item is truly optional.</p>
</dd>
<dt><a name="GLid-static-decimal-format-minus-sign" id=
"GLid-static-decimal-format-minus-sign"></a>minus-sign</dt>
<dd>
<p><b>minus-sign</b> specifies the character used for the
minus-sign-symbol; the default value is the hyphen-minus character
(-, #x2D). The value must be a single character.</p>
</dd>
<dt><a name="GLdt-module" id="GLdt-module"></a>module</dt>
<dd>
<p>A <b>module</b> is a fragment of XQuery code that conforms to
the <a href="#doc-xquery30-Module">Module</a> grammar and can
independently undergo the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a> described in
<a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>. Each module is either a <a title="main module"
href="#dt-main-module">main module</a> or a <a title=
"library module" href="#dt-library-module">library module</a>.</p>
</dd>
<dt><a name="GLdt-module-context" id=
"GLdt-module-context"></a>module context</dt>
<dd>
<p>The <b>module context</b> for a given module consists of all the
information that is accessible to top-level expressions in the
module.</p>
</dd>
<dt><a name="GLdt-module-declaration" id=
"GLdt-module-declaration"></a>module declaration</dt>
<dd>
<p>A <b>module declaration</b> serves to identify a <a title=
"module" href="#dt-module">module</a> as a <a title=
"library module" href="#dt-library-module">library module</a>. A
module declaration begins with the keyword <code>module</code> and
contains a namespace prefix and a <a href=
"#doc-xquery30-URILiteral">URILiteral</a>.</p>
</dd>
<dt><a name="GLdt-module-feature" id=
"GLdt-module-feature"></a>module feature</dt>
<dd>
<p><span>The</span> <b>Module Feature</b> allows a query Prolog to
contain a <b>Module Import</b> and allows <b>library modules</b> to
be created.</p>
</dd>
<dt><a name="GLdt-module-import" id="GLdt-module-import"></a>module
import</dt>
<dd>
<p>A <b>module import</b> imports the <span>public variable
declarations and public function declarations</span> from one or
more <a title="library module" href="#dt-library-module">library
modules</a> into the <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> and <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> of the importing
<a title="module" href="#dt-module">module</a>.</p>
</dd>
<dt><a name="GLmust" id="GLmust"></a>must</dt>
<dd>
<p><b>MUST</b> means that the item is an absolute requirement of
the specification.</p>
</dd>
<dt><a name="GLmustnot" id="GLmustnot"></a>must not</dt>
<dd>
<p><b>MUST NOT</b> means that the item is an absolute prohibition
of the specification.</p>
</dd>
<dt><a name="GLdt-name-expression" id=
"GLdt-name-expression"></a>name expression</dt>
<dd>
<p>When an expression is used to specify the name of a constructed
node, that expression is called the <b>name expression</b> of the
constructor.</p>
</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>
<p>A node test that consists only of an EQName or a Wildcard is
called a <b>name test</b>.</p>
</dd>
<dt><a name="GLdt-named-func" id="GLdt-named-func"></a>named
function</dt>
<dd>
<p>A <b>named function</b> is a function defined in the static
context for the <span class="xquery">query</span>. To uniquely
identify a particular named function, both its name as an
<span>expanded</span> QName and its arity are required.</p>
</dd>
<dt><a name="GLdt-named-function-ref" id=
"GLdt-named-function-ref"></a>named function reference</dt>
<dd>
<p>A <b><span>named function reference</span></b>
<span>denotes</span> a <a title="named function" href=
"#dt-named-func">named function</a>.</p>
</dd>
<dt><a name="GLdt-named-functions" id=
"GLdt-named-functions"></a>named functions</dt>
<dd>
<p><b>Named functions</b>. This is a mapping from (expanded QName,
arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-function-item">function</a><sup><small>DM30</small></sup>.</p>
</dd>
<dt><a name="GLdt-namespace-declaration" id=
"GLdt-namespace-declaration"></a>namespace declaration</dt>
<dd>
<p>A <b>namespace declaration</b> declares a namespace prefix and
associates it with a namespace URI, adding the (prefix, URI) pair
to the set of <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
</dd>
<dt><a name="GLdt-namespace-decl-attr" id=
"GLdt-namespace-decl-attr"></a>namespace declaration attribute</dt>
<dd>
<p>A <b>namespace declaration attribute</b> is used inside a direct
element constructor. Its purpose is to bind a namespace prefix or
to set the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a> for the
constructed element node, including its attributes.</p>
</dd>
<dt><a name="GLdt-namespace-sensitive" id=
"GLdt-namespace-sensitive"></a>namespace-sensitive</dt>
<dd>
<p>The <b>namespace-sensitive</b> types are <code>xs:QName</code>,
<code>xs:NOTATION</code>, types derived by restriction from
<code>xs:QName</code> or <code>xs:NOTATION</code>, list types that
have a namespace-sensitive item type, and union types with a
namespace-sensitive type in their transitive membership.</p>
</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd>
<p>A <b>node</b> is an instance of one of the <b>node kinds</b>
defined in <a href="#xpath-datamodel-30">[XQuery and XPath Data
Model (XDM) 3.0]</a>.</p>
</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd>
<p>A <b>node test</b> is a condition on the name, kind (element,
attribute, text, document, comment, or processing instruction),
and/or <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of a node. A node test determines which nodes
contained by an axis are selected by a <a title="step" href=
"#dt-step">step</a>.</p>
</dd>
<dt><a name="GLnon-delimiting-token" id=
"GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt>
<dd>
<p>The <b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xquery30-URIQualifiedName">URIQualifiedName</a>, <a href=
"#prod-xquery30-NCName">NCName</a>, <a href=
"#prod-xquery30-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xquery30-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xquery30-QName">QName</a>, "NaN", "allowing", "ancestor",
"ancestor-or-self", "and", "as", "ascending", "at", "attribute",
"base-uri", "boundary-space", "by", "case", "cast", "castable",
"catch", "child", "collation", "comment", "construction",
"context", "copy-namespaces", "count", "decimal-format",
"decimal-separator", "declare", "default", "descendant",
"descendant-or-self", "descending", "digit", "div", "document",
"document-node", "element", "else", "empty", "empty-sequence",
"encoding", "end", "eq", "every", "except", "external",
"following", "following-sibling", "for", "function", "ge",
"greatest", "group", "grouping-separator", "gt", "idiv", "if",
"import", "in", "infinity", "inherit", "instance", "intersect",
"is", "item", "lax", "le", "least", "let", "lt", "minus-sign",
"mod", "module", "namespace", "namespace-node", "ne", "next",
"no-inherit", "no-preserve", "node", "of", "only", "option", "or",
"order", "ordered", "ordering", "parent", "pattern-separator",
"per-mille", "percent", "preceding", "preceding-sibling",
"preserve", "previous", "processing-instruction", "return",
"satisfies", "schema", "schema-attribute", "schema-element",
"self", "sliding", "some", "stable", "start", "strict", "strip",
"switch", "text", "then", "to", "treat", "try", "tumbling", "type",
"typeswitch", "union", "unordered", "validate", "variable",
"version", "when", "where", "window", "xquery", "zero-digit"</p>
</dd>
<dt><a name="GLdt-numeric" id="GLdt-numeric"></a>numeric</dt>
<dd>
<p>When referring to a type, the term <b>numeric</b> denotes the
types <code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</p>
</dd>
<dt><a name="GLdt-numeric-predicate" id=
"GLdt-numeric-predicate"></a>numeric predicate</dt>
<dd>
<p>A predicate whose predicate expression returns a numeric type is
called a <b>numeric predicate</b>.</p>
</dd>
<dt><a name="GLdt-operator-function" id=
"GLdt-operator-function"></a>operator function</dt>
<dd>
<p>For each operator and valid combination of operand types, the
operator mapping tables specify a result type and an <b>operator
function</b> that implements the semantics of the operator for the
given types.</p>
</dd>
<dt><a name="GLdt-option-declaration" id=
"GLdt-option-declaration"></a>option declaration</dt>
<dd>
<p>An <b>option declaration</b> declares an option that affects the
behavior of a particular implementation. Each option consists of an
identifying EQName and a StringLiteral.</p>
</dd>
<dt><a name="GLdt-ordering-mode" id=
"GLdt-ordering-mode"></a>ordering mode</dt>
<dd>
<p><b>Ordering mode.</b> Ordering mode, which has the value
<code>ordered</code> or <code>unordered</code>, affects the
ordering of the result sequence returned by certain
<span>expressions, as discussed in <a href=
"#id-unordered-expressions"><b>3.11 Ordered and Unordered
Expressions</b></a>.</span></p>
</dd>
<dt><a name="GLdt-ordering-mode-decl" id=
"GLdt-ordering-mode-decl"></a>ordering mode declaration</dt>
<dd>
<p>An <b>ordering mode declaration</b> sets the <a title=
"ordering mode" href="#dt-ordering-mode">ordering mode</a> in the
<a title="static context" href="#dt-static-context">static
context</a>, overriding any implementation-defined default.</p>
</dd>
<dt><a name="GLdt-output-declaration" id=
"GLdt-output-declaration"></a>output declaration</dt>
<dd>
<p>An <b>output declaration</b> is an option declaration in the
namespace "http://www.w3.org/2010/xslt-xquery-serialization"; it is
used to declare serialization parameters.</p>
</dd>
<dt><a name="GLdt-partial-function-application" id=
"GLdt-partial-function-application"></a>partial function
application</dt>
<dd>
<p>A <span>static or <a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic</a></span> function call
is a <b>partial function application</b> if one or more arguments
is an ArgumentPlaceholder.</p>
</dd>
<dt><a name="GLdt-path-expression" id=
"GLdt-path-expression"></a>path expression</dt>
<dd>
<p>A <b>path expression</b> can be used to locate nodes within
trees. A path expression consists of a series of one or more
<a title="step" href="#dt-step">steps</a>, separated by
"<code>/</code>" or "<code>//</code>", and optionally beginning
with "<code>/</code>" or "<code>//</code>".</p>
</dd>
<dt><a name="GLid-static-decimal-format-pattern-separator-sign" id=
"GLid-static-decimal-format-pattern-separator-sign"></a>pattern-separator-sign</dt>
<dd>
<p><b>pattern-separator</b> specifies the character used for the
pattern-separator-symbol, which separates positive and negative
sub-pictures in a picture string; the default value is the
semi-colon character (;)</p>
</dd>
<dt><a name="GLid-static-decimal-format-per-mille-sign" id=
"GLid-static-decimal-format-per-mille-sign"></a>per-mille-sign</dt>
<dd>
<p><b>per-mille</b> specifies the character used for the
per-mille-symbol; the default value is the Unicode per-mille
character (#x2030)</p>
</dd>
<dt><a name="GLid-static-decimal-format-percent-sign" id=
"GLid-static-decimal-format-percent-sign"></a>percent-sign</dt>
<dd>
<p><b>percent</b> specifies the character used for the
percent-symbol; the default value is the percent character (%)</p>
</dd>
<dt><a name="GLdt-positional-variable" id=
"GLdt-positional-variable"></a>positional variable</dt>
<dd>
<p>A <b>positional variable</b> is a variable that is preceded by
the keyword <code>at</code>.</p>
</dd>
<dt><a name="GLdt-pragma" id="GLdt-pragma"></a>pragma</dt>
<dd>
<p>A <b>pragma</b> is denoted by the delimiters <code>(#</code> and
<code>#)</code>, and consists of an identifying EQName followed by
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>
content.</p>
</dd>
<dt><a name="GLdt-predefined-entity-reference" id=
"GLdt-predefined-entity-reference"></a>predefined entity
reference</dt>
<dd>
<p>A <b>predefined entity reference</b> is a short sequence of
characters, beginning with an ampersand, that represents a single
character that might otherwise have syntactic significance.</p>
</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd>
<p><b>Primary expressions</b> are the basic primitives of the
language. They include literals, variable references, context item
expressions, <span class="xquery">constructors,</span> and function
calls. A primary expression may also be created by enclosing any
expression in parentheses, which is sometimes helpful in
controlling the precedence of operators.</p>
</dd>
<dt><a name="GLdt-principal-node-kind" id=
"GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
<p>Every axis has a <b>principal node kind</b>. If an axis can
contain elements, then the principal node kind is element;
otherwise, it is the kind of nodes that the axis can contain.</p>
</dd>
<dt><a name="GLdt-private-variable" id=
"GLdt-private-variable"></a>private variable</dt>
<dd>
<p>A <b>private variable</b> is a variable with a
<code>%private</code> annotation. A private variable is hidden from
<a title="module import" href="#dt-module-import">module
import</a>, which can not import it into the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> of another module.</p>
</dd>
<dt><a name="GLdt-private-function" id=
"GLdt-private-function"></a>private function</dt>
<dd>
<p>A <b>private function</b> is a function with a
<code>%private</code> annotation. A private function is hidden from
<a title="module import" href="#dt-module-import">module
import</a>, which can not import it into the <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> of another module.</p>
</dd>
<dt><a name="GLdt-public-function" id=
"GLdt-public-function"></a>public function</dt>
<dd>
<p>A <b>public function</b> is a function <span>without a
<code>%private</code> annotation</span>. A public function is
accessible to <a title="module import" href=
"#dt-module-import">module import</a>, which can import it into the
<a title="statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a> of another module.</p>
</dd>
<dt><a name="GLdt-public-variable" id=
"GLdt-public-variable"></a>public variable</dt>
<dd>
<p>A <b>public variable</b> is a variable without a
<code>%private</code> annotation. A public variable is accessible
to <a title="module import" href="#dt-module-import">module
import</a>, which can import it into the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> of another module. <span>Using <code>%public</code>
and <code>%private</code> annotations in a main module is not an
error, but it does not affect module imports, since a main module
cannot be imported.</span> It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0116" title=
"err:XQST0116">err:XQST0116</a>] <span>if a variable declaration
contains both a <code>%private</code> and a <code>%public</code>
annotation, more than one <code>%private</code> annotation, or more
than one <code>%public</code> annotation.</span></p>
</dd>
<dt><a name="GLdt-pure-union-type" id=
"GLdt-pure-union-type"></a>pure union type</dt>
<dd>
<p>A <b>pure union type</b> is an XML Schema union type that
satisfies the following constraints: (1) <code>{variety}</code> is
<code>union</code>, (2) the <code>{facets}</code> property is
empty, (3) no type in the transitive membership of the union type
has <code>{variety}</code> <code>list</code>, and (4) no type in
the transitive membership of the union type is a type with
<code>{variety}</code> <code>union</code> having a non-empty
<code>{facets}</code> property</p>
</dd>
<dt><a name="GLdt-query" id="GLdt-query"></a>query</dt>
<dd>
<p>A <b>query</b> consists of one or more <a title="module" href=
"#dt-module">modules</a>.</p>
</dd>
<dt><a name="GLdt-queryBody" id="GLdt-queryBody"></a>query
body</dt>
<dd>
<p>The <b>Query Body</b>, if present, consists of an expression
that defines the result of the query.</p>
</dd>
<dt><a name="GLdt-resolve-relative-uri" id=
"GLdt-resolve-relative-uri"></a>resolve</dt>
<dd>
<p>To <b>resolve a relative URI</b> <code>$rel</code> against a
base URI <code>$base</code> is to expand it to an absolute URI, as
if by calling the function <code>fn:resolve-uri($rel,
$base)</code>.</p>
</dd>
<dt><a name="GLdt-reverse-document-order" id=
"GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>
<p>The node ordering that is the reverse of document order is
called <b>reverse document order</b>.</p>
</dd>
<dt><a name="GLdt-schema-aware-feature" id=
"GLdt-schema-aware-feature"></a>schema aware feature</dt>
<dd>
<p>The <b>Schema Aware Feature</b> permits the query Prolog to
contain a <a title="schema import" href="#dt-schema-import">schema
import</a>, and permits a query to contain a <code>validate</code>
expression (see <a href="#id-validate"><b>3.18 Validate
Expressions</b></a>).</p>
</dd>
<dt><a name="GLdt-schema-import" id="GLdt-schema-import"></a>schema
import</dt>
<dd>
<p>A <b>schema import</b> imports the element declarations,
attribute declarations, and type definitions from a schema into the
<a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a>. <span>For each <span>named</span>
user-defined <span>simple type</span> in the schema, schema import
also adds a corresponding <a title="constructor function" href=
"#dt-constructor-function">constructor function</a>.</span></p>
</dd>
<dt><a name="GLdt-schema-type" id="GLdt-schema-type"></a>schema
type</dt>
<dd>
<p>A <b>schema type</b> is a type that is (or could be) defined
using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a>
or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the
built-in types of <a href="#XMLSchema10">[XML Schema 1.0]</a> or
<a href="#XMLSchema11">[XML Schema 1.1]</a>).</p>
</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd>
<p>A <b>sequence</b> is an ordered collection of zero or more
<a title="item" href="#dt-item">items</a>.</p>
</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>sequence type</dt>
<dd>
<p>A <b>sequence type</b> is a type that can be expressed using the
<a href="#doc-xquery30-SequenceType">SequenceType</a> syntax.
Sequence types are used whenever it is necessary to refer to a type
in an XQuery 3.0 expression. The term <b>sequence type</b> suggests
that this syntax is used to describe the type of an XQuery 3.0
value, which is always a sequence.</p>
</dd>
<dt><a name="GLdt-serialization" id=
"GLdt-serialization"></a>serialization</dt>
<dd>
<p><b>Serialization</b> is the process of converting an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> to a
sequence of octets (step DM4 in Figure 1.)<span>, as described in
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization 3.0]</a>.</span></p>
</dd>
<dt><a name="GLdt-serialization-feature" id=
"GLdt-serialization-feature"></a>serialization feature</dt>
<dd>
<p><span>The</span> <b>Serialization Feature</b> provides means for
serializing the result of a query as specified in <a href=
"#id-serialization"><b>2.2.4 Serialization</b></a>.</p>
</dd>
<dt><a name="GLdt-setter" id="GLdt-setter"></a>setter</dt>
<dd>
<p><b>Setters</b> are declarations that set the value of some
property that affects query processing, such as construction mode,
ordering mode, or default collation.</p>
</dd>
<dt><a name="GLshould" id="GLshould"></a>should</dt>
<dd>
<p><b>SHOULD</b> means that there may exist valid reasons in
particular circumstances to ignore a particular item, but the full
implications must be understood and carefully weighed before
choosing a different course.</p>
</dd>
<dt><a name="GLdt-singleton" id="GLdt-singleton"></a>singleton</dt>
<dd>
<p>A sequence containing exactly one item is called a
<b>singleton</b>.</p>
</dd>
<dt><a name="GLdt-singleton-focus" id=
"GLdt-singleton-focus"></a>singleton focus</dt>
<dd>
<p>A <b>singleton focus</b> is a focus that refers to a single
item; in a singleton focus, context item is set to the item,
context position = 1 and context size = 1.</p>
</dd>
<dt><a name="GLstable" id="GLstable"></a>stable</dt>
<dd>
<p>Document order is <b>stable</b>, which means that the relative
order of two nodes will not change during the processing of a given
<span class="xquery">query</span>, even if this order is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</dd>
<dt><a name="GLdt-static-typing-feature" id=
"GLdt-static-typing-feature"></a>static typing feature</dt>
<dd>
<p>The <b>Static Typing Feature</b> requires implementations to
report all <a title="type error" href="#dt-type-error">type
errors</a> during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>.</p>
</dd>
<dt><a name="GLdt-static-analysis" id=
"GLdt-static-analysis"></a>static analysis phase</dt>
<dd>
<p>The <b>static analysis phase</b> depends on the expression
itself and on the <a title="static context" href=
"#dt-static-context">static context</a>. The <b>static analysis
phase</b> does not depend on input data (other than schemas).</p>
</dd>
<dt><a name="GLdt-static-context" id=
"GLdt-static-context"></a>static context</dt>
<dd>
<p>The <b>static context</b> of an expression is the information
that is available during static analysis of the expression, prior
to its evaluation.</p>
</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static
error</dt>
<dd>
<p>An error that <span>can</span> be detected during the static
analysis phase<span>, and is not a type error,</span> is a
<b>static error</b>.</p>
</dd>
<dt><a name="GLdt-static-function-call" id=
"GLdt-static-function-call"></a>static function call</dt>
<dd>
<p>A <b><span>static</span> function call</b> consists of an EQName
followed by a parenthesized list of zero or more arguments.</p>
</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static
type</dt>
<dd>
<p>The <b>static type</b> of an expression is the best inference
that the processor is able to make statically about the type of the
result of the expression.</p>
</dd>
<dt><a name="GLdt-static-decimal-formats" id=
"GLdt-static-decimal-formats"></a>statically known decimal
formats</dt>
<dd>
<p><b>Statically known decimal formats.</b> This is <span>a mapping
from QName to decimal format, with one default format that has no
visible name.</span> Each format is used for serializing decimal
numbers using <code>fn:format-number()</code>.</p>
</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically known collections</dt>
<dd>
<p><b>Statically known collections.</b> This is a mapping from
strings to types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:collection</code> function. The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</p>
</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically
known documents</dt>
<dd>
<p><b>Statically known documents.</b> This is a mapping from
strings to types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:doc</code> function. The type is the <a title=
"static type" href="#dt-static-type">static type</a> of a call to
<code>fn:doc</code> with the given URI as its literal argument.</p>
</dd>
<dt><a name="GLdt-static-collations" id=
"GLdt-static-collations"></a>statically known collations</dt>
<dd>
<p><b>Statically known collations.</b> This is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>
<span>mapping from URI to collation.</span> It defines the names of
the collations that are available for use in processing
<span class="xquery">queries and</span> expressions.</p>
</dd>
<dt><a name="GLdt-known-default-collection" id=
"GLdt-known-default-collection"></a>statically known default
collection type</dt>
<dd>
<p><b>Statically known default collection type.</b> This is the
type of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.</p>
</dd>
<dt><a name="GLdt-known-func-signatures" id=
"GLdt-known-func-signatures"></a>statically known function
signatures</dt>
<dd>
<p><b>Statically known function signatures.</b> This is a mapping
from (expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-signature">function
signature</a><sup><small>DM30</small></sup>.</p>
</dd>
<dt><a name="GLdt-static-namespaces" id=
"GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd>
<p><b>Statically known namespaces.</b> This is a <span>mapping from
prefix to namespace URI that defines</span> all the namespaces that
are known during static processing of a given expression.</p>
</dd>
<dt><a name="GLdt-step" id="GLdt-step"></a>step</dt>
<dd>
<p>A <b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=""
href="#dt-predicate">predicates</a>. The value of the step consists
of those items that satisfy the predicates, working from left to
right. A step may be either an <a title="axis step" href=
"#dt-axis-step">axis step</a> or a postfix expression.</p>
</dd>
<dt><a name="GLdt-string-value" id="GLdt-string-value"></a>string
value</dt>
<dd>
<p>The <b>string value</b> of a node is a string and can be
extracted by applying the <code>fn:string</code> function to the
node.</p>
</dd>
<dt><a name="GLdt-substitution-group" id=
"GLdt-substitution-group"></a>substitution group</dt>
<dd>
<p><b>Substitution groups</b> are defined in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> and <a href="#XMLSchema11">[XML
Schema 1.1]</a> Part 1. Informally, the substitution group headed
by a given element (called the <b>head element</b>) consists of the
set of elements that can be substituted for the head element
without affecting the outcome of schema validation.</p>
</dd>
<dt><a name="GLdt-subtype" id="GLdt-subtype"></a>subtype</dt>
<dd>
<p>A <a title="sequence type" href="#dt-sequence-type">sequence
type</a> <code>A</code> is a <b>subtype</b> of a sequence type
<code>B</code> if the judgement <code>subtype(A, B)</code> is
true.</p>
</dd>
<dt><a name="GLdt-subtype-substitution" id=
"GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd>
<p>The use of a value whose <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> is derived from an expected
type is known as <b>subtype substitution</b>.</p>
</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>
<p>Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
</dd>
<dt><a name="GLsymbolseparators" id="GLsymbolseparators"></a>symbol
separators</dt>
<dd>
<p><a title="whitespace" href="#Whitespace">Whitespace</a> and
<a href="#doc-xquery30-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgc: xml-version */</a>
annotation.</p>
</dd>
<dt><a name="GLdt-target-namespace" id=
"GLdt-target-namespace"></a>target namespace</dt>
<dd>
<p><span>The <b>target namespace</b> of a module is the namespace
of the objects (such as elements or functions) that it
defines.</span></p>
</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<p>A <b>terminal</b> is a symbol or string or pattern that can
appear in the right-hand side of a rule, but never appears on the
left-hand side in the main grammar, although it may appear on the
left-hand side of a rule in the grammar for terminals.</p>
</dd>
<dt><a name="GLid-tuple-foobar" id=
"GLid-tuple-foobar"></a>tuple</dt>
<dd>
<p>A <b>tuple</b> is a set of zero or more named variables, each of
which is bound to a value that is an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>.</p>
</dd>
<dt><a name="GLid-tuple-stream-foobar" id=
"GLid-tuple-stream-foobar"></a>tuple stream</dt>
<dd>
<p>A <b>tuple stream</b> is an ordered sequence of zero or more
<b>tuples</b>.</p>
</dd>
<dt><a name="GLdt-type-annotation" id=
"GLdt-type-annotation"></a>type annotation</dt>
<dd>
<p>Each element node and attribute node in an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> has
a <b>type annotation</b> ( <span>described</span> in <a href=
"#xpath-datamodel-30">[XQuery and XPath Data Model (XDM) 3.0]</a>.
) The type annotation of a node is a <span>reference to an XML
Schema type.</span></p>
</dd>
<dt><a name="GLdt-type-declaration" id=
"GLdt-type-declaration"></a>type declaration</dt>
<dd>
<p>A variable binding may be accompanied by a <b>type
declaration</b>, which consists of the keyword <code>as</code>
followed by the static type of the variable, declared using the
syntax in <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType
Syntax</b></a>.</p>
</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
error</dt>
<dd>
<p>A <b>type error</b> may be raised during the static analysis
phase or the dynamic evaluation phase. During the static analysis
phase, a <a title="type error" href="#dt-type-error">type error</a>
occurs when the <a title="static type" href=
"#dt-static-type">static type</a> of an expression does not match
the expected type of the context in which the expression occurs.
During the dynamic evaluation phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
does not match the expected type of the context in which the value
occurs.</p>
</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type
promotion</dt>
<dd>
<p>Under certain circumstances, an atomic value can be promoted
from one type to another. <b>Type promotion</b> is used in
evaluating function calls (see <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a> )<span class="xquery">, <code>order
by</code> clauses (see <a href="#id-order-by-clause"><b>3.10.8
Order By Clause</b></a>),</span> and operators that accept numeric
or string operands (see <a href="#mapping"><b>B.2 Operator
Mapping</b></a>).</p>
</dd>
<dt><a name="GLdt-typed-data-feature" id=
"GLdt-typed-data-feature"></a>typed data feature</dt>
<dd>
<p>The <b>Typed Data Feature</b> permits an XDM instance to contain
element node types other than <code>xs:untyped</code> and
attributes node types other than <code>xs:untypedAtomic</code>.</p>
</dd>
<dt><a name="GLdt-typed-value" id="GLdt-typed-value"></a>typed
value</dt>
<dd>
<p>The <b>typed value</b> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function
to the node.</p>
</dd>
<dt><a name="GLdt-udf" id="GLdt-udf"></a>user-defined function</dt>
<dd>
<p><b>User defined functions</b> are functions that contain a
<b>function body</b>, which provides the implementation of the
function as an XQuery expression.</p>
</dd>
<dt><a name="GLdt-value" id="GLdt-value"></a>value</dt>
<dd>
<p>In the <a title="data model" href="#dt-datamodel">data
model</a>, a <b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.</p>
</dd>
<dt><a name="GLdt-variable-reference" id=
"GLdt-variable-reference"></a>variable reference</dt>
<dd>
<p>A <b>variable reference</b> is an EQName preceded by a
$-sign.</p>
</dd>
<dt><a name="GLdt-variable-values" id=
"GLdt-variable-values"></a>variable values</dt>
<dd>
<p><b>Variable values</b>. This is a <span>mapping from <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> to
value.</span> It contains the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> as the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> for the expression. The
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> is the name of the variable and the value is the dynamic
value of the variable, which includes its <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>.</p>
</dd>
<dt><a name="GLdt-version-declaration" id=
"GLdt-version-declaration"></a>version declaration</dt>
<dd>
<p>A <b>version declaration</b> can identify the applicable XQuery
syntax and semantics for a <a title="module" href=
"#dt-module">module</a>, as well as its encoding.</p>
</dd>
<dt><a name="GLdt-warning" id="GLdt-warning"></a>warning</dt>
<dd>
<p>In addition to <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XQuery 3.0
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>whitespace</dt>
<dd>
<p>A <b>whitespace</b> character is any of the characters defined
by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p>
</dd>
<dt><a name="GLdt-window" id="GLdt-window"></a>window</dt>
<dd>
<p>A <b>window</b> is a sequence of consecutive items drawn from
the <a title="binding sequence" href="#dt-binding-sequence">binding
sequence</a>.</p>
</dd>
<dt><a name="GLdt-anyAtomicType" id=
"GLdt-anyAtomicType"></a>xs:anyAtomicType</dt>
<dd>
<p><code>xs:anyAtomicType</code> is an atomic type that includes
all atomic values (and no values that are not atomic). Its base
type is <code>xs:anySimpleType</code> from which all simple types,
including atomic, list, and union types, are derived. All primitive
atomic types, such as <code>xs:decimal</code> and
<code>xs:string</code>, have <code>xs:anyAtomicType</code> as their
base type.</p>
</dd>
<dt><a name="GLdt-dayTimeDuration" id=
"GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt>
<dd>
<p><code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.</p>
</dd>
<dt><a name="GLdt-xs-error" id="GLdt-xs-error"></a>xs:error</dt>
<dd>
<p><code>xs:error</code> is a simple type with no value space,
defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. In
implementations that support XML Schema 1.1, it can be used in the
<a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType
Syntax</b></a> to raise errors.</p>
</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xs:untyped</dt>
<dd>
<p><code>xs:untyped</code> is used as the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> of
an element node that has not been validated, or has been validated
in <code>skip</code> mode.</p>
</dd>
<dt><a name="GLdt-untypedAtomic" id=
"GLdt-untypedAtomic"></a>xs:untypedAtomic</dt>
<dd>
<p><code>xs:untypedAtomic</code> is an atomic type that is used to
denote untyped atomic data, such as text that has not been assigned
a more specific type.</p>
</dd>
<dt><a name="GLdt-yearMonthDuration" id=
"GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt>
<dd>
<p><code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.</p>
</dd>
<dt><a name="GLid-static-decimal-format-zero-digit" id=
"GLid-static-decimal-format-zero-digit"></a>zero-digit</dt>
<dd>
<p><b>zero-digit</b> specifies the character used for the
zero-digit-symbol; the default value is the digit zero (0). This
character must be a digit (category Nd in the Unicode property
database), and it must have the numeric value zero. This attribute
implicitly defines the Unicode character that is used to represent
each of the values 0 to 9 in the final result string: Unicode is
organized so that each set of decimal digits forms a contiguous
block of characters in numerical sequence.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-example-applications" id=
"id-example-applications"></a>I Example Applications
(Non-Normative)</h2>
<p>This section contains examples of several important classes of
queries that can be expressed using XQuery. The applications
described here include joins across multiple data sources, grouping
and aggregation, queries based on sequential relationships,
recursive transformations, and selection of distinct combinations
of values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This section needs to be rewritten in light of the new features
of XQuery 3.0, which can significantly simplify some of these
queries.</p>
</div>
<div class="div2">
<h3><a name="id-joins" id="id-joins"></a>I.1 Joins</h3>
<p>Joins, which combine data from multiple sources into a single
result, are a very important type of query. In this section we will
illustrate how several types of joins can be expressed in XQuery.
We will base our examples on the following three documents:</p>
<ol class="enumar">
<li>
<p>A document named <code>parts.xml</code> that contains many
<code>part</code> elements; each <code>part</code> element in turn
contains <code>partno</code> and <code>description</code>
subelements.</p>
</li>
<li>
<p>A document named <code>suppliers.xml</code> that contains many
<code>supplier</code> elements; each <code>supplier</code> element
in turn contains <code>suppno</code> and <code>suppname</code>
subelements.</p>
</li>
<li>
<p>A document named <code>catalog.xml</code> that contains
information about the relationships between suppliers and parts.
The catalog document contains many <code>item</code> elements, each
of which in turn contains <code>partno</code>, <code>suppno</code>,
and <code>price</code> subelements.</p>
</li>
</ol>
<p>A conventional ("inner") join returns information from two or
more related sources, as illustrated by the following example,
which combines information from three documents. The example
generates a "descriptive catalog" derived from the catalog
document, but containing part descriptions instead of part numbers
and supplier names instead of supplier numbers. The new catalog is
ordered alphabetically by part description and secondarily by
supplier name.</p>
<div class="exampleInner">
<pre>
&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;
</pre></div>
<p>The previous query returns information only about parts that
have suppliers and suppliers that have parts. An <b>outer join</b>
is a join that preserves information from one or more of the
participating sources, including elements that have no matching
element in the other source. For example, a <b>left outer join</b>
between suppliers and parts might return information about
suppliers that have no matching parts.</p>
<p>The following query demonstrates a left outer join. It returns
names of all the suppliers in alphabetic order, including those
that supply no parts. In the result, each supplier element contains
the descriptions of all the parts it supplies, in alphabetic
order.</p>
<div class="exampleInner">
<pre>
for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/partno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;
</pre></div>
<p>The previous query preserves information about suppliers that
supply no parts. Another type of join, called a <b>full outer
join</b>, might be used to preserve information about both
suppliers that supply no parts and parts that have no supplier. The
result of a full outer join can be structured in any of several
ways. The following query generates a list of <code>supplier</code>
elements, each containing nested <code>part</code> elements for the
parts that it supplies (if any), followed by a list of
<code>part</code> elements for the parts that have no supplier.
This might be thought of as a "supplier-centered" full outer join.
Other forms of outer join queries are also possible.</p>
<div class="exampleInner">
<pre>
&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;
</pre></div>
<p>The previous query uses an element constructor to enclose its
output inside a <code>master-list</code> element. The concatenation
operator (",") is used to combine the two main parts of the query.
The result is an ordered sequence of <code>supplier</code> elements
followed by an <code>orphan-parts</code> element that contains
descriptions of all the parts that have no supplier.</p>
</div>
<div class="div2">
<h3><a name="id-queries-on-sequence" id=
"id-queries-on-sequence"></a>I.2 Queries on Sequence</h3>
<p>XQuery uses the <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
operators to compare nodes based on document order. Although these
operators are quite simple, they can be used to express complex
queries for XML documents in which sequence is meaningful. The
first two queries in this section involve a surgical report that
contains <code>procedure</code>, <code>incision</code>,
<code>instrument</code>, <code>action</code>, and
<code>anesthesia</code> elements.</p>
<p>The following query returns all the <code>action</code> elements
that occur between the first and second <code>incision</code>
elements inside the first procedure. The original document order
among these nodes is preserved in the result of the query.</p>
<div class="exampleInner">
<pre>
let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i
</pre></div>
<p>It is worth noting here that document order is defined in such a
way that a node is considered to precede its descendants in
document order. In the surgical report, an <code>action</code> is
never part of an <code>incision</code>, but an
<code>instrument</code> is. Since the <code>&gt;&gt;</code>
operator is based on document order, the predicate <code>$i
&gt;&gt; ($proc//incision)[1]</code> is true for any
<code>instrument</code> element that is a descendant of the first
<code>incision</code> element in the first procedure.</p>
<p>For some queries, it may be helpful to declare a function that
can test whether a node precedes another node without being its
ancestor. The following function returns <code>true</code> if its
first operand precedes its second operand but is not an ancestor of
its second operand; otherwise it returns <code>false</code>:</p>
<div class="exampleInner">
<pre>
declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</pre></div>
<p>Similarly, a <code>local:follows</code> function could be
written:</p>
<div class="exampleInner">
<pre>
declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</pre></div>
<p>Using the <code>local:precedes</code> function, we can write a
query that finds <code>instrument</code> elements between the first
two incisions, excluding from the query result any
<code>instrument</code> that is a descendant of the first
<code>incision</code>:</p>
<div class="exampleInner">
<pre>
let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i
</pre></div>
<p>The following query reports incisions for which no prior
anesthesia was recorded in the surgical report. Since an
<code>anesthesia</code> is never part of an <code>incision</code>,
we can use <code>&lt;&lt;</code> instead of the less-efficient
<code>local:precedes</code> function:</p>
<div class="exampleInner">
<pre>
for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc
</pre></div>
<p>In some documents, particular sequences of elements may indicate
a logical hierarchy. This is most commonly true of HTML. The
following query returns the introduction of an XHTML document,
wrapping it in a <code>div</code> element. In this example, we
assume that an <code>h2</code> element containing the text
"Introduction" marks the beginning of the introduction, and the
introduction continues until the next <code>h2</code> or
<code>h1</code> element, or the end of the document, whichever
comes first.</p>
<div class="exampleInner">
<pre>
let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;
</pre></div>
<p>Note that the above query makes explicit the hierarchy that was
implicit in the original document. In this example, we assume that
the <code>h2</code> element containing the text "Introduction" has
no subelements.</p>
</div>
<div class="div2">
<h3><a name="id-recursive-transformations" id=
"id-recursive-transformations"></a>I.3 Recursive
Transformations</h3>
<p>Occasionally it is necessary to scan over a hierarchy of
elements, applying some transformation at each level of the
hierarchy. In XQuery this can be accomplished by defining a
recursive function. In this section we will present two examples of
such recursive functions.</p>
<p>Suppose that we need to compute a table of contents for a given
document by scanning over the document, retaining only elements
named <code>section</code> or <code>title</code>, and preserving
the hierarchical relationships among these elements. For each
<code>section</code>, we retain subelements named
<code>section</code> or <code>title</code>; but for each
<code>title</code>, we retain the full content of the element. This
might be accomplished by the following recursive function:</p>
<div class="exampleInner">
<pre>
declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };
</pre></div>
<p>The "skeleton" of a given document, containing only its sections
and titles, can then be obtained by invoking the
<code>local:sections-and-titles</code> function on the root node of
the document, as follows:</p>
<div class="exampleInner">
<pre>
local:sections-and-titles(fn:doc("cookbook.xml"))
</pre></div>
<p>As another example of a recursive transformation, suppose that
we wish to scan over a document, transforming every attribute named
<code>color</code> to an element named <code>color</code>, and
every element named <code>size</code> to an attribute named
<code>size</code>. This can be accomplished by the following
recursive function (note that the element constructor in case
<code>$e</code> generates attributes before child elements):</p>
<div class="exampleInner">
<pre>
declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in 
             ($e/@* except $e/@color,     (: attr -&gt; attr :)
              $e/size,                    (: elem -&gt; attr :)
              $e/@color,                  (: attr -&gt; elem :)
              $e/node() except $e/size )  (: elem -&gt; elem :)
           return local:swizzle($c) }
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };
</pre></div>
<p>The transformation can be applied to a whole document by
invoking the <code>local:swizzle</code> function on the root node
of the document, as follows:</p>
<div class="exampleInner">
<pre>
local:swizzle(fn:doc("plans.xml"))
</pre></div>
</div>
<div class="div2">
<h3><a name="id-select-distinct" id="id-select-distinct"></a>I.4
Selecting Distinct Combinations</h3>
<p>It is sometimes necessary to search through a set of data to
find all the distinct combinations of a given list of properties.
For example, an input data set might consist of a large set of
<code>order</code> elements, each of which has the same basic
structure, as illustrated by the following example:</p>
<div class="exampleInner">
<pre>
&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;
</pre></div>
<p>From this data set, a user might wish to find all the distinct
combinations of <code>product</code>, <code>size</code>, and
<code>color</code> that occur together in an <code>order</code>.
The following query returns this list, enclosing each distinct
combination in a new element named <code>option</code>:</p>
<div class="exampleInner">
<pre>
for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-revision-log" id="id-revision-log"></a>J Change Log
(Non-Normative)</h2>
<p class="xquery">This appendix lists the changes that have been
made to this specification since the <span>first</span> publication
of the XQuery 1.0 Recommendation.</p>
<div class="div2">
<h3><a name="id-incompatibilities" id=
"id-incompatibilities"></a>J.1 Incompatibilities</h3>
<p>The following names are now reserved, and cannot appear as
function names (see <a href="#id-reserved-fn-names"><b>A.3 Reserved
Function Names</b></a>):</p>
<ul>
<li>
<p><code>function</code></p>
</li>
<li>
<p><code>namespace-node</code></p>
</li>
<li>
<p><code>switch</code></p>
</li>
</ul>
<p>Code written for XQuery 1.0 processors may assume that every
item is either a node or an atomic value. This is no longer true,
since XQuery 3.0 introduces function items. Thus, an XQuery 1.0
function that declares a parameter as an <code>item()</code> can
now have a function item passed as a parameter, which might not
have been anticipated by the author of the function.</p>
</div>
<div class="div2">
<h3><a name="id-changes-this-draft" id=
"id-changes-this-draft"></a>J.2 Changes introduced during the
Proposed Recommendation period:</h3>
<div class="div3">
<h4><a name="id-changes-this-draft-substantive" id=
"id-changes-this-draft-substantive"></a>J.2.1 Substantive
Changes</h4>
<p>No substantive changes were made during the Proposed
Recommendation period.</p>
</div>
<div class="div3">
<h4><a name="id-changes-this-draft-editorial" id=
"id-changes-this-draft-editorial"></a>J.2.2 Editorial Changes</h4>
<ol class="enumar">
<li>
<p>Clarified wording of FLWOR expression in introductory text.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24221">Bug
24221</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="id-changes-PR" id="id-changes-PR"></a>J.3 Changes
introduced during the Candidate Recommendation period:</h3>
<div class="div3">
<h4><a name="id-changes-PR-substantive" id=
"id-changes-PR-substantive"></a>J.3.1 Substantive Changes</h4>
<p>The following substantive changes have been made.</p>
<ol class="enumar">
<li>
<p>Removed
<code>require-feature()</code>/<code>prohibit-feature()</code> due
to implementation experience.</p>
</li>
<li>
<p>Added the <a href="#id-typed-data-feature"><b>5.2.4 Typed Data
Feature</b></a>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20828">Bug
20828</a>.</p>
</li>
<li>
<p>Added entry to <a href="#id-incompatibilities"><b>J.1
Incompatibilities</b></a> to indicate that <code>function</code>,
<code>namespace-node</code>, and <code>switch</code> are all
reserved. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20902">Bug
20902</a>.</p>
</li>
<li>
<p>Added entry to <a href="#id-incompatibilities"><b>J.1
Incompatibilities</b></a> to indicate that function items violate
the XQuery 1.0/XPath 2.0 expectation that a every item is either a
node or an atomic value. See <a href=
"https://lists.w3.org/Archives/Member/w3c-xsl-query/2013Feb/0050.html">
https://lists.w3.org/Archives/Member/w3c-xsl-query/2013Feb/0050.htm
(member only)</a>.</p>
</li>
<li>
<p>Fixed text for castable. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21664">Bug
21664</a>.</p>
</li>
<li>
<p>Added error code [<a href="#ERRXPDY0130" title=
"err:XPDY0130">err:XPDY0130</a>] for implementation-defined limits.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21413">Bug
21413</a>.</p>
</li>
<li>
<p>Changed <code>fn:map</code> to <code>fn:for-each</code>, changed
<code>fn:map-pairs</code> to <code>fn:for-each-pair</code>. See
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21128">Bug
21128</a>.</p>
</li>
<li>
<p>Implementations must recognize options declared in the XQuery
specification. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20450">Bug
20540</a>.</p>
</li>
<li>
<p>Adopted new definition of derives-from(AT, ET). Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20643">Bug
20643</a>.</p>
</li>
<li>
<p>If the NodeTest in an axis step is a NamespaceNodeTest then a
static error is raised. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20736">Bug
20736</a>.</p>
</li>
<li>
<p>A try/catch expression catches dynamic errors and type errors
raised by the evaluation of the target expression of the try
clause. Previously, the text referred to expressions lexically
contained within the try clause. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=18877">Bug
18877</a>.</p>
</li>
<li>
<p>Added support for <code>xs:error</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20634">Bug
20634</a>.</p>
</li>
<li>
<p>If any component in the focus is defined, all components of the
focus are defined. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21011">Bug
21011</a>.</p>
</li>
<li>
<p>Defined <code>validate type xs:untyped</code> - all elements
receive the type annotation <code>xs:untyped</code>, and all
attributes receive the type annotation
<code>xs:untypedAtomic</code>. If the type name is
<code>xs:untypedAtomic</code>, the node receives the type
annotation <code>xs:untypedAtomic</code>; a type error is raised if
the node has children. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21011">Bug
21011</a>.</p>
</li>
<li>
<p>Changed XPTY0117 to FONS0004 in section 2.5.2, changed text of
[<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>].
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21893">Bug
21893</a>.</p>
</li>
<li>
<p>Explicitly stated that no catch clause "matches" the error
value, a the try/catch expression raises the error that was raised
by the target expression. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21666">Bug
21666</a>.</p>
</li>
<li>
<p>Changed "When tokenizing, the longest possible match that is
valid in the current context is used." to "When tokenizing, the
longest possible match consistent with the EBNF is used." Decided
in Teleconference #541 2013-05-21.</p>
</li>
<li>
<p>If the name of an element in a computed element constructor is
in no namespace, creating a default namespace for that element
using a computed namespace constructor is an error. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22032">Bug
22032</a>.</p>
</li>
<li>
<p>Added an exception for subtype(Ai*, Bi?) when Ai is a pure union
type with no member types, as in xs:error. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20862">Bug
20862</a>.</p>
</li>
<li>
<p>Modified definition of statically known decimal formats in
context. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19365">Bug
19365</a>, see comment #10.</p>
</li>
<li>
<p>A processor must not raise errors for serialization parameters
that it does not support. "A processor that is performing
serialization must raise a serialization error if the values of any
serialization parameters <span>that it supports</span> (other than
any that are ignored under the previous paragraph) are
incorrect."</p>
</li>
<li>
<p>Changed the second rule of <a href=
"#id-itemtype-subtype"><b>2.5.6.2 The judgement
subtype-itemtype(Ai, Bi)</b></a> and <a href=
"#id-itemtype-subtype"><b>2.5.6.2 The judgement
subtype-itemtype(Ai, Bi)</b></a> for the sake of transitivity.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20632">Bug
20632</a>.</p>
</li>
<li>
<p>Removed the paragraph that said no published version of XML
Schema references the XML 1.1 specifications, since this is no
longer true.</p>
</li>
<li>
<p>Modified <a href="#id-sequencetype-subtype"><b>2.5.6
SequenceType Subtype Relationships</b></a> to better account for
<code>xs:error</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=22552">Bug
22552</a>.</p>
</li>
<li>
<p>Improved Step 5.b.ii.A in <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a> .</p>
</li>
</ol>
<p class="xquery">The following items were changed in earlier
drafts, but were erroneously omitted in previous change logs.</p>
<ol class="enumar">
<li>
<p>Added support for unions of types in <a href=
"#id-typeswitch"><b>3.16.2 Typeswitch</b></a>.</p>
</li>
<li>
<p>A cycle in the definition of a module's dynamic context
components, for example because of a cycle in variable
declarations, is now a dynamic error [<a href="#ERRXQDY0054" title=
"err:XQDY0054">err:XQDY0054</a>], not a static error.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-changes-PR-editorial" id=
"id-changes-PR-editorial"></a>J.3.2 Editorial Changes</h4>
<p>The following are some of the editorial changes that have been
made.</p>
<ol class="enumar">
<li>
<p>Deleted unused error, checked for consistency of errors.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20837">Bug
20837</a>.</p>
</li>
<li>
<p>Added an example to show how to copy "unused" namespaces from
one node to another using <code>in-scope-prefixes($e) ! namespace
{namespace-uri-for-prefix($e,.)} {.}</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21025">Bug
21025</a>.</p>
</li>
<li>
<p>Restored normative status of FunctionTest semantics - see
<a href="#id-function-test"><b>2.5.5.7 Function Test</b></a>. They
had been accidentally demoted to NOTE status. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19341">Bug
19341</a>.</p>
</li>
<li>
<p>Added entry for <a href="#doc-xquery30-StringConcatExpr">||</a>
to <a href="#id-precedence-order"><b>A.4 Precedence Order
(Non-Normative)</b></a>.</p>
</li>
<li>
<p>Deleted note on the converse relationship from <a href=
"#id-sequencetype-subtype"><b>2.5.6 SequenceType Subtype
Relationships</b></a>.</p>
</li>
<li>
<p>Removed statement that implied the XQuery 3.0 requirements
include a requirement for an XML-based representation.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-changes-this-draft-not-implemented" id=
"id-changes-this-draft-not-implemented"></a>J.3.3 Resolutions that
are no longer relevant.</h4>
<p>The following are changes that have been decided, but are no
longer relevant because of our decision to remove
<code>require-feature</code>/<code>prohibit-feature</code>.</p>
<ol class="enumar">
<li>
<p>Resolution of the following bugs, all related to
require/prohibit feature, has not yet been implemented in this
document: <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21130#c2">Bug
21130</a>, <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19597">Bug
19597</a>, <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=21717">Bug
21717</a>.</p>
</li>
<li>
<p>Reworked <code>require-feature</code> and
<code>prohibit-feature</code> to work cleanly per module. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19602">Bug
19602</a>.</p>
</li>
<li>
<p>Clarified meaning of vendor extensions, added definition of
named feature, simplified
<code>require-feature</code>/<code>prohibit-feature</code> using
that definition. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19670">Bug
19670</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="id-changes-CR" id="id-changes-CR"></a>J.4 Changes
introduced in the Candidate Recommendation</h3>
<div class="div3">
<h4><a name="id-changes-CR-substantive" id=
"id-changes-CR-substantive"></a>J.4.1 Substantive Changes</h4>
<p>The following substantive changes have been made.</p>
<ol class="enumar">
<li>
<p>Pure union types (formerly known as restricted union types) are
now permitted in AtomicOrUnionTypes. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=13399">Bug
13399</a>.</p>
</li>
<li>
<p>Adopted the XML restriction that control characters #x1 to #x1F
and 0x7F to 0x9F cannot appear in unescaped form in an XQuery.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14921">Bug
14921</a>.</p>
</li>
<li>
<p>Added available text resources to the static context, as part of
the resolution of <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14932">Bug
14932</a>.</p>
</li>
<li>
<p>Changed error XQST0046 for URI literals so that it is no longer
dependent on the lexical space of xs:anyURI - the error is now
raised if the value of a URILiteral or a BracedURILiteral is of
nonzero length and is neither an absolute URI nor a relative URI.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15675">Bug
15675</a>.</p>
</li>
<li>
<p>All function annotations are carried through function coercion.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15690">Bug
15690</a>.</p>
</li>
<li>
<p>Clarified and extended rules for casting. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15807">Bug
15807</a>.</p>
</li>
<li>
<p>Modified the scope of grouping variables. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15728">Bug
15728</a>.</p>
</li>
<li>
<p>Abandoned the special casting rule that prevented atomization
for namespace sensitive types. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16089">Bug
16089</a>.</p>
</li>
<li>
<p>The split of base URI into static base URI and dynamic base URI
has been reverted<span class="xquery">; instead there is simply a
note giving implementations freedom to handle base URI as needed in
the case where compiled queries are deployed remotely from the
source code</span>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=17595">Bug
17595</a>.</p>
</li>
<li>
<p>A grouping variable is bound to an atomized value. See decision
in <a href=
"https://lists.w3.org/Archives/Member/w3c-xsl-query/2012Jan/0125.html">
Teleconference #497 Minutes (member only)</a>.</p>
</li>
<li>
<p>Changed the syntax of EQName to avoid conflicts with potential
JSON syntax extensions in future versions. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15399">Bug
15399</a>.</p>
</li>
<li>
<p>Relaxed rules that required inputs, outputs, and query modules
to all use the same versions of XML, XML Names, and XML Schemas for
names, characters, attribute value normalization, line-breaks, etc.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15966">Bug
15966</a>.</p>
</li>
<li>
<p>Function items are now supported for context-dependent functions
if they depend only on the static context. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15912">Bug
15912</a>.</p>
</li>
<li>
<p>Removed error XPDY0229. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16681">Bug
16681</a>.</p>
</li>
<li>
<p>The default namespace for both options and annotations is now
<code>http://www.w3.org/2012/xquery</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16199">Bug
16199</a>.</p>
</li>
<li>
<p>Changed precedence of simple map operator, reorganized text
accordingly. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16197">Bug
16197</a>.</p>
</li>
<li>
<p>Integrated proposals on static and dynamic context from <a href=
"http://lists.w3.org/Archives/Member/w3c-xsl-query/2012May/0118.html">
http://lists.w3.org/Archives/Member/w3c-xsl-query/2012May/0118.html</a>.
Resolves Bugs <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14656">14656</a>,
<a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14375">14375</a>,
and <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15791">15791</a>.</p>
</li>
<li>
<p>Clarified errors for variable declarations and function
declarations that have both <code>%private</code> and
<code>%public</code> annotations. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16104">Bug
16104</a> and <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19077">Bug
19077</a>.</p>
</li>
<li>
<p>Renamed annotation assertions to function assertions, clarified
that an unrecognized assertion has no effect on processing and that
an assertion always restricts the set of matched functions (and
never extends them). Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=17474">Bug
17474</a>.</p>
</li>
<li>
<p>If there is a Comment before the end of a Version Declaration,
an implementation must either raise an implementation-defined
static error or ignore the commment. Decided in Montreal
Face-to-Face, see <a href=
"http://lists.w3.org/Archives/Member/w3c-xsl-query/2012Jul/0081.html">
https://lists.w3.org/Archives/Member/w3c-xsl-query/2012Jul/0081.html</a>.</p>
</li>
<li>
<p>The namespace URI specified in a default namespace declaration
must not be <code>http://www.w3.org/XML/1998/namespace</code> or
<code>http://www.w3.org/2000/xmlns/</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14930">Bug
14930</a>.</p>
</li>
<li>
<p>Combined the Schema Validation Feature and the Schema Import
Feature into one feature, the Schema Aware Feature (see <a href=
"#id-schema-aware-feature"><b>5.2.3 Schema Aware Feature</b></a>).
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=11585">Bug
11585</a>.</p>
</li>
<li>
<p>The serialization feature (see <a href=
"#id-serialization-feature"><b>5.2.7 Serialization Feature</b></a>)
always requires use of the serialization specification. Decided in
teleconference #519, 2012-09-18.</p>
</li>
<li>
<p>Using <code>%public</code> and <code>%private</code> annotations
in a main module is not an error, but it does not affect module
imports, since a main module cannot be imported. Decided in
teleconference #519, 2012-09-18.</p>
</li>
<li>
<p>Higher order functions are now an optional feature. Decided in
teleconference #519, 2012-09-18.</p>
</li>
<li>
<p>If the type name is <code>xs:untyped</code>, no are created as a
result of validation; the result of <code>validate type xs:untyped
{ $x }</code> is the value of <code>$x</code> with all type
annotatins removed. Decided in face-to-face #517, 2012-07-23 to
2012-07-25.</p>
</li>
<li>
<p>Changed rules for whitespace in URI Literals and Braced URI
Literals in <a href="#id-uri-literals"><b>2.4.5 URI
Literals</b></a>. Decided in face-to-face #517, 2012-07-23 to
2012-07-25.</p>
</li>
<li>
<p>Serialization parameter names are defined by the element names
in the schema in the serialization spec. Error XQST0109 is also
raised if the name of an output declaration is
<code>use-character-maps</code>. If a serialization option is not
implemented, an implementation must ignore it, without raising an
error. Decided in Teleconference #520 2012-09-25.</p>
</li>
<li>
<p>An implementation may raise a dynamic error [<a href=
"#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>] if the
<code>URIExpr</code> of a computed namespace constructor is not a
valid instance of <code>xs:anyURI</code>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15675">Bug
15675</a>.</p>
</li>
<li>
<p>Updated the appendix of implementation-defined items.</p>
</li>
<li>
<p>In <code>E castable as T</code>, if <code>E</code> raises a
dyanmic error, <code>castable</code> returns <code>false</code>, it
does not "fail". See <a href="#id-castable"><b>3.16.4
Castable</b></a>.</p>
</li>
<li>
<p>Adopted rewording of <a href=
"#id-schema-element-test"><b>2.5.5.4 Schema Element Test</b></a>.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10207">Bug
10207</a>.</p>
</li>
<li>
<p>Corrected rule #17 of <a href="#id-itemtype-subtype"><b>2.5.6.2
The judgement subtype-itemtype(Ai, Bi)</b></a> . Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19425">Bug
19425</a>.</p>
</li>
<li>
<p>Added error [<a href="#ERRXPST0133" title=
"err:XPST0133">err:XPST0133</a>], which is raised if the namespace
URI for an EQName is <code>http://www.w3.org/2000/xmlns/</code>, in
the early section on names. Removed duplicate material in the
section on node tests. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19658">Bug
19658</a>.</p>
</li>
<li>
<p>Allow an XQuery implementation to process an XQuery 1.0 query
according to either the XQuery 1.0 specification or the XQuery 3.0
specification. See <a href="#id-version-declaration"><b>4.1 Version
Declaration</b></a>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19671">Bug
19671</a>.</p>
</li>
<li>
<p>All modules share the same <a title="initial context item" href=
"#dt-initial-context-item">initial context item</a>, used in the
query body and in prologs of all modules. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19267">Bug
19267</a>.</p>
</li>
<li>
<p>Added row for statically known decimal formats to <a href=
"#id-xq-evaluation-context-components"><b>C.2 Dynamic Context
Components</b></a>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19365">Bug
19365</a>.</p>
</li>
<li>
<p>In <a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>, nonlocal variables for the declared function
are empty. Fixes an omission in implementing the resolution of
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15791">Bug
15791</a>.</p>
</li>
<li>
<p>In <a href="#FunctionDeclns"><b>4.18 Function
Declaration</b></a>, state explicitly that the processed function
is added to the named functions component of the dynamic
context.</p>
</li>
<li>
<p>Updated <a href="#id-incompatibilities"><b>J.1
Incompatibilities</b></a> to state that three function names are
now reserved (<code>function</code>, <code>namespace-node</code>,
and <code>switch</code>). Fulfils Action A-523-06.</p>
</li>
<li>
<p>Ai is a subtype of Bi if Ai and Bi are both pure union types,
and every type t in the transitive membership of Ai is also in the
transitive membership of Bi. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19504">Bug
19504</a>.</p>
</li>
<li>
<p>Added <code>html-version</code> and <code>item-separator</code>
to Appendix C.1. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20267">Bug
20267</a>.</p>
</li>
<li>
<p>Implementations must raise an error if limits are exceeded.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20310">Bug
20310</a>.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-changes-CR-editorial" id=
"id-changes-CR-editorial"></a>J.4.2 Editorial Changes</h4>
<p>The following are some of the editorial changes that have been
made.</p>
<ol class="enumar">
<li>
<p>Introduced the concept of singleton focus, borrowed from XSLT,
and used it to clarify context declaration. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=15789">Bug
15789</a>.</p>
</li>
<li>
<p>Reworked much of the prose re functions, to increase clarity and
better accommodate dynamic function calls and partial function
applications.</p>
</li>
<li>
<p>Renamed "Module URI" to "the target namespace of a module".
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14368">Bug
14368</a>.</p>
</li>
<li>
<p>Eliminated the undefined term "global variable". Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=14369">Bug
14369</a>.</p>
</li>
<li>
<p>Simplified Conformance language. Consistently use "provides a
feature" instead of using both "provides" and "supports". Reduce
redundant use of the term "conforms to".</p>
</li>
<li>
<p>Consistently use "absent" for properties with no value in both
static and dynamic context.</p>
</li>
<li>
<p>More consistent use of terminology for raising an error,
eliminating other terms (signal, report, raise, throw) that have
been used in various versions of this specification over the
years.</p>
</li>
<li>
<p>Improved the definition of <a title="static error" href=
"#dt-static-error">static error</a>.</p>
</li>
<li>
<p>Editorial rewrite of the description of document order.</p>
</li>
<li>
<p>Corrected several places where EQNames, QNames, and expanded
QNames were conflated.</p>
</li>
<li>
<p>Simplified <a href="#id-variables"><b>3.1.2 Variable
References</b></a> so that it no longer enumerates expressions that
bind variables, and merely refers to the static context. This
simplifies maintenance of the specification.</p>
</li>
<li>
<p>Improved the definition of <a title="node test" href=
"#dt-node-test">node test</a>.</p>
</li>
<li>
<p>Removed definition for "depends on a function", which is no
longer used.</p>
</li>
<li>
<p>Removed a dangling note describing an obsolete error for
context-sensitive functions in <a href=
"#id-named-function-ref"><b>3.1.6 Named Function References</b></a>
.</p>
</li>
<li>
<p>Fixed headings in Appendix C that implied that it describes
static and dynamic contexts only for modules. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20350">Bug
20350</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="id-changes-prior-drafts" id=
"id-changes-prior-drafts"></a>J.5 Changes introduced in prior
Working Drafts</h3>
<div class="div3">
<h4><a name="id-changes-prior-drafts-substantive" id=
"id-changes-prior-drafts-substantive"></a>J.5.1 Substantive
Changes</h4>
<p>The following substantive changes have been made in prior
Working Drafts.</p>
<ol class="enumar">
<li>
<p>Applied all <a href=
"http://www.w3.org/XML/2007/qt-errata/xquery-errata.html">XQuery
2ed errata</a>.</p>
</li>
<li>
<p>Added <code>group by</code> clause to FLWOR Expressions
(<a href="#id-group-by"><b>3.10.7 Group By Clause</b></a>).</p>
</li>
<li>
<p>Added <code>tumbling window</code> and <code>sliding
window</code> in FLWOR Expressions (<a href="#id-windows"><b>3.10.4
Window Clause</b></a>).</p>
</li>
<li>
<p>Added <code>count</code> clause in FLWOR Expressions (<a href=
"#id-count"><b>3.10.6 Count Clause</b></a>).</p>
</li>
<li>
<p>Added <code>allowing empty</code> in <a href=
"#id-xquery-for-clause"><b>3.10.2 For Clause</b></a>, for
functionality similar to outer joins in SQL.</p>
</li>
<li>
<p>Added <a href="#id-try-catch"><b>3.15 Try/Catch
Expressions</b></a> for handling dynamic errors and type
errors.</p>
</li>
<li>
<p>Added <span>named function references</span> (<a href=
"#id-named-function-ref"><b>3.1.6 Named Function References</b></a>
).</p>
</li>
<li>
<p>Added inline function <span>expression</span>s (<a href=
"#id-inline-func"><b>3.1.7 Inline Function
Expressions</b></a>).</p>
</li>
<li>
<p>Added dynamic function <span>call</span> (<a href=
"#id-dynamic-function-invocation"><b>3.2.2 Dynamic Function
Call</b></a> ).</p>
</li>
<li>
<p>Added <a href="#id-function-coercion"><b>3.1.5.3 Function
Coercion</b></a>.</p>
</li>
<li>
<p>Added <a href="#id-sequencetype-subtype"><b>2.5.6 SequenceType
Subtype Relationships</b></a>, moving sequence type subtype
judgments into the language specification rather than the formal
semantics.</p>
</li>
<li>
<p>Added private functions (<a href="#FunctionDeclns"><b>4.18
Function Declaration</b></a>).</p>
</li>
<li>
<p>Added switch expressions (<a href="#id-switch"><b>3.13 Switch
Expression</b></a>)</p>
</li>
<li>
<p>Added computed namespace constructors (<a href=
"#id-computed-namespaces"><b>3.9.3.7 Computed Namespace
Constructors</b></a>).</p>
</li>
<li>
<p>Added output declarations (<a href="#id-serialization"><b>2.2.4
Serialization</b></a>).</p>
</li>
<li>
<p>Added annotations (<a href="#id-annotations"><b>4.15
Annotations</b></a>).</p>
</li>
<li>
<p>Simplified BNF for FLWOR expressions, changed description of
semantics so that each clause is understood as accepting a tuple
stream as input, acting on that tuple stream, and producing a tuple
stream as output.</p>
</li>
<li>
<p>Modified <a href="#doc-xquery30-ValidateExpr">validate
expressions</a> to allow validation against a type that is
explicitly specified in the query using the <code>type</code>
keyword.</p>
</li>
<li>
<p>Extended <a href="#doc-xquery30-VarDecl">variable
declarations</a> to allow default values for external
variables.</p>
</li>
<li>
<p>Added <a href="#id-context-item-declarations"><b>4.17 Context
Item Declaration</b></a>.</p>
</li>
<li>
<p>Modified <a href="#id-version-declaration"><b>4.1 Version
Declaration</b></a> to add support for XQuery 3.0.</p>
</li>
<li>
<p>Added <a href="#id-decimal-format-decl"><b>4.10 Decimal Format
Declaration</b></a> to allow a query to specify formats for
<code>fn:format-number()</code>. Added corresponding properties to
the static context.</p>
</li>
<li>
<p>Relaxed constraints on module imports in <a href=
"#id-module-import"><b>4.12 Module Import</b></a> to allow modules
to reference each other without restriction and to remove
restrictions on forward references to global variables.</p>
</li>
<li>
<p>Modified <a href="#id-variable-declarations"><b>4.16 Variable
Declaration</b></a> to clarify type information and remove
ambiguities with respect to types.</p>
</li>
<li>
<p>Removed obsolete Latin-1, using ISO-8859-1 instead. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=7797">Bug
7797</a>.</p>
</li>
<li>
<p>Changed conformance section to make full-axis support mandatory.
Added note saying the Working Group has not yet decided which
XQuery 3.0 features are optional.</p>
</li>
<li>
<p>Added normative rules for resolving module URIs to <a href=
"#id-module-import"><b>4.12 Module Import</b></a>.</p>
</li>
<li>
<p>Clarified type information available to
<code>derives-from()</code> in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6513#c21">Bug 6513,
Comment #21</a>.</p>
</li>
<li>
<p>Modified <code>derives-from()</code> in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType Matching</b></a>
to support union types. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7749#c2">Bug
7749</a>.</p>
</li>
<li>
<p>Added <a title="function assertion" href=
"#dt-function-assertion">function assertions</a> to <a href=
"#doc-xquery30-FunctionTest">function tests</a>.</p>
</li>
<li>
<p>Removed section on static typing extensions.</p>
</li>
<li>
<p>Added support for literal URLs in names, using <a href=
"#doc-xquery30-EQName">EQNames</a>.</p>
</li>
<li>
<p>Added support for XML Schema 1.1.</p>
</li>
<li>
<p>Added support for union types in function arguments.</p>
</li>
<li>
<p>Allowed serialization options to be specified as an XDM instance
using output declarations. See <a href="#id-serialization"><b>2.2.4
Serialization</b></a>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=9302">Bug 9302</a>.
Moved serialization options to the static context, with module
scope.</p>
</li>
<li>
<p>Allowed implementations to ignore errors in non-matching case
operands. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=9252">Bug
9252</a>.</p>
</li>
<li>
<p>Required validation to check the values of nodes of type
xs:NOTATION. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=9816">Bug
9816</a>.</p>
</li>
<li>
<p>Clarified wording on conflicts between function signatures and
constructor functions in <a title=
"statically known function signatures" href=
"#dt-known-func-signatures"><span>statically known</span> function
signatures</a>.</p>
</li>
<li>
<p>Fixed an editorial error in which the wrong error was reported
for duplicate decimal formats. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10271">Bug
10271</a>.</p>
</li>
<li>
<p>Added error for duplicate property declarations within a single
decimal format declaration. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10272">Bug
10272</a>.</p>
</li>
<li>
<p>Specified consistency constraints for types and values of
default values for external variables. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10407">Bug
10407</a>.</p>
</li>
<li>
<p>Added missing consistency constraints for statically known
namespaces to <a href="#id-consistency-constraints"><b>2.2.5
Consistency Constraints</b></a> (the prefix <code>xmlns</code> is
not bound to any namespace URI, no prefix is bound to the namespace
URI <code>http://www.w3.org/2000/xmlns/</code>). Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10700">Bug
10700</a>.</p>
</li>
<li>
<p>The prefixes <code>math</code>, <code>err</code>, and
<code>out</code> are no longer predeclared. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10681">Bug
10681</a>.</p>
</li>
<li>
<p>Forbid the namespace URI "http://www.w3.org/2000/xmlns/" in
constructed namespace nodes. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10728">Bug
10728</a>.</p>
</li>
<li>
<p>Corrected definition of group by: 1. We now that no two items
with different grouping keys are deep equal to each other, 2. We
now handle a non-transitivity edge case. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10733">Bug
10733</a>.</p>
</li>
<li>
<p>Corrected a bug in XQuery Second Edition involving consecutive '
or " characters in attribute content. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10989">Bug
10989</a>.</p>
</li>
<li>
<p>Adopted rules for abstract elements in substitution groups:
abstract elements do not appear in substitution groups, block
attributes must be taken into account when building the
substitution groups. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10207">Bug
10207</a>.</p>
</li>
<li>
<p>Changed the rules for static detection of dynamic and type
errors in <a href="#id-kinds-of-errors"><b>2.3.1 Kinds of
Errors</b></a>: Independently of whether the Static Typing Feature
is in effect, if an implementation can determine during the static
analysis phase that a QueryBody , if evaluated, would necessarily
raise a dynamic error or that an expression, if evaluated, would
necessarily raise a type error, the implementation may (but is not
required to) report that error during the static analysis
phase.</p>
</li>
<li>
<p>Clarified that implementation-defined annotations must not be in
any of the following namespaces:
<code>http://www.w3.org/XML/1998/namespace</code>,
<code>http://www.w3.org/2001/XMLSchema</code>,
<code>http://www.w3.org/2001/XMLSchema-instance</code>.</p>
</li>
<li>
<p>Prohibited implementations from defining annotations or
annotations assertions in reserved namespaces, changing to
<a title="must not" href="#mustnot">MUST NOT</a>. Added
<code>http://www.w3.org/2005/xpath-functions</code> and
<code>http://www.w3.org/2005/xpath-functions/math</code> to the
list of prohibited namespaces. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10865">Bug
10865</a>.</p>
</li>
<li>
<p>Prohibited the <code>xmlns</code> namespace in EQNames. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10869">Bug
10869</a>.</p>
</li>
<li>
<p>Prohibited user defined functions from being declared in the
math namespace. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10883">Bug
10883</a>.</p>
</li>
<li>
<p>Defined the behavior of "depends on" in the presence of function
items. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10885">Bug
10885</a>.</p>
</li>
<li>
<p>Removed default values from annotations. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11014">Bug
11014</a>.</p>
</li>
<li>
<p>Added missing semantics for EQNames with URILiterals. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10857">Bug
10857</a>.</p>
</li>
<li>
<p>Added support for private variables. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10875">Bug
10875</a>.</p>
</li>
<li>
<p>Added support for casting to union types. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7860">Bug
7860</a>.</p>
</li>
<li>
<p>Eliminated err:XQST0036 - implementations must be able to
determine whether a type in the schemas of one module is derived
from a type in the schemas of another module. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12173">Bug
12173</a>.</p>
</li>
<li>
<p>Prohibited reserved namespaces in annotations (in addition to
annotation assertions). Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11538">Bug
11538</a>.</p>
</li>
<li>
<p>Required implementations to resolve cycles in module imports,
ensuring that a given module is imported only once. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10863">Bug
10863</a>.</p>
</li>
<li>
<p>In try/catch expressions, only the first catch clause the
matches an error needs to be evaluated. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11171">Bug
11171</a>. (This change appeared in an earlier draft, but was not
mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Allowed a <code>URILiteral</code> in <code>Wildcard</code>.
(This change appeared in an earlier draft, but was not mentioned in
the corresponding change log.)</p>
</li>
<li>
<p>How XDM instances are created from sources other than an Infoset
or PSVI is implementation-defined. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12208">Bug
12208</a>. (This change appeared in an earlier draft, but was not
mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Clarified use of Static Base URI, Dynamic Base URI per <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11561#c6">Bug
11561#c6</a>. (This change appeared in an earlier draft, but was
not mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Added err:XQST0118 for start tag / end tag name mismatches.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11609">Bug
11609</a>. (This change appeared in an earlier draft, but was not
mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Adds errors for casts to namepace sensitive types in cast and
function conversion rules. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11964">Bug
11964</a>. (This change appeared in an earlier draft, but was not
mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Specified use of "unknown" types, including types from documents
and types from other modules. Eliminated err:XQST0036. Resolves
<a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11095#c6">Bug
11095</a>. (This change appeared in an earlier draft, but was not
mentioned in the corresponding change log.)</p>
</li>
<li>
<p>Introduced <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">Generalized atomic types</a>,
restricted unions in SequenceType to these types.</p>
</li>
<li>
<p>Added string concatenation operator <code>"con" || "cat" ||
"enate"</code></p>
</li>
<li>
<p>Clarified that conformance to the data model or functions and
operators requires a definition of every item specified to be
implementation-defined, unless that item is part of an optional
feature that is not supported by the implementation.</p>
</li>
<li>
<p>Added <code>prohibit-feature</code> and
<code>require-feature</code> declaration options.</p>
</li>
<li>
<p>Implemented simple mapping operator proposal using "!" operator.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12951">Bug
12951</a>.</p>
</li>
<li>
<p>Inline function <span>expression</span>s can also have
annotations. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12909">Bug
12909</a>.</p>
</li>
<li>
<p>Changed the ordering of rules in namespace constructors.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12649">Bug
12649</a>.</p>
</li>
<li>
<p>Changed rules for matching substitution groups. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10065">Bug
10065</a>.</p>
</li>
<li>
<p>Eliminated redundant errors for duplicate variables in window
clauses. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=13680">Bug
13680</a>.</p>
</li>
<li>
<p>Changed XQTY0102 to a dynamic error. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=13289">Bug
13289</a>.</p>
</li>
<li>
<p>A namespace constructor must have a namespace URI of length &gt;
0. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12738">Bug
12738</a>.</p>
</li>
<li>
<p>Functions <span class="xquery">and annotations</span> cannot be
in the "http://www.w3.org/2012/xquery" namespace.</p>
</li>
<li>
<p>For a partial function application, a failure in the function
conversion rules MUST raise a type error.</p>
</li>
<li>
<p>Function item coercion is required to raise a type error if
there's a mismatch in the number of parameters (expected vs
actual). Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14350">Bug
14350</a>.</p>
</li>
<li>
<p>In the triggers for err:XPST0112, broaden the class of functions
that can't be referenced by partial function applications and named
function references, from "focus-dependent" to "context-dependent
built-in".</p>
</li>
<li>
<p>Added default language, calendar, and place to the dynamic
context. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14995">Bug
14995</a>.</p>
</li>
<li>
<p>Changed namespace handling in option declarations to provide a
default namespace.</p>
</li>
<li>
<p>Expanded definition of XPST0080 so that casting to
xs:anySimpleType is also an error. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=19090">Bug
19090</a>.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-changes-prior-drafts-editorial" id=
"id-changes-prior-drafts-editorial"></a>J.5.2 Editorial
Changes</h4>
<p>The following are some of the editorial changes that have been
made.</p>
<ol class="enumar">
<li>
<p>Add Note to group-by section on unexpected replication of
LET-bindings after grouping. Advises users to use a separate FLWOR
to bind the expression, and a nested FLWOR for grouping, like this:
let $x := 47 return for $e in //emps group by $d := $e/dept return
f($d, $x)</p>
</li>
<li>
<p>Changed introductory text on the relationship between XQuery and
XPath to list the cases where a syntactically valid query can
return different results in the two languages - see
https://www.w3.org/Bugs/Public/show_bug.cgi?id=7163.</p>
</li>
<li>
<p>Introduced definitions of scope, global scope, module scope,
lexical scope, and dynamic scope to <a href=
"#id-xq-context-components"><b>C Context Components</b></a>.</p>
</li>
<li>
<p>Fixed names of <code>op:hexBinary-equal</code> and
<code>op:base64Binary-equal</code> in <a href="#mapping"><b>B.2
Operator Mapping</b></a>. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7048">Bug
7048</a>.</p>
</li>
<li>
<p>Clarified overwriteability of the context item static type,
resolving <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=8875#c1">Bug
8875</a>.</p>
</li>
<li>
<p>Added a definion for <a title="resolve" href=
"#dt-resolve-relative-uri">resolving a relative URI.</a> Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10571">Bug
10571</a>.</p>
</li>
<li>
<p>Provided a definition for matching a
<code>ParenthesizedItemType</code>: A <a href=
"#doc-xquery30-ParenthesizedItemType">ParenthesizedItemType</a>
matches an item if and only if the item matches the <a href=
"#doc-xquery30-ItemType">ItemType</a> that is in parentheses.</p>
</li>
<li>
<p>Clarified that defaults are used for missing properties of
decimal formats. If a given property is not declared, the default
values specified in statically known decimal formats are used.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10858">Bug
10858</a>.</p>
</li>
<li>
<p>Clarified semantics of decimal formats in which all properties
are defaulted. If a format declares no properties, default values
are used for all properties. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10273">Bug
10273</a>.</p>
</li>
<li>
<p>Eliminated the vestigial term <b>user declared function</b>,
which was not defined, and used the word <b>user-defined
function</b> throughout. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10466">Bug
10466</a>.</p>
</li>
<li>
<p>Added <code>fn:unparsed-text</code>,
<code>fn:uri-collection</code> and
<code>fn:get-environment-variable</code> to the list of input
sources. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10503">Bug
10503</a>.</p>
</li>
<li>
<p>Changed terminology for properties with no value, particularly
in the case of namespace URIs, using the Data Model's new term
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-absent">absent</a><sup><small>DM30</small></sup>.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10683">Bug
10683</a>.</p>
</li>
<li>
<p>Clarified that in-scope variables are augmented by inline
function <span>expression</span>s. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10686">Bug
10686</a>.</p>
</li>
<li>
<p>Corrected several editorial errors involving static context for
statically known namespaces. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10689">Bug
10689</a>.</p>
</li>
<li>
<p>Pulled FunctionTest out into it's own SequenceType matching
sub-section. Clarified which default namespace to use throughout.
Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10705">Bug
10705</a>.</p>
</li>
<li>
<p>Replaced the term "evaluation order" for describing parentheses.
New description: "Parentheses may be used to override the
precedence rules". Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10716">Bug
10716</a>.</p>
</li>
<li>
<p>Added functions to the definitions of item, XDM. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10679">Bug
10679</a>.</p>
</li>
<li>
<p>Eliminated erroneous reference to [err:XPST0081]. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10680">Bug
10680</a>.</p>
</li>
<li>
<p>Added a note to the introduction, specifying that in most
contexts, processors are not required to raise errors if a URI is
not lexically valid according to [RFC3986] and [RFC3987]. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10682">Bug
10682</a>.</p>
</li>
<li>
<p>Made editorial corrections governing the prefix expression for
computed namespace nodes. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10727">Bug
10727</a>.</p>
</li>
<li>
<p>Removed the word "legal", which is no longer used in this
specification, replacing with more precise terminology.</p>
</li>
<li>
<p>Modified definition of public/private functions to make the
presence or absence of a %private annotation part of the
definition. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10874">Bug
10874</a>.</p>
</li>
<li>
<p>Fixed an incorrect <code>group by</code> example. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10980">Bug
10980</a>.</p>
</li>
<li>
<p>Corrected an example in <a href="#id-joins"><b>I.1
Joins</b></a>. See <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/2010Nov/0036.html">
http://lists.w3.org/Archives/Public/public-qt-comments/2010Nov/0036.html</a>.</p>
</li>
<li>
<p>Clarified rules on ItemType Subtype Judgement for functions:
annotations in these rules are optional, the rules apply even if no
annotations are present; return types are covariant, function
arguments are contravariant.</p>
</li>
<li>
<p>Modified description of attribute constructors when the name
contains a URILiteral.</p>
</li>
<li>
<p>Clarified that "Evaluating Function Calls" section applies to
dynamic function <span>call</span> and partial function application
as well. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10574">Bug
10574</a>.</p>
</li>
<li>
<p>Clarified use of 'URILiteral':NCName as a name in
element/attribute construction. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10857">Bug
10857</a>.</p>
</li>
<li>
<p>Clarified relationship of conformance to XDM, F&amp;O
conformance items. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=13073">Bug
13073</a>.</p>
</li>
<li>
<p>Eliminated the phrase "query module", which was not
well-defined.</p>
</li>
<li>
<p>Added example for decimal format declaration. Resolves <a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=10859">Bug
10859</a>.</p>
</li>
<li>
<p>Clarified contributions of schema import, module import and
module declaration to the statically known namespaces. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=8265">Bug
8265</a>.</p>
</li>
<li>
<p>Renamed LiteralFunctionItem as NamedFunctionRef. (<a href=
"#id-named-function-ref"><b>3.1.6 Named Function References</b></a>
)</p>
</li>
<li>
<p>Removed the concept of "scope" defined in Appendix C. Resolves
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10368">Bug
10368</a>.</p>
</li>
<li>
<p>Changed the definition of <a title="subtype" href=
"#dt-subtype">subtype</a>, which is now based on <code>subtype(A,
B)</code>. Changed the titles of corresponding sections that
describe judgements.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</body>
</html>
