<!-- http://www.w3.org/TR/rif-core/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF Core Dialect (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF Core Dialect (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/" id="this-version-url">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-rif-core-20121211/">http://www.w3.org/TR/2012/PER-rif-core-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Harold Boley, National Research Council Canada</dd>
<dd>Gary Hallmark, Oracle Corporation</dd>
<dd>Michael Kifer, State University of New York at Stony Brook, USA</dd>
<dd>Adrian Paschke, Freie Universitaet Berlin</dd>
<dd>Axel Polleres, DERI</dd>
<dd>Dave Reynolds, Hewlett-Packard Laboratories, Bristol UK</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2010/rif/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/REC-rif-core-20130205.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2010/rif/translation/rif-core">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>This document, developed by the <a href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group" title="RIF Working Group">Rule Interchange Format (RIF) Working Group</a>, specifies RIF-Core, a common subset of RIF-BLD and RIF-PRD based on RIF-DTB 1.0. The RIF-Core presentation syntax and semantics are specified by restriction in two different ways. First, RIF-Core is specified by restricting the syntax and semantics of RIF-BLD, and second, by restricting RIF-PRD. The XML serialization syntax of RIF-Core is specified by a mapping from the presentation syntax. A normative XML schema is also provided.</p> </div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a>  (this document)</li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a></li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/PER-rif-core-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1"><a href="#RIF-Core_Presentation_Syntax"><span class="tocnumber">2</span> <span class="toctext">RIF-Core Presentation Syntax</span></a>
<ul>
<li class="toclevel-2"><a href="#Alphabet_of_RIF-Core"><span class="tocnumber">2.1</span> <span class="toctext">Alphabet of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Terms_of_RIF-Core"><span class="tocnumber">2.2</span> <span class="toctext">Terms of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Formulas_of_RIF-Core"><span class="tocnumber">2.3</span> <span class="toctext">Formulas of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Annotations_and_Documents"><span class="tocnumber">2.4</span> <span class="toctext">Annotations and Documents</span></a></li>
<li class="toclevel-2"><a href="#Well-formed_Formulas"><span class="tocnumber">2.5</span> <span class="toctext">Well-formed Formulas</span></a></li>
<li class="toclevel-2"><a href="#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-Core"><span class="tocnumber">2.6</span> <span class="toctext">EBNF Grammar for the Presentation Syntax of RIF-Core</span></a>
<ul>
<li class="toclevel-3"><a href="#EBNF_for_the_RIF-Core_Condition_Language"><span class="tocnumber">2.6.1</span> <span class="toctext">EBNF for the RIF-Core Condition Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_the_RIF-Core_Rule_Language"><span class="tocnumber">2.6.2</span> <span class="toctext">EBNF for the RIF-Core Rule Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_RIF-Core_Annotations"><span class="tocnumber">2.6.3</span> <span class="toctext">EBNF for RIF-Core Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#RIF-Core_as_a_Specialization_of_RIF-PRD"><span class="tocnumber">3</span> <span class="toctext">RIF-Core as a Specialization of RIF-PRD</span></a>
<ul>
<li class="toclevel-2"><a href="#Alphabet_of_RIF-Core_2"><span class="tocnumber">3.1</span> <span class="toctext">Alphabet of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Terms_of_RIF-Core_2"><span class="tocnumber">3.2</span> <span class="toctext">Terms of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Formulas_of_RIF-Core_2"><span class="tocnumber">3.3</span> <span class="toctext">Formulas of RIF-Core</span></a></li>
<li class="toclevel-2"><a href="#Annotations_and_Documents_2"><span class="tocnumber">3.4</span> <span class="toctext">Annotations and Documents</span></a></li>
<li class="toclevel-2"><a href="#Well-formed_Formulas_2"><span class="tocnumber">3.5</span> <span class="toctext">Well-formed Formulas</span></a></li>
<li class="toclevel-2"><a href="#Rules_and_Groups"><span class="tocnumber">3.6</span> <span class="toctext">Rules and Groups</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#RIF-Core_Semantics"><span class="tocnumber">4</span> <span class="toctext">RIF-Core Semantics</span></a></li>
<li class="toclevel-1"><a href="#XML_Serialization_Syntax_for_RIF-Core"><span class="tocnumber">5</span> <span class="toctext">XML Serialization Syntax for RIF-Core</span></a></li>
<li class="toclevel-1"><a href="#Safeness_Criteria"><span class="tocnumber">6</span> <span class="toctext">Safeness Criteria</span></a>
<ul>
<li class="toclevel-2"><a href="#Safeness"><span class="tocnumber">6.1</span> <span class="toctext">Safeness</span></a></li>
<li class="toclevel-2"><a href="#Strong_Safeness_.28Informative.29"><span class="tocnumber">6.2</span> <span class="toctext">Strong Safeness (Informative)</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_Clauses"><span class="tocnumber">7</span> <span class="toctext">Conformance Clauses</span></a></li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">8</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">9.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Informational_References"><span class="tocnumber">9.2</span> <span class="toctext">Informational References</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_XML_Schema_for_RIF-Core"><span class="tocnumber">10</span> <span class="toctext">Appendix: XML Schema for RIF-Core</span></a>
<ul>
<li class="toclevel-2"><a href="#Condition_Language"><span class="tocnumber">10.1</span> <span class="toctext">Condition Language</span></a></li>
<li class="toclevel-2"><a href="#Rule_Language"><span class="tocnumber">10.2</span> <span class="toctext">Rule Language</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_RIF_Media_Type_Registration"><span class="tocnumber">11</span> <span class="toctext">Appendix: RIF Media Type Registration</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">12</span> <span class="toctext">Appendix: Change Log (Informative)</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Overview" name="Overview"></a><h2> <span class="mw-headline">1  Overview </span></h2>
<p><span class="anchor" id="overview"></span> This specification describes <i><b>RIF-Core</b></i> (the Core dialect of the Rule Interchange Format). From a theoretical perspective, RIF-Core corresponds to the language of definite Horn rules without function symbols (often called 'Datalog') with a standard first-order semantics. RIF-Core thus is a subset of RIF-BLD [<a href="#ref-rif-bld" title="">RIF-BLD</a>]. At the same time, RIF-Core is a language of production rules where conclusions are interpreted as assert actions. RIF-Core thus also is a subset of RIF-PRD [<a href="#ref-rif-prd" title="">RIF-PRD</a>]. Moreover, RIF-Core is based on built-in functions and predicates over selected XML Schema datatypes, as specified in RIF-DTB 1.0 [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. The common subset of RIF-BLD and RIF-PRD is specified based on RIF-DTB 1.0.
</p><p>Syntactically, RIF-Core has a number of Datalog extensions to support features such as objects and frames as in F-logic [<a href="#ref-flogic-95" title="">KLW95</a>], internationalized resource identifiers (or IRIs, defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>]) as identifiers for concepts, and XML Schema datatypes [<a href="#ref-xml-schema2" title="">XML-SCHEMA2</a>]. In addition, RIF RDF and OWL Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] defines the syntax and semantics of integrated RIF-Core/RDF and RIF-Core/OWL languages. These features make RIF-Core a Web-aware language. However, it should be kept in mind that RIF is designed to enable interoperability among rule languages in general, and its uses are not limited to the Web. 
</p><p>RIF-Core is defined as a specialization of RIF-BLD (hence of [<a href="#ref-rif-fld" title="">RIF-FLD</a>], making it a starting point of the RIF extensibility framework). It is a syntactic subset of RIF-BLD, so that a well-formed RIF-Core formula (including document and condition formulas) is also a well-formed RIF-BLD formula.
</p><p>RIF-Core is also a syntactic subset of  [<a href="#ref-rif-prd" title="">RIF-PRD</a>]. It is intended that a RIF-PRD consumer can treat a RIF-Core document as if it was a RIF-PRD rule set while it also conforms to the normative RIF-Core first order semantics. However, due to the presence of builtin functions and predicates there are rule sets in the syntactic intersection of RIF-PRD and RIF-BLD which would not terminate under RIF-PRD semantics. We therefore define a notion of safe RIF-Core rules, which is a subset of RIF-Core rules that can be executed using a forward chaining strategy, and we define conformance in terms of such safe rules. These notions of safeness and conformance are defined formally in section 5 <a href="#sec-conformance" title="">Conformance and Safeness</a>.
</p><p>RIF-Core is not the <i>maximal</i> common subset of RIF-BLD and RIF-PRD. It omits some features from the intersection which do not significantly add to the expressiveness of the language and are judged to be not widely supported by rule languages.
</p><p>To give a preview, here is a simple complete RIF-Core example deriving a ternary relation from its inverse.
</p><p><b>Example 1</b> (An introductory RIF-Core example).
</p><p>A rule can be written in English to derive <tt>buy</tt> relationships from the <tt>sell</tt> relationships that are
stored as facts (e.g., as exemplified by the English statements below):
</p>
<ul>
  <li>
   <em>
     A buyer buys an item from a seller
     if the seller sells the item to the buyer.
   </em>
  </li>
  <li>
   <em>
     John sells LeRif to Mary.
   </em>
  </li>
</ul>
<p>The fact <i>Mary buys LeRif from John</i> can be logically derived by a <i>modus ponens</i> argument.
Assuming Web IRIs for the predicates <tt>buy</tt> and <tt>sell</tt>, as well as for the individuals
<tt>John</tt>, <tt>Mary</tt>, and <tt>LeRif</tt>, the above English phrase can be represented in RIF-Core Presentation Syntax as follows.
</p>
<pre>Document(
  Prefix(cpt &lt;http://example.com/concepts#&gt;)
  Prefix(ppl &lt;http://example.com/people#&gt;)
  Prefix(bks &lt;http://example.com/books#&gt;)

  Group
  (
    Forall&nbsp;?Buyer&nbsp;?Item&nbsp;?Seller (
        cpt:buy(?Buyer&nbsp;?Item&nbsp;?Seller)&nbsp;:- cpt:sell(?Seller&nbsp;?Item&nbsp;?Buyer)
    )
 
    cpt:sell(ppl:John bks:LeRif ppl:Mary)
  )
)
</pre>
<p>For the interchange of documents containing such rules (and facts), an equivalent RIF-Core XML syntax is provided in this specification. To formalize their meaning, a RIF-Core Semantics is specified.
</p><p>This document assumes familiarity with [<a href="#ref-rif-bld" title="">RIF-BLD</a>] or [<a href="#ref-rif-prd" title="">RIF-PRD</a>], as RIF-Core is derived from these documents via syntactic restrictions.
</p><p><span class="anchor" id="sec-core-direct-syntax"></span>
</p>
<a id="RIF-Core_Presentation_Syntax" name="RIF-Core_Presentation_Syntax"></a><h2> <span class="mw-headline">2  RIF-Core Presentation Syntax </span></h2>
<p>Like RIF-BLD and RIF-PRD, RIF-Core has both a <i><b>presentation syntax</b></i>
and an <i><b>XML syntax</b></i>.
It is defined in "mathematical English," a special form
of English for communicating mathematical definitions, examples, etc. and by an EBNF syntax.
The mathematical English is normative, the EBNF is not normative; both instances of the presentation syntax are not intended to be a concrete
syntax for RIF-Core. The English presentation syntax deliberately leaves out details such as the delimiters
of the various syntactic components, escape symbols, parenthesizing,
precedence of operators, and the like. Since RIF is an interchange format,
it uses XML, and only XML, as its concrete syntax. RIF-Core conformance is described in
terms of semantics-preserving mappings. 
</p><p>Since RIF-Core is a syntactic subset of RIF-BLD, this section defines
the presentation syntax of RIF-Core as a restriction on 
<a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-bld-direct-syntax" title="BLD">the presentation syntax of RIF-BLD</a>.
</p><p><span class="anchor" id="sec-alphabet"></span> 
</p>
<a id="Alphabet_of_RIF-Core" name="Alphabet_of_RIF-Core"></a><h4> <span class="mw-headline">2.1  Alphabet of RIF-Core </span></h4>
<p>The <i><b>alphabet</b></i> of the presentation language of RIF-Core is the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-alphabet" title="BLD">alphabet of the RIF-BLD presentation language</a> with the exclusion of the symbol <tt>##</tt> (subclass) and the set of symbols <tt>ArgNames</tt> (used for named-argument uniterms).
</p><p><span class="anchor" id="sec-terms"></span>
</p>
<a id="Terms_of_RIF-Core" name="Terms_of_RIF-Core"></a><h4> <span class="mw-headline">2.2  Terms of RIF-Core </span></h4>
<p>The <i><b>Terms</b></i> of RIF-Core are the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-terms" title="BLD">terms of RIF-BLD</a> with the exclusion of <i>subclass terms</i> and of <i>terms with named arguments</i>.
In RIF-Core there are only <em>closed ground</em> lists.  
</p><p><b>Definition (List Term)</b>
</p>
     <ul>     
       <li>
	 A <i><b>closed ground list</b></i> has the form <tt>List(t<sub>1</sub> ... <sub>m</sub>)</tt>, where <tt>m&ge;0</tt> and <tt>t<sub>1</sub>, ..., t<sub>m</sub></tt> are ground terms (no tail and no variables are allowed).  
       </li>
     </ul>
     <p>
        A closed list of the form <tt>List()</tt> (i.e., a list in which <tt>m=0</tt>) is called the <i><b>empty list</b></i>. 
     </p>
<p><span class="anchor" id="sec-Formulas"></span>
</p>
<a id="Formulas_of_RIF-Core" name="Formulas_of_RIF-Core"></a><h4> <span class="mw-headline">2.3  Formulas of RIF-Core </span></h4>
<p>The <i><b>Formulas</b></i> of RIF-Core are the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-formulas" title="BLD">formulas of RIF-BLD</a> with the following restrictions.
</p>
<ul><li> Subterms that occur inside atomic formulas can be variables, constants, ground list, or external positional terms. This implies that RIF-Core only allows external function applications.
</li><li> Equality terms and class membership terms <i>cannot</i> occur in rule conclusions -- they are allowed only in rule premises.
</li><li> Terms with named arguments and subclass terms are excluded from RIF-Core.
</li></ul>
<p><span class="anchor" id="sec-annotations"></span>
</p>
<a id="Annotations_and_Documents" name="Annotations_and_Documents"></a><h4> <span class="mw-headline">2.4  Annotations and Documents </span></h4>
<p>RIF-Core allows every term and formula to be optionally annotated in the same way as in RIF-BLD. The frame formulas that are allowed as part of an annotation must be syntactically correct for RIF-Core. In particular, no function symbols are allowed in such a formula.
</p><p><span class="anchor" id="sec-well-formed"></span>
</p>
<a id="Well-formed_Formulas" name="Well-formed_Formulas"></a><h4> <span class="mw-headline">2.5  Well-formed Formulas </span></h4>
<p>A syntactically correct RIF-Core formula that passes the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">well-formedness test for RIF-BLD</a> is also a well-formed RIF-Core formula.
</p><p>Recall that RIF-Core does not allow uninterpreted (i.e., non-external) function symbols. Therefore no symbol in RIF-Core can occur in the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-context" title="BLD">context</a> of an (uninterpreted) function symbol.
</p><p><br />
<span class="anchor" id="sec-concrete-syntax"></span>
</p>
<a id="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-Core" name="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-Core"></a><h4> <span class="mw-headline">2.6  EBNF Grammar for the Presentation Syntax of RIF-Core </span></h4>
<p>Until now, we have used mathematical English to specify the syntax of RIF-Core as a restriction on RIF-BLD. Tool developers, however, may prefer EBNF notation, which provides a more succinct view of the syntax. However, EBNF is unable to express all of the well-formedness conditions. For instance, the requirement that each symbol appear in only one context cannot be expressed in EBNF. As a result, the EBNF grammar defines a strict superset of RIF-Core.  For that reason this section is <i>not normative</i>.
</p><p>The EBNF for the RIF-Core presentation syntax is given as follows. For convenience of reading we show the entire EBNF divided into three parts (rules, conditions, and annotations); these are derived from the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-concrete-syntax" title="BLD">ENBF for RIF-BLD</a> by applying the restrictions described above. 
</p><p><span class="anchor" id="part-rule-language"></span>
<b>Rule Language:</b>
</p>
<pre>  Document      &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base          &nbsp;::= 'Base' '(' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'
  Prefix        &nbsp;::= 'Prefix' '(' <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE          &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE        &nbsp;::= Implies | ATOMIC
  Implies       &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR       &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a>
  PROFILE       &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a>
</pre>
<p><span class="anchor" id="part-condition-language"></span>
<b>Condition Language:</b>
</p>
<pre>  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? Equal |
                     IRIMETA? Member |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* ')'
  GROUNDUNITERM &nbsp;::= Const '(' GROUNDTERM* ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | List | 'External' '(' Expr ')')
  GROUNDTERM    &nbsp;::= IRIMETA? (Const | List | 'External' '(' GROUNDUNITERM ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' GROUNDTERM* ')'
  Const         &nbsp;::= '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"^^' SYMSPACE | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CONSTSHORT</a>
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> | '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"'
  SYMSPACE      &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CURIE</a>
</pre>
<p><span class="anchor" id="part-annotations"></span>
<b>Annotations:</b>
</p>
<pre>  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
</pre>
<p><tt>ANGLEBRACKIRI</tt>, <tt>CURIE</tt>, <tt>CONSTSHORT</tt>, and <tt>UNICODESTRING</tt> are defined in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">Shortcuts for Constants in RIF's Presentation Syntax</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>The following subsections explain and exemplify the Condition Language, Rule Language, and Annotations parts.
</p><p><span class="anchor" id="sec-ebnf-condition-language"></span> 
</p>
<a id="EBNF_for_the_RIF-Core_Condition_Language" name="EBNF_for_the_RIF-Core_Condition_Language"></a><h5> <span class="mw-headline">2.6.1  EBNF for the RIF-Core Condition Language </span></h5>
<p>The RIF-Core Condition Language represents formulas that can be used in the premises of RIF-Core rules (also called rule bodies). The EBNF grammar for a superset of the RIF-Core condition language is shown in the above <a href="#part-condition-language" title="">conditions part</a>.
</p><p>This is a specialization of the EBNF for the RIF-BLD condition language specified in the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#part-condition-language" title="BLD">RIF-BLD conditions part</a> reflecting the syntax restrictions on RIF-Core described normatively in sections 2.1 through 2.5 above.
</p><p><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ex-rif-bld-cond-pres-syntax" title="BLD">Example 3</a> from the RIF-BLD document, illustrates some RIF-BLD conditions. All the conditions, except for the terms with named arguments and the equalities with (non-ground) list terms, are also RIF-Core conditions.
</p><p><br />
<span class="anchor" id="sec-ebnf-rule-language"></span>
</p>
<a id="EBNF_for_the_RIF-Core_Rule_Language" name="EBNF_for_the_RIF-Core_Rule_Language"></a><h5> <span class="mw-headline">2.6.2  EBNF for the RIF-Core Rule Language </span></h5>
<p>The presentation syntax for RIF-Core rules is based on the syntax in Section <a href="#sec-ebnf-condition-language" title="">EBNF for the RIF-Core Condition Language</a> with the productions shown in the above <a href="#part-rule-language" title="">rules part</a>.
</p><p>Again, this is a specialization of the EBNF for the RIF-BLD rule language specified in the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#part-rule-language" title="BLD">RIF-BLD rules part</a> reflecting the syntax restrictions on RIF-Core described normatively in sections 2.1 through 2.5 above.
</p><p><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ex-rif-bld-rule-pres-syntax" title="BLD">Example 4</a> from the RIF-BLD document also illustrates a set of RIF-Core rules.
In contrast, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ex-rif-bld-namedargs-pres-syntax" title="BLD">Example 7</a> from the RIF-BLD document shows a formula that is <em>not</em> in RIF-Core because it includes terms with named arguments, which are not allowed in this dialect.
</p><p><br />
<span class="anchor" id="sec-ebnf-annotations"></span>
</p>
<a id="EBNF_for_RIF-Core_Annotations" name="EBNF_for_RIF-Core_Annotations"></a><h5> <span class="mw-headline">2.6.3  EBNF for RIF-Core Annotations </span></h5>
<p>The presentation syntax for RIF-Core annotations uses the production shown in the above <a href="#part-annotations" title="">annotations part</a>.
</p><p>This defines the specialization of the EBNF for the RIF-BLD annotation language specified through the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#part-annotations" title="BLD">RIF-BLD annotations part</a> where annotation frames use the more restricted TERMs defined in the above <a href="#part-condition-language" title="">conditions part</a> of RIF-Core.
</p><p><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ex-rif-bld-annotatedgroup-pres-syntax" title="BLD">Example 5</a> from the RIF-BLD document also illustrates a RIF-Core document that contains an annotated group formula.
</p><p><span class="anchor" id="sec-core-prd-spec"></span>
</p>
<a id="RIF-Core_as_a_Specialization_of_RIF-PRD" name="RIF-Core_as_a_Specialization_of_RIF-PRD"></a><h2> <span class="mw-headline">3  RIF-Core as a Specialization of RIF-PRD </span></h2>
<p><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-interoperability" title="PRD">RIF-Core is a syntactic subset of RIF-PRD</a>, and this section defines
the presentation syntax of RIF-Core as a restriction on 
the presentation syntax of RIF-PRD <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-conditions-abstract-syntax" title="PRD">Conditions</a>, 
<a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-actions-abstract-syntax" title="PRD">Actions</a>, and <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-rules-abstract-syntax" title="PRD">Rules</a>.
</p><p><span class="anchor" id="sec-prd-alphabet"></span> 
</p>
<a id="Alphabet_of_RIF-Core_2" name="Alphabet_of_RIF-Core_2"></a><h4> <span class="mw-headline">3.1  Alphabet of RIF-Core </span></h4>
<p>The <i><b>alphabet</b></i> of the presentation language of RIF-Core is the alphabet of the RIF-PRD presentation language (<a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-conditions-abstract-syntax" title="PRD">Conditions</a>, 
<a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-actions-abstract-syntax" title="PRD">Actions</a>, and <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-rules-abstract-syntax" title="PRD">Rules</a>) with the exclusion of the symbols <tt>##</tt>, <tt>such that</tt>, <tt>Not</tt>, <tt>INeg</tt>, <tt>Do</tt>, <tt>Assert</tt>, <tt>Retract</tt>, <tt>Modify</tt>, <tt>Execute</tt>, and <tt>New</tt>.
</p>
<a id="Terms_of_RIF-Core_2" name="Terms_of_RIF-Core_2"></a><h4> <span class="mw-headline">3.2  Terms of RIF-Core </span></h4>
<p>The <i><b>Terms</b></i> of RIF-Core are the <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-terms" title="PRD">terms</a> of RIF-PRD with the exclusion of <i>subclass terms</i>. In Core there are only <em>closed ground</em> lists.
</p>
<a id="Formulas_of_RIF-Core_2" name="Formulas_of_RIF-Core_2"></a><h4> <span class="mw-headline">3.3  Formulas of RIF-Core </span></h4>
<p>The <i><b>Formulas</b></i> of RIF-Core are the <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-formulas" title="PRD">formulas of RIF-PRD</a> with the exclusion of <i>negation formulas</i>.
</p>
<a id="Annotations_and_Documents_2" name="Annotations_and_Documents_2"></a><h4> <span class="mw-headline">3.4  Annotations and Documents </span></h4>
<p>RIF-Core allows every term and formula to be optionally annotated in the same way as in RIF-PRD. The frame formulas that are allowed as part of an annotation must be syntactically correct for RIF-Core.
</p>
<a id="Well-formed_Formulas_2" name="Well-formed_Formulas_2"></a><h4> <span class="mw-headline">3.5  Well-formed Formulas </span></h4>
<p>A syntactically correct RIF-Core formula that passes the <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-well-formed-formulas" title="PRD">well-formedness test for RIF-PRD</a> is also a well-formed RIF-Core formula.
</p>
<a id="Rules_and_Groups" name="Rules_and_Groups"></a><h4> <span class="mw-headline">3.6  Rules and Groups </span></h4>
<p>A RIF-Core rule is a <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/#sec-well-formed-rules-and-groups" title="PRD">well-formed RIF-PRD rule</a> rule with no nested forall, no binding pattern, and where the action block is a single atom, a single frame, or a conjunction 
of atoms and/or frames. A RIF-Core group is a RIF-PRD group without <tt>strategy</tt> and without <tt>priority</tt>.
</p><p><br />
<span class="anchor" id="sec-core-semantics"></span>
</p>
<a id="RIF-Core_Semantics" name="RIF-Core_Semantics"></a><h2> <span class="mw-headline">4  RIF-Core Semantics </span></h2>
<p>RIF-Core is a syntactic subset of RIF-BLD, and the semantics of RIF-Core is identical to the semantics of RIF-BLD for that subset. RIF-Core is also a syntactic subset of RIF-PRD, and the semantics of RIF-Core is also identical to the semantics of RIF-PRD for that subset.
</p><p><span class="anchor" id="sec-xml-core"></span>
</p>
<a id="XML_Serialization_Syntax_for_RIF-Core" name="XML_Serialization_Syntax_for_RIF-Core"></a><h2> <span class="mw-headline">5  XML Serialization Syntax for RIF-Core </span></h2>
<p>The XML syntax of RIF-Core is a subset of the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-xml-bld" title="BLD">XML syntax of RIF-BLD</a>. All XML tags of RIF-BLD (except <tt>Subclass</tt>, <tt>sub</tt> and <tt>super</tt>) are supported, but the XML schema of RIF-Core restricts their context with respect to what is allowed by the XML schema of RIF-BLD. The semantics of the XML syntax for RIF-Core is defined through the same <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#sec-translation-condition-language" title="BLD">RIF-BLD XML-to-presentation syntax mapping</a>.
</p><p>XML serialization of a complete RIF-Core document appears in the RIF-BLD specification as <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ex-RIF-doc-with-annotation-serialization" title="BLD">Example 8</a>.
</p><p><span class="anchor" id="sec-core-safeness-intro"></span>
</p>
<a id="Safeness_Criteria" name="Safeness_Criteria"></a><h2> <span class="mw-headline">6  Safeness Criteria </span></h2>
<p>RIF-Core is a syntactic subset of both RIF-BLD and RIF-PRD. The semantics of a RIF-Core formula is the same as the semantics given to it by RIF-BLD.
</p><p>All RIF-Core documents are also syntactically valid RIF-PRD documents. However, some formulas may be <i>unsafe</i> and cannot be executed under the RIF-PRD operational semantics. Thus, in order to allow production rule systems and logic programming systems to interchange rules via RIF-Core, we restrict RIF-Core to <i>safe</i> rules so that the logical semantics of RIF-BLD and the operational fixed-point semantics of RIF-PRD coincide. 
</p><p><span class="anchor" id="sec-core-safeness"></span>
</p>
<a id="Safeness" name="Safeness"></a><h3> <span class="mw-headline">6.1  Safeness </span></h3>
<p>Intuitively, safeness of rules guarantees that, when performing reasoning in a forward-chaining manner, it is possible to find bindings for all the variables in the rule so that the condition can be evaluated.
</p><p>To define safeness, we need to define, first, the notion of <i>binding patterns</i> for externally defined terms, as well as under what conditions variables are considered <i>bound</i>.
</p><p><b>Definition (Binding pattern).</b> <i><b>Binding patterns</b></i> are lists of the form (<tt>p<sub>1</sub></tt>, <tt>...</tt>, <tt>p<sub>n</sub></tt>), such that <tt>p<sub>i</sub></tt>=<tt>b</tt> or <tt>p<sub>i</sub></tt>=<tt>u</tt>, for <tt>1 &le; i &le; n</tt>: <tt>b</tt> stands for a "bound" and <tt>u</tt> stands for an "unbound" argument. &nbsp;&nbsp;☐
</p><p>Each external function or predicate has an associated list of <i><b>valid binding patterns</b></i>.  We define here the binding patterns valid for the functions and predicates defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. 
</p><p>Every function or predicate <tt>f</tt> defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] has a valid binding pattern for each of its schemas with only the symbol <tt>b</tt> such that its length is the number of arguments in the schema. In addition,
</p>
<ul><li> the external predicate <tt>pred:iri-string</tt> has the valid binding patterns (<tt>b</tt>, <tt>u</tt>) and (<tt>u</tt>, <tt>b</tt>) and
</li><li> the external predicate <tt>pred:list-contains</tt> has the valid binding pattern (<tt>b</tt>, <tt>u</tt>).
</li></ul>
<p>The functions and predicates defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] have no other valid binding patterns.
</p><p>To keep the definitions concise and intuitive, <i>boundedness</i> and <i>safeness</i> are defined, below, for condition formulas in disjunctive normal form, that can be existentially quantified themselves, but that contain, otherwise, no existential sub-formula. The definitions apply to any valid RIF-Core condition formula, because they can always, in principle, be put in that form, by applying the following syntactic transforms, in sequence:
</p>
<ol><li> if <i>f</i> contains existential sub-formulas, all the quantified variables are renamed, if necessary, and given a name that is unique in <i>f</i>, and the scope of the quantifiers is extended to <i>f</i>. Assume, for instance, that <i>f</i> has an existential sub-formula, <i>sf = <tt>Exists v<sub>1</sub>...v<sub>n</sub> (sf')</tt>, n &ge; 1</i>, such that the names <i><tt>v<sub>1</sub>...v<sub>n</sub></tt></i> do not occur in <i>f</i> outside of <i>sf</i>. After the transform, <i>f</i> becomes <i><tt>Exists v<sub>1</sub>...v<sub>n</sub> (f')</tt></i>, where <i>f' </i> is <i>f</i> with <i>sf</i> replaced by <i>sf' </i>. The transform is applied iteratively to all the existential sub-formulas in <i>f</i>;
</li><li> the (possibly existentially quantified) resulting formula is rewritten in disjunctive normal form ([<a href="#ref-mendelson97" title="">Mendelson97</a>], p. 30).
</li></ol>
<p><b>Definition (Boundedness).</b> An external function term <tt>External(f(t<sub>1</sub>,...,t<sub>n</sub>))</tt> is <i><b>bound</b></i> in a condition formula, if and only if <tt>f</tt> has a valid binding pattern (<tt>p<sub>1</sub></tt>, <tt>...</tt>, <tt>p<sub>n</sub></tt>) and, for all <i>j, 1 &le; j &le; n</i>, such that <tt>p<sub>j</sub></tt>=<tt>b</tt>, <tt>t<sub>j</sub></tt> is bound in the formula.
</p><p>A variable, <i>v</i>, is <i><b>bound</b></i> in an atomic formula, <i>a</i>, if and only if
</p>
<ul><li> <i>a</i> is neither an equality nor an external predicate, and <i>v</i> occurs as an argument in <i>a</i>;
</li><li> or <i>v</i> is bound in the conjunction formula <i>f = <tt>And(a)</tt></i>.
</li></ul>
<p>A variable, <i>v</i>, is <i><b>bound</b></i> in a conjunction formula, <i>f = <tt>And(c<sub>1</sub>...c<sub>n</sub>)</tt>, n&nbsp;&ge;&nbsp;1</i>, if and only if, either
</p>
<ul><li> <i>v</i> is bound in at least one of the conjuncts;
</li><li> or <i>v</i> occurs as the <i>j-th</i> argument in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an externally defined predicate, and the <i>j-th</i> position in a binding pattern that is associated with <i><tt>c<sub>i</sub></tt></i> is <tt>u</tt>, and all the arguments that occur, in <i><tt>c<sub>i</sub></tt></i>, in positions with value <i><tt>b</tt></i> in the same binding pattern are bound in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>;
</li><li> or <i>v</i> occurs in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an equality formula, and <i>v</i> occurs as the term on one side of the equality, and the term on the other side of the equality is bound in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>.
</li></ul>
<p>A variable, <i>v</i>, is <i><b>bound</b></i> in a disjunction formula, if and only if <i>v</i> is bound in every disjunct where it occurs;
</p><p>A variable, <i>v</i>, is <i><b>bound</b></i> in an existential formula, <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt>, <i>n &ge; 1</i>, if and only if <i>v</i> is bound in <i><tt>f'</tt></i>. &nbsp;&nbsp;☐
</p><p>Notice that the variables, <tt>v<sub>1</sub>,...,v<sub>n</sub></tt>, that are existentially quantified in an existential formula <i>f = <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt></i>, are bound in any formula, <i>F</i>, that contains <i>f</i> as a sub-formula, if and only if they are bound in <i>f</i>, since they do not exist outside of <i>f</i>.
</p><p><span class="anchor" id="def-safeness"></span>
<b>Definition (Safeness).</b> A variable, <i>v</i>, is <i><b>safe</b></i> in a condition formula, <i>f</i>, if and only if
</p>
<ul><li> <i>f</i> is an atomic formula and <i>f</i> is not an equality formula in which both terms are variables,  and <i>v</i> occurs in <i>f</i>;
</li><li> or <i>f</i> is a conjunction, <i>f = <tt>And(c<sub>1</sub>...c<sub>n</sub>)</tt>, n&nbsp;&ge;&nbsp;1</i>, and <i>v</i> is safe in at least one conjunct in <i>f</i>, or <i>v</i> occurs in a conjunct, <i><tt>c<sub>i</sub></tt></i>, that is an equality formula in which both terms are variables, and <i>v</i> occurs as the term on one side of the equality, and the variable on the other side of the equality is safe in <i>f' = <tt>And(c<sub>1</sub>...c<sub>i-1</sub>&nbsp;c<sub>i+1</sub>...c<sub>n</sub>)</tt></i>;
</li><li> or <i>f</i> is a disjunction, and <i>v</i> is safe in every disjunct;
</li><li> or <i>f</i> is an existential formula, <i>f = <tt>Exists v<sub>1</sub>,...,v<sub>n</sub> (f')</tt>, n &ge; 1</i>, and <i>v</i> is safe in <i>f' </i>.
</li></ul>
<p>A RIF-Core rule, <i>r</i> is <i><b>safe</b></i> if and only if
</p>
<ul><li> <i>r</i> is a variable free atomic formula,
</li><li> or <i>r</i> is a universal fact, <tt>Forall v<sub>1</sub>,...,v<sub>n</sub> (f)</tt>, <i>n &ge; 1</i>, and <i><tt>f</tt></i> is variable free,
</li><li> or <i>r</i> is a rule implication, <tt>&phi;&nbsp;:- &psi;</tt>, and all the variables that occur in <i><tt>&phi;</tt></i> are safe in <i><tt>&psi;</tt></i>, and all the variables that occur in <i><tt>&psi;</tt></i> are bound in <i><tt>&psi;</tt></i>;
</li><li> or <i>r</i> is a universal rule, <tt>Forall v<sub>1</sub>,...,v<sub>n</sub> (r')</tt>, <i>n &ge; 1</i>, and <i><tt>r'</tt></i> is safe.
</li></ul>
<p>A group, <tt>Group (s<sub>1</sub>...s<sub>n</sub>)</tt>, <i>n &ge; 0</i>, is <i><b>safe</b></i> if and only if
</p>
<ul><li> it is empty, that is, <i>n = 0</i>;
</li><li> or <i><tt>s<sub>1</sub></tt></i> and ... and <i><tt>s<sub>n</sub></tt></i> are safe.
</li></ul>
<p>A document is <i><b>safe</b></i> if and only if
</p>
<ul><li> it contains a safe group, or no group at all,
</li><li> and all the documents that it imports are safe. &nbsp;&nbsp;☐
</li></ul>
<p><span id="safeness-example"></span><b>Example.</b> Consider the following formula:
</p>
<pre>Forall&nbsp;?x&nbsp;?y&nbsp;?z&nbsp;?u
  (ex:p(?x)&nbsp;:- Or( And( ex:q(?z)
                        External(pred:iri-string(?x&nbsp;?z))))
                   And(&nbsp;?x=?y&nbsp;?y=?u ex:q(?u)))
</pre>
<p>One can verify that this formula is safe, in the following way: the only variable appearing in the conclusion of the rule is <tt>?x</tt>; <tt>?x</tt> is safe in the first component of the disjunction, because it occurs in the atomic formula <tt>pred:iri-string(?x,?z)</tt>. It is also safe in the second disjunct, because it occurs as the left term in an equality formula where the right term is <tt>?y</tt>, which is safe because it occurs as the left term in an equality formula where the right term is <tt>?u</tt>, which is safe because it occurs in the atomic formula <tt>ex:q(?u)</tt>. Being safe in both disjuncts, <tt>?x</tt> is safe in the disjunction.
</p><p>Moreover, <tt>?x</tt>, <tt>?y</tt>, <tt>?z</tt> and <tt>?u</tt> are all bound in the body of the rule:
</p>
<ul><li> <tt>?z</tt> is bound in the first disjunct because it occurs as an argument in the atom <tt>ex:q(?z)</tt>. Therefore, it is bound in the disjunction because it does not occur in the other disjunct;
</li><li> <tt>?u</tt> is bound in the second disjunct because it occurs as an argument in the atom <tt>ex:q(?u)</tt>. Therefore, it is bound in the disjunction because it does not occur in the other disjunct;
</li><li> <tt>?y</tt> is bound in the second disjunct because it  occurs as the left term in an equality formula where the right term is <tt>?u</tt>, which is bound in the conjunction without that equality formula. Therefore, it is bound in the disjunction because it does not occur in the other disjunct;
</li><li> <tt>?x</tt> is bound in the first disjunct because <tt>(u,b)</tt> is a valid binding pattern for <tt>pred:iri-string</tt>, where <tt>?x</tt> occurs as the first argument, and <tt>?z</tt>, which occurs as the second argument, is bound in the conjunction without the external predicate.  <tt>?x</tt> is also bound in the second disjunct, because it  occurs as the left term in an equality formula where the right term is <tt>?y</tt>, which is bound in the conjunction without that equality formula. Therefore, <tt>?x</tt> is bound in the disjunction.
</li></ul>
<p><span class="anchor" id="sec-strong-safeness"></span>
</p>
<a id="Strong_Safeness_.28Informative.29" name="Strong_Safeness_.28Informative.29"></a><h3> <span class="mw-headline">6.2  Strong Safeness (Informative) </span></h3>
<p>While safeness guarantees the possibility to do forward chaining with the rules, it does not guarantee that it is possible to construct a finite grounding. For this purpose we define strong safeness.
</p><p>The conformance clauses for RIF-Core only require conformance over safe rule sets as defined above. However, some rule engines, such as some Datalog engines, are only able to process rule sets which can be finitely grounded. For maximum interoperability with such systems it is recommended that RIF-Core producers restrict themselves to strongly safe rule sets where possible.
</p><p>Let R be a set of safe rule implications <tt>&phi;&nbsp;:- &psi;</tt> and let <tt>P</tt> be the set of pairs <tt>(p,n)</tt>, where <tt>p</tt> is a predicate symbol and <tt>n</tt> is a nonnegative integer (an arity). For the purposes of the definitions in this section we view frames <tt>a[b -&gt; c]</tt> and membership formulas <tt>a#b</tt>, respectively, as ternary and binary predicate symbols, and so <tt>(-&gt;,3)</tt>, <tt>(#,2)</tt> &isin; <tt>P</tt>. Note that equality <tt>=</tt> does not appear in <tt>P</tt>.
</p><p>We define the <i>graph of variable dependencies</i> of a set of atomic formulas A as a labeled directed graph G<sub>R</sub>=(V, E, L), where the labeling function L maps edges to sets of external function and predicate symbols, V is the set of variables appearing in A, and E is the smallest set and L' is the smallest function such that for every variable <tt>?V</tt>
</p>
<ul><li> for every atomic formula <tt>?V=t</tt> or <tt>t=?V</tt> in A and every variable <tt>?V'&ne;?V</tt> appearing in <tt>t</tt> such that <tt>f<sub>1</sub>, ..., f<sub>n</sub></tt>, <tt>0 &le; n</tt>, are the function symbols of the terms in <tt>t</tt> (including <tt>t</tt> itself) in which <tt>?V'</tt> appears, (<tt>?V,?V'</tt>) &isin; E and {<tt>f<sub>1</sub>, ..., f<sub>n</sub></tt>} &isin; L'((<tt>?V,?V'</tt>)), and
</li><li> for every external atomic formula <tt>External(f(t<sub>1</sub>,...,t<sub>n</sub>))</tt> in A, every <tt>i</tt> &isin; {<tt>1,...,n</tt>} such that <tt>t<sub>i</sub></tt>=<tt>?V</tt>, every valid binding pattern (<tt>p<sub>1</sub></tt>, <tt>...</tt>, <tt>p<sub>n</sub></tt>) of <tt>f</tt> such that <tt>p<sub>i</sub></tt>=<tt>u</tt>, and every variable <tt>?V'</tt> appearing in some t<sub>j</sub> such that  <tt>p<sub>i</sub></tt>=<tt>b</tt> and <tt>f<sub>1</sub>, ..., f<sub>m</sub></tt>, <tt>0 &le; m</tt>, are the function symbols of the terms in <tt>t<sub>j</sub></tt> in which <tt>?V'</tt> appears, (<tt>?V,?V'</tt>) &isin; E and {<tt>f<sub>1</sub>, ..., f<sub>m</sub></tt>} &isin; L'((<tt>?V,?V'</tt>)).
</li></ul>
<p>Finally, L is defined as: for every (e,e') &isin; E, L((e,e')) is the union of the minimal sets in L'((e,e')).
</p><p>For every rule implication, <tt>&phi;&nbsp;:- &psi;</tt>, we define the collection, B<sub>&psi;</sub>, of the sets of the atomic formulas in each of the conjunctions that are the components of <tt>&psi;'</tt>, where <tt>&psi;'</tt> is <tt>&psi;</tt> rewritten as a condition formula in disjunctive normal form, possibly existentially quantified itself, but otherwise containing no existential sub-formula (see description of the transform in the section <a href="#sec-core-safeness" title="">Safeness</a>, above).
</p><p>The <i>dependency graph</i> of a set of implications R is a labelled directed graph G<sub>R</sub>=(V, E), where edges are triples (v,v',l) such that v, v' &isin; V and l is a set of external function and predicate symbols. V is defined as: for every <tt>(p,n)</tt> &isin; <tt>P</tt> and every integer <tt>i</tt> such that <tt>1 &le; i &le; n</tt>, <tt>(p,n)/i</tt> &isin; V. 
E is the smallest set such that for every <tt>(p,n)/i</tt> &isin; V and every <tt>&phi;&nbsp;:- &psi;</tt> in R such that there is an atomic subformula <tt>p(t<sub>1</sub>,...,t<sub>i</sub>,...,t<sub>n</sub>)</tt> of <tt>&phi;</tt>, then for every variable <tt>?V</tt> appearing in <tt>t<sub>i</sub></tt>:
</p>
<ul><li> for every non-external and non-equality atomic formula with predicate symbol <tt>p'</tt> and <tt>m</tt> arguments in any A &isin; B<sub>&psi;</sub> and every <tt>j</tt> &isin; {<tt>1,...,m</tt>} such that a variable <tt>?V'</tt>is the <tt>j</tt>th argument and there is a path from <tt>?V</tt> to <tt>?V'</tt> in the graph of variable dependencies of A and F is the union of the labels of the shortest path, (<tt>(p,n)/i,(p',m)/j, F &cup; {f<sub>1</sub>,...,f<sub>l</sub>}</tt>) &isin; E, where <tt>f<sub>1</sub>, ..., f<sub>l</sub></tt>, <tt>0 &le; l</tt>, are the function symbols of the terms in <tt>t<sub>i</sub></tt> in which <tt>?V</tt> appears.
</li></ul>
<p><span class="anchor" id="def-strong-safeness">
<b>Definition (Strong safeness).</b> </span>
A set of rule implications <i>R</i> is <i><b>strongly safe</b></i> if its dependency graph does not contain cycles involving edges labelled with sets involving a function defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] that is not a casting function.  A RIF document <i>D</i> is strongly safe if the set <i>R</i> of rule implications that are subformulas of <i>D</i> is strongly safe.
</p><p><br />
</p><p><br />
</p><p><span class="anchor" id="sec-conformance"></span>
</p>
<a id="Conformance_Clauses" name="Conformance_Clauses"></a><h2> <span class="mw-headline">7  Conformance Clauses </span></h2>
<p>RIF-Core conformance is described in terms of semantics-preserving transformations.
</p><p>Let &Tau; be a set of datatypes and symbol spaces that includes the datatypes specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] and the symbol spaces <tt>rif:iri</tt> and <tt>rif:local</tt>. Suppose also that &Epsilon; is a set of external predicates and functions that includes the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. We say that a formula &phi; is a <i>Core</i><sub>&Tau;,&Epsilon;</sub> formula iff 
</p>
<ul>
  <li>
    &phi; is a well-formed Core formula,
  </li>
  <li>
    all the datatypes and symbol spaces used in &phi; are in &Tau;, and
  </li>
  <li>
    all the externally defined functions and predicates used in &phi; are in &Epsilon;.
  </li>
</ul>
<p><span class="anchor" id="def-conformance"></span>
A RIF processor is a <i><b>conformant</b></i> <i>Core</i><sub>&Tau;,&Epsilon;</sub> <i><b>consumer</b></i> iff it implements a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-sem-preserving-map-to" title="BLD"><i>semantics-preserving mapping</i></a> from the set of all <i>safe</i> <i>Core</i><sub>&Tau;,&Epsilon;</sub> formulas to the language <i>L</i> of the processor.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>Core</i><sub>&Tau;,&Epsilon;</sub> <i><b>producer</b></i> iff it implements a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-sem-preserving-map-from" title="BLD"><i>semantics-preserving mapping</i></a> from the language <i>L</i> of the processor to a set of <i>safe</i> <i>Core</i><sub>&Tau;,&Epsilon;</sub> formulas.
</p><p>An <i><b>admissible document</b></i> is an XML document that conforms to all the syntactic
constraints of RIF-Core, including ones that cannot be checked by an XML
Schema validator. Note that the concrete presentation syntax given in Section 2.6 is purely informative (to help implementers see the set of language structures supported by RIF-Core); the only normative concrete syntax for RIF-Core is the XML syntax. 
</p><p>In addition:
</p>
<ul><li> Conformant Core producers and consumers are required to support only the entailments of the form &phi; |=<sub><tt><i>CORE</i></tt></sub> &psi;, where &psi; is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ptr-closed-rif-condform" title="BLD"><i>closed RIF-Core condition formulas</i></a>, that is a RIF-Core condition formula which also meets the criteria for closed condition formula defined in <a href="#ref-rif-bld" title="">RIF-BLD</a>.
</li></ul>
<ul><li> A <i><b>conformant Core consumer</b></i> must reject any document containing features it does not support.
</li></ul>
<ul><li> A <i><b>conformant Core producer</b></i> is a conformant Core<sub>&Tau;,&Epsilon;</sub> producer which produces documents that include only the symbol spaces, datatypes, and externals that are required by Core.
</li></ul>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">8  Acknowledgements </span></h2>
<p>This document is the product of the Rules Interchange Format (RIF) Working Group (see below) whose 
members deserve recognition for their time and commitment.  The editors extend special thanks to Jos de Bruijn for his safeness definition and to: Jos de Bruijn, Leora Morgenstern, Christian de Sainte-Marie, Stella Mitchell and Changhai Ke for their thorough reviews and insightful discussions; the working group chairs, Chris Welty and Christian de Sainte-Marie, for their invaluable technical help and inspirational leadership; and W3C staff contact Sandro Hawke, a constant source of ideas, help, and feedback.
</p><p><br />
The regular attendees at meetings of the Rule Interchange Format (RIF) Working Group at the time of the publication were:
Adrian Paschke (Freie Universitaet Berlin), 
Axel Polleres (DERI),
Chris Welty (IBM), 
Christian de Sainte Marie (IBM), 
Dave Reynolds (HP), 
Gary Hallmark (ORACLE), 
Harold Boley (NRC), 
Jos de Bruijn (FUB),
Leora Morgenstern (IBM), 
Michael Kifer (Stony Brook), 
Mike Dean (BBN), 
Sandro Hawke (W3C/MIT), and
Stella Mitchell (IBM).
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">9  References </span></h2>
<a id="Normative_References" name="Normative_References"></a><h3> <span class="mw-headline">9.1  Normative References </span></h3>
<p><span class="anchor" id="ref-rdf-concepts"></span> 
</p>
<dl><dt> [RDF-CONCEPTS]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax</i>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rfc-3066"></span> 
</p>
<dl><dt> [RFC-3066]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3066" title="http://tools.ietf.org/html/rfc3066">RFC 3066</a> - Tags for the Identification of Languages</i>, H. Alvestrand, IETF, January 2001. This document is <a class="external free" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">http://www.ietf.org/rfc/rfc3066</a> .
</dd></dl>
<p><br />
<span class="anchor" id="ref-rfc-3987"></span> 
</p>
<dl><dt> [RFC-3987]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3987" title="http://tools.ietf.org/html/rfc3987">RFC 3987</a> - Internationalized Resource Identifiers (IRIs)</i>, M. Duerst and M. Suignard, IETF, January 2005. This document is <a class="external free" href="http://www.ietf.org/rfc/rfc3987" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987">http://www.ietf.org/rfc/rfc3987</a> .
</dd></dl>
<p><span class="anchor" id="ref-rif-bld"></span>
</p>
<dl><dt> [RIF-BLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/"><span>RIF Basic Logic Dialect (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-dtb"></span>
</p>
<dl><dt> [RIF-DTB]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-fld"></span>
</p>
<dl><dt> [RIF-FLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/"><span>RIF Framework for Logic Dialects (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">http://www.w3.org/TR/2013/REC-rif-fld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-fld/">http://www.w3.org/TR/rif-fld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-swc"></span>
</p>
<dl><dt> [RIF-RDF+OWL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/"><span>RIF RDF and OWL Compatibility (Second Edition)</span></a></cite> Jos de Bruijn, Chris Welty, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-prd"></span>
</p>
<dl><dt> [RIF-PRD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/"><span>RIF Production Rule Dialect (Second Edition)</span></a></cite> Christian de Sainte Marie, Gary Hallmark, Adrian Paschke, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-xml-1-point-0"></span> 
</p>
<dl><dt> [XML1.0]
</dt><dd> <i>Extensible Markup Language (XML) 1.0 (Fourth Edition)</i>, W3C Recommendation, World Wide Web Consortium, 16 August 2006, edited in place 29 September 2006. This version is <a class="external free" href="http://www.w3.org/TR/2006/REC-xml-20060816/" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-base"></span> 
</p>
<dl><dt> [XML-Base]
</dt><dd> <i>XML Base</i>, W3C Recommendation, World Wide Web Consortium, 27 June 2001. This version is <a class="external free" href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/" rel="nofollow" title="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">http://www.w3.org/TR/2001/REC-xmlbase-20010627/</a>. The latest version is available at <a class="external free" href="http://www.w3.org/TR/xmlbase/" rel="nofollow" title="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-schema2"></span> 
</p>
<dl><dt> [XML-SCHEMA2]
</dt><dd> <i>XML Schema Part 2: Datatypes</i>, W3C Recommendation, World Wide Web Consortium, 2 May 2001. This version is <a class="external free" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/" rel="nofollow" title="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>. The latest version is available at <a class="external free" href="http://www.w3.org/TR/xmlschema-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.
</dd></dl>
<p><br />
</p>
<a id="Informational_References" name="Informational_References"></a><h3> <span class="mw-headline">9.2  Informational References </span></h3>
<p><span class="anchor" id="ref-alternating-normal-form"></span> 
</p>
<dl><dt> [ANF01]
</dt><dd> <i>Normal Form Conventions for XML Representations of Structured Data</i>, Henry S. Thompson. October 2001. Available at <a class="external free" href="http://www.ltg.ed.ac.uk/~ht/normalForms.html" rel="nofollow" title="http://www.ltg.ed.ac.uk/~ht/normalForms.html">http://www.ltg.ed.ac.uk/~ht/normalForms.html</a>.
</dd></dl>
<p><span class="anchor" id="ref-chang-lee"></span> 
</p>
<dl><dt> [CL73]
</dt><dd> <i>Symbolic Logic and Mechanical Theorem Proving</i>, C.L. Chang and R.C.T. Lee. Academic Press, 1973.
</dd></dl>
<p><span class="anchor" id="ref-curie"></span> 
</p>
<dl><dt> [CURIE]
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">CURIE Syntax 1.0</a></cite>, S. McCarron, M. Birbeck,  Editors, W3C Working Group Note, 16 December 2010, <a class="external free" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">http://www.w3.org/TR/2010/NOTE-curie-20101216</a> . Latest version available at <a class="external free" href="http://www.w3.org/TR/curie" rel="nofollow" title="http://www.w3.org/TR/curie">http://www.w3.org/TR/curie</a>.
</dd></dl>
<p><span class="anchor" id="ref-enderton01"></span> 
</p>
<dl><dt> [Enderton01]
</dt><dd> <i>A Mathematical Introduction to Logic, Second Edition</i>, H. B. Enderton. Academic Press, 2001.
</dd></dl>
<p><span class="anchor" id="ref-flogic-95"></span> 
</p>
<dl><dt> [KLW95]
</dt><dd> <i>Logical foundations of object-oriented and frame-based languages,</i> M. Kifer, G. Lausen, J. Wu. Journal of ACM, July 1995, pp. 741--843.
</dd></dl>
<p><span class="anchor" id="ref-mendelson97"></span> 
</p>
<dl><dt> [Mendelson97]
</dt><dd> <i>Introduction to Mathematical Logic, Fourth Edition</i>, E. Mendelson. Chapman &amp; Hall, 1997.
</dd></dl>
<dl><dt><span id="ref-owl-reference">[OWL-Reference]</span>
</dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web Ontology Language Reference</a></i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004. Latest version available at <a class="external free" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-syntax"></span> 
</p>
<dl><dt> [RDFSYN04]
</dt><dd> <i>RDF/XML Syntax Specification (Revised)</i>, Dave Beckett, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-syntax-grammar/" rel="nofollow" title="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-ucr"></span>
</p>
<dl><dt> [RIF-UCR]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/"><span>RIF Use Cases and Requirements (Second Edition)</span></a></cite> Adrian Paschke, Leora Morgenstern, David Hirtle, Allen Ginsberg, Paula-Lavinia Patranjan, Frank McCabe, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-ucr/">http://www.w3.org/TR/rif-ucr/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-type-and-role-tags"></span> 
</p>
<dl><dt> [TRT03]
</dt><dd> <i>Object-Oriented RuleML: User-Level Roles, URI-Grounded Clauses, and Order-Sorted Terms</i>, H. Boley.  Springer LNCS 2876, Oct. 2003, pp. 1-16.  Available at <a class="external free" href="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf" rel="nofollow" title="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf">http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf</a>.
</dd></dl>
<p><span class="anchor" id="ref-vanemden-kowalski"></span> 
</p>
<dl><dt> [vEK76]
</dt><dd> <i>The semantics of predicate logic as a programming language</i>, M. van Emden and R. Kowalski. Journal of the ACM 23 (1976), pp. 733-742.
</dd></dl>
<p><span class="anchor" id="sec-xsd-bld"></span>
</p>
<a id="Appendix:_XML_Schema_for_RIF-Core" name="Appendix:_XML_Schema_for_RIF-Core"></a><h2> <span class="mw-headline">10  Appendix: XML Schema for RIF-Core </span></h2>
<p>The <b>namespace</b> of RIF is "<a class="external free" href="http://www.w3.org/2007/rif" rel="nofollow" title="http://www.w3.org/2007/rif#">http://www.w3.org/2007/rif#</a>". 
</p><p>XML schemas for the RIF-Core sublanguages are defined below and are also available at <a class="external free" href="http://www.w3.org/2010/rif-schema/core/" rel="nofollow" title="http://www.w3.org/2010/rif-schema/core/">http://www.w3.org/2010/rif-schema/core/</a> with additional examples.
</p><p><br />
</p>
<a id="Condition_Language" name="Condition_Language"></a><h3> <span class="mw-headline">10.1  Condition Language </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: CoreCond.xsd, v. 1.4, 2010-05-08, hboley/apaschke"&gt;

 &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
            schemaLocation='http://www.w3.org/2001/xml.xsd'/&gt; 
	   
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Condition Language as defined by
    the RIF-Core dialect.
    
    The schema is based on the following EBNF for the RIF-Core Condition Language
    (prepared for generalization to the RIF-BLD and RIF-PRD Condition Languages):
 
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? Equal |
                     IRIMETA? Member |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* ')'
  GROUNDUNITERM &nbsp;::= Const '(' GROUNDTERM* ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | List | 'External' '(' Expr ')')
  GROUNDTERM    &nbsp;::= IRIMETA? (Const | List | 'External' '(' GROUNDUNITERM ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' GROUNDTERM* ')'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= NCName | '"' UNICODESTRING '"'
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
 
  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
 
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  
  &lt;xs:group name="FORMULA"&gt;  
    &lt;!--
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? Equal |
                     IRIMETA? Member |
                     IRIMETA? 'External' '(' Atom ')' 
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="And"/&gt;
      &lt;xs:element ref="Or"/&gt;
      &lt;xs:element ref="Exists"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
      &lt;xs:element ref="Equal"/&gt;
      &lt;xs:element ref="Member"/&gt;
      &lt;xs:element name="External" type="External-FORMULA.type"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:complexType name="External-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORMULA.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Atom"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="And"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Or"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Exists"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="formula"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="formula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="declare"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Var"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="ATOMIC"&gt;
    &lt;!--
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Frame)
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Atom"/&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Atom"&gt;
    &lt;!--
  Atom          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  
  &lt;xs:group name="UNITERM"&gt;
    &lt;!--
  UNITERM       &nbsp;::= Const '(' (TERM* ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:element name="args" type="args-UNITERM.type" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;

  &lt;xs:group name="GROUNDUNITERM"&gt;
    &lt;!-- sensitive to ground terms
  GROUNDUNITERM       &nbsp;::= Const '(' (GROUNDTERM* ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:element name="args" type="args-GROUNDUNITERM.type" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="op"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Const"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="args-UNITERM.type"&gt;
    &lt;!-- sensitive to UNITERM (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="args-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDUNITERM (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="GROUNDTERM" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="Equal"&gt;
    &lt;!--
  Equal         &nbsp;::= TERM '=' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="left"/&gt;
        &lt;xs:element ref="right"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="left"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="right"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Member"&gt;
    &lt;!--
  Member        &nbsp;::= TERM '#' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="instance"/&gt;
        &lt;xs:element ref="class"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="instance"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="class"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Frame"&gt;
    &lt;!--
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="object"/&gt;
        &lt;xs:element name="slot" type="slot-Frame.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="object"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-Frame.type"&gt;
    &lt;!-- sensitive to Frame (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="TERM"&gt;  
    &lt;!--
  TERM          &nbsp;::= IRIMETA? (Const | Var | List | 'External' '(' Expr ')')
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="Var"/&gt;
         &lt;xs:element ref="List"/&gt;
         &lt;xs:element name="External" type="External-TERM.type"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:group name="GROUNDTERM"&gt;  
    &lt;!--
  GROUNDTERM    &nbsp;::= IRIMETA? (Const | List | 'External' '(' GROUNDUNITERM ')')
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="List"/&gt;
         &lt;xs:element name="External" type="External-GROUNDUNITERM.type"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

 &lt;xs:element name="List"&gt;  
    &lt;!--
      List          &nbsp;::= 'List' '(' GROUNDTERM* ')'
                 rewritten as
      List          &nbsp;::= 'List' '(' LISTELEMENTS? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:group ref="LISTELEMENTS" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="LISTELEMENTS"&gt;
    &lt;!--
  LISTELEMENTS  &nbsp;::= GROUNDTERM+
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="items"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="items"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="GROUNDTERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="External-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-TERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="External-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDTERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-GROUNDUNITERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="content-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Expr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="content-GROUNDUNITERM.type"&gt;
    &lt;!-- sensitive to GROUNDTERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Expr" type="content-GROUNDEXPR.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="content-GROUNDEXPR.type"&gt;
    &lt;!-- sensitive to GROUNDEXPR context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="GROUNDUNITERM"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="Expr"&gt;
    &lt;!--
  Expr          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="Const"&gt;
    &lt;!--
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" type="xs:anyURI" use="required"/&gt; 
      &lt;xs:attribute ref="xml:lang"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Name" type="xs:string"&gt;
    &lt;!--
  Name          &nbsp;::= UNICODESTRING
    --&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Var"&gt;
    &lt;!--
  Var           &nbsp;::= '?' Name
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="IRIMETA"&gt;
    &lt;!--
  IRIMETA  &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="id" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="meta" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="id"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="IRICONST.type"/&gt;   &lt;!-- type="&amp;rif;iri" --&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="meta"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="Frame"/&gt;
       &lt;xs:element name="And" type="And-meta.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="And-meta.type"&gt;
  &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-meta.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-meta.type"&gt;
    &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="IRICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/id context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2007/rif#iri"/&gt;
  &lt;/xs:complexType&gt;
  
 &lt;/xs:schema&gt;
</pre>
<a id="Rule_Language" name="Rule_Language"></a><h3> <span class="mw-headline">10.2  Rule Language </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: CoreRule.xsd, v. 1.5, 2010-05-08, hboley/apaschke"&gt;
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Rule Language as defined by
    the RIF-Core dialect.
    
    The schema is based on the following EBNF for the RIF-Core Rule Language
    (prepared for generalization to the RIF-BLD and RIF-PRD Rule Languages):
  
  Document      &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base          &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'
  Prefix        &nbsp;::= 'Prefix' '(' NCName ANGLEBRACKIRI ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE          &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE        &nbsp;::= Implies | ATOMIC
  Implies       &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR       &nbsp;::= ANGLEBRACKIRI
  PROFILE       &nbsp;::= ANGLEBRACKIRI
      
    Note that this is an extension of the syntax for the RIF-Core Condition Language (CoreCond.xsd).
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
 
  &lt;!-- The Rule Language includes the Condition Language from the same directory --&gt;
  &lt;xs:include schemaLocation="CoreCond.xsd"/&gt;
 
  &lt;xs:element name="Document"&gt;
    &lt;!--
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="directive" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="payload" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="directive"&gt;
    &lt;!--
  Base and Prefix represented directly in XML
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Import"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="payload"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Group"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Import"&gt;
    &lt;!--
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element ref="location"/&gt;
        &lt;xs:element ref="profile" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="location" type="xs:anyURI"/&gt;
 
  &lt;xs:element name="profile" type="xs:anyURI"/&gt;

  &lt;xs:element name="Group"&gt;
    &lt;!--
  Group    &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
    --&gt;
    &lt;xs:complexType&gt;
     &lt;xs:sequence&gt;
      &lt;xs:group ref="Group.content"/&gt;
      &lt;/xs:sequence&gt; 
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
 &lt;xs:group name="Group.content"&gt;
     &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sentence" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
 &lt;/xs:group&gt;

 &lt;xs:element name="sentence"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="RULE"/&gt;
       &lt;xs:element ref="Group"/&gt;
     &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;
  
  &lt;xs:group name="RULE"&gt;
    &lt;!--
  RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Forall"/&gt;
      &lt;xs:group ref="CLAUSE"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="Forall"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="Forall.content"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="Forall.content"&gt;  
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;!-- different from formula in And, Or and Exists --&gt;
        &lt;xs:element name="formula"&gt;
          &lt;xs:complexType&gt;
            &lt;xs:group ref="CLAUSE"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:group name="CLAUSE"&gt;  
    &lt;!--
  CLAUSE  &nbsp;::= Implies | ATOMIC
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Implies"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Implies"&gt;
    &lt;!--
  Implies  &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="if"/&gt;
        &lt;xs:element ref="then"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="if"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="then"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:sequence&gt;
       &lt;xs:group ref="then.content"/&gt;
     &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="then.content"&gt;  
     &lt;xs:choice&gt;
       &lt;xs:group ref="ATOMIC"/&gt;
       &lt;xs:element name="And" type="And-then.type"/&gt;
     &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

 
  &lt;xs:complexType name="And-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-then.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

 &lt;/xs:schema&gt;
</pre>
<a id="Appendix:_RIF_Media_Type_Registration" name="Appendix:_RIF_Media_Type_Registration"></a><h2> <span class="mw-headline">11  Appendix: RIF Media Type Registration </span></h2>
<p>The anticipated RIF media type is "application/rif+xml".  The registration for this media type (pending IETF discussion and approval by the IESG) follows.
</p>
<pre>

   Type name: application

   Subtype name: rif+xml

   Required parameters: none

   Optional parameters: charset, as per RFC 3023 (XML Media Types)

   Encoding considerations: same as RFC 3023 (XML Media Types)

   Security considerations: 

       Systems which consume RIF documents are potentially vulnerable
       to attack by malicious producers of RIF documents.  The
       vulnerabilities and forms of attack are similar to those of
       other Web-based formats with programming or scripting
       capabilities, such as HTML with embedded Javascript.

       Excessive Resource Use / Denial of Service Attacks

          Complete processing of a RIF document, even a conformant
          RIF Core document, may require arbitrarily great CPU and
          memory resources.  Through the use of "import", processing
          may also require arbitrary URI dereferencing, which may
          consume all available network resources on the consuming
          system or other systems.  RIF consuming systems SHOULD
          implement reasonable defenses against these attacks.

       Exploiting Implementation Flaws

          RIF is a relatively complex format, and rule engines can be
          extremely sophisticated, so it is likely that some RIF
          consuming systems will have bugs which allow specially
          constructed RIF documents to perform inappropriate
          operations. We urge RIF implementors to make systems which
          carefully anticipate and handle all possible inputs,
          including those which present syntactic or semantic errors.

       External (Application) Functions

          Because RIF may be extended with local, application defined
          datatypes and functions, new vulnerabilities may be
          introduced.  Before being installed on systems which consume
          untrusted RIF documents, these external functions should be
          closely reviewed for their own vulnerabilities and for the
          vulnerabilities that may occur when they are used in
          unexpected combinations, like "cross-site scripting"
          attacks.
       
       In addition, as this media type uses the "+xml" convention, it
       shares the same security considerations as other XML formats;
       see RFC 3023 (XML Media Types).


   Interoperability considerations: 

       This media type is intended to be shared with other RIF
       dialects, to be specified in the future.  Interoperation
       between the dialects is governed by the RIF specifications.

   Published specifications: 

       RIF Core Dialect
       W3C Working Draft (Recommendation Track)
       http://www.w3.org/TR/rif-core/

       RIF Datatypes and Builtins
       W3C Working Draft (Recommendation Track)
       http://www.w3.org/TR/rif-dtb/

       RIF Basic Logic Dialect
       W3C Working Draft (Recommendation Track)
       http://www.w3.org/TR/rif-bld/

       RIF Production Rule Dialect
       W3C Working Draft (Recommendation Track)
       http://www.w3.org/TR/rif-prd/

       RIF Framework for Logic Dialects
       W3C Working Draft (Recommendation Track)
       http://www.w3.org/TR/rif-fld/

       This media type is intended for use by all RIF dialects,
       including those to be specified in the future.  Identification
       of the RIF dialect in use by a document is done by examining
       the use of specific XML elements within the document.

   Applications that use this media type: 

       See: http://www.w3.org/2005/rules/wiki/Implementations

   Additional information:

     Magic number(s): 

           As with XML in general (See RFC 3023 (XML Media Types)),
           there is no magic number for this format.

           However, the XML namespace "http://www.w3.org/2007/rif#" will
           normally be present in the document.  It may theoretically
           be missing if the document uses XML entities in an
           obfuscatory manner, and may also be present in documents with 
           ther media types, so use of the namespace is not conclusive.
         
           The hex form of that namespace will depend on the charset.
           For utf-8, the hex is: 68 74 74 70 3a 2f 2f 77 77 77 2e 77
           33 2e 6f 72.
           
     File extension(s): 

           .rif (or .xml)

     Macintosh file type code(s): 

           "TEXT" (like other XML)

   Person &amp; email address to contact for further information:

       Sandro Hawke, sandro@w3.org.  Please send technical comments
       and questions about RIF to public-rif-comments@w3.org, a
       mailing list with a public archive at
       http://lists.w3.org/Archives/Public/public-rif-comments/ 

   Intended usage: 

       COMMON

   Restrictions on usage: 

       None

   Author:

       The editor and contact for this media type registration is
       Sandro Hawke, sandro@w3.org.

   Change controller: 

       RIF is a product of the Rule Interchange Format (RIF) Working
       Group of the World Wide Web Consortium (W3C).  See
       http://www.w3.org/2005/rules/wg for information on the group.
       The W3C (currently acting through this working group) has
       change control over the RIF specification.


</pre>
<p><br />
</p>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">12  Appendix: Change Log (Informative) </span></h2>
<p>This appendix summarizes the main changes to this document.
</p><p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/WD-rif-core-20090703/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-rif-core-20090703/">draft of July 3, 2009</a>.
</p>
<ul><li> IRI was replaced with ANGLEBRACKIRI in CoreRule.xsd, v. 1.3.
</li><li> The complexType ANYURICONST was introduced in CoreRule.xsd, v. 1.3.
</li><li> A number of typos were found and fixed.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/CR-rif-core-20091001/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-rif-core-20091001/">Candidate Recommendation of October 1, 2009</a>.
</p>
<ul><li> Import's anyURIs were moved directly into location and profile.
</li><li> Simplified notion of conformant Core consumer.
</li><li> Fixed List by permitting IRIMETA and aligning syntax to Expr and Atom.
</li><li> Accommodated DTB-triggered UNICODESTRING/NCName changes of BLD in EBNF. 
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/rif-core/" rel="nofollow" title="http://www.w3.org/TR/rif-core/">Recommendation of 22 June, 2010</a>.
</p>
<ul><li> Definition (Strong safeness): introduced document metavariable D; omitted Editor's Note. 
</li></ul>
</div>


</body>
</html>