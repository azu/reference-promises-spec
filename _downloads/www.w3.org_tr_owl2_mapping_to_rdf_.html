<!-- http://www.w3.org/TR/owl2-mapping-to-rdf/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="owl.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both">OWL 2 Web Ontology Language <br /><span id="short-title">Mapping to RDF Graphs (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 11 December 2012</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/" id="this-version-url">http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/</a></dd>

<dt>Latest version (series 2):</dt>
<dd><a href="http://www.w3.org/TR/owl2-mapping-to-rdf/">http://www.w3.org/TR/owl2-mapping-to-rdf/</a></dd>

<dt>Latest Recommendation:</dt>
<dd><a href="http://www.w3.org/TR/owl-mapping-to-rdf">http://www.w3.org/TR/owl-mapping-to-rdf</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-owl2-mapping-to-rdf-20121018/">http://www.w3.org/TR/2012/PER-owl2-mapping-to-rdf-20121018/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Peter F. Patel-Schneider, Nuance Communications</dd>
<dd><a href="http://www.cs.ox.ac.uk/people/boris.motik/">Boris Motik</a>, University of Oxford</dd>
<dt>Contributors: (in alphabetical order)</dt><dd><a href="http://www.cs.ox.ac.uk/people/bernardo.cuencagrau/">Bernardo Cuenca Grau</a>, University of Oxford</dd>
<dd><a href="http://www.cs.ox.ac.uk/people/ian.horrocks/">Ian Horrocks</a>, University of Oxford</dd>
<dd><a href="http://www.cs.man.ac.uk/~bparsia/">Bijan Parsia</a>, University of Manchester</dd>
<dd><a href="http://sciencecommons.org/about/whoweare/ruttenberg/">Alan Ruttenberg</a>, Science Commons (Creative Commons)</dd>
<dd><a href="http://www.fzi.de/michael.schneider">Michael Schneider</a>, FZI Research Center for Information Technology</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2007/OWL/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/diff-from-20121018">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2012/pdf/REC-owl2-mapping-to-rdf-20121211.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2007/OWL/translation/owl2-mapping-to-rdf">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2012 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>The OWL 2 Web Ontology Language, informally OWL 2, is an ontology language for the Semantic Web with formally defined meaning.  OWL 2 ontologies provide classes, properties, individuals, and data values and are stored as Semantic Web documents.  OWL 2 ontologies can be used along with information written in RDF, and OWL 2 ontologies themselves are primarily exchanged as RDF documents.  The OWL 2 <a href="http://www.w3.org/TR/2012/REC-owl2-overview-20121211/" title="Document Overview">Document Overview</a> describes the overall state of OWL 2, and should be read before other OWL 2 documents.</p><p>This document defines the mapping of OWL 2 ontologies into RDF graphs, and vice versa.</p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Summary of Changes</h4>

            <div>There have been no <a href="http://www.w3.org/2005/10/Process-20051014/tr#substantive-change">substantive</a> changes since the <a href="http://www.w3.org/TR/2012/PER-owl2-mapping-to-rdf-20121018/">previous version</a>.   For details on the minor changes see the <a href="#changelog">change log</a> and <a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/diff-from-20121018">color-coded diff</a>.</div>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-owl-comments@w3.org">public-owl-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2007/OWL/">OWL Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2007/OWL/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/41712/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<p>
</p>
<script type="text/javascript">/*&lt;![CDATA[*/

function show_short_toc() {
    set_display_by_class('li','toclevel-3','none');
    set_display_by_id('short-toc','none');
    set_display_by_id('full-toc','');
}

function show_full_toc() {
    set_display_by_class('li','toclevel-3','');
    set_display_by_id('short-toc','');
    set_display_by_id('full-toc','none');
}

/*]]&gt;*/</script>


<p>

</p>
<table class="toc" id="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction_and_Preliminaries"><span class="tocnumber">1</span> <span class="toctext">Introduction and Preliminaries</span></a></li>
<li class="toclevel-1"><a href="#Mapping_from_the_Structural_Specification_to_RDF_Graphs"><span class="tocnumber">2</span> <span class="toctext">Mapping from the Structural Specification to RDF Graphs</span></a>
<ul>
<li class="toclevel-2"><a href="#Translation_of_Axioms_without_Annotations"><span class="tocnumber">2.1</span> <span class="toctext">Translation of Axioms without Annotations</span></a></li>
<li class="toclevel-2"><a href="#Translation_of_Annotations"><span class="tocnumber">2.2</span> <span class="toctext">Translation of Annotations</span></a></li>
<li class="toclevel-2"><a href="#Translation_of_Axioms_with_Annotations"><span class="tocnumber">2.3</span> <span class="toctext">Translation of Axioms with Annotations</span></a>
<ul>
<li class="toclevel-3"><a href="#Axioms_that_Generate_a_Main_Triple"><span class="tocnumber">2.3.1</span> <span class="toctext">Axioms that Generate a Main Triple</span></a></li>
<li class="toclevel-3"><a href="#Axioms_that_are_Translated_to_Multiple_Triples"><span class="tocnumber">2.3.2</span> <span class="toctext">Axioms that are Translated to Multiple Triples</span></a></li>
<li class="toclevel-3"><a href="#Axioms_Represented_by_Blank_Nodes"><span class="tocnumber">2.3.3</span> <span class="toctext">Axioms Represented by Blank Nodes</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Mapping_from_RDF_Graphs_to_the_Structural_Specification"><span class="tocnumber">3</span> <span class="toctext">Mapping from RDF Graphs to the Structural Specification</span></a>
<ul>
<li class="toclevel-2"><a href="#Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents"><span class="tocnumber">3.1</span> <span class="toctext">Extracting Declarations and the IRIs of the Directly Imported Ontology Documents</span></a>
<ul>
<li class="toclevel-3"><a href="#Resolving_Included_RDF_Graphs"><span class="tocnumber">3.1.1</span> <span class="toctext">Resolving Included RDF Graphs</span></a></li>
<li class="toclevel-3"><a href="#Parsing_of_the_Ontology_Header_and_Declarations"><span class="tocnumber">3.1.2</span> <span class="toctext">Parsing of the Ontology Header and Declarations</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Populating_an_Ontology"><span class="tocnumber">3.2</span> <span class="toctext">Populating an Ontology</span></a>
<ul>
<li class="toclevel-3"><a href="#Analyzing_Declarations"><span class="tocnumber">3.2.1</span> <span class="toctext">Analyzing Declarations</span></a></li>
<li class="toclevel-3"><a href="#Parsing_of_Annotations"><span class="tocnumber">3.2.2</span> <span class="toctext">Parsing of Annotations</span></a></li>
<li class="toclevel-3"><a href="#Parsing_of_Ontology_Annotations"><span class="tocnumber">3.2.3</span> <span class="toctext">Parsing of Ontology Annotations</span></a></li>
<li class="toclevel-3"><a href="#Parsing_of_Expressions"><span class="tocnumber">3.2.4</span> <span class="toctext">Parsing of Expressions</span></a></li>
<li class="toclevel-3"><a href="#Parsing_of_Axioms"><span class="tocnumber">3.2.5</span> <span class="toctext">Parsing of Axioms</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">4</span> <span class="toctext">Appendix: Change Log (Informative)</span></a>
<ul>
<li class="toclevel-2"><a href="#Changes_Since_Recommendation"><span class="tocnumber">4.1</span> <span class="toctext">Changes Since Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Proposed_Recommendation"><span class="tocnumber">4.2</span> <span class="toctext">Changes Since Proposed Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Candidate_Recommendation"><span class="tocnumber">4.3</span> <span class="toctext">Changes Since Candidate Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Last_Call"><span class="tocnumber">4.4</span> <span class="toctext">Changes Since Last Call</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgments"><span class="tocnumber">5</span> <span class="toctext">Acknowledgments</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<p><br />
</p>
<a id="Introduction_and_Preliminaries" name="Introduction_and_Preliminaries"></a><h2> <span class="mw-headline">1  Introduction and Preliminaries </span></h2>
<p>This document defines two mappings between the structural specification of OWL 2 [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>] and RDF graphs [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>]. The mapping presented in <a href="#Mapping_from_the_Structural_Specification_to_RDF_Graphs" title="">Section 2</a> can be used to transform any OWL 2 ontology <i>O</i> into an RDF graph <i>T(O)</i>. The mapping presented in <a href="#Mapping_from_RDF_Graphs_to_the_Structural_Specification" title="">Section 3</a> can be used to transform an RDF graph <i>G</i> satisfying certain restrictions into an OWL 2 DL ontology <i>O<sub>G</sub></i>. These transformations do not incur any change in the formal meaning of the ontology. More precisely, for any OWL 2 DL ontology <i>O</i>, let <i>G = T(O)</i> be the RDF graph obtained by transforming <i>O</i> as specified in <a href="#Mapping_from_the_Structural_Specification_to_RDF_Graphs" title="">Section 2</a>, and let <i>O<sub>G</sub></i> be the OWL 2 DL ontology obtained by applying the reverse transformation from <a href="#Mapping_from_RDF_Graphs_to_the_Structural_Specification" title="">Section 3</a> to <i>G</i>; then, <i>O</i> and <i>O<sub>G</sub></i> are logically equivalent &mdash; that is, they have exactly the same set of models.
</p><p>The mappings presented in this document are backwards-compatible with that of OWL 1 DL: every OWL 1 DL ontology encoded as an RDF graph can be mapped into a valid OWL 2 DL ontology using the mapping from <a href="#Mapping_from_RDF_Graphs_to_the_Structural_Specification" title="">Section 3</a> such that the resulting OWL 2 DL ontology has exactly the same set of models as the original OWL 1 DL ontology.
</p><p>The syntax for triples used in this document is the one used in the RDF Semantics [<cite><a href="#ref-rdf-semantics" title="">RDF Semantics</a></cite>]. Full IRIs are abbreviated using the prefixes from the OWL 2 Specification [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>]. OWL 2 ontologies mentioned in this document should be understood as instances of the structural specification of OWL 2 [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>]; when required, these are written in this document using the functional-style syntax.
</p><p>The following notation is used throughout this document for referring to parts of RDF graphs:
</p>
<ul><li> <span class="name">*:x</span> denotes an IRI;
</li><li> <span class="name">_:x</span> denotes a blank node;
</li><li> <span class="name">x</span> denotes a blank node or an IRI;
</li><li> <span class="name">lt</span> denotes a literal; and
</li><li> <span class="name">xlt</span> denotes a blank node, an IRI, or a literal.
</li></ul>
<p>The italicized keywords <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em>, <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em>, <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em>, <em class="RFC2119" title="SHOULD NOT in RFC 2119 context">SHOULD NOT</em>, and <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> are used to specify normative features of OWL 2 documents and tools, and are interpreted as specified in RFC 2119 [<cite><a href="#ref-rfc-2119" title="">RFC 2119</a></cite>].
</p>
<a id="Mapping_from_the_Structural_Specification_to_RDF_Graphs" name="Mapping_from_the_Structural_Specification_to_RDF_Graphs"></a><h2> <span class="mw-headline">2  Mapping from the Structural Specification to RDF Graphs </span></h2>
<p>This section defines a mapping of an OWL 2 ontology <i>O</i> into an RDF graph <i>T(O)</i>. The mapping is presented in three parts. <a href="#Translation_of_Axioms_without_Annotations" title="">Section 2.1</a> shows how to translate axioms that do not contain annotations, <a href="#Translation_of_Annotations" title="">Section 2.2</a> shows how to translate annotations, and <a href="#Translation_of_Axioms_with_Annotations" title="">Section 2.3</a> shows how to translate axioms containing annotations.
</p>
<a id="Translation_of_Axioms_without_Annotations" name="Translation_of_Axioms_without_Annotations"></a><h3> <span class="mw-headline">2.1  Translation of Axioms without Annotations </span></h3>
<p>Table 1 presents the operator <i>T</i> that maps an OWL 2 ontology <i>O</i> into an RDF graph <i>T(O)</i>, provided that no axiom in <i>O</i> is annotated. The mapping is defined recursively; that is, the mapping of a construct often depends on the mappings of its subconstructs, but in a slightly unusual way: if the mapping of a construct refers to the mapping of a subconstruct, then the triples generated by the recursive invocation of the mapping on the subconstruct are added to the graph under construction, and the <i>main node</i> of the mapping of the subconstruct is used in place of the recursive invocation itself.
</p><p>The definition of the operator <i>T</i> uses the operator <i>TANN</i> in order to translate annotations. The operator <i>TANN</i> is defined in <a href="#Translation_of_Annotations" title="">Section 2.2</a>. It takes an annotation and an IRI or a blank node and produces the triples that attach the annotation to the supplied object.
</p><p>In the mapping, each generated blank node (i.e., each blank node that does not correspond to an anonymous individual) is fresh in each application of a mapping rule. Furthermore, possible conditions on the mapping rules are enclosed in curly braces '{ }'. Finally, the following conventions are used in this section to denote different parts of OWL 2 ontologies:
</p>
<ul><li> <span class="name">OP</span> denotes an object property;
</li><li> <span class="name">OPE</span> denotes an object property expression;
</li><li> <span class="name">DP</span> denotes a data property;
</li><li> <span class="name">DPE</span> denotes a data property expression;
</li><li> <span class="name">AP</span> denotes an annotation property;
</li><li> <span class="name">C</span> denotes a class;
</li><li> <span class="name">CE</span> denotes a class expression;
</li><li> <span class="name">DT</span> denotes a datatype;
</li><li> <span class="name">DR</span> denotes a data range;
</li><li> <span class="name">U</span> denotes an IRI;
</li><li> <span class="name">F</span> denotes a constraining facet;
</li><li> <span class="name">a</span> denotes an individual (named or anonymous);
</li><li> <span class="name">*:a</span> denotes a named individual;
</li><li> <span class="name">lt</span> denotes a literal;
</li><li> <span class="name">as</span> denotes an annotation source; and
</li><li> <span class="name">av</span> denotes an annotation value.
</li></ul>
<p>In this section, <span class="name">T(SEQ y<sub>1</sub> ... y<sub>n</sub>)</span> denotes the translation of a sequence of objects from the structural specification into an RDF list, as shown in Table 1.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 1.</span> Transformation to Triples
</caption>
<tbody><tr>
<th> Element <i>E</i> of the Structural Specification
</th><th> Triples Generated in an Invocation of <i>T(E)</i>
</th><th> Main Node of <i>T(E)</i>
</th></tr>
<tr>
<td class="name"> SEQ
</td><td>
</td><td class="name"> <i>rdf:nil</i>
</td></tr>
<tr>
<td class="name"><span id="a_SEQ"> </span>SEQ y<sub>1</sub> ... y<sub>n</sub>
</td><td class="name"> _:x <i>rdf:first</i> T(y<sub>1</sub>) .<br /> _:x <i>rdf:rest</i> T(SEQ y<sub>2</sub> ... y<sub>n</sub>) .
</td><td class="name"> _:x
</td></tr>
<tr>
<td> <span id="a_Ontology"> </span><span id="a_imports"> </span><span id="a_version"> </span>Ontology( ontologyIRI [ versionIRI ]<br /> &nbsp;&nbsp;&nbsp; Import( importedOntologyIRI<sub>1</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; Import( importedOntologyIRI<sub>k</sub> )<br /> &nbsp;&nbsp;&nbsp; annotation<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; annotation<sub>m</sub><br /> &nbsp;&nbsp;&nbsp; axiom<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; axiom<sub>n</sub><br />)
</td><td> ontologyIRI <i>rdf:type</i> <i>owl:Ontology</i> .<br /> [ ontologyIRI <i>owl:versionIRI</i> versionIRI ] .<br /> ontologyIRI <i>owl:imports</i> importedOntologyIRI<sub>1</sub> .<br /> ...<br /> ontologyIRI <i>owl:imports</i> importedOntologyIRI<sub>k</sub> .<br /> TANN(annotation<sub>1</sub>, ontologyIRI) .<br /> ...<br /> TANN(annotation<sub>m</sub>, ontologyIRI) .<br /> T(axiom<sub>1</sub>) .<br /> ...<br /> T(axiom<sub>n</sub>) .
</td><td> ontologyIRI
</td></tr>
<tr>
<td> Ontology(<br /> &nbsp;&nbsp;&nbsp; Import( importedOntologyIRI<sub>1</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; Import( importedOntologyIRI<sub>k</sub> )<br /> &nbsp;&nbsp;&nbsp; annotation<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; annotation<sub>m</sub><br /> &nbsp;&nbsp;&nbsp; axiom<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; axiom<sub>n</sub><br />)
</td><td> _:x <i>rdf:type</i> <i>owl:Ontology</i> .<br /> _:x <i>owl:imports</i> importedOntologyIRI<sub>1</sub> .<br /> ...<br /> _:x <i>owl:imports</i> importedOntologyIRI<sub>k</sub> .<br /> TANN(annotation<sub>1</sub>, _:x) .<br /> ...<br /> TANN(annotation<sub>m</sub>, _:x) .<br /> T(axiom<sub>1</sub>) .<br /> ...<br /> T(axiom<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> C
</td><td>
</td><td> C
</td></tr>
<tr>
<td> DT
</td><td>
</td><td> DT
</td></tr>
<tr>
<td> OP
</td><td>
</td><td> OP
</td></tr>
<tr>
<td> DP
</td><td>
</td><td> DP
</td></tr>
<tr>
<td> AP
</td><td>
</td><td> AP
</td></tr>
<tr>
<td> U
</td><td>
</td><td> U
</td></tr>
<tr>
<td> a
</td><td>
</td><td> a
</td></tr>
<tr>
<td> "abc@"^^<i>rdf:PlainLiteral</i>
</td><td>
</td><td> "abc"
</td></tr>
<tr>
<td> "abc@langTag"^^<i>rdf:PlainLiteral</i>
</td><td>
</td><td> "abc"@langTag
</td></tr>
<tr>
<td> lt<br />  { where lt is a literal of datatype<br /> &nbsp; other than <i>rdf:PlainLiteral</i> }
</td><td>
</td><td> lt
</td></tr>
<tr>
<td> <span id="a_DeclarationDatatype"> </span> Declaration( Datatype( DT ) )
</td><td> T(DT) <i>rdf:type</i> <i>rdfs:Datatype</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DeclarationClass"> </span> Declaration( Class( C ) )
</td><td> T(C) <i>rdf:type</i> <i>owl:Class</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DeclarationObjectProperty"> </span> Declaration( ObjectProperty( OP ) )
</td><td> T(OP) <i>rdf:type</i> <i>owl:ObjectProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DeclarationDataProperty"> </span> Declaration( DataProperty( DP ) )
</td><td> T(DP) <i>rdf:type</i> <i>owl:DatatypeProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DeclarationAnnotationProperty"> </span> Declaration( AnnotationProperty( AP ) )
</td><td> T(AP) <i>rdf:type</i> <i>owl:AnnotationProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_NamedIndividual"> </span> Declaration( NamedIndividual( *:a ) )
</td><td> T(*:a) <i>rdf:type</i> <i>owl:NamedIndividual</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ObjectInverseOf"> </span> ObjectInverseOf( OP )
</td><td> _:x <i>owl:inverseOf</i> T(OP) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataIntersectionOf"> </span> DataIntersectionOf( DR<sub>1</sub> ... DR<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ DR<sub>1</sub> ... DR<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataUnionOf"> </span> DataUnionOf( DR<sub>1</sub> ... DR<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ DR<sub>1</sub> ... DR<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataComplementOf"> </span> DataComplementOf( DR )
</td><td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:datatypeComplementOf</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataOneOf"> </span> DataOneOf( lt<sub>1</sub> ... lt<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ lt<sub>1</sub> ... lt<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DatatypeRestriction"> </span> DatatypeRestriction( DT<br /> &nbsp;&nbsp;&nbsp; F<sub>1</sub> lt<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; F<sub>n</sub> lt<sub>n</sub><br />)
</td><td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:onDatatype</i> T(DT) .<br /> _:x <i>owl:withRestrictions</i> T(SEQ _:y<sub>1</sub> ... _:y<sub>n</sub>) .<br /> _:y<sub>1</sub> F<sub>1</sub> lt<sub>1</sub> .<br /> ...<br /> _:y<sub>n</sub> F<sub>n</sub> lt<sub>n</sub> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectIntersectionOf"> </span> ObjectIntersectionOf( CE<sub>1</sub> ... CE<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ CE<sub>1</sub> ... CE<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectUnionOf"> </span> ObjectUnionOf( CE<sub>1</sub> ... CE<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ CE<sub>1</sub> ... CE<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectComplementOf"> </span> ObjectComplementOf( CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectOneOf"> </span> ObjectOneOf( a<sub>1</sub> ... a<sub>n</sub> )
</td><td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ a<sub>1</sub> ... a<sub>n</sub>) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectSomeValuesFrom"> </span> ObjectSomeValuesFrom( OPE CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:someValuesFrom</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectAllValuesFrom"> </span> ObjectAllValuesFrom( OPE CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:allValuesFrom</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectHasValue"> </span> ObjectHasValue( OPE a )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:hasValue</i> T(a) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectHasSelf"> </span> ObjectHasSelf( OPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:hasSelf</i> "true"^^<i>xsd:boolean</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectMinCardinality"> </span> ObjectMinCardinality( n OPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:minCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectMinCardinalityQualified"> </span> ObjectMinCardinality( n OPE CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:minQualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onClass</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectMaxCardinality"> </span> ObjectMaxCardinality( n OPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:maxCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectMaxCardinalityQualified"> </span> ObjectMaxCardinality( n OPE CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:maxQualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onClass</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectExactCardinality"> </span> ObjectExactCardinality( n OPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:cardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_ObjectExactCardinalityQualified"> </span> ObjectExactCardinality( n OPE CE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(OPE) .<br /> _:x <i>owl:qualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onClass</i> T(CE) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataSomeValuesFrom"> </span> DataSomeValuesFrom( DPE DR )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:someValuesFrom</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataSomeValuesFromNary"> </span> DataSomeValuesFrom( DPE<sub>1</sub> ... DPE<sub>n</sub> DR ), n &ge; 2
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperties</i> T(SEQ DPE<sub>1</sub> ... DPE<sub>n</sub>) .<br /> _:x <i>owl:someValuesFrom</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataAllValuesFrom"> </span> DataAllValuesFrom( DPE DR )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:allValuesFrom</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataAllValuesFromNary"> </span> DataAllValuesFrom( DPE<sub>1</sub> ... DPE<sub>n</sub> DR ), n &ge; 2
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperties</i> T(SEQ DPE<sub>1</sub> ... DPE<sub>n</sub>) .<br /> _:x <i>owl:allValuesFrom</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataHasValue"> </span> DataHasValue( DPE lt )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:hasValue</i> T(lt) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataMinCardinality"> </span> DataMinCardinality( n DPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:minCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataMinCardinalityQualified"> </span> DataMinCardinality( n DPE DR )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:minQualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onDataRange</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataMaxCardinality"> </span> DataMaxCardinality( n DPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:maxCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataMaxCardinalityQualified"> </span> DataMaxCardinality( n DPE DR )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:maxQualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onDataRange</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataExactCardinality"> </span> DataExactCardinality( n DPE )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:cardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_DataExactCardinalityQualified"> </span> DataExactCardinality( n DPE DR )
</td><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> T(DPE) .<br /> _:x <i>owl:qualifiedCardinality</i> "n"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onDataRange</i> T(DR) .
</td><td> _:x
</td></tr>
<tr>
<td> <span id="a_SubClassOf"> </span> SubClassOf( CE<sub>1</sub> CE<sub>2</sub> )
</td><td> T(CE<sub>1</sub>) <i>rdfs:subClassOf</i> T(CE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_EquivalentClasses"> </span> EquivalentClasses( CE<sub>1</sub> ... CE<sub>n</sub> )
</td><td> T(CE<sub>1</sub>) <i>owl:equivalentClass</i> T(CE<sub>2</sub>) .<br /> ...<br /> T(CE<sub>n-1</sub>) <i>owl:equivalentClass</i> T(CE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointClasses"> </span> DisjointClasses( CE<sub>1</sub> CE<sub>2</sub> )
</td><td> T(CE<sub>1</sub>) <i>owl:disjointWith</i> T(CE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointClassesNary"> </span> DisjointClasses( CE<sub>1</sub> ... CE<sub>n</sub> ), n &gt; 2
</td><td> _:x <i>rdf:type</i> <i>owl:AllDisjointClasses</i> .<br /> _:x <i>owl:members</i> T(SEQ CE<sub>1</sub> ... CE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointUnion"> </span> DisjointUnion( C CE<sub>1</sub> ... CE<sub>n</sub> )
</td><td> T(C) <i>owl:disjointUnionOf</i> T(SEQ CE<sub>1</sub> ... CE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SubObjectPropertyOf"> </span> SubObjectPropertyOf( OPE<sub>1</sub> OPE<sub>2</sub> )
</td><td> T(OPE<sub>1</sub>) <i>rdfs:subPropertyOf</i> T(OPE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SubObjectPropertyOfChain"> </span> SubObjectPropertyOf( ObjectPropertyChain( OPE<sub>1</sub> ... OPE<sub>n</sub> ) OPE )
</td><td> T(OPE) <i>owl:propertyChainAxiom</i> T(SEQ OPE<sub>1</sub> ... OPE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_EquivalentObjectProperties"> </span> EquivalentObjectProperties( OPE<sub>1</sub> ... OPE<sub>n</sub> )
</td><td> T(OPE<sub>1</sub>) <i>owl:equivalentProperty</i> T(OPE<sub>2</sub>) .<br /> ...<br /> T(OPE<sub>n-1</sub>) <i>owl:equivalentProperty</i> T(OPE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointObjectProperties"> </span> DisjointObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )
</td><td> T(OPE<sub>1</sub>) <i>owl:propertyDisjointWith</i> T(OPE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointObjectPropertiesNary"> </span> DisjointObjectProperties( OPE<sub>1</sub> ... OPE<sub>n</sub> ), n &gt; 2
</td><td> _:x <i>rdf:type</i> <i>owl:AllDisjointProperties</i> .<br /> _:x <i>owl:members</i> T(SEQ OPE<sub>1</sub> ... OPE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ObjectPropertyDomain"> </span> ObjectPropertyDomain( OPE CE )
</td><td> T(OPE) <i>rdfs:domain</i> T(CE) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ObjectPropertyRange"> </span> ObjectPropertyRange( OPE CE )
</td><td> T(OPE) <i>rdfs:range</i> T(CE) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_InverseObjectProperties"> </span> InverseObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )
</td><td> T(OPE<sub>1</sub>) <i>owl:inverseOf</i> T(OPE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_FunctionalObjectProperty"> </span> FunctionalObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_InverseFunctionalObjectProperty"> </span> InverseFunctionalObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ReflexiveObjectProperty"> </span> ReflexiveObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:ReflexiveProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_IrreflexiveObjectProperty"> </span> IrreflexiveObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:IrreflexiveProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SymmetricObjectProperty"> </span> SymmetricObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:SymmetricProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_AsymmetricObjectProperty"> </span> AsymmetricObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:AsymmetricProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_TransitiveObjectProperty"> </span> TransitiveObjectProperty( OPE )
</td><td> T(OPE) <i>rdf:type</i> <i>owl:TransitiveProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SubDataPropertyOf"> </span> SubDataPropertyOf( DPE<sub>1</sub> DPE<sub>2</sub> )
</td><td> T(DPE<sub>1</sub>) <i>rdfs:subPropertyOf</i> T(DPE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_EquivalentDataProperties"> </span> EquivalentDataProperties( DPE<sub>1</sub> ... DPE<sub>n</sub> )
</td><td> T(DPE<sub>1</sub>) <i>owl:equivalentProperty</i> T(DPE<sub>2</sub>) .<br /> ...<br /> T(DPE<sub>n-1</sub>) <i>owl:equivalentProperty</i> T(DPE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointDataProperties"> </span> DisjointDataProperties( DPE<sub>1</sub> DPE<sub>2</sub> )
</td><td> T(DPE<sub>1</sub>) <i>owl:propertyDisjointWith</i> T(DPE<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DisjointDataPropertiesNary"> </span> DisjointDataProperties( DPE<sub>1</sub> ... DPE<sub>n</sub> ), n &gt; 2
</td><td> _:x <i>rdf:type</i> <i>owl:AllDisjointProperties</i> .<br /> _:x <i>owl:members</i> T(SEQ DPE<sub>1</sub> ... DPE<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DataPropertyDomain"> </span> DataPropertyDomain( DPE CE )
</td><td> T(DPE) <i>rdfs:domain</i> T(CE) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DataPropertyRange"> </span> DataPropertyRange( DPE DR )
</td><td> T(DPE) <i>rdfs:range</i> T(DR) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_FunctionalDataProperty"> </span> FunctionalDataProperty( DPE )
</td><td> T(DPE) <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DatatypeDefinition"> </span> DatatypeDefinition( DT DR )
</td><td> T(DT) <i>owl:equivalentClass</i> T(DR) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_HasKey"> </span> HasKey( CE ( OPE<sub>1</sub> ... OPE<sub>m</sub> ) ( DPE<sub>1</sub> ... DPE<sub>n</sub> ) )
</td><td> T(CE) <i>owl:hasKey</i> T(SEQ OPE<sub>1</sub> ... OPE<sub>m</sub> DPE<sub>1</sub> ... DPE<sub>n</sub> ) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SameIndividual"> </span> SameIndividual( a<sub>1</sub> ... a<sub>n</sub> )
</td><td> T(a<sub>1</sub>) <i>owl:sameAs</i> T(a<sub>2</sub>) .<br /> ...<br /> T(a<sub>n-1</sub>) <i>owl:sameAs</i> T(a<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DifferentIndividuals"> </span> DifferentIndividuals( a<sub>1</sub> a<sub>2</sub> )
</td><td> T(a<sub>1</sub>) <i>owl:differentFrom</i> T(a<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DifferentIndividualsNary"> </span> DifferentIndividuals( a<sub>1</sub> ... a<sub>n</sub> ), n &gt; 2
</td><td> _:x <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:x <i>owl:members</i> T(SEQ a<sub>1</sub> ... a<sub>n</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ClassAssertion"> </span> ClassAssertion( CE a )
</td><td> T(a) <i>rdf:type</i> T(CE) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ObjectPropertyAssertion"> </span> ObjectPropertyAssertion( OP a<sub>1</sub> a<sub>2</sub> )
</td><td> T(a<sub>1</sub>) T(OP) T(a<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_ObjectPropertyAssertionInverseOf"> </span> ObjectPropertyAssertion( ObjectInverseOf( OP ) a<sub>1</sub> a<sub>2</sub> )
</td><td> T(a<sub>2</sub>) T(OP) T(a<sub>1</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_NegativeObjectPropertyAssertion"> </span> NegativeObjectPropertyAssertion( OPE a<sub>1</sub> a<sub>2</sub> )
</td><td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> T(a<sub>1</sub>) .<br /> _:x <i>owl:assertionProperty</i> T(OPE) .<br /> _:x <i>owl:targetIndividual</i> T(a<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_DataPropertyAssertion"> </span> DataPropertyAssertion( DPE a lt )
</td><td> T(a) T(DPE) T(lt) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_NegativeDataPropertyAssertion"> </span> NegativeDataPropertyAssertion( DPE a lt )
</td><td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> T(a) .<br /> _:x <i>owl:assertionProperty</i> T(DPE) .<br /> _:x <i>owl:targetValue</i> T(lt) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_AnnotationAssertion"> </span> AnnotationAssertion( AP as av )
</td><td> T(as) T(AP) T(av) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_SubAnnotationPropertyOf"> </span> SubAnnotationPropertyOf( AP<sub>1</sub> AP<sub>2</sub> )
</td><td> T(AP<sub>1</sub>) <i>rdfs:subPropertyOf</i> T(AP<sub>2</sub>) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_AnnotationPropertyDomain"> </span> AnnotationPropertyDomain( AP U )
</td><td> T(AP) <i>rdfs:domain</i> T(U) .
</td><td>
</td></tr>
<tr>
<td> <span id="a_AnnotationPropertyRange"> </span> AnnotationPropertyRange( AP U )
</td><td> T(AP) <i>rdfs:range</i> T(U) .
</td><td>
</td></tr>
</tbody></table>
</div>
<a id="Translation_of_Annotations" name="Translation_of_Annotations"></a><h3> <span class="mw-headline">2.2  Translation of Annotations </span></h3>
<p>The operator <i>TANN</i>, which translates annotations and attaches them to an IRI or a blank node, is defined in Table 2.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 2.</span> Translation of Annotations
</caption>
<tbody><tr>
<th> Annotation <i>ann</i>
</th><th> Triples Generated in an Invocation of <i>TANN(ann, y)</i>
</th></tr>
<tr>
<td class="name"> <span id="a_Annotation"> </span>Annotation( AP av )
</td><td class="name"> T(y) T(AP) T(av) .
</td></tr>
<tr>
<td class="name"> <span id="a_AnnotationWithAnnotation"> </span>Annotation(<br /> &nbsp;&nbsp;&nbsp; annotation<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; annotation<sub>n</sub><br /> &nbsp;&nbsp;&nbsp; AP av<br /> )
</td><td class="name"> T(y) T(AP) T(av) .<br /> _:x <i>rdf:type</i> <i>owl:Annotation</i> .<br /> _:x <i>owl:annotatedSource</i> T(y) .<br /> _:x <i>owl:annotatedProperty</i> T(AP) .<br /> _:x <i>owl:annotatedTarget</i> T(av) .<br /> TANN(annotation<sub>1</sub>, _:x)<br /> ...<br />TANN(annotation<sub>n</sub>, _:x)
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>Let <i>ann</i> be the following annotation.
</p>
<div class="fss">
<p>Annotation( <i>rdfs:label</i> "Peter Griffin" )
</p>
</div>
<p>An invocation of <i>TANN(ann, a:Peter)</i> then produces the following triples.
</p>
<div class="rdf">
<p><i>a:Peter</i> <i>rdfs:label</i> "Peter Griffin" .
</p>
</div>
</div>
<div class="anexample">
<p>Let <i>ann</i> be the following annotation, which is itself annotated.
</p>
<div class="fss">
<p>Annotation( Annotation( <i>a:author</i> <i>a:Seth_MacFarlane</i> )<br /> &nbsp;&nbsp;&nbsp; <i>rdfs:label</i> "Peter Griffin" )
</p>
</div>
<p>An invocation of <i>TANN(ann, a:Peter)</i> then produces the following triples:
</p>
<div class="rdf">
<p><i>a:Peter</i> <i>rdfs:label</i> "Peter Griffin" .<br />
_:x <i>rdf:type</i> <i>owl:Annotation</i> .<br />
_:x <i>owl:annotatedSource</i> <i>a:Peter</i> .<br />
_:x <i>owl:annotatedProperty</i> <i>rdfs:label</i> .<br />
_:x <i>owl:annotatedTarget</i> "Peter Griffin" .<br />
_:x <i>a:author</i> <i>a:Seth_MacFarlane</i> .
</p>
</div>
</div>
<a id="Translation_of_Axioms_with_Annotations" name="Translation_of_Axioms_with_Annotations"></a><h3> <span class="mw-headline">2.3  Translation of Axioms with Annotations </span></h3>
<p>If an axiom <i>ax</i> contains embedded annotations <span class="name">annotation<sub>1</sub> ... annotation<sub>m</sub></span>, its serialization into RDF depends on the type of the axiom. Let <i>ax'</i> be the axiom that is obtained from <i>ax</i> by removing all axiom annotations.
</p>
<a id="Axioms_that_Generate_a_Main_Triple" name="Axioms_that_Generate_a_Main_Triple"></a><h4> <span class="mw-headline">2.3.1  Axioms that Generate a Main Triple </span></h4>
<p><span id="a_AxiomAnnotationMainTriple"> </span>If the row of Table 1 corresponding to the type of <i>ax'</i> contains a single <i>main</i> triple <span class="name">s p xlt .</span>, then the axiom <i>ax</i> is translated into the following triples:
</p>
<div class="rdf">
<p>s p xlt .<br />
_:x <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x <i>owl:annotatedSource</i> s .<br />
_:x <i>owl:annotatedProperty</i> p .<br />
_:x <i>owl:annotatedTarget</i> xlt .<br />
TANN(annotation<sub>1</sub>, _:x)<br />
...<br />
TANN(annotation<sub>m</sub>, _:x)
</p>
</div>
<p>This is the case if <i>ax'</i> is of type <span class="nonterminal">SubClassOf</span>, <span class="nonterminal">DisjointClasses</span> with two classes, <span class="nonterminal">SubObjectPropertyOf</span> without a property chain as the subproperty expression, <span class="nonterminal">SubDataPropertyOf</span>, <span class="nonterminal">ObjectPropertyDomain</span>, <span class="nonterminal">DataPropertyDomain</span>, <span class="nonterminal">ObjectPropertyRange</span>, <span class="nonterminal">DataPropertyRange</span>, <span class="nonterminal">InverseObjectProperties</span>, <span class="nonterminal">FunctionalObjectProperty</span>, <span class="nonterminal">FunctionalDataProperty</span>, <span class="nonterminal">InverseFunctionalObjectProperty</span>, <span class="nonterminal">ReflexiveObjectProperty</span>, <span class="nonterminal">IrreflexiveObjectProperty</span>, <span class="nonterminal">SymmetricObjectProperty</span>, <span class="nonterminal">AsymmetricObjectProperty</span>, <span class="nonterminal">TransitiveObjectProperty</span>, <span class="nonterminal">DisjointObjectProperties</span> with two properties, <span class="nonterminal">DisjointDataProperties</span> with two properties, <span class="nonterminal">ClassAssertion</span>, <span class="nonterminal">ObjectPropertyAssertion</span>, <span class="nonterminal">DataPropertyAssertion</span>, <span class="nonterminal">Declaration</span>, <span class="nonterminal">DifferentIndividuals</span> with two individuals, or <span class="nonterminal">AnnotationAssertion</span>.
</p>
<div class="anexample">
<p>Consider the following subclass axiom:
</p>
<div class="fss">
<p>SubClassOf( Annotation( <i>rdfs:comment</i> "Children are people." ) <i>a:Child</i> <i>a:Person</i> )
</p>
</div>
<p>Without the annotation, the axiom would be translated into the following triple:
</p>
<div class="rdf">
<p><i>a:Child</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
</p>
</div>
<p>Thus, the annotated axiom is transformed into the following triples:
</p>
<div class="rdf">
<p><i>a:Child</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .<br />
_:x <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x <i>owl:annotatedSource</i> <i>a:Child</i> .<br />
_:x <i>owl:annotatedProperty</i> <i>rdfs:subClassOf</i> .<br />
_:x <i>owl:annotatedTarget</i> <i>a:Person</i> .<br />
_:x <i>rdfs:comment</i> "Children are people." .
</p>
</div>
</div>
<p>For <i>ax'</i> of type <span class="nonterminal">DisjointUnion</span>, <span class="nonterminal">SubObjectPropertyOf</span> with a subproperty chain, or <span class="nonterminal">HasKey</span>, the first triple from the corresponding row of Table 1 is the <i>main</i> triple and it is subjected to the transformation described above; the other triples from the corresponding row of Table 1 &mdash; called <i>side</i> triples &mdash; are output without any change.
</p>
<div class="anexample">
<p>Consider the following subproperty axiom:
</p>
<div class="fss">
<p>SubObjectPropertyOf( Annotation( <i>rdfs:comment</i> "An aunt is a mother's sister." ) ObjectPropertyChain( <i>a:hasMother</i> <i>a:hasSister</i> ) <i>a:hasAunt</i> ) )
</p>
</div>
<p>Without the annotation, the axiom would be translated into the following triples:
</p>
<div class="rdf">
<p><i>a:hasAunt</i> <i>owl:propertyChainAxiom</i> _:y<sub>1</sub>.<br />
_:y<sub>1</sub> <i>rdf:first</i> <i>a:hasMother</i> .<br />
_:y<sub>1</sub> <i>rdf:rest</i> _:y<sub>2</sub> .<br />
_:y<sub>2</sub> <i>rdf:first</i> <i>a:hasSister</i> .<br />
_:y<sub>2</sub> <i>rdf:rest</i> <i>rdf:nil</i> .
</p>
</div>
<p>In order to capture the annotation on the axiom, the first triple plays the role of the main triple for the axiom, so it is represented using a fresh blank node <span class="name">_:x</span> in order to be able to attach the annotation to it. The original triple is output alongside all other triples as well.
</p>
<div class="rdf">
<p>_:x <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x <i>owl:annotatedSource</i> <i>a:hasAunt</i> .<br />
_:x <i>owl:annotatedProperty</i> <i>owl:propertyChainAxiom</i> .<br />
_:x <i>owl:annotatedTarget</i> _:y<sub>1</sub> .<br />
_:x <i>rdfs:comment</i> "An aunt is a mother's sister." .<br />
<br />
<i>a:hasAunt</i> <i>owl:propertyChainAxiom</i> _:y<sub>1</sub>.<br />
_:y<sub>1</sub> <i>rdf:first</i> <i>a:hasMother</i> .<br />
_:y<sub>1</sub> <i>rdf:rest</i> _:y<sub>2</sub> .<br />
_:y<sub>2</sub> <i>rdf:first</i> <i>a:hasSister</i> .<br />
_:y<sub>2</sub> <i>rdf:rest</i> <i>rdf:nil</i> .
</p>
</div>
</div>
<div class="anexample">
<p>Consider the following key axiom:
</p>
<div class="fss">
<p>HasKey( Annotation( <i>rdfs:comment</i> "SSN uniquely determines a person." ) <i>a:Person</i> () ( <i>a:hasSSN</i> ) )
</p>
</div>
<p>Without the annotation, the axiom would be translated into the following triples:
</p>
<div class="rdf">
<p><i>a:Person</i> <i>owl:hasKey</i> _:y .<br />
_:y <i>rdf:first</i> <i>a:hasSSN</i> .<br />
_:y <i>rdf:rest</i> <i>rdf:nil</i> .
</p>
</div>
<p>In order to capture the annotation on the axiom, the first triple plays the role of the main triple for the axiom, so it is represented using a fresh blank node <span class="name">_:x</span> in order to be able to attach the annotation to it.
</p>
<div class="rdf">
<p>_:x <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x <i>owl:annotatedSource</i> <i>a:Person</i> .<br />
_:x <i>owl:annotatedProperty</i> <i>owl:hasKey</i> .<br />
_:x <i>owl:annotatedTarget</i> _:y .<br />
_:x <i>rdfs:comment</i> "SSN uniquely determines a person." .<br />
<br />
<i>a:Person</i> <i>owl:hasKey</i> _:y .<br />
_:y <i>rdf:first</i> <i>a:hasSSN</i> .<br />
_:y <i>rdf:rest</i> <i>rdf:nil</i> .
</p>
</div>
</div>
<a id="Axioms_that_are_Translated_to_Multiple_Triples" name="Axioms_that_are_Translated_to_Multiple_Triples"></a><h4> <span class="mw-headline">2.3.2  Axioms that are Translated to Multiple Triples </span></h4>
<p><span id="a_AxiomAnnotationMultipleTriple"> </span>If the axiom <i>ax'</i> is of type <span class="nonterminal">EquivalentClasses</span>, <span class="nonterminal">EquivalentObjectProperties</span>, <span class="nonterminal">EquivalentDataProperties</span>, or <span class="nonterminal">SameIndividual</span>, its translation into RDF can be broken up into several RDF triples (because RDF can only represent binary relations). In this case, each of the RDF triples obtained by the translation of <i>ax'</i> is transformed as described in previous section, and the annotations are repeated for each of the triples obtained in the translation.
</p>
<div class="anexample">
<p>Consider the following individual equality axiom:
</p>
<div class="fss">
<p>SameIndividual( Annotation( <i>a:source</i> <i>a:Fox</i> ) <i>a:Meg</i> <i>a:Megan</i> <i>a:Megan_Griffin</i> )
</p>
</div>
<p>This axiom is first split into the following equalities between pairs of individuals, and the annotation is repeated on each axiom obtained in this process:
</p>
<div class="fss">
<p>SameIndividual( Annotation( <i>a:source</i> <i>a:Fox</i> ) <i>a:Meg</i> <i>a:Megan</i> )<br />
SameIndividual( Annotation( <i>a:source</i> <i>a:Fox</i> ) <i>a:Megan</i> <i>a:Megan_Griffin</i> )
</p>
</div>
<p>Each of these axioms is now transformed into triples as explained in the previous section:
</p>
<div class="rdf">
<p><i>a:Meg</i> <i>owl:sameAs</i> <i>a:Megan</i> .<br />
_:x<sub>1</sub> <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x<sub>1</sub> <i>owl:annotatedSource</i> <i>a:Meg</i> .<br />
_:x<sub>1</sub> <i>owl:annotatedProperty</i> <i>owl:sameAs</i> .<br />
_:x<sub>1</sub> <i>owl:annotatedTarget</i> <i>a:Megan</i> .<br />
_:x<sub>1</sub> <i>a:source</i> <i>a:Fox</i> .<br />
<br />
<i>a:Megan</i> <i>owl:sameAs</i> <i>a:Megan_Griffin</i> .<br />
_:x<sub>2</sub> <i>rdf:type</i> <i>owl:Axiom</i> .<br />
_:x<sub>2</sub> <i>owl:annotatedSource</i> <i>a:Megan</i> .<br />
_:x<sub>2</sub> <i>owl:annotatedProperty</i> <i>owl:sameAs</i> .<br />
_:x<sub>2</sub> <i>owl:annotatedTarget</i> <i>a:Megan_Griffin</i> .<br />
_:x<sub>2</sub> <i>a:source</i> <i>a:Fox</i> .
</p>
</div>
</div>
<a id="Axioms_Represented_by_Blank_Nodes" name="Axioms_Represented_by_Blank_Nodes"></a><h4> <span class="mw-headline">2.3.3  Axioms Represented by Blank Nodes </span></h4>
<p><span id="a_AxiomAnnotationBlankNode"> </span>If the axiom <i>ax'</i> is of type <span class="nonterminal">NegativeObjectPropertyAssertion</span>, <span class="nonterminal">NegativeDataPropertyAssertion</span>, <span class="nonterminal">DisjointClasses</span> with more than two classes, <span class="nonterminal">DisjointObjectProperties</span> with more than two properties, <span class="nonterminal">DisjointDataProperties</span> with more than two properties, or <span class="nonterminal">DifferentIndividuals</span> with more than two individuals, then its translation already requires introducing a blank node <span class="name">_:x</span>. In such cases, <i>ax</i> is translated by first translating <i>ax'</i> into <span class="name">_:x</span> as shown in Table 1, and then attaching the annotations of <i>ax</i> to <span class="name">_:x</span>.
</p>
<div class="anexample">
<p>Consider the following negative object property assertion:
</p>
<div class="fss">
<p>NegativeObjectPropertyAssertion( Annotation( <i>a:author</i> <i>a:Seth_MacFarlane</i> ) <i>a:brotherOf</i> <i>a:Chris</i> <i>a:Stewie</i> )
</p>
</div>
<p>Even without the annotation, this axiom would be represented using a blank node. The annotation can readily be attached to this node, so the axiom is transformed into the following triples:
</p>
<div class="rdf">
<p>_:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br />
_:x <i>owl:sourceIndividual</i> <i>a:Chris</i> .<br />
_:x <i>owl:assertionProperty</i> <i>a:brotherOf</i> .<br />
_:x <i>owl:targetIndividual</i> <i>a:Stewie</i> .<br />
_:x <i>a:author</i> <i>a:Seth_MacFarlane</i> .
</p>
</div>
</div>
<a id="Mapping_from_RDF_Graphs_to_the_Structural_Specification" name="Mapping_from_RDF_Graphs_to_the_Structural_Specification"></a><h2> <span class="mw-headline">3  Mapping from RDF Graphs to the Structural Specification </span></h2>
<p>This section specifies the results of steps CP&nbsp;2.2 and CP&nbsp;3.3 of the canonical parsing process from Section 3.6 of the OWL 2 Specification [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>] on an ontology document <i>D</i> that can be parsed into an RDF graph <i>G</i>. An OWL 2 tool <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> implement these steps in any way it chooses; however, the results <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be structurally equivalent to the ones defined in the following sections. These steps do not depend on the RDF syntax used to encode the RDF graph in <i>D</i>; therefore, the ontology document <i>D</i> is identified in this section with the corresponding RDF graph <i>G</i>.
</p><p>An <i>RDF syntax ontology document</i> is any document accessible from some given IRI that can be parsed into an RDF graph, and that then be transformed into an OWL 2 ontology by the canonical parsing process instantiated as specified in this section.
</p><p>The following sections contain rules in which triple patterns are matched to <i>G</i>. Note that if a triple pattern contains a variable number of triples, the maximal possible subset of <i>G</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be matched. 
</p><p>The following notation is used in the patterns:
</p>
<ul><li> The notation <span class="name">NN_INT(n)</span> can be matched to any literal whose value <span class="name">n</span> is a nonnegative integer.
</li><li> Possible conditions on the pattern are enclosed in curly braces '{ }'.
</li><li> Some patterns use optional parts, which are enclosed in square brackets '[ ]'.
</li><li> The abbreviation <span class="name">T(SEQ y<sub>1</sub> ... y<sub>n</sub>)</span> denotes the pattern corresponding to RDF lists, as shown in Table 3. When a list pattern is matched to <i>G</i>, all list variables <span class="name">_:x<sub>i</sub></span> and <span class="name">_:x<sub>j</sub></span> with <span class="name">i &ne; j</span> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be matched to different nodes; furthermore, it <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be possible to match the list pattern to two maximal subsets of <i>G</i> such that some list variable in the first pattern instance is matched to the same node as some (possibly different) variable in the second pattern instance. This is necessary in order to detect malformed lists such as lists with internal cycles, lists that share tails, and lists that cross.
</li></ul>
<div class="center">
<table border="2" cellpadding="5" class="allname">
<caption> <span class="caption">Table 3.</span> Patterns Corresponding to RDF Lists
</caption>
<tbody><tr>
<th> Sequence <i>S</i>
</th><th> Triples Corresponding to <i>T(S)</i>
</th><th> Main Node of <i>T(S)</i>
</th></tr>
<tr>
<td class="name"> SEQ
</td><td>
</td><td class="name"> <i>rdf:nil</i>
</td></tr>
<tr>
<td class="name"> SEQ y
</td><td> _:x <i>rdf:first</i> y .<br /> _:x <i>rdf:rest</i> <i>rdf:nil</i> .
</td><td class="name"> _:x
</td></tr>
<tr>
<td class="name"> SEQ y<sub>1</sub> ... y<sub>n</sub><br /> { n&gt;1 }
</td><td class="name"> _:x<sub>1</sub> <i>rdf:first</i> y<sub>1</sub> .<br /> _:x<sub>1</sub> <i>rdf:rest</i> _:x<sub>2</sub> .<br /> ... <br /> _:x<sub>n</sub> <i>rdf:first</i> y<sub>n</sub> .<br /> _:x<sub>n</sub> <i>rdf:rest</i> <i>rdf:nil</i> .
</td><td class="name"> _:x<sub>1</sub>
</td></tr>
</tbody></table>
</div>
<a id="Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents" name="Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents"></a><h3> <span class="mw-headline">3.1  Extracting Declarations and the IRIs of the Directly Imported Ontology Documents </span></h3>
<p>This section specifies the result of step CP&nbsp;2.2 of the canonical parsing process on an RDF graph <i>G</i>.
</p>
<a id="Resolving_Included_RDF_Graphs" name="Resolving_Included_RDF_Graphs"></a><h4> <span class="mw-headline">3.1.1  Resolving Included RDF Graphs </span></h4>
<p>For backwards compatibility with OWL 1 DL, if <i>G</i> contains an <i>owl:imports</i> triple pointing to an RDF document encoding an RDF graph <i>G'</i> where <i>G'</i> does not have an ontology header, this <i>owl:imports</i> triple is interpreted as an <i>include</i> rather than an import &mdash; that is, the triples of <i>G'</i> are included into <i>G</i> and are not parsed into a separate ontology. To achieve this, the following transformation is applied to <i>G</i> as long as the following rule is applicable to <i>G</i>.
</p>
<div class="indent">
<p>If <i>G</i> contains a pair of triples of the form
</p>
<div class="rdf">
<p>x <i>rdf:type</i> <i>owl:Ontology</i> .<br />
x <i>owl:imports</i> *:y .
</p>
</div>
<p>and the values for <span class="name">x</span> and <span class="name">*:y</span> have not already been considered, the following actions are performed:
</p>
<ol><li> The document accessible from the IRI <span class="name">*:y</span> is retrieved using the augmented retrieval process from Section 3.2 of the OWL 2 Specification [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>].
</li><li> The document is parsed into an RDF graph <i>G'</i>.
</li><li> If the parsing succeeds and the graph <i>G'</i> does not contain a triple of the form <div class="rdf">z <i>rdf:type</i> <i>owl:Ontology</i>. </div> then <i>G'</i> is merged (as in the RDF Semantics [<cite><a href="#ref-rdf-semantics" title="">RDF Semantics</a></cite>]) into <i>G</i> and the triple <div class="rdf">x <i>owl:imports</i> *:y .</div> is removed from <i>G</i>.
</li></ol>
</div>
<a id="Parsing_of_the_Ontology_Header_and_Declarations" name="Parsing_of_the_Ontology_Header_and_Declarations"></a><h4> <span class="mw-headline">3.1.2  Parsing of the Ontology Header and Declarations </span></h4>
<p>Next, the ontology header is extracted from <i>G</i> by matching patterns from Table 4 to <i>G</i>. It <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be possible to match exactly one such pattern to <i>G</i> in exactly one way. The matched triples are removed from <i>G</i>. The set <i>Imp(G)</i> of the IRIs of ontology documents that are directly imported into <i>G</i> contains exactly all <span class="name">*:z<sub>1</sub>, ..., *:z<sub>k</sub></span> that are matched in the pattern.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 4.</span> Parsing of the Ontology Header
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then the ontology header has this form.
</th></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:Ontology</i> .<br /> [ *:x <i>owl:versionIRI</i> *:y  .]<br /> *:x <i>owl:imports</i> *:z<sub>1</sub> .<br /> ...<br /> *:x <i>owl:imports</i> *:z<sub>k</sub> .<br /> { k &ge; 0 and<br /> &nbsp; the following triple pattern cannot be matched in <i>G</i>:<br /> &nbsp;&nbsp;&nbsp;&nbsp; u w *:x .<br /> &nbsp;&nbsp;&nbsp;&nbsp; u <i>rdf:type</i> <i>owl:Ontology</i> .<br /> &nbsp;&nbsp;&nbsp;&nbsp; w <i>rdf:type</i> <i>owl:OntologyProperty</i> .<br /> }
</td><td> Ontology( *:x [ *:y ]<br /> &nbsp;&nbsp;&nbsp; Import( *:z<sub>1</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; Import( *:z<sub>k</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Ontology</i> .<br /> _:x <i>owl:imports</i> *:z<sub>1</sub> .<br /> ...<br /> _:x <i>owl:imports</i> *:z<sub>k</sub> .<br /> { k &ge; 0 and <br /> &nbsp; the following triple pattern cannot be matched in <i>G</i>:<br /> &nbsp;&nbsp;&nbsp;&nbsp; u w _:x .<br /> &nbsp;&nbsp;&nbsp;&nbsp; u <i>rdf:type</i> <i>owl:Ontology</i> .<br /> &nbsp;&nbsp;&nbsp;&nbsp; w <i>rdf:type</i> <i>owl:OntologyProperty</i> .<br /> }
</td><td> Ontology(<br /> &nbsp;&nbsp;&nbsp; Import( *:z<sub>1</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; Import( *:z<sub>k</sub> )<br /> &nbsp;&nbsp;&nbsp; ...<br /> )
</td></tr>
</tbody></table>
</div>
<p>Next, for backwards compatibility with OWL 1 DL, certain redundant triples are removed from <i>G</i>. In particular, if the triple pattern from the left-hand side of Table 5 is matched in <i>G</i>, then the triples on the right-hand side of Table 5 are removed from <i>G</i>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 5.</span> Triples to be Removed for Backwards Compatibility with OWL 1 DL
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then these triples are removed from <i>G</i>.
</th></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:Ontology</i> .
</td><td> x <i>rdf:type</i> <i>owl:Ontology</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:Class</i> .<br /> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td><td> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td><td> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:DataRange</i> .<br /> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td><td> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td><td> x <i>rdf:type</i> <i>rdfs:Class</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> x <i>rdf:type</i> <i>owl:Class</i> .
</td><td> x <i>rdf:type</i> <i>owl:Class</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:ObjectProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:FunctionalProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:TransitiveProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:DatatypeProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:AnnotationProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:OntologyProperty</i> .<br /> x <i>rdf:type</i> <i>rdf:Property</i> .
</td><td> x <i>rdf:type</i> <i>rdf:Property</i> .
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>rdf:List</i> .<br /> x <i>rdf:first</i> y .<br /> x <i>rdf:rest</i> z .
</td><td> x <i>rdf:type</i> <i>rdf:List</i> .
</td></tr>
</tbody></table>
</div>
<p>Next, for backwards compatibility with OWL 1 DL, <i>G</i> is modified such that declarations can be properly extracted in the next step. When a triple pattern from the first column of Table 6 is matched in <i>G</i>, the matching triples are <i>replaced in G</i> with the triples from the second column. This matching phase stops when matching a pattern and replacing it as specified does not change <i>G</i>. Note that <i>G</i> is a set and thus cannot contain duplicate triples, so this last condition prevents infinite matches.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 6.</span> Additional Declaration Triples
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then the matched triples are replaced in <i>G</i> with these triples.
</th></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:OntologyProperty</i> .
</td><td> *:x <i>rdf:type</i> <i>owl:AnnotationProperty</i> .
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .
</td><td> *:x <i>rdf:type</i> <i>owl:ObjectProperty</i> .<br /> *:x <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:TransitiveProperty</i> .
</td><td> *:x <i>rdf:type</i> <i>owl:ObjectProperty</i> .<br /> *:x <i>rdf:type</i> <i>owl:TransitiveProperty</i> .
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:SymmetricProperty</i> .
</td><td> *:x <i>rdf:type</i> <i>owl:ObjectProperty</i> .<br /> *:x <i>rdf:type</i> <i>owl:SymmetricProperty</i> .
</td></tr>
</tbody></table>
</div>
<p>Next, the set of declarations <i>Decl(G)</i> is extracted from <i>G</i> according to Table 7. The matched triples are not removed from <i>G</i> &mdash; the triples from Table 7 can contain annotations so, in order to correctly parse the annotations, they will be matched again in the step described in <a href="#Parsing_of_Axioms" title="">Section 3.2.5</a>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 7.</span> Parsing Declarations in <i>G</i>
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then this declaration is added to <i>Decl(G)</i>.
</th></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:Class</i> .
</td><td> Declaration( Class( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>rdfs:Datatype</i> .
</td><td> Declaration( Datatype( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:ObjectProperty</i> .
</td><td> Declaration( ObjectProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:DatatypeProperty</i> .
</td><td> Declaration( DataProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:AnnotationProperty</i> .
</td><td> Declaration( AnnotationProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:NamedIndividual</i> .
</td><td> Declaration( NamedIndividual( *:x ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>owl:Class</i> .
</td><td> Declaration( Class( *:y ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>rdfs:Datatype</i> .
</td><td> Declaration( Datatype( *:y ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>owl:ObjectProperty</i> .
</td><td> Declaration( ObjectProperty( *:y ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>owl:DatatypeProperty</i> .
</td><td> Declaration( DataProperty( *:y ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>owl:AnnotationProperty</i> .
</td><td> Declaration( AnnotationProperty( *:y ) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> *:y .<br /> _:x <i>owl:annotatedProperty</i> <i>rdf:type</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>owl:NamedIndividual</i> .
</td><td> Declaration( NamedIndividual( *:y ) )
</td></tr>
</tbody></table>
</div>
<p>Finally, the set <span class="name">RIND</span> of blank nodes used in reification is identified. This is done by initially setting <span class="name">RIND = &empty;</span> and then applying the patterns shown in Table 8. The matched triples are not deleted from <i>G</i>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 8.</span> Identifying Reification Blank Nodes
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern, then <span class="name">_:x</span> is added to <span class="name">RIND</span>.
</th></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Axiom</i> .
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Annotation</i> .
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDisjointClasses</i> .
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDisjointProperties</i> .
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDifferent</i> .
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .
</td></tr>
</tbody></table>
</div>
<a id="Populating_an_Ontology" name="Populating_an_Ontology"></a><h3> <span class="mw-headline">3.2  Populating an Ontology </span></h3>
<p>This section specifies the result of step CP&nbsp;3.3 of the canonical parsing process on an RDF graph <i>G</i>, the corresponding instance <i>O<sub>G</sub></i> of the <span class="nonterminal">Ontology</span> class, and the set <i>AllDecl(G)</i> of all declarations for <i>G</i> computed as specified in step CP&nbsp;3.1 of the canonical parsing process.
</p>
<a id="Analyzing_Declarations" name="Analyzing_Declarations"></a><h4> <span class="mw-headline">3.2.1  Analyzing Declarations </span></h4>
<p>The following functions map an IRI or a blank node <span class="name">x</span> occurring in <i>G</i> into an object of the structural specification. In particular,
</p>
<ul><li> <span class="name">CE(x)</span> maps <span class="name">x</span> into a class expression,
</li><li> <span class="name">DR(x)</span> maps <span class="name">x</span> into a data range,
</li><li> <span class="name">OPE(x)</span> maps <span class="name">x</span> into an object property expression,
</li><li> <span class="name">DPE(x)</span> maps <span class="name">x</span> into a data property expression, and
</li><li> <span class="name">AP(x)</span> maps <span class="name">x</span> into an annotation property.
</li></ul>
<p>Initially, these functions are undefined for all IRIs and blank nodes occurring in <i>G</i>; this is written as <span class="name">CE(x) = &epsilon;</span>, <span class="name">DR(x) = &epsilon;</span>, <span class="name">OPE(x) = &epsilon;</span>, <span class="name">DPE(x) = &epsilon;</span>, and <span class="name">AP(x) = &epsilon;</span>. The functions are updated as parsing progresses. All of the following conditions <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be satisfied at any given point in time during parsing.
</p>
<ul><li> For each <span class="name">x</span>, at most one of <span class="name">OPE(x)</span>, <span class="name">DPE(x)</span>, and <span class="name">AP(x)</span> is defined.
</li><li> For each <span class="name">x</span>, at most one of <span class="name">CE(x)</span> and <span class="name">DR(x)</span> is defined.
</li></ul>
<p>Furthermore, the value of any of these functions for any <span class="name">x</span> <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be redefined during parsing (i.e., if a function is not undefined for <span class="name">x</span>, no attempt should be made to change the function's value for <span class="name">x</span>).
</p><p>Functions <span class="name">CE</span>, <span class="name">DR</span>, <span class="name">OPE</span>, <span class="name">DPE</span>, and <span class="name">AP</span> are initialized as shown in Table 9.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 9.</span> Initialization of <span class="name">CE</span>, <span class="name">DR</span>, <span class="name">OPE</span>, <span class="name">DPE</span>, and <span class="name">AP</span>
</caption>
<tbody><tr>
<th> If <i>AllDecl(G)</i> contains this declaration...
</th><th> ...then perform this assignment.
</th></tr>
<tr>
<td> Declaration( Class( *:x ) )
</td><td> CE(*:x)&nbsp;:= <i>a class with the IRI *:x</i>
</td></tr>
<tr>
<td> Declaration( Datatype( *:x ) )
</td><td> DR(*:x)&nbsp;:= <i>a datatype with the IRI *:x</i>
</td></tr>
<tr>
<td> Declaration( ObjectProperty( *:x ) )
</td><td> OPE(*:x)&nbsp;:= <i>an object property with the IRI *:x</i>
</td></tr>
<tr>
<td> Declaration( DataProperty( *:x ) )
</td><td> DPE(*:x)&nbsp;:= <i>a data property with the IRI *:x</i>
</td></tr>
<tr>
<td> Declaration( AnnotationProperty( *:x ) )
</td><td> AP(*:x)&nbsp;:= <i>an annotation property with the IRI *:x</i>
</td></tr>
</tbody></table>
</div>
<a id="Parsing_of_Annotations" name="Parsing_of_Annotations"></a><h4> <span class="mw-headline">3.2.2  Parsing of Annotations </span></h4>
<p>The annotations in <i>G</i> are parsed next. The function <span class="name">ANN</span> assigns a set of annotations <span class="name">ANN(x)</span> to each IRI or blank node <span class="name">x</span>. This function is initialized by setting <span class="name">ANN(x)</span> = &empty; for each each IRI or blank node <span class="name">x</span>. Next, the triple patterns from Table 10 are matched in <i>G</i> and, for each matched pattern, <span class="name">ANN(x)</span> is extended with an annotation from the right column. Each time one of these triple patterns is matched, the matched triples are removed from <i>G</i>. This process is repeated until no further matches are possible.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 10.</span> Parsing of Annotations
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then this annotation is added to <i>ANN(x)</i>.
</th></tr>
<tr>
<td> x *:y xlt .<br />{ AP(*:y) &ne; &epsilon; and<br /> &nbsp; there is no blank node _:w such that <i>G</i> contains the following triples:<br /> &nbsp;&nbsp;&nbsp; _:w <i>rdf:type</i> <i>owl:Annotation</i> .<br /> &nbsp;&nbsp;&nbsp; _:w <i>owl:annotatedSource</i> x .<br /> &nbsp;&nbsp;&nbsp; _:w <i>owl:annotatedProperty</i> *:y .<br /> &nbsp;&nbsp;&nbsp; _:w <i>owl:annotatedTarget</i> xlt . }
</td><td> Annotation( *:y xlt )
</td></tr>
<tr>
<td> x *:y xlt .<br /> _:w <i>rdf:type</i> <i>owl:Annotation</i> .<br /> _:w <i>owl:annotatedSource</i> x .<br /> _:w <i>owl:annotatedProperty</i> *:y .<br /> _:w <i>owl:annotatedTarget</i> xlt .<br />{ AP(*:y) &ne; &epsilon; and<br /> &nbsp; no other triple in <i>G</i> contains _:w in subject or object position }
</td><td> Annotation( ANN(_:w) *:y xlt )
</td></tr>
</tbody></table>
</div>
<a id="Parsing_of_Ontology_Annotations" name="Parsing_of_Ontology_Annotations"></a><h4> <span class="mw-headline">3.2.3  Parsing of Ontology Annotations </span></h4>
<p>Let <span class="name">x</span> be the node that was matched in <i>G</i> to <span class="name">*:x</span> or <span class="name">_:x</span> according to the patterns from Table 4; then, <span class="name">ANN(x)</span> determines the set of ontology annotations of <i>O<sub>G</sub></i>.
</p>
<a id="Parsing_of_Expressions" name="Parsing_of_Expressions"></a><h4> <span class="mw-headline">3.2.4  Parsing of Expressions </span></h4>
<p>Next, functions <span class="name">OPE</span>, <span class="name">DR</span>, and <span class="name">CE</span> are extended as shown in Tables 11, 12, and 13, as well as in Tables 14 and 15. The patterns in the latter two tables are not generated by the mapping from <a href="#Mapping_from_the_Structural_Specification_to_RDF_Graphs" title="">Section 2</a>, but they can be present in RDF graphs that encode OWL 1 DL ontologies. Each time a pattern is matched, the matched triples are removed from <i>G</i>. Pattern matching is repeated until no triple pattern can be matched to <i>G</i>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 11.</span> Parsing Object Property Expressions
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then <i>OPE(_:x)</i> is set to this object property expression.
</th></tr>
<tr>
<td> _:x <i>owl:inverseOf</i> *:y .<br /> { OPE(_:x) = &epsilon; and OPE(*:y) &ne; &epsilon; }
</td><td> ObjectInverseOf( OPE(*:y) )
</td></tr>
</tbody></table>
</div>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 12.</span> Parsing of Data Ranges
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then <i>DR(_:x)</i> is set to this data range.
</th></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and DR(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DataIntersectionOf( DR(y<sub>1</sub>) ... DR(y<sub>n</sub>) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and DR(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DataUnionOf( DR(y<sub>1</sub>) ... DR(y<sub>n</sub>) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:datatypeComplementOf</i> y .<br /> { DR(y) &ne; &epsilon; }
</td><td> DataComplementOf( DR(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ lt<sub>1</sub> ... lt<sub>n</sub>) .<br /> { n &ge; 1 }
</td><td> DataOneOf( lt<sub>1</sub> ... lt<sub>n</sub> )
</td></tr>
<tr>
<td>_:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:onDatatype</i> *:y .<br /> _:x <i>owl:withRestrictions</i> T(SEQ _:z<sub>1</sub> ... _:z<sub>n</sub>) .<br /> _:z<sub>1</sub> *:w<sub>1</sub> lt<sub>1</sub> .<br /> ...<br /> _:z<sub>n</sub> *:w<sub>n</sub> lt<sub>n</sub> .<br /> { DR(*:y) is a datatype }
</td><td> DatatypeRestriction( DR(*:y)<br /> &nbsp;&nbsp;&nbsp; *:w<sub>1</sub> lt<sub>1</sub><br /> &nbsp;&nbsp;&nbsp; ...<br /> &nbsp;&nbsp;&nbsp; *:w<sub>n</sub> lt<sub>n</sub><br /> )
</td></tr>
</tbody></table>
</div>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 13.</span> Parsing of Class Expressions
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then <i>CE(_:x)</i> is set to this class expression.
</th></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> ObjectIntersectionOf( CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> ObjectUnionOf( CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> y .<br /> { CE(y) &ne; &epsilon; }
</td><td> ObjectComplementOf( CE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ *:y<sub>1</sub> ... *:y<sub>n</sub>) .<br /> { n &ge; 1 }
</td><td> ObjectOneOf( *:y<sub>1</sub> ... *:y<sub>n</sub> )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:someValuesFrom</i> z .<br /> { OPE(y) &ne; &epsilon; and CE(z) &ne; &epsilon; }
</td><td> ObjectSomeValuesFrom( OPE(y) CE(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:allValuesFrom</i> z .<br /> { OPE(y) &ne; &epsilon; and CE(z) &ne; &epsilon; }
</td><td> ObjectAllValuesFrom( OPE(y) CE(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:hasValue</i> *:z .<br /> { OPE(y) &ne; &epsilon; }
</td><td> ObjectHasValue( OPE(y) *:z )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br />  _:x <i>owl:hasSelf</i> "true"^^<i>xsd:boolean</i> .<br /> { OPE(y) &ne; &epsilon; }
</td><td> ObjectHasSelf( OPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minQualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x owl:onClass z .<br /> { OPE(y) &ne; &epsilon; and CE(z) &ne; &epsilon; }
</td><td> ObjectMinCardinality( n OPE(y) CE(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxQualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x owl:onClass z .<br /> { OPE(y) &ne; &epsilon; and CE(z) &ne; &epsilon; }
</td><td> ObjectMaxCardinality( n OPE(y) CE(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:qualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x owl:onClass z .<br /> { OPE(y) &ne; &epsilon; and CE(z) &ne; &epsilon; }
</td><td> ObjectExactCardinality( n OPE(y) CE(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { OPE(y) &ne; &epsilon; }
</td><td> ObjectMinCardinality( n OPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { OPE(y) &ne; &epsilon; }
</td><td> ObjectMaxCardinality( n OPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:cardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { OPE(y) &ne; &epsilon; }
</td><td> ObjectExactCardinality( n OPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:hasValue</i> lt .<br /> { DPE(y) &ne; &epsilon; }
</td><td> DataHasValue( DPE(y) lt )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:someValuesFrom</i> z .<br /> { DPE(y) &ne; &epsilon; and DR(z) &ne; &epsilon; }
</td><td> DataSomeValuesFrom( DPE(y) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperties</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> _:x <i>owl:someValuesFrom</i> z .<br /> { n &ge; 1, DPE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n, and DR(z) &ne; &epsilon; }
</td><td> DataSomeValuesFrom( DPE(y<sub>1</sub>) ... DPE(y<sub>n</sub>) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:allValuesFrom</i> z .<br /> { DPE(y) &ne; &epsilon; and DR(z) &ne; &epsilon; }
</td><td> DataAllValuesFrom( DPE(y) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperties</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> _:x <i>owl:allValuesFrom</i> z .<br /> { n &ge; 1, DPE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n, and DR(z) &ne; &epsilon; }
</td><td> DataAllValuesFrom( DPE(y<sub>1</sub>) ... DPE(y<sub>n</sub>) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minQualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:onDataRange</i> z .<br /> { DPE(y) &ne; &epsilon; and DR(z) &ne; &epsilon; }
</td><td> DataMinCardinality( n DPE(y) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxQualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:onDataRange</i> z .<br /> { DPE(y) &ne; &epsilon; and DR(z) &ne; &epsilon; }
</td><td> DataMaxCardinality( n DPE(y) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:qualifiedCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> _:x <i>owl:onDataRange</i> z .<br /> { DPE(y) &ne; &epsilon; and DR(z) &ne; &epsilon; }
</td><td> DataExactCardinality( n DPE(y) DR(z) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { DPE(y) &ne; &epsilon; }
</td><td> DataMinCardinality( n DPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { DPE(y) &ne; &epsilon; }
</td><td> DataMaxCardinality( n DPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:cardinality</i> NN_INT(n) .<br /> _:x <i>owl:onProperty</i> y .<br /> { DPE(y) &ne; &epsilon; }
</td><td> DataExactCardinality( n DPE(y) )
</td></tr>
</tbody></table>
</div>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 14.</span> Parsing of Data Ranges for Compatibility with OWL 1 DL
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then <i>DR(_:x)</i> is set to this object property expression.
</th></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:DataRange</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ lt<sub>1</sub> ... lt<sub>n</sub>) .<br /> { n &ge; 1 }
</td><td> DataOneOf( lt<sub>1</sub> ... lt<sub>n</sub> )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:DataRange</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ) .
</td><td> DataComplementOf( <i>rdfs:Literal</i> )
</td></tr>
</tbody></table>
</div>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 15.</span> Parsing of Class Expressions for Compatibility with OWL 1 DL
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then <i>CE(_:x)</i> is set to this class expression.
</th></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ) .
</td><td> <i>owl:Nothing</i>
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> T(SEQ y) .<br /> { CE(y) &ne; &epsilon; }
</td><td> CE(y)
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ) .
</td><td> <i>owl:Thing</i>
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> T(SEQ y) .<br /> { CE(y) &ne; &epsilon; }
</td><td> CE(y)
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:oneOf</i> T(SEQ) .
</td><td> <i>owl:Nothing</i>
</td></tr>
</tbody></table>
</div>
<a id="Parsing_of_Axioms" name="Parsing_of_Axioms"></a><h4> <span class="mw-headline">3.2.5  Parsing of Axioms </span></h4>
<p>Next, <i>O<sub>G</sub></i> is populated with axioms. For clarity, the axiom patterns are split into two tables.
</p>
<ul><li> Table 16 presents the patterns for axioms without annotations.
</li><li> Annotated axioms are parsed as follows:
<ul><li> In case of the patterns for <i>owl:AllDisjointClasses</i>, <i>owl:AllDisjointProperties</i>, <i>owl:AllDifferent</i>, and <i>owl:NegativePropertyAssertion</i>, axiom annotations are defined by <span class="name">ANN(_:x)</span>.
</li><li> For all other axioms, axiom annotations are obtained by additionally matching patterns from Table 17 in <i>G</i> during axiom matching.
</li></ul>
</li></ul>
<p>The axioms in <i>G</i> are parsed as follows:
</p>
<ul><li> All annotated axioms are parsed first.
</li><li> Only when no pattern for annotated axioms can be matched in <i>G</i>, then the patterns for axioms without annotations are matched.
</li></ul>
<p>In either case, each time a triple pattern is matched, the matched triples are removed from <i>G</i>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 16.</span> Parsing of Axioms without Annotations
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then the following axiom is added to <i>O<sub>G</sub></i>.
</th></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:Class</i> .
</td><td> Declaration( Class( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>rdfs:Datatype</i> .
</td><td> Declaration( Datatype( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:ObjectProperty</i> .
</td><td> Declaration( ObjectProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:DatatypeProperty</i> .
</td><td> Declaration( DataProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:AnnotationProperty</i> .
</td><td> Declaration( AnnotationProperty( *:x ) )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:NamedIndividual</i> .
</td><td> Declaration( NamedIndividual( *:x ) )
</td></tr>
<tr>
<td> x <i>rdfs:subClassOf</i> y .<br /> { CE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> SubClassOf( CE(x) CE(y) )
</td></tr>
<tr>
<td> x <i>owl:equivalentClass</i> y .<br /> { CE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(x) CE(y) )
</td></tr>
<tr>
<td> x <i>owl:disjointWith</i> y .<br /> { CE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> DisjointClasses( CE(x) CE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDisjointClasses</i> .<br /> _:x <i>owl:members</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DisjointClasses( CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> *:x <i>owl:disjointUnionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2,<br /> &nbsp; CE(x) &ne; &epsilon;, and<br /> &nbsp; CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DisjointUnion( CE(*:x) CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> x <i>rdfs:subPropertyOf</i> y .<br /> { OPE(x) &ne; &epsilon; and OPE(y) &ne; &epsilon; }
</td><td> SubObjectPropertyOf( OPE(x) OPE(y) )
</td></tr>
<tr>
<td> x <i>owl:propertyChainAxiom</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2,<br /> &nbsp; OPE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n, and<br /> &nbsp; OPE(x) &ne; &epsilon; }
</td><td> SubObjectPropertyOf(<br /> &nbsp;&nbsp;&nbsp; ObjectPropertyChain( OPE(y<sub>1</sub>) ... OPE(y<sub>n</sub>) )<br /> &nbsp;&nbsp;&nbsp; OPE(x)<br /> )
</td></tr>
<tr>
<td> x <i>owl:equivalentProperty</i> y .<br /> { OPE(x) &ne; &epsilon; and OPE(y) &ne; &epsilon; }
</td><td> EquivalentObjectProperties( OPE(x) OPE(y) )
</td></tr>
<tr>
<td> x <i>owl:propertyDisjointWith</i> y .<br /> { OPE(x) &ne; &epsilon; and OPE(y) &ne; &epsilon; }
</td><td> DisjointObjectProperties( OPE(x) OPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDisjointProperties</i> .<br /> _:x <i>owl:members</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and OPE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DisjointObjectProperties( OPE(y<sub>1</sub>) ... OPE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> x <i>rdfs:domain</i> y .<br /> { OPE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> ObjectPropertyDomain( OPE(x) CE(y) )
</td></tr>
<tr>
<td> x <i>rdfs:range</i> y .<br /> { OPE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> ObjectPropertyRange( OPE(x) CE(y) )
</td></tr>
<tr>
<td> x <i>owl:inverseOf</i> y .<br /> { OPE(x) &ne; &epsilon; and OPE(y) &ne; &epsilon; }
</td><td> InverseObjectProperties( OPE(x) OPE(y) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:FunctionalProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> FunctionalObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> InverseFunctionalObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:ReflexiveProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> ReflexiveObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:IrreflexiveProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> IrreflexiveObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:SymmetricProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> SymmetricObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:AsymmetricProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> AsymmetricObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:TransitiveProperty</i> .<br /> { OPE(x) &ne; &epsilon; }
</td><td> TransitiveObjectProperty( OPE(x) )
</td></tr>
<tr>
<td> x <i>rdfs:subPropertyOf</i> y .<br /> { DPE(x) &ne; &epsilon; and DPE(y) &ne; &epsilon; }
</td><td> SubDataPropertyOf( DPE(x) DPE(y) )
</td></tr>
<tr>
<td> x <i>owl:equivalentProperty</i> y .<br /> { DPE(x) &ne; &epsilon; and DPE(y) &ne; &epsilon; }
</td><td> EquivalentDataProperties( DPE(x) DPE(y) )
</td></tr>
<tr>
<td> x <i>owl:propertyDisjointWith</i> y .<br /> { DPE(x) &ne; &epsilon; and DPE(y) &ne; &epsilon; }
</td><td> DisjointDataProperties( DPE(x) DPE(y) )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDisjointProperties</i> .<br /> _:x <i>owl:members</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2 and DPE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> DisjointDataProperties( DPE(y<sub>1</sub>) ... DPE(y<sub>n</sub>) )
</td></tr>
<tr>
<td> x <i>rdfs:domain</i> y .<br /> { DPE(x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> DataPropertyDomain( DPE(x) CE(y) )
</td></tr>
<tr>
<td> x <i>rdfs:range</i> y .<br /> { DPE(x) &ne; &epsilon; and DR(y) &ne; &epsilon; }
</td><td> DataPropertyRange( DPE(x) DR(y) )
</td></tr>
<tr>
<td> x <i>rdf:type</i> <i>owl:FunctionalProperty</i> .<br /> { DPE(x) &ne; &epsilon; }
</td><td> FunctionalDataProperty( DPE(x) )
</td></tr>
<tr>
<td> *:x <i>owl:equivalentClass</i> y .<br /> { DR(*:x) &ne; &epsilon; amd DR(y) &ne; &epsilon; }
</td><td> DatatypeDefinition( DR(*:x) DR(y) )
</td></tr>
<tr>
<td> x <i>owl:hasKey</i> T(SEQ y<sub>1</sub> ... y<sub>k</sub>) .<br /> { CE(x) &ne; &epsilon;, and<br /> &nbsp; the sequence y<sub>1</sub> ... y<sub>k</sub> can be partitioned into disjoint sequences<br /> &nbsp;&nbsp;&nbsp; z<sub>1</sub> ... z<sub>m</sub> and w<sub>1</sub> ... w<sub>n</sub> such that<br /> &nbsp;&nbsp;&nbsp; m &gt; 0 or n &gt; 0 (or both) and<br /> &nbsp;&nbsp;&nbsp; OPE(z<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; m and<br /> &nbsp;&nbsp;&nbsp; DPE(w<sub>j</sub>) &ne; &epsilon; for each 1 &le; j &le; n }
</td><td> HasKey( CE(x) ( OPE(z<sub>1</sub>) ... OPE(z<sub>m</sub>) ) ( DPE(w<sub>1</sub>) ... DPE(w<sub>n</sub>) ) )
</td></tr>
<tr>
<td> x <i>owl:sameAs</i> y .
</td><td> SameIndividual( x y )
</td></tr>
<tr>
<td> x <i>owl:differentFrom</i> y .
</td><td> DifferentIndividuals( x y )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:x <i>owl:members</i> T(SEQ x<sub>1</sub> ... x<sub>n</sub>) .<br /> { n &ge; 2 }
</td><td> DifferentIndividuals( x<sub>1</sub> ... x<sub>n</sub> )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:x <i>owl:distinctMembers</i> T(SEQ x<sub>1</sub> ... x<sub>n</sub>) .<br /> { n &ge; 2 }
</td><td> DifferentIndividuals( x<sub>1</sub> ... x<sub>n</sub> )
</td></tr>
<tr>
<td> x <i>rdf:type</i> y .<br /> { CE(y) &ne; &epsilon; }
</td><td> ClassAssertion( CE(y) x )
</td></tr>
<tr>
<td> x *:y z .<br /> { OPE(*:y) &ne; &epsilon; }
</td><td> ObjectPropertyAssertion( OPE(*:y) x z )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> w .<br /> _:x <i>owl:assertionProperty</i> y .<br /> _:x <i>owl:targetIndividual</i> z .<br /> { OPE(y) &ne; &epsilon; }
</td><td> NegativeObjectPropertyAssertion( OPE(y) w z )
</td></tr>
<tr>
<td> x *:y lt .<br /> { DPE(*:y) &ne; &epsilon; }
</td><td> DataPropertyAssertion( DPE(*:y) x lt )
</td></tr>
<tr>
<td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> w .<br /> _:x <i>owl:assertionProperty</i> y .<br /> _:x <i>owl:targetValue</i> lt .<br /> { DPE(y) &ne; &epsilon; }
</td><td> NegativeDataPropertyAssertion( DPE(y) w lt )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:DeprecatedClass</i> .
</td><td> AnnotationAssertion( <i>owl:deprecated</i> *:x "true"^^<i>xsd:boolean</i> )
</td></tr>
<tr>
<td> *:x <i>rdf:type</i> <i>owl:DeprecatedProperty</i> .
</td><td> AnnotationAssertion( <i>owl:deprecated</i> *:x "true"^^<i>xsd:boolean</i> )
</td></tr>
<tr>
<td> *:x <i>rdfs:subPropertyOf</i> *:y .<br /> { AP(*:x) &ne; &epsilon; and AP(*:y) &ne; &epsilon; }
</td><td> SubAnnotationPropertyOf( AP(*:x) AP(*:y) )
</td></tr>
<tr>
<td> *:x <i>rdfs:domain</i> *:y .<br /> { AP(*:x) &ne; &epsilon; }
</td><td> AnnotationPropertyDomain( AP(*:x) *:y )
</td></tr>
<tr>
<td> *:x <i>rdfs:range</i> *:y .<br /> { AP(*:x) &ne; &epsilon; }
</td><td> AnnotationPropertyRange( AP(*:x) *:y )
</td></tr></tbody></table>
</div>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 17.</span> Parsing of Annotated Axioms
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then the following axiom is added to <i>O<sub>G</sub></i>.
</th></tr>
<tr>
<td> s *:p xlt .<br /> _:x <i>rdf:type</i> <i>owl:Axiom</i> .<br /> _:x <i>owl:annotatedSource</i> s .<br /> _:x <i>owl:annotatedProperty</i> *:p .<br /> _:x <i>owl:annotatedTarget</i> xlt .<br /> {  s *:p xlt .<br /> &nbsp; is the main triple of an axiom according to Table 16 and<br /> &nbsp; <i>G</i> contains possible necessary side triples for the axiom }
</td><td> The result is the axiom corresponding to s *:p xlt . (and possible side triples)<br /> that additionally contains the annotations ANN(_:x).
</td></tr>
</tbody></table>
</div>
<p>Next, for each blank node or IRI <span class="name">x</span> such that <span class="name">x</span> &notin; <span class="name">RIND</span>, and for each annotation
<span class="name">Annotation( annotation<sub>1</sub> ... annotation<sub>n</sub> AP y )</span> &isin; <span class="name">ANN(x)</span> with <span class="name">n</span> possibly being equal to zero, the following annotation assertion is added to <i>O<sub>G</sub></i>:
</p>
<div class="fss">
<p>AnnotationAssertion( annotation<sub>1</sub> ... annotation<sub>n</sub> AP x y )
</p>
</div>
<p>Finally, the patterns from Table 18 are matched in <i>G</i> and the resulting axioms are added to <i>O<sub>G</sub></i>. These patterns are not generated by the mapping from <a href="#Mapping_from_the_Structural_Specification_to_RDF_Graphs" title="">Section 2</a>, but they can be present in RDF graphs that encode OWL 1 DL ontologies. (Note that the patterns from the table do not contain triples of the form <span class="name">*:x <i>rdf:type</i> <i>owl:Class</i></span> because such triples are removed while parsing the entity declarations, as specified in <a href="#Parsing_of_the_Ontology_Header_and_Declarations" title="">Section 3.1.2</a>.) Each time a triple pattern is matched, the matched triples are removed from <i>G</i>.
</p>
<div class="center">
<table border="2" cellpadding="5" class="allname" style="text-align: left">
<caption> <span class="caption">Table 18.</span> Parsing of Axioms for Compatibility with OWL 1 DL
</caption>
<tbody><tr>
<th> If <i>G</i> contains this pattern...
</th><th> ...then the following axiom is added to <i>O<sub>G</sub></i>.
</th></tr>
<tr>
<td> *:x <i>owl:complementOf</i> y .<br /> { CE(*:x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) ObjectComplementOf( CE(y) ) )
</td></tr>
<tr>
<td> *:x <i>owl:unionOf</i> T(SEQ) .<br /> { CE(*:x) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) <i>owl:Nothing</i> )
</td></tr>
<tr>
<td> *:x <i>owl:unionOf</i> T(SEQ y) .<br /> { CE(*:x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) CE(y) )
</td></tr>
<tr>
<td> *:x <i>owl:unionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2,<br /> &nbsp; CE(*:x) &ne; &epsilon;, and<br /> &nbsp; CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> EquivalentClasses( CE(*:x) ObjectUnionOf( CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) ) )
</td></tr>
<tr>
<td> *:x <i>owl:intersectionOf</i> T(SEQ) .<br /> { CE(*:x) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) <i>owl:Thing</i> )
</td></tr>
<tr>
<td> *:x <i>owl:intersectionOf</i> T(SEQ y) .<br /> { CE(*:x) &ne; &epsilon; and CE(y) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) CE(y) )
</td></tr>
<tr>
<td> *:x <i>owl:intersectionOf</i> T(SEQ y<sub>1</sub> ... y<sub>n</sub>) .<br /> { n &ge; 2,<br /> &nbsp; CE(*:x) &ne; &epsilon;, and<br /> &nbsp; CE(y<sub>i</sub>) &ne; &epsilon; for each 1 &le; i &le; n }
</td><td> EquivalentClasses( CE(*:x) ObjectIntersectionOf( CE(y<sub>1</sub>) ... CE(y<sub>n</sub>) ) )
</td></tr>
<tr>
<td> *:x <i>owl:oneOf</i> T(SEQ) .<br /> { CE(*:x) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) <i>owl:Nothing</i> )
</td></tr>
<tr>
<td> *:x <i>owl:oneOf</i> T(SEQ *:y<sub>1</sub> ... *:y<sub>n</sub>) .<br /> { n &ge; 1 and CE(*:x) &ne; &epsilon; }
</td><td> EquivalentClasses( CE(*:x) ObjectOneOf( *:y<sub>1</sub> ... *:y<sub>n</sub> ) )
</td></tr>
</tbody></table>
</div>
<p>At the end of this process, the graph <i>G</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be empty.
</p>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">4  Appendix: Change Log (Informative) </span></h2>
<a id="Changes_Since_Recommendation" name="Changes_Since_Recommendation"></a><h3> <span class="mw-headline">4.1  Changes Since Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/">Recommendation of 27 October, 2009</a>.
</p>
<ul><li> With the publication of the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">Recommendation of 5 April 2012</a>, the elements of OWL 2 which are based on XSD 1.1 are now considered required, and the note detailing the optional dependency on the XSD 1.1 <a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">Candidate Recommendation of 30 April, 2009</a> has been removed from the "Status of this Document" section.
</li><li> Minor typographical errors were corrected as detailed on the <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Errata" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Errata">OWL 2 Errata</a> page.
</li></ul>
<a id="Changes_Since_Proposed_Recommendation" name="Changes_Since_Proposed_Recommendation"></a><h3> <span class="mw-headline">4.2  Changes Since Proposed Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/PR-owl2-mapping-to-rdf-20090922/" rel="nofollow" title="http://www.w3.org/TR/2009/PR-owl2-mapping-to-rdf-20090922/">Proposed Recommendation of 22 September, 2009</a>.
</p>
<ul><li> The two arguments in the ClassAssertion axiom in Table 16 were swapped to bring the axiom in line with the functional-style syntax.
</li></ul>
<a id="Changes_Since_Candidate_Recommendation" name="Changes_Since_Candidate_Recommendation"></a><h3> <span class="mw-headline">4.3  Changes Since Candidate Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/CR-owl2-mapping-to-rdf-20090611/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-owl2-mapping-to-rdf-20090611/">Candidate Recommendation of 11 June, 2009</a>.
</p>
<ul><li> Two minor bugs were fixed in the reverse mappings of inverseOf and hasKey.
</li></ul>
<a id="Changes_Since_Last_Call" name="Changes_Since_Last_Call"></a><h3> <span class="mw-headline">4.4  Changes Since Last Call </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/WD-owl2-mapping-to-rdf-20090421/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-owl2-mapping-to-rdf-20090421/">Last Call Working Draft of 21 April, 2009</a>.
</p>
<ul><li> The RDF vocabulary for annotations was changed: owl:subject, owl:predicate and owl:object became, respectively, owl:annotatedSource, owl:annotatedProperty and owl:annotatedTarget.
</li><li> Several lists of syntax were updated to track a previous change in Structural Specification and Functional-Style Syntax.
</li><li> Two of the examples were fixed.
</li><li> Some minor editorial changes were made.
</li></ul>
</div>
<a id="Acknowledgments" name="Acknowledgments"></a><h2> <span class="mw-headline">5  Acknowledgments </span></h2>
<p>The starting point for the development of OWL 2 was the <a class="external text" href="http://www.w3.org/Submission/2006/10/" rel="nofollow" title="http://www.w3.org/Submission/2006/10/">OWL1.1 member submission</a>, itself a result of user and developer feedback, and in particular of information gathered during the <a class="external text" href="http://www.webont.org/owled/" rel="nofollow" title="http://www.webont.org/owled/">OWL Experiences and Directions (OWLED) Workshop series</a>. The working group also considered <a class="external text" href="http://www.w3.org/2001/sw/WebOnt/webont-issues.html" rel="nofollow" title="http://www.w3.org/2001/sw/WebOnt/webont-issues.html">postponed issues</a> from the <a class="external text" href="http://www.w3.org/2004/OWL/" rel="nofollow" title="http://www.w3.org/2004/OWL/">WebOnt Working Group</a>.
</p><p>This document has been produced by the OWL Working Group (see below), and its contents reflect extensive discussions within the Working Group as a whole.
The editors extend special thanks to
Markus Kr&ouml;tzsch (FZI),
Alan Ruttenberg (Science Commons),
Uli Sattler (University of Manchester),
Michael Schneider (FZI) and
Evren Sirin (Clark &amp; Parsia)
for their thorough reviews.
</p><p>The regular attendees at meetings of the OWL Working Group at the time of publication of this document were:
Jie Bao (RPI),
Diego Calvanese (Free University of Bozen-Bolzano),
Bernardo Cuenca Grau (Oxford University Computing Laboratory),
Martin Dzbor (Open University),
Achille Fokoue (IBM Corporation),
Christine Golbreich (Universit&eacute; de Versailles St-Quentin and LIRMM),
Sandro Hawke (W3C/MIT),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Ian Horrocks (Oxford University Computing Laboratory),
Elisa Kendall (Sandpiper Software),
Markus Kr&ouml;tzsch (FZI),
Carsten Lutz (Universit&auml;t Bremen),
Deborah L. McGuinness (RPI),
Boris Motik (Oxford University Computing Laboratory),
Jeff Pan (University of Aberdeen),
Bijan Parsia (University of Manchester),
Peter F. Patel-Schneider (Bell Labs Research, Alcatel-Lucent),
Sebastian Rudolph (FZI),
Alan Ruttenberg (Science Commons),
Uli Sattler (University of Manchester),
Michael Schneider (FZI),
Mike Smith (Clark &amp; Parsia),
Evan Wallace (NIST),
Zhe Wu (Oracle Corporation), and
Antoine Zimmermann (DERI Galway).
We would also like to thank past members of the working group:
Jeremy Carroll,
Jim Hendler, and
Vipul Kashyap.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">6  References </span></h2>
<dl><dt> <span id="ref-owl-2-specification">[OWL 2 Specification]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">OWL 2 Web Ontology Language: <span>Structural Specification and Functional-Style Syntax (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>.</span></dd><dt> <span id="ref-rdf-concepts">[RDF Concepts]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a></cite>. Graham Klyne and Jeremy J. Carroll, eds. W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/.  Latest version available as http://www.w3.org/TR/rdf-concepts/.
</dd><dt> <span id="ref-rdf-semantics">[RDF Semantics]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF Semantics</a></cite>. Patrick Hayes, ed., W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-mt-20040210/.  Latest version available as http://www.w3.org/TR/rdf-mt/.
</dd><dt> <span id="ref-rfc-2119">[RFC 2119]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc2119.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</a></cite>. Network Working Group, S. Bradner. IETF, March 1997, http://www.ietf.org/rfc/rfc2119.txt
</dd></dl>


</body>
</html>