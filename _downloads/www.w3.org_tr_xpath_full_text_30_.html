<!-- http://www.w3.org/TR/xpath-full-text-30/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--{xml-fix} XSLT Processor: SAXON 9.3.0.5 from Saxonica SAXON EE 9.3.0.5--><!--This document was created at 20130107 1556-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQuery and XPath Full Text 3.0</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
      table.small    { font-size: x-small; }
    
/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery and XPath Full Text
3.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working Draft 08
January 2013</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2013/WD-xpath-full-text-30-20130108/">http://www.w3.org/TR/2013/WD-xpath-full-text-30-20130108/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-full-text-30/">http://www.w3.org/TR/xpath-full-text-30/</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://www.w3.org/TR/2011/WD-xpath-full-text-30-20111213/">http://www.w3.org/TR/2011/WD-xpath-full-text-30-20111213/</a></dd>
<dt>Editor:</dt>
<dd>Mary Holstege, Mark Logic Corporation</dd>
</dl>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2013/WD-xpath-full-text-30-20130108/xpath-full-text-30.xml">
XML</a> and&#160;<a href=
"http://www.w3.org/TR/2013/WD-xpath-full-text-30-20130108/xpath-full-text-30-diff.html">Changes
since previous Recommendation</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2013&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document defines the syntax and formal semantics of XQuery
and XPath Full Text 3.0, which is a language that extends XQuery
<span>3.0 <a href="#xquery-30">[XQuery 3.0: An XML Query
Language]</a></span> and XPath <span>3.0 <a href="#xpath-30">[XML
Path Language (XPath) 3.0]</a></span> with full-text search
capabilities.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#maturity-levels">
Working Draft</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html">Process
Document</a>. It was jointly developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
W3C <a href="http://www.w3.org/Style/XSL/">XSLT Working Group</a>,
each of which is part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>. The Working
Groups expect to advance this specification to <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
Status.</p>
<p>This document is the second Working Draft of the 3.0 version of
XQuery and XPath Full Text. Currently there are no substantive
changes from the previous Working Draft. The reason for publishing
this Working Draft is to provide the Full Text grammar fully
integrated with the XPath 3.0 grammar. Reviewers are expressly
requested to submit candidate requirements for XQuery and XPath
Full Text 3.0 either by using the Bugzilla system or the public
comments mailing list, as described just below.</p>
<p>No implementation report currently exists. However, a Test Suite
for XQuery and XPath Full Text 3.0 is under development.</p>
<p>This document incorporates changes made against the previous
publication of the Working Draft. Changes to this document since
the previous publication of the Working Draft are detailed in
<a href="#id-xqft-changelog"><b>J Change Log</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[FT3]” in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>Publication as a Working Draft does not imply endorsement by the
W3C Membership. This is a draft document and may be updated,
replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by groups operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XML Query Working Group and also maintains a
<a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also include
instructions for disclosing a patent. An individual who has actual
knowledge of a patent which the individual believes contains
<a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#introduction">Introduction</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#tq-ftsearch-xml">Full-Text
Search and XML</a><br />
&#160;&#160;&#160;&#160;1.2 <a href=
"#tq-ft-organization">Organization of this document</a><br />
&#160;&#160;&#160;&#160;1.3 <a href="#tq-ft-namespaces">A word
about namespaces</a><br />
2 <a href="#tq-extensions">Full-Text Extensions to XQuery and
XPath</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#processing-model">Processing
Model</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#section-ftcontainsexpr">Full-Text Contains Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#section-ftcontainsexpr-description">Description</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#section-ftcontainsexpr-examples">Examples</a><br />
&#160;&#160;&#160;&#160;2.3 <a href=
"#section-score-variables">Score Variables</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#section-using-weights">Using Weights Within a Scored
FTContainsExpr</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#section-extensions-static-context">Extensions to the Static
Context</a><br />
&#160;&#160;&#160;&#160;2.5 <a href=
"#section-extensions-feature-selection">Extensions to
Features</a><br />
3 <a href="#ftselections">Full-Text Selections</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#ftprimary">Primary Full-Text
Selections</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#ftweight">Weights</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#ftwords">Search Tokens and
Phrases</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#fttimes">Cardinality
Selection</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#ftmatchoptions">Match
Options</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.1 <a href=
"#ftlanguageoption">Language Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.2 <a href=
"#ftwildcardoption">Wildcard Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.3 <a href=
"#ftthesaurusoption">Thesaurus Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.4 <a href=
"#ftstemoption">Stemming Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.5 <a href=
"#ftcaseoption">Case Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.6 <a href=
"#ftdiacriticsoption">Diacritics Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.7 <a href=
"#ftstopwordoption">Stop Word Option</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.8 <a href=
"#ftextensionoption">Extension Option</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#logical_ftoperators">Logical
Full-Text Operators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href=
"#sec-ftor">Or-Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href=
"#sec-ftand">And-Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href=
"#sec-ftmildnot">Mild-Not Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.4 <a href=
"#sec-ftnot">Not-Selection</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#ftposfilter">Positional
Filters</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.1 <a href=
"#ftorder">Ordered Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2 <a href=
"#ftwindow">Window Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3 <a href=
"#ftdistance">Distance Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.4 <a href=
"#ftscope">Scope Selection</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.5 <a href=
"#ftcontent">Anchoring Selection</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#ftignoreoption">Ignore
Option</a><br />
&#160;&#160;&#160;&#160;3.8 <a href=
"#id-extension-selections">Extension Selections</a><br />
4 <a href="#tq-semantics">Semantics</a><br />
&#160;&#160;&#160;&#160;4.1 <a href=
"#TokenizationSec">Tokenization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.1 <a href=
"#tq-ft-Tokenization-examples">Examples</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.2 <a href=
"#TokenizationRepresentationsSec">Representations of Tokenized Text
and Matching</a><br />
&#160;&#160;&#160;&#160;4.2 <a href=
"#FTSelectionEvalSec">Evaluation of FTSelections</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1 <a href=
"#AllMatchesSec">AllMatches</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1.1
<a href="#tq-ft-formalmodel">Formal Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1.2
<a href="#tq-ft-AllMatches-examples">Examples</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1.3
<a href="#tq-ft-XML-representation">XML representation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.2 <a href=
"#FTSelectionsXMLSec">XML Representation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.3 <a href=
"#tq-ft-evaluate-function">The evaluate function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.4 <a href=
"#tq-ft-fs-FTWords">FTWords</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5 <a href=
"#FTMatchOptionsSec">Match Options Semantics</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.1
<a href="#tq-ft-matchopt-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.2
<a href="#tq-ft-matchopt-highlevel">High-Level Semantics</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.3
<a href="#options-sem-functions">Formal Semantics
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.4
<a href="#tq-ft-matchopt-FTCaseOption">FTCaseOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.5
<a href=
"#tq-ft-matchopt-FTDiacriticsOption">FTDiacriticsOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.6
<a href="#tq-ft-matchopt-FTStemOption">FTStemOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.7
<a href=
"#tq-ft-matchopt-FTThesaurusOption">FTThesaurusOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.8
<a href=
"#tq-ft-matchopt-FTStopWordOption">FTStopWordOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.9
<a href=
"#tq-ft-matchopt-FTLanguageOption">FTLanguageOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.5.10
<a href=
"#tq-ft-matchopt-FTWildCardOption">FTWildCardOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6 <a href=
"#FTOperatorsSemanticsSec">Full-Text Operators Semantics</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.1
<a href="#tq-ft-fs-FTOr">FTOr</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.2
<a href="#tq-ft-fs-FTAnd">FTAnd</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.3
<a href="#tq-ft-fs-FTUnaryNot">FTUnaryNot</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.4
<a href="#tq-ft-fs-FTMildNot">FTMildNot</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.5
<a href="#tq-ft-fs-FTOrder">FTOrder</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.6
<a href="#tq-ft-fs-FTScope">FTScope</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.7
<a href="#tq-ft-fs-FTContent">FTContent</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.8
<a href="#tq-ft-fs-FTWindow">FTWindow</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.9
<a href="#tq-ft-fs-FTDistance">FTDistance</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.6.10
<a href="#tq-ft-fs-FTTimes">FTTimes</a><br />
&#160;&#160;&#160;&#160;4.3 <a href=
"#FTContainsSec">FTContainsExpr</a><br />
&#160;&#160;&#160;&#160;4.4 <a href="#ScoreSec">Scoring</a><br />
&#160;&#160;&#160;&#160;4.5 <a href=
"#tq-ft-FTContainsExpr-example">Example</a><br />
5 <a href="#id-tq-conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;5.1 <a href=
"#id-minimal-conformance">Minimal Conformance</a><br />
&#160;&#160;&#160;&#160;5.2 <a href=
"#id-conform-optional-features">Optional Features</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.1 <a href=
"#id-ftmildnot-option">FTMildNot Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.2 <a href=
"#id-unary-not-option">FTUnaryNot Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.3 <a href=
"#id-ftunit-option">FTUnit and FTBigUnit</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.4 <a href=
"#id-ftorder-option">FTOrder Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.5 <a href=
"#id-ftscope-option">FTScope Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.6 <a href=
"#id-ftwindow-option">FTWindow Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.7 <a href=
"#id-ftdistance-option">FTDistance Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.8 <a href=
"#id-fttimes-option">FTTimes Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.9 <a href=
"#id-ftcontent-option">FTContent Operator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.10 <a href=
"#id-ftcase-option">FTCaseOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.11 <a href=
"#id-ftstopword-option">FTStopWordOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.12 <a href=
"#id-ftlanguage-option">FTLanguageOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.13 <a href=
"#id-ftignore-option">FTIgnoreOption</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.14 <a href=
"#id-scoring-option">Scoring</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.15 <a href=
"#id-weights-conf">Weights</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#id-grammar">EBNF for XQuery 3.0 Grammar
with Full Text extensions</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#grammar-terminals">Terminal
Symbols</a><br />
B <a href="#id-xpath-grammar">EBNF for XPath 3.0 Grammar with
Full-Text extensions</a><br />
&#160;&#160;&#160;&#160;B.1 <a href=
"#xpath-grammar-terminals">Terminal Symbols</a><br />
C <a href="#id-xqft-static-context-components">Static Context
Components</a><br />
D <a href="#id-errors">Error Conditions</a><br />
E <a href="#id-xqft-xqueryx">XML Syntax (XQueryX) for XQuery and
XPath Full Text 3.0</a><br />
&#160;&#160;&#160;&#160;E.1 <a href=
"#id-xqft-full-text-schema">XQueryX representation of XQuery and
XPath Full Text 3.0</a><br />
&#160;&#160;&#160;&#160;E.2 <a href=
"#id-xqft-full-text-stylesheet">XQueryX stylesheet for XQuery and
XPath Full Text 3.0</a><br />
&#160;&#160;&#160;&#160;E.3 <a href=
"#id-xqft-full-text-examples">XQueryX for XQuery and XPath Full
Text 3.0 example</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;E.3.1 <a href=
"#Example1">Example</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;E.3.1.1
<a href="#Example1-XQuery-Full-Text">XQuery solution in XQuery and
XPath Full Text 3.0 Use Cases:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;E.3.1.2
<a href="#Example1-Full-Text-XQueryX">A Solution in Full Text
XQueryX:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;E.3.1.3
<a href="#Example1-Full-Text-Transformation">Transformation of Full
Text XQueryX Solution into XQuery Full Text</a><br />
F <a href="#References">References</a><br />
&#160;&#160;&#160;&#160;F.1 <a href=
"#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;F.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
G <a href="#ft-acknowledgements">Acknowledgements</a>
(Non-Normative)<br />
H <a href="#ft-glossary">Glossary</a> (Non-Normative)<br />
I <a href="#impl-def">Checklist of Implementation-Defined
Features</a> (Non-Normative)<br />
J <a href="#id-xqft-changelog">Change Log</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="introduction" id="introduction"></a>1
Introduction</h2>
<p>This document defines the language and the formal semantics of
XQuery and XPath Full Text 3.0. This language is designed to meet
the requirements identified in, and to support the queries in, W3C
XQuery and XPath Full Text Requirements and Use Cases
<span><a href="#xpath-full-text-30-requirements-use-cases">[XQuery
and XPath Full Text 3.0 Requirements and Use Cases]</a></span>
.</p>
<p>In this document, examples and material labeled as "Note" are
provided for explanatory purposes and are not normative.</p>
<p>XQuery and XPath Full Text 3.0 extends the syntax and semantics
of XQuery <span>3.0</span> and XPath <span>3.0</span>.</p>
<p>Additionally, this document defines an XML syntax for XQuery and
XPath Full Text 3.0. The most recent versions of the two XQueryX
XML Schemas and the XQueryX XSLT stylesheet for XQuery and XPath
Full Text 3.0 are available at <a href=
"http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx.xsd">
http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx.xsd</a>,
<a href=
"http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx-ftmatchoption-extensions.xsd">
http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx-ftmatchoption-extensions.xsd</a>,
and <a href=
"http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx.xsl">
http://www.w3.org/2013/01/xpath-full-text/xpath-full-text-30-xqueryx.xsl</a>,
respectively.</p>
<div class="div2">
<h3><a name="tq-ftsearch-xml" id="tq-ftsearch-xml"></a>1.1
Full-Text Search and XML</h3>
<p>As XML becomes mainstream, users expect to be able to search
their XML documents. This requires a standard way to do full-text
search, as well as structured searches, against XML documents. A
similar requirement for full-text search led ISO to define the
SQL/MM-FT <a href="#sqlmm">[SQL/MM]</a> standard. SQL/MM-FT defines
extensions to SQL to express full-text searches providing
functionality similar to that defined in this full-text language
extension to XQuery <span>3.0</span> and XPath
<span>3.0</span>.</p>
<p>XML documents may contain highly structured data (fixed schemas,
known types such as numbers, dates), semi-structured data (flexible
schemas and types), markup data (text with embedded tags), and
unstructured data (untagged free-flowing text). Where a document
contains unstructured or semi-structured data, it is important to
be able to search using Information Retrieval techniques such as
scoring and weighting.</p>
<p>Full-text search is different from substring search in many
ways:</p>
<ol class="enumar">
<li>
<p>A full-text search searches for tokens and phrases rather than
substrings. A substring search for news items that contain the
string "lease" will return a news item that contains "Foobar
Corporation releases version 20.9 ...". A full-text search for the
token "lease" will not.</p>
</li>
<li>
<p>There is an expectation that a full-text search will support
language-based searches which substring search cannot. An example
of a language-based search is "find me all the news items that
contain a token with the same linguistic stem as 'mouse'" (finds
"mouse" and "mice"). Another example based on token proximity is
"find me all the news items that contain the tokens 'XML' and
'Query' allowing up to 3 intervening tokens".</p>
</li>
<li>
<p>Full-text search must address the vagaries and nuances of
language. Search results are often of varying usefulness. When you
search a web site for cameras that cost less than $100, this is an
exact search. There is a set of cameras that matches this search,
and a set that does not. Similarly, when you do a string search
across news items for "mouse", there is only 1 expected result set.
When you do a full-text search for all the news items that contain
the token "mouse", you probably expect to find news items
containing the token "mice", and possibly "rodents", or possibly
"computers". Not all results are equal. Some results are more
"mousey" than others. Because full-text search may be inexact, we
have the notion of score or relevance. We generally expect to see
the most relevant results at the top of the results list.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As XQuery and XPath evolve, they may apply the notion of score
to querying structured data. For example, when making travel plans
or shopping for cameras, it is sometimes useful to get an ordered
list of near matches in addition to exact matches. If XQuery and
XPath define a generalized inexact match, we expect XQuery and
XPath to utilize the scoring framework provided by XQuery and XPath
Full Text 3.0.</p>
</div>
<p>[<a name="Full-TextQueriesDef" id="Full-TextQueriesDef" title=
"Full-TextQueries">Definition</a>: <b>Full-text queries</b> are
performed on tokens and phrases. Tokens and phrases are produced
via tokenization.] Informally, tokenization breaks a character
string into a sequence of tokens, units of punctuation, and
spaces.</p>
<p>Tokenization, in general terms, is the process of converting a
text string into smaller units that are used in query processing.
Those units, called tokens, are the most basic text units that a
full-text search can refer to. Full-text operators typically work
on sequences of tokens found in the target text of a search. These
tokens are characterized by integers that capture the relative
position(s) of the token inside the string, the relative
position(s) of the sentence containing the token, and the relative
position(s) of the paragraph containing the token. The positions
typically comprise a start and an end position.</p>
<p>Tokenization, including the definition of the term "tokens",
<a title="should" href="#should">SHOULD</a> be <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.
Implementations <a title="should" href="#should">SHOULD</a> expose
the rules and sample results of tokenization as much as possible to
enable users to predict and interpret the results of tokenization.
Tokenization operates on the string value of an item; for element
nodes this does not include the content of attribute nodes, but for
attribute nodes it does. Tokenization is defined more formally in
<a href="#TokenizationSec"><b>4.1 Tokenization</b></a>.</p>
<p>[<a name="TokenDef" id="TokenDef" title="Token">Definition</a>:
A <b>token</b> is a non-empty sequence of characters returned by a
tokenizer as a basic unit to be searched. Beyond that, tokens are
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.] [<a name=
"PhraseDef" id="PhraseDef" title="Phrase">Definition</a>: A
<b>phrase</b> is an ordered sequence of any number of tokens.
Beyond that, phrases are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Consecutive tokens need not be separated by either punctuation
or space, and tokens may overlap.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some natural languages, tokens and words can be used
interchangeably.</p>
</div>
<p>[<a name="SentenceDef" id="SentenceDef" title=
"Sentence">Definition</a>: A <b>sentence</b> is an ordered sequence
of any number of tokens. Beyond that, sentences are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support sentences.]</p>
<p>[<a name="ParagraphDef" id="ParagraphDef" title=
"Paragraph">Definition</a>: A <b>paragraph</b> is an ordered
sequence of any number of tokens. Beyond that, paragraphs are
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support paragraphs.]</p>
<p>Some XML elements represent semantic markup, e.g.,
&lt;title&gt;. Others represent formatting markup, e.g., &lt;b&gt;
to indicate bold. Semantic markup serves well as token boundaries.
Some formatting markup serves well as token boundaries; for
example, paragraphs are most commonly delimited by formatting
markup. Other formatting markup may not serve well as token
boundaries. Implementations are free to provide <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> ways to
differentiate between the markup's effect on token boundaries
during tokenization. In the absence of an implementation-defined
way to differentiate, element markup (start tags, end tags, and
empty-element tags) creates token boundaries.</p>
<p>A sample tokenization is used for the examples in this document.
The results might be different for other tokenizations.</p>
<p>Tokenization enables functions and operators that operate on a
part or the root of the token (e.g., wildcards, stemming).</p>
<p>Tokenization enables functions and operators which work with the
relative positions of tokens (e.g., proximity operators).</p>
<p>This specification focuses on functionality that serves all
languages. It also selectively includes functionalities useful
within specific families of languages. For example, searching
within sentences and paragraphs is useful to many western languages
and to some non-western languages, so that functionality is
incorporated into this specification.</p>
<p>Certain aspects of language processing are described in this
specification as <b>implementation-defined</b> or
<b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>Implementation-defined</b> indicates an aspect that may differ
between implementations, but must be specified by the implementor
for each particular implementation.]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.]</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="tq-ft-organization" id="tq-ft-organization"></a>1.2
Organization of this document</h3>
<p>This document is organized as follows. We first present a
<a href="#tq-extensions">high level syntax</a> for the XQuery and
XPath Full Text 3.0 language along with some examples. Then, we
present the <a href="#ftselections">syntax and examples</a> of the
basic primitives in the XQuery and XPath Full Text 3.0 language.
This is followed by the <a href="#tq-semantics">semantics</a> of
the XQuery and XPath Full Text 3.0 language. The appendix contains
a section that provides an <a href="#id-xpath-grammar">EBNF for the
XPath <span>3.0</span> Grammar with Full-Text Extensions</a>, an
<a href="#id-grammar">EBNF for XQuery <span>3.0</span> Grammar with
Full-Text Extensions</a>, <a href=
"#ft-acknowledgements">acknowledgements</a> and a <a href=
"#ft-glossary">glossary</a>.</p>
</div>
<div class="div2">
<h3><a name="tq-ft-namespaces" id="tq-ft-namespaces"></a>1.3 A word
about namespaces</h3>
<p>Certain namespace prefixes are predeclared by XQuery
<span>3.0</span> and, by implication, by this specification, and
bound to fixed namespace URIs. These namespace prefixes are as
follows:</p>
<ul>
<li>
<p><code>xml = http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>local =
http://www.w3.org/2005/xquery-local-functions</code></p>
</li>
</ul>
<p>In addition to the prefixes in the above list, this document
uses the prefix <code>err</code> to represent the namespace URI
<code>http://www.w3.org/2005/xqt-errors</code>, This namespace
prefix is not predeclared and its use in this document is not
normative. Error codes that are not defined in this document are
defined in other XQuery <span>3.0</span> and XPath <span>3.0</span>
specifications, particularly <span><a href="#xpath-30">[XML Path
Language (XPath) 3.0]</a> and <a href="#xpath-functions-30">[XQuery
and XPath Functions and Operators 3.0]</a></span> .</p>
<p>Finally, this document uses the prefix <code>fts</code> to
represent a namespace containing a number of functions used in this
document to describe the semantics of XQuery and XPath Full Text
functions. There is no requirement that these functions be
implemented, therefore no URI is associated with that prefix.</p>
</div>
</div>
<div class="div1">
<h2><a name="tq-extensions" id="tq-extensions"></a>2 Full-Text
Extensions to XQuery and XPath</h2>
<p>XQuery and XPath Full Text 3.0 extends the languages of XQuery
<span>3.0</span> and XPath <span>3.0</span> in three ways. It:</p>
<ol class="enumar">
<li>
<p>Adds a new expression called FTContainsExpr;</p>
</li>
<li>
<p>Enhances the syntax of FLWOR expressions in XQuery
<span>3.0</span> and <code>for</code> expressions in XPath
<span>3.0</span> with optional score variables; and</p>
</li>
<li>
<p>Adds static context declarations for full-text match options to
the query prolog.</p>
</li>
</ol>
<p>Additionally, it extends the data model and processing models in
various ways.</p>
<div class="div2">
<h3><a name="processing-model" id="processing-model"></a>2.1
Processing Model</h3>
<p>A <a title="full-text contains expression" href=
"#dt-ftcontains">full-text contains expression</a> (<a href=
"#section-ftcontainsexpr"><b>2.2 Full-Text Contains
Expression</b></a>) is composed of several parts:</p>
<ol class="enumar">
<li>
<p>An XPath <span>3.0</span> or XQuery <span>3.0</span> expression
(RangeExpr) that specifies the sequence of items to be searched.
[<a name="dt-search-context" id="dt-search-context" title=
"search context">Definition</a>: Those items are called the
<b>search context</b>.]</p>
</li>
<li>
<p>The full-text selection to be applied (<a href=
"#ftselections"><b>3 Full-Text Selections</b></a>). <b>Full-text
selections</b> are, syntactically and semantically, fully
composable and contain:</p>
<ul>
<li>
<p>Required:</p>
<ul>
<li>
<p>Tokens and phrases for which a search is performed (<a href=
"#ftwords"><b>3.2 Search Tokens and Phrases</b></a>).</p>
</li>
</ul>
</li>
<li>
<p>Optional:</p>
<ul>
<li>
<p>Match options, such as indicators for case sensitivity and stop
words (<a href="#ftmatchoptions"><b>3.4 Match Options</b></a>);</p>
</li>
<li>
<p>Boolean full-text operators, that compose a full-text selection
from simpler full-text selections (<a href=
"#logical_ftoperators"><b>3.5 Logical Full-Text
Operators</b></a>);</p>
</li>
<li>
<p>Other full-text operators that are constraints on the positions
of matches, such as indicators for distance between tokens and for
the cardinality of matches (<a href="#ftposfilter"><b>3.6
Positional Filters</b></a> and <a href="#fttimes"><b>3.3
Cardinality Selection</b></a>); and</p>
</li>
<li>
<p>The weighting information. Each individual search term in a
full-text selection may be annotated with optional weight
information. This information may be used during the evaluation of
the full-text selections to calculate scoring, information that
quantifies the relevance of the result to the given search
criteria.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>An optional XPath <span>3.0</span> or XQuery <span>3.0</span>
expression (UnionExpr) that specifies the set of nodes, descendents
of the RangeExp, whose contents must be ignored for the purpose of
determining a match during the search (<a href=
"#ftignoreoption"><b>3.7 Ignore Option</b></a>).</p>
</li>
</ol>
<p>The results of the evaluation of the full-text selection
operators are instances of the AllMatches model, which complements
the XQuery Data Model (XDM) for processing full-text queries. An
AllMatches instance describes all possible solutions to the
full-text query for a given search context item. Each solution is
described by a Match instance. A Match instance contains the tokens
from the search context that must be included (described using
StringInclude instances which model the positive terms) and the
tokens from search context item that must be excluded (described
using StringExclude instances which model the negative terms). Each
negative or positive term is modeled as a tuple: the position of
the query token or phrase in the full-text selection, and a
TokenInfo structure that describes a set of tokens in the text
string which match the query token or phrase.</p>
<img src="images/ProcMod-XQueryFT.gif" alt=
"Processing Model Extensions" />
<p>Figure 1 provides a schematic overview of the XQuery and XPath
Full Text 3.0 processing steps that are discussed in detail below.
Some of these steps are completely outside the domain of XQuery; in
Figure 1, these are depicted outside the black line that represents
the boundaries of the language. The diagram only shows the central
pieces of the XQuery Processing Model (see <a href=
"http://www.w3.org/TR/xquery/#id-processing-model">Section 2.2
Processing Model</a><sup><small>XQ</small></sup>), however zooms in
on the Execution Engine where the processing of the full-text
extensions takes place. The full-text processing steps are labeled
as FTn within the diagram and are referenced within the text.</p>
<p>Like all XQuery expressions, an FTContainsExpr returns an XDM
Instance (see Fig. 1). With the exception of FTWords, which
consumes TokenInfos, all full-text selections are closed under the
AllMatches data model, i.e., their input and output are AllMatches
instances. Tokenization transforms an XDM instance into TokenInfos,
which ultimately get converted into AllMatches instances by the
evaluation of full-text selections. Thus, the evaluation of nested
full-text and XQuery expressions instances moves back and forth
between these two models.</p>
<p>The resulting AllMatches instance obtained by the evaluation of
an FTContainsExpr is converted into a Boolean value before being
returned to the enclosing XPath or XQuery operation as follows. If
at least one member of the disjunction contains only positive terms
then value returned is true. If all members of the disjunction
contain negative terms the result is false.</p>
<p>Weighting information, in an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
fashion, may be used when calculating the scoring information
computed and made available by FTContainsExpr to the optional score
construct.</p>
<p>Given the components of a given full-text contains expression,
the evaluation algorithm will proceed according to the following
steps, also referenced in the processing model diagram as steps
FT<em>n</em> (see Fig. 1):</p>
<ol class="enumar">
<li>
<p>Evaluate the search context expression (resulting in the
sequence of search context items), the ignore option, if any
(resulting in the set of ignored nodes), and any other XQuery/XPath
exprssions nested within the full-text contains expression.
(FT1)</p>
</li>
<li>
<p>Tokenize the query string(s). (FT2.1)</p>
</li>
<li>
<p>For each search context item:</p>
<ol class="enumla">
<li>
<p>Delete the ignored nodes from the search context item.</p>
</li>
<li>
<p>Tokenize the result of the previous step. This produces a
sequence of tokens. (FT2.2) Note that implementations may (as an
optimization) perform tokenization as part of the External
Processing that is described in the XQuery Processing Model, when
an XML document is parsed into an Infoset/PSVI and ultimately into
a XQuery Data Model instance.</p>
</li>
<li>
<p>Evaluate the FTSelection against the tokens of the search
context. (FT3, FT4)</p>
</li>
</ol>
</li>
<li>
<p>Convert the topmost AllMatches instances into a Boolean value.
(FT5)</p>
<p>The additional scoring information (also part of FT5) that is
produced by the evaluation of the full-text contains expression is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> and is
not specified in this document. The scoring information is made
available at the same time the Boolean value is returned.</p>
</li>
</ol>
<p>(A more detailed version of the above procedure appears in
Section <a href="#FTContainsSec"><b>4.3
FTContainsExpr</b></a>.)</p>
<p>Section <a href="#ftselections"><b>3 Full-Text
Selections</b></a> describes the syntax and the informal semantics
of full-text operators. Their formal semantics as well as the
formal definition of the AllMatches data model are given in Section
<a href="#tq-semantics"><b>4 Semantics</b></a>.</p>
</div>
<div class="div2">
<h3><a name="section-ftcontainsexpr" id=
"section-ftcontainsexpr"></a>2.2 Full-Text Contains Expression</h3>
<p>[<a name="dt-ftcontains" id="dt-ftcontains" title=
"full-text contains expression">Definition</a>: A <b>full-text
contains expression</b> is a expression that evaluates a sequence
of items against a full-text selection. ]</p>
<p>As a syntactic construct, a full-text contains expression
(grammar symbol: <a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a>) behaves like a
comparison expression (see <a href=
"http://www.w3.org/TR/xquery/#id-general-comparisons">Section 3.5.2
General Comparisons</a><sup><small>XQ</small></sup>). This grammar
rule introduces <a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e640.doc-xquery30-ComparisonExpr" id=
"noid_d3e640.doc-xquery30-ComparisonExpr"></a>[87]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTContainsExpr">FTContainsExpr</a>
( (<a href="#prod-xquery30-ValueComp">ValueComp</a><br />
| <a href="#prod-xquery30-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xquery30-NodeComp">NodeComp</a>) <a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a> )?</code></td>
</tr>
</tbody>
</table>
<p>A full-text contains expression may be used anywhere a
ComparisonExpr may be used. The <code>contains text</code> operator
has higher precedence than other comparison operators, so the
results of <code>contains text</code> expressions may be compared
without enclosing them in parentheses.</p>
<div class="div3">
<h4><a name="section-ftcontainsexpr-description" id=
"section-ftcontainsexpr-description"></a>2.2.1 Description</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTContainsExpr" id=
"doc-xquery30-FTContainsExpr"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTContainsExpr">FTContainsExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringConcatExpr">StringConcatExpr</a> ( "contains"
"text" <a href="#doc-xquery30-FTSelection">FTSelection</a> <a href=
"#doc-xquery30-FTIgnoreOption">FTIgnoreOption</a>? )?</code></td>
</tr>
</tbody>
</table>
<p>A full-text contains expression returns a Boolean value. It
returns true if there is some item returned by the RangeExpr that,
after <a href="#TokenizationSec">tokenization</a>, matches the
full-text selection <a href=
"#doc-xquery30-FTSelection">FTSelection</a>. Since tokenization
includes tokens derived only from the string values of items, a
full-text contains expression searches the text of element nodes
and of their descendant elements. The string value of other kinds
of nodes, such as attributes and comments, will not be included
unless the attribute or comment node itself is the target
(RangeExpr) of the full-text contains expression. See Section
<a href="#ftselections"><b>3 Full-Text Selections</b></a> for more
details. For the purpose of determining a match, certain
descendants of nodes (identified by <a href=
"#doc-xquery30-FTIgnoreOption">FTIgnoreOption</a>) in the RangeExpr
may be ignored, as specified in Section <a href=
"#ftignoreoption"><b>3.7 Ignore Option</b></a>.</p>
<p>An XQuery and XPath Full Text 3.0 processor <a title="should"
href="#should">SHOULD</a> try to use the information available in
xml:lang for processing of collations, as well as the various match
options defined in Section <a href="#ftmatchoptions"><b>3.4 Match
Options</b></a>.</p>
</div>
<div class="div3">
<h4><a name="section-ftcontainsexpr-examples" id=
"section-ftcontainsexpr-examples"></a>2.2.2 Examples</h4>
<p>The following example in XQuery <span>3.0</span> Full Text
returns the author of each book with a title containing a token
with the same root as <code>dog</code> and the token
<code>cat</code>.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b in /books/book
where $b/title contains text ("dog" using stemming) ftand "cat" 
return $b/author
</pre></div>
</div>
<p>The same example in XPath <span>3.0</span> Full Text is written
as:</p>
<div class="xpath">
<div class="exampleInner">
<pre>

/books/book[title contains text ("dog" using stemming) ftand "cat"]/author
</pre></div>
</div>
<p>In the next example a ComparisonExpr is combined with an
FTContainsExpr using the logical XQuery operator <code>and</code>.
The query selects books that have a price of less than 50 and a
title which contains a token with the same root as
<code>train</code>:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
/books/book[price &lt; 50 and title contains text ("train" using stemming)]
</pre></div>
</div>
<p>The following example shows the combination of two
<code>contains text</code> expressions the results of which are
compared using the not-equals operator. The query selects books
where either the title contains the token <code>dog</code> and the
token <code>cat</code> and the content does not contain a token
with the same root as <code>train</code>, or where the title fails
to have one of the matching tokens but the content does:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
/books/book[title contains text "dog" ftand "cat" ne
            content contains text ("train" using stemming)]
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="section-score-variables" id=
"section-score-variables"></a>2.3 Score Variables</h3>
<p>Besides specifying a match of a full-text query as a Boolean
condition, full-text query applications typically also have the
ability to associate scores with the results. [<a name="Score" id=
"Score" title="Score">Definition</a>: The <b>score</b> of a
full-text query result expresses its relevance to the search
conditions.]</p>
<p>XQuery and XPath Full Text 3.0 extends the languages of XQuery
<span>3.0</span> and XPath <span>3.0</span> further by adding
optional <code>score</code> variables to the <code>for</code> and
<code>let</code> clauses of FLWOR expressions.</p>
<p>The production for the extended <code>for</code> clause in
XQuery <span>3.0</span> follows.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ForClause" id=
"doc-xquery30-ForClause"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href="#doc-xquery30-ForBinding">ForBinding</a>
("," <a href=
"#doc-xquery30-ForBinding">ForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-ForBinding" id=
"doc-xquery30-ForBinding"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ForBinding">ForBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? <a href=
"#prod-xquery30-AllowingEmpty">AllowingEmpty</a>? <a href=
"#prod-xquery30-PositionalVar">PositionalVar</a>? <a href=
"#doc-xquery30-FTScoreVar">FTScoreVar</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTScoreVar" id=
"doc-xquery30-FTScoreVar"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTScoreVar">FTScoreVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"score" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
</table>
<p>In XPath <span>3.0</span>, the SimpleForClause is extended
similarly.</p>
<p>When a <code>score</code> variable is present in a
<code>for</code> clause the evaluation of the expression following
the <code>in</code> keyword not only needs to determine the result
sequence of the expression, i.e., the sequence of items which are
iteratively bound to the <code>for</code> variable. It must also
determine in each iteration the relevance "score" value of the
current item and bind the <code>score</code> variable to that
value.</p>
<p>The scope of a score variable bound in a for or let clause
comprises all subexpressions of the containing FLWOR expression
that appear after the variable binding. The scope does not include
the expression to which the variable is bound. The for and let
clauses of a given FLWOR expression may bind the same score
variable name more than once. In this case, each new binding
occludes the previous one, which becomes inaccessible in the
remainder of the FLWOR expression.</p>
<p>The expanded QName of a score variable bound in a for clause
must be distinct from both the expanded QName of the variable with
which it is associated and the expanded QName of any positional
variable with which it is associated [<a href=
"http://www.w3.org/TR/xquery-30/#ERRXQST0089" title=
"err:XQST0089">err:XQST0089</a>]<sup><small>XQ30</small></sup>.</p>
<p>The semantics of scoring and how it relates to second-order
functions is discussed in Section <a href="#ScoreSec"><b>4.4
Scoring</b></a>.</p>
<p>In the following example <code>book</code> elements are
determined that satisfy the condition <code>[content contains text
"web site" ftand "usability" and .//chapter/title contains text
"testing"]</code>. The scores assigned to the <code>book</code>
elements are returned.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b score $s 
    in /books/book[content contains text "web site" ftand "usability" 
                   and .//chapter/title contains text "testing"]
return $s
</pre></div>
</div>
<p>The example above is also a valid example of the XPath
<span>3.0</span> extension.</p>
<p>Scores are typically used to order results, as in the following,
more complete example.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b score $s 
    in /books/book[content contains text "web site" ftand "usability"]
where $s &gt; 0.5
order by $s descending
return &lt;result&gt;  
          &lt;title&gt; {$b//title} &lt;/title&gt; 
          &lt;score&gt; {$s} &lt;/score&gt; 
       &lt;/result&gt;
</pre></div>
</div>
<p>Note that the score variable gets <em>one</em> score value for
each item in the value of the expression after the <code>in</code>
keyword, regardless of the number of FTContainsExprs in that
expression. In the following example, two separate full-text
contains expressions are used to select the matching paragraphs.
There is still just one score for each <code>para</code> returned.
The highest scoring paragraphs will be returned first:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $p score $s in 
  //book[title contains text "software"]/para[. contains text "usability"]
     order by $s descending
  return $p
</pre></div>
</div>
<p>The following more elaborate example uses multiple score
variables to return the matching paragraphs ordered so that those
from the highest scoring books precede those from the lowest
scoring books, where the highest scoring paragraphs of each book
are returned before the lower scoring paragraphs of that book:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b score $score1 in //book[title contains text "software"]
    order by $score1 descending
return
    for $p score $score2 in $b/para[. contains text "usability"]
       order by $score2 descending
    return $p
</pre></div>
</div>
<p>The <code>score</code> variable is bound to a value which
reflects the relevance of the match criteria in the full-text
selections to the items returned by the respective RangeExprs. The
calculation of relevance is <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>,
but score evaluation must follow these rules:</p>
<ol class="enumar">
<li>
<p>Score values are of type <code>xs:double</code> in the range [0,
1].</p>
</li>
<li>
<p>For score values greater than 0, a higher score must imply a
higher degree of relevance</p>
</li>
</ol>
<p>Similarly to their use in a <code>for</code> clause, score
variables may be specified in a <code>let</code> clause. A score
variable in a <code>let</code> clause is also bound to the score of
the expression evaluation, but in the <code>let</code> clause one
score is determined for the complete result.</p>
<p>The production for the extended <code>let</code> clause
follows.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-LetClause" id=
"doc-xquery30-LetClause"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href="#doc-xquery30-LetBinding">LetBinding</a>
("," <a href=
"#doc-xquery30-LetBinding">LetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-LetBinding" id=
"doc-xquery30-LetBinding"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-LetBinding">LetBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("$" <a href="#prod-xquery30-VarName">VarName</a>
<a href="#prod-xquery30-TypeDeclaration">TypeDeclaration</a>?) |
<a href="#doc-xquery30-FTScoreVar">FTScoreVar</a>) ":=" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>When using the score option in a <code>for</code> clause the
expression following the <code>in</code> keyword has the dual
purpose of filtering, i.e., driving the iteration, and determining
the scores. It is possible to separately specify expressions for
filtering and scoring by combining a simple <code>for</code> clause
with a <code>let</code> clause that uses scoring. The following is
an example of this.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b in /books/book[.//chapter/title contains text "testing"]
let score $s := $b/content contains text "web site" ftand "usability" 
order by $s descending
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</pre></div>
</div>
<p>This example returns <code>book</code> elements with chapter
titles that contain "testing". Along with the <code>book</code>
elements scores are returned. These scores, however, reflect
whether the book content contains "web site" and "usability".</p>
<p>Note that it is not a requirement of the score of an
FTContainsExpr to be 0, if the expression evaluates to false, nor
to be non-zero, if the expression evaluates to true. Hence, in the
example above it is not possible to infer the Boolean value of the
FTContainsExpr in the <code>let</code> clause from the calculated
score of a returned <code>result</code> element. For instance, an
implementation may want to assign a non-zero score to a book that
contained "web site", but not "usability", as this may be
considered more relevant than a book that does not contain "web
site" or "usability".</p>
<p>The expression ExprSingle associated with the score variable is
passed to the scoring algorithm. The scoring algorithm calculates
the score value based on the passed expression (not on the value
returned by evaluating the expression). The set of expressions
supported by the scoring algorithm is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. If an
expression not supported by the scoring algorithm is passed to the
scoring algorithm, the result is implementation-defined.</p>
<p>The use of <code>score</code> variables introduces a
second-order aspect to the evaluation of expressions which cannot
be emulated by (first-order) XQuery functions. Consider the
following replacement of the clause <code>let score $s :=
FTContainsExpr</code></p>
<div class="exampleInner">
<pre>
let $s := score(FTContainsExpr)
</pre></div>
<p>where a function <code>score</code> is applied to some
FTContainsExpr. If the function <code>score</code> were
first-order, it would only be applied to the result of the
evaluation of its argument, which is one of the Boolean constants
<code>true</code> or <code>false</code>. Hence, there would be at
most two possible values such a <code>score</code> function would
be able to return and no further differentiation would be
possible.</p>
<div class="div3">
<h4><a name="section-using-weights" id=
"section-using-weights"></a>2.3.1 Using Weights Within a Scored
FTContainsExpr</h4>
<p>[<a name="WeightDeclarationsDef" id="WeightDeclarationsDef"
title="WeightDeclarations">Definition</a>: Scoring may be
influenced by adding <b>weight declarations</b> to search tokens,
phrases, and expressions.] Weight declarations are introduced
syntactically in the FTPrimaryWithOptions production, described in
Section <a href="#ftweight"><b>3.1.1 Weights</b></a>.</p>
<p>The weights assigned are not related to any absolute standard,
but typically have a relationship to other weights within the same
FTContains expression.</p>
<p>The effect of weights on the resulting score is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.
However, scoring algorithms <a title="must" href="#must">MUST</a>
conform to the constraint that when no explicit weight is
specified, the default weight is 1.0.</p>
<p>The following example illustrates how different weights can be
used for different search terms.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $b in /books/book
let score $s := $b/content contains text ("web site" weight {0.5})
                                ftand ("usability" weight {2})
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="section-extensions-static-context" id=
"section-extensions-static-context"></a>2.4 Extensions to the
Static Context</h3>
<p>The XQuery Static Context is extended with a component for each
full-text <a title="match option group" href=
"#dt-match-option-group">match option group</a>. The settings of
these components can be changed by using the following declaration
syntax in the Prolog.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Prolog" id=
"doc-xquery30-Prolog"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Prolog">Prolog</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href=
"#prod-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#prod-xquery30-Setter">Setter</a> | <a href=
"#prod-xquery30-NamespaceDecl">NamespaceDecl</a> | <a href=
"#prod-xquery30-Import">Import</a> | <a href=
"#doc-xquery30-FTOptionDecl">FTOptionDecl</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)* ((<a href=
"#prod-xquery30-ContextItemDecl">ContextItemDecl</a> | <a href=
"#prod-xquery30-AnnotatedDecl">AnnotatedDecl</a> | <a href=
"#prod-xquery30-OptionDecl">OptionDecl</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTOptionDecl" id=
"doc-xquery30-FTOptionDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTOptionDecl">FTOptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ft-option" <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a></code></td>
</tr>
</tbody>
</table>
<p>Match options modify the match semantics of full-text
expressions. They are described in detail in Section <a href=
"#ftmatchoptions"><b>3.4 Match Options</b></a>. When a match option
is specified explicitly in a full-text expression, it overrides the
setting of the respective component in the static context.</p>
</div>
<div class="div2">
<h3><a name="section-extensions-feature-selection" id=
"section-extensions-feature-selection"></a>2.5 Extensions to
Features</h3>
<p>The set of feature names that can be used in the XQuery
<code>require-feature</code> or <code>prohibit-feature</code> is
extended to include the following names defined in the
<code>"http://www.w3.org/2011/xquery-features"</code>
namespace.</p>
<p>These features fall into a hierarchy of feature names following
the rules given in <a href=
"http://www.w3.org/TR/xquery-30/#id-require-prohibit-feature">Section
4.20 require-feature and prohibit-feature</a>
<sup><small>XQ30</small></sup>.</p>
<ul>
<li>
<p>The name <code>full-text</code> corresponds to support for the
minimal conformance defined in <a href=
"#id-minimal-conformance"><b>5.1 Minimal Conformance</b></a>.</p>
</li>
</ul>
<p>Adding any of the following feature names to
<code>require-feature</code> implicitly requires the
<code>full-text</code> feature as well:</p>
<ul>
<li>
<p>The name <code>full-text-mild-not</code> corresponds to the
feature defined in <a href="#id-ftmildnot-option"><b>5.2.1
FTMildNot Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-unary-not</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-unary-not-option"><b>5.2.2 FTUnaryNot Operator</b></a>.</p>
<p>Adding either of the following two feature names to
<code>require-feature</code> implicitly requires
<code>full-text-unary-not</code> also:</p>
<ul>
<li>
<p>The name <code>full-text-unary-not-no-ftand</code> corresponds
to the feature defined in <a href="#id-unary-not-option"><b>5.2.2
FTUnaryNot Operator</b></a> without <a title=
"Negation Restriction 1" href="#id-Negation-Restriction-1">Negation
Restriction 1</a>.</p>
</li>
<li>
<p>The name <code>full-text-unary-not-positional-filter</code>
corresponds to the feature defined in <a href=
"#id-unary-not-option"><b>5.2.2 FTUnaryNot Operator</b></a> without
<a title="Negation Restriction 2" href=
"#id-Negation-Restriction-2">Negation Restriction 2</a>.</p>
</li>
</ul>
<p>Adding the name
<code>full-text-unary-not-optional-features</code> to
<code>require-features</code> implicitly requires whichever of the
above two features that are not explicitly forbidden; adding it to
<code>prohibit-features</code> implicitly forbids whichever of the
above two features that are not explicitly required.</p>
</li>
<li>
<p>The name <code>full-text-sentences</code> corresponds to the
"sentence" feature defined in <a href="#id-ftunit-option"><b>5.2.3
FTUnit and FTBigUnit</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-paragraphs</code> corresponds to the
"paragraph" feature defined in <a href="#id-ftunit-option"><b>5.2.3
FTUnit and FTBigUnit</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-ordered</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-ftorder-option"><b>5.2.4 FTOrder Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-scope</code> corresponds to the feature
defined in <a href="#id-ftscope-option"><b>5.2.5 FTScope
Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-window</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-ftwindow-option"><b>5.2.6 FTWindow Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-distance</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-ftdistance-option"><b>5.2.7 FTDistance Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-times</code> corresponds to the feature
defined in <a href="#id-fttimes-option"><b>5.2.8 FTTimes
Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-anchoring</code> corresponds to the
feature defined in <a href="#id-ftcontent-option"><b>5.2.9
FTContent Operator</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-case</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-ftcase-option"><b>5.2.10 FTCaseOption</b></a>.</p>
<p>Adding either of the following two feature names to
<code>require-feature</code> implicitly requires
<code>full-text-case</code> also:</p>
<ul>
<li>
<p>The name <code>full-text-case-upper</code> corresponds to the
"uppercase" feature defined in <a href=
"#id-ftcase-option"><b>5.2.10 FTCaseOption</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-case-lower</code> corresponds to the
"lowercase" feature defined in <a href=
"#id-ftcase-option"><b>5.2.10 FTCaseOption</b></a>.</p>
</li>
</ul>
<p>Adding the name <code>full-text-case-optional-features</code> to
<code>require-features</code> implicitly requires whichever of the
above two features that are not explicitly forbidden; adding it to
<code>prohibit-features</code> implicitly forbids whichever of the
above two features that are not explicitly required.</p>
</li>
<li>
<p>The name <code>full-text-stop-words</code> corresponds to the
feature defined in <a href="#id-ftstopword-option"><b>5.2.11
FTStopWordOption</b></a>.</p>
<p>Adding either of the following two feature names to
<code>require-feature</code> implicitly requires
<code>full-text-stop-words</code> also:</p>
<ul>
<li>
<p>The name <code>full-text-stop-words-body</code> corresponds to
the feature defined in <a href="#id-ftstopword-option"><b>5.2.11
FTStopWordOption</b></a> in the body of a query.</p>
</li>
<li>
<p>The name <code>full-text-stop-words-literal</code> corresponds
to the StringLiteral form of the feature defined in <a href=
"#id-ftstopword-option"><b>5.2.11 FTStopWordOption</b></a>.</p>
</li>
</ul>
<p>Adding the name
<code>full-text-stop-words-optional-features</code> to
<code>require-features</code> implicitly requires whichever of the
above two features that are not explicitly prohibited; adding it to
<code>prohibit-features</code> implicitly forbids whichever of the
above two features that are not explicitly required.</p>
</li>
<li>
<p>The name <code>full-text-multi-language</code> corresponds to
the unrestricted form of the feature defined in <a href=
"#id-ftlanguage-option"><b>5.2.12 FTLanguageOption</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-score</code> corresponds to the
unrestricted form of the feature defined in <a href=
"#id-scoring-option"><b>5.2.14 Scoring</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-ignore</code> corresponds to the
feature defined in <a href="#id-ftignore-option"><b>5.2.13
FTIgnoreOption</b></a>.</p>
</li>
<li>
<p>The name <code>full-text-weight-negative</code> corresponds to
the feature defined in <a href="#id-weights-conf"><b>5.2.15
Weights</b></a>.</p>
</li>
<li>
<p>The name
<code><span>full-text-language-<var>xxx</var></span></code>
corresponds to the support for the language <var>xxx</var> as
defined in <a href="#ftlanguageoption"><b>3.4.1 Language
Option</b></a>. <var>xxx</var> can be any language identifier. An
implementation <a title="must" href="#must">MUST</a> follow the
same rules for determining language feature name equivalence as it
does for language option equivalence. For example,
"full-text-language-de" is equivalent to
"full-text-language-deu".</p>
</li>
<li>
<p>The name
<code><span>full-text-thesaurus-<var>xxx</var></span></code>
corresponds to support for the <var>xxx</var> relationship as
defined in <a href="#ftthesaurusoption"><b>3.4.3 Thesaurus
Option</b></a>. An implementation <a title="must" href=
"#must">MUST</a> recognize feature names for the relationship names
USE, UF, BT, NT, BTG, NTG, BTP, NTP, TT, and RT. It <a title="may"
href="#may">MAY</a> recognize others.</p>
</li>
<li>
<p>Adding the name <code>full-text-optional-features</code> to
<code>require-features</code> implicitly requires whichever of the
full-text features listed above that are not expressly prohibited;
adding it to <code>prohibit-features</code> implicitly prohibits
whichever of the full-text features listed above that are not
explicitly required.</p>
</li>
</ul>
<p>All XQuery implementations must recognize the feature names in
the above list.</p>
</div>
</div>
<div class="div1">
<h2><a name="ftselections" id="ftselections"></a>3 Full-Text
Selections</h2>
<p>This section describes the full-text selections which contain
the full-text operators in a <a title=
"full-text contains expression" href="#dt-ftcontains">full-text
contains expression</a> (<a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a>), as well as the
match options which modify the matching semantics of the full-text
selections. In the following, the syntax for each type of full-text
selection is given together with an informal statement of its
meaning.</p>
<p>[<a name="ftselection" id="ftselection" title=
"full-text selection">Definition</a>: A <b>full-text selection</b>
specifies the conditions of a full-text search. ]</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTSelection" id=
"doc-xquery30-FTSelection"></a>[199]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTSelection">FTSelection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTOr">FTOr</a> <a href=
"#doc-xquery30-FTPosFilter">FTPosFilter</a>*</code></td>
</tr>
</tbody>
</table>
<p>As shown in the grammar, a full-text selection consists of
search conditions possibly involving logical operators (<a href=
"#doc-xquery30-FTOr">FTOr</a>), followed by an arbitrary number of
positional filters (<a href=
"#doc-xquery30-FTPosFilter">FTPosFilter</a>).</p>
<p>The syntax and semantics of the individual full-text selection
operators follow.</p>
<p>This XML document is the source document for examples in this
section.</p>
<div class="exampleInner">
<pre>
&lt;books&gt;
  &lt;book number="1"&gt;
    &lt;title shortTitle="Improving Web Site Usability"&gt;Improving  
        the Usability of a Web Site Through Expert Reviews and
        Usability Testing&lt;/title&gt;
    &lt;author&gt;Millicent Marigold&lt;/author&gt;
    &lt;author&gt;Montana Marigold&lt;/author&gt;
    &lt;editor&gt;Véra Tudor-Medina&lt;/editor&gt;
    &lt;content&gt;
      &lt;p&gt;The usability of a Web site is how well the  
          site supports the users in achieving specified  
          goals. A Web site should facilitate learning,  
          and enable efficient and effective task  
          completion, while propagating few errors.
      &lt;/p&gt;
      &lt;note&gt;This book has been approved by the Web Site  
          Users Association.
      &lt;/note&gt;
    &lt;/content&gt;
  &lt;/book&gt;
&lt;/books&gt;
</pre></div>
<p>Tokenization is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A sample
tokenization is used for the examples in this section. This sample
tokenization uses white space, punctuation and XML tags as
word-breakers, periods followed by a space as sentence boundaries,
and <code>&lt;p&gt;</code> for paragraph boundaries. The first
sentence and paragraph start at the beginning of the document, and
the last sentence and paragraph end at the end of the document. The
results may be different for other tokenizations.</p>
<p>The first five tokens in this example using the sample
tokenization would be "Improving", "the", "usability", "of", and
"a".</p>
<p>Unless stated otherwise, the results assume a case-insensitive
match.</p>
<div class="div2">
<h3><a name="ftprimary" id="ftprimary"></a>3.1 Primary Full-Text
Selections</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTPrimary" id=
"doc-xquery30-FTPrimary"></a>[206]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTPrimary">FTPrimary</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery30-FTWords">FTWords</a> <a href=
"#doc-xquery30-FTTimes">FTTimes</a>?) | ("(" <a href=
"#doc-xquery30-FTSelection">FTSelection</a> ")") | <a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftprimary" id="dt-ftprimary" title=
"primary full-text selection">Definition</a>: A <b>primary
full-text selection</b> is the basic form of a full-text selection.
It specifies tokens and phrases as search conditions (<a href=
"#doc-xquery30-FTWords">FTWords</a>), optionally followed by a
cardinality constraint (<a href=
"#doc-xquery30-FTTimes">FTTimes</a>). An <a href=
"#doc-xquery30-FTSelection">FTSelection</a> in parentheses and the
<a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a> are
also a primary full-text selections.]</p>
<div class="div3">
<h4><a name="ftweight" id="ftweight"></a>3.1.1 Weights</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e1403.doc-xquery30-FTPrimaryWithOptions" id=
"noid_d3e1403.doc-xquery30-FTPrimaryWithOptions"></a>[205]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTPrimary">FTPrimary</a> <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a>? <a href=
"#doc-xquery30-FTWeight">FTWeight</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTWeight" id=
"doc-xquery30-FTWeight"></a>[200]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTWeight">FTWeight</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"weight" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>As shown in the grammar, a full-text primary selection may be
optionally followed by match options (which are discussed in
<a href="#ftmatchoptions"><b>3.4 Match Options</b></a>) and by a
"weight" value that is specified using an expression enclosed in
braces. The Expr is evaluated as if it were an argument to a
function with an expected type <code>xs:double</code>. The weight
<a title="must" href="#must">MUST</a> have an absolute value
between 0.0 and 1000.0 inclusive. If the absolute value of the
weight is greater than 1000.0, an error is raised: [<a href=
"#ERRFTDY0016" title="err:FTDY0016">err:FTDY0016</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As a consequence of the flexibility given to implementations
under <a href=
"http://www.w3.org/TR/xquery/#id-errors-and-opt">Section 2.3.4
Errors and Optimization</a><sup><small>XQ</small></sup>, it is
possible that evaluation of weight declarations in an
FTContainsExpr for which no scores are evaluated may be skipped by
the implementation and errors with them may go unreported.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="ftwords" id="ftwords"></a>3.2 Search Tokens and
Phrases</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTWords" id=
"doc-xquery30-FTWords"></a>[207]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTWords">FTWords</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTWordsValue">FTWordsValue</a>
<a href=
"#doc-xquery30-FTAnyallOption">FTAnyallOption</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTWordsValue" id=
"doc-xquery30-FTWordsValue"></a>[208]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTWordsValue">FTWordsValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-StringLiteral">StringLiteral</a>
| ("{" <a href="#prod-xquery30-Expr">Expr</a> "}")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTAnyallOption" id=
"doc-xquery30-FTAnyallOption"></a>[210]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTAnyallOption">FTAnyallOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("any" "word"?) | ("all" "words"?) | "phrase"</code></td>
</tr>
</tbody>
</table>
<p><a href="#doc-xquery30-FTWords">FTWords</a> finds matches that
contain the specified tokens and phrases.</p>
<p>FTWords consists of two parts: a mandatory <a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a> part and an optional
<a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> part.
<a href="#doc-xquery30-FTWordsValue">FTWordsValue</a> specifies the
tokens and phrases that must be contained in the matches. <a href=
"#doc-xquery30-FTAnyallOption">FTAnyallOption</a> specifies how
containment is checked.</p>
<p>In general, the tokens and phrases in <a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a> are specified using a
nested XQuery expression. To simplify notation, the enclosing
braces may be omitted if <a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a> consists of a single
string literal.</p>
<p>The following rules specify how an <a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a> matches tokens and
phrases. First, the <a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a> is converted to a
sequence of strings as though it were an argument to a function
with the expected type of <code>xs:string*</code>. If the sequence
is empty, the FTWords yields no matches. Otherwise, each of those
strings is tokenized into a sequence of tokens as described in
<a href="#TokenizationSec">Section 4.1 Tokenization</a>. Then,
<a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
checked.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
"any", the sequence of tokens for each string is considered as a
phrase. If the sequence of tokens is empty, then the phrase
contributes nothing to the set of matches for the FTWords.
Otherwise, a match is found in the tokenized form of the text being
searched, whenever that form contains a subsequence of tokens that
corresponds to the sequence of query tokens in an
implementation-defined way and that subsequence of tokens covers
consecutive token positions in the tokenized text. If the value of
the FTWordsValue contains more than one string, the different
strings are considered to be alternatives, i.e., the search context
must contain at least one of the generated phrases. Each resulting
match will contain exactly one such phrase.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
"all", the sequence of tokens for each string is considered as a
phrase. If any such sequence of tokens is empty, the FTWords yields
no matches. The resulting matches must contain all of the generated
phrases.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
"phrase", the tokens from all the strings are concatenated in a
single sequence, which is considered as a phrase. If the sequence
of tokens is empty, the FTWords yields no matches. The resulting
matches must contain the generated phrase.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
"any word", the tokens from all the strings are combined into a
single set. If the set is empty, the FTWords yields no matches. The
search context must contain at least one of the tokens in the set.
Each resulting match will contain exactly one such token.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
"all words", the tokens from all the strings are combined into a
single set. If the set is empty, the FTWords yields no matches. The
resulting matches must contain all of the tokens in the set.</p>
<p>If the <a href="#doc-xquery30-FTWordsValue">FTWordsValue</a>
evaluates to a single string, the use of "any", "all", and "phrase"
in <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a>
produces the same results.</p>
<p>If <a href="#doc-xquery30-FTAnyallOption">FTAnyallOption</a> is
omitted, "any" is the default.</p>
<p>The following expression returns the sample <code>book</code>
element, because its <code>title</code> element contains the token
"Expert":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[./title contains text "Expert"]
</pre></div>
</div>
<p>The following expression returns the sample <code>book</code>
element, because its <code>title</code> element contains the phrase
"Expert Reviews":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[./title contains text "Expert Reviews"]
</pre></div>
</div>
<p>The following expression returns the sample <code>book</code>
element, because its <code>title</code> element contains the two
tokens "Expert" and "Reviews":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[./title contains text {"Expert", "Reviews"} all]
</pre></div>
</div>
<p>The following expression returns false for our sample document,
because the <code>p</code> element doesn't contain the phrase "Web
Site Usability" although it contains all of the tokens in the
phrase:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book//p contains text "Web Site Usability"
</pre></div>
</div>
<p>The following expression returns book numbers of
<code>book</code> elements by "Marigold" with a title about "Web
Site Usability", sorting them in descending score order:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
for $book in /books/book[.//author contains text "Marigold"] 
let score $score := $book/title/@shortTitle contains text "Web Site Usability" 
where $score &gt; 0.8 
order by $score descending
return $book/@number
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="fttimes" id="fttimes"></a>3.3 Cardinality
Selection</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTTimes" id=
"doc-xquery30-FTTimes"></a>[211]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTTimes">FTTimes</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"occurs" <a href="#doc-xquery30-FTRange">FTRange</a>
"times"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-cardinality-selection" id=
"dt-cardinality-selection" title=
"cardinality selection">Definition</a>: A <b>cardinality
selection</b> consist of an <a href=
"#doc-xquery30-FTWords">FTWords</a> followed by the <a href=
"#doc-xquery30-FTTimes">FTTimes</a> postfix operator.] A
cardinality selection selects matches for which the operand
<a href="#doc-xquery30-FTWords">FTWords</a> is matched a specified
number of times.</p>
<p>A cardinality selection limits the number of different matches
of <a href="#doc-xquery30-FTWords">FTWords</a> within the specified
range. The semantics of FTRange are described in <a href=
"#ftdistance"><b>3.6.3 Distance Selection</b></a>.</p>
<p>In the document fragment "very very big":</p>
<ol class="enumar">
<li>
<p>The <a href="#doc-xquery30-FTWords">FTWords</a> <code>"very
big"</code> has 1 match consisting of the second "very" and
"big".</p>
</li>
<li>
<p>The <a href="#doc-xquery30-FTWords">FTWords</a> <code>{"very",
"big"} all</code> has 2 matches; one consisting of the first "very"
and "big", and the other containing the second "very" and
"big".</p>
</li>
<li>
<p>The <a href="#doc-xquery30-FTWords">FTWords</a> <code>{"very",
"big"} any</code> has 3 matches.</p>
</li>
</ol>
<p>The following expression returns the example <code>book</code>
element's number, because the <code>book</code> element contains 2
or more occurrences of "usability":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[. contains text "usability" occurs at least 2 times]/@number
</pre></div>
</div>
<p>The following expression returns the empty sequence, because
there are 3 occurrences of <code>{"usability", "testing"}
any</code> in the designated <code>title</code>:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1" and title contains text {"usability", 
"testing"} any occurs at most 2 times] 
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="ftmatchoptions" id="ftmatchoptions"></a>3.4 Match
Options</h3>
<p>Full-text match options modify the matching behaviour of the
<a title="primary full-text selection" href="#dt-ftprimary">primary
full-text selection</a> to which they are applied.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTPrimaryWithOptions" id=
"doc-xquery30-FTPrimaryWithOptions"></a>[205]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTPrimary">FTPrimary</a> <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a>? <a href=
"#doc-xquery30-FTWeight">FTWeight</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTMatchOptions" id=
"doc-xquery30-FTMatchOptions"></a>[221]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTMatchOptions">FTMatchOptions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("using" <a href=
"#doc-xquery30-FTMatchOption">FTMatchOption</a>)+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTMatchOption" id=
"doc-xquery30-FTMatchOption"></a>[222]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTMatchOption">FTMatchOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTLanguageOption">FTLanguageOption</a><br />
| <a href=
"#doc-xquery30-FTWildCardOption">FTWildCardOption</a><br />
| <a href=
"#doc-xquery30-FTThesaurusOption">FTThesaurusOption</a><br />
| <a href="#doc-xquery30-FTStemOption">FTStemOption</a><br />
| <a href="#doc-xquery30-FTCaseOption">FTCaseOption</a><br />
| <a href=
"#doc-xquery30-FTDiacriticsOption">FTDiacriticsOption</a><br />
| <a href=
"#doc-xquery30-FTStopWordOption">FTStopWordOption</a><br />
| <a href=
"#doc-xquery30-FTExtensionOption">FTExtensionOption</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-match-options" id="dt-match-options" title=
"match option">Definition</a>: <b>Match options</b> modify the set
of tokens in the query, or how they are matched against tokens in
the text.]</p>
<p>[<a name="dt-match-option-group" id="dt-match-option-group"
title="match option group">Definition</a>: Each of the alternatives
of production <a href=
"#doc-xquery30-FTMatchOption">FTMatchOption</a> other than <a href=
"#doc-xquery30-FTExtensionOption">FTExtensionOption</a> corresponds
to one <b>match option group</b>. ] The match options from any
given group are mutually exclusive, i.e., only one of these
settings can be in effect, whereas match options of different
groups can be combined freely.</p>
<p>It is a static error [<a href="#ERRFTST0019" title=
"err:FTST0019">err:FTST0019</a>] if, within a single <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a>, there is more
than one match option of any given <a title="match option group"
href="#dt-match-option-group">match option group</a>. For example,
if the <a href="#doc-xquery30-FTCaseOption">FTCaseOption</a>
"lowercase" is specified, then "uppercase" cannot also be specified
as part of the same <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a>.</p>
<p>Although match options only take effect in the application of
<a href="#doc-xquery30-FTWords">FTWords</a>, the syntax also allows
to specify match options that modify the non-primitive full-text
selection <code>"(" FTSelection ")"</code>. Such a higher-level
match option provides a default for the respective match option
group for any embedded <a href=
"#doc-xquery30-FTPrimary">FTPrimary</a>, just as <a href=
"#doc-xquery30-FTOptionDecl">match option declarations</a> in the
<a href="#doc-xquery30-Prolog">Prolog</a> provide default match
options for the whole query.</p>
<p>Match options are propagated through the query via the static
context. For each of the seven match option groups, the static
context has a component that contains one option from that group.
The seven settings are initialized by the implementation in
accordance with the table in Appendix <a href=
"#id-xqft-static-context-components"><b>C Static Context
Components</b></a>, and are modified by any <a href=
"#doc-xquery30-FTOptionDecl">FTOptionDecl</a>s in the <a href=
"#doc-xquery30-Prolog">Prolog</a>. The resulting settings are then
propagated unchanged to every <a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a> in the module
(including those in <code>VarDecl</code>s and
<code>FunctionDecl</code>s, and including any that happen to be
nested within another <code>FTContainsExpr</code>). At any given
<code>FTContainsExpr</code>, the settings from the static context
are copied to the <code>FTContainsExpr</code>'s inner settings,
which are then propagated down the syntax tree. At each <a href=
"#doc-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a>, the
locally specified match options (if any) overwrite the
corresponding inner setting(s). At each <a href=
"#doc-xquery30-FTWords">FTWords</a>, the inner settings are used as
the effective match options for tokenizing the query strings and
matching them against the tokens in the text. (These inner settings
could be seen as a parallel set of components in the static
context, but Section <a href="#tq-semantics"><b>4 Semantics</b></a>
models them as structures that get passed as parameters to various
semantic functions.)</p>
<p>Thus, when a match option appears in an <a href=
"#doc-xquery30-FTSelection">FTSelection</a>, it applies to the
associated <a href="#doc-xquery30-FTPrimary">FTPrimary</a>, but not
to any <code>FTContainsExpr</code>s that happen to be embedded
within that <code>FTPrimary</code>. Instead, for a nested
<code>FTContainsExpr</code>, the default match options are those
declared in the <code>Prolog</code> or, if not declared in the
<code>Prolog</code>, then supplied by the implementation's initial
values.</p>
<p>An <a href="#doc-xquery30-FTMatchOption">FTMatchOption</a>
applies to the <a href="#doc-xquery30-FTPrimary">FTPrimary</a> that
immediately precedes it. That FTPrimary is either an <a href=
"#doc-xquery30-FTWords">FTWords</a> (possibly qualified by an
<a href="#doc-xquery30-FTTimes">FTTimes</a>), an <a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a>, or a
parenthesized <a href=
"#doc-xquery30-FTSelection">FTSelection</a>.</p>
<p>[<a name="dt-match-option-order" id="dt-match-option-order"
title="match option application order">Definition</a>: The order in
which effective match options for an <a href=
"#doc-xquery30-FTWords">FTWords</a> are applied is called the
<b>match option application order</b>.] This order is significant
because match options are not always commutative. For example,
synonym(stem(word)) is not always the same as
stem(synonym(word)).</p>
<p>The match option application order is subject to some
constraints:</p>
<ol class="enumar">
<li>
<p>The Language Option must be applied first</p>
</li>
<li>
<p>The Stemming Option must be applied before the Case Option and
the Diacritics Option</p>
</li>
</ol>
<p>Aside from these constraints, the full order of the application
of match options is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>More information on their semantics is given in <a href=
"#FTMatchOptionsSec"><b>4.2.5 Match Options Semantics</b></a>.</p>
<p>If no match options declarations are present in the prolog and
the implementation does not define any overwriting of the static
context components for the match options, the query:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book/title contains text "usability" 
</pre></div>
</div>
<p>is, assuming "de" is the <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> default
language, equivalent to the query:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book/title contains text "usability" 
    using language "de"
    using no wildcards
    using no thesaurus
    using no stemming
    using case insensitive 
    using diacritics insensitive 
    using no stop words
</pre></div>
</div>
<p>We describe each match option group in more detail in the
following sections.</p>
<div class="div3">
<h4><a name="ftlanguageoption" id="ftlanguageoption"></a>3.4.1
Language Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTLanguageOption" id=
"doc-xquery30-FTLanguageOption"></a>[232]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTLanguageOption">FTLanguageOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"language" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftlanguageoption" id="dt-ftlanguageoption" title=
"language option">Definition</a>: A <b>language option</b> modifies
token matching by specifying the language of search tokens and
phrases.]</p>
<p>The StringLiteral following the keyword <code>language</code>
designates one language. It must be castable to
<code>xs:language</code>; otherwise, an error is raised: [<a href=
"http://www.w3.org/TR/xpath-30/#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]<sup><small>XP30</small></sup>.</p>
<p>The "language" option influences tokenization, stemming, and
stop words in an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way. The
"language" option <a title="may" href="#may">MAY</a> influence the
behavior of other match options in an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
<p>The set of standardized language identifiers is defined in
<a href="#BCP47">[BCP 47]</a>. The set of valid language
identifiers among the standardized set is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An
implementation <a title="may" href="#may">MAY</a> choose to use
private extensions introduced by a singleton 'x' for additional
language identifiers, or other singletons for registered extensions
as described in sec. 2.2.6 of <a href="#BCP47">[BCP 47]</a>. It is
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> what
additional language identifiers, if any, are valid. If an invalid
language identifier is specified, then the behavior is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. If the
implementation chooses to raise an error in that case, it must
raise [<a href="#ERRFTST0009" title=
"err:FTST0009">err:FTST0009</a>]. <span>An implementation <a title=
"must" href="#must">MUST</a> treat language identifiers that
<a href="#BCP47">[BCP 47]</a> defines as equivalent as identifying
the same language. For example "mn" and "MN" are equivalent, as
language tags are case insensitive, and "de" and "deu" are
equivalent, as they are different codes for the same language.
However, it is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> whether an
implementation treats a particular language identifier with script,
region, or variant portions as equivalent to the language
identifier without them. For example, an implementation may treat
"en-UK" as equivalent "en" and "en-US" but "sr-Latn" as different
from "sr" and "sr-Cyrl".</span></p>
<p>The default language is specified in the static context.</p>
<p>When an XQuery and XPath Full Text processor evaluates text in a
document that is governed by an xml:lang attribute and the portion
of the full-text query doing that evaluation contains an
FTLanguageOption that specifies a different language from the
language specified by the governing xml:lang attribute, the
language-related behavior of that full-text query is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>This is an example where the language option is used to select
the appropriate stop word list:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/content//p contains text "salon de thé"
using stop words default using language "fr"
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftwildcardoption" id="ftwildcardoption"></a>3.4.2
Wildcard Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTWildCardOption" id=
"doc-xquery30-FTWildCardOption"></a>[233]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTWildCardOption">FTWildCardOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"wildcards" | ("no" "wildcards")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftwildcardoption" id="dt-ftwildcardoption" title=
"wildcard option">Definition</a>: A <b>wildcard option</b> modifies
token and phrase matching by specifying whether or not wildcards
are recognized in query strings.]</p>
<p>When the "wildcards" option is used, wildcard syntax may be
included within query strings. A wildcard consists of an indicator
(a period or full stop, "."), optionally followed by a qualifier.
Each wildcard in a query token will match zero or more characters
within a token in the text being searched, as described below. The
number of characters that can be matched depends on the qualifier.
The forms of wildcard syntax specified by this document are:</p>
<ol class="enumar">
<li>
<p>A single period, without any qualifiers: Matches a single
arbitrary character.</p>
</li>
<li>
<p>A period immediately followed by a single question mark, "?":
Matches either no characters or one character.</p>
</li>
<li>
<p>A period immediately followed by a single asterisk, "*": Matches
zero or more characters.</p>
</li>
<li>
<p>A period immediately followed by a single plus sign, "+":
Matches one or more characters.</p>
</li>
<li>
<p>A period immediately followed by a sequence of characters that
matches the regular expression <code>{[0-9]+,[0-9]+}</code>:
Matches a number of characters, where the number is no less than
the number represented by the series of digits before the comma,
and no greater than the number represented by the series of digits
following the comma.</p>
<p>If a period in the query string is immediately followed by a
left curly brace, but the subsequent characters do not conform to
the given regular expression, then an error is raised: [<a href=
"#ERRFTDY0020" title="err:FTDY0020">err:FTDY0020</a>].</p>
</li>
</ol>
<p>A question mark, asterisk, plus sign, or left curly brace that
is not immediately preceded by a period is not treated as a
qualifier. For example, using the sample tokenization and
"wildcards", the query string "wil+" does not match the search text
"will" or "willlllll", but only matches the search text "wil". (The
sample tokenization treats the plus sign as punctuation.)</p>
<p>When "wildcards" is used, any character in a query string can be
"escaped" by immediately preceding it with a backslash, "\". That
is, a backslash immediately followed by any character represents
that character literally, preventing any special interpretation
that the "wildcards" option might otherwise attach to it. In
particular:</p>
<ol class="enumar">
<li>
<p>Escaping a period prevents its interpretation as a wildcard.</p>
</li>
<li>
<p>Escaping a question mark, asterisk, plus sign, or left curly
brace ensures that it is not interpreted as a qualifier.</p>
</li>
<li>
<p>An escaped backslash ("\\") represents a literal backslash.</p>
</li>
<li>
<p>If a query string is terminated by an unescaped backslash, an
error is raised: [<a href="#ERRFTDY0020" title=
"err:FTDY0020">err:FTDY0020</a>].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A query string of the form <code>"abc\"xyz"</code> does
<em>not</em> represent the three characters "abc" followed by a
literal double-quote followed by the three characters "xyz".
Instead, this is a malformed StringLiteral, and the processor will
report a syntax error [<a href=
"http://www.w3.org/TR/xpath-30/#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>]<sup><small>XP30</small></sup>.</p>
</div>
<p>When the "no wildcards" option is used, no wildcards are
recognized in query strings. Periods, question marks, asterisks,
plus signs, left curly braces, and backslashes are always
recognized as ordinary text characters.</p>
<p>The default is "no wildcards".</p>
<p>The following expression returns true, because the
<code>p</code> element contains "well":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/p contains text "w.ll" using wildcards
</pre></div>
</div>
<p>The following expression returns true, because the
<code>title</code> element contains "site":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text ".?site" using wildcards
</pre></div>
</div>
<p>The following expression returns true, because the
<code>title</code> element contains "improving":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text "improv.*" using wildcards
</pre></div>
</div>
<p>The following expression raises error [<a href="#ERRFTDY0020"
title="err:FTDY0020">err:FTDY0020</a>], because the query string
uses incorrect syntax:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/p contains text "wi.{5,7]" using wildcards
</pre></div>
</div>
<p>The following expression returns true, because the title
contains "site":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text "\s\i\t\e" using wildcards
</pre></div>
</div>
<p>The following expression returns true, because the title
contains "Usability":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text "Usab.+\\" using wildcards
</pre></div>
</div>
<p>(Note that "\\" represents a literal backslash, which the sample
tokenization treats as punctuation.)</p>
<p>The following expression raises error [<a href="#ERRFTDY0020"
title="err:FTDY0020">err:FTDY0020</a>], because the query string
ends with an unescaped backslash:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/p contains text "will\" using wildcards
</pre></div>
</div>
<p>The following expression returns false, because the
<code>p</code> element does not contain the phrase "w ll":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/p contains text "w.ll" using no wildcards
</pre></div>
</div>
<p>(Note that, without wildcards, the sample tokenization will
treat the period in "w.ll" as punctuation, thus producing "w" and
"ll" as separate tokens.)</p>
</div>
<div class="div3">
<h4><a name="ftthesaurusoption" id="ftthesaurusoption"></a>3.4.3
Thesaurus Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTThesaurusOption" id=
"doc-xquery30-FTThesaurusOption"></a>[226]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTThesaurusOption">FTThesaurusOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("thesaurus" (<a href=
"#doc-xquery30-FTThesaurusID">FTThesaurusID</a> | "default"))<br />
| ("thesaurus" "(" (<a href=
"#doc-xquery30-FTThesaurusID">FTThesaurusID</a> | "default") (","
<a href="#doc-xquery30-FTThesaurusID">FTThesaurusID</a>)*
")")<br />
| ("no" "thesaurus")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTThesaurusID" id=
"doc-xquery30-FTThesaurusID"></a>[227]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTThesaurusID">FTThesaurusID</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" <a href="#doc-xquery30-URILiteral">URILiteral</a>
("relationship" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)? (<a href=
"#doc-xquery30-FTLiteralRange">FTLiteralRange</a>
"levels")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-URILiteral" id=
"doc-xquery30-URILiteral"></a>[198]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTLiteralRange" id=
"doc-xquery30-FTLiteralRange"></a>[228]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTLiteralRange">FTLiteralRange</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "least" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "most" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("from" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a> "to" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftthesaurusoption" id="dt-ftthesaurusoption" title=
"thesaurus option">Definition</a>: A <b>thesaurus option</b>
modifies token and phrase matching by specifying whether a
thesaurus is used or not.] If thesauri are used, the thesaurus
option specifies information to locate the thesauri either by
default or through a URI reference. It also states the relationship
to be applied and how many levels within the thesaurus to be
traversed.</p>
<p>If the thesaurus option specifies a thesaurus with a relative
URI, that relative URI is resolved to an absolute URI using the
base URI in the static context and that absolute URI is used to
identify the thesaurus.</p>
<p>If the URI specifies a thesaurus that is not found in the
statically known thesauri, an error is raised [<a href=
"#ERRFTST0018" title="err:FTST0018">err:FTST0018</a>].</p>
<p>Thesauri add related tokens and phrases to the query or change
query tokens. Thus, the user may narrow, broaden, or otherwise
modify the query using synonyms, hypernyms (more generic terms),
etc. The search is performed as though the user has specified all
related query tokens and phrases in a disjunction (FTOr).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A thesaurus may be standards-based or locally-defined. It may be
a traditional thesaurus, or a taxonomy, soundex, ontology, or topic
map. How the thesaurus is represented is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<p>An FTThesaurusID may optionally contain a StringLiteral to
specify the relationship sought between tokens and phrases written
in the query and terms in the thesaurus. Relationships include, but
are not limited to, the relationships and their abbreviations
presented in <a href="#iso-2788">[ISO 2788]</a> and their
equivalents in other languages. The set of relationships supported
by an implementation is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations <a title="should" href="#should">SHOULD</a> support
the relationships defined in <a href="#iso-2788">[ISO 2788]</a>.
The following list of terms have the meanings defined in <a href=
"#iso-2788">[ISO 2788]</a>. If a query specifies thesaurus
relationships not supported by the thesaurus, or does not specify a
relationship, the behavior is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<ol class="enumar">
<li>
<p><em>equivalence relationships (synonyms):</em> PREFERRED TERM
(USE), NONPREFERRED USED FOR TERM (UF);</p>
</li>
<li>
<p><em>hierarchical relationships:</em> BROADER TERM (BT), NARROWER
TERM (NT), BROADER TERM GENERIC (BTG), NARROWER TERM GENERIC (NTG),
BROADER TERM PARTITIVE (BTP), NARROWER TERM PARTITIVE (NTP), TOP
Terms (TT); and</p>
</li>
<li>
<p><em>associative relationships:</em> RELATED TERM (RT).</p>
</li>
</ol>
<p>An FTThesaurusID may also optionally include an FTLiteralRange
to specify the number of levels to be queried in hierarchical
relationships. An FTLiteralRange is a constrained form of <a href=
"#doc-xquery30-FTRange">FTRange</a>, and specifies a (possibly
empty) range of integer values according to the same rules.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For historical reasons, an implementation <a title="may" href=
"#may">MAY</a> allow an FTLiteralRange to have subexpressions more
general than IntegerLiterals, and <a title="may" href=
"#may">MAY</a> even allow its subexpressions to be dynamically
evaluated.</p>
</div>
<p>The effect of specifying a particular range of levels in an
FTThesaurusID is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. This
includes cases involving empty ranges, negative levels, or levels
not supported by the thesaurus.</p>
<p>If no levels are specified, the default is to query all levels
in hierarchical relationships or to query an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> number of
levels in hierarchical relationships.</p>
<p>The "thesaurus" option specifies that string matches include
tokens that can be found in one of the specified thesauri. When
"default" is used in place of a FTThesaurusID, the thesauri
specified in the static context are used, which are either given by
the prolog declaration for the thesaurus option, or, if no such
declaration exists a system-defined default thesaurus with a
system-defined relationship. The default thesaurus may be used in
combination with other explicitly specified thesauri.</p>
<p>The "no thesaurus" option specifies that no thesaurus will be
used.</p>
<p>The default is "no thesaurus".</p>
<p>The following expression returns true, because it finds a
<code>content</code> element containing "task" which the thesaurus
identified as a synonym for "duty":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
.//book/content contains text "duty" using
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "UF"
</pre></div>
</div>
<p>The following expression returns a <code>book</code> element,
because it finds a <code>content</code> element containing "users",
which is a narrower term of "people":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[./content contains text "people" using
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "NT" at most 2 levels]
</pre></div>
</div>
<p>Assuming the thesaurus available at URL
"http://bstore1.example.com/UsabilitySoundex.xml" contains soundex
capabilities, the following query returns a <code>book</code>
element containing "Marigold" which sounds like "Merrygould":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "Merrygould" using thesaurus at
"http://bstore1.example.com/UsabilitySoundex.xml" relationship
"sounds like"]
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftstemoption" id="ftstemoption"></a>3.4.4 Stemming
Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTStemOption" id=
"doc-xquery30-FTStemOption"></a>[225]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTStemOption">FTStemOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"stemming" | ("no" "stemming")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftstemoption" id="dt-ftstemoption" title=
"stemming option">Definition</a>: A <b>stemming option</b> modifies
token and phrase matching by specifying whether stemming is applied
or not. ]</p>
<p>The "stemming" option specifies that matches may contain tokens
that have the same stem as the tokens and phrases written in the
query. It is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> what a stem
of a token is.</p>
<p>The "no stemming" option specifies that the tokens and phrases
are not stemmed.</p>
<p>It is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> whether the
stemming is based on an algorithm, dictionary, or mixed
approach.</p>
<p>The default is "no stemming".</p>
<p>The following expression returns true, because the
<code>title</code> of the specified <code>book</code> contains
"improving" which has the same stem as "improve":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]/title contains text "improve" using stemming 
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftcaseoption" id="ftcaseoption"></a>3.4.5 Case
Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTCaseOption" id=
"doc-xquery30-FTCaseOption"></a>[223]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTCaseOption">FTCaseOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" "insensitive")<br />
| ("case" "sensitive")<br />
| "lowercase"<br />
| "uppercase"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftcaseoption" id="dt-ftcaseoption" title=
"case option">Definition</a>: A <b>case option</b> modifies the
matching of tokens and phrases by specifying how uppercase and
lowercase characters are considered.]</p>
<p>There are four possible character case options:</p>
<ol class="enumar">
<li>
<p>Using the option "case insensitive", tokens and phrases are
matched, regardless of the case of characters of the query tokens
and phrases.</p>
</li>
<li>
<p>Using the option "case sensitive", tokens and phrases are
matched, if and only if the case of their characters is the same as
written in the query.</p>
</li>
<li>
<p>Using the option "lowercase", tokens and phrases are matched, if
and only if they match the query without regard to character case,
but contain only lowercase characters.</p>
</li>
<li>
<p>Using the option "uppercase", tokens and phrases are matched, if
and only if they match the query without regard to character case,
but contain only uppercase characters.</p>
</li>
</ol>
<p>The default is "case insensitive".</p>
<p>The effect of the case options is also influenced by the query's
default collation (see <a href=
"http://www.w3.org/TR/xquery/#static_context">Section 2.1.1 Static
Context</a><sup><small>XQ</small></sup> and <a href=
"http://www.w3.org/TR/xquery/#id-default-collation-declaration">Section
4.4 Default Collation Declaration</a><sup><small>XQ</small></sup>).
The following table summarizes how these interact.</p>
<table border="1" summary="Case Matrix">
<caption>Case Matrix</caption>
<thead>
<tr>
<th colspan="1">Case option \ Default collation</th>
<th colspan="1">UCC (Unicode Codepoint Collation)</th>
<th colspan="1">CCS (some generic case-sensitive collation)</th>
<th colspan="1">CCI (some generic case-insensitive collation)</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1">case insensitive</th>
<td>compare as if both lower</td>
<td>case-insensitive variant of CCS if it exists, else error</td>
<td>CCI</td>
</tr>
<tr>
<th colspan="1">case sensitive</th>
<td>UCC</td>
<td>CCS</td>
<td>case-sensitive variant of CCI if it exists, else error</td>
</tr>
<tr>
<th colspan="1">lowercase</th>
<td>compare using UCC after applying fn:lower-case() to the query
string</td>
<td>compare using CCS after applying fn:lower-case() to the query
string</td>
<td>CCI</td>
</tr>
<tr>
<th colspan="1">uppercase</th>
<td>compare using UCC after applying fn:upper-case() to the query
string</td>
<td>compare using CCS after applying fn:upper-case() to the query
string</td>
<td>CCI</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this table, "else error" means "Otherwise, an error is
raised: [<a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOCH0002" title=
"err:FOCH0002">err:FOCH0002</a>]<sup><small>FO30</small></sup>".
The phrase "if it exists" is used, because the case-sensitive
collation CCS does not always have a case-insensitive variant (and,
even if one exists, it may not be possible to determine it
algorithmically), and because the case-insensitive collation CCI
does not always have a case-sensitive variant (and, even if one
exists, it may not be possible to determine it
algorithmically).</p>
</div>
<p>The following expression returns false, because the
<code>title</code> element doesn't contain "usability" in
lower-case characters:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text "Usability" using lowercase 
</pre></div>
</div>
<p>The following expression returns true, because the character
case is not considered:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text "usability" using case insensitive
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftdiacriticsoption" id="ftdiacriticsoption"></a>3.4.6
Diacritics Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTDiacriticsOption" id=
"doc-xquery30-FTDiacriticsOption"></a>[224]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTDiacriticsOption">FTDiacriticsOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("diacritics" "insensitive")<br />
| ("diacritics" "sensitive")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftdiacriticsoption" id="dt-ftdiacriticsoption"
title="diacritics option">Definition</a>: A <b>diacritics
option</b> modifies token and phrase matching by specifying how
diacritics are considered. ]</p>
<p>There are two possible diacritics options:</p>
<ol class="enumar">
<li>
<p>The option "diacritics" "insensitive" matches tokens and phrases
with and without diacritics. Whether diacritics are written in the
query or not is not considered.</p>
</li>
<li>
<p>The option "diacritics" "sensitive" matches tokens and phrases
only if they contain the diacritics as they are written in the
query.</p>
</li>
</ol>
<p>The default is "diacritics insensitive".</p>
<p>The effect of the diacritics options is also influenced by the
query's default collation (see <a href=
"http://www.w3.org/TR/xquery/#static_context">Section 2.1.1 Static
Context</a><sup><small>XQ</small></sup> and <a href=
"http://www.w3.org/TR/xquery/#id-default-collation-declaration">Section
4.4 Default Collation Declaration</a><sup><small>XQ</small></sup>).
The following table summarizes how these interact.</p>
<table border="1" summary="Diacritics Matrix">
<caption>Diacritics Matrix</caption>
<thead>
<tr>
<th colspan="1">Diacritics option \ Default collation</th>
<th colspan="1">UCC (Unicode Codepoint Collation)</th>
<th colspan="1">CDS (some generic diacritics-sensitive
collation)</th>
<th colspan="1">CDI (some generic diacritics-insensitive
collation)</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1">diacritics insensitive</th>
<td>UCC comparison, but without considering diacritics</td>
<td>diacritics-insensitive variant of CDS if it exists, else
error</td>
<td>CDI</td>
</tr>
<tr>
<th colspan="1">diacritics sensitive</th>
<td>UCC</td>
<td>CDS</td>
<td>diacritics-sensitive variant of CDI if it exists, else
error</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this table, "else error" means "Otherwise, an error is
raised: [<a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOCH0002" title=
"err:FOCH0002">err:FOCH0002</a>]<sup><small>FO30</small></sup>".
The phrase "if it exists" is used, because the diacritics-sensitive
collation CDS does not always have a diacritics-insensitive variant
(and, even if one exists, it may not be possible to determine it
algorithmically), and because the diacritics-insensitive collation
CDI does not always have a diacritics-sensitive variant (and, even
if one exists, it may not be possible to determine it
algorithmically).</p>
</div>
<p>The following expression returns true, because the token "Véra"
in the <code>editor</code> element is matched, as the acute accent
is not considered in the comparison:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]//editor contains text "Vera" using diacritics insensitive
</pre></div>
</div>
<p>This returns false, because the <code>editor</code> element does
not contain the token "Vera" in this exact form, i.e. without any
diacritics:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/editors contains text "Vera" using diacritics sensitive
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftstopwordoption" id="ftstopwordoption"></a>3.4.7 Stop
Word Option</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTStopWordOption" id=
"doc-xquery30-FTStopWordOption"></a>[229]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTStopWordOption">FTStopWordOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("stop" "words" <a href=
"#doc-xquery30-FTStopWords">FTStopWords</a> <a href=
"#doc-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />
| ("stop" "words" "default" <a href=
"#doc-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />
| ("no" "stop" "words")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTStopWords" id=
"doc-xquery30-FTStopWords"></a>[230]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTStopWords">FTStopWords</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" <a href=
"#doc-xquery30-URILiteral">URILiteral</a>)<br />
| ("(" <a href="#prod-xquery30-StringLiteral">StringLiteral</a>
("," <a href="#prod-xquery30-StringLiteral">StringLiteral</a>)*
")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTStopWordsInclExcl" id=
"doc-xquery30-FTStopWordsInclExcl"></a>[231]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("union" | "except") <a href=
"#doc-xquery30-FTStopWords">FTStopWords</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftstopwordoption" id="dt-ftstopwordoption" title=
"stop word option">Definition</a>: A <b>stop word option</b>
controls matching of tokens by specifying whether stop words are
used or not. Stop words are tokens in the query that match any
token in the text being searched. ] More precisely, a stop word
option defines a collection of stop words according to the rules
below. Then, in every FTWords to which the stop word option
applies, each query token is checked: if it appears (using an
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> comparison)
in the specified collection of stop words, it is considered a stop
word.</p>
<p>Normally a stop word matches exactly one token, but there may be
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> conditions,
under which a stop word may match a different number of tokens.</p>
<p>Tokens matched by stop words retain their position numbers and
are counted by <a href="#doc-xquery30-FTDistance">FTDistance</a>
and <a href="#doc-xquery30-FTWindow">FTWindow</a> filters.</p>
<p><a href="#doc-xquery30-FTStopWords">FTStopWords</a> specifies
the list of stop words either explicitly as a comma-separated list
of string literals, or by the keyword <code>at</code> followed by a
literal URI. If the URI specifies a list of stop words that is not
found in the statically known stop word lists, an error is raised
[<a href="#ERRFTST0008" title="err:FTST0008">err:FTST0008</a>].
Whether the stop word list is resolved from the statically known
stop word lists or given explicitly, no tokenization is performed
on the stop words: they are used as they occur in the list.</p>
<p>If the stop words option specifies a stop word list with a
relative URI, that relative URI is resolved to an absolute URI
using the base URI in the static context and that absolute URI is
used to identify the stop word list.</p>
<p>Multiple stop word lists may be combined using "union" or
"except". The keywords "union" and "except" are applied from left
to right. If "union" is specified, every string occurring in the
lists specified by the left-hand side or the right-hand side is a
stop word. If "except" is specified, only strings occurring in the
list specified by the left-hand side but not in the list specified
by the right-hand side are stop words.</p>
<p>The "stop words default" option specifies that an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collection
of stop words is used.</p>
<p>The "no stop words" option specifies that no stop words are
used. This is equivalent to specifying an empty list of stop
words.</p>
<p>The default is "no stop words".</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Some implementations may apply stop word lists during indexing
and be unable to comply with query-time requests to not apply those
stop words. An implementation may still support stop-word options
(and therefore not raise [<a href="#ERRFTST0006" title=
"err:FTST0006">err:FTST0006</a>]) by applying any additional stop
words specified in the query. Pre-application of irrevocable stop
word lists falls under implementation-defined tokenization behavior
in this case, and a query that specifies "no stop words" may still
have some words ignored. <span>In addition, an implementation that
applies irrevocable stop word lists at indexing time may therefore,
as part of the implementation-defined tokenization, fail to count
those stop words in the token counts. Since the query strings will
be tokenized in accordance with the same rules, those stop words
would likewise not count in the position counts for the query
string. Thus, irrevocable stop words of this sort are invisible to
the normal rules of full-text matching defined in this
specification, and are handled purely as a tokenization issue. The
examples in this specification assume that stop words are not
removed at tokenization in this way.</span></p>
</div>
<p>The following expression returns true, because the document
contains the phrase "propagating few errors":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]//p contains text "propagating of errors"
using stop words ("a", "the", "of") 
</pre></div>
</div>
<p>Note the asymmetry in the stop word semantics: the property of
being a stop word is only relevant to query terms, not to document
terms. Hence, it is irrelevant for the above-mentioned match
whether "few" is a stop word or not, and on the other hand we do
not want the query above to match "propagating" followed by 2 stop
words, or even a sequence of 3 stop words in the document.</p>
<p>Similarly, the following expression also returns true, because
the document contains the text "completion, while propagating few
errors":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]//p contains text "in the propagating of"
using stop words ("a", "in", "the", "of")
</pre></div>
</div>
<p>This expression, however, returns false, because the p element
in the document ends with "errors." so there are not enough tokens
to match the stop words in the query:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]//p contains text "propagating few errors of the"
using stop words ("a", "in", "the", "of")
</pre></div>
</div>
<p>The following expression returns false. In this case specifying
"few" as a stop word has no effect, since "few" does not appear in
the query. Although the words "propagating" and "errors" appear in
the text being searched, the phrase "propagating errors" cannot be
matched, since that phrase does not occur.</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]//p contains text "propagating errors" 
using stop words ("few")
</pre></div>
</div>
<p>The following expression returns false, because "of" is not in
the <code>p</code> element between "propagating" and "errors":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1"]//p contains text "propagating of errors" 
using no stop words
</pre></div>
</div>
<p>The following expression uses the stop words list specified at
the URL. Assuming that the specified stop word list contains the
word "then", this query is reduced to a query on the phrase
"planning X conducting", allowing any token as a substitute for X.
It returns a <code>book</code> element, because its
<code>content</code> element contains "planning then conducting".
It would also return the <code>book</code> if the phrases "planning
and conducting" and "planning before conducting" had been in its
<code>content</code>:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content contains text "planning then 
conducting" using stop words at 
"http://bstore1.example.com/StopWordList.xml"]
</pre></div>
</div>
<p>The following expression returns <code>book</code>s containing
"planning then conducting", but not does not return
<code>book</code>s containing "planning and conducting", since it
is exempting "then" from being a stop word:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content contains text "planning then conducting"
using stop words at "http://bstore1.example.com/StopWordList.xml"
except ("the", "then")]
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftextensionoption" id="ftextensionoption"></a>3.4.8
Extension Option</h4>
<p>[<a name="dt-ftextensionoption" id="dt-ftextensionoption" title=
"extension option">Definition</a>: An <b>extension option</b> is a
match option that acts in an <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a> way.
]</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTExtensionOption" id=
"doc-xquery30-FTExtensionOption"></a>[234]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTExtensionOption">FTExtensionOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"option" <a href="#prod-xquery30-EQName">EQName</a>
<a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p>An extension option consists of an identifying QName and a
StringLiteral. Typically, a particular option will be recognized by
some implementations and not by others. The syntax is designed so
that option declarations can be successfully parsed by all
implementations.</p>
<p>The QName of an extension option must resolve to a namespace URI
and local name, using the statically known namespaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no default namespace for options.</p>
</div>
<p>Each implementation recognizes an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs used to denote extension options.</p>
<p>If the namespace part of the QName is not a namespace recognized
by the implementation as one used to denote extension option, then
the extension option is ignored.</p>
<p>Otherwise, the effect of the extension option, including its
error behavior, is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. For
example, if the local part of the QName is not recognized, or if
the StringLiteral does not conform to the rules defined by the
implementation for the particular extension option, the
implementation may choose whether to report an error, ignore the
extension option, or take some other action.</p>
<p>Implementations may impose rules on where particular extension
options may appear relative to other match options, and the
interpretation of an option declaration may depend on its
position.</p>
<p>An extension option must not be used to change the syntax
accepted by the processor, or to suppress the detection of static
errors. However, it may be used without restriction to modify the
set of tokens in the query or how they are matched against tokens
in the text being searched. An extension option has the same scope
as other match options.</p>
<p>The following examples illustrate several possible uses for
extension options:</p>
<p>This extension option is set as part of the static context of
all full-text expressions in the module and might be used to ensure
that queries are insensitive to Arabic short-vowels.</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";

declare ft-option using option exq:diacritics "short-vowel insensitive";
</pre></div>
<p>This extension option applies only to the matching in the
full-text selection in which it is found and might be used to
specify how compound words should be matched.</p>
<div class="xquery">
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";

//para[. contains text
         ("Kinder" ftand "Platz" distance exactly 1 words)
         using stemming
         using option exq:compounds "distance=1" ]
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="logical_ftoperators" id="logical_ftoperators"></a>3.5
Logical Full-Text Operators</h3>
<p>Full-text selections can be combined with the logical
connectives <code>ftor</code> (full-text or), <code>ftand</code>
(full-text and), <code>not in</code> (mild not), and
<code>ftnot</code> (unary full-text not).</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTOr" id=
"doc-xquery30-FTOr"></a>[201]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTOr">FTOr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTAnd">FTAnd</a> ( "ftor" <a href=
"#doc-xquery30-FTAnd">FTAnd</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTAnd" id=
"doc-xquery30-FTAnd"></a>[202]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTAnd">FTAnd</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTMildNot">FTMildNot</a> ( "ftand"
<a href="#doc-xquery30-FTMildNot">FTMildNot</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTMildNot" id=
"doc-xquery30-FTMildNot"></a>[203]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTMildNot">FTMildNot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTUnaryNot">FTUnaryNot</a> ( "not"
"in" <a href="#doc-xquery30-FTUnaryNot">FTUnaryNot</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTUnaryNot" id=
"doc-xquery30-FTUnaryNot"></a>[204]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTUnaryNot">FTUnaryNot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ftnot")? <a href=
"#doc-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="sec-ftor" id="sec-ftor"></a>3.5.1 Or-Selection</h4>
<p>[<a name="dt-or-selection" id="dt-or-selection" title=
"or-selection">Definition</a>: An <b>or-selection</b> combines two
full-text selections using the <code>ftor</code> operator.]</p>
<p>An or-selection finds all matches that satisfy at least one of
the operand full-text selections.</p>
<p>The following expression returns the <code>book</code> element
written by "Millicent":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[.//author contains text "Millicent" ftor "Voltaire"]
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="sec-ftand" id="sec-ftand"></a>3.5.2 And-Selection</h4>
<p>[<a name="dt-and-selection" id="dt-and-selection" title=
"and-selection">Definition</a>: An <b>and-selection</b> combines
two full-text selections using the <code>ftand</code>
operator.]</p>
<p>An and-selection finds matches that satisfy all of the operand
full-text selections simultaneously. A match of an and-selection is
formed by combining matches for each of the operand full-text
selections as described in <a href="#tq-ft-fs-FTAnd"><b>4.2.6.2
FTAnd</b></a>.</p>
<p>For example, <code>"usability" ftand "testing"</code> will find
two matches in <code>//book[@number="1"]/title</code>: each of the
two matches for the FTWords selection <code>"usability"</code> (the
two occurrences of "usability" in the string value of the title
element) is combined with the single match for the FTWords
<code>"testing"</code> (only one occurrence of "testing" in the
title). Since the above and-selection has at least one match, the
following expression will return "true".</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"]/title contains text ("usability" ftand "testing")
</pre></div>
</div>
<p>The following expression returns false, because "Millicent" and
"Montana" are not contained by the same <code>author</code> element
in any <code>book</code> element:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book/author contains text "Millicent" ftand "Montana"
</pre></div>
</div>
<p>No <code>author</code> element in any <code>book</code> element
contains both "Millicent" and "Montana". Therefore, for any such
<code>author</code> element, there are either one match for the
FTWords <code>"Millicent"</code> and zero matches for the FTWords
<code>"Montana"</code>, or vice versa, or no matches for both of
them. In any of these cases, the and-selection will have zero
matches.</p>
</div>
<div class="div3">
<h4><a name="sec-ftmildnot" id="sec-ftmildnot"></a>3.5.3 Mild-Not
Selection</h4>
<p>[<a name="dt-mild-not-selection" id="dt-mild-not-selection"
title="mild-not selection">Definition</a>: A <b>mild-not
selection</b> combines two full-text selections using the <code>not
in</code> operator.]</p>
<p>The <code>not in</code> operator is a milder form of the
operator combination <code>ftand ftnot</code>. The selection
<code>A not in B</code> matches a token sequence that matches
<code>A</code>, but not when it is a part of a match of
<code>B</code>. In contrast, <code>A ftand ftnot B</code> only
finds matches when the token sequence contains <code>A</code> and
does not contain <code>B</code>.</p>
<p>As an example, consider a search for <code>"Mexico" not in "New
Mexico"</code>. This may return, among others, a document which is
all about "Mexico" but mentions at the end that "New Mexico was
named after Mexico". The occurrence of "Mexico" in "New Mexico" is
not considered, but other occurrences of "Mexico" are matched. Note
that this document would not be matched by the full-text selection
<code>"Mexico" ftand ftnot "New Mexico"</code>.</p>
<p>A match to a mild-not selection must contain at least one token
that satisfies the first condition and does not satisfy the second
condition. If it contains a token that satisfies both the first and
the second condition, the token is not considered as a match.</p>
<p>The following expression returns true, because "usability"
appears in the <code>title</code> and the <code>p</code> elements
and the token within the phrase "Usability Testing" in the
<code>title</code> element is not considered:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book contains text "usability" not in "usability testing"
</pre></div>
</div>
<p>If either operand of a mild-not selection yields an
<b>AllMatches</b> that contains a <b>Match</b> that contains a
<b>StringExclude</b>, then a dynamic error [<a href="#ERRFTDY0017"
title="err:FTDY0017">err:FTDY0017</a>] is raised.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This situation can arise if the operand contains a not-selection
or a cardinality constraint (<a href=
"#doc-xquery30-FTTimes">FTTimes</a>) involving
<code>exactly</code>, <code>at most</code>, or <code>from ...
to</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="sec-ftnot" id="sec-ftnot"></a>3.5.4 Not-Selection</h4>
<p>[<a name="dt-unary-not-selection" id="dt-unary-not-selection"
title="not-selection">Definition</a>: A <b>not-selection</b> is a
full-text selection starting with the prefix operator
<code>ftnot</code>.]</p>
<p>A not-selection selects matches that do not satisfy the operand
full-text selection. Details about how such matches are constructed
are given in <a href="#tq-ft-fs-FTUnaryNot"><b>4.2.6.3
FTUnaryNot</b></a>.</p>
<p>The following expression returns the empty sequence, because all
<code>book</code> elements contain "usability":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[. contains text ftnot "usability"]
</pre></div>
</div>
<p>The following expression returns true, because <code>book</code>
elements contain "improving" and "usability" but not "improving
usability":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book contains text "improving" ftand
"usability" ftand ftnot "improving usability"
</pre></div>
</div>
<p>The following expression returns <code>book</code> elements
containing "web site usability" but not "usability testing":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[title/@shortTitle contains text "web site usability" ftand 
ftnot "usability testing"]
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="ftposfilter" id="ftposfilter"></a>3.6 Positional
Filters</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTPosFilter" id=
"doc-xquery30-FTPosFilter"></a>[213]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTPosFilter">FTPosFilter</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTOrder">FTOrder</a> | <a href=
"#doc-xquery30-FTWindow">FTWindow</a> | <a href=
"#doc-xquery30-FTDistance">FTDistance</a> | <a href=
"#doc-xquery30-FTScope">FTScope</a> | <a href=
"#doc-xquery30-FTContent">FTContent</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ftposfilter" id="dt-ftposfilter" title=
"positional filter">Definition</a>: <b>Positional filters</b> are
postfix operators that serve to filter matches based on various
constraints on their positional information.]</p>
<p>Recall that the grammar rule for <a href=
"#doc-xquery30-FTSelection">FTSelection</a> allows an arbitrary
number of positional filters to follow an <a href=
"#doc-xquery30-FTOr">FTOr</a>. In a group of multiple adjacent
positional filters, <a href="#doc-xquery30-FTOrder">FTOrder</a>
filters are applied first, and then the other positional filters
are applied from left to right, skipping the <a href=
"#doc-xquery30-FTOrder">FTOrder</a> filters. That is, the first
filter is applied to the result of the <a href=
"#doc-xquery30-FTOr">FTOr</a>, the second is applied to the result
of that first application, and so on.</p>
<p>An <a href="#doc-xquery30-FTOr">FTOr</a> consists of one or more
<a href="#doc-xquery30-FTAnd">FTAnd</a>s (separated by
<code>ftor</code>), each of which could be an <a href=
"#doc-xquery30-FTPosFilter">FTPosFilter</a> applied to an embedded
FTOr, enclosed in parentheses.</p>
<div class="div3">
<h4><a name="ftorder" id="ftorder"></a>3.6.1 Ordered Selection</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTOrder" id=
"doc-xquery30-FTOrder"></a>[214]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTOrder">FTOrder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ordered-selection" id="dt-ordered-selection" title=
"ordered selection">Definition</a>: An <b>ordered selection</b>
consists of a full-text selection followed by the postfix operator
"ordered".] An ordered selection constrains the order of tokens and
phrases to be the same as the order in which they are written in
the operand selection.</p>
<p>The default is unordered. Unordered is in effect when ordered is
not specified in the query. Unordered cannot be written explicitly
in the query.</p>
<p>An ordered selection selects matches which satisfy the operand
full-text selection and which also satisfy the following
constraint: the order that the matching tokens or phrases have in
the text being searched is the same order that the corresponding
query tokens or phrases have in the operand selection. In both
cases, the ordering is determined from the minimum start positions
of the constituent tokens.</p>
<p>The following expression returns true, because titles of
<code>book</code> elements contain "web site" and "usability" in
the order in which they are written in the query, i.e., "web site"
must precede "usability":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book/title contains text ("web site" ftand "usability") ordered
</pre></div>
</div>
<p>The following expression returns false, because although
"Montana" and "Millicent" both appear in the <code>book</code>
element, they do not appear in the order they are written in the
query:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[@number="1"] contains text ("Montana" ftand "Millicent") ordered
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="ftwindow" id="ftwindow"></a>3.6.2 Window
Selection</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTWindow" id=
"doc-xquery30-FTWindow"></a>[215]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTWindow">FTWindow</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"window" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a> <a href=
"#doc-xquery30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTUnit" id=
"doc-xquery30-FTUnit"></a>[217]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTUnit">FTUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"words" | "sentences" | "paragraphs"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-window-selection" id="dt-window-selection" title=
"window selection">Definition</a>: A <b>window selection</b>
consists of a full-text selection followed by one of the (complex)
postfix operators derived from <a href=
"#doc-xquery30-FTWindow">FTWindow</a>.] A window selection selects
matches which satisfy the operand full-text selection and for which
the matched tokens and phrases, more precisely the individual
StringIncludes of that match, are found within a number of <a href=
"#doc-xquery30-FTUnit">FTUnit</a>s (words, sentences, and
paragraphs). The number of <a href=
"#doc-xquery30-FTUnit">FTUnit</a>s is specified by an AdditiveExpr
that is converted as though it were an argument to a function with
the expected type of <code>xs:integer</code>.</p>
<p>A window selection may cross element boundaries. The size of the
window is not affected by the presence or absence of element
boundaries. Stop words are included in the computation of the
window size whether they are ignored by the query or not.</p>
<p>A window selection examines the matches generated by the
preceding portion of the <a href=
"#doc-xquery30-FTSelection">FTSelection</a>, and selects those for
which the matched tokens and phrases (more precisely, the
individual StringIncludes of that match) are all found within a
window whose size is a specified number of FTUnits (words,
sentences, or paragraphs); for each such window, the window
selection then generates a match containing the merge of those
StringIncludes, plus any StringExcludes that fall within the
window.</p>
<p>The following expression returns true, because "web", "site",
and "usability" are within a window of 5 tokens in the
<code>title</code> element:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book/title contains text "web" ftand "site"
ftand "usability" window 5 words
</pre></div>
</div>
<p>The following expression returns true, because "web" and "site"
in the order they are written in the query and either "usability"
or "testing" are within a window of at most 10 tokens:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book contains text ("web" ftand "site" ordered)
ftand ("usability" ftor "testing") window 10 words
</pre></div>
</div>
<p>The following expression returns false, because the instances of
"web site" and "usability" in the <code>title</code> element are
not within a window of 3. The phrase "Web Site Usability" in the
attribute does not apply because the attribute is not part of the
string value of the node. A similar query with a window of 5 would
return true.</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book//title contains text "web site" ftand
"usability" window 3 words
</pre></div>
</div>
<p>The following expression returns the sample <code>book</code>
element, because its <code>number</code> attribute is 1 and it
contains a window of 2 words which contains an occurrence of
"efficient" but not an occurrence of "and". There is just one such
matching window in the sample text and it contains "enable
efficient".</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1" and . contains text "efficient" 
ftand ftnot "and" window 2 words]
</pre></div>
</div>
<p>The following expression returns the empty sequence, because in
the selected <code>book</code> element, there is no occurrence of
"efficient" within a window of 3 tokens which would not also
contain an occurrence of "and":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[@number="1" and . contains text "efficient" 
ftand ftnot "and" window 3 words]
</pre></div>
</div>
<p>In order to allow meaningful results for nested positional
filters, e.g., a window selection embedded inside a distance
selection, the resulting matches for window selections are formed
from the input matches that satisfy the window constraint as
follows. All StringIncludes of such a match are coerced into a
single StringInclude that spans all token positions from the
smallest to the largest position of any input StringIncludes. This
is explained in more detail in Section <a href=
"#ftdistance"><b>3.6.3 Distance Selection</b></a>.</p>
</div>
<div class="div3">
<h4><a name="ftdistance" id="ftdistance"></a>3.6.3 Distance
Selection</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTDistance" id=
"doc-xquery30-FTDistance"></a>[216]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTDistance">FTDistance</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"distance" <a href="#doc-xquery30-FTRange">FTRange</a>
<a href="#doc-xquery30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTRange" id=
"doc-xquery30-FTRange"></a>[212]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTRange">FTRange</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "least" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "most" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("from" <a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a>
"to" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-distance-selection" id="dt-distance-selection"
title="distance selection">Definition</a>: A <b>distance
selection</b> consists of a full-text selection followed by one of
the (complex) postfix operators derived from <a href=
"#doc-xquery30-FTDistance">FTDistance</a>.]</p>
<p>A distance selection selects matches which satisfy the operand
full-text selection and for which the matched tokens and phrases
satisfy the specified distance conditions.</p>
<p>Distances in the search context are measured in units of tokens,
sentences, or paragraphs. Roughly speaking, the distance between
two matches is the number of intervening units, so a distance of
zero tokens (sentences, paragraphs) means no intervening tokens
(sentences, paragraphs). More precisely, given two matches, we
first determine their order by sorting on starting position and if
necessary on ending position. Let M1 be the "earlier" and M2 be the
"later". (If there are overlapping tokens involved, the
designations "earlier" and "later" may not be intuitively obvious.)
Then the distance between the two is M2's starting position minus
M1's ending position, minus 1.</p>
<p>When computing distances in the search context, a distance
selection may cross element boundaries; they affect the distance
computed only to the extent that they affect the tokenization of
the search context. Stop words are counted in those computations
whether they are ignored or not.</p>
<p>When a distance selection applies a distance condition to more
than two matches, the distance condition is required to hold on
each successive pair of matches.</p>
<p>An <a href="#doc-xquery30-FTDistance">FTDistance</a> expresses a
distance condition in terms of an <a href=
"#doc-xquery30-FTUnit">FTUnit</a> and an <a href=
"#doc-xquery30-FTRange">FTRange</a>. An <a href=
"#doc-xquery30-FTUnit">FTUnit</a> can be <code>words</code>,
<code>sentences</code>, or <code>paragraphs</code>, where
<code>words</code> refers to a distance measured in tokens.</p>
<p>An <a href="#doc-xquery30-FTRange">FTRange</a> specifies a range
of integer values by providing a minimum and/or maximum value for
some integer quantity. (Here, where the FTRange appears in an
FTDistance, that quantity is a distance. When it appears in an
FTTimes, the quantity is a number of occurrences.) Each one of the
AdditiveExpr specified in an <a href=
"#doc-xquery30-FTRange">FTRange</a> is converted as though it were
an argument to a function with the expected parameter type of
<code>xs:integer</code>.</p>
<p>Let the value of the first (or only) operand be M. If "from" is
specified, let the value of the second operand be N.</p>
<p>If "exactly" is specified, then the range is the closed interval
[M, M]. If "at least" is specified, then the range is the
half-closed interval [M, unbounded). If "at most" is specified,
then the range is the half-closed interval (unbounded, M]. If
"from-to" is specified, then the range is the closed interval [M,
N]. Note: If M is greater than N, the range is empty.</p>
<p>Here are some examples of <a href=
"#doc-xquery30-FTRange">FTRange</a>s:</p>
<ol class="enumar">
<li>
<p>'exactly 0' specifies the range [0, 0].</p>
</li>
<li>
<p>'at least 1' specifies the range [1,unbounded).</p>
</li>
<li>
<p>'at most 1' specifies the range (unbounded, 1].</p>
</li>
<li>
<p>'from 5 to 10' specifies the range [5, 10].</p>
</li>
</ol>
<p>The following expression returns false, because "completion" and
"errors" are less than 11 tokens apart:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book contains text ("completion" ftand "errors" 
distance at least 11 words)
</pre></div>
</div>
<p>The following expression returns true:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book contains text "web" ftand "site" ftand
"usability" distance at most 2 words
</pre></div>
</div>
<p>The search context contains two occurrences of the phrase "the
usability of a web site" (once in the &lt;title&gt; and once in the
&lt;content&gt;). In this phrase, the tokens "usability" and "web"
have a distance of 2 words, and the tokens "web" and "site" have a
distance of 0 words, both of which satisfy the constraint
<code>distance at most 2 words</code>. (The tokens "usability" and
"site" have a distance of 3 words, but this does not cause the
distance filter to fail, because these are not successive matches.)
Thus, the full-text selection yields two matches, and the whole
expression yields true. (The phrase "Improving Web Site Usability"
would also satisfy the given full-text selection, but in the sample
document it occurs in an attribute value, and so does not
contribute to the string value or the tokenization of the book
element.)</p>
<p>The following expression returns the empty sequence, because
between any token "usability" and the token in any occurrence of
the phrase "web site" that is the nearest to the token "usability"
there is always more than one intervening token:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[.//p contains text "web site"
ftand "usability" distance at most 1 words] 
</pre></div>
</div>
<p>The following expression returns the <code>book</code> title,
because for the occurrences of the tokens "web" and "users" in the
<code>note</code> element only one intervening token appears:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book[. contains text "web"
ftand "users" distance at most 1 words]/title 
</pre></div>
</div>
<p>In order to allow meaningful results for nested positional
filters, e.g., a distance selection embedded inside another
distance selection, the resulting matches for distance selections
are formed from the input matches that satisfy the distance
constraint as follows. All StringIncludes of such a match are
coerced into a single StringInclude that spans all token positions
from the smallest to the largest position of any input
StringIncludes. Thus, a distance selection that embeds a window or
a distance selection takes the result of the embedded selection as
a single unit.</p>
<p>The following gives an example of nested distance
selections:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books/book contains text ((("richard" ftand "nixon") distance at most 2 words) 
                   ftand 
                   (("george" ftand "bush") distance at most 2 words) 
                  distance at least 20 words)
</pre></div>
</div>
<p>This expression allows to find <code>book</code> elements that
contain, for instance, "Richard M. Nixon" and "George W. Bush" at
least 20 words apart. The matches for the inner distance selections
are treated as single units (represented by StringIncludes) by the
outer distance selection. Suppose such phrases are present in the
search context, then the outer distance selection enforces a
constraint on the number of intervening tokens ("at least 20")
between the last token of "Richard M. Nixon" and the first token of
"George W. Bush".</p>
</div>
<div class="div3">
<h4><a name="ftscope" id="ftscope"></a>3.6.4 Scope Selection</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTScope" id=
"doc-xquery30-FTScope"></a>[218]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTScope">FTScope</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("same" | "different") <a href=
"#doc-xquery30-FTBigUnit">FTBigUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTBigUnit" id=
"doc-xquery30-FTBigUnit"></a>[219]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTBigUnit">FTBigUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sentence" | "paragraph"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-scope-selection" id="dt-scope-selection" title=
"scope selection">Definition</a>: A <b>scope selection</b> consists
of a full-text selection followed by one of the (complex) postfix
operators derived from <a href=
"#doc-xquery30-FTScope">FTScope</a>.]</p>
<p>A scope selection selects matches which satisfy the operand
full-text selection and for which the matched tokens and phrases
are contained in the same scope or in different scopes.</p>
<p>Possible scopes are sentences and paragraphs.</p>
<p>By default, there are no restrictions on the scope of the
matches.</p>
<p>The following expression returns false, because the tokens
"usability" and "Marigold" are not contained within the same
sentence:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book contains text "usability" ftand "Marigold" same sentence
</pre></div>
</div>
<p>The following expression returns true, because the tokens
"usability" and "Marigold" are contained within different
sentences:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book contains text "usability" ftand "Marigold" different sentence
</pre></div>
</div>
<p>The following expression returns a <code>book</code> element,
because it contains "usability" and "testing" in the same
paragraph:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[. contains text "usability" ftand "testing" same paragraph] 
</pre></div>
</div>
<p>The following expression returns a <code>book</code> element,
because "site" and "errors" appear in the same sentence:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
//book[. contains text "site" ftand "errors" same sentence] 
</pre></div>
</div>
<p>It is possible that both "same sentence" and "different
sentence" conditions are simultaneously safisfied for several
tokens and/or phrases within the same document fragment. This can
be observed if there are occurrences of the tokens and/or phrases
both within the same sentence and within difference sentences. For
example, consider the following document fragment.</p>
<div class="exampleInner">
<pre>
&lt;introduction&gt;
... The usability of a Web site is how well the site supports the user in
achieving specified goals. ... Expert reviews and usability testing are methods of
identifying problems in layout, terminology, and navigation. ...
&lt;/introduction&gt;
</pre></div>
<p>This sample will satisfy both conditions <code>("usability"
ftand "reviews") different sentence</code> and <code>("usability"
ftand "reviews") same sentence</code>. The tokens "usability" and
"reviews" occur both in different sentences (the first and second
shown sentences) and in the same sentence (the second shown
sentences.)</p>
<p>The above observation also holds for the "same paragraph" and
"different paragraph" conditions.</p>
</div>
<div class="div3">
<h4><a name="ftcontent" id="ftcontent"></a>3.6.5 Anchoring
Selection</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTContent" id=
"doc-xquery30-FTContent"></a>[220]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTContent">FTContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" "start") | ("at" "end") | ("entire"
"content")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-anchoring-selection" id="dt-anchoring-selection"
title="anchoring selection">Definition</a>: An <b>anchoring
selection</b> consists of a full-text selection followed by one of
the postfix operators "at start", "at end", or "entire
content".]</p>
<p>An anchoring selection selects matches which satisfy the operand
full-text selection and for which the matched tokens and phrases
are the first, last, or all tokens in the tokenized form of the
items being searched.</p>
<ul>
<li>
<p>Using the "at start" operator, tokens or phrases are matched, if
they cover the first token position in the tokenized string value
of the item being searched.</p>
</li>
<li>
<p>Using the "at end" operator, tokens or phrases are matched, if
they cover the last token position in the tokenized string value of
the item being searched.</p>
</li>
<li>
<p>Using the "entire content" operator, tokens or phrases are
matched, if they cover all token positions of the tokenized string
value of the item being searched.</p>
</li>
</ul>
<p>The following expression returns each <code>title</code> element
starting with the phrase "improving the usability of a web
site":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books//title[. contains text "improving the usability
of a web site" at start]
</pre></div>
</div>
<p>The following expression returns the <code>p</code> element of
the sample, because it ends with the phrase "propagating few
errors":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books//p[. contains text "propagat.*" using wildcards ftand "few
errors" distance at most 2 words at end]
</pre></div>
</div>
<p>Since the distance operator doesn't imply an ordering, the last
example would also yield a match if the <code>p</code> element
ended with, say, "few errors are propagated".</p>
<p>The following expression returns each <code>note</code> element
whose entire content is "this book has been approved by the web
site users association":</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books//note[. contains text "this book has been
approved by the web site users association" entire content]
</pre></div>
</div>
<p>The following example returns true because both the
<code>content</code> and the <code>note</code> elements match:</p>
<div class="xpath">
<div class="exampleInner">
<pre>
/books//* contains text "Association" at end
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="ftignoreoption" id="ftignoreoption"></a>3.7 Ignore
Option</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTIgnoreOption" id=
"doc-xquery30-FTIgnoreOption"></a>[235]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTIgnoreOption">FTIgnoreOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"without" "content" <a href=
"#prod-xquery30-UnionExpr">UnionExpr</a></code></td>
</tr>
</tbody>
</table>
<p>The <b>ignore option</b> specifies a set of nodes whose contents
are ignored. It is applicable only to a top-level <a href=
"#doc-xquery30-FTSelection">FTSelection</a> (see <a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a>). [<a name=
"IgnoredNodesDef" id="IgnoredNodesDef" title=
"IgnoredNodes">Definition</a>: <b>Ignored nodes</b> are the set of
nodes whose content are ignored.] Ignored nodes are identified by
the XQuery expression UnionExpr. The value of the UnionExpr must be
a sequence of zero or more nodes; otherwise a type error is raised
[<a href="http://www.w3.org/TR/xpath-30/#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]<sup><small>XP30</small></sup>.</p>
<p>Let <code>I1, I2, ..., In</code> be the sequence of items of the
search context and let <code>N1, N2, ..., Nk</code> be the sequence
of nodes that UnionExpr evaluates to. For each <code>Ij
(j=1..n)</code> a copy is made that omits each node <code>Ni
(i=1..k)</code>. Those copies form the new search context. If
UnionExpr evaluates to an empty sequence no nodes are omitted.</p>
<p>In the following fragment, if <code>$x//annotation</code> is
ignored, "Web Usability" will be found 2 times: once in the
<code>title</code> element and once in the <code>editor</code>
element. The 2 occurrences in the 2 <code>annotation</code>
elements are ignored. On the other hand, "expert" will not be
found, as it appears only in an <code>annotation</code>
element.</p>
<div class="exampleInner">
<pre>
let $x := &lt;book&gt;
   &lt;title&gt;Web Usability and Practice&lt;/title&gt;
   &lt;author&gt;Montana &lt;annotation&gt; this author is
       an expert in Web Usability&lt;/annotation&gt; Marigold
   &lt;/author&gt;
   &lt;editor&gt;Véra Tudor-Medina on Web &lt;annotation&gt; best
       editor on Web Usability&lt;/annotation&gt; Usability
   &lt;/editor&gt;
 &lt;/book&gt;
 
</pre></div>
<p>By default, no element content is ignored.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Nodes <a title="may" href="#may">MAY</a> be ignored during
indexing and during query processing. The ignore option applies
only to query processing. Whether and how indexing ignores nodes is
out of scope for this specification.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-extension-selections" id=
"id-extension-selections"></a>3.8 Extension Selections</h3>
<p>[<a name="dt-extension-selection" id="dt-extension-selection"
title="extension selection">Definition</a>: An <b>extension
selection</b> is a full-text selection whose semantics are
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.]
Typically, a particular extension will be recognized by some
implementations and not by others. The syntax is designed so that
extension selections can be successfully parsed by all
implementations, and so that fallback behavior can be defined for
implementations that do not recognize a particular extension.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-FTExtensionSelection" id=
"doc-xquery30-FTExtensionSelection"></a>[209]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTExtensionSelection">FTExtensionSelection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Pragma">Pragma</a>+ "{" <a href=
"#doc-xquery30-FTSelection">FTSelection</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-Pragma" id=
"doc-xquery30-Pragma"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Pragma">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xquery30-S">S</a>? <a href=
"#prod-xquery30-EQName">EQName</a> (<a href=
"#prod-xquery30-S">S</a> <a href=
"#doc-xquery30-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery30-PragmaContents" id=
"doc-xquery30-PragmaContents"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PragmaContents">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
</table>
<p>An extension selection consists of one or more pragmas followed
by a full-text selection enclosed in curly braces. See <a href=
"http://www.w3.org/TR/xquery/#id-extension-expressions">Section
3.14 Extension Expressions</a><sup><small>XQ</small></sup> for
information on pragmas in general. A pragma is denoted by the
delimiters <code>(#</code> and <code>#)</code>, and consists of an
identifying QName followed by <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>
content. The content of a pragma may consist of any string of
characters that does not contain the ending delimiter
<code>#)</code>. The QName of a pragma must resolve to a namespace
URI and local name, using the statically known namespaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since there is no default namespace for pragmas, a pragma QName
must include a namespace prefix.</p>
</div>
<p>Each implementation recognizes an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs used to denote pragmas.</p>
<p>If the namespace part of a pragma QName is not recognized by the
implementation as a pragma namespace, then the pragma is ignored.
If all the pragmas in an <a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a> are
ignored, then full-text extension selection is just the full-text
selection enclosed in curly braces; if this full-text selection is
absent, then a static error is raised [<a href=
"http://www.w3.org/TR/xquery-30/#ERRXQST0079" title=
"err:XQST0079">err:XQST0079</a>]<sup><small>XQ30</small></sup>.</p>
<p>If an implementation recognizes the namespace of one or more
pragmas in an <a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a>, then
the value of the <a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a>,
including its error behavior, is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>. For
example, an implementation that recognizes the namespace of a
pragma QName, but does not recognize the local part of the QName,
might choose either to raise an error or to ignore the pragma.</p>
<p>It is a static error [<a href=
"http://www.w3.org/TR/xquery-30/#ERRXQST0013" title=
"err:XQST0013">err:XQST0013</a>]<sup><small>XQ30</small></sup> if
an implementation recognizes a pragma but determines that its
content is invalid.</p>
<p>If an implementation recognizes a pragma, it must report any
static errors in the following full-text selection even if it will
not apply that selection.</p>
<p>The following examples illustrate three ways in which extension
selections might be used.</p>
<p>A pragma can be used to furnish a hint for how to evaluate the
following full-text selection, without actually changing the
result. For example:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book/author[name contains text (# exq:use-index #) {'Berners-Lee'}]
</pre></div>
</div>
<p>An implementation that recognizes the <code>exq:use-index</code>
pragma might use an index to evaluate the full-text selection that
follows. An implementation that does not recognize this pragma
would evaluate the full-text selection in its normal way.</p>
<p>A pragma might be used to modify the semantics of the following
full-text selection in ways that would not (in the absence of the
pragma) be conformant with this specification. For example, a
pragma might be used to change distance counting so that adjacent
words are at a distance of 1 (otherwise they would be at a distance
of 0):</p>
<div class="xquery">
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book[.//p contains text (# exq:distance #) { "web site"
ftand "usability" distance at most 1 words }]
</pre></div>
</div>
<p>Such changes to the language semantics must be scoped to the
expression contained within the curly braces following the
pragma.</p>
<p>A pragma might contain syntactic constructs that are evaluated
in place of the following full-text selection. In this case, the
following selection itself (if it is present) provides a fallback
for use by implementations that do not recognize the pragma. For
example:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";

//city[. contains text (# exq:classifier with class 'Animals' #) 
       {"animal" using thesaurus at "http://example.org/thesaurus.xml" 
        relationship "RT"}]
</pre></div>
</div>
<p>Here an implementation that recognizes the pragma will return
the result of evaluating the proprietary syntax <code>with class
'animals'</code>, while an implementation that does not recognize
the pragma will instead return the result of the thesaurus option.
If no fallback expression is required, or if none is feasible, then
the expression between the curly braces may be omitted, in which
case implementations that do not recognize the pragma will raise a
static error.</p>
</div>
</div>
<div class="div1">
<h2><a name="tq-semantics" id="tq-semantics"></a>4 Semantics</h2>
<p>This section describes the formal semantics of XQuery and XPath
Full Text 3.0. The figure below shows how XQuery and XPath Full
Text 3.0 integrates with XQuery <span>3.0</span> and XPath
<span>3.0</span>.</p>
<p>The following diagram represents the interaction of XQuery and
XPath Full Text 3.0 with the rest of XQuery <span>3.0</span> and
XPath <span>3.0</span>. It illustrates how full-text expressions
can be nested within XQuery <span>3.0</span> and XPath
<span>3.0</span> expressions and vice versa.</p>
<img src="images/XQueryFullTextInteraction.jpg" alt=
"XQuery and Full Text Interaction diagram" />
<ul>
<li>
<p>Step 1 represents the composability of XQuery <span>3.0</span>
and XPath <span>3.0</span> expressions and the fact that such
expressions evaluate to a sequence of XDM items. This process is
outside the scope of this document and will not be discussed
further.</p>
</li>
<li>
<p>Step 2 shows how XQuery <span>3.0</span> and XPath
<span>3.0</span> expressions can be nested within full-text
expressions. If an XQuery <span>3.0</span> and XPath
<span>3.0</span> expression is nested on the left-hand side of an
<b>FTContains</b> expression or within <b>FTWords</b>, the sequence
of XDM items that result from evaluation of that XQuery
<span>3.0</span> or XPath <span>3.0</span> expression are converted
to their tokenized form, as described in <a href=
"#TokenizationSec">Tokenization</a>. If the XQuery <span>3.0</span>
and XPath <span>3.0</span> expression is nested within another type
of <b>FTSelection</b>, the items in its result sequence are
converted to atomic values, as discussed in <a href=
"#ftselections">FTSelections</a>.</p>
</li>
<li>
<p>Step 3 represents the composability of <b>FTSelection</b>s. Each
<b>FTSelection</b> operates on zero or more <b>AllMatches</b> and
returns an <b>AllMatches</b>. The process is described in the
<a href="#FTSelectionEvalSec">Evaluation of FTSelections</a>
section.</p>
</li>
<li>
<p>Step 4 shows how XQuery and XPath Full Text 3.0 and scoring
expressions can be nested into XQuery <span>3.0</span> and XPath
<span>3.0</span> expressions. The sections <a href=
"#FTContainsSec"><b>4.3 FTContainsExpr</b></a> and <a href=
"#ScoreSec"><b>4.4 Scoring</b></a> describe how this is
achieved.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the list above and throughout the rest of this section, bold
typeface has been used to distinguish the concepts that are part of
the <a href="#AllMatchesSec">AllMatches</a> model.</p>
</div>
<p>The functions and schemas defined in this section are considered
to be within the fts: namespace (as discussed in section <a href=
"#tq-ft-namespaces"><b>1.3 A word about namespaces</b></a>). These
functions and schemas are used only for describing the semantics.
There is no requirement that an implementation of this
specification must use the functions, schemas, or algorithms
described in this section of this specification. The only
requirement is that implementations must achieve the same results
that an implementation that does use these functions, schemas, and
algorithms would achieve.</p>
<p>Note that by using XQuery <span>3.0</span> and XPath
<span>3.0</span> to specify the formal semantics, we avoid the need
to introduce new formalism. We simply reuse the formal semantics of
XQuery <span>3.0</span> and XPath <span>3.0</span>.</p>
<div class="xquery">
<div class="div2">
<h3><a name="TokenizationSec" id="TokenizationSec"></a>4.1
Tokenization</h3>
<p>[<a name="TokenizationDef" id="TokenizationDef" title=
"Tokenization">Definition</a>: Formally, <b>tokenization</b> is the
process of converting an XDM item to a collections of tokens,
taking any structural information of the item into account to
identify token, sentence, and paragraph boundaries. Each token is
assigned a starting and ending position.]</p>
<p>Tokenization, including the definition of the term "token",
<a title="should" href="#should">SHOULD</a> be <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.
Implementations <a title="should" href="#should">SHOULD</a> expose
the rules and sample results of tokenization as much as possible to
enable users to predict and interprete the results of tokenization.
Tokenization <a title="must" href="#must">MUST</a> conform to these
constraints:</p>
<ol class="enumar">
<li>
<p>Each token <a title="must" href="#must">MUST</a> consist of one
or more characters.</p>
</li>
<li>
<p>Tokenization of an item <a title="must" href="#must">MUST</a>
include only tokens derived from the string value of that item. The
string value is defined in <a href="#xpath-datamodel-30">[XQuery
and XPath Data Model (XDM) 3.0]</a> in <a href=
"http://www.w3.org/TR/xpath-datamodel/#StringValue">Section 2.6.5
String Values</a><sup><small>DM</small></sup>; for element nodes it
does not include the contents of attributes, but for attribute
nodes it does.</p>
</li>
<li>
<p>The tokenizer <a title="should" href="#should">SHOULD</a>, when
tokenizing two equal items, identify the same tokens in each. The
cases where it does not are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The starting and ending position of a token <a title="must"
href="#must">MUST</a> be integers, and the starting position
<a title="must" href="#must">MUST</a> be less than or equal to the
ending position.</p>
</li>
<li>
<p>In the tokenization of an item, consider the range of token
positions from the smallest starting position to the largest ending
position; every token position in that range must be covered by
some token in the tokenization. That is, for every token position
<code>P</code>, there must exist some token <code>T</code> such
that <code>T's starting position &lt;= P &lt;= T's ending
position</code>.</p>
</li>
<li>
<p>The tokenizer <a title="must" href="#must">MUST</a> preserve the
containment hierarchy (paragraphs contain sentences contain tokens)
by adhering to the following constraints:</p>
<ol class="enumla">
<li>
<p>Each token is contained in at most one sentence and at most one
paragraph. (In particular, this means that no tokens of any
sentence are contained in any other sentence, and no tokens of any
paragraph are contained in any other paragraph.)</p>
</li>
<li>
<p>All tokens of a sentence are contained in at most one
paragraph.</p>
</li>
<li>
<p>The range of token positions from the smallest starting position
to the largest ending position in a sentence does not overlap with
the token position range from any other sentence.</p>
</li>
<li>
<p>The range of token positions from the smallest starting position
to the largest ending position in a paragraph does not overlap with
the token position range from any other paragraph.</p>
</li>
</ol>
</li>
</ol>
<p>Useful information for tokenizer implementors may be found in
<a href="#UAX29">[UAX29]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Usually, the starting and ending positions of a token are the
same. For some languages, some tokenizers may identify overlapping
tokens. For example, the German word
"Donaudampfschifffahrtskapitaensmuetze" might be tokenized into the
following tokens: "Donaudampfschifffahrtskapitaensmuetze", "Donau",
"dampf", "schiff", "dampfschiff", "kapitaen", "muetze",
"kapitaensmuetze", "schifffahrt", "dampfschifffahrt", and perhaps
others. In the face of overlapping tokens, it is
implementation-dependent what positions a tokenizer assigns to each
such token. For example, a tokenizer might assign the same position
value to each of the tokens
"Donaudampfschifffahrtskapitaensmuetze", "Donau", "dampf",
"schiff", "dampfshiff", etc. In that case, the distance between
each (overlapping) token assigned the same position is -1.
Tokenizers might retain additional information about those
overlapping tokens that allows the full-text implementation to
distinguish among them.</p>
<p>Consider the sentence "Ich sehe den Dampfschifffahrtskapitän auf
dem Fluß." If an implementation tokenizes
"Dampfschifffahrtskapitän" as overlapping tokens at the same
position, then the implementation could still determine that the
query "'Schifffahrt Dampf' window 0 words ordered" fails to match
the sentence because phrase matching is implementation-defined and
may make use of additional implementation-dependent token
information.</p>
<p>Even more complex situations can arise. Consider, for example,
the German sentence "Er stellte sie vor." A sophisticated tokenizer
might construct the token "vorstellen" covering positions 2 through
4, which overlaps the token "sie" at position 3. For the purposes
of distance calculations, tokens are considered in the order of
their starting positions, so the distance between "vorstellen" and
"sie" would be 3-4-1=-2. (See <code>fts:wordDistance</code>,
below.)</p>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="tq-ft-Tokenization-examples" id=
"tq-ft-Tokenization-examples"></a>4.1.1 Examples</h4>
<p>For example, the following example must return false, because
the 'secret' only occurs within an attribute and a comment, neither
of which contributes characters to the string value of the 'p'
element node:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
&lt;p kind='secret'&gt;Sensitive material &lt;!-- secret --&gt;&lt;/p&gt; contains text 'secret'

</pre></div>
</div>
<p>The following document may lead to overlapping tokens to account
for the ambiguity caused by the hyphen:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;I will re-
sign tommorow.&lt;/p&gt;

</pre></div>
<p>The following document fragment is the source document for
examples in this section. A sample tokenization is used for the
examples in this section. The results might be different for other
tokenizations.</p>
<p>Unless stated otherwise, the results assume a case-insensitive
match.</p>
<div class="exampleInner">
<pre>
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford Mustang 2000, 65K, excellent condition, runs 
        great, AC, CC, power all
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda Accord 1999, 78K, A/C, cruise control, runs 
        and looks great, excellent condition
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford Mustang, 1995, 150K highway mileage, no rust, 
        excellent condition
    &lt;/offer&gt;
&lt;/offers&gt;
        
</pre></div>
<p>In this sample tokenization, tokens are delimited by punctuation
and whitespace symbols.</p>
<ul>
<li>
<p>The token "Ford" is at relative position 1.</p>
</li>
<li>
<p>The token "Mustang" is at relative position 2.</p>
</li>
<li>
<p>The token "2000" is at relative position 3.</p>
</li>
<li>
<p>Relative position numbers are assigned sequentially through the
end of the document.</p>
</li>
</ul>
<p>Hence in this example each token occupies exactly one position,
and no overlapping of tokens occurs. The relative positions of
tokens are shown below in parentheses.</p>
<div class="exampleInner"><a name="SampleTokenizedDoc" id=
"SampleTokenizedDoc"></a>
<pre>
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford(1) Mustang(2) 2000(3), 65K(4), excellent(5)
        condition(6), runs(7) great(8), AC(9), CC(10), 
        power(11) all(12)
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda(13) Accord(14) 1999(15), 78K(16), A(17)/C(18),
        cruise(19) control(20), runs(21) and(22) looks(23)
        great(24), excellent(25) condition(26)
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford(27) Mustang(28), 1995(29), 150K(30) highway(31)
        mileage(32), little(33)  rust(34), excellent(35) 
        condition(36)
    &lt;/offer&gt;
&lt;/offers&gt;
        
</pre></div>
<p>The relative positions of paragraphs are determined similarly.
In this sample tokenization, the paragraph delimiters are start
tags and end tags.</p>
<ul>
<li>
<p>The tokens in the first 'offer' element are assigned relative
paragraph number 1.</p>
</li>
<li>
<p>The tokens from the next 'offer' element are assigned relative
paragraph number 2.</p>
</li>
<li>
<p>Relative paragraph numbers are assigned sequentially through the
end of the document.</p>
</li>
</ul>
<p>The relative positions of sentences are determined similarly
using sentence delimiters.</p>
<p>Implementations may provide for the means to ignore or side-step
certain structural elements when performing tokenization. In the
following example, the implementation has decided to ignore the
markup for <code>&lt;bold&gt;</code> and prune out the entire
subtree headed by <code>&lt;deleted&gt;</code>.</p>
<div class="exampleInner">
<pre>
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This &lt;bold&gt;entire paragraph&lt;/bold&gt; is one sentence
as far as the tokenizer is concerned.
&lt;/para&gt;
</pre></div>
<p>Using the same notation as before, this sample tokenization is
shown below. All the tokens marked with a token position also have
the same sentence and paragraph relative positions. Note that there
are no tokens marked for the ignored subtree.</p>
<div class="exampleInner">
<pre>
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This(1) &lt;bold&gt;entire(2) paragraph(3)&lt;/bold&gt; is(4) one(5) sentence(6)
as(7) far(8) as(9) the(10) tokenizer(11) is(12) concerned(13).
&lt;/para&gt;
</pre></div>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="TokenizationRepresentationsSec" id=
"TokenizationRepresentationsSec"></a>4.1.2 Representations of
Tokenized Text and Matching</h4>
<p>[<a name="QueryItemDef" id="QueryItemDef" title=
"QueryItem">Definition</a>: A <b>QueryItem</b> is a sequence of
<b>QueryTokenInfo</b>s representing the collection of tokens
derived from tokenizing one query string. ]</p>
<p>[<a name="QueryTokenInfoDef" id="QueryTokenInfoDef" title=
"QueryTokenInfo">Definition</a>: A <b>QueryTokenInfo</b> is the
identity of a token inside a query string. ] Each
<b>QueryTokenInfo</b> is associated with a position that captures
the relative position of the query string in the query.</p>
<p>[<a name="TokenInfoDef" id="TokenInfoDef" title=
"TokenInfo">Definition</a>: A <b>TokenInfo</b> represents a
contiguous collection of tokens from an XML document. ] Each
<b>TokenInfo</b> is associated with:</p>
<ul>
<li>
<p><code>startPos</code>: the smallest starting position of a token
in the sequence</p>
</li>
<li>
<p><code>endPos</code>: the largest ending position of any token of
the sequence</p>
</li>
<li>
<p><code>startSent</code>: the relative position of the sentence
containing the token with the smallest starting position or zero if
the tokenizer does not report sentences</p>
</li>
<li>
<p><code>endSent</code>: the relative position of the sentence
containing the token with the largest ending position or zero if
the tokenizer does not report sentences</p>
</li>
<li>
<p><code>startPara</code>: the relative position of the paragraph
containing the token with the smallest starting position or zero if
the tokenizer does not report paragraphs</p>
</li>
<li>
<p><code>endPara</code>: the relative position of the paragraph
containing the token with the largest ending position or zero if
the tokenizer does not report paragraphs</p>
</li>
</ul>
<p>The following matching function is the central <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> primitive
performing the full-text retrieval.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:matchTokenInfos (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $stopWords as xs:string*,
      $queryTokens as element(fts:queryToken)* )
   as element(fts:tokenInfo)*  external;
            
</pre></div>
</div>
<p>The above function returns the <b>TokenInfo</b>s in items in
<code>$searchContext</code> that match the query string represented
by the sequence <code>$queryTokens</code>, when using the match
options in <code>$matchOptions</code> and stop words in
<code>$stopWords</code>. If <code>$queryTokens</code> is a sequence
of more than one query token, each returned <b>TokenInfo</b> must
represent a phrase matching that sequence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>While this matching function assumes a tokenized representation
of the query strings, it does not assume a tokenized representation
of the input items in <code>$searchContext</code>, i.e. the texts
being searched. Hence, the tokenization of the search context is
implicit in this function and coupled to the retrieval of matches.
Of course, this does not imply that tokenization of the search
context cannot be done a priori. The tokenization of each item in
<code>$searchContext</code> does not necessarily take into account
the match options in <code>$matchOptions</code> or the query tokens
in <code>$queryTokens</code>. This allows implementations to
tokenize and index input data without the knowledge of particular
match options used in full-text queries.</p>
</div>
</div>
</div>
</div>
</div>
<div class="xquery">
<div class="div2">
<h3><a name="FTSelectionEvalSec" id="FTSelectionEvalSec"></a>4.2
Evaluation of FTSelections</h3>
<p>The XQuery <span>3.0</span> and XPath <span>3.0</span> Data
Model is inadequate to support fully composable
<b>FTSelection</b>s. Full-text operations, such as
<b>FTSelection</b>s, operate on linguistic units, such as positions
of tokens, and which are not captured in the XQuery
<span>3.0</span> and XPath <span>3.0</span> Data Model (XDM).</p>
<p>XQuery and XPath Full Text adds relative token, sentence, and
paragraph position numbers via <b>AllMatches</b>. <b>AllMatches</b>
make <b>FTSelection</b>s fully composable.</p>
<div class="xquery">
<div class="div3">
<h4><a name="AllMatchesSec" id="AllMatchesSec"></a>4.2.1
AllMatches</h4>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-formalmodel" id="tq-ft-formalmodel"></a>4.2.1.1
Formal Model</h5>
<p>[<a name="AllMatchesDef" id="AllMatchesDef" title=
"AllMatches">Definition</a>: An <b>AllMatches</b> describes the
possible results of an <b>FTSelection</b>.] The UML Static Class
diagram of <b>AllMatches</b> is shown on the diagram given
below.</p>
<img src="images/AllMatchesClassDiagram.png" alt=
"AllMatches class diagram" />
<p>The <b>AllMatches</b> object contains zero or more
<b>Match</b>es.</p>
<p>[<a name="MatchDef" id="MatchDef" title="Match">Definition</a>:
Each <b>Match</b> describes one result to the <b>FTSelection</b>.]
The result is described in terms of zero or more
<b>StringInclude</b>s and zero or more <b>StringExclude</b>s.</p>
<p>[<a name="StringMatchDef" id="StringMatchDef" title=
"StringMatch">Definition</a>: A <b>StringMatch</b> is a possible
match of a sequence of query tokens with a corresponding sequence
of tokens in a document. A StringMatch may be a
<b>StringInclude</b> or <b>StringExclude</b>.] The <b>queryPos</b>
attribute specifies the position of the query token in the query.
This attribute is needed for <b>FTOrder</b>s. The matched document
token sequence is described in the <b>TokenInfo</b> associated with
the <b>StringMatch</b>.</p>
<p>[<a name="StringIncludeDef" id="StringIncludeDef" title=
"StringInclude">Definition</a>: A <b>StringInclude</b> is a
<b>StringMatch</b> that describes a <b>TokenInfo</b> that must be
contained in the document.]</p>
<p>[<a name="StringExcludeDef" id="StringExcludeDef" title=
"StringExclude">Definition</a>: A <b>StringExclude</b> is a
<b>StringMatch</b> that describes a <b>TokenInfo</b> that must not
be contained in the document.]</p>
<p>Intuitively, <b>AllMatches</b> specifies the <b>TokenInfo</b>s
that a search context item contains and does not contain to satisfy
an <b>FTSelection</b>.</p>
<p>The <b>AllMatches</b> structure resembles the Disjunctive Normal
Form (DNF) in propositional and first-order logic. The
<b>AllMatches</b> is a disjunction of <b>Match</b>es. Each
<b>Match</b> is a conjunction of <b>StringInclude</b>s, and
<b>StringExclude</b>s.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-AllMatches-examples" id=
"tq-ft-AllMatches-examples"></a>4.2.1.2 Examples</h5>
<p>Since in most of the examples below the tokens span only a
single position, we characterize the <b>TokenInfo</b> instance by
simply giving this position, written as "Pos:X". This should be
read as the value for both, the <code>startPos</code> and the
<code>endPos</code> attribute. Furthermore, for expository reasons,
we include in each <b>StringMatch</b> example an attribute "query
string", set to the original query string, in order to facilitate
the association from which query string that match came from.</p>
<p>The simplest example of an <b>FTSelection</b> is an
<b>FTWords</b> such as <code>"Mustang"</code>. The
<b>AllMatches</b> corresponding to this <b>FTWords</b> is given
below.</p>
<img src="images/SampleAllMatches1.jpg" alt="Sample AllMatches" />
<p>As shown, the <b>AllMatches</b> consists of two <b>Match</b>es.
Each <b>Match</b> represents one possible result of the
<b>FTWords</b> <code>"Mustang"</code>. The result represented by
the first <b>Match</b>, represented as a <b>StringInclude</b>,
contains the token "Mustang" at position 2. The result described by
the second <b>Match</b> contains the token "Mustang" at position
28.</p>
<p>A more complex example of an <b>FTSelection</b> is an
<b>FTWords</b> such as <code>"Ford Mustang"</code>. The
<b>AllMatches</b> for this <b>FTWords</b> is given below.</p>
<img src="images/SampleAllMatches2.jpg" alt="Sample AllMatches" />
<p>There are two possible results for this <b>FTWords</b>, and
these are represented by the two <b>Match</b>es. Each of the
<b>Match</b>es requires two tokens to be matched. The first
<b>Match</b> is obtained by matching "Ford" at position 1 and
matching "Mustang" at position 2. Similarly, the second
<b>Match</b> is obtained by matching "Ford" at position 27 and
"Mustang" at position 28.</p>
<p>An even more complex example of an <b>FTSelection</b> is an
<b>FTSelection</b> such as <code>"Mustang" ftand ftnot
"rust"</code> that searches for "Mustang" but not "rust". The
<b>AllMatches</b> for this <b>FTSelection</b> is given below.</p>
<img src="images/SampleAllMatches3.jpg" alt="Sample AllMatches" />
<p>This example introduces <b>StringExclude</b>.
<b>StringExclude</b> corresponds to negation in DNF (Disjunctive
Normal Form). It specifies that the result described by the
corresponding <b>Match</b> must not match the token at the
specified position. In this example, the first <b>Match</b>
specifies that "Mustang" is matched at position 2, and that the
token "rust" at position 34 is not matched.</p>
</div>
</div>
<div class="div4">
<h5><a name="tq-ft-XML-representation" id=
"tq-ft-XML-representation"></a>4.2.1.3 XML representation</h5>
<p><b>AllMatches</b> has a well-defined hierarchical structure.
Therefore, the <b>AllMatches</b> can be easily modeled in XML. This
XML representation and those which follow formally describe the
semantics of <b>FTSelection</b>s. For example, the XML
representation of <b>AllMatches</b> formally specifies how an
<b>FTSelection</b> operates on zero or more <b>AllMatches</b> to
produce a resulting <b>AllMatches</b>.</p>
<p>The XML schema for representing <b>AllMatches</b> is given
below.</p>
<div class="semfunc-file-allmatches-xsd">
<div class="exampleInner">
<pre>
&lt;xs:schema 
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="allMatches"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:match" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="stokenNum" type="xs:integer" use="required" /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="allMatches" type="fts:allMatches"/&gt;

  &lt;xs:complexType name="match"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:stringInclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="fts:stringExclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="stringInclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="stringExclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="match" type="fts:match"/&gt;

  &lt;xs:complexType name="stringMatch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:tokenInfo"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="isContiguous" 
                  type="xs:boolean" 
                  use="required"/&gt;  
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="tokenInfo"&gt;
    &lt;xs:attribute name="startPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startPara" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPara" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="tokenInfo" type="fts:tokenInfo"/&gt;

  &lt;xs:complexType name="queryItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryToken" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="queryTokenInfo"&gt;
    &lt;xs:attribute name="word" 
                  type="xs:string" 
                  use="required"/&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryToken" type="fts:queryTokenInfo"/&gt;
&lt;/xs:schema&gt;
                
</pre></div>
</div>
<p>The <code>stokenNum</code> attribute in <b>AllMatches</b> is
related to the representation of the semantics as XQuery functions.
Therefore, it is not considered part of the <b>AllMatches</b>
model. The <code>stokenNum</code> attribute stores the number of
query tokens used when evaluating the <b>AllMatches</b>. This value
is used to compute the correct value for the <code>queryPos</code>
attribute in new <b>StringMatch</b>es.</p>
</div>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="FTSelectionsXMLSec" id="FTSelectionsXMLSec"></a>4.2.2
XML Representation</h4>
<p><b>FTSelection</b>s are fully composable and may be nested
arbitrarily under other <b>FTSelection</b>s. Each
<b>FTSelection</b> may be associated with match options (such as
stemming and stop words) and score weights. Since score weights are
solely interpreted by the formal semantics scoring function, they
do not influence the semantics of <b>FTSelection</b>s. Therefore,
score weights are not considered in the formal semantics.</p>
<p>The XML structures defined by the following schema represent
<b>FTSelection</b>s within the semantic functions of section
<a href="#tq-semantics"><b>4 Semantics</b></a>. This representation
is used for definitional purposes only and should not be confused
with the XML representation for queries in Appendix <a href=
"#id-xqft-xqueryx"><b>E XML Syntax (XQueryX) for XQuery and XPath
Full Text 3.0</b></a>. Every <b>FTSelection</b> is represented as
an XML element. Every nested <b>FTSelection</b> is represented as a
nested descendant element. For binary <b>FTSelection</b>s, e.g.,
<b>FTAnd</b>, the nested <b>FTSelection</b>s are represented in
<code>&lt;left&gt;</code> and <code>&lt;right&gt;</code> descendant
elements. For unary <b>FTSelection</b>s, a
<code>&lt;selection&gt;</code> descendant element is used.
Additional characteristics of <b>FTSelection</b>s, e.g., the
distance unit for <b>FTDistance</b>, are stored in attributes.</p>
<div class="semfunc-file-ftselection-xsd">
<div class="exampleInner">
<pre>
&lt;xs:schema
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;
           
  &lt;xs:include schemaLocation="AllMatches.xsd" /&gt;
  &lt;xs:include schemaLocation="MatchOptions.xsd" /&gt;

  &lt;xs:complexType name="ftSelection"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="ftWords" type="fts:ftWords"/&gt;
        &lt;xs:element name="ftAnd" type="fts:ftAnd"/&gt;
        &lt;xs:element name="ftOr" type="fts:ftOr"/&gt;
        &lt;xs:element name="ftUnaryNot" type="fts:ftUnaryNot"/&gt;
        &lt;xs:element name="ftMildNot" type="fts:ftMildNot"/&gt;
        &lt;xs:element name="ftOrder" type="fts:ftOrder"/&gt;
        &lt;xs:element name="ftScope" type="fts:ftScope"/&gt;
        &lt;xs:element name="ftContent" type="fts:ftContent"/&gt;
        &lt;xs:element name="ftDistance" type="fts:ftDistance"/&gt;
        &lt;xs:element name="ftWindow" type="fts:ftWindow"/&gt;
        &lt;xs:element name="ftTimes" type="fts:ftTimes"/&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element ref="fts:matchOptions" 
                  minOccurs="0"/&gt;
      &lt;xs:element name="weight" 
                  type="xs:double" 
                  minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="selection" type="fts:ftSelection"/&gt;

  &lt;xs:complexType name="ftWords"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryItem" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:ftWordsType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryItem" type="fts:queryItem"/&gt;
  
  &lt;xs:complexType name="ftAnd"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOr"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftUnaryNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftMildNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOrder"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftScope"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:scopeType" 
                  use="required"/&gt;
    &lt;xs:attribute name="scope" 
                  type="fts:scopeSelector" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:contentMatchType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftDistance"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftWindow"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="size" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftTimes"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftWords"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
    
  &lt;xs:simpleType name="ftWordsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="any"/&gt;
      &lt;xs:enumeration value="all"/&gt;
      &lt;xs:enumeration value="phrase"/&gt;
      &lt;xs:enumeration value="any word"/&gt;
      &lt;xs:enumeration value="all word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="same"/&gt;
      &lt;xs:enumeration value="different"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeSelector"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="distanceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
      &lt;xs:enumeration value="word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="contentMatchType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="at start"/&gt;
      &lt;xs:enumeration value="at end"/&gt;
      &lt;xs:enumeration value="entire content"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;
            
</pre></div>
</div>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="tq-ft-evaluate-function" id=
"tq-ft-evaluate-function"></a>4.2.3 The <code>evaluate</code>
function</h4>
<p>The semantics for the evaluation of <b>FTSelection</b>s is
defined using the <code>fts:evaluate</code> function. The function
takes three parameters: (1) an <b>FTSelection</b>, 2) a search
context item, and 3) the default set of match options that apply to
the evaluation of the <b>FTSelection</b>.</p>
<p>The <code>fts:evaluate</code> function returns the
<b>AllMatches</b> that is the result of evaluating the
<b>FTSelection</b>. When <code>fts:evaluate</code> is applied to
some <b>FTSelection</b> X, it calls the function
<code>fts:ApplyX</code> to build the resulting <b>AllMatches</b>.
If X is applied on nested <b>FTSelection</b>s, the
<code>fts:evaluate</code> function is recursively called on these
nested <b>FTSelection</b>s and the returned <b>AllMatches</b> are
used in the evaluation of <code>fts:ApplyX</code>.</p>
<p>The semantics for the <code>fts:evaluate</code> function is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:evaluate (
      $ftSelection as element(*, fts:ftSelection), 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokenNum as xs:integer )
   as element(fts:allMatches)
{
   if (fn:count($ftSelection/fts:matchOptions) &gt; 0) then 
      (: First we deal with all match options that the    :)
      (: FTSelection might bear: we add the match options :)
      (: to the current match options structure, and      :)
      (: pass the new structure to the recursive call.    :)
      let $newFTSelection := 
         &lt;fts:selection&gt;{$ftSelection/*
                           [fn:not(self::fts:matchOptions)]}&lt;/fts:selection&gt;
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          fts:replaceMatchOptions($matchOptions, 
                                              $ftSelection/fts:matchOptions),
                          $queryTokenNum)
   else if (fn:count($ftSelection/fts:weight) &gt; 0) then
      (: Weight has no bearing on semantics -- just :)
      (: call "evaluate" on nested FTSelection     :)
      let $newFTSelection := $ftSelection/*[fn:not(self::fts:weight)]
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          $matchOptions,
                          $queryTokenNum)
   else
      typeswitch ($ftSelection/*[1]) 
         case $nftSelection as element(fts:ftWords) return
            (: Apply the FTWords in the search context :)
            fts:ApplyFTWords($searchContext,
                             $matchOptions,
                             $nftSelection/@type,
                             $nftSelection/fts:queryItem,
                             $queryTokenNum + 1)
         case $nftSelection as element(fts:ftAnd) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTAnd($left, $right)
         case $nftSelection as element(fts:ftOr) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTOr($left, $right)
         case $nftSelection as element(fts:ftUnaryNot) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTUnaryNot($nested)
         case $nftSelection as element(fts:ftMildNot) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTMildNot($left, $right)
         case $nftSelection as element(fts:ftOrder) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTOrder($nested)
         case $nftSelection as element(fts:ftScope) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTScope($nftSelection/@type, 
                                    $nftSelection/@scope,
                                    $nested)
         case $nftSelection as element(fts:ftContent) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTContent($searchContext,
                                      $nftSelection/@type, 
                                      $nested)
         case $nftSelection as element(fts:ftDistance) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTDistance($nftSelection/@type,
                                       $nftSelection/fts:range,
                                       $nested)
         case $nftSelection as element(fts:ftWindow) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTWindow($nftSelection/@type,
                                     $nftSelection/@size,
                                     $nested)
         case $nftSelection as element(fts:ftTimes) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTTimes($nftSelection/fts:range,
                                    $nested)
         default return &lt;fts:allMatches stokenNum="0" /&gt;
};
            
</pre></div>
</div>
<p>For concreteness, assume that the <b>FTSelection</b> was invoked
inside an <code>contains text</code> expression such as
<code>searchContext contains text ftSelection</code>. In order to
determine the <b>AllMatches</b> result of <code>ftSelection</code>,
the <code>fts:evaluate</code> function is invoked as follows:
<code>fts:evaluate($ftSelection, $searchContext, $matchOptions,
0)</code>, where <code>$ftSelection</code> is the XML
representation of the <code>ftSelection</code> and
<code>$searchContext</code> is bound to the result of the
evaluation of the XQuery expression <code>searchContext</code>.</p>
<p>Initially, the <code>$queryTokensNum</code> is 0, i.e., no query
tokens have been processed.</p>
<p>The variable <code>$matchOptions</code> is bound to the list of
match options as defined in the static context (see Appendix
<a href="#id-xqft-static-context-components"><b>C Static Context
Components</b></a>). Match options embedded in
<code>$ftSelection</code> modify the match options collection as
evaluation proceeds.</p>
<p>Given the invocation of: <code>fts:evaluate($ftSelection,
$searchContext, $matchOptions)</code>, evaluation proceeds as
follows. First, <code>$ftSelection</code> is checked to see whether
1) it contains a match option, 2) it contains a weight
specification, 3) it is an <b>FTWords</b>, or 4) none of the above
hold.</p>
<ol class="enumar">
<li>
<p>If <code>$ftSelection</code> contains one or more match options,
these are combined with the inherited match options via a call to
<code>fts:replaceMatchOptions</code> (see <a href=
"#FTMatchOptionsSec"><b>4.2.5 Match Options Semantics</b></a>). The
<code>evaluate</code> function is then invoked on the nested
<b>FTSelection</b> with the new set of match options, and the
result of that call is returned.</p>
</li>
<li>
<p>If <code>$ftSelection</code> contains a weight specification,
then the specification is ignored because it does not alter the
semantics. The <code>evaluate</code> function is recursively called
on the nested <b>FTSelection</b> and the resulting
<b>AllMatches</b> is returned.</p>
</li>
<li>
<p>If <code>$ftSelection</code> is an <b>FTWords</b>, then it does
not have any nested <b>FTSelection</b>s. Consequently, this is the
base of the recursive call, and the <b>AllMatches</b> result of the
<b>FTWords</b> is computed and returned. The <b>AllMatches</b> is
computed by invoking the <code>ApplyFTWords</code> function with
the current search context and other necessary information.</p>
</li>
<li>
<p>If <code>$ftSelection</code> contains neither a match option nor
a weight specification and is not an <b>FTWords</b>, the
<b>FTSelection</b> performs a full-text operation, such as
<code>ftand</code>, <code>ftor</code>, <code>window</code>. These
operations are fully-compositional and may be invoked on nested
<b>FTSelection</b>s. Consequently, evaluation proceeds as
follows.</p>
<ul>
<li>
<p>First, the <code>evaluate</code> function is recursively invoked
on each nested <b>FTSelection</b>. The result of evaluating each
nested <b>FTSelection</b> is an <b>AllMatches</b>.</p>
</li>
<li>
<p>The <b>AllMatches</b> are transformed into the resulting
<b>AllMatches</b> by applying the full-text operation corresponding
to <code>FTSelection1</code> which is generically named
<code>applyX</code> for some type of <b>FTSelection</b> X in the
code.</p>
</li>
</ul>
<p>For example, let <code>FTSelection1</code> be <code>FTSelection2
ftand FTSelection3</code> . Here <code>FTSelection2</code> and
<code>FTSelection3</code> may themselves be arbitrarily nested
<b>FTSelection</b>s. Thus, <code>evaluate</code> is invoked on
<code>FTSelection2</code> and <code>FTSelection3</code>, and the
resulting <b>AllMatches</b> are transformed to the final
<b>AllMatches</b> using the <code>ApplyFTAnd</code> function
corresponding to <code>ftand</code> .</p>
</li>
</ol>
<p>The semantics of the <code>ApplyX</code> function for each
<b>FTSelection</b> kind X is given below.</p>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="tq-ft-fs-FTWords" id="tq-ft-fs-FTWords"></a>4.2.4
FTWords</h4>
<p>An <b>FTWords</b> that consists of a single query string
consisting of a sequence of token to be matched as a phrase is
evaluated by the <code>applyQueryTokensAsPhrase</code> function.
Its parameters are 1) the search context, 2) the list of match
options, 3) the query string to be matched as a sequence of
<code>fts:queryToken</code> items, and 4) the position where the
latter query string occurs in the query.</p>
<div class="semfunc-file-ftssimple-xquery">
<div class="exampleInner">
<pre>
(: simplified version not dealing with special match options :)
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
   {
      for $tokenInfo in
         fts:matchTokenInfos( 
            $searchContext,
            $matchOptions,
            (),
            $queryTokens )
      return  
         &lt;fts:match&gt;  
            &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
            {$tokenInfo}
            &lt;/fts:stringInclude&gt; 
         &lt;/fts:match&gt;
   } 
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>If after the application of all the match options, the sequence
of query tokens returned for an <b>FTWords</b> is empty, an empty
<b>AllMatches</b> is returned.</p>
<p>The <b>AllMatches</b> corresponding to an <b>FTWords</b> is a
set of <b>Match</b>es. Each of the <b>Match</b>es is associated
with a starting and an ending position indicating where the
corresponding query tokens were found. For example, the
<b>AllMatches</b> result for the <b>FTWords</b> "Mustang" is given
below. To simplify the presentation in the figures we write
<code>Pos: N</code>, if the attributes <code>startPos</code> and
<code>endPos</code> are the same with <code>N</code> being that
position.</p>
<img src="images/FTWordEx.jpg" alt="FTWords example" />
<p>There are five variations of <b>FTWords</b> depending on how the
tokens and phrases in the nested XQuery <span>3.0</span> and XPath
<span>3.0</span> expression are matched.</p>
<ul>
<li>
<p>When <code>any word</code> is specified, at least one token in
the tokenization of the nested expression must be matched.</p>
</li>
<li>
<p>When <code>all word</code> is specified, all tokens in the
tokenization of the nested expression must be matched.</p>
</li>
<li>
<p>When <code>phrase</code> is specified, all tokens in the
tokenization of the nested expression must be matched as a
phrase.</p>
</li>
<li>
<p>When <code>any</code> is specified, at least one string atomic
value in the nested expression must be matched as a phrase.</p>
</li>
<li>
<p>When <code>all</code> is specified, all string atomic values in
the nested expression must be matched as a phrase.</p>
</li>
</ul>
<p>The semantics for <b>FTWords</b> when <code>any word</code> is
specified is given below. Since <b>FTWords</b> does not have nested
<b>FTSelection</b>s, the <code>ApplyFTWords</code> function does
not take <b>AllMatches</b> parameters corresponding to nested
<b>FTSelection</b> results.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:MakeDisjunction (
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches) 
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTOr($curRes, 
                                      $firstAllMatches)
      return fts:MakeDisjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAnyWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query string has already occurred. :)
   (: Get sequence of QueryTokens over all query items. :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
         let $firstAllMatches := $allAllMatches[1]
         let $restAllMatches := fn:subsequence($allAllMatches, 2)
         return fts:MakeDisjunction($firstAllMatches, $restAllMatches)
};
</pre></div>
</div>
<p>The tokenized query strings are passed to ApplyFTWordsAnyWord as
a sequence of <code>fts:queryItem</code>, each containing the
tokens of a single query string. A single flattened sequence of all
tokens (of type <code>fts:queryToken</code>) over all query items
is constructed. For each of these, the result of <b>FTWords</b> is
computed using <code>applyQueryTokensAsPhrase</code>. Finally, the
disjunction of all resulting <b>AllMatches</b> is computed.</p>
<p>The semantics for <b>FTWords</b> when <code>all word</code> is
specified is similar to the above, however composes a conjunction.
It is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:MakeConjunction ( 
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches)
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTAnd($curRes, 
                                       $firstAllMatches)
      return fts:MakeConjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAllWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query strings has already occurred. :)
   (: Get sequence of QueryTokens over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
            let $firstAllMatches := $allAllMatches[1]
            let $restAllMatches := fn:subsequence($allAllMatches, 2)
            return fts:MakeConjunction($firstAllMatches, $restAllMatches)
};
</pre></div>
</div>
<p>The semantics for <b>FTWords</b> if <code>phrase</code> is
specified is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordsPhrase (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Get sequence of QueryTokenInfos over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         fts:applyQueryTokensAsPhrase($searchContext,
                                       $matchOptions,
                                       $queryTokens,
                                       $queryPos)
};
</pre></div>
</div>
<p>The <code>ApplyFTWordsPhrase</code> function also flattens the
sequence of query items to a sequence of query tokens, but then
calls <code>applyQueryTokensAsPhrase</code> on that entire
sequence, instead of calling it on each query token individually.
Hence, the sequence of all query tokens is matched as a single
phrase and the computed <b>TokenInfo</b>s are returned.</p>
<p>The semantics for <b>FTWords</b> when <code>any</code> is
specified is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordsAny (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) eq 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      let $newQueryPos := 
         if ($firstAllMatches//@queryPos) 
         then fn:max($firstAllMatches//@queryPos) + 1
         else $queryPos
      let $restAllMatches :=
         fts:ApplyFTWordsAny($searchContext,
                             $matchOptions,
                             $restQueryItem,
                             $newQueryPos)
      return fts:ApplyFTOr($firstAllMatches, $restAllMatches)
};
</pre></div>
</div>
<p>The <b>FTWords</b> with <code>any</code> specified forms the
disjunction of the <b>AllMatches</b> that are the result of the
matching of each query item as a phrase.</p>
<p>The semantics for <b>FTWords</b> when <code>all</code> is
specified is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordsAll (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) = 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      return
         if ($restQueryItem) then
            let $newQueryPos := 
               if ($firstAllMatches//@queryPos) 
               then fn:max($firstAllMatches//@queryPos) + 1
               else $queryPos
            let $restAllMatches :=
               fts:ApplyFTWordsAll($searchContext,
                                   $matchOptions,
                                   $restQueryItem,
                                   $newQueryPos)
            return 
               fts:ApplyFTAnd($firstAllMatches, $restAllMatches)
         else $firstAllMatches
};
</pre></div>
</div>
<p>The difference between <code>all</code> and <code>any</code> is
the use of conjunction instead of disjunction.</p>
<p>The <code>ApplyFTWords</code> function combines all of these
functions.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWords ( 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $type as fts:ftWordsType,
      $queryItems as element(fts:queryItem)*, 
      $queryPos as xs:integer )
   as element(fts:allMatches) 
{
   if ($type eq "any word")
   then fts:ApplyFTWordsAnyWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "all word")
   then fts:ApplyFTWordsAllWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "phrase")
   then fts:ApplyFTWordsPhrase($searchContext,
                               $matchOptions,
                               $queryItems,
                               $queryPos)
   else if ($type eq "any")
   then fts:ApplyFTWordsAny($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
   else fts:ApplyFTWordsAll($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
};
                
</pre></div>
</div>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="FTMatchOptionsSec" id="FTMatchOptionsSec"></a>4.2.5
Match Options Semantics</h4>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-types" id=
"tq-ft-matchopt-types"></a>4.2.5.1 Types</h5>
<p>XQuery <span>3.0</span> functions are used to define the
semantics of <b>FTMatchOption</b>s. These functions operate on an
XML representation of the <b>FTMatchOption</b>s. The representation
closely follows the <a href="#ftmatchoptions">syntax</a>. Each
<b>FTMatchOption</b> is represented by an XML element. Additional
characteristics of the match option are represented as attributes.
The schema is given below.</p>
<div class="exampleInner">
<pre>
&lt;xs:schema 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:fts="http://www.w3.org/2007/xpath-full-text"
    targetNamespace="http://www.w3.org/2007/xpath-full-text"
    elementFormDefault="qualified" 
    attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="ftMatchOptions"&gt;
    &lt;xs:sequence&gt;
       &lt;xs:element ref="fts:thesaurus" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stopwords" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:case" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:diacritics" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stem" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:wildcard" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:language" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="matchOptions" type="fts:ftMatchOptions"/&gt;

  &lt;xs:element name="case" type="fts:ftCaseOption" /&gt;
  &lt;xs:element name="diacritics" type="fts:ftDiacriticsOption" /&gt;
  &lt;xs:element name="thesaurus" type="fts:ftThesaurusOption" /&gt;
  &lt;xs:element name="stem" type="fts:ftStemOption" /&gt;
  &lt;xs:element name="wildcard" type="fts:ftWildCardOption" /&gt;
  &lt;xs:element name="language" type="fts:ftLanguageOption" /&gt;
  &lt;xs:element name="stopwords" type="fts:ftStopWordOption" /&gt; 

 &lt;xs:complexType name="ftCaseOption"&gt;
   &lt;xs:sequence&gt;
     &lt;xs:element name="value"&gt;
       &lt;xs:simpleType&gt;
         &lt;xs:restriction base="xs:string"&gt;
           &lt;xs:enumeration value="case insensitive"/&gt;
           &lt;xs:enumeration value="case sensitive"/&gt;
           &lt;xs:enumeration value="lowercase"/&gt;
           &lt;xs:enumeration value="uppercase"/&gt;
         &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;
     &lt;/xs:element&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftDiacriticsOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="diacritics insensitive"/&gt;
            &lt;xs:enumeration value="diacritics sensitive"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
       
  &lt;xs:complexType name="ftThesaurusOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="thesaurusName" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="relationship" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec" 
                  minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="thesaurusIndicator"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:enumeration value="using"/&gt;
          &lt;xs:enumeration value="no"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftRangeSpec"&gt;
    &lt;xs:attribute name="type" 
                  type="fts:rangeSpecType" 
                  use="required"/&gt;
    &lt;xs:attribute name="m" 
                  type="xs:integer"/&gt;
    &lt;xs:attribute name="n" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:simpleType name="rangeSpecType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="exactly"/&gt;
      &lt;xs:enumeration value="at least"/&gt;
      &lt;xs:enumeration value="at most"/&gt;
      &lt;xs:enumeration value="from to"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:complexType name="ftStemOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="stemming"/&gt;
            &lt;xs:enumeration value="no stemming"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftWildCardOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="wildcards"/&gt;
            &lt;xs:enumeration value="no wildcards"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftLanguageOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftStopWordOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="default-stopwords"&gt;
            &lt;xs:complexType /&gt;
        &lt;/xs:element&gt;
        &lt;xs:element name="stopword" type="xs:string" /&gt;
        &lt;xs:element name="uri" type="xs:anyURI" /&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element name="oper" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:choice&gt;
            &lt;xs:element name="stopword" type="xs:string" /&gt;
            &lt;xs:element name="uri" type="xs:anyURI" /&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="type"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:string"&gt;
                &lt;xs:enumeration value="union"/&gt;
                &lt;xs:enumeration value="except"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
&lt;/xs:schema&gt;            
</pre></div>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-highlevel" id=
"tq-ft-matchopt-highlevel"></a>4.2.5.2 High-Level Semantics</h5>
<p>The previous section described FTSelections without giving any
details about how <b>FTMatchOption</b>s need to be interpreted. All
processing of <b>FTMatchOption</b>s was delegated to the function
<code>matchTokenInfos</code>, which is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. In this
section, further details on the semantics of <b>FTMatchOption</b>s
are given.</p>
<p>The extension is achieved by modifying an existing function and
adding functions that are specific to the
<b>FTMatchOption</b>s.</p>
<p><em>Modifications in the semantics of existing
functions</em></p>
<p>The semantics of most of the <b>FTSelection</b>s remains
unmodified. The modifications are to the method for matching a
sequence of query tokens.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   let $thesaurusOption := $matchOptions/fts:thesaurus[1]
   return 
      if ($thesaurusOption and 
          $thesaurusOption/@thesaurusIndicator eq "using") then
         let $noThesaurusOptions := 
            &lt;fts:matchOptions&gt;{
               $matchOptions/*[fn:not(self::fts:thesaurus)]
            }&lt;/fts:matchOptions&gt;
         let $lookupRes := fts:applyThesaurusOption($thesaurusOption,
                                                    $noThesaurusOptions,
                                                    $queryTokens)            
         return fts:ApplyFTWordsAny($searchContext,
                                    $noThesaurusOptions,
                                    $lookupRes,
                                    $queryPos)
      else
         (: from here on we have a single sequence of query tokens :)
         (: which is to be matched a phrase; no alternatives anymore :)
         &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
         {
            for $pos in
               fts:matchTokenInfos( 
                  $searchContext,
                  $matchOptions,
                  fts:applyStopWordOption($matchOptions/fts:stopwords),
                  $queryTokens )
            return  
               &lt;fts:match&gt;  
                  &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
                  {$pos}
                  &lt;/fts:stringInclude&gt; 
               &lt;/fts:match&gt;
         } 
         &lt;/fts:allMatches&gt; 
};
</pre></div>
</div>
<p>Two <b>FTMatchOption</b>s need to be processed differently than
the rest of the <b>FTMatchOption</b>s as shown in the function
above.</p>
<ul>
<li>
<p>Unlike all other <b>FTMatchOption</b>s the semantics of the
<b>FTThesaurusOption</b> cannot be formulated as an operation on
individual query tokens, because a thesaurus lookup may return
alternative query items for a whole phrase, i.e., a sequence of
query tokens. Since the result of a thesaurus lookup is a sequence
of alternatives, there must be a higher level of processing. The
above call to <code>applyThesaurusOption</code> returns for the
given sequence of query tokens (representing a phrase) all
thesaurus expansions for the selected thesaurus, relationship and
level range as a sequence of query items. The alternative
expansions are evaluated as a disjunction using the
<code>fts:ApplyFTWordsAny</code>. The matching of the alternatives
is performed with <b>FTThesaurusOption</b> turned off to avoid
double expansions, i.e., expansion of an already expanded
token.</p>
</li>
<li>
<p>For the semantics of the <b>FTStopWordOption</b> the list of
stop words needs to be computed as demanded by the special syntax
for stop word lists involving the operators "union" and
"except".</p>
</li>
</ul>
<p><em>Semantics of new <b>FTMatchOption</b>s functions</em></p>
<p>The expansion of <b>FTSelection</b>s also includes adding
additional functions that are specific to the
<b>FTMatchOption</b>s.</p>
<p>The <code>evaluate</code> function above handles match options
occurring in the query structure by using a call to the function
<code>replaceMatchOptions</code> which is defined below. The latter
function replaces match options from the list given by the first
argument with match options of the same group in the list given by
the second argument, if any. If an option is present in the second
list but not in the first list, the option is included to the
resulting list too. Intuitively, the
<code>replaceMatchOptions</code> computes the effective match
options for a given <b>FTSelection</b>. The function uses the
options specified specifically for the current <b>FTSelection</b> (
<code>$ftSelection/fts:matchOptions</code> to override any options
of the same group declared up the query tree
(<code>$matchOptions</code>).</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:replaceMatchOptions (
      $matchOptions as element(fts:matchOptions),
      $newMatchOptions as element(fts:matchOptions) )
   as element(fts:matchOptions)
{
   &lt;fts:matchOptions&gt;
   {
      (if ($newMatchOptions/fts:thesaurus) then $newMatchOptions/fts:thesaurus
       else $matchOptions/fts:thesaurus),
      (if ($newMatchOptions/fts:stopwords) then $newMatchOptions/fts:stopwords
       else $matchOptions/fts:stopwords),
      (if ($newMatchOptions/fts:case) then $newMatchOptions/fts:case
       else $matchOptions/fts:case),
      (if ($newMatchOptions/fts:diacritics) then $newMatchOptions/fts:diacritics
       else $matchOptions/fts:diacritics),
      (if ($newMatchOptions/fts:stem) then $newMatchOptions/fts:stem
       else $matchOptions/fts:stem),
      (if ($newMatchOptions/fts:wildcard) then $newMatchOptions/fts:wildcard
       else $matchOptions/fts:wildcard),
      (if ($newMatchOptions/fts:language) then $newMatchOptions/fts:language
       else $matchOptions/fts:language)
   }
   &lt;/fts:matchOptions&gt;
};

</pre></div>
</div>
<p>This function determines how match options of the same group
overwrite each other, so that only one option of the same group
remains.</p>
<p>The details of the semantics of the remaining
<b>FTMatchOption</b>s are determined by the <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> function
<code>matchTokenInfos</code>.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="options-sem-functions" id=
"options-sem-functions"></a>4.2.5.3 Formal Semantics Functions</h5>
<p><b>FTMatchOption</b> functions which are necessary to support
match option processing are given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:resolveStopWordsUri ( $uri as xs:string? ) 
   as xs:string* external;

declare function fts:lookupThesaurus (
      $tokens as element(fts:queryToken)*,
      $thesaurusName as xs:string?, 
      $relationship as xs:string?,
      $range as element(fts:range)?,
      $noThesaurusOptions as element(fts:matchOptions) ) 
   as element(fts:queryItem)* external;
</pre></div>
</div>
<p>The function <code>resolveStopWordsUri</code> is used to resolve
any URI to a sequence of strings to be used as stop words.</p>
<p>The function <code>lookupThesaurus</code> finds all expansions
related to <code>$tokens</code> in the thesaurus
<code>$thesaurusName</code> using the relationship
<code>$relationship</code> within the optional number of levels
<code>$range</code>. If <code>$tokens</code> consists of more than
one query token, it is regarded as a phrase. The current match
options other than the thesaurus option are also passed to the
function, via <code>$noThesaurusOptions</code>, allowing the
implementation to apply any of those match options (whichever it
deems relevant) to the input or output of the actual thesaurus
lookup.</p>
<p>The thesaurus function returns a sequence of expansion
alternatives. Each alternative is regarded as a new search phrase
and is represented as a query item. Alternatives are treated as
though they are connected with a disjunction (<b>FTOr</b>).</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTCaseOption" id=
"tq-ft-matchopt-FTCaseOption"></a>4.2.5.4 FTCaseOption</h5>
<p><b>FTMatchOption</b>s of type <b>FTCaseOption</b> are passed in
the <code>$matchOptions</code> parameter to
<code>matchTokenInfos</code>. If the <b>FTCaseOption</b> is
"lowercase" the returned <b>TokenInfo</b>s must span only tokens
that are all lowercase. If the <b>FTCaseOption</b> is "uppercase"
the returned <b>TokenInfo</b>s must span only tokens that are all
uppercase. If the <b>FTCaseOption</b> is "case insensitive" the
function must return all <b>TokenInfo</b>s matching the query
tokens when disregarding character case. If the <b>FTCaseOption</b>
is "case sensitive" the function must return all <b>TokenInfo</b>s
that also accord with the query tokens in character case.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTDiacriticsOption" id=
"tq-ft-matchopt-FTDiacriticsOption"></a>4.2.5.5
FTDiacriticsOption</h5>
<p><b>FTMatchOption</b>s of type <b>FTDiacriticsOption</b> are
passed in the <code>$matchOptions</code> parameter to
<code>matchTokenInfos</code>. If the <b>FTDiacriticsOption</b> is
"diacritics insensitive" the function must return all
<b>TokenInfo</b>s matching the query tokens when disregarding
diacritical marks. If the <b>FTDiacriticsOption</b> is "diacritics
sensitive" the function must return all <b>TokenInfo</b>s that also
accord with the query tokens in diacritical marks.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTStemOption" id=
"tq-ft-matchopt-FTStemOption"></a>4.2.5.6 FTStemOption</h5>
<p><b>FTMatchOption</b>s of type <b>FTStemOption</b> are passed in
the <code>$matchOptions</code> parameter to
<code>matchTokenInfos</code>. It is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> what the
effect of the option "stemming" is on matching tokens, however, it
is expected that this option allows to match linguistic variants of
the query tokens. If the <b>FTStemOption</b> is "no stemming" the
returned <b>TokenInfo</b>s must span exact matches (i.e. not
including linguistic variations) of the query tokens.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTThesaurusOption" id=
"tq-ft-matchopt-FTThesaurusOption"></a>4.2.5.7
FTThesaurusOption</h5>
<p>The semantics for the <b>FTThesaurusOption</b> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:applyThesaurusOption (
      $matchOption as element(fts:thesaurus),
      $noThesaurusOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)* )
   as element(fts:queryItem)*
{
   if ($matchOption/@thesaurusIndicator = "using") then
      fts:lookupThesaurus( $queryTokens,
                           $matchOption/fts:thesaurusName,
                           $matchOption/fts:relationship,
                           $matchOption/fts:range,
                           $noThesaurusOptions )
   else if ($matchOption/@thesaurusIndicator = "no") then
      &lt;fts:queryItem&gt;
      {$queryTokens}
      &lt;/fts:queryItem&gt;
   else ()
};
</pre></div>
</div>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTStopWordOption" id=
"tq-ft-matchopt-FTStopWordOption"></a>4.2.5.8 FTStopWordOption</h5>
<p>Stop words interact with <b>FTDistance</b> and <b>FTWindow</b>.
The semantics for the <b>FTStopWordOption</b> is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:applyStopWordOption (
      $stopWordOption as element(fts:stopwords)? )
   as xs:string*
{
   if ($stopWordOption) then
      let $swords := 
         typeswitch ($stopWordOption/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            case element(fts:default-stopwords)
               return fts:resolveStopWordsUri(())
            default return ()
      return fts:calcStopWords( $swords, $stopWordOption/fts:oper )
   else ()
};
declare function fts:calcStopWords ( 
      $stopWords as xs:string*,
      $opers as element(fts:oper)* )
   as xs:string*
{
   if ( fn:empty($opers) ) then $stopWords
   else
      let $swords := 
         typeswitch ($opers[1]/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            default return ()
      return
         if ($opers[1]/@type eq "union") then
            fts:calcStopWords( ($stopWords, $swords), 
                               $opers[fn:position() gt 2] )
         else (: "except" :)
            fts:calcStopWords( $stopWords[fn:not(.)=$swords],
                               $opers[fn:position() gt 2] )
};
            
</pre></div>
</div>
<p>Given the applicable setting of the Stop Word Option, the
function <code>fts:applyStopWordOption</code> calls
<code>fts:calcStopWords</code> to compute the set of stop words,
and returns that set as an instance of <code>xs:string*</code>.
This then is passed to <code>fts:matchTokenInfos</code>, which uses
it to affect the matching of tokens. The
<code>fts:calcStopWords</code> function uses the function
<code>fts:resolveStopWordsUri</code> to resolve any URI to a
sequence of strings.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTLanguageOption" id=
"tq-ft-matchopt-FTLanguageOption"></a>4.2.5.9 FTLanguageOption</h5>
<p>The <b>FTLanguageOption</b> is not associated with a semantics
function. It is just a parameter to other semantics functions.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-matchopt-FTWildCardOption" id=
"tq-ft-matchopt-FTWildCardOption"></a>4.2.5.10
FTWildCardOption</h5>
<p><b>FTMatchOption</b>s of type <b>FTWildCardOption</b> are passed
in the <code>$matchOptions</code> parameter to
<code>matchTokenInfos</code>. If the <b>FTWildCardOption</b> is
"wildcards" the function must return all <b>TokenInfo</b>s in the
search context that span tokens, such that those tokens are
wildcard expansions of the corresponding query token. The wildcard
expansions are described in <a href="#ftwildcardoption">Section
3.2.7 FTWildCardOption</a>. If the <b>FTWildCardOption</b> is "no
wildcards" all query tokens must be matched literally.</p>
</div>
</div>
</div>
</div>
<div class="xquery">
<div class="div3">
<h4><a name="FTOperatorsSemanticsSec" id=
"FTOperatorsSemanticsSec"></a>4.2.6 Full-Text Operators
Semantics</h4>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTOr" id="tq-ft-fs-FTOr"></a>4.2.6.1
FTOr</h5>
<p>The parameters of the <code>ApplyFTOr</code> function are the
two <b>AllMatches</b> parameters corresponding to the results of
the two nested <b>FTSelection</b>s. The semantics is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTOr (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}"&gt;
   {$allMatches1/fts:match,$allMatches2/fts:match}
   &lt;/fts:allMatches&gt;
};
            
</pre></div>
</div>
<p>The <code>ApplyFTOr</code> function creates a new
<b>AllMatches</b> in which <b>Match</b>es are the union of those
found in the input <b>AllMatches</b>. Each <b>Match</b> represents
one possible result of the corresponding <b>FTSelection</b>. Thus,
a <b>Match</b> from either of the <b>AllMatches</b> is a
result.</p>
<p>For example, consider the <b>FTSelection</b> <code>"Mustang"
ftor "Honda"</code>. The <b>AllMatches</b> corresponding to
"Mustang" and "Honda" are given below.</p>
<img src="images/FTOrEx1.jpg" alt="FTOr input AllMatches 1" />
<p><img src="images/FTOrEx2.jpg" alt=
"FTOr input AllMatches 2" /></p>
<p>The <b>AllMatches</b> produced by <code>ApplyFTOr</code> is
given below.</p>
<img src="images/FTOrEx3.jpg" alt="FTOr result AllMatches" /></div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTAnd" id="tq-ft-fs-FTAnd"></a>4.2.6.2
FTAnd</h5>
<p>The parameters of the <code>ApplyFTAnd</code> function are the
two <b>AllMatches</b> corresponding to the results of the two
nested <b>FTSelection</b>s. The semantics is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTAnd (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}" &gt;
   {
      for $sm1 in $allMatches1/fts:match
      for $sm2 in $allMatches2/fts:match
      return &lt;fts:match&gt;
             {$sm1/*, $sm2/*}
             &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
            
</pre></div>
</div>
<p>The result of the conjunction is a new <b>AllMatches</b> that
contains the "Cartesian product" of the matches of the
participating <b>FTSelection</b>s. Every resulting <b>Match</b> is
formed by the combination of the <b>StringInclude</b> components
and <b>StringExclude</b> from the <b>AllMatches</b> of the nested
<b>FTSelection</b> . Thus every match contains the positions to
satisfy a <b>Match</b> from both original <b>FTSelection</b>s and
excludes the positions that violate the same <b>Match</b>es.</p>
<p>For example, consider the <b>FTSelection</b> <code>"Mustang"
ftand "rust"</code>. The source <b>AllMatches</b> are give
below.</p>
<img src="images/FTAndEx1.jpg" alt="FTAnd input AllMatches 1" />
<p><img src="images/FTAndEx2.jpg" alt=
"FTAnd input AllMatches 2" /></p>
<p>The <b>AllMatches</b> produced by <code>ApplyFTAnd</code> is
given below.</p>
<img src="images/FTAndEx3.jpg" alt=
"FTAnd result AllMatches" /></div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTUnaryNot" id=
"tq-ft-fs-FTUnaryNot"></a>4.2.6.3 FTUnaryNot</h5>
<p>The <code>ApplyFTUnaryNot</code> function has one
<b>AllMatches</b> parameter corresponding to the result of the
nested <b>FTSelection</b> to be negated. The semantics is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:InvertStringMatch ( $strm as element(*,fts:stringMatch) ) 
   as element(*,fts:stringMatch)
{
   if ($strm instance of element(fts:stringExclude)) then
      &lt;fts:stringInclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringInclude&gt;
   else
      &lt;fts:stringExclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringExclude&gt;
};

declare function fts:UnaryNotHelper ( $matches as element(fts:match)* )
   as element(fts:match)*
{
   if (fn:empty($matches))
   then &lt;fts:match/&gt;
   else
      for $sm in $matches[1]/*
      for $rest in fts:UnaryNotHelper( fn:subsequence($matches, 2) )
      return 
         &lt;fts:match&gt;
         {
            fts:InvertStringMatch($sm),
            $rest/*
         }
         &lt;/fts:match&gt;
};

declare function fts:ApplyFTUnaryNot (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      fts:UnaryNotHelper($allMatches/fts:match)
   }
   &lt;/fts:allMatches&gt;
};
            
</pre></div>
</div>
<p>The generation of the resulting <b>AllMatches</b> of an
<b>FTUnaryNot</b> resembles the transformation of a negation of
prepositional formula in DNF back to DNF. The negation of
<b>AllMatches</b> requires the inversion of all the
<b>StringMatch</b>es within the <b>AllMatches</b>.</p>
<p>In the <code>InvertStringMatch</code> function above, this
inversion occurs as follows.</p>
<ol class="enumar">
<li>
<p>The function <code>fts:invertStringMatch</code> inverts a
<b>StringInclude</b> into a <b>StringExclude</b> and vice
versa.</p>
</li>
<li>
<p>The function <code>fts:UnaryNotHelper</code> transforms the
source <b>Match</b>es into the resulting <b>Match</b>es by forming
the combinations of the inversions of a <b>StringInclude</b> or
<b>StringExclude</b> component over the source <b>Match</b>es into
new <b>Match</b>es.</p>
</li>
</ol>
<p>For example, consider the <b>FTSelection</b> <code>ftnot
("Mustang" ftor "Honda")</code>. The source <b>AllMatches</b> is
given below:</p>
<img src="images/FTNegationEx1.jpg" alt=
"FTUnaryNot input AllMatches" />
<p>The <b>FTUnaryNot</b> transforms the <b>StringInclude</b>s to
<b>StringExclude</b>s as illustrated below.</p>
<img src="images/FTNegationEx2.jpg" alt=
"FTUnaryNot result AllMatches" /></div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTMildNot" id=
"tq-ft-fs-FTMildNot"></a>4.2.6.4 FTMildNot</h5>
<p>The parameters of the <code>ApplyFTMildNot</code> function are
the two <b>AllMatches</b> parameters corresponding to the results
of the two nested <b>FTSelection</b>s. The semantics is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:CoveredIncludePositions (
       $match as element(fts:match) )
    as xs:integer*
{
    for $strInclude in $match/fts:stringInclude
    return $strInclude/fts:tokenInfo/@startPos
           to $strInclude/fts:tokenInfo/@endPos
};

declare function fts:ApplyFTMildNot (
       $allMatches1 as element(fts:allMatches),
       $allMatches2 as element(fts:allMatches) )
    as element(fts:allMatches)
{
    if (fn:count($allMatches1//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the left-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the right-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringInclude) eq 0) then
       $allMatches1
    else
       &lt;fts:allMatches stokenNum="{$allMatches1/@stokenNum}"&gt;
       {
          $allMatches1/fts:match[
             every $matches2 in $allMatches2/fts:match
             satisfies
                let $posSet1 := fts:CoveredIncludePositions(.)
                let $posSet2 := fts:CoveredIncludePositions($matches2)
                   return some $pos in $posSet1 satisfies fn:not($pos = $posSet2)
          ]
       }
       &lt;/fts:allMatches&gt;
};
            
</pre></div>
</div>
<p>The resulting <b>AllMatches</b> contains <b>Match</b>es of the
first operand that do not mention in their <b>StringInclude</b>
components positions in a <b>StringInclude</b> component in the
<b>AllMatches</b> of the second operand.</p>
<p>For example, consider the <b>FTSelection</b> <code>("Ford" not
in "Ford Mustang")</code>. The source <b>AllMatches</b> for the
left-hand side argument is given below.</p>
<img src="images/FTMildNegationEx1.jpg" alt=
"FTMildNot input AllMatches 1" />
<p>The source <b>AllMatches</b> for the right-hand side argument is
given below.</p>
<img src="images/FTMildNegationEx2.jpg" alt=
"FTMildNot input AllMatches 2" />
<p>The <b>FTMildNot</b> will transform these to an empty
<b>AllMatches</b> because both position 1 and position 27 from the
first <b>AllMatches</b> contain only <b>TokenInfo</b>s from
<b>StringInclude</b> components of the second
<b>AllMatches</b>.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTOrder" id="tq-ft-fs-FTOrder"></a>4.2.6.5
FTOrder</h5>
<p>The <code>ApplyFTOrder</code> function has one <b>AllMatches</b>
parameter corresponding to the result of the nested
<b>FTSelection</b>s. The semantics is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTOrder (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude
            satisfies (($stringInclude1/fts:tokenInfo/@startPos &lt;= 
                        $stringInclude2/fts:tokenInfo/@startPos)
                       and
                       ($stringInclude1/@queryPos &lt;= 
                        $stringInclude2/@queryPos))
                      or
                       (($stringInclude1/fts:tokenInfo/@startPos&gt;= 
                         $stringInclude2/fts:tokenInfo/@startPos)
                        and
                        ($stringInclude1/@queryPos &gt;= 
                         $stringInclude2/@queryPos))
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies (($stringExcl/fts:tokenInfo/@startPos &lt;= 
                              $stringIncl/fts:tokenInfo/@startPos)
                             and
                              ($stringExcl/@queryPos &lt;= 
                               $stringIncl/@queryPos))
                            or
                             (($stringExcl/fts:tokenInfo/@startPos &gt;= 
                               $stringIncl/fts:tokenInfo/@startPos)
                              and
                              ($stringExcl/@queryPos &gt;= 
                               $stringIncl/@queryPos))
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }         
   &lt;/fts:allMatches&gt;
};
            
</pre></div>
</div>
<p>The resulting <b>AllMatches</b> contains the <b>Match</b>es for
which the starting positions in the <b>StringInclude</b> elements
are in the order of the query positions of their query strings.
<b>StringExclude</b>s that preserve the order (with respect to
their starting positions) are also retained.</p>
<p>For example, consider the <b>FTSelection</b> <code>("great"
ftand "condition") ordered</code>. The source <b>AllMatches</b> is
given below.</p>
<img src="images/FTOrderEx1.jpg" alt=
"FTOrder input AllMatches" /><img src="images/FTOrderEx2.jpg" alt=
"FTOrder input AllMatches" /><img src="images/FTOrderEx3.jpg" alt=
"FTOrder input AllMatches" />
<p>The <b>AllMatches</b> for <b>FTOrder</b> are given below.</p>
<img src="images/FTOrderEx4.jpg" alt=
"FTOrder result AllMatches" /><img src="images/FTOrderEx5.jpg" alt=
"FTOrder result AllMatches" /></div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTScope" id="tq-ft-fs-FTScope"></a>4.2.6.6
FTScope</h5>
<p>The parameters of the <code>ApplyFTScope</code> function are 1)
the type of the scope (same or different), 2) the linguistic unit
(sentence or paragraph), and 2) one <b>AllMatches</b> parameter
corresponding to the result of the nested <b>FTSelection</b>s. The
function definitions depend on the type of the scope (paragraph,
sentence) and the scope predicate (same, different).</p>
<p>The semantics of <code>same sentence</code> is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTScopeSameSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude 
            satisfies $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@startSent
                  and $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude1/fts:tokenInfo/@endSent
                  and $stringInclude2/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@endSent
                  and $stringInclude1/fts:tokenInfo/@startSent &gt; 0
                  and $stringInclude2/fts:tokenInfo/@startSent &gt; 0
      return 
        &lt;fts:match&gt;
        {
           $match/fts:stringInclude,
           for $stringExcl in $match/fts:stringExclude
           where
              $stringExcl/fts:tokenInfo/@startSent = 0
              or
              ($stringExcl/fts:tokenInfo/@startSent = 
               $stringExcl/fts:tokenInfo/@endSent
               and 
                  (every $stringIncl in $match/fts:stringInclude
                   satisfies $stringIncl/fts:tokenInfo/@startSent = 
                             $stringExcl/fts:tokenInfo/@startSent) )
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>An <b>AllMatches</b> returned by the scope <code>same
sentence</code> contains those <b>Match</b>es whose
<b>StringInclude</b>s span only a single sentence and all span the
same sentence. In these <b>Match</b>es only those
<b>StringExclude</b>s are retained that also only span a single
sentence, which is, in case there are <b>StringInclude</b>s in that
<b>Match</b>, the same as the one spanned by the
<b>StringInclude</b>s.</p>
<p>The semantics of <code>different sentence</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTScopeDifferentSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where
         count($match/fts:stringInclude) &gt; 1
         and
         (
            every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies
               $stringInclude1 is $stringInclude2
               or
               (
                     ( $stringInclude1/fts:tokenInfo/@startSent !=  
                       $stringInclude2/fts:tokenInfo/@startSent 
                    or $stringInclude1/fts:tokenInfo/@startSent !=  
                       $stringInclude1/fts:tokenInfo/@endSent 
                    or $stringInclude2/fts:tokenInfo/@startSent !=  
                       $stringInclude2/fts:tokenInfo/@endSent ) 
                   and $stringInclude1/fts:tokenInfo/@startSent &gt; 0 
                   and $stringInclude2/fts:tokenInfo/@endSent &gt; 0
               )
         )
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies ($stringIncl/fts:tokenInfo/@startSent !=  
                             $stringExcl/fts:tokenInfo/@startSent 
                          or $stringIncl/fts:tokenInfo/@startSent !=  
                             $stringIncl/fts:tokenInfo/@endSent 
                          or $stringExcl/fts:tokenInfo/@startSent !=  
                             $stringExcl/fts:tokenInfo/@endSent ) 
                         and $stringIncl/fts:tokenInfo/@startSent &gt; 0 
                         and $stringExcl/fts:tokenInfo/@endSent &gt; 0
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>An <b>AllMatches</b> returned by the scope <code>different
sentence</code> contains those <b>Match</b>es that have at least
two StringIncludes, no two of which begin and end all in the same
sentence. In these <b>Match</b>es only those <b>StringExclude</b>s
are retained that do not conflict with any of the
<b>StringInclude</b>s.</p>
<p>The semantics of <code>same paragraph</code> is analogous to
<code>same sentence</code> and is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTScopeSameParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@startPara
                  and $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude1/fts:tokenInfo/@endPara
                  and $stringInclude2/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@endPara
                  and $stringInclude1/fts:tokenInfo/@startPara &gt; 0
                  and $stringInclude2/fts:tokenInfo/@endPara &gt; 0
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where 
               $stringExcl/fts:tokenInfo/@startPara = 0
               or
               ($stringExcl/fts:tokenInfo/@startPara = 
                $stringExcl/fts:tokenInfo/@endPara
                and
                   (every $stringIncl in $match/fts:stringInclude
                    satisfies $stringIncl/fts:tokenInfo/@startPara = 
                              $stringExcl/fts:tokenInfo/@startPara) )
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>different paragraph</code> is analogous
to <code>different sentence</code> and is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTScopeDifferentParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where
         count($match/fts:stringInclude) &gt; 1
         and
         (
            every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies
               $stringInclude1 is $stringInclude2
               or
               (
                     ( $stringInclude1/fts:tokenInfo/@startPara !=  
                       $stringInclude2/fts:tokenInfo/@startPara 
                    or $stringInclude1/fts:tokenInfo/@startPara !=  
                       $stringInclude1/fts:tokenInfo/@endPara 
                    or $stringInclude2/fts:tokenInfo/@startPara !=  
                       $stringInclude2/fts:tokenInfo/@endPara ) 
                   and $stringInclude1/fts:tokenInfo/@startPara &gt; 0 
                   and $stringInclude2/fts:tokenInfo/@endPara &gt; 0
               )
         )
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies ($stringIncl/fts:tokenInfo/@startPara !=  
                             $stringExcl/fts:tokenInfo/@startPara 
                          or $stringIncl/fts:tokenInfo/@startPara !=  
                             $stringIncl/fts:tokenInfo/@endPara 
                          or $stringExcl/fts:tokenInfo/@startPara !=  
                             $stringExcl/fts:tokenInfo/@endPara ) 
                         and $stringIncl/fts:tokenInfo/@startPara &gt; 0 
                         and $stringExcl/fts:tokenInfo/@endPara &gt; 0
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics for the general case is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTScope (
      $type as fts:scopeType,
      $selector as fts:scopeSelector, 
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "same" and $selector eq "sentence")
   then fts:ApplyFTScopeSameSentence($allMatches)
   else if ($type eq "different" and $selector eq "sentence")
      then fts:ApplyFTScopeDifferentSentence($allMatches)
   else if ($type eq "same" and $selector eq "paragraph")
      then fts:ApplyFTScopeSameParagraph($allMatches)
   else fts:ApplyFTScopeDifferentParagraph($allMatches)
};
</pre></div>
</div>
<p>For example, consider the <b>FTSelection</b> <code>("Mustang"
ftand "Honda") same paragraph</code>. The source <b>AllMatches</b>
is given below.</p>
<img src="images/FTScopeEx.jpg" alt="FTScope input AllMatches" />
<p>The <b>FTScope</b> returns an empty <b>AllMatches</b> because
neither <b>Match</b> contains <b>TokenInfo</b>s from a single
sentence.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTContent" id=
"tq-ft-fs-FTContent"></a>4.2.6.7 FTContent</h5>
<p>The parameters of the <code>ApplyFTContent</code> function are
1) the search context, 2) the type of the content match (<code>at
start</code>, <code>at end</code>, or <code>entire content</code>),
and 3) one <b>AllMatches</b> parameter corresponding to the result
of the nested <b>FTSelection</b>s.</p>
<p>The evaluation of <code>ApplyFTContent</code> depends on the
type of the content match:</p>
<ul>
<li>
<p><code>entire content</code> retains those <b>Match</b>es such
that for every token position in the search context, some
<b>StringInclude</b> in the <b>Match</b> covers that token
position.</p>
</li>
<li>
<p><code>at start</code> retains those <b>Match</b>es that contain
a <b>StringInclude</b> that covers the lowest token position in the
search context.</p>
</li>
<li>
<p><code>at end</code> retains those <b>Match</b>es that contain a
<b>StringInclude</b> that covers the highest token position in the
search context.</p>
</li>
</ul>
<p>The semantics is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTContent (
      $searchContext as item(),
      $type as fts:contentMatchType,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      $allMatches/fts:match[
         let $start_pos := fts:getLowestTokenPosition($searchContext),
             $end_pos   := fts:getHighestTokenPosition($searchContext),
             $match     := .
         return
            if ($type eq "entire content") then
               every $pos in $start_pos to $end_pos
               satisfies
                  some $si in $match/fts:stringInclude[data(@isContiguous)]
                  satisfies
                     fts:TokenInfoCoversTokenPosition($si/fts:tokenInfo, $pos)
            else
               let $pos :=
                  if ($type eq "at start") then
                     $start_pos
                  else (: $type eq "at end" :)
                     $end_pos
               return
                  some $ti in $match/fts:stringInclude/fts:tokenInfo
                  satisfies
                     fts:TokenInfoCoversTokenPosition($ti, $pos)
      ]
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p><code>ApplyFTContent</code> depends on the helper function
<code>fts:TokenInfoCoversTokenPosition</code>, which ascertains
whether the given <code>$tokenInfo</code> covers a particular
<code>$tokenPosition</code>.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:TokenInfoCoversTokenPosition(
      $tokenInfo as element(fts:tokenInfo),
      $tokenPosition as xs:integer )
   as xs:boolean
{
   ($tokenPosition &gt;= $tokenInfo/@startPos)
   and
   ($tokenPosition &lt;= $tokenInfo/@endPos)
};
</pre></div>
</div>
<p><code>ApplyFTContent</code> also depends on two functions whose
definitions are <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>:
<code>getLowestTokenPosition</code> and
<code>getHighestTokenPosition</code> return (respectively) the
first and last token positions of the item
<code>$searchContext</code>.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:getLowestTokenPosition(
      $searchContext as item() )
   as xs:integer
   external;

declare function fts:getHighestTokenPosition(
      $searchContext as item() )
   as xs:integer
   external;
</pre></div>
</div>
<p>Note that the way <code>@isContiguous</code> is calculated in
<code>joinIncludes</code> and used in <code>ApplyFTContent</code>
can lead to counter-intuitive results. For example, consider the
following query:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
"one two three four"
contains text
   ("one" ftand "three" window 3 words)
   ftand
   ("two" ftand "four" window 3 words)
   entire content
</pre></div>
</div>
<p>Even though the four query tokens <em>do</em> cover all of the
search context's token positions, the query yields false, because
the <b>Match</b> that <code>ApplyFTContent</code> receives as input
has two <b>StringInclude</b>s, each of which is non-contiguous.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTWindow" id="tq-ft-fs-FTWindow"></a>4.2.6.8
FTWindow</h5>
<p>Before we define the semantics functions of the <b>FTWindow</b>
and <b>FTDistance</b> operations, we introduce the auxiliary
function <code>joinIncludes</code> that will be used in their
definitions. <code>joinIncludes</code> takes a sequence of
<b>StringInclude</b>s of a <b>Match</b> and transforms it into
either the empty sequence, in case the input sequence was empty, or
otherwise a single <b>StringInclude</b> representing the span from
the first position of the match to the last. For the purpose of
being able to evaluate an "entire content" operator further up in
the tree, we pre-evaluate whether all possible positions between
first and last are covered in the input <b>StringInclude</b>s and
store that boolean in the attribute "isContiguous".</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:joinIncludes(
      $strIncls as element(fts:stringInclude)* )
   as element(fts:stringInclude)?
{
   if (fn:empty($strIncls))
   then 
      $strIncls
   else
      let $posSet := fts:CoveredIncludePositions(&lt;fts:match&gt;$strIncls&lt;/fts:match&gt;),
         $minPos := fn:min($strIncls/fts:tokenInfo/@startPos),
         $maxPos := fn:max($strIncls/fts:tokenInfo/@endPos),
         $isContiguous := 
            ( every $pos in $minPos to $maxPos
              satisfies ($pos = $posSet) )
            and
            ( every $strIncl in $strIncls
              satisfies $strIncl/@isContiguous )
      return
         &lt;fts:stringInclude 
            queryPos="{$strIncls[1]/@queryPos}"
            isContiguous="{$isContiguous}"&gt;
            &lt;fts:tokenInfo
               startPos ="{$minPos}"
               endPos   ="{$maxPos}"
               startSent="{fn:min($strIncls/fts:tokenInfo/@startSent)}"
               endSent  ="{fn:max($strIncls/fts:tokenInfo/@endSent)}"
               startPara="{fn:min($strIncls/fts:tokenInfo/@startPara)}"
               endPara  ="{fn:max($strIncls/fts:tokenInfo/@endPara)}"/&gt;
         &lt;/fts:stringInclude&gt;
};
</pre></div>
</div>
<p>The parameters of the <code>ApplyFTWindow</code> function are 1)
the unit of type <code>fts:distanceType</code>, 2) a size, and 3)
one <b>AllMatches</b> parameter corresponding to the result of the
nested <b>FTSelection</b>s. For each unit type a function is
defined as follows.</p>
<p>The semantics of <code>window N words</code> is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPos),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPos)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPos &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPos &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>window N sentences</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTSentenceWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startSent),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endSent)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startSent &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endSent &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>window N paragraphs</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTParagraphWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPara),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPara)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPara &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPara &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The resulting <b>AllMatches</b> contains <b>Match</b>es of the
operand that satisfy the condition that there exists a sequence of
the specified number of consecutive (token, sentence, or paragraph)
positions, such that all <b>StringInclude</b>s are within that
window, and the <b>StringExclude</b>s retained are also within that
window. For each <b>Match</b> that satisfies the window condition
the <b>StringInclude</b>s are joined into a single
<b>StringInclude</b>. This enables further window or distance
operations to be applied to the result in a way that that result is
taken as a single entity.</p>
<p>The semantics for the general function is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWindow (
      $type as fts:distanceType,
      $size as xs:integer,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      fts:ApplyFTWordWindow($allMatches, $size)
   else if ($type eq "sentence") then 
      fts:ApplyFTSentenceWindow($allMatches, $size)
   else
      fts:ApplyFTParagraphWindow($allMatches, $size)
};
</pre></div>
</div>
<p>For example, consider the <b>FTWindow</b> selection <code>("Ford
Mustang" ftand "excellent") window 10 words</code>. The
<b>Match</b>es of the source <b>AllMatches</b> for <code>("Ford
Mustang" ftand "excellent")</code> are given below.</p>
<img src="images/FTWindowEx1.jpg" alt="FTWindow AllMatches" />
<p><img src="images/FTWindowEx2.jpg" alt=
"FTWindow AllMatches" /></p>
<img src="images/FTWindowEx3.jpg" alt="FTWindow AllMatches" />
<p><img src="images/FTWindowEx4.jpg" alt=
"FTWindow AllMatches" /></p>
<img src="images/FTWindowEx5.jpg" alt="FTWindow AllMatches" />
<p><img src="images/FTWindowEx6.jpg" alt=
"FTWindow AllMatches" /></p>
<p>The result for the <b>FTWindow</b> selection consists of only
the first, the fifth, and the sixth <b>Match</b>es because their
respective window sizes are 5, 4, and 9.</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTDistance" id=
"tq-ft-fs-FTDistance"></a>4.2.6.9 FTDistance</h5>
<p>The parameters of the <code>ApplyFTDistance</code> function are
1) one <b>AllMatches</b> parameter corresponding to the result of
the nested <b>FTSelection</b>s, 2) the unit of the distance
(tokens, sentences, paragraphs), and 3) the range specified. The
resulting <b>AllMatches</b> contains <b>Match</b>es of the operand
that satisfy the condition that the distance for every pair of
consecutive <b>StringInclude</b>s is within the specified interval,
where the distance is measured (in tokens, sentences, or
paragraphs) from the end of the preceding <b>StringInclude</b> to
the start of the next.</p>
<p>An invocation of the <code>ApplyFTDistance</code> function will
call one of twelve helper functions, each of which handles a
particular unit of distance and type of range.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTDistance (
      $type as fts:distanceType,
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTWordDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then 
         fts:ApplyFTWordDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTWordDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTWordDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else if ($type eq "sentence") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTSentenceDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTSentenceDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTSentenceDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTSentenceDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else
      if ($range/@type eq "exactly") then
         fts:ApplyFTParagraphDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTParagraphDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTParagraphDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTParagraphDistanceFromTo( $allMatches, $range/@m, $range/@n)
};
</pre></div>
</div>
<p><em>Word Distance</em></p>
<p>The semantics of case <code>word distance exactly N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordDistanceExactly(
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $idx in 1 to fn:count($sorted) - 1
            satisfies fts:wordDistance(
                         $sorted[$idx]/fts:tokenInfo,
                         $sorted[$idx+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>word distance at least N</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                         $sorted[$index]/fts:tokenInfo,
                         $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>word distance at most N</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
        &lt;fts:match&gt;
        {
           fts:joinIncludes($match/fts:stringInclude),
           for $stringExcl in $match/fts:stringExclude
           where some $stringIncl in $match/fts:stringInclude
                 satisfies fts:wordDistance(
                               $stringIncl/fts:tokenInfo,
                               $stringExcl/fts:tokenInfo
                           ) &lt;= $n
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>word distance from M to N</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTWordDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The preceding four helper functions all rely on
<code>fts:wordDistance</code>, which returns the number of token
positions that occur between two <b>TokenInfo</b>s. For example,
two tokens with consecutive positions have a distance of 0 tokens,
and two overlapping tokens have a distance of -1 tokens.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:wordDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startPos - $sorted[1]/@endPos - 1
};
            
</pre></div>
</div>
<p><em>Sentence Distance</em></p>
<p>The semantics of <code>sentence distance exactly N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTSentenceDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>sentence distance at least N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTSentenceDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                    order by $si/fts:tokenInfo/@startSent ascending,
                             $si/fts:tokenInfo/@endSent ascending
                    return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>sentence distance at most N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTSentenceDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>sentence distance from M to N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTSentenceDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The preceding four helper functions all rely on
<code>fts:sentenceDistance</code>, which returns the number of
sentences between two <b>TokenInfo</b>s.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:sentenceDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startSent - $sorted[1]/@endSent - 1
};
            
</pre></div>
</div>
<p><em>Paragraph Distance</em></p>
<p>The semantics of <code>paragraph distance exactly N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTParagraphDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>paragraph distance at least N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTParagraphDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>paragraph distance at most N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTParagraphDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>paragraph distance from M to N</code> is
given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTParagraphDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The preceding four helper functions all rely on
<code>fts:paraDistance</code>, which returns the number of
paragraphs between two <b>TokenInfo</b>s.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:paraDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startPara - $sorted[1]/@endPara - 1
};
            
</pre></div>
</div>
<p>For example, consider the <b>FTDistance</b> selection
<code>("Ford Mustang" ftand "excellent") distance at most 3
words</code>. The <b>Match</b>es of the source <b>AllMatches</b>
for <code>("Ford Mustang" ftand "excellent")</code> are given
below.</p>
<img src="images/FTDistanceEx1.jpg" alt=
"FTDistance input AllMatches" />
<p><img src="images/FTDistanceEx2.jpg" alt=
"FTDistance input AllMatches" /></p>
<img src="images/FTDistanceEx3.jpg" alt=
"FTDistance input AllMatches" />
<p><img src="images/FTDistanceEx4.jpg" alt=
"FTDistance input AllMatches" /></p>
<img src="images/FTDistanceEx5.jpg" alt=
"FTDistance input AllMatches" />
<p><img src="images/FTDistanceEx6.jpg" alt=
"FTDistance input AllMatches" /></p>
<p>The result for the <b>FTDistance</b> selection consists of only
the first <b>Match</b> (with positions 1, 2, and 5) and the fifth
<b>Match</b> (with positions 25, 27, and 28), because only for
these <b>Match</b>es the word distance between consecutive
<b>TokenInfo</b>s is always less than or equal to 3. For the first
<b>Match</b>, the word distance between the two <b>TokenInfo</b>s
is 2 (<code>startPos</code> 5 - <code>endPos</code> 2 - 1), and for
the fifth <b>Match</b>, it's 1 (<code>startPos</code> 27 -
<code>endPos</code> 25 - 1).</p>
</div>
</div>
<div class="xquery">
<div class="div4">
<h5><a name="tq-ft-fs-FTTimes" id="tq-ft-fs-FTTimes"></a>4.2.6.10
FTTimes</h5>
<p>The parameters of the <code>ApplyFTTimes</code> function are 1)
an <b>FTRange</b> specification, and 2) a parameter corresponding
to the result of the nested <b>FTWords</b>.</p>
<p>The function definitions depend on the range specification
<b>FTRange</b> to limit the number of occurrences.</p>
<p>The general semantics is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:FormCombinations (
      $sms as element(fts:match)*, 
      $k as xs:integer ) 
   as element(fts:match)*
(:
   Find all combinations of exactly $k elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   if ($k eq 0) then &lt;fts:match/&gt;
   else if (fn:count($sms) lt $k) then ()
   else if (fn:count($sms) eq $k) then &lt;fts:match&gt;{$sms/*}&lt;/fts:match&gt;
   else
      let $first := $sms[1],
          $rest  := fn:subsequence($sms, 2)
      return (
         (: all the combinations that don't involve $first :)
         fts:FormCombinations($rest, $k),

         (: and all the combinations that do involve $first :)
         for $combination in fts:FormCombinations($rest, $k - 1)
         return
            &lt;fts:match&gt;
            {
               $first/*,
               $combination/*
            }
            &lt;/fts:match&gt;
      )
};

declare function fts:FormCombinationsAtLeast (
      $sms as element(fts:match)*,
      $times as xs:integer)
   as element(fts:match)*
(:
   Find all combinations of $times or more elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   for $k in $times to fn:count($sms)
   return fts:FormCombinations($sms, $k)
};

declare function fts:FormRange (
      $sms as element(fts:match)*, 
      $l as xs:integer, 
      $u as xs:integer, 
      $stokenNum as xs:integer ) 
   as element(fts:allMatches)
{
   if ($l &gt; $u) then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $am1 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $l)}
                  &lt;/fts:allMatches&gt;
      let $am2 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $u+1)}
                  &lt;/fts:allMatches&gt;
      return fts:ApplyFTAnd($am1,
                            fts:ApplyFTUnaryNot($am2))
};
            
</pre></div>
</div>
<p>The semantics of <code>occurs exactly N times</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTTimesExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $n, $n, $allMatches/@stokenNum)      
};
</pre></div>
</div>
<p>The semantics of <code>occurs at least N times</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTTimesAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt; 
   {fts:FormCombinationsAtLeast($allMatches/fts:match, $n)} 
   &lt;/fts:allMatches&gt;
};
</pre></div>
</div>
<p>The semantics of <code>occurs at most N times</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTTimesAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, 0, $n, $allMatches/@stokenNum)
};
</pre></div>
</div>
<p>The semantics of <code>occurs from M to N times</code> is given
below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTTimesFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $m, $n, $allMatches/@stokenNum)  
};
</pre></div>
</div>
<p>The way to ensure that there are at least <b>N</b> different
matches of an <b>FTSelection</b> is to ensure that at least
<b>N</b> of its <b>Match</b>es occur simultaneously. This is
similar to forming their conjunction by combining <b>N</b> or more
distinct <b>Match</b>es into one simple match. Therefore, the
<b>AllMatches</b> for the selection condition specifying the range
qualifier <code>at least N</code> contains the possible
combinations of <b>N</b> or more simple matches of the operand.
This operation is performed in the function
<code>fts:FormCombinationsAtLeast</code>.</p>
<p>The range [L, U] is represented by the condition <code>at least
L and not at least U+1</code>. This transformation is performed in
the function <code>fts:FormRange</code>.</p>
<p>The semantics for the general case is given below.</p>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:ApplyFTTimes (
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if (fn:count($allMatches//fts:stringExclude) gt 0) then
      fn:error(fn:QName('http://www.w3.org/2005/xqt-errors',
                        'XPST0003'))
   else if ($range/@type eq "exactly") then
      fts:ApplyFTTimesExactly($allMatches, $range/@n)
   else if ($range/@type eq "at least") then 
      fts:ApplyFTTimesAtLeast($allMatches, $range/@n)
   else if ($range/@type eq "at most") then
      fts:ApplyFTTimesAtMost($allMatches, $range/@n)
   else fts:ApplyFTTimesFromTo($allMatches, 
                               $range/@m, 
                               $range/@n)
};
</pre></div>
</div>
<p>The above function performs a sanity check to ensure that the
nested <b>AllMatches</b> is a result of the evaluation of
<b>FTWords</b> as defined in the grammar rule for <a href=
"#doc-xquery30-FTPrimary">FTPrimary</a> . Otherwise, an error
[<a href="http://www.w3.org/TR/xpath-30/#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>]<sup><small>XP30</small></sup> is
raised.</p>
<p>For example, consider the <b>FTTimes</b> selection
<code>"Mustang" occurs at least 2 times</code>. The source
<b>AllMatches</b> of the <b>FTWords</b> selection
<code>"Mustang"</code> is given below.</p>
<img src="images/FTTimesEx1.jpg" alt="FTTimes input AllMatches" />
<p>The result consists of the pairs of the <b>Match</b>es.</p>
<img src="images/FTTimesEx2.jpg" alt=
"FTTimes result AllMatches" /></div>
</div>
</div>
</div>
</div>
</div>
<div class="xquery">
<div class="div2">
<h3><a name="FTContainsSec" id="FTContainsSec"></a>4.3
FTContainsExpr</h3>
<p>Consider an <b>FTContainsExpr</b> expression of the form
<code>SearchContext contains text FTSelection</code>, where
<code>SearchContext</code> is an XQuery <span>3.0</span> expression
that returns a sequence of items. The <b>FTContainsExpr</b> returns
true if and only if one of those items satisfies the
<code>FTSelection</code>.</p>
<p>If the <b>FTContainsExpr</b> is of the form <code>SearchContext
contains text FTSelection without content IgnoreExpr</code> for
some XQuery <span>3.0</span> expression <code>IgnoreExpr</code>,
then any nodes returned by <code>IgnoreExpr</code> are (notionally)
pruned from each search context item before attempting to satisfy
the <code>FTSelection</code>.</p>
<p>More formally, evaluation of an <b>FTContainsExpr</b> proceeds
according to the following steps. Where appropriate, the
explanation includes references to arcs labelled "FTn" in the
processing model diagram (Figure 1) in <a href=
"#processing-model"><b>2.1 Processing Model</b></a>.</p>
<ol class="enumar">
<li>
<p>For each XQuery/XPath expression nested within the
FTContainsExpr, evaluate it with respect to the same dynamic
context as the FTContainsExpr (FT1). Specifically:</p>
<ol class="enumla">
<li>
<p>Evaluate the search context expression
(<code>SearchContext</code>), resulting in the sequence of search
context items.</p>
</li>
<li>
<p>Evaluate the ignore option (<code>IgnoreExpr</code>) if any,
resulting in the set of ignored nodes.</p>
</li>
<li>
<p>At each FTWordsValue, evaluate the literal/expression and
convert the result to <code>xs:string*</code>.</p>
</li>
<li>
<p>At each weight specification, evaluate the expression and
convert the result to <code>xs:double</code>.</p>
</li>
<li>
<p>At each FTWindow and FTRange, evaluate the AdditiveExpr(s) and
convert each to <code>xs:integer</code>.</p>
</li>
</ol>
</li>
<li>
<p>Using the settings of the match option components in the
FTContainsExpr's static context, construct an
<code>element(fts:matchOptions)</code> structure.</p>
</li>
<li>
<p>Based on the parse-tree of the FTContainsExpr's FTSelection and
the results of steps 1c-1e, construct an
<code>element(*,fts:ftSelection)</code> structure. We refer to this
as the "operator tree" below. In this process:</p>
<ol class="enumla">
<li>
<p>Construct the operator tree from the top down, propagating
FTMatchOptions down to FTWordsValues.</p>
</li>
<li>
<p>Tokenize the query string(s) obtained at 1c. (FT2.1)</p>
</li>
</ol>
</li>
<li>
<p>Call the function <code>fts:FTContainsExpr</code> (see
declaration below), passing the following arguments to its
parameters:</p>
<ul>
<li>
<p><code>$searchContextItems</code>: The sequence of items returned
by <code>SearchContext</code>, calculated in step 1a.</p>
</li>
<li>
<p><code>$ignoreNodes</code>: The sequence of items returned by
<code>IgnoreExpr</code> (in 1b), if that expression is present, or
the empty sequence otherwise.</p>
</li>
<li>
<p><code>$ftSelection</code>: The XML node representation of
<code>FTSelection</code> (constructed in step 2).</p>
</li>
<li>
<p><code>$defOptions</code>: The XML representation of the match
options in the FTContainsExpr's static context (constructed in step
3).</p>
</li>
</ul>
<p>Within the function, for each search context item:</p>
<ol class="enumla">
<li>
<p>Delete the ignored nodes from the search context item.
[<code>fts:FTContainsExpr</code> calls
<code>fts:reconstruct</code>.]</p>
</li>
<li>
<p>Traverse the operator tree from the top down, propagating
FTMatchOptions down to FTWordsValues. [<code>fts:evaluate</code>
calls itself and <code>fts:replaceMatchOptions</code>.]</p>
</li>
<li>
<p>At each FTWordsValue, using the prevailing FTMatchOptions:</p>
<ol class="enumlr">
<li>
<p>Tokenize the search context obtained at 4a. (FT2.2) (Whether
this pays any attention to FTMatchOptions is up to the
implementation.) [This happens within
<code>fts:matchTokenInfos</code>.]</p>
</li>
<li>
<p>Match the search context tokens and the query tokens, yielding
an <code>element(fts:tokenInfo)*</code> structure. [This happens
within <code>fts:matchTokenInfos</code>.]</p>
</li>
<li>
<p>Convert that into an <code>element(fts:allMatches)</code>. (FT3)
[This happens in <code>fts:applyQueryTokensAsPhrase</code>.]</p>
</li>
</ol>
</li>
<li>
<p>Traverse the operator tree from the bottom up. At each point,
the <b>AllMatches</b> instances produced by subtrees are taken as
input, and a new <b>AllMatches</b> instance is obtained as output.
(FT4) [This is most of the section 4 code.]</p>
</li>
<li>
<p>If the topmost <b>AllMatches</b> instance contains a
<b>Match</b> with no <b>StringExclude</b>s, then the search context
item satisfies the full-text condition given by the
<b>FTSelection</b>, and the call to <code>fts:FTContainsExpr</code>
returns <code>true</code>. [This is handled by the QuantifiedExpr
in <code>fts:FTContainsExpr</code>.]</p>
</li>
</ol>
<p>[Note that the section 4 code doesn't implement 4b-4d as three
sequential steps. Instead, they are different aspects of a single
traversal of the operator tree.]</p>
<p>If none of the topmost <b>AllMatches</b> provides a successful
match, then <code>fts:FTContainsExpr</code> returns
<code>false</code>.</p>
</li>
<li>
<p>The boolean value returned by the call to
<code>fts:FTContainsExpr</code> is the value of the FTContainsExpr.
(FT5)</p>
</li>
</ol>
<div class="semfunc-file-fts-xquery">
<div class="exampleInner">
<pre>
declare function fts:FTContainsExpr (
      $searchContextItems as item()*,
      $ignoreNodes as node()*,
      $ftSelection as element(*,fts:ftSelection),
      $defOptions as element(fts:matchOptions) )
   as xs:boolean 
{ 
   some $searchContext in $searchContextItems
   satisfies 
      let $newSearchContext := fts:reconstruct( $searchContext, $ignoreNodes )
      return
         if (fn:empty($newSearchContext)) then fn:false()
         else
            let $allMatches := fts:evaluate($ftSelection,
                                            $newSearchContext,
                                            $defOptions,
                                            0)
            return 
               some $match in $allMatches/fts:match
               satisfies 
                  fn:count($match/fts:stringExclude) eq 0
};

declare function fts:reconstruct (
      $n as item(),
      $ignore as node()* )
   as item()?
{
   typeswitch ($n)
     case node() return
        if (some $i in $ignore satisfies $n is $i) then ()
        else if ($n instance of element()) then
           let $nodeName := fn:node-name($n)
           let $nodeContent := for $nn in $n/node()
                               return fts:reconstruct($nn,$ignore)
           return element {$nodeName} {$nodeContent}
        else if ($n instance of document-node()) then
           document {
              for $nn in $n/node()
              return fts:reconstruct($nn, $ignore)
           }
        else $n
     default return $n
};
            
</pre></div>
</div>
</div>
</div>
<div class="xquery">
<div class="div2">
<h3><a name="ScoreSec" id="ScoreSec"></a>4.4 Scoring</h3>
<p>This section addresses the semantics of scoring variables in
XQuery <span>3.0</span> <code>for</code> and <code>let</code>
clauses and XPath <span>3.0</span> <code>for</code>
expressions.</p>
<p>Scoring variables associate a numeric score with the result of
the evaluation of XQuery <span>3.0</span> and XPath
<span>3.0</span> expressions. This numeric score tries to estimate
the value of a result item to the user information need expressed
using the XQuery <span>3.0</span> and XPath <span>3.0</span>
expression. The numeric score is computed using an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
<em>scoring algorithm</em>.</p>
<p>There are numerous scoring algorithms used in practice. Most of
the scoring algorithms take as inputs a query and a set of results
to the query. In computing the score, these algorithms rely on the
structure of the query to estimate the relevance of the
results.</p>
<p>In the context of defining the semantics of XQuery and XPath
Full Text, passing the structure of the query poses a problem. The
query may contain XQuery <span>3.0</span> and XPath
<span>3.0</span> expressions and XQuery and XPath Full Text 3.0
expressions in particular. The semantics of XQuery <span>3.0</span>
and XPath <span>3.0</span> expressions is defined using (among
other things) functions that take as arguments sequences of items
and return sequences of items. They are not aware of what
expression produced a particular sequence, i.e., they are not aware
of the expression structure.</p>
<p>To define the semantics of scoring in XQuery and XPath Full Text
3.0 using XQuery <span>3.0</span>, expressions that produce the
query result (or the functions that implement the expressions) must
be passed as arguments. In other words, second-order functions are
necessary. Currently XQuery <span>3.0</span> and XPath
<span>3.0</span> do not provide such functions.</p>
<p>Nevertheless, in the interest of the exposition, assume that
such second-order functions are present. In particular, that there
are two semantic second-order function <code>fts:score</code> and
<code>fts:scoreSequence</code> that take one argument (an
expression) and return the score value of this expression,
respectively a sequence of score values, one for each item to which
the expression evaluates. The scores must satisfy <a href=
"#section-score-variables">scoring properties</a>.</p>
<p>A <code>for</code> clause containing a score variable</p>
<div class="exampleInner">
<pre>
for $result score $score in Expr
...
</pre></div>
<p>is evaluated as though it is replaced by the following the set
of clauses.</p>
<div class="exampleInner">
<pre>
let $scoreSeq := fts:scoreSequence(Expr)
for $result at $i in Expr
let $score := $scoreSeq[$i]
...
</pre></div>
<p>Here, <code>$scoreSeq</code> and <code>$i</code> are new
variables, not appearing elsewhere, and
<code>fts:scoreSequence</code> is the second-order function.</p>
<p>Similarly, a <code>let</code> clause containing a score
variable</p>
<div class="exampleInner">
<pre>
let score $score := Expr
...
</pre></div>
<p>is evaluated as though it is replaced by the following
clause.</p>
<div class="exampleInner">
<pre>
let $score := fts:score(Expr)
...
</pre></div>
</div>
</div>
<div class="xquery">
<div class="div2">
<h3><a name="tq-ft-FTContainsExpr-example" id=
"tq-ft-FTContainsExpr-example"></a>4.5 Example</h3>
<p>This section presents a more complex example for the evaluation
of <b>FTContainsExpr</b>. This example uses the same sample
document fragment and assigns it <code>$doc</code>. Consider the
following <b>FTContainsExpr</b>.</p>
<div class="xpath">
<div class="exampleInner">
<pre>
    $doc contains text (
        (
            "Mustang"
            ftand
            ({("great", "excellent")} any word occurs at least 2 times)
            window 11 words
        )
        ftand
        ftnot "rust"
    ) same paragraph
</pre></div>
</div>
<p>Begin by evaluating the <b>FTSelection</b> to
<b>AllMatches</b>.</p>
<div class="exampleInner">
<pre>
    (
        (
            "Mustang"
            ftand
            ({("great", "excellent")} any word occurs at least 2 times)
            window 11 words
        )
        ftand
        ftnot "rust"
    ) same paragraph
</pre></div>
<p>Step 1: Evaluate the <b>FTWords</b> <code>"Mustang"</code>.</p>
<img src="images/CompleteExample01.jpg" alt="Example, step 1" />
<p>Step 2: Evaluate the <b>FTWords</b> <code>{"great", "excellent"}
any word</code>.</p>
<p>Step 2.1: Match the token "great"</p>
<img src="images/CompleteExample02.jpg" alt="Example, step 2" />
<p>Step 2.2 Match the token "excellent"</p>
<img src="images/CompleteExample03.jpg" alt="Example, step 3" />
<p>Step 2.3 - Combine the above <b>AllMatches</b> as if <b>FTOr</b>
is used, i.e., by forming a union of the <b>Match</b>es.</p>
<img src="images/CompleteExample04.jpg" alt="Example, step 4" />
<p>Step 3 - Apply the <b>FTTimes</b> <code>{("great", "excellent")}
any word occurs at least 2 times</code> forming two pairs of
<b>Match</b>es.</p>
<img src="images/CompleteExample05_1.jpg" alt=
"Example, step 5.1" />
<p><img src="images/CompleteExample05_1_2.jpg" alt=
"Example, step 5.1" /></p>
<img src="images/CompleteExample05_2.jpg" alt=
"Example, step 5.2" />
<p>Step 4 - Apply the <b>FTAnd</b> <code>"Mustang" ftand
({("great", "excellent")} any word occurs at least 2 times)</code>
forming all possible pairs of <b>StringMatch</b>es.</p>
<img src="images/CompleteExample06_1.jpg" alt=
"Example, step 6.1" />
<p><img src="images/CompleteExample06_1_2.jpg" alt=
"Example, step 6.1" /></p>
<img src="images/CompleteExample06_2.jpg" alt=
"Example, step 6.2" />
<p><img src="images/CompleteExample06_2_2.jpg" alt=
"Example, step 6.2" /></p>
<img src="images/CompleteExample06_3.jpg" alt=
"Example, step 6.3" />
<p><img src="images/CompleteExample06_3_2.jpg" alt=
"Example, step 6.3" /></p>
<img src="images/CompleteExample06_4.jpg" alt=
"Example, step 6.4" />
<p><img src="images/CompleteExample06_4_2.jpg" alt=
"Example, step 6.4" /></p>
<img src="images/CompleteExample06_5.jpg" alt=
"Example, step 6.5" />
<p><img src="images/CompleteExample06_5_2.jpg" alt=
"Example, step 6.5" /></p>
<p>Step 5 - Apply the <b>FTWindow</b> <code>( "Mustang" ftand
({("great", "excellent")} any word occurs at least 2 times) window
11 words )</code> , filtering out <b>Match</b>es for which the
window is not less than or equal to 11 tokens.</p>
<img src="images/CompleteExample07_1.jpg" alt=
"Example, step 7.1" />
<p><img src="images/CompleteExample07_2.jpg" alt=
"Example, step 7.2" /></p>
<img src="images/CompleteExample07_2_2.jpg" alt=
"Example, step 7.2" />
<p>Step 6 - Evaluate <b>FTWords</b> <code>"rust"</code>.</p>
<img src="images/CompleteExample08.jpg" alt="Example, step 8" />
<p>Step 7 - Apply the <b>FTUnaryNot</b> <code>ftnot "rust"</code>,
transforming the <code>StringInclude</code> into a
<code>StringExclude</code>.</p>
<img src="images/CompleteExample09.jpg" alt="Example, step 9" />
<p>Step 8 - Apply the <b>FTAnd</b> <code>( ( "Mustang" ftand
({("great", "excellent")} any word occurs at least 2 times) window
11 words ) ftand ftnot "rust" )</code> , forming all possible
combintations of three <b>StringMatch</b>es from the first
<b>AllMatches</b> and one <b>StringMatch</b> from the second
<b>AllMatches</b>.</p>
<img src="images/CompleteExample10_1.jpg" alt=
"Example, step 10.1" />
<p><img src="images/CompleteExample10_2.jpg" alt=
"Example, step 10.2" /></p>
<img src="images/CompleteExample10_3.jpg" alt=
"Example, step 10.3" />
<p>Step 9: Apply the <b>FTScope</b>, filtering out <b>Match</b>es
whose <b>TokenInfo</b>s are not within the same paragraph (assuming
the <code>&lt;offer&gt;</code> elements determine paragraph
boundaries).</p>
<img src="images/CompleteExample11.jpg" alt="Example, step 11" />
<p>The resulting <b>AllMatches</b> contains a <b>Match</b> that
does not contain a <b>StringExclude</b>. Therefore, the sample
<b>FTContainsExpr</b> returns <code>true</code>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-tq-conformance" id="id-tq-conformance"></a>5
Conformance</h2>
<p>This section defines the conformance criteria for a XQuery and
XPath Full Text 3.0 processor.</p>
<p>In this section, the following terms are used to indicate the
requirement levels defined in <a href="#RFC2119">[RFC 2119]</a>.
[<a name="must" id="must" title="must">Definition</a>: <b>MUST</b>
means that the item is an absolute requirement of the
specification.] [<a name="may" id="may" title="may">Definition</a>:
<b>MAY</b> means that an item is truly optional.] [<a name="should"
id="should" title="should">Definition</a>: <b>SHOULD</b> means that
there may exist valid reasons in particular circumstances to ignore
a particular item, but the full implications must be understood and
carefully weighed before choosing a different course.]</p>
<p>An XQuery and XPath Full Text 3.0 processor that claims to
conform to this specification <a title="must" href="#must">MUST</a>
include a claim of Minimal Conformance as defined in <a href=
"#id-minimal-conformance"><b>5.1 Minimal Conformance</b></a>. In
addition to a claim of Minimal Conformance, it <a title="may" href=
"#may">MAY</a> claim conformance to one or more optional features
defined in <a href="#id-conform-optional-features"><b>5.2 Optional
Features</b></a></p>
<div class="div2">
<h3><a name="id-minimal-conformance" id=
"id-minimal-conformance"></a>5.1 Minimal Conformance</h3>
<p>Minimal Conformance to this specification <a title="must" href=
"#must">MUST</a> include all of the following items:</p>
<ol class="enumar">
<li>
<p>Minimal support for XQuery <span>3.0 <a href=
"#xquery-30">[XQuery 3.0: An XML Query Language]</a></span> or
XPath <span>3.0 <a href="#xpath-30">[XML Path Language (XPath)
3.0]</a></span> . The optional features of XQuery <span>3.0
<a href="#xquery-30">[XQuery 3.0: An XML Query Language]</a></span>
or XPath <span>3.0 <a href="#xpath-30">[XML Path Language (XPath)
3.0]</a></span> <a title="may" href="#may">MAY</a> be
supported.</p>
</li>
<li>
<p>Support for everything specified in this document except those
operators and match options specified in <a href=
"#id-conform-optional-features"><b>5.2 Optional Features</b></a> to
be optional. If an implementation does not provide a given optional
operator or match option, it <a title="must" href="#must">MUST</a>
implement any requirements specified in <a href=
"#id-conform-optional-features"><b>5.2 Optional Features</b></a>
for implementations that do not provide that operator or match
option.</p>
</li>
<li>
<p>A definition of every item specified to be <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> in <a href=
"#impl-def"><b>I Checklist of Implementation-Defined
Features</b></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations are not required to define items specified to be
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a></p>
</div>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-conform-optional-features" id=
"id-conform-optional-features"></a>5.2 Optional Features</h3>
<div class="div3">
<h4><a name="id-ftmildnot-option" id=
"id-ftmildnot-option"></a>5.2.1 FTMildNot Operator</h4>
<p>It is optional whether the implementation supports the
FTMildNot. If it does not support FTMildNot and encounters one in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0001" title=
"err:FTST0001">err:FTST0001</a>].</p>
</div>
<div class="div3">
<h4><a name="id-unary-not-option" id=
"id-unary-not-option"></a>5.2.2 FTUnaryNot Operator</h4>
<p>The unrestricted form of negation in FTUnaryNot, that can negate
every kind of FTSelection, is optional. Implementations may choose
to support the negation operation in a restricted form, enforcing
one or both of the following restrictions.</p>
<ul>
<li>
<p>[<a name="id-Negation-Restriction-1" id=
"id-Negation-Restriction-1" title=
"Negation Restriction 1">Definition</a>: <b>Negation Restriction
1.</b> An <a href="#doc-xquery30-FTUnaryNot">FTUnaryNot</a>
expression may only appear as a direct right operand of an "ftand"
(<a href="#doc-xquery30-FTAnd">FTAnd</a>) operation.]</p>
</li>
<li>
<p>[<a name="id-Negation-Restriction-2" id=
"id-Negation-Restriction-2" title=
"Negation Restriction 2">Definition</a>: <b>Negation Restriction
2.</b> An <a href="#doc-xquery30-FTUnaryNot">FTUnaryNot</a>
expression may not appear as a descendant of an <a href=
"#doc-xquery30-FTOr">FTOr</a> that is modified by an <a href=
"#doc-xquery30-FTPosFilter">FTPosFilter</a>. (An FTOr is modified
by an FTPosFilter, if it is derived using the production for
<a href="#doc-xquery30-FTSelection">FTSelection</a> together with
that FTPosFilter.)]</p>
</li>
</ul>
<p>Consider the following example FTSelections.</p>
<div class="exampleInner">
<pre>
1. ftnot "web"

2. "web" ftand ( ftnot "information" ftor "retrieval" )

3. "web" ftand ftnot("information" ftand "retrieval")

4. "web" ftand ftnot("information" ftand "retrieval" window 5 words)

5. "web" ftand ("information" ftand ftnot "retrieval" window 5 words)
</pre></div>
<p>The first two FTSelections both violate restriction 1, while the
third and the fourth are conform with both restrictions. The fifth
one violates restriction 2, while obeying restriction 1. Note that
in the last example the FTSelection to which the window operation
is applied is <code>"information" ftand ftnot "retrieval"</code>,
which contains an FTUnaryNot expression.</p>
<p>If the implementation does enforce one or both of these
restrictions on FTUnaryNot and encounters a full-text query that
does not obey the restriction then it <a title="must" href=
"#must">MUST</a> raise an error [<a href="#ERRFTST0002" title=
"err:FTST0002">err:FTST0002</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftunit-option" id="id-ftunit-option"></a>5.2.3
FTUnit and FTBigUnit</h4>
<p>Support for the "sentences" alternative of <a href=
"#doc-xquery30-FTUnit">FTUnit</a> and the "sentence" alternative of
<a href="#doc-xquery30-FTBigUnit">FTBigUnit</a> is optional.
Similarly, support for the "paragraphs" alternative of FTUnit and
the "paragraph" alternative of FTBigUnit is optional. If an
implementation does not support one or more choices of FTUnit or
FTBigUnit and encounters an unsupported FTUnit or FTBigUnit in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0003" title=
"err:FTST0003">err:FTST0003</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftorder-option" id="id-ftorder-option"></a>5.2.4
FTOrder Operator</h4>
<p>The unrestricted form of the FTOrder postfix operator, that can
be applied to any kind of FTSelection, is optional. Implementations
may choose to enforce the following restriction on the use of
FTOrder.</p>
<p>[<a name="id-Order-Operator-Restriction" id=
"id-Order-Operator-Restriction" title=
"Order Operator Restriction">Definition</a>: <b>Order Operator
Restriction.</b> FTOrder may only appear directly succeeding an
FTWindow or an FTDistance operator.]</p>
<p>If the implementation does enforce this restriction and
encounters a full-text query that does not obey the restriction
then it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTST0010" title="err:FTST0010">err:FTST0010</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftscope-option" id="id-ftscope-option"></a>5.2.5
FTScope Operator</h4>
<p>It is optional whether the implementation supports the FTScope
operator. If it does not support FTScope and encounters one in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0004" title=
"err:FTST0004">err:FTST0004</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftwindow-option" id="id-ftwindow-option"></a>5.2.6
FTWindow Operator</h4>
<p>The unrestricted form of the FTWindow postfix operator, that can
be applied to any kind of FTSelection, is optional. Implementations
may choose to enforce the following restriction on the use of
FTWindow.</p>
<p>[<a name="id-Window-Operator-Restriction" id=
"id-Window-Operator-Restriction" title=
"Window Operator Restriction">Definition</a>: <b>Window Operator
Restriction.</b> FTWindow can only be applied to an FTOr that is
either a single FTWords or a combination of FTWords involving only
the operators ftand and ftor.]</p>
<p>If the implementation does enforce this restriction and
encounters a full-text query that does not obey the restriction
then it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTST0011" title="err:FTST0011">err:FTST0011</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftdistance-option" id=
"id-ftdistance-option"></a>5.2.7 FTDistance Operator</h4>
<p>The unrestricted form of the FTDistance postfix operator, that
can be applied to any kind of FTSelection, is optional.
Implementations may choose to enforce the following restriction on
the use of FTDistance.</p>
<p>[<a name="id-Distance-Operator-Restriction" id=
"id-Distance-Operator-Restriction" title=
"Distance Operator Restriction">Definition</a>: <b>Distance
Operator Restriction.</b> FTDistance can only be applied to an FTOr
that is either a single FTWords or a combination of FTWords
involving only the operators ftand and ftor.]</p>
<p>If the implementation does enforce this restriction and
encounters a full-text query that does not obey the restriction
then it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTST0011" title="err:FTST0011">err:FTST0011</a>].</p>
</div>
<div class="div3">
<h4><a name="id-fttimes-option" id="id-fttimes-option"></a>5.2.8
FTTimes Operator</h4>
<p>It is optional whether the implementation supports the FTTimes
operator. If it does not support FTTimes and encounters one in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0005" title=
"err:FTST0005">err:FTST0005</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftcontent-option" id=
"id-ftcontent-option"></a>5.2.9 FTContent Operator</h4>
<p>It is optional whether the implementation supports the FTContent
operator. If it does not support FTContent and encounters one in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0012" title=
"err:FTST0012">err:FTST0012</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftcase-option" id="id-ftcase-option"></a>5.2.10
FTCaseOption</h4>
<p>It is optional whether the implementation supports the
"lowercase" and "uppercase" choices for the FTCaseOption. If it
does not support these choices for the FTCaseOption and encounters
an unsupported choice in a full-text query, then it <a title="must"
href="#must">MUST</a> raise an error [<a href="#ERRFTST0015" title=
"err:FTST0015">err:FTST0015</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftstopword-option" id=
"id-ftstopword-option"></a>5.2.11 FTStopWordOption</h4>
<p>It is optional whether the implementation supports the
FTStopWordOption. If it does not support FTStopWordOption and
encounters one in a full-text query, then it <a title="must" href=
"#must">MUST</a> raise an error [<a href="#ERRFTST0006" title=
"err:FTST0006">err:FTST0006</a>].</p>
<p>It is optional whether the implementation supports the
FTStopWordOption in the body of the query. If it supports
FTStopWordOption in the prolog, but not in the body of a query, and
encounters one in the body of a query it <a title="must" href=
"#must">MUST</a> raise an error [<a href="#ERRFTST0006" title=
"err:FTST0006">err:FTST0006</a>].</p>
<p>It is optional whether the implementation supports the
StringLiteral alternative of <a href=
"#doc-xquery30-FTStopWords">FTStopWords</a> in the
FTStopWordOption. If it does not support the StringLiteral
alternative of FTStopWords and encounters such an alternative in a
full-text query, then it <a title="must" href="#must">MUST</a>
raise an error [<a href="#ERRFTST0006" title=
"err:FTST0006">err:FTST0006</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftlanguage-option" id=
"id-ftlanguage-option"></a>5.2.12 FTLanguageOption</h4>
<p>It is optional whether the implementation supports the
unrestricted form of FTLanguageOption. Implementations may choose
to enforce the following restriction on the use of
FTLanguageOption.</p>
<p>[<a name="id-Single-Language-Restriction" id=
"id-Single-Language-Restriction" title=
"Single Language Restriction">Definition</a>: <b>Single Language
Restriction.</b> If a full-text query contains more than one
FTLanguageOption in its body and the prolog, then the languages
specified must be the same.]</p>
<p>If the implementation does enforce this restriction and
encounters a full-text query that does not obey the restriction
then it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTST0013" title="err:FTST0013">err:FTST0013</a>].</p>
</div>
<div class="div3">
<h4><a name="id-ftignore-option" id="id-ftignore-option"></a>5.2.13
FTIgnoreOption</h4>
<p>The implementation may constrain the set of ignored nodes. If
the operand of <a href=
"#doc-xquery30-FTIgnoreOption">FTIgnoreOption</a> violates the
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> restriction
on that operand, it <a title="must" href="#must">MUST</a> raise an
error [<a href="#ERRFTST0007" title=
"err:FTST0007">err:FTST0007</a>].</p>
</div>
<div class="div3">
<h4><a name="id-scoring-option" id="id-scoring-option"></a>5.2.14
Scoring</h4>
<p>The implementation may restrict the allowable expressions used
to compute scores. The restrictions are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>If the implementation does enforce such restrictions and
encounters a full-text query that does not obey the restriction
then it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTST0014" title="err:FTST0014">err:FTST0014</a>].</p>
</div>
<div class="div3">
<h4><a name="id-weights-conf" id="id-weights-conf"></a>5.2.15
Weights</h4>
<p>An implementation may constrain the range of valid weights to
non-negative values. If an implementation does enforce this
restriction and encounters a full-text query that uses a negative
weight, it <a title="must" href="#must">MUST</a> raise an error
[<a href="#ERRFTDY0016" title="err:FTDY0016">err:FTDY0016</a>].</p>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="id-grammar" id="id-grammar"></a>A EBNF for XQuery
<span>3.0</span> Grammar with Full Text extensions</h2>
<p>The EBNF in this document and in this section is aligned with
the current XML Query 1.0 grammar <span>(see <a href=
"http://www.w3.org/TR/xquery-30/">http://www.w3.org/TR/xquery-30/</a>)</span>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Module" id=
"prod-xquery30-Module"></a>[1]&#160;&#160;&#160;</td>
<td><code>Module</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-VersionDecl">VersionDecl</a>?
(<a href="#prod-xquery30-LibraryModule">LibraryModule</a> |
<a href="#prod-xquery30-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VersionDecl" id=
"prod-xquery30-VersionDecl"></a>[2]&#160;&#160;&#160;</td>
<td><code>VersionDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"xquery" (("encoding" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>) | ("version"
<a href="#prod-xquery30-StringLiteral">StringLiteral</a>
("encoding" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)?)) <a href=
"#prod-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-MainModule" id=
"prod-xquery30-MainModule"></a>[3]&#160;&#160;&#160;</td>
<td><code>MainModule</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Prolog">Prolog</a> <a href=
"#prod-xquery30-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LibraryModule" id=
"prod-xquery30-LibraryModule"></a>[4]&#160;&#160;&#160;</td>
<td><code>LibraryModule</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ModuleDecl">ModuleDecl</a>
<a href="#prod-xquery30-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ModuleDecl" id=
"prod-xquery30-ModuleDecl"></a>[5]&#160;&#160;&#160;</td>
<td><code>ModuleDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> <a href=
"#prod-xquery30-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Prolog" id=
"prod-xquery30-Prolog"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Prolog">Prolog</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href=
"#prod-xquery30-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#prod-xquery30-Setter">Setter</a> | <a href=
"#prod-xquery30-NamespaceDecl">NamespaceDecl</a> | <a href=
"#prod-xquery30-Import">Import</a> | <a href=
"#prod-xquery30-FTOptionDecl">FTOptionDecl</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)* ((<a href=
"#prod-xquery30-ContextItemDecl">ContextItemDecl</a> | <a href=
"#prod-xquery30-AnnotatedDecl">AnnotatedDecl</a> | <a href=
"#prod-xquery30-OptionDecl">OptionDecl</a>) <a href=
"#prod-xquery30-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Separator" id=
"prod-xquery30-Separator"></a>[7]&#160;&#160;&#160;</td>
<td><code>Separator</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Setter" id=
"prod-xquery30-Setter"></a>[8]&#160;&#160;&#160;</td>
<td><code>Setter</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#prod-xquery30-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#prod-xquery30-BaseURIDecl">BaseURIDecl</a> | <a href=
"#prod-xquery30-ConstructionDecl">ConstructionDecl</a> | <a href=
"#prod-xquery30-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#prod-xquery30-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#prod-xquery30-CopyNamespacesDecl">CopyNamespacesDecl</a> |
<a href=
"#prod-xquery30-DecimalFormatDecl">DecimalFormatDecl</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BoundarySpaceDecl" id=
"prod-xquery30-BoundarySpaceDecl"></a>[9]&#160;&#160;&#160;</td>
<td><code>BoundarySpaceDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DefaultCollationDecl" id=
"prod-xquery30-DefaultCollationDecl"></a>[10]&#160;&#160;&#160;</td>
<td><code>DefaultCollationDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BaseURIDecl" id=
"prod-xquery30-BaseURIDecl"></a>[11]&#160;&#160;&#160;</td>
<td><code>BaseURIDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ConstructionDecl" id=
"prod-xquery30-ConstructionDecl"></a>[12]&#160;&#160;&#160;</td>
<td><code>ConstructionDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderingModeDecl" id=
"prod-xquery30-OrderingModeDecl"></a>[13]&#160;&#160;&#160;</td>
<td><code>OrderingModeDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EmptyOrderDecl" id=
"prod-xquery30-EmptyOrderDecl"></a>[14]&#160;&#160;&#160;</td>
<td><code>EmptyOrderDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CopyNamespacesDecl" id=
"prod-xquery30-CopyNamespacesDecl"></a>[15]&#160;&#160;&#160;</td>
<td><code>CopyNamespacesDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#prod-xquery30-PreserveMode">PreserveMode</a> "," <a href=
"#prod-xquery30-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PreserveMode" id=
"prod-xquery30-PreserveMode"></a>[16]&#160;&#160;&#160;</td>
<td><code>PreserveMode</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InheritMode" id=
"prod-xquery30-InheritMode"></a>[17]&#160;&#160;&#160;</td>
<td><code>InheritMode</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DecimalFormatDecl" id=
"prod-xquery30-DecimalFormatDecl"></a>[18]&#160;&#160;&#160;</td>
<td><code>DecimalFormatDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" (("decimal-format" <a href=
"#prod-xquery30-EQName">EQName</a>) | ("default" "decimal-format"))
(<a href="#prod-xquery30-DFPropertyName">DFPropertyName</a> "="
<a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DFPropertyName" id=
"prod-xquery30-DFPropertyName"></a>[19]&#160;&#160;&#160;</td>
<td><code>DFPropertyName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"decimal-separator" | "grouping-separator" | "infinity" |
"minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" |
"digit" | "pattern-separator"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Import" id=
"prod-xquery30-Import"></a>[20]&#160;&#160;&#160;</td>
<td><code>Import</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-SchemaImport">SchemaImport</a> |
<a href="#prod-xquery30-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaImport" id=
"prod-xquery30-SchemaImport"></a>[21]&#160;&#160;&#160;</td>
<td><code>SchemaImport</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#prod-xquery30-SchemaPrefix">SchemaPrefix</a>? <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaPrefix" id=
"prod-xquery30-SchemaPrefix"></a>[22]&#160;&#160;&#160;</td>
<td><code>SchemaPrefix</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xquery30-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ModuleImport" id=
"prod-xquery30-ModuleImport"></a>[23]&#160;&#160;&#160;</td>
<td><code>ModuleImport</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=")? <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery30-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamespaceDecl" id=
"prod-xquery30-NamespaceDecl"></a>[24]&#160;&#160;&#160;</td>
<td><code>NamespaceDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery30-NCName">NCName</a> "=" <a href=
"#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DefaultNamespaceDecl" id=
"prod-xquery30-DefaultNamespaceDecl"></a>[25]&#160;&#160;&#160;</td>
<td><code>DefaultNamespaceDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#prod-xquery30-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTOptionDecl" id=
"prod-xquery30-FTOptionDecl"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTOptionDecl">FTOptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ft-option" <a href=
"#prod-xquery30-FTMatchOptions">FTMatchOptions</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnnotatedDecl" id=
"prod-xquery30-AnnotatedDecl"></a>[27]&#160;&#160;&#160;</td>
<td><code>AnnotatedDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" <a href=
"#prod-xquery30-Annotation">Annotation</a>* (<a href=
"#prod-xquery30-VarDecl">VarDecl</a> | <a href=
"#prod-xquery30-FunctionDecl">FunctionDecl</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Annotation" id=
"prod-xquery30-Annotation"></a>[28]&#160;&#160;&#160;</td>
<td><code>Annotation</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"%" <a href="#prod-xquery30-EQName">EQName</a> ("("
<a href="#prod-xquery30-Literal">Literal</a> ("," <a href=
"#prod-xquery30-Literal">Literal</a>)* ")")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarDecl" id=
"prod-xquery30-VarDecl"></a>[29]&#160;&#160;&#160;</td>
<td><code>VarDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"variable" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? ((":="
<a href="#prod-xquery30-VarValue">VarValue</a>) | ("external" (":="
<a href=
"#prod-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarValue" id=
"prod-xquery30-VarValue"></a>[30]&#160;&#160;&#160;</td>
<td><code>VarValue</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarDefaultValue" id=
"prod-xquery30-VarDefaultValue"></a>[31]&#160;&#160;&#160;</td>
<td><code>VarDefaultValue</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContextItemDecl" id=
"prod-xquery30-ContextItemDecl"></a>[32]&#160;&#160;&#160;</td>
<td><code>ContextItemDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "context" "item" ("as" <a href=
"#prod-xquery30-ItemType">ItemType</a>)? ((":=" <a href=
"#prod-xquery30-VarValue">VarValue</a>) | ("external" (":="
<a href="#prod-xquery30-VarDefaultValue">VarDefaultValue</a>)?))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionDecl" id=
"prod-xquery30-FunctionDecl"></a>[33]&#160;&#160;&#160;</td>
<td><code>FunctionDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" <a href="#prod-xquery30-EQName">EQName</a> "("
<a href="#prod-xquery30-ParamList">ParamList</a>? ")" ("as"
<a href="#prod-xquery30-SequenceType">SequenceType</a>)? (<a href=
"#prod-xquery30-FunctionBody">FunctionBody</a> |
"external")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-reserved-function-names">xgc:
reserved-function-names</a><sup><small>XQ</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParamList" id=
"prod-xquery30-ParamList"></a>[34]&#160;&#160;&#160;</td>
<td><code>ParamList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Param">Param</a> ("," <a href=
"#prod-xquery30-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Param" id=
"prod-xquery30-Param"></a>[35]&#160;&#160;&#160;</td>
<td><code>Param</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionBody" id=
"prod-xquery30-FunctionBody"></a>[36]&#160;&#160;&#160;</td>
<td><code>FunctionBody</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EnclosedExpr" id=
"prod-xquery30-EnclosedExpr"></a>[37]&#160;&#160;&#160;</td>
<td><code>EnclosedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OptionDecl" id=
"prod-xquery30-OptionDecl"></a>[38]&#160;&#160;&#160;</td>
<td><code>OptionDecl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" <a href=
"#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QueryBody" id=
"prod-xquery30-QueryBody"></a>[39]&#160;&#160;&#160;</td>
<td><code>QueryBody</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Expr" id=
"prod-xquery30-Expr"></a>[40]&#160;&#160;&#160;</td>
<td><code>Expr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a> (","
<a href="#prod-xquery30-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ExprSingle" id=
"prod-xquery30-ExprSingle"></a>[41]&#160;&#160;&#160;</td>
<td><code>ExprSingle</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FLWORExpr">FLWORExpr</a><br />
| <a href="#prod-xquery30-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xquery30-SwitchExpr">SwitchExpr</a><br />
| <a href="#prod-xquery30-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#prod-xquery30-IfExpr">IfExpr</a><br />
| <a href="#prod-xquery30-TryCatchExpr">TryCatchExpr</a><br />
| <a href="#prod-xquery30-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FLWORExpr" id=
"prod-xquery30-FLWORExpr"></a>[42]&#160;&#160;&#160;</td>
<td><code>FLWORExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-InitialClause">InitialClause</a>
<a href="#prod-xquery30-IntermediateClause">IntermediateClause</a>*
<a href="#prod-xquery30-ReturnClause">ReturnClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InitialClause" id=
"prod-xquery30-InitialClause"></a>[43]&#160;&#160;&#160;</td>
<td><code>InitialClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ForClause">ForClause</a> |
<a href="#prod-xquery30-LetClause">LetClause</a> | <a href=
"#prod-xquery30-WindowClause">WindowClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntermediateClause" id=
"prod-xquery30-IntermediateClause"></a>[44]&#160;&#160;&#160;</td>
<td><code>IntermediateClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-InitialClause">InitialClause</a>
| <a href="#prod-xquery30-WhereClause">WhereClause</a> | <a href=
"#prod-xquery30-GroupByClause">GroupByClause</a> | <a href=
"#prod-xquery30-OrderByClause">OrderByClause</a> | <a href=
"#prod-xquery30-CountClause">CountClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForClause" id=
"prod-xquery30-ForClause"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href="#prod-xquery30-ForBinding">ForBinding</a>
("," <a href=
"#prod-xquery30-ForBinding">ForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForBinding" id=
"prod-xquery30-ForBinding"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-ForBinding">ForBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? <a href=
"#prod-xquery30-AllowingEmpty">AllowingEmpty</a>? <a href=
"#prod-xquery30-PositionalVar">PositionalVar</a>? <a href=
"#prod-xquery30-FTScoreVar">FTScoreVar</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AllowingEmpty" id=
"prod-xquery30-AllowingEmpty"></a>[47]&#160;&#160;&#160;</td>
<td><code>AllowingEmpty</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"allowing" "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PositionalVar" id=
"prod-xquery30-PositionalVar"></a>[48]&#160;&#160;&#160;</td>
<td><code>PositionalVar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTScoreVar" id=
"prod-xquery30-FTScoreVar"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTScoreVar">FTScoreVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"score" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LetClause" id=
"prod-xquery30-LetClause"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href="#prod-xquery30-LetBinding">LetBinding</a>
("," <a href=
"#prod-xquery30-LetBinding">LetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-LetBinding" id=
"prod-xquery30-LetBinding"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-LetBinding">LetBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("$" <a href="#prod-xquery30-VarName">VarName</a>
<a href="#prod-xquery30-TypeDeclaration">TypeDeclaration</a>?) |
<a href="#prod-xquery30-FTScoreVar">FTScoreVar</a>) ":=" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowClause" id=
"prod-xquery30-WindowClause"></a>[52]&#160;&#160;&#160;</td>
<td><code>WindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" (<a href=
"#prod-xquery30-TumblingWindowClause">TumblingWindowClause</a> |
<a href=
"#prod-xquery30-SlidingWindowClause">SlidingWindowClause</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TumblingWindowClause" id=
"prod-xquery30-TumblingWindowClause"></a>[53]&#160;&#160;&#160;</td>
<td><code>TumblingWindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"tumbling" "window" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> <a href=
"#prod-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#prod-xquery30-WindowEndCondition">WindowEndCondition</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SlidingWindowClause" id=
"prod-xquery30-SlidingWindowClause"></a>[54]&#160;&#160;&#160;</td>
<td><code>SlidingWindowClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sliding" "window" "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> <a href=
"#prod-xquery30-WindowStartCondition">WindowStartCondition</a>
<a href=
"#prod-xquery30-WindowEndCondition">WindowEndCondition</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowStartCondition" id=
"prod-xquery30-WindowStartCondition"></a>[55]&#160;&#160;&#160;</td>
<td><code>WindowStartCondition</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"start" <a href=
"#prod-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowEndCondition" id=
"prod-xquery30-WindowEndCondition"></a>[56]&#160;&#160;&#160;</td>
<td><code>WindowEndCondition</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"only"? "end" <a href=
"#prod-xquery30-WindowVars">WindowVars</a> "when" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WindowVars" id=
"prod-xquery30-WindowVars"></a>[57]&#160;&#160;&#160;</td>
<td><code>WindowVars</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" <a href=
"#prod-xquery30-CurrentItem">CurrentItem</a>)? <a href=
"#prod-xquery30-PositionalVar">PositionalVar</a>? ("previous" "$"
<a href="#prod-xquery30-PreviousItem">PreviousItem</a>)? ("next"
"$" <a href="#prod-xquery30-NextItem">NextItem</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CurrentItem" id=
"prod-xquery30-CurrentItem"></a>[58]&#160;&#160;&#160;</td>
<td><code>CurrentItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PreviousItem" id=
"prod-xquery30-PreviousItem"></a>[59]&#160;&#160;&#160;</td>
<td><code>PreviousItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NextItem" id=
"prod-xquery30-NextItem"></a>[60]&#160;&#160;&#160;</td>
<td><code>NextItem</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CountClause" id=
"prod-xquery30-CountClause"></a>[61]&#160;&#160;&#160;</td>
<td><code>CountClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"count" "$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-WhereClause" id=
"prod-xquery30-WhereClause"></a>[62]&#160;&#160;&#160;</td>
<td><code>WhereClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"where" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupByClause" id=
"prod-xquery30-GroupByClause"></a>[63]&#160;&#160;&#160;</td>
<td><code>GroupByClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"group" "by" <a href=
"#prod-xquery30-GroupingSpecList">GroupingSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingSpecList" id=
"prod-xquery30-GroupingSpecList"></a>[64]&#160;&#160;&#160;</td>
<td><code>GroupingSpecList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-GroupingSpec">GroupingSpec</a>
("," <a href=
"#prod-xquery30-GroupingSpec">GroupingSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingSpec" id=
"prod-xquery30-GroupingSpec"></a>[65]&#160;&#160;&#160;</td>
<td><code>GroupingSpec</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-GroupingVariable">GroupingVariable</a> (<a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a>)? ("collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GroupingVariable" id=
"prod-xquery30-GroupingVariable"></a>[66]&#160;&#160;&#160;</td>
<td><code>GroupingVariable</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderByClause" id=
"prod-xquery30-OrderByClause"></a>[67]&#160;&#160;&#160;</td>
<td><code>OrderByClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#prod-xquery30-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderSpecList" id=
"prod-xquery30-OrderSpecList"></a>[68]&#160;&#160;&#160;</td>
<td><code>OrderSpecList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-OrderSpec">OrderSpec</a> (","
<a href="#prod-xquery30-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderSpec" id=
"prod-xquery30-OrderSpec"></a>[69]&#160;&#160;&#160;</td>
<td><code>OrderSpec</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a>
<a href=
"#prod-xquery30-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderModifier" id=
"prod-xquery30-OrderModifier"></a>[70]&#160;&#160;&#160;</td>
<td><code>OrderModifier</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReturnClause" id=
"prod-xquery30-ReturnClause"></a>[71]&#160;&#160;&#160;</td>
<td><code>ReturnClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"return" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuantifiedExpr" id=
"prod-xquery30-QuantifiedExpr"></a>[72]&#160;&#160;&#160;</td>
<td><code>QuantifiedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xquery30-VarName">VarName</a> <a href=
"#prod-xquery30-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchExpr" id=
"prod-xquery30-SwitchExpr"></a>[73]&#160;&#160;&#160;</td>
<td><code>SwitchExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"switch" "(" <a href="#prod-xquery30-Expr">Expr</a> ")"
<a href="#prod-xquery30-SwitchCaseClause">SwitchCaseClause</a>+
"default" "return" <a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchCaseClause" id=
"prod-xquery30-SwitchCaseClause"></a>[74]&#160;&#160;&#160;</td>
<td><code>SwitchCaseClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" <a href=
"#prod-xquery30-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SwitchCaseOperand" id=
"prod-xquery30-SwitchCaseOperand"></a>[75]&#160;&#160;&#160;</td>
<td><code>SwitchCaseOperand</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeswitchExpr" id=
"prod-xquery30-TypeswitchExpr"></a>[76]&#160;&#160;&#160;</td>
<td><code>TypeswitchExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#prod-xquery30-Expr">Expr</a>
")" <a href="#prod-xquery30-CaseClause">CaseClause</a>+ "default"
("$" <a href="#prod-xquery30-VarName">VarName</a>)? "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CaseClause" id=
"prod-xquery30-CaseClause"></a>[77]&#160;&#160;&#160;</td>
<td><code>CaseClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" ("$" <a href="#prod-xquery30-VarName">VarName</a>
"as")? <a href=
"#prod-xquery30-SequenceTypeUnion">SequenceTypeUnion</a> "return"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SequenceTypeUnion" id=
"prod-xquery30-SequenceTypeUnion"></a>[78]&#160;&#160;&#160;</td>
<td><code>SequenceTypeUnion</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-SequenceType">SequenceType</a>
("|" <a href=
"#prod-xquery30-SequenceType">SequenceType</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IfExpr" id=
"prod-xquery30-IfExpr"></a>[79]&#160;&#160;&#160;</td>
<td><code>IfExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xquery30-Expr">Expr</a> ")"
"then" <a href="#prod-xquery30-ExprSingle">ExprSingle</a> "else"
<a href="#prod-xquery30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryCatchExpr" id=
"prod-xquery30-TryCatchExpr"></a>[80]&#160;&#160;&#160;</td>
<td><code>TryCatchExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-TryClause">TryClause</a> <a href=
"#prod-xquery30-CatchClause">CatchClause</a>+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryClause" id=
"prod-xquery30-TryClause"></a>[81]&#160;&#160;&#160;</td>
<td><code>TryClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"try" "{" <a href=
"#prod-xquery30-TryTargetExpr">TryTargetExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TryTargetExpr" id=
"prod-xquery30-TryTargetExpr"></a>[82]&#160;&#160;&#160;</td>
<td><code>TryTargetExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CatchClause" id=
"prod-xquery30-CatchClause"></a>[83]&#160;&#160;&#160;</td>
<td><code>CatchClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"catch" <a href=
"#prod-xquery30-CatchErrorList">CatchErrorList</a> "{" <a href=
"#prod-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CatchErrorList" id=
"prod-xquery30-CatchErrorList"></a>[84]&#160;&#160;&#160;</td>
<td><code>CatchErrorList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-NameTest">NameTest</a> ("|"
<a href="#prod-xquery30-NameTest">NameTest</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrExpr" id=
"prod-xquery30-OrExpr"></a>[85]&#160;&#160;&#160;</td>
<td><code>OrExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AndExpr">AndExpr</a> ( "or"
<a href="#prod-xquery30-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AndExpr" id=
"prod-xquery30-AndExpr"></a>[86]&#160;&#160;&#160;</td>
<td><code>AndExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a> ( "and" <a href=
"#prod-xquery30-ComparisonExpr">ComparisonExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ComparisonExpr" id=
"prod-xquery30-ComparisonExpr"></a>[87]&#160;&#160;&#160;</td>
<td><code>ComparisonExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTContainsExpr">FTContainsExpr</a> ( (<a href=
"#prod-xquery30-ValueComp">ValueComp</a><br />
| <a href="#prod-xquery30-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xquery30-NodeComp">NodeComp</a>) <a href=
"#prod-xquery30-FTContainsExpr">FTContainsExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTContainsExpr" id=
"prod-xquery30-FTContainsExpr"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTContainsExpr">FTContainsExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringConcatExpr">StringConcatExpr</a> ( "contains"
"text" <a href="#prod-xquery30-FTSelection">FTSelection</a>
<a href="#prod-xquery30-FTIgnoreOption">FTIgnoreOption</a>?
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StringConcatExpr" id=
"prod-xquery30-StringConcatExpr"></a>[89]&#160;&#160;&#160;</td>
<td><code>StringConcatExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-RangeExpr">RangeExpr</a> ( "||"
<a href="#prod-xquery30-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-RangeExpr" id=
"prod-xquery30-RangeExpr"></a>[90]&#160;&#160;&#160;</td>
<td><code>RangeExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AdditiveExpr" id=
"prod-xquery30-AdditiveExpr"></a>[91]&#160;&#160;&#160;</td>
<td><code>AdditiveExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xquery30-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-MultiplicativeExpr" id=
"prod-xquery30-MultiplicativeExpr"></a>[92]&#160;&#160;&#160;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xquery30-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnionExpr" id=
"prod-xquery30-UnionExpr"></a>[93]&#160;&#160;&#160;</td>
<td><code>UnionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xquery30-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntersectExceptExpr" id=
"prod-xquery30-IntersectExceptExpr"></a>[94]&#160;&#160;&#160;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-InstanceofExpr">InstanceofExpr</a> ( ("intersect" |
"except") <a href=
"#prod-xquery30-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InstanceofExpr" id=
"prod-xquery30-InstanceofExpr"></a>[95]&#160;&#160;&#160;</td>
<td><code>InstanceofExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#prod-xquery30-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TreatExpr" id=
"prod-xquery30-TreatExpr"></a>[96]&#160;&#160;&#160;</td>
<td><code>TreatExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xquery30-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CastableExpr" id=
"prod-xquery30-CastableExpr"></a>[97]&#160;&#160;&#160;</td>
<td><code>CastableExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-CastExpr">CastExpr</a> (
"castable" "as" <a href="#prod-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CastExpr" id=
"prod-xquery30-CastExpr"></a>[98]&#160;&#160;&#160;</td>
<td><code>CastExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xquery30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnaryExpr" id=
"prod-xquery30-UnaryExpr"></a>[99]&#160;&#160;&#160;</td>
<td><code>UnaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xquery30-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValueExpr" id=
"prod-xquery30-ValueExpr"></a>[100]&#160;&#160;&#160;</td>
<td><code>ValueExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ValidateExpr">ValidateExpr</a> |
<a href="#prod-xquery30-ExtensionExpr">ExtensionExpr</a> | <a href=
"#prod-xquery30-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-GeneralComp" id=
"prod-xquery30-GeneralComp"></a>[101]&#160;&#160;&#160;</td>
<td><code>GeneralComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValueComp" id=
"prod-xquery30-ValueComp"></a>[102]&#160;&#160;&#160;</td>
<td><code>ValueComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NodeComp" id=
"prod-xquery30-NodeComp"></a>[103]&#160;&#160;&#160;</td>
<td><code>NodeComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValidateExpr" id=
"prod-xquery30-ValidateExpr"></a>[104]&#160;&#160;&#160;</td>
<td><code>ValidateExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" (<a href=
"#prod-xquery30-ValidationMode">ValidationMode</a> | ("type"
<a href="#prod-xquery30-TypeName">TypeName</a>))? "{" <a href=
"#prod-xquery30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ValidationMode" id=
"prod-xquery30-ValidationMode"></a>[105]&#160;&#160;&#160;</td>
<td><code>ValidationMode</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ExtensionExpr" id=
"prod-xquery30-ExtensionExpr"></a>[106]&#160;&#160;&#160;</td>
<td><code>ExtensionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Pragma">Pragma</a>+ "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Pragma" id=
"prod-xquery30-Pragma"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-Pragma">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xquery30-S">S</a>? <a href=
"#prod-xquery30-EQName">EQName</a> (<a href=
"#prod-xquery30-S">S</a> <a href=
"#prod-xquery30-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PragmaContents" id=
"prod-xquery30-PragmaContents"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-PragmaContents">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SimpleMapExpr" id=
"prod-xquery30-SimpleMapExpr"></a>[109]&#160;&#160;&#160;</td>
<td><code>SimpleMapExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PathExpr">PathExpr</a> ("!"
<a href="#prod-xquery30-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PathExpr" id=
"prod-xquery30-PathExpr"></a>[110]&#160;&#160;&#160;</td>
<td><code>PathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xquery30-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-leading-lone-slash">xgc:
leading-lone-slash</a><sup><small>XQ</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-RelativePathExpr" id=
"prod-xquery30-RelativePathExpr"></a>[111]&#160;&#160;&#160;</td>
<td><code>RelativePathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-StepExpr">StepExpr</a> (("/" |
"//") <a href="#prod-xquery30-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StepExpr" id=
"prod-xquery30-StepExpr"></a>[112]&#160;&#160;&#160;</td>
<td><code>StepExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PostfixExpr">PostfixExpr</a> |
<a href="#prod-xquery30-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AxisStep" id=
"prod-xquery30-AxisStep"></a>[113]&#160;&#160;&#160;</td>
<td><code>AxisStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ReverseStep">ReverseStep</a> |
<a href="#prod-xquery30-ForwardStep">ForwardStep</a>) <a href=
"#prod-xquery30-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForwardStep" id=
"prod-xquery30-ForwardStep"></a>[114]&#160;&#160;&#160;</td>
<td><code>ForwardStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ForwardAxis">ForwardAxis</a>
<a href="#prod-xquery30-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ForwardAxis" id=
"prod-xquery30-ForwardAxis"></a>[115]&#160;&#160;&#160;</td>
<td><code>ForwardAxis</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AbbrevForwardStep" id=
"prod-xquery30-AbbrevForwardStep"></a>[116]&#160;&#160;&#160;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xquery30-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReverseStep" id=
"prod-xquery30-ReverseStep"></a>[117]&#160;&#160;&#160;</td>
<td><code>ReverseStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-ReverseAxis">ReverseAxis</a>
<a href="#prod-xquery30-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ReverseAxis" id=
"prod-xquery30-ReverseAxis"></a>[118]&#160;&#160;&#160;</td>
<td><code>ReverseAxis</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AbbrevReverseStep" id=
"prod-xquery30-AbbrevReverseStep"></a>[119]&#160;&#160;&#160;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NodeTest" id=
"prod-xquery30-NodeTest"></a>[120]&#160;&#160;&#160;</td>
<td><code>NodeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-KindTest">KindTest</a> | <a href=
"#prod-xquery30-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NameTest" id=
"prod-xquery30-NameTest"></a>[121]&#160;&#160;&#160;</td>
<td><code>NameTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> | <a href=
"#prod-xquery30-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Wildcard" id=
"prod-xquery30-Wildcard"></a>[122]&#160;&#160;&#160;</td>
<td><code>Wildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery30-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery30-NCName">NCName</a>)<br />
| (<a href="#prod-xquery30-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PostfixExpr" id=
"prod-xquery30-PostfixExpr"></a>[123]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-PrimaryExpr">PrimaryExpr</a>
(<a href="#prod-xquery30-Predicate">Predicate</a> | <a href=
"#prod-xquery30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ArgumentList" id=
"prod-xquery30-ArgumentList"></a>[124]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#prod-xquery30-Argument">Argument</a> (","
<a href="#prod-xquery30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PredicateList" id=
"prod-xquery30-PredicateList"></a>[125]&#160;&#160;&#160;</td>
<td><code>PredicateList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Predicate" id=
"prod-xquery30-Predicate"></a>[126]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xquery30-Expr">Expr</a>
"]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PrimaryExpr" id=
"prod-xquery30-PrimaryExpr"></a>[127]&#160;&#160;&#160;</td>
<td><code>PrimaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Literal">Literal</a><br />
| <a href="#prod-xquery30-VarRef">VarRef</a><br />
| <a href=
"#prod-xquery30-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href=
"#prod-xquery30-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#prod-xquery30-FunctionCall">FunctionCall</a><br />
| <a href="#prod-xquery30-OrderedExpr">OrderedExpr</a><br />
| <a href="#prod-xquery30-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#prod-xquery30-Constructor">Constructor</a><br />
| <a href=
"#prod-xquery30-FunctionItemExpr">FunctionItemExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Literal" id=
"prod-xquery30-Literal"></a>[128]&#160;&#160;&#160;</td>
<td><code>Literal</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NumericLiteral">NumericLiteral</a> | <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NumericLiteral" id=
"prod-xquery30-NumericLiteral"></a>[129]&#160;&#160;&#160;</td>
<td><code>NumericLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a> | <a href=
"#prod-xquery30-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xquery30-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarRef" id=
"prod-xquery30-VarRef"></a>[130]&#160;&#160;&#160;</td>
<td><code>VarRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xquery30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-VarName" id=
"prod-xquery30-VarName"></a>[131]&#160;&#160;&#160;</td>
<td><code>VarName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParenthesizedExpr" id=
"prod-xquery30-ParenthesizedExpr"></a>[132]&#160;&#160;&#160;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xquery30-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContextItemExpr" id=
"prod-xquery30-ContextItemExpr"></a>[133]&#160;&#160;&#160;</td>
<td><code>ContextItemExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OrderedExpr" id=
"prod-xquery30-OrderedExpr"></a>[134]&#160;&#160;&#160;</td>
<td><code>OrderedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-UnorderedExpr" id=
"prod-xquery30-UnorderedExpr"></a>[135]&#160;&#160;&#160;</td>
<td><code>UnorderedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionCall" id=
"prod-xquery30-FunctionCall"></a>[136]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> <a href=
"#prod-xquery30-ArgumentList">ArgumentList</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-reserved-function-names">xgc:
reserved-function-names</a><sup><small>XQ</small></sup></span>
*/</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-parens">gn:
parens</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Argument" id=
"prod-xquery30-Argument"></a>[137]&#160;&#160;&#160;</td>
<td><code>Argument</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ExprSingle">ExprSingle</a> |
<a href=
"#prod-xquery30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ArgumentPlaceholder" id=
"prod-xquery30-ArgumentPlaceholder"></a>[138]&#160;&#160;&#160;</td>
<td><code>ArgumentPlaceholder</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Constructor" id=
"prod-xquery30-Constructor"></a>[139]&#160;&#160;&#160;</td>
<td><code>Constructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#prod-xquery30-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirectConstructor" id=
"prod-xquery30-DirectConstructor"></a>[140]&#160;&#160;&#160;</td>
<td><code>DirectConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#prod-xquery30-DirCommentConstructor">DirCommentConstructor</a><br />

| <a href=
"#prod-xquery30-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirElemConstructor" id=
"prod-xquery30-DirElemConstructor"></a>[141]&#160;&#160;&#160;</td>
<td><code>DirElemConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;" <a href="#prod-xquery30-QName">QName</a> <a href=
"#prod-xquery30-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#prod-xquery30-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#prod-xquery30-QName">QName</a> <a href=
"#prod-xquery30-S">S</a>? "&gt;"))</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirAttributeList" id=
"prod-xquery30-DirAttributeList"></a>[142]&#160;&#160;&#160;</td>
<td><code>DirAttributeList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-S">S</a> (<a href=
"#prod-xquery30-QName">QName</a> <a href="#prod-xquery30-S">S</a>?
"=" <a href="#prod-xquery30-S">S</a>? <a href=
"#prod-xquery30-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirAttributeValue" id=
"prod-xquery30-DirAttributeValue"></a>[143]&#160;&#160;&#160;</td>
<td><code>DirAttributeValue</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xquery30-EscapeQuot">EscapeQuot</a>
| <a href=
"#prod-xquery30-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#prod-xquery30-EscapeApos">EscapeApos</a> |
<a href=
"#prod-xquery30-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuotAttrValueContent" id=
"prod-xquery30-QuotAttrValueContent"></a>[144]&#160;&#160;&#160;</td>
<td><code>QuotAttrValueContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href=
"#prod-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AposAttrValueContent" id=
"prod-xquery30-AposAttrValueContent"></a>[145]&#160;&#160;&#160;</td>
<td><code>AposAttrValueContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href=
"#prod-xquery30-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirElemContent" id=
"prod-xquery30-DirElemContent"></a>[146]&#160;&#160;&#160;</td>
<td><code>DirElemContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DirectConstructor">DirectConstructor</a><br />
| <a href="#prod-xquery30-CDataSection">CDataSection</a><br />
| <a href="#prod-xquery30-CommonContent">CommonContent</a><br />
| <a href=
"#prod-xquery30-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommonContent" id=
"prod-xquery30-CommonContent"></a>[147]&#160;&#160;&#160;</td>
<td><code>CommonContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | "{{" | "}}" |
<a href="#prod-xquery30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirCommentConstructor" id=
"prod-xquery30-DirCommentConstructor"></a>[148]&#160;&#160;&#160;</td>
<td><code>DirCommentConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;!--" <a href=
"#prod-xquery30-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirCommentContents" id=
"prod-xquery30-DirCommentContents"></a>[149]&#160;&#160;&#160;</td>
<td><code>DirCommentContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href="#prod-xquery30-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery30-Char">Char</a> - '-')))*</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirPIConstructor" id=
"prod-xquery30-DirPIConstructor"></a>[150]&#160;&#160;&#160;</td>
<td><code>DirPIConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;?" <a href="#prod-xquery30-PITarget">PITarget</a>
(<a href="#prod-xquery30-S">S</a> <a href=
"#prod-xquery30-DirPIContents">DirPIContents</a>)?
"?&gt;"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DirPIContents" id=
"prod-xquery30-DirPIContents"></a>[151]&#160;&#160;&#160;</td>
<td><code>DirPIContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CDataSection" id=
"prod-xquery30-CDataSection"></a>[152]&#160;&#160;&#160;</td>
<td><code>CDataSection</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;![CDATA[" <a href=
"#prod-xquery30-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CDataSectionContents" id=
"prod-xquery30-CDataSectionContents"></a>[153]&#160;&#160;&#160;</td>
<td><code>CDataSectionContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>* - (Char*
']]&gt;' Char*))</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ComputedConstructor" id=
"prod-xquery30-ComputedConstructor"></a>[154]&#160;&#160;&#160;</td>
<td><code>ComputedConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#prod-xquery30-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#prod-xquery30-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#prod-xquery30-CompNamespaceConstructor">CompNamespaceConstructor</a><br />

| <a href=
"#prod-xquery30-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#prod-xquery30-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#prod-xquery30-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompDocConstructor" id=
"prod-xquery30-CompDocConstructor"></a>[155]&#160;&#160;&#160;</td>
<td><code>CompDocConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompElemConstructor" id=
"prod-xquery30-CompElemConstructor"></a>[156]&#160;&#160;&#160;</td>
<td><code>CompElemConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (<a href="#prod-xquery30-EQName">EQName</a> |
("{" <a href="#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ContentExpr" id=
"prod-xquery30-ContentExpr"></a>[157]&#160;&#160;&#160;</td>
<td><code>ContentExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompAttrConstructor" id=
"prod-xquery30-CompAttrConstructor"></a>[158]&#160;&#160;&#160;</td>
<td><code>CompAttrConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (<a href="#prod-xquery30-EQName">EQName</a> |
("{" <a href="#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompNamespaceConstructor" id=
"prod-xquery30-CompNamespaceConstructor"></a>[159]&#160;&#160;&#160;</td>
<td><code>CompNamespaceConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" (<a href="#prod-xquery30-Prefix">Prefix</a> |
("{" <a href="#prod-xquery30-PrefixExpr">PrefixExpr</a> "}")) "{"
<a href="#prod-xquery30-URIExpr">URIExpr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Prefix" id=
"prod-xquery30-Prefix"></a>[160]&#160;&#160;&#160;</td>
<td><code>Prefix</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-NCName">NCName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PrefixExpr" id=
"prod-xquery30-PrefixExpr"></a>[161]&#160;&#160;&#160;</td>
<td><code>PrefixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URIExpr" id=
"prod-xquery30-URIExpr"></a>[162]&#160;&#160;&#160;</td>
<td><code>URIExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompTextConstructor" id=
"prod-xquery30-CompTextConstructor"></a>[163]&#160;&#160;&#160;</td>
<td><code>CompTextConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompCommentConstructor" id=
"prod-xquery30-CompCommentConstructor"></a>[164]&#160;&#160;&#160;</td>
<td><code>CompCommentConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CompPIConstructor" id=
"prod-xquery30-CompPIConstructor"></a>[165]&#160;&#160;&#160;</td>
<td><code>CompPIConstructor</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery30-NCName">NCName</a> | ("{" <a href=
"#prod-xquery30-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery30-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionItemExpr" id=
"prod-xquery30-FunctionItemExpr"></a>[166]&#160;&#160;&#160;</td>
<td><code>FunctionItemExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#prod-xquery30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamedFunctionRef" id=
"prod-xquery30-NamedFunctionRef"></a>[167]&#160;&#160;&#160;</td>
<td><code>NamedFunctionRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a> "#" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-reserved-function-names">xgc:
reserved-function-names</a><sup><small>XQ</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-InlineFunctionExpr" id=
"prod-xquery30-InlineFunctionExpr"></a>[168]&#160;&#160;&#160;</td>
<td><code>InlineFunctionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Annotation">Annotation</a>*
"function" "(" <a href="#prod-xquery30-ParamList">ParamList</a>?
")" ("as" <a href="#prod-xquery30-SequenceType">SequenceType</a>)?
<a href="#prod-xquery30-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SingleType" id=
"prod-xquery30-SingleType"></a>[169]&#160;&#160;&#160;</td>
<td><code>SingleType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-SimpleTypeName">SimpleTypeName</a> "?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeDeclaration" id=
"prod-xquery30-TypeDeclaration"></a>[170]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#prod-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SequenceType" id=
"prod-xquery30-SequenceType"></a>[171]&#160;&#160;&#160;</td>
<td><code>SequenceType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xquery30-ItemType">ItemType</a> <a href=
"#prod-xquery30-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-OccurrenceIndicator" id=
"prod-xquery30-OccurrenceIndicator"></a>[172]&#160;&#160;&#160;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-occurrence-indicators">xgc:
occurrence-indicators</a><sup><small>XQ</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ItemType" id=
"prod-xquery30-ItemType"></a>[173]&#160;&#160;&#160;</td>
<td><code>ItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#prod-xquery30-FunctionTest">FunctionTest</a> |
<a href="#prod-xquery30-AtomicOrUnionType">AtomicOrUnionType</a> |
<a href=
"#prod-xquery30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AtomicOrUnionType" id=
"prod-xquery30-AtomicOrUnionType"></a>[174]&#160;&#160;&#160;</td>
<td><code>AtomicOrUnionType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-KindTest" id=
"prod-xquery30-KindTest"></a>[175]&#160;&#160;&#160;</td>
<td><code>KindTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xquery30-ElementTest">ElementTest</a><br />
| <a href="#prod-xquery30-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xquery30-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xquery30-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xquery30-PITest">PITest</a><br />
| <a href="#prod-xquery30-CommentTest">CommentTest</a><br />
| <a href="#prod-xquery30-TextTest">TextTest</a><br />
| <a href=
"#prod-xquery30-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#prod-xquery30-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnyKindTest" id=
"prod-xquery30-AnyKindTest"></a>[176]&#160;&#160;&#160;</td>
<td><code>AnyKindTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DocumentTest" id=
"prod-xquery30-DocumentTest"></a>[177]&#160;&#160;&#160;</td>
<td><code>DocumentTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xquery30-ElementTest">ElementTest</a> | <a href=
"#prod-xquery30-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TextTest" id=
"prod-xquery30-TextTest"></a>[178]&#160;&#160;&#160;</td>
<td><code>TextTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommentTest" id=
"prod-xquery30-CommentTest"></a>[179]&#160;&#160;&#160;</td>
<td><code>CommentTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NamespaceNodeTest" id=
"prod-xquery30-NamespaceNodeTest"></a>[180]&#160;&#160;&#160;</td>
<td><code>NamespaceNodeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PITest" id=
"prod-xquery30-PITest"></a>[181]&#160;&#160;&#160;</td>
<td><code>PITest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery30-NCName">NCName</a> | <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeTest" id=
"prod-xquery30-AttributeTest"></a>[182]&#160;&#160;&#160;</td>
<td><code>AttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xquery30-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xquery30-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttribNameOrWildcard" id=
"prod-xquery30-AttribNameOrWildcard"></a>[183]&#160;&#160;&#160;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-AttributeName">AttributeName</a>
| "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaAttributeTest" id=
"prod-xquery30-SchemaAttributeTest"></a>[184]&#160;&#160;&#160;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xquery30-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeDeclaration" id=
"prod-xquery30-AttributeDeclaration"></a>[185]&#160;&#160;&#160;</td>
<td><code>AttributeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementTest" id=
"prod-xquery30-ElementTest"></a>[186]&#160;&#160;&#160;</td>
<td><code>ElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xquery30-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#prod-xquery30-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementNameOrWildcard" id=
"prod-xquery30-ElementNameOrWildcard"></a>[187]&#160;&#160;&#160;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SchemaElementTest" id=
"prod-xquery30-SchemaElementTest"></a>[188]&#160;&#160;&#160;</td>
<td><code>SchemaElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xquery30-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementDeclaration" id=
"prod-xquery30-ElementDeclaration"></a>[189]&#160;&#160;&#160;</td>
<td><code>ElementDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AttributeName" id=
"prod-xquery30-AttributeName"></a>[190]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementName" id=
"prod-xquery30-ElementName"></a>[191]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-SimpleTypeName" id=
"prod-xquery30-SimpleTypeName"></a>[192]&#160;&#160;&#160;</td>
<td><code>SimpleTypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypeName" id=
"prod-xquery30-TypeName"></a>[193]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FunctionTest" id=
"prod-xquery30-FunctionTest"></a>[194]&#160;&#160;&#160;</td>
<td><code>FunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Annotation">Annotation</a>*
(<a href="#prod-xquery30-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#prod-xquery30-TypedFunctionTest">TypedFunctionTest</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AnyFunctionTest" id=
"prod-xquery30-AnyFunctionTest"></a>[195]&#160;&#160;&#160;</td>
<td><code>AnyFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-TypedFunctionTest" id=
"prod-xquery30-TypedFunctionTest"></a>[196]&#160;&#160;&#160;</td>
<td><code>TypedFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#prod-xquery30-SequenceType">SequenceType</a> ("," <a href=
"#prod-xquery30-SequenceType">SequenceType</a>)*)? ")" "as"
<a href="#prod-xquery30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ParenthesizedItemType" id=
"prod-xquery30-ParenthesizedItemType"></a>[197]&#160;&#160;&#160;</td>
<td><code>ParenthesizedItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xquery30-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URILiteral" id=
"prod-xquery30-URILiteral"></a>[198]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTSelection" id=
"prod-xquery30-FTSelection"></a>[199]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTSelection">FTSelection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTOr">FTOr</a> <a href=
"#prod-xquery30-FTPosFilter">FTPosFilter</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTWeight" id=
"prod-xquery30-FTWeight"></a>[200]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTWeight">FTWeight</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"weight" "{" <a href="#prod-xquery30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTOr" id=
"prod-xquery30-FTOr"></a>[201]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTOr">FTOr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTAnd">FTAnd</a> ( "ftor"
<a href="#prod-xquery30-FTAnd">FTAnd</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTAnd" id=
"prod-xquery30-FTAnd"></a>[202]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTAnd">FTAnd</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTMildNot">FTMildNot</a> (
"ftand" <a href="#prod-xquery30-FTMildNot">FTMildNot</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTMildNot" id=
"prod-xquery30-FTMildNot"></a>[203]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTMildNot">FTMildNot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTUnaryNot">FTUnaryNot</a> (
"not" "in" <a href="#prod-xquery30-FTUnaryNot">FTUnaryNot</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTUnaryNot" id=
"prod-xquery30-FTUnaryNot"></a>[204]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTUnaryNot">FTUnaryNot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ftnot")? <a href=
"#prod-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTPrimaryWithOptions" id=
"prod-xquery30-FTPrimaryWithOptions"></a>[205]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTPrimary">FTPrimary</a> <a href=
"#prod-xquery30-FTMatchOptions">FTMatchOptions</a>? <a href=
"#prod-xquery30-FTWeight">FTWeight</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTPrimary" id=
"prod-xquery30-FTPrimary"></a>[206]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTPrimary">FTPrimary</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-FTWords">FTWords</a> <a href=
"#prod-xquery30-FTTimes">FTTimes</a>?) | ("(" <a href=
"#prod-xquery30-FTSelection">FTSelection</a> ")") | <a href=
"#prod-xquery30-FTExtensionSelection">FTExtensionSelection</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTWords" id=
"prod-xquery30-FTWords"></a>[207]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTWords">FTWords</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTWordsValue">FTWordsValue</a>
<a href=
"#prod-xquery30-FTAnyallOption">FTAnyallOption</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTWordsValue" id=
"prod-xquery30-FTWordsValue"></a>[208]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTWordsValue">FTWordsValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-StringLiteral">StringLiteral</a>
| ("{" <a href="#prod-xquery30-Expr">Expr</a> "}")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTExtensionSelection" id=
"prod-xquery30-FTExtensionSelection"></a>[209]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Pragma">Pragma</a>+ "{" <a href=
"#prod-xquery30-FTSelection">FTSelection</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTAnyallOption" id=
"prod-xquery30-FTAnyallOption"></a>[210]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTAnyallOption">FTAnyallOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("any" "word"?) | ("all" "words"?) | "phrase"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTTimes" id=
"prod-xquery30-FTTimes"></a>[211]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTTimes">FTTimes</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"occurs" <a href="#prod-xquery30-FTRange">FTRange</a>
"times"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTRange" id=
"prod-xquery30-FTRange"></a>[212]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTRange">FTRange</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "least" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "most" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("from" <a href="#prod-xquery30-AdditiveExpr">AdditiveExpr</a>
"to" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTPosFilter" id=
"prod-xquery30-FTPosFilter"></a>[213]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTPosFilter">FTPosFilter</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-FTOrder">FTOrder</a> | <a href=
"#prod-xquery30-FTWindow">FTWindow</a> | <a href=
"#prod-xquery30-FTDistance">FTDistance</a> | <a href=
"#prod-xquery30-FTScope">FTScope</a> | <a href=
"#prod-xquery30-FTContent">FTContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTOrder" id=
"prod-xquery30-FTOrder"></a>[214]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTOrder">FTOrder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTWindow" id=
"prod-xquery30-FTWindow"></a>[215]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTWindow">FTWindow</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"window" <a href=
"#prod-xquery30-AdditiveExpr">AdditiveExpr</a> <a href=
"#prod-xquery30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTDistance" id=
"prod-xquery30-FTDistance"></a>[216]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTDistance">FTDistance</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"distance" <a href="#prod-xquery30-FTRange">FTRange</a>
<a href="#prod-xquery30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTUnit" id=
"prod-xquery30-FTUnit"></a>[217]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTUnit">FTUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"words" | "sentences" | "paragraphs"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTScope" id=
"prod-xquery30-FTScope"></a>[218]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery30-FTScope">FTScope</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("same" | "different") <a href=
"#prod-xquery30-FTBigUnit">FTBigUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTBigUnit" id=
"prod-xquery30-FTBigUnit"></a>[219]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTBigUnit">FTBigUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sentence" | "paragraph"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTContent" id=
"prod-xquery30-FTContent"></a>[220]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTContent">FTContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" "start") | ("at" "end") | ("entire"
"content")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTMatchOptions" id=
"prod-xquery30-FTMatchOptions"></a>[221]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("using" <a href=
"#prod-xquery30-FTMatchOption">FTMatchOption</a>)+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTMatchOption" id=
"prod-xquery30-FTMatchOption"></a>[222]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTMatchOption">FTMatchOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-FTLanguageOption">FTLanguageOption</a><br />
| <a href=
"#prod-xquery30-FTWildCardOption">FTWildCardOption</a><br />
| <a href=
"#prod-xquery30-FTThesaurusOption">FTThesaurusOption</a><br />
| <a href="#prod-xquery30-FTStemOption">FTStemOption</a><br />
| <a href="#prod-xquery30-FTCaseOption">FTCaseOption</a><br />
| <a href=
"#prod-xquery30-FTDiacriticsOption">FTDiacriticsOption</a><br />
| <a href=
"#prod-xquery30-FTStopWordOption">FTStopWordOption</a><br />
| <a href=
"#prod-xquery30-FTExtensionOption">FTExtensionOption</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTCaseOption" id=
"prod-xquery30-FTCaseOption"></a>[223]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTCaseOption">FTCaseOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" "insensitive")<br />
| ("case" "sensitive")<br />
| "lowercase"<br />
| "uppercase"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTDiacriticsOption" id=
"prod-xquery30-FTDiacriticsOption"></a>[224]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTDiacriticsOption">FTDiacriticsOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("diacritics" "insensitive")<br />
| ("diacritics" "sensitive")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTStemOption" id=
"prod-xquery30-FTStemOption"></a>[225]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTStemOption">FTStemOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"stemming" | ("no" "stemming")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTThesaurusOption" id=
"prod-xquery30-FTThesaurusOption"></a>[226]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTThesaurusOption">FTThesaurusOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("thesaurus" (<a href=
"#prod-xquery30-FTThesaurusID">FTThesaurusID</a> |
"default"))<br />
| ("thesaurus" "(" (<a href=
"#prod-xquery30-FTThesaurusID">FTThesaurusID</a> | "default") (","
<a href="#prod-xquery30-FTThesaurusID">FTThesaurusID</a>)*
")")<br />
| ("no" "thesaurus")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTThesaurusID" id=
"prod-xquery30-FTThesaurusID"></a>[227]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTThesaurusID">FTThesaurusID</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" <a href="#prod-xquery30-URILiteral">URILiteral</a>
("relationship" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a>)? (<a href=
"#prod-xquery30-FTLiteralRange">FTLiteralRange</a>
"levels")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTLiteralRange" id=
"prod-xquery30-FTLiteralRange"></a>[228]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTLiteralRange">FTLiteralRange</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "least" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "most" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("from" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a> "to" <a href=
"#prod-xquery30-IntegerLiteral">IntegerLiteral</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTStopWordOption" id=
"prod-xquery30-FTStopWordOption"></a>[229]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTStopWordOption">FTStopWordOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("stop" "words" <a href=
"#prod-xquery30-FTStopWords">FTStopWords</a> <a href=
"#prod-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />

| ("stop" "words" "default" <a href=
"#prod-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />

| ("no" "stop" "words")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTStopWords" id=
"prod-xquery30-FTStopWords"></a>[230]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTStopWords">FTStopWords</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" <a href=
"#prod-xquery30-URILiteral">URILiteral</a>)<br />
| ("(" <a href="#prod-xquery30-StringLiteral">StringLiteral</a>
("," <a href="#prod-xquery30-StringLiteral">StringLiteral</a>)*
")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTStopWordsInclExcl" id=
"prod-xquery30-FTStopWordsInclExcl"></a>[231]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTStopWordsInclExcl">FTStopWordsInclExcl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("union" | "except") <a href=
"#prod-xquery30-FTStopWords">FTStopWords</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTLanguageOption" id=
"prod-xquery30-FTLanguageOption"></a>[232]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTLanguageOption">FTLanguageOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"language" <a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTWildCardOption" id=
"prod-xquery30-FTWildCardOption"></a>[233]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTWildCardOption">FTWildCardOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"wildcards" | ("no" "wildcards")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTExtensionOption" id=
"prod-xquery30-FTExtensionOption"></a>[234]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTExtensionOption">FTExtensionOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"option" <a href="#prod-xquery30-EQName">EQName</a>
<a href=
"#prod-xquery30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-FTIgnoreOption" id=
"prod-xquery30-FTIgnoreOption"></a>[235]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery30-FTIgnoreOption">FTIgnoreOption</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"without" "content" <a href=
"#prod-xquery30-UnionExpr">UnionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EQName" id=
"prod-xquery30-EQName"></a>[236]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-QName">QName</a> | <a href=
"#prod-xquery30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<div class="div2">
<h3><a name="grammar-terminals" id="grammar-terminals"></a>A.1
Terminal Symbols</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-IntegerLiteral" id=
"prod-xquery30-IntegerLiteral"></a>[237]&#160;&#160;&#160;</td>
<td><code>IntegerLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery30-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DecimalLiteral" id=
"prod-xquery30-DecimalLiteral"></a>[238]&#160;&#160;&#160;</td>
<td><code>DecimalLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xquery30-Digits">Digits</a>) |
(<a href="#prod-xquery30-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-DoubleLiteral" id=
"prod-xquery30-DoubleLiteral"></a>[239]&#160;&#160;&#160;</td>
<td><code>DoubleLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xquery30-Digits">Digits</a>) |
(<a href="#prod-xquery30-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#prod-xquery30-Digits">Digits</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-StringLiteral" id=
"prod-xquery30-StringLiteral"></a>[240]&#160;&#160;&#160;</td>
<td><code>StringLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#prod-xquery30-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') |
("'" (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | <a href=
"#prod-xquery30-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-URIQualifiedName" id=
"prod-xquery30-URIQualifiedName"></a>[241]&#160;&#160;&#160;</td>
<td><code>URIQualifiedName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xquery30-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xquery30-NCName">NCName</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-BracedURILiteral" id=
"prod-xquery30-BracedURILiteral"></a>[242]&#160;&#160;&#160;</td>
<td><code>BracedURILiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" (<a href=
"#prod-xquery30-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery30-CharRef">CharRef</a> | [^&amp;{}])*
"}"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PredefinedEntityRef" id=
"prod-xquery30-PredefinedEntityRef"></a>[243]&#160;&#160;&#160;</td>
<td><code>PredefinedEntityRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EscapeQuot" id=
"prod-xquery30-EscapeQuot"></a>[244]&#160;&#160;&#160;</td>
<td><code>EscapeQuot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-EscapeApos" id=
"prod-xquery30-EscapeApos"></a>[245]&#160;&#160;&#160;</td>
<td><code>EscapeApos</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-ElementContentChar" id=
"prod-xquery30-ElementContentChar"></a>[246]&#160;&#160;&#160;</td>
<td><code>ElementContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
[{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QuotAttrContentChar" id=
"prod-xquery30-QuotAttrContentChar"></a>[247]&#160;&#160;&#160;</td>
<td><code>QuotAttrContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
["{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-AposAttrContentChar" id=
"prod-xquery30-AposAttrContentChar"></a>[248]&#160;&#160;&#160;</td>
<td><code>AposAttrContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a> -
['{}&lt;&amp;])</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Comment" id=
"prod-xquery30-Comment"></a>[249]&#160;&#160;&#160;</td>
<td><code>Comment</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xquery30-CommentContents">CommentContents</a> | <a href=
"#prod-xquery30-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#ws-explicit">ws:
explicit</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-comments">gn:
comments</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-PITarget" id=
"prod-xquery30-PITarget"></a>[250]&#160;&#160;&#160;</td>
<td><code>PITarget</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CharRef" id=
"prod-xquery30-CharRef"></a>[251]&#160;&#160;&#160;</td>
<td><code>CharRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-QName" id=
"prod-xquery30-QName"></a>[252]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-NCName" id=
"prod-xquery30-NCName"></a>[253]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-S" id=
"prod-xquery30-S"></a>[254]&#160;&#160;&#160;</td>
<td><code>S</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Char" id=
"prod-xquery30-Char"></a>[255]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XQ</small></sup></span> */</i></td>
</tr>
</tbody>
</table>
<p>The following symbols are used only in the definition of
terminal symbols; they are not terminal symbols in the grammar of
<a href="#id-grammar"><b>A EBNF for XQuery 3.0 Grammar with Full
Text extensions</b></a>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-Digits" id=
"prod-xquery30-Digits"></a>[256]&#160;&#160;&#160;</td>
<td><code>Digits</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery30-CommentContents" id=
"prod-xquery30-CommentContents"></a>[257]&#160;&#160;&#160;</td>
<td><code>CommentContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery30-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xpath-grammar" id="id-xpath-grammar"></a>B EBNF for
XPath <span>3.0</span> Grammar with Full-Text extensions</h2>
<p>The EBNF in this document and in this section is aligned with
the current XPath 2.0 grammar <span>(see <a href=
"http://www.w3.org/TR/xpath-30/">http://www.w3.org/TR/xpath-30/</a>)</span>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-XPath" id=
"prod-xpath30-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code>XPath</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ParamList" id=
"prod-xpath30-ParamList"></a>[2]&#160;&#160;&#160;</td>
<td><code>ParamList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-Param">Param</a> ("," <a href=
"#prod-xpath30-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Param" id=
"prod-xpath30-Param"></a>[3]&#160;&#160;&#160;</td>
<td><code>Param</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath30-EQName">EQName</a> <a href=
"#prod-xpath30-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FunctionBody" id=
"prod-xpath30-FunctionBody"></a>[4]&#160;&#160;&#160;</td>
<td><code>FunctionBody</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-EnclosedExpr" id=
"prod-xpath30-EnclosedExpr"></a>[5]&#160;&#160;&#160;</td>
<td><code>EnclosedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#prod-xpath30-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Expr" id=
"prod-xpath30-Expr"></a>[6]&#160;&#160;&#160;</td>
<td><code>Expr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-ExprSingle">ExprSingle</a> (","
<a href="#prod-xpath30-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ExprSingle" id=
"prod-xpath30-ExprSingle"></a>[7]&#160;&#160;&#160;</td>
<td><code>ExprSingle</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath30-LetExpr">LetExpr</a><br />
| <a href="#prod-xpath30-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath30-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath30-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ForExpr" id=
"prod-xpath30-ForExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code>ForExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-SimpleForClause">SimpleForClause</a> "return"
<a href="#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleForClause" id=
"prod-xpath30-SimpleForClause"></a>[9]&#160;&#160;&#160;</td>
<td><code>SimpleForClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href=
"#prod-xpath30-SimpleForBinding">SimpleForBinding</a> ("," <a href=
"#prod-xpath30-SimpleForBinding">SimpleForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleForBinding" id=
"prod-xpath30-SimpleForBinding"></a>[10]&#160;&#160;&#160;</td>
<td><code>SimpleForBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath30-VarName">VarName</a> <a href=
"#prod-xpath30-FTScoreVar">FTScoreVar</a>? "in" <a href=
"#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-LetExpr" id=
"prod-xpath30-LetExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code>LetExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-SimpleLetClause">SimpleLetClause</a> "return"
<a href="#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleLetClause" id=
"prod-xpath30-SimpleLetClause"></a>[12]&#160;&#160;&#160;</td>
<td><code>SimpleLetClause</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href=
"#prod-xpath30-SimpleLetBinding">SimpleLetBinding</a> ("," <a href=
"#prod-xpath30-SimpleLetBinding">SimpleLetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleLetBinding" id=
"prod-xpath30-SimpleLetBinding"></a>[13]&#160;&#160;&#160;</td>
<td><code>SimpleLetBinding</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath30-VarName">VarName</a> ":="
<a href="#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTScoreVar" id=
"prod-xpath30-FTScoreVar"></a>[14]&#160;&#160;&#160;</td>
<td><code>FTScoreVar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"score" "$" <a href=
"#prod-xpath30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-QuantifiedExpr" id=
"prod-xpath30-QuantifiedExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code>QuantifiedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xpath30-VarName">VarName</a> "in" <a href=
"#prod-xpath30-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath30-VarName">VarName</a> "in" <a href=
"#prod-xpath30-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-IfExpr" id=
"prod-xpath30-IfExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code>IfExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xpath30-Expr">Expr</a> ")" "then"
<a href="#prod-xpath30-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xpath30-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-OrExpr" id=
"prod-xpath30-OrExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code>OrExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-AndExpr">AndExpr</a> ( "or"
<a href="#prod-xpath30-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AndExpr" id=
"prod-xpath30-AndExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code>AndExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#prod-xpath30-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ComparisonExpr" id=
"prod-xpath30-ComparisonExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code>ComparisonExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTContainsExpr">FTContainsExpr</a>
( (<a href="#prod-xpath30-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath30-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath30-NodeComp">NodeComp</a>) <a href=
"#prod-xpath30-FTContainsExpr">FTContainsExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTContainsExpr" id=
"prod-xpath30-FTContainsExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code>FTContainsExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-StringConcatExpr">StringConcatExpr</a> ( "contains"
"text" <a href="#prod-xpath30-FTSelection">FTSelection</a> <a href=
"#prod-xpath30-FTIgnoreOption">FTIgnoreOption</a>? )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-StringConcatExpr" id=
"prod-xpath30-StringConcatExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code>StringConcatExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-RangeExpr">RangeExpr</a> ( "||"
<a href="#prod-xpath30-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-RangeExpr" id=
"prod-xpath30-RangeExpr"></a>[22]&#160;&#160;&#160;</td>
<td><code>RangeExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xpath30-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AdditiveExpr" id=
"prod-xpath30-AdditiveExpr"></a>[23]&#160;&#160;&#160;</td>
<td><code>AdditiveExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xpath30-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-MultiplicativeExpr" id=
"prod-xpath30-MultiplicativeExpr"></a>[24]&#160;&#160;&#160;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xpath30-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-UnionExpr" id=
"prod-xpath30-UnionExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code>UnionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xpath30-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-IntersectExceptExpr" id=
"prod-xpath30-IntersectExceptExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#prod-xpath30-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-InstanceofExpr" id=
"prod-xpath30-InstanceofExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code>InstanceofExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#prod-xpath30-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-TreatExpr" id=
"prod-xpath30-TreatExpr"></a>[28]&#160;&#160;&#160;</td>
<td><code>TreatExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xpath30-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-CastableExpr" id=
"prod-xpath30-CastableExpr"></a>[29]&#160;&#160;&#160;</td>
<td><code>CastableExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-CastExpr">CastExpr</a> (
"castable" "as" <a href="#prod-xpath30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-CastExpr" id=
"prod-xpath30-CastExpr"></a>[30]&#160;&#160;&#160;</td>
<td><code>CastExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xpath30-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-UnaryExpr" id=
"prod-xpath30-UnaryExpr"></a>[31]&#160;&#160;&#160;</td>
<td><code>UnaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xpath30-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ValueExpr" id=
"prod-xpath30-ValueExpr"></a>[32]&#160;&#160;&#160;</td>
<td><code>ValueExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-GeneralComp" id=
"prod-xpath30-GeneralComp"></a>[33]&#160;&#160;&#160;</td>
<td><code>GeneralComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ValueComp" id=
"prod-xpath30-ValueComp"></a>[34]&#160;&#160;&#160;</td>
<td><code>ValueComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NodeComp" id=
"prod-xpath30-NodeComp"></a>[35]&#160;&#160;&#160;</td>
<td><code>NodeComp</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Pragma" id=
"prod-xpath30-Pragma"></a>[36]&#160;&#160;&#160;</td>
<td><code>Pragma</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xpath30-S">S</a>? <a href=
"#prod-xpath30-EQName">EQName</a> (<a href="#prod-xpath30-S">S</a>
<a href="#prod-xpath30-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PragmaContents" id=
"prod-xpath30-PragmaContents"></a>[37]&#160;&#160;&#160;</td>
<td><code>PragmaContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleMapExpr" id=
"prod-xpath30-SimpleMapExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code>SimpleMapExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-PathExpr">PathExpr</a> ("!"
<a href="#prod-xpath30-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PathExpr" id=
"prod-xpath30-PathExpr"></a>[39]&#160;&#160;&#160;</td>
<td><code>PathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xpath30-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xpath30-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xpath30-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-leading-lone-slash">xgc:
leading-lone-slash</a><sup><small>XP</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-RelativePathExpr" id=
"prod-xpath30-RelativePathExpr"></a>[40]&#160;&#160;&#160;</td>
<td><code>RelativePathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-StepExpr">StepExpr</a> (("/" |
"//") <a href="#prod-xpath30-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-StepExpr" id=
"prod-xpath30-StepExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code>StepExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-PostfixExpr">PostfixExpr</a> |
<a href="#prod-xpath30-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AxisStep" id=
"prod-xpath30-AxisStep"></a>[42]&#160;&#160;&#160;</td>
<td><code>AxisStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-ReverseStep">ReverseStep</a> |
<a href="#prod-xpath30-ForwardStep">ForwardStep</a>) <a href=
"#prod-xpath30-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ForwardStep" id=
"prod-xpath30-ForwardStep"></a>[43]&#160;&#160;&#160;</td>
<td><code>ForwardStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-ForwardAxis">ForwardAxis</a>
<a href="#prod-xpath30-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath30-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ForwardAxis" id=
"prod-xpath30-ForwardAxis"></a>[44]&#160;&#160;&#160;</td>
<td><code>ForwardAxis</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AbbrevForwardStep" id=
"prod-xpath30-AbbrevForwardStep"></a>[45]&#160;&#160;&#160;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xpath30-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ReverseStep" id=
"prod-xpath30-ReverseStep"></a>[46]&#160;&#160;&#160;</td>
<td><code>ReverseStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-ReverseAxis">ReverseAxis</a>
<a href="#prod-xpath30-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath30-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ReverseAxis" id=
"prod-xpath30-ReverseAxis"></a>[47]&#160;&#160;&#160;</td>
<td><code>ReverseAxis</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AbbrevReverseStep" id=
"prod-xpath30-AbbrevReverseStep"></a>[48]&#160;&#160;&#160;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NodeTest" id=
"prod-xpath30-NodeTest"></a>[49]&#160;&#160;&#160;</td>
<td><code>NodeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-KindTest">KindTest</a> | <a href=
"#prod-xpath30-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NameTest" id=
"prod-xpath30-NameTest"></a>[50]&#160;&#160;&#160;</td>
<td><code>NameTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a> | <a href=
"#prod-xpath30-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Wildcard" id=
"prod-xpath30-Wildcard"></a>[51]&#160;&#160;&#160;</td>
<td><code>Wildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath30-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath30-NCName">NCName</a>)<br />
| (<a href="#prod-xpath30-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PostfixExpr" id=
"prod-xpath30-PostfixExpr"></a>[52]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-PrimaryExpr">PrimaryExpr</a>
(<a href="#prod-xpath30-Predicate">Predicate</a> | <a href=
"#prod-xpath30-ArgumentList">ArgumentList</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ArgumentList" id=
"prod-xpath30-ArgumentList"></a>[53]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#prod-xpath30-Argument">Argument</a> (","
<a href="#prod-xpath30-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PredicateList" id=
"prod-xpath30-PredicateList"></a>[54]&#160;&#160;&#160;</td>
<td><code>PredicateList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Predicate" id=
"prod-xpath30-Predicate"></a>[55]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xpath30-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PrimaryExpr" id=
"prod-xpath30-PrimaryExpr"></a>[56]&#160;&#160;&#160;</td>
<td><code>PrimaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-Literal">Literal</a><br />
| <a href="#prod-xpath30-VarRef">VarRef</a><br />
| <a href=
"#prod-xpath30-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#prod-xpath30-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#prod-xpath30-FunctionCall">FunctionCall</a><br />
| <a href=
"#prod-xpath30-FunctionItemExpr">FunctionItemExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Literal" id=
"prod-xpath30-Literal"></a>[57]&#160;&#160;&#160;</td>
<td><code>Literal</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-NumericLiteral">NumericLiteral</a>
| <a href=
"#prod-xpath30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NumericLiteral" id=
"prod-xpath30-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>
<td><code>NumericLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-IntegerLiteral">IntegerLiteral</a>
| <a href="#prod-xpath30-DecimalLiteral">DecimalLiteral</a> |
<a href="#prod-xpath30-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-VarRef" id=
"prod-xpath30-VarRef"></a>[59]&#160;&#160;&#160;</td>
<td><code>VarRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xpath30-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-VarName" id=
"prod-xpath30-VarName"></a>[60]&#160;&#160;&#160;</td>
<td><code>VarName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ParenthesizedExpr" id=
"prod-xpath30-ParenthesizedExpr"></a>[61]&#160;&#160;&#160;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath30-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ContextItemExpr" id=
"prod-xpath30-ContextItemExpr"></a>[62]&#160;&#160;&#160;</td>
<td><code>ContextItemExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FunctionCall" id=
"prod-xpath30-FunctionCall"></a>[63]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a> <a href=
"#prod-xpath30-ArgumentList">ArgumentList</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-reserved-function-names">xgc:
reserved-function-names</a><sup><small>XP</small></sup></span>
*/</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-parens">gn:
parens</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Argument" id=
"prod-xpath30-Argument"></a>[64]&#160;&#160;&#160;</td>
<td><code>Argument</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-ExprSingle">ExprSingle</a> |
<a href=
"#prod-xpath30-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ArgumentPlaceholder" id=
"prod-xpath30-ArgumentPlaceholder"></a>[65]&#160;&#160;&#160;</td>
<td><code>ArgumentPlaceholder</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FunctionItemExpr" id=
"prod-xpath30-FunctionItemExpr"></a>[66]&#160;&#160;&#160;</td>
<td><code>FunctionItemExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#prod-xpath30-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NamedFunctionRef" id=
"prod-xpath30-NamedFunctionRef"></a>[67]&#160;&#160;&#160;</td>
<td><code>NamedFunctionRef</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a> "#" <a href=
"#prod-xpath30-IntegerLiteral">IntegerLiteral</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-reserved-function-names">xgc:
reserved-function-names</a><sup><small>XP</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-InlineFunctionExpr" id=
"prod-xpath30-InlineFunctionExpr"></a>[68]&#160;&#160;&#160;</td>
<td><code>InlineFunctionExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" <a href=
"#prod-xpath30-ParamList">ParamList</a>? ")" ("as" <a href=
"#prod-xpath30-SequenceType">SequenceType</a>)? <a href=
"#prod-xpath30-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SingleType" id=
"prod-xpath30-SingleType"></a>[69]&#160;&#160;&#160;</td>
<td><code>SingleType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-SimpleTypeName">SimpleTypeName</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-TypeDeclaration" id=
"prod-xpath30-TypeDeclaration"></a>[70]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#prod-xpath30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SequenceType" id=
"prod-xpath30-SequenceType"></a>[71]&#160;&#160;&#160;</td>
<td><code>SequenceType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xpath30-ItemType">ItemType</a> <a href=
"#prod-xpath30-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-OccurrenceIndicator" id=
"prod-xpath30-OccurrenceIndicator"></a>[72]&#160;&#160;&#160;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-occurrence-indicators">xgc:
occurrence-indicators</a><sup><small>XP</small></sup></span>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ItemType" id=
"prod-xpath30-ItemType"></a>[73]&#160;&#160;&#160;</td>
<td><code>ItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#prod-xpath30-FunctionTest">FunctionTest</a> |
<a href="#prod-xpath30-AtomicOrUnionType">AtomicOrUnionType</a> |
<a href=
"#prod-xpath30-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AtomicOrUnionType" id=
"prod-xpath30-AtomicOrUnionType"></a>[74]&#160;&#160;&#160;</td>
<td><code>AtomicOrUnionType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-KindTest" id=
"prod-xpath30-KindTest"></a>[75]&#160;&#160;&#160;</td>
<td><code>KindTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath30-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath30-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xpath30-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xpath30-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xpath30-PITest">PITest</a><br />
| <a href="#prod-xpath30-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath30-TextTest">TextTest</a><br />
| <a href=
"#prod-xpath30-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#prod-xpath30-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AnyKindTest" id=
"prod-xpath30-AnyKindTest"></a>[76]&#160;&#160;&#160;</td>
<td><code>AnyKindTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-DocumentTest" id=
"prod-xpath30-DocumentTest"></a>[77]&#160;&#160;&#160;</td>
<td><code>DocumentTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xpath30-ElementTest">ElementTest</a> | <a href=
"#prod-xpath30-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-TextTest" id=
"prod-xpath30-TextTest"></a>[78]&#160;&#160;&#160;</td>
<td><code>TextTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-CommentTest" id=
"prod-xpath30-CommentTest"></a>[79]&#160;&#160;&#160;</td>
<td><code>CommentTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NamespaceNodeTest" id=
"prod-xpath30-NamespaceNodeTest"></a>[80]&#160;&#160;&#160;</td>
<td><code>NamespaceNodeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-PITest" id=
"prod-xpath30-PITest"></a>[81]&#160;&#160;&#160;</td>
<td><code>PITest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath30-NCName">NCName</a> | <a href=
"#prod-xpath30-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AttributeTest" id=
"prod-xpath30-AttributeTest"></a>[82]&#160;&#160;&#160;</td>
<td><code>AttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xpath30-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xpath30-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AttribNameOrWildcard" id=
"prod-xpath30-AttribNameOrWildcard"></a>[83]&#160;&#160;&#160;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SchemaAttributeTest" id=
"prod-xpath30-SchemaAttributeTest"></a>[84]&#160;&#160;&#160;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xpath30-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AttributeDeclaration" id=
"prod-xpath30-AttributeDeclaration"></a>[85]&#160;&#160;&#160;</td>
<td><code>AttributeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ElementTest" id=
"prod-xpath30-ElementTest"></a>[86]&#160;&#160;&#160;</td>
<td><code>ElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xpath30-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#prod-xpath30-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ElementNameOrWildcard" id=
"prod-xpath30-ElementNameOrWildcard"></a>[87]&#160;&#160;&#160;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SchemaElementTest" id=
"prod-xpath30-SchemaElementTest"></a>[88]&#160;&#160;&#160;</td>
<td><code>SchemaElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xpath30-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ElementDeclaration" id=
"prod-xpath30-ElementDeclaration"></a>[89]&#160;&#160;&#160;</td>
<td><code>ElementDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AttributeName" id=
"prod-xpath30-AttributeName"></a>[90]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ElementName" id=
"prod-xpath30-ElementName"></a>[91]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-SimpleTypeName" id=
"prod-xpath30-SimpleTypeName"></a>[92]&#160;&#160;&#160;</td>
<td><code>SimpleTypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-TypeName" id=
"prod-xpath30-TypeName"></a>[93]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FunctionTest" id=
"prod-xpath30-FunctionTest"></a>[94]&#160;&#160;&#160;</td>
<td><code>FunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#prod-xpath30-TypedFunctionTest">TypedFunctionTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-AnyFunctionTest" id=
"prod-xpath30-AnyFunctionTest"></a>[95]&#160;&#160;&#160;</td>
<td><code>AnyFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-TypedFunctionTest" id=
"prod-xpath30-TypedFunctionTest"></a>[96]&#160;&#160;&#160;</td>
<td><code>TypedFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#prod-xpath30-SequenceType">SequenceType</a> ("," <a href=
"#prod-xpath30-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#prod-xpath30-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-ParenthesizedItemType" id=
"prod-xpath30-ParenthesizedItemType"></a>[97]&#160;&#160;&#160;</td>
<td><code>ParenthesizedItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath30-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-URILiteral" id=
"prod-xpath30-URILiteral"></a>[98]&#160;&#160;&#160;</td>
<td><code>URILiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTSelection" id=
"prod-xpath30-FTSelection"></a>[99]&#160;&#160;&#160;</td>
<td><code>FTSelection</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTOr">FTOr</a> <a href=
"#prod-xpath30-FTPosFilter">FTPosFilter</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTWeight" id=
"prod-xpath30-FTWeight"></a>[100]&#160;&#160;&#160;</td>
<td><code>FTWeight</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"weight" "{" <a href="#prod-xpath30-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTOr" id=
"prod-xpath30-FTOr"></a>[101]&#160;&#160;&#160;</td>
<td><code>FTOr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTAnd">FTAnd</a> ( "ftor" <a href=
"#prod-xpath30-FTAnd">FTAnd</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTAnd" id=
"prod-xpath30-FTAnd"></a>[102]&#160;&#160;&#160;</td>
<td><code>FTAnd</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTMildNot">FTMildNot</a> ( "ftand"
<a href="#prod-xpath30-FTMildNot">FTMildNot</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTMildNot" id=
"prod-xpath30-FTMildNot"></a>[103]&#160;&#160;&#160;</td>
<td><code>FTMildNot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTUnaryNot">FTUnaryNot</a> ( "not"
"in" <a href="#prod-xpath30-FTUnaryNot">FTUnaryNot</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTUnaryNot" id=
"prod-xpath30-FTUnaryNot"></a>[104]&#160;&#160;&#160;</td>
<td><code>FTUnaryNot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ftnot")? <a href=
"#prod-xpath30-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTPrimaryWithOptions" id=
"prod-xpath30-FTPrimaryWithOptions"></a>[105]&#160;&#160;&#160;</td>
<td><code>FTPrimaryWithOptions</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTPrimary">FTPrimary</a> <a href=
"#prod-xpath30-FTMatchOptions">FTMatchOptions</a>? <a href=
"#prod-xpath30-FTWeight">FTWeight</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTPrimary" id=
"prod-xpath30-FTPrimary"></a>[106]&#160;&#160;&#160;</td>
<td><code>FTPrimary</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-FTWords">FTWords</a> <a href=
"#prod-xpath30-FTTimes">FTTimes</a>?) | ("(" <a href=
"#prod-xpath30-FTSelection">FTSelection</a> ")") | <a href=
"#prod-xpath30-FTExtensionSelection">FTExtensionSelection</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTWords" id=
"prod-xpath30-FTWords"></a>[107]&#160;&#160;&#160;</td>
<td><code>FTWords</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTWordsValue">FTWordsValue</a>
<a href=
"#prod-xpath30-FTAnyallOption">FTAnyallOption</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTWordsValue" id=
"prod-xpath30-FTWordsValue"></a>[108]&#160;&#160;&#160;</td>
<td><code>FTWordsValue</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-StringLiteral">StringLiteral</a> |
("{" <a href="#prod-xpath30-Expr">Expr</a> "}")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTExtensionSelection" id=
"prod-xpath30-FTExtensionSelection"></a>[109]&#160;&#160;&#160;</td>
<td><code>FTExtensionSelection</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-Pragma">Pragma</a>+ "{" <a href=
"#prod-xpath30-FTSelection">FTSelection</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTAnyallOption" id=
"prod-xpath30-FTAnyallOption"></a>[110]&#160;&#160;&#160;</td>
<td><code>FTAnyallOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("any" "word"?) | ("all" "words"?) | "phrase"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTTimes" id=
"prod-xpath30-FTTimes"></a>[111]&#160;&#160;&#160;</td>
<td><code>FTTimes</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"occurs" <a href="#prod-xpath30-FTRange">FTRange</a>
"times"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTRange" id=
"prod-xpath30-FTRange"></a>[112]&#160;&#160;&#160;</td>
<td><code>FTRange</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xpath30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "least" <a href=
"#prod-xpath30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("at" "most" <a href=
"#prod-xpath30-AdditiveExpr">AdditiveExpr</a>)<br />
| ("from" <a href="#prod-xpath30-AdditiveExpr">AdditiveExpr</a>
"to" <a href=
"#prod-xpath30-AdditiveExpr">AdditiveExpr</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTPosFilter" id=
"prod-xpath30-FTPosFilter"></a>[113]&#160;&#160;&#160;</td>
<td><code>FTPosFilter</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-FTOrder">FTOrder</a> | <a href=
"#prod-xpath30-FTWindow">FTWindow</a> | <a href=
"#prod-xpath30-FTDistance">FTDistance</a> | <a href=
"#prod-xpath30-FTScope">FTScope</a> | <a href=
"#prod-xpath30-FTContent">FTContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTOrder" id=
"prod-xpath30-FTOrder"></a>[114]&#160;&#160;&#160;</td>
<td><code>FTOrder</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTWindow" id=
"prod-xpath30-FTWindow"></a>[115]&#160;&#160;&#160;</td>
<td><code>FTWindow</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"window" <a href=
"#prod-xpath30-AdditiveExpr">AdditiveExpr</a> <a href=
"#prod-xpath30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTDistance" id=
"prod-xpath30-FTDistance"></a>[116]&#160;&#160;&#160;</td>
<td><code>FTDistance</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"distance" <a href="#prod-xpath30-FTRange">FTRange</a>
<a href="#prod-xpath30-FTUnit">FTUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTUnit" id=
"prod-xpath30-FTUnit"></a>[117]&#160;&#160;&#160;</td>
<td><code>FTUnit</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"words" | "sentences" | "paragraphs"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTScope" id=
"prod-xpath30-FTScope"></a>[118]&#160;&#160;&#160;</td>
<td><code>FTScope</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("same" | "different") <a href=
"#prod-xpath30-FTBigUnit">FTBigUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTBigUnit" id=
"prod-xpath30-FTBigUnit"></a>[119]&#160;&#160;&#160;</td>
<td><code>FTBigUnit</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"sentence" | "paragraph"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTContent" id=
"prod-xpath30-FTContent"></a>[120]&#160;&#160;&#160;</td>
<td><code>FTContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" "start") | ("at" "end") | ("entire"
"content")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTMatchOptions" id=
"prod-xpath30-FTMatchOptions"></a>[121]&#160;&#160;&#160;</td>
<td><code>FTMatchOptions</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("using" <a href=
"#prod-xpath30-FTMatchOption">FTMatchOption</a>)+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTMatchOption" id=
"prod-xpath30-FTMatchOption"></a>[122]&#160;&#160;&#160;</td>
<td><code>FTMatchOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-FTLanguageOption">FTLanguageOption</a><br />
| <a href=
"#prod-xpath30-FTWildCardOption">FTWildCardOption</a><br />
| <a href=
"#prod-xpath30-FTThesaurusOption">FTThesaurusOption</a><br />
| <a href="#prod-xpath30-FTStemOption">FTStemOption</a><br />
| <a href="#prod-xpath30-FTCaseOption">FTCaseOption</a><br />
| <a href=
"#prod-xpath30-FTDiacriticsOption">FTDiacriticsOption</a><br />
| <a href=
"#prod-xpath30-FTStopWordOption">FTStopWordOption</a><br />
| <a href=
"#prod-xpath30-FTExtensionOption">FTExtensionOption</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTCaseOption" id=
"prod-xpath30-FTCaseOption"></a>[123]&#160;&#160;&#160;</td>
<td><code>FTCaseOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("case" "insensitive")<br />
| ("case" "sensitive")<br />
| "lowercase"<br />
| "uppercase"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTDiacriticsOption" id=
"prod-xpath30-FTDiacriticsOption"></a>[124]&#160;&#160;&#160;</td>
<td><code>FTDiacriticsOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("diacritics" "insensitive")<br />
| ("diacritics" "sensitive")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTStemOption" id=
"prod-xpath30-FTStemOption"></a>[125]&#160;&#160;&#160;</td>
<td><code>FTStemOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"stemming" | ("no" "stemming")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTThesaurusOption" id=
"prod-xpath30-FTThesaurusOption"></a>[126]&#160;&#160;&#160;</td>
<td><code>FTThesaurusOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("thesaurus" (<a href=
"#prod-xpath30-FTThesaurusID">FTThesaurusID</a> | "default"))<br />
| ("thesaurus" "(" (<a href=
"#prod-xpath30-FTThesaurusID">FTThesaurusID</a> | "default") (","
<a href="#prod-xpath30-FTThesaurusID">FTThesaurusID</a>)*
")")<br />
| ("no" "thesaurus")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTThesaurusID" id=
"prod-xpath30-FTThesaurusID"></a>[127]&#160;&#160;&#160;</td>
<td><code>FTThesaurusID</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" <a href="#prod-xpath30-URILiteral">URILiteral</a>
("relationship" <a href=
"#prod-xpath30-StringLiteral">StringLiteral</a>)? (<a href=
"#prod-xpath30-FTLiteralRange">FTLiteralRange</a>
"levels")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTLiteralRange" id=
"prod-xpath30-FTLiteralRange"></a>[128]&#160;&#160;&#160;</td>
<td><code>FTLiteralRange</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("exactly" <a href=
"#prod-xpath30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "least" <a href=
"#prod-xpath30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("at" "most" <a href=
"#prod-xpath30-IntegerLiteral">IntegerLiteral</a>)<br />
| ("from" <a href="#prod-xpath30-IntegerLiteral">IntegerLiteral</a>
"to" <a href=
"#prod-xpath30-IntegerLiteral">IntegerLiteral</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTStopWordOption" id=
"prod-xpath30-FTStopWordOption"></a>[129]&#160;&#160;&#160;</td>
<td><code>FTStopWordOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("stop" "words" <a href=
"#prod-xpath30-FTStopWords">FTStopWords</a> <a href=
"#prod-xpath30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />
| ("stop" "words" "default" <a href=
"#prod-xpath30-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br />
| ("no" "stop" "words")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTStopWords" id=
"prod-xpath30-FTStopWords"></a>[130]&#160;&#160;&#160;</td>
<td><code>FTStopWords</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("at" <a href=
"#prod-xpath30-URILiteral">URILiteral</a>)<br />
| ("(" <a href="#prod-xpath30-StringLiteral">StringLiteral</a> (","
<a href="#prod-xpath30-StringLiteral">StringLiteral</a>)*
")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTStopWordsInclExcl" id=
"prod-xpath30-FTStopWordsInclExcl"></a>[131]&#160;&#160;&#160;</td>
<td><code>FTStopWordsInclExcl</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("union" | "except") <a href=
"#prod-xpath30-FTStopWords">FTStopWords</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTLanguageOption" id=
"prod-xpath30-FTLanguageOption"></a>[132]&#160;&#160;&#160;</td>
<td><code>FTLanguageOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"language" <a href=
"#prod-xpath30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTWildCardOption" id=
"prod-xpath30-FTWildCardOption"></a>[133]&#160;&#160;&#160;</td>
<td><code>FTWildCardOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"wildcards" | ("no" "wildcards")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTExtensionOption" id=
"prod-xpath30-FTExtensionOption"></a>[134]&#160;&#160;&#160;</td>
<td><code>FTExtensionOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"option" <a href="#prod-xpath30-EQName">EQName</a>
<a href="#prod-xpath30-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-FTIgnoreOption" id=
"prod-xpath30-FTIgnoreOption"></a>[135]&#160;&#160;&#160;</td>
<td><code>FTIgnoreOption</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"without" "content" <a href=
"#prod-xpath30-UnionExpr">UnionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-EQName" id=
"prod-xpath30-EQName"></a>[136]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-QName">QName</a> | <a href=
"#prod-xpath30-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<div class="div2">
<h3><a name="xpath-grammar-terminals" id=
"xpath-grammar-terminals"></a>B.1 Terminal Symbols</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-IntegerLiteral" id=
"prod-xpath30-IntegerLiteral"></a>[137]&#160;&#160;&#160;</td>
<td><code>IntegerLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath30-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-DecimalLiteral" id=
"prod-xpath30-DecimalLiteral"></a>[138]&#160;&#160;&#160;</td>
<td><code>DecimalLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xpath30-Digits">Digits</a>) |
(<a href="#prod-xpath30-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-DoubleLiteral" id=
"prod-xpath30-DoubleLiteral"></a>[139]&#160;&#160;&#160;</td>
<td><code>DoubleLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xpath30-Digits">Digits</a>) |
(<a href="#prod-xpath30-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#prod-xpath30-Digits">Digits</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-StringLiteral" id=
"prod-xpath30-StringLiteral"></a>[140]&#160;&#160;&#160;</td>
<td><code>StringLiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xpath30-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href=
"#prod-xpath30-EscapeApos">EscapeApos</a> | [^'])* "'")</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-URIQualifiedName" id=
"prod-xpath30-URIQualifiedName"></a>[141]&#160;&#160;&#160;</td>
<td><code>URIQualifiedName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath30-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xpath30-NCName">NCName</a></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-BracedURILiteral" id=
"prod-xpath30-BracedURILiteral"></a>[142]&#160;&#160;&#160;</td>
<td><code>BracedURILiteral</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" [^{}]* "}"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-EscapeQuot" id=
"prod-xpath30-EscapeQuot"></a>[143]&#160;&#160;&#160;</td>
<td><code>EscapeQuot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-EscapeApos" id=
"prod-xpath30-EscapeApos"></a>[144]&#160;&#160;&#160;</td>
<td><code>EscapeApos</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Comment" id=
"prod-xpath30-Comment"></a>[145]&#160;&#160;&#160;</td>
<td><code>Comment</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xpath30-CommentContents">CommentContents</a> | <a href=
"#prod-xpath30-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#ws-explicit">ws:
explicit</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-comments">gn:
comments</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-QName" id=
"prod-xpath30-QName"></a>[146]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-NCName" id=
"prod-xpath30-NCName"></a>[147]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-S" id=
"prod-xpath30-S"></a>[148]&#160;&#160;&#160;</td>
<td><code>S</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Char" id=
"prod-xpath30-Char"></a>[149]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <span><a href=
"http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc:
xml-version</a><sup><small>XP</small></sup></span> */</i></td>
</tr>
</tbody>
</table>
<p>The following symbols are used only in the definition of
terminal symbols; they are not terminal symbols in the grammar of
<a href="#id-xpath-grammar"><b>B EBNF for XPath 3.0 Grammar with
Full-Text extensions</b></a>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-Digits" id=
"prod-xpath30-Digits"></a>[150]&#160;&#160;&#160;</td>
<td><code>Digits</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath30-CommentContents" id=
"prod-xpath30-CommentContents"></a>[151]&#160;&#160;&#160;</td>
<td><code>CommentContents</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath30-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xqft-static-context-components" id=
"id-xqft-static-context-components"></a>C Static Context
Components</h2>
<p>The following table describes the full-text components of the
<b>static context</b> (as defined in <a href=
"http://www.w3.org/TR/xquery/#static_context">Section 2.1.1 Static
Context</a><sup><small>XQ</small></sup>). The following aspects of
each component are described:</p>
<ul>
<li>
<p><em>Default initial value:</em> This is the initial value of the
component if it is not overridden or augmented by the
implementation or by a query.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by implementation:</em>
Indicates whether an XQuery implementation is allowed to replace
the default initial value of the component by a different,
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value
and/or to augment the default initial value by additional <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> values.</p>
</li>
<li>
<p><em>Can be overwritten or augmented by a query:</em> Indicates
whether a query is allowed to replace and/or augment the initial
value provided by default or by the implementation. If so,
indicates how this is accomplished (for example, by a declaration
in the <b>prolog</b>; as defined in <a href=
"http://www.w3.org/TR/xquery/#id-query-prolog">Section 4 Modules
and Prologs</a><sup><small>XQ</small></sup>).</p>
</li>
<li>
<p><em>Scope:</em> Indicates where the component is applicable.
"Global" indicates that the component applies globally, throughout
all the modules used in a query. "Module" indicates that the
component applies throughout a <b>module</b> (as defined in
<a href="http://www.w3.org/TR/xquery/#id-query-prolog">Section 4
Modules and Prologs</a><sup><small>XQ</small></sup>). "Lexical"
indicates that the component applies within the expression in which
it is defined (equivalent to "module", if the component is declared
in a prolog.)</p>
</li>
<li>
<p><em>Consistency Rules:</em> Indicates rules that must be
observed in assigning values to the component.</p>
</li>
</ul>
<div class="small">
<table width="100%" border="1" summary="Static Context" class=
"small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th colspan="1">Component</th>
<th colspan="1">Default initial value</th>
<th colspan="1">Can be overwritten or augmented by
implementation?</th>
<th colspan="1">Can be overwritten or augmented by a query?</th>
<th colspan="1">Scope</th>
<th colspan="1">Consistency rules</th>
</tr>
<tr>
<td><a href="#ftcaseoption">FTCaseOption</a></td>
<td><code>case insensitive</code></td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>lexical</td>
<td>Value must be <code>case insensitive</code>, <code>case
sensitive</code>, <code>lowercase</code>, or
<code>uppercase</code>.</td>
</tr>
<tr>
<td><a href="#ftdiacriticsoption">FTDiacriticsOption</a></td>
<td><code>diacritics insensitive</code></td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>lexical</td>
<td>Value must be <code>diacritics insensitive</code> or
<code>diacritics sensitive</code>.</td>
</tr>
<tr>
<td><a href="#ftstemoption">FTStemOption</a></td>
<td><code>no stemming</code></td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>lexical</td>
<td>Value must be <code>stemming</code> or <code>no
stemming</code>.</td>
</tr>
<tr>
<td><a href="#ftthesaurusoption">FTThesaurusOption</a></td>
<td><code>no thesaurus</code></td>
<td>overwriteable</td>
<td>overwriteable by prolog (refer to default to augment)</td>
<td>lexical</td>
<td>Each URI in the value must be found in the statically known
thesauri.</td>
</tr>
<tr>
<td>Statically known thesauri</td>
<td>none</td>
<td>augmentable</td>
<td>cannot be augmented or overwritten by prolog</td>
<td>module</td>
<td>Each URI uniquely identifies a thesaurus list.</td>
</tr>
<tr>
<td><a href="#ftstopwordoption">FTStopWordOption</a></td>
<td><code>no stop words</code></td>
<td>overwriteable</td>
<td>overwriteable by prolog (refer to default to augment)</td>
<td>lexical</td>
<td>Each URI in the value must be found in the statically known
stop word lists.</td>
</tr>
<tr>
<td>Statically known stop word lists</td>
<td>none</td>
<td>augmentable</td>
<td>cannot be augmented or overwritten by prolog</td>
<td>module</td>
<td>Each URI uniquely identifies a stop word list.</td>
</tr>
<tr>
<td><a href="#ftlanguageoption">FTLanguageOption</a></td>
<td><a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a></td>
<td>overwriteable</td>
<td>overwriteable by prolog</td>
<td>lexical</td>
<td>Value must be castable to <code>xs:language</code>.</td>
</tr>
<tr>
<td>Statically known languages</td>
<td>none</td>
<td>augmentable</td>
<td>cannot be augmented or overwritten by prolog</td>
<td>module</td>
<td>Each string uniquely identifies a language.</td>
</tr>
<tr>
<td><a href="#ftwildcardoption">FTWildCardOption</a></td>
<td><code>no wildcards</code></td>
<td>no</td>
<td>overwriteable by prolog</td>
<td>lexical</td>
<td>Value must be <code>wildcards</code> or <code>no
wildcards</code>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>D Error Conditions</h2>
<dl>
<dt><a name="ERRFTST0001" id="ERRFTST0001"></a>err:FTST0001</dt>
<dd>
<p>An implementation that does not support the FTMildNot operator
must raise a static error if a full-text query contains a mild
not.</p>
</dd>
<dt><a name="ERRFTST0002" id="ERRFTST0002"></a>err:FTST0002</dt>
<dd>
<p>An implementation that enforces one of the restrictions on
FTUnaryNot must raise a static error if a full-text query does not
obey the restriction.</p>
</dd>
<dt><a name="ERRFTST0003" id="ERRFTST0003"></a>err:FTST0003</dt>
<dd>
<p>An implementation that does not support one or more of the
choices on FTUnit and FTBigUnit must raise a static error if a
full-text query contains one of those choices.</p>
</dd>
<dt><a name="ERRFTST0004" id="ERRFTST0004"></a>err:FTST0004</dt>
<dd>
<p>An implementation that does not support the FTScope operator
must raise a static error if a full-text query contains a
scope.</p>
</dd>
<dt><a name="ERRFTST0005" id="ERRFTST0005"></a>err:FTST0005</dt>
<dd>
<p>An implementation that does not support the FTTimes operator
must raise a static error if a full-text query contains a
times.</p>
</dd>
<dt><a name="ERRFTST0006" id="ERRFTST0006"></a>err:FTST0006</dt>
<dd>
<p>An implementation that restricts the use of FTStopWordOption
must raise a static error if a full-text query contains a stop word
option that does not meet the restriction.</p>
</dd>
<dt><a name="ERRFTST0007" id="ERRFTST0007"></a>err:FTST0007</dt>
<dd>
<p>An implementation that restricts the use of FTIgnoreOption must
raise a static error if a full-text query contains an ignore option
that does not meet the restriction.</p>
</dd>
<dt><a name="ERRFTST0008" id="ERRFTST0008"></a>err:FTST0008</dt>
<dd>
<p>It is a static error if, during the static analysis phase, the
query is found to contain a stop word option that refers to a stop
word list that is not found in the statically known stop word
lists.</p>
</dd>
<dt><a name="ERRFTST0009" id="ERRFTST0009"></a>err:FTST0009</dt>
<dd>
<p>It may be a static error if, during the static analysis phase,
the query is found to contain a language identifier in a language
option that the implementation does not support. The implementation
may choose not to raise this error and instead provide some other
implementation-defined behavior.</p>
</dd>
<dt><a name="ERRFTST0010" id="ERRFTST0010"></a>err:FTST0010</dt>
<dd>
<p>It is a static error if, during the static analysis phase, an
expression is found to use an FTOrder operator that does not appear
directly succeeding an FTWindow or an FTDistance operator and the
implementation enforces this restriction.</p>
</dd>
<dt><a name="ERRFTST0011" id="ERRFTST0011"></a>err:FTST0011</dt>
<dd>
<p>An implementation may restrict the use of FTWindow and
FTDistance to an FTOr that is either a single FTWords or a
combination of FTWords involving only the operators ftand and ftor.
If it a static error if, during the static analysis phase, an
expression is found that violates this restriction and the
implementation enforces this restriction.</p>
</dd>
<dt><a name="ERRFTST0012" id="ERRFTST0012"></a>err:FTST0012</dt>
<dd>
<p>An implementation that does not support the FTContent operator
must raise a static error if a full-text query contains one.</p>
</dd>
<dt><a name="ERRFTST0013" id="ERRFTST0013"></a>err:FTST0013</dt>
<dd>
<p>It is a static error if, during the static analysis phase, an
implementation that restricts the use of FTLanguageOption to a
single language, encounters more than one distinct language
option.</p>
</dd>
<dt><a name="ERRFTST0014" id="ERRFTST0014"></a>err:FTST0014</dt>
<dd>
<p>An implementation may constrain the form of the expression used
to compute scores. It is a static error if, during the static
analysis phase, such an implementation encounters a scoring
expression that does not meet the restriction.</p>
</dd>
<dt><a name="ERRFTST0015" id="ERRFTST0015"></a>err:FTST0015</dt>
<dd>
<p>It is a static error if, during the static analysis phase, an
implementation that restricts the choices of FTCaseOption
encounters the "lowercase" or "uppercase" option.</p>
</dd>
<dt><a name="ERRFTDY0016" id="ERRFTDY0016"></a>err:FTDY0016</dt>
<dd>
<p>It is a dynamic error if a weight value is not within the
required range of values; it is also a dynamic error if an
implementation that does not support negative weights encounters a
negative weight value.</p>
</dd>
<dt><a name="ERRFTDY0017" id="ERRFTDY0017"></a>err:FTDY0017</dt>
<dd>
<p>It is a dynamic error if an implementation encounters a mild not
selection, one of whose operands evaluates to an <b>AllMatches</b>
that contains a <b>StringExclude</b></p>
</dd>
<dt><a name="ERRFTST0018" id="ERRFTST0018"></a>err:FTST0018</dt>
<dd>
<p>It is a static error if, during the static analysis phase, the
query is found to contain a thesaurus option that refers to a
thesaurus that is not found in the statically known thesauri.</p>
</dd>
<dt><a name="ERRFTST0019" id="ERRFTST0019"></a>err:FTST0019</dt>
<dd>
<p>It is a static error if, within a single <a href=
"#doc-xquery30-FTMatchOptions">FTMatchOptions</a>, there is more
than one match option of any given <a title="match option group"
href="#dt-match-option-group">match option group</a>.</p>
</dd>
<dt><a name="ERRFTDY0020" id="ERRFTDY0020"></a>err:FTDY0020</dt>
<dd>
<p>It is a dynamic error if, when "wildcards" is in effect, a query
string violates wildcard syntax.</p>
</dd>
<dt><a name="ERRFOCH0002" id="ERRFOCH0002"></a>err:FOCH0002</dt>
<dd>
<p>It is a dynamic error if, in a function invocation, the argument
corresponding to the specified function's collation parameter does
not identify a supported collation.</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p>It is a static error if an expression is not a valid instance of
the grammar defined in <a href="#id-grammar"><b>A EBNF for XQuery
3.0 Grammar with Full Text extensions</b></a> or of the grammar
defined in <a href="#id-xpath-grammar"><b>B EBNF for XPath 3.0
Grammar with Full-Text extensions</b></a>.</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p>It is a type error if, during the static analysis phase, an
expression is found to have a static type that is not appropriate
for the context in which the expression occurs, or during the
dynamic evaluation phase, the dynamic type of a value does not
match a required type as specified by the matching rules in
<a href="http://www.w3.org/TR/xpath20/#id-sequencetype-matching">Section
2.5.4 SequenceType Matching</a><sup><small>XP</small></sup>.</p>
</dd>
<dt><a name="ERRXQST0013" id="ERRXQST0013"></a>err:XQST0013</dt>
<dd>
<p>It is a static error if an implementation recognizes a pragma
but determines that its content is invalid.</p>
</dd>
<dt><a name="ERRXQST0079" id="ERRXQST0079"></a>err:XQST0079</dt>
<dd>
<p>It is a static error if an extension expression contains neither
a pragma that is recognized by the implementation nor an expression
enclosed in curly braces.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-xqft-xqueryx" id="id-xqft-xqueryx"></a>E XML Syntax
(XQueryX) for XQuery and XPath Full Text 3.0</h2>
<p><a href="#xqueryx-30">[XQueryX 3.0]</a> defines an XML
representation of <a href="#xquery-30">[XQuery 3.0: An XML Query
Language]</a>. <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a>, section 5.4, XML Syntax,
states "XQuery and XPath Full Text MAY have more than one syntax
binding. One query language syntax MUST be expressed in XML in a
way that reflects the underlying structure of the query. See XML
Query Requirements." This appendix specifies XML Schemas that
together define the XML representation of XQuery and XPath Full
Text 3.0 by representing the abstract syntax found in <a href=
"#id-grammar"><b>A EBNF for XQuery 3.0 Grammar with Full Text
extensions</b></a>. Because XQuery and XPath Full Text 3.0
integrates seamlessly with XQuery <span>3.0</span>, it follows that
the XML Syntax for XQuery and XPath Full Text 3.0 must integrate
well with the XML Syntax for XQuery <span>3.0</span>.</p>
<p>The XML Schema specified in this appendix accomplishes
integration by importing the XML Schema defined for XQueryX in
<a href="http://www.w3.org/TR/xqueryx/#Schema">Section 4 An XML
Schema for the XQuery XML Syntax</a><sup><small>XQX</small></sup>,
incorporating all of its type and element definitions. It then
extends that schema by adding definitions of new types and elements
in a namespace belonging to the full-text specification.</p>
<p>The semantics of a Full Text XQueryX document are determined by
the semantics of the XQuery Full Text expression that results from
transforming the XQueryX document into XQuery Full Text syntax
using the XSLT stylesheet that appears in section <a href=
"#id-xqft-full-text-stylesheet"><b>E.2 XQueryX stylesheet for
XQuery and XPath Full Text 3.0</b></a>. The "correctness" of that
transformation is determined by asking the following the question:
Can some Full Text XQueryX processor QX process some Full Text
XQueryX document D1 to produce results R1, after which the
stylesheet is used to translate D1 into an XQuery Full Text
expression E1 that, when processed by some XQuery Full Text
processor Q, produces results R2 that are equivalent (under some
meaningful definition of "equivalent") to results R1?</p>
<div class="div2">
<h3><a name="id-xqft-full-text-schema" id=
"id-xqft-full-text-schema"></a>E.1 XQueryX representation of XQuery
and XPath Full Text 3.0</h3>
<p>The XML Schema that defines the complex types and elements for
XQueryX in support of XQuery and XPath Full Text 3.0, including the
ftContainsExpr, incorporates a second XML Schema that defines types
and elements to support the ftMatchOption. Both XML Schemas are
defined in this section.</p>
<div class="exampleInner">
<pre>

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified"
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton    --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton    --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton    --&gt;
&lt;!-- Cleaned up naming                           2007-04-27: Mary Holstege --&gt;
&lt;!-- Revised to align with updated syntax        2008-01-14: Jim Melton    --&gt;
&lt;!-- Moved ftOptionDecl: prolog part two to one  2008-01-24: Jim Melton    --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton    --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;xsd:include schemaLocation="./xpath-full-text-30-xqueryx-ftmatchoption-extensions.xsd"/&gt;

  &lt;xsd:element name="ftOptionDecl" substitutionGroup="xqx:prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
        &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;!-- Create a new substitution group for full-text expressions           --&gt;
  &lt;xsd:complexType name="ftExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqx:expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExpr" type="xqxft:ftExpr" abstract="true" substitutionGroup="xqx:expr"/&gt;


  &lt;!-- Represents an untyped variable for the "score" clause               --&gt;
  &lt;xsd:element name="ftScoreVariableBinding" type="xqx:QName"
               substitutionGroup="xqx:forLetClauseItemExtensions"/&gt;



  &lt;!-- FTContains ("contains text")                                        --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContainsExpr ::=                                                --&gt;
  &lt;!--     RangeExpr ( "contains" "text" FTSelection FTIgnoreOption? )?    --&gt;
  &lt;xsd:complexType name="ftContainsExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRangeExpr"
                       type="xqx:exprWrapper" /&gt;
          &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
            &lt;xsd:element name="ftSelectionExpr"
                         type="xqxft:ftSelectionWrapper" /&gt;
            &lt;xsd:element name="ftIgnoreOption"
                         type="xqxft:ftIgnoreOption"
                         minOccurs="0" maxOccurs="1" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContainsExpr" type="xqxft:ftContainsExpr" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;!-- FTProximity                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftProximity" /&gt;

  &lt;xsd:element name="ftProximity" type="xqxft:ftProximity" abstract="true"/&gt;


  &lt;!-- some simple type definitions                                        --&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnit ::= "words" | "sentences" | "paragraphs"                   --&gt;
  &lt;xsd:simpleType name="ftUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
      &lt;xsd:enumeration value="word"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTBigUnit ::= "sentence" | "paragraph"                            --&gt;
  &lt;xsd:simpleType name="ftBigUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContent ::= ("at" "start") | ("at" "end") | ("entire" "content")--&gt;
  &lt;xsd:simpleType name="contentLocation"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="at start"/&gt;
      &lt;xsd:enumeration value="at end"/&gt;
      &lt;xsd:enumeration value="entire content"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTScope ::= ("same" | "different") FTBigUnit                      --&gt;
  &lt;xsd:simpleType name="ftScopeType"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="same"/&gt;
      &lt;xsd:enumeration value="different"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;!-- range-related definitions                                           --&gt;
  &lt;xsd:complexType name="unaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="lower" type="xqx:exprWrapper" /&gt;
      &lt;xsd:element name="upper" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTRange ::= ("exactly" AdditiveExpr)                              --&gt;
  &lt;!--             | ("at" "least" AdditiveExpr)                           --&gt;
  &lt;!--             | ("at" "most" AdditiveExpr)                            --&gt;
  &lt;!--             | ("from" AdditiveExpr "to" AdditiveExpr)               --&gt;
  &lt;xsd:complexType name="ftRange"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="atLeastRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="atMostRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="exactlyRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="fromToRange" type="xqxft:binaryRange" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- ftPosFilter alternative: ordered                                    --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOrder ::= "ordered"                                             --&gt;
  &lt;xsd:complexType name="ftOrdered"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftOrdered" type="xqxft:ftOrdered" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: window                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWindow ::= "window" AdditiveExpr FTUnit                         --&gt;
  &lt;xsd:complexType name="ftWindow"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftWindow" type="xqxft:ftWindow" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: distance                                   --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDistance ::= "distance" FTRange FTUnit                          --&gt;
  &lt;xsd:complexType name="ftDistance"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRange" type="xqxft:ftRange" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftDistance" type="xqxft:ftDistance" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: scope                                      --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftScope"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="type" type="xqxft:ftScopeType" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftBigUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftScope" type="xqxft:ftScope" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: FTContent                                  --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftContent"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="location" type="xqxft:contentLocation" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContent" type="xqxft:ftContent" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftPosFilter"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="xqxft:ftProximity" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- FTSelection                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTSelection ::= FTOr FTPosFilter*                                 --&gt;
  &lt;xsd:complexType name="ftSelection" &gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftSelectionSource" type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="ftPosFilter"
                       type="xqxft:ftPosFilter"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftSelection" type="xqxft:ftSelection" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;xsd:complexType name="ftSelectionWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqxft:ftSelection"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTIgnoreOption ::= "without" "content" UnionExpr                  --&gt;
  &lt;xsd:complexType name="ftIgnoreOption"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqx:expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Full-Text logical operators                                         --&gt;
  &lt;xsd:element name="ftLogicalOp" type="xqx:binaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOr ::= FTAnd ( "ftor" FTAnd )*                                  --&gt;
  &lt;xsd:element name="ftOr" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTAnd ::= FTMildNot ( "ftand" FTMildNot )*                        --&gt;
  &lt;xsd:element name="ftAnd" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--       FTMildNot ::= FTUnaryNot ( "not" "in" FTUnaryNot )*              --&gt;
  &lt;xsd:element name="ftMildNot" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:element name="ftLogicalNot" type="xqx:unaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnaryNot ::= ("ftnot")? FTPrimaryWithOptions                    --&gt;
  &lt;xsd:element name="ftUnaryNot" type="xqx:unaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalNot"/&gt;


  &lt;!-- Definitions associated with FTWords                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTTimes ::= "occurs" FTRange "times"                              --&gt;
  &lt;xsd:complexType name="ftTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftRange" type="xqxft:ftRange"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  FTAnyallOption ::= ("any" "word"?) | ("all" "words"?) | "phrase"   --&gt;
  &lt;xsd:simpleType name="ftAnyAllOption"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="any"/&gt;
      &lt;xsd:enumeration value="all"/&gt;
      &lt;xsd:enumeration value="any word"/&gt;
      &lt;xsd:enumeration value="all words"/&gt;
      &lt;xsd:enumeration value="phrase"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWordsValue ::= StringLiteral | ("{" Expr "}")                         --&gt;
  &lt;xsd:complexType name="ftWordsAlternatives"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ftWordsLiteral" type="xqx:exprWrapper"/&gt;
      &lt;xsd:element name="ftWordsExpression" type="xqx:exprWrapper"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWords ::= FTWordsValue FTAnyallOption?                          --&gt;
  &lt;xsd:complexType name="ftWords"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWordsValue" type="xqxft:ftWordsAlternatives" /&gt;
      &lt;xsd:element name="ftAnyAllOption" type="xqxft:ftAnyAllOption"
                   minOccurs="0" maxOccurs="1" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  ... FTWordsValue FTAnyallOption?                                   --&gt;
  &lt;xsd:group name="ftWordsWithTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWords" type="xqxft:ftWords" /&gt;
      &lt;xsd:element name="ftTimes" type="xqxft:ftTimes" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionSelection ::= Pragma+ "{" FTSelection? "}"             --&gt;
  &lt;xsd:complexType name="ftExtensionSelection"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="pragma" type="xqx:pragma"
                   minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="ftSelection" type="xqxft:ftSelection"
                   minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimary ::= (FTWords FTTimes?)                                  --&gt;
  &lt;!--               | ("(" FTSelection ")")                               --&gt;
  &lt;!--               | FTExtensionSelection                                --&gt;
  &lt;xsd:complexType name="ftPrimary"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="parenthesized" type="xqx:exprWrapper"/&gt;
          &lt;xsd:group ref="xqxft:ftWordsWithTimes" /&gt;
          &lt;xsd:element name="ftExtensionSelection" type="xqxft:ftExtensionSelection"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimaryWithOptions ::= FTPrimary FTMatchOptions? FTWeight?      --&gt;
  &lt;xsd:complexType name="ftPrimaryWithOptions"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftPrimary" type="xqxft:ftPrimary"/&gt;
          &lt;xsd:element ref="xqxft:ftMatchOptions"
                       minOccurs="0" maxOccurs="1"/&gt;
          &lt;xsd:element name="weight"
                       type="xqx:exprWrapper"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftPrimaryWithOptions" type="xqxft:ftPrimaryWithOptions"
               substitutionGroup="xqxft:ftExpr"/&gt;

&lt;/xsd:schema&gt;


</pre></div>
<div class="exampleInner">
<pre>

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                         2006-08-17: Jim Melton       --&gt;
&lt;!-- First version believed complete          2006-08-29: Jim Melton       --&gt;
&lt;!-- Cleaned up naming                        2007-04-27: Mary Holstege    --&gt;     
&lt;!-- Revised to align with updated syntax     2008-01-14: Jim Melton       --&gt;
&lt;!-- Comments added to clarify each element   2008-11-12: Jim Melton       --&gt;
&lt;!-- Add element decl for ftMatchOptions      2009-07-06: Michael Dyck     --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;!-- FTMatchOption                                                       --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOption ::= FTLanguageOption                                --&gt;
  &lt;!--                   | FTWildCardOption                                --&gt;
  &lt;!--                   | FTThesaurusOption                               --&gt;
  &lt;!--                   | FTStemOption                                    --&gt;
  &lt;!--                   | FTCaseOption                                    --&gt;
  &lt;!--                   | FTDiacriticsOption                              --&gt;
  &lt;!--                   | FTStopWordOption                                --&gt;
  &lt;!--                   | FTExtensionOption                               --&gt;
  &lt;xsd:complexType name="ftMatchOption" /&gt;

  &lt;xsd:element name="ftMatchOption" type="xqxft:ftMatchOption"
               abstract="true" /&gt;
  

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOptions ::= ( "using" FTMatchOption )+                     --&gt;
  &lt;xsd:complexType name="ftMatchOptions"&gt;
    &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftMatchOptions" type="xqxft:ftMatchOptions"/&gt;
  

  &lt;!-- ftMatchOption alternative: case                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTCaseOption ::= ("case" "insensitive")                           --&gt;
  &lt;!--                  | ("case" "sensitive")                             --&gt;
  &lt;!--                  | "lowercase"                                      --&gt;
  &lt;!--                  | "uppercase"                                      --&gt;
  &lt;xsd:complexType name="ftCaseOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="lowercase"/&gt;
                &lt;xsd:enumeration value="uppercase"/&gt;
                &lt;xsd:enumeration value="case sensitive"/&gt;
                &lt;xsd:enumeration value="case insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="case" type="xqxft:ftCaseOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: diacritics                               --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDiacriticsOption ::= ("diacritics" "insensitive")               --&gt;
  &lt;!--                        | ("diacritics" "sensitive")                 --&gt;
  &lt;xsd:complexType name="ftDiacriticsOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="diacritics sensitive"/&gt;
                &lt;xsd:enumeration value="diacritics insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="diacritics" type="xqxft:ftDiacriticsOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stemming                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStemOption ::= ("stemming") | ("no" "stemming")                 --&gt;
  &lt;xsd:complexType name="ftStemOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="stemming" /&gt; 
                &lt;xsd:enumeration value="no stemming" /&gt; 
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="stem" type="xqxft:ftStemOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: thesaurus                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusID ::= "at" URILiteral ("relationship" StringLiteral)? --&gt;
  &lt;!--                       (FTRange "levels")?                           --&gt;
  &lt;xsd:complexType name="ftThesaurusID"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="at" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="relationship" type="xsd:string" minOccurs="0" /&gt;
      &lt;xsd:element name="levels" type="xqxft:ftRange" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... (FTThesaurusID | "default")                                   --&gt;
  &lt;!--   ... "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")     --&gt;
  &lt;xsd:complexType name="thesaurusSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="default" /&gt;
        &lt;xsd:element name="thesaurusID"
                     type="xqxft:ftThesaurusID" /&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="thesaurusID" type="xqxft:ftThesaurusID"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusOption ::=                                             --&gt;
  &lt;!--       ("thesaurus" (FTThesaurusID | "default"))                     --&gt;
  &lt;!--     | ("thesaurus"                                                  --&gt;
  &lt;!--          "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")  --&gt;
  &lt;!--     | ("no" "thesaurus")                                            --&gt;
  &lt;xsd:complexType name="ftThesaurusOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="noThesauri" /&gt;
          &lt;xsd:element name="thesauri" type="xqxft:thesaurusSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="thesaurus" type="xqxft:ftThesaurusOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stopwords                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--     FTStopWords ::= ("at" URILiteral)                               --&gt;
  &lt;!--   | ("(" StringLiteral ("," StringLiteral)* ")")                    --&gt;
  &lt;xsd:complexType name="ftStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ref" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="list"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="xqx:stringConstantExpr"
                         minOccurs="1" maxOccurs="unbounded" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftStopWords" type="xqxft:ftStopWords" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... "stop" "words" FTStopWords ...                                --&gt;
  &lt;!--   ... "stop" "words" "default" ...                                  --&gt;
  &lt;xsd:group name="baseStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="default" /&gt;
      &lt;xsd:element ref="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordsInclExcl ::= ("union" | "except") FTStopWords          --&gt;
  &lt;xsd:complexType name="ftStopWordsInclExcl"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="union" type="xqxft:ftStopWords" /&gt;
      &lt;xsd:element name="except" type="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... ("using" "stop" "words" FTStopWords FTStopWordsInclExcl*) ... --&gt;
  &lt;!--   ... ("using" "default" "stop" "words" FTStopWordsInclExcl*) ...   --&gt;
  &lt;xsd:complexType name="stopWordsSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:group ref="xqxft:baseStopWords" /&gt;
      &lt;xsd:element name="ftStopWordsInclExcl"
                   type="xqxft:ftStopWordsInclExcl"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordOption ::=                                              --&gt;
  &lt;!--       ("stop" "words" FTStopWords FTStopWordsInclExcl*)             --&gt;
  &lt;!--     | ("stop" "words" "default" FTStopWordsInclExcl*)               --&gt;
  &lt;!--     | ("no" "stop" "words")                                         --&gt;
  &lt;xsd:complexType name="ftStopWordOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="noStopwords" /&gt;
          &lt;xsd:element name="stopwords" type="xqxft:stopWordsSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stopword" type="xqxft:ftStopWordOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: language                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTLanguageOption ::= "language" StringLiteral                     --&gt;
  &lt;xsd:complexType name="ftLanguageOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="language" type="xqxft:ftLanguageOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: wildcards                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWildCardOption ::= ("wildcards")                                --&gt;
  &lt;!--                      | ("no" "wildcards")                           --&gt;
  &lt;xsd:complexType name="ftWildCardOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="wildcards" /&gt; 
                &lt;xsd:enumeration value="no wildcards" /&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="wildcard" type="xqxft:ftWildCardOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionOption ::= "option" QName StringLiteral                --&gt;
  &lt;xsd:complexType name="ftExtensionOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftExtensionName" type="xqx:QName"/&gt;
          &lt;xsd:element name="ftExtensionValue" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExtensionOption" type="xqxft:ftExtensionOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;

&lt;/xsd:schema&gt;


</pre></div>
</div>
<div class="div2">
<h3><a name="id-xqft-full-text-stylesheet" id=
"id-xqft-full-text-stylesheet"></a>E.2 XQueryX stylesheet for
XQuery and XPath Full Text 3.0</h3>
<p>The XSLT stylesheet that defines the semantics of XQueryX in
support of XQuery and XPath Full Text 3.0 integrates seamlessly
with the XQueryX XSLT stylesheet defined in <a href=
"http://www.w3.org/TR/xqueryx/#Stylesheet">Section B Transforming
XQueryX to XQuery</a><sup><small>XQX</small></sup> by importing the
XQueryX XSLT stylesheet. It provides additional templates that
define the semantics of the XQueryX representation of XQuery and
XPath Full Text 3.0 by transforming that XQueryX representation
into the human readable syntax of XQuery and XPath Full Text
3.0.</p>
<div class="exampleInner">
<pre>

&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
                xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton   --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton   --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton   --&gt;
&lt;!-- Revised to align with 2008-01-24 draft      2008-02-08: Jim Melton   --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton   --&gt;
&lt;!-- Various bug fixes                           2009-07-14: Michael Dyck --&gt;
&lt;!-- ftcontains =&gt; "contains text", Bug 7247     2009-09-17: Jim Melton   --&gt;
&lt;!-- with =&gt; using, stop words default, Bug 7271 2009-09-17: Jim Melton   --&gt;
&lt;!-- {} around weight values, around empty
     selection after pragmas                     2010-09-07: Jim Melton   --&gt;

&lt;xsl:import href="http://www.w3.org/2005/XQueryX/xqueryx.xsl"/&gt;


&lt;!-- ftOptionDecl --&gt;
&lt;xsl:template match="xqxft:ftOptionDecl"&gt;
  &lt;xsl:text&gt;declare ft-option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftScoreVariableBinding --&gt;
&lt;xsl:template match="xqxft:ftScoreVariableBinding"&gt;
  &lt;xsl:text&gt; score &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$DOLLAR"/&gt;
  &lt;xsl:if test="@xqx:prefix"&gt;
    &lt;xsl:value-of select="@xqx:prefix"/&gt;
    &lt;xsl:value-of select="$COLON"/&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftcontains --&gt;
&lt;xsl:template match="xqxft:ftContainsExpr"&gt;
  &lt;xsl:apply-templates select="xqxft:ftRangeExpr"/&gt;
  &lt;xsl:text&gt; contains text &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionExpr"/&gt;
  &lt;xsl:apply-templates select="xqxft:ftIgnoreOption"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:value"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftRangeExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftIgnoreOption"&gt;
  &lt;xsl:text&gt;without content &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelection"&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionSource"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;    &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftPosFilter"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionSource"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPosFilter"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;      &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- FTProximity alternative: ordered --&gt;
&lt;xsl:template match="xqxft:ftOrdered"&gt;
  &lt;xsl:text&gt;ordered &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: window --&gt;
&lt;xsl:template match="xqxft:ftWindow"&gt;
  &lt;xsl:text&gt;window &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:text&gt;s&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: distance --&gt;
&lt;xsl:template match="xqxft:ftDistance"&gt;
  &lt;xsl:text&gt;distance &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftRange"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:text&gt;s&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: scope --&gt;
&lt;xsl:template match="xqxft:ftScope"&gt;
  &lt;xsl:value-of select="xqxft:type"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: content --&gt;
&lt;xsl:template match="xqxft:ftContent"&gt;
  &lt;xsl:value-of select="xqxft:location"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:exactlyRange"&gt;
  &lt;xsl:text&gt;exactly &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atLeastRange"&gt;
  &lt;xsl:text&gt;at least &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atMostRange"&gt;
  &lt;xsl:text&gt;at most &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:fromToRange"&gt;
  &lt;xsl:text&gt;from &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:lower"/&gt;
  &lt;xsl:text&gt; to &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:upper"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:lower"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:upper"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: case --&gt;
&lt;xsl:template match="xqxft:case"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: diacritics --&gt;
&lt;xsl:template match="xqxft:diacritics"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stemming --&gt;
&lt;xsl:template match="xqxft:stem"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: thesaurus --&gt;
&lt;xsl:template match="xqxft:thesaurus"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:noThesauri"&gt;
      &lt;xsl:text&gt;no thesaurus &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesauri"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:text&gt;thesaurus &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="child::*[2]"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:default"&gt;
  &lt;xsl:text&gt;default &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesaurusID"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:at"&gt;
  &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:relationship"&gt;
  &lt;xsl:text&gt;relationship "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:levels"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; levels &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stopword --&gt;
&lt;xsl:template match="xqxft:stopword"&gt;
  &lt;xsl:text&gt;using &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:noStopwords"&gt;
      &lt;xsl:text&gt;no stop words &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt; 
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:stopwords"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:default"&gt;
      &lt;xsl:text&gt;stop words default &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;stop words &lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="xqxft:ftStopWords"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:apply-templates select="xqxft:ftStopWordsInclExcl"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:ftStopWords"&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="ftStopWords_type"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:ref"&gt;
      &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqxft:ref"/&gt;
      &lt;xsl:text&gt;" &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:list"&gt;
  &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:FTStopWordsInclExcl"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:union"&gt;
  &lt;xsl:text&gt;union &lt;/xsl:text&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:except"&gt;
  &lt;xsl:text&gt;except &lt;/xsl:text&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:language"&gt;
  &lt;xsl:text&gt;using language "&lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;"&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:wildcard"&gt;
  &lt;xsl:text&gt;using &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnd"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; ftand &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftOr"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; ftor &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftMildNot"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; not in &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftUnaryNot"&gt;
  &lt;xsl:text&gt;ftnot &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:operand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimaryWithOptions"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimary"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:parenthesized"&gt;
  &lt;xsl:text&gt;( &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; ) &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWords"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsValue"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsLiteral"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsExpression"&gt;
  &lt;xsl:text&gt; { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnyAllOption"&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftTimes"&gt;
  &lt;xsl:text&gt;occurs &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; times &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionSelection"&gt;
  &lt;xsl:apply-templates select="xqxft:pragma"/&gt;
  &lt;xsl:text&gt; { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelection"/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:pragma"&gt;
  &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
  &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
  &lt;xsl:value-of select="$SPACE"/&gt;
  &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
  &lt;xsl:value-of select="$PRAGMA_END"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionOption"&gt;
  &lt;xsl:text&gt;using option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionName"&gt;
  &lt;xsl:if test="@xqx:prefix"&gt;
    &lt;xsl:value-of select="@xqx:prefix"/&gt;
    &lt;xsl:value-of select="$COLON"/&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionValue"&gt;
  &lt;xsl:text&gt; "&lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;"&lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:weight"&gt;
  &lt;xsl:text&gt; weight { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;


</pre></div>
</div>
<div class="div2">
<h3><a name="id-xqft-full-text-examples" id=
"id-xqft-full-text-examples"></a>E.3 XQueryX for XQuery and XPath
Full Text 3.0 example</h3>
<p>The following example is based on the data and queries of one of
the use cases in <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a>. In this example, we show
the English description of the query, the XQuery Full Text solution
given in <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a>, a Full Text XQueryX
solution, and the XQuery Full Text query that results from applying
the Full Text XQueryX-to-XQuery Full Text transformation defined by
the stylesheet in <a href="#id-xqft-full-text-stylesheet"><b>E.2
XQueryX stylesheet for XQuery and XPath Full Text 3.0</b></a> to
the Full Text XQueryX solution. The latter XQuery Full Text
expression is presented only as a sanity-check — the intent of the
stylesheet is not to create the identical XQuery Full Text
expression given in <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a>, but to produce <em>a</em>
valid XQuery Full Text expression with the same semantics.</p>
<p>Comparison of the results of the Full Text XQueryX-to-XQuery
Full Text transformation given in this document with the XQuery
Full Text solutions in the <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a> may be helpful in
evaluating the correctness of the Full Text XQueryX solution in the
example.</p>
<p>The XQuery Full Text Use Cases solution given for the example is
provided only to assist readers of this document in understanding
the Full Text XQueryX solution. There is no intent to imply that
this document specifies a "compilation" or "transformation" of
XQuery Full Text syntax into Full Text XQueryX syntax.</p>
<p>In the following example, note that path expressions are
expanded to show their structure. Also, note that the prefix syntax
for binary operators like "and" makes the precedence explicit. In
general, humans find it easier to read an XML representation that
does not expand path expressions, but it is less convenient for
programmatic representation and manipulation. XQueryX is designed
as a language that is convenient for production and modification by
software, and not as a convenient syntax for humans to read and
write.</p>
<p>Finally, please note that white space, including new lines, have
been added to some of the Full Text XQueryX documents and XQuery
Full Text expressions for readability. That additional white space
is not necessarily produced by the Full Text XQueryX-to-XQuery Full
Text transformation.</p>
<div class="div3">
<h4><a name="Example1" id="Example1"></a>E.3.1 Example</h4>
<p>Here is Q4 from the <a href=
"#xpath-full-text-30-requirements-use-cases">[XQuery and XPath Full
Text 3.0 Requirements and Use Cases]</a>, use case SCORE: Find all
books with parts about "usability testing".</p>
<div class="div4">
<h5><a name="Example1-XQuery-Full-Text" id=
"Example1-XQuery-Full-Text"></a>E.3.1.1 XQuery solution in XQuery
and XPath Full Text <span>3.0</span> Use Cases:</h5>
<div class="xquery">
<div class="exampleInner">
<pre>
declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part contains text "usability test.*" 
      using wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return filter($book, $irrelevantParts)
</pre></div>
</div>
</div>
<div class="div4">
<h5><a name="Example1-Full-Text-XQueryX" id=
"Example1-Full-Text-XQueryX"></a>E.3.1.2 A Solution in Full Text
XQueryX:</h5>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
            xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2007/xpath-full-text
                                http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd
                                http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;

  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:functionDecl&gt;
        &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
        &lt;xqx:paramList&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;nodes&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:anyKindTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;exclude&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:elementTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
        &lt;/xqx:paramList&gt;
        &lt;xqx:typeDeclaration&gt;
          &lt;xqx:anyKindTest/&gt;
        &lt;/xqx:typeDeclaration&gt;
        &lt;xqx:functionBody&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;node&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:exceptOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;nodes&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:exceptOp&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:typeswitchExpr&gt;
                &lt;xqx:argExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:argExpr&gt;
                &lt;xqx:typeswitchExprCaseClause&gt;
                  &lt;xqx:variableBinding&gt;e&lt;/xqx:variableBinding&gt;
                  &lt;xqx:sequenceType&gt;
                    &lt;xqx:elementTest/&gt;
                  &lt;/xqx:sequenceType&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:computedElementConstructor&gt;
                      &lt;xqx:tagNameExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;node-name&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:tagNameExpr&gt;
                      &lt;xqx:contentExpr&gt;
                        &lt;xqx:sequenceExpr&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:attributeTest&gt;
                                &lt;xqx:attributeName&gt;
                                  &lt;xqx:star/&gt;
                                &lt;/xqx:attributeName&gt;
                              &lt;/xqx:attributeTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                          &lt;xqx:functionCallExpr&gt;
                            &lt;xqx:functionName xqx:prefix="fn"&gt;filter&lt;/xqx:functionName&gt;
                            &lt;xqx:arguments&gt;
                              &lt;xqx:exceptOp&gt;
                                &lt;xqx:firstOperand&gt;
                                  &lt;xqx:pathExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:filterExpr&gt;
                                        &lt;xqx:varRef&gt;
                                          &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                        &lt;/xqx:varRef&gt;
                                      &lt;/xqx:filterExpr&gt;
                                    &lt;/xqx:stepExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                      &lt;xqx:anyKindTest/&gt;
                                    &lt;/xqx:stepExpr&gt;
                                  &lt;/xqx:pathExpr&gt;
                                &lt;/xqx:firstOperand&gt;
                                &lt;xqx:secondOperand&gt;
                                  &lt;xqx:varRef&gt;
                                    &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                                  &lt;/xqx:varRef&gt;
                                &lt;/xqx:secondOperand&gt;
                              &lt;/xqx:exceptOp&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:arguments&gt;
                          &lt;/xqx:functionCallExpr&gt;
                        &lt;/xqx:sequenceExpr&gt;
                      &lt;/xqx:contentExpr&gt;
                    &lt;/xqx:computedElementConstructor&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprCaseClause&gt;
                &lt;xqx:typeswitchExprDefaultClause&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:varRef&gt;
                      &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                    &lt;/xqx:varRef&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprDefaultClause&gt;
              &lt;/xqx:typeswitchExpr&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:functionBody&gt;
      &lt;/xqx:functionDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:forClause&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;book&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:functionCallExpr&gt;
                      &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                      &lt;xqx:arguments&gt;
                        &lt;xqx:stringConstantExpr&gt;
                          &lt;xqx:value&gt;http://bstore1.example.com/full-text.xml&lt;/xqx:value&gt;
                        &lt;/xqx:stringConstantExpr&gt;
                      &lt;/xqx:arguments&gt;
                    &lt;/xqx:functionCallExpr&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;books&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
        &lt;/xqx:forClause&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;irrelevantParts&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:flworExpr&gt;
                &lt;xqx:forClause&gt;
                  &lt;xqx:forClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;part&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:forExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:forExpr&gt;
                  &lt;/xqx:forClauseItem&gt;
                &lt;/xqx:forClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqxft:ftScoreVariableBinding&gt;score&lt;/xqxft:ftScoreVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqxft:ftContainsExpr&gt;
                        &lt;xqxft:ftRangeExpr&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqxft:ftRangeExpr&gt;
                        &lt;xqxft:ftSelectionExpr&gt;
                          &lt;xqxft:ftSelection&gt;
                            &lt;xqxft:ftSelectionSource&gt;
                              &lt;xqxft:ftPrimaryWithOptions&gt;
                                &lt;xqxft:ftPrimary&gt;
                                  &lt;xqxft:ftWords&gt;
                                    &lt;xqxft:ftWordsValue&gt;
                                      &lt;xqxft:ftWordsLiteral&gt;
                                        &lt;xqx:stringConstantExpr&gt;
                                          &lt;xqx:value&gt;usability test.*&lt;/xqx:value&gt;
                                        &lt;/xqx:stringConstantExpr&gt;
                                     &lt;/xqxft:ftWordsLiteral&gt;
                                    &lt;/xqxft:ftWordsValue&gt;
                                  &lt;/xqxft:ftWords&gt;
                                &lt;/xqxft:ftPrimary&gt;
                                &lt;xqxft:wildcard&gt;
                                  &lt;xqxft:value&gt;using wildcards&lt;/xqxft:value&gt;
                                &lt;/xqxft:wildcard&gt;
                              &lt;/xqxft:ftPrimaryWithOptions&gt;
                            &lt;/xqxft:ftSelectionSource&gt;
                          &lt;/xqxft:ftSelection&gt;
                        &lt;/xqxft:ftSelectionExpr&gt;
                      &lt;/xqxft:ftContainsExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:whereClause&gt;
                  &lt;xqx:lessThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;score&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:decimalConstantExpr&gt;
                        &lt;xqx:value&gt;0.5&lt;/xqx:value&gt;
                      &lt;/xqx:decimalConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:lessThanOp&gt;
                &lt;/xqx:whereClause&gt;
                &lt;xqx:returnClause&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:returnClause&gt;
              &lt;/xqx:flworExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:whereClause&gt;
          &lt;xqx:lessThanOp&gt;
          &lt;xqx:firstOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:varRef&gt;
                  &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
                &lt;/xqx:varRef&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:firstOperand&gt;
          &lt;xqx:secondOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:pathExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:filterExpr&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:filterExpr&gt;
                  &lt;/xqx:stepExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                    &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                  &lt;/xqx:stepExpr&gt;
                &lt;/xqx:pathExpr&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:secondOperand&gt;
          &lt;/xqx:lessThanOp&gt;
        &lt;/xqx:whereClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqx:functionCallExpr&gt;
            &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
            &lt;xqx:arguments&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;book&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:arguments&gt;
          &lt;/xqx:functionCallExpr&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="Example1-Full-Text-Transformation" id=
"Example1-Full-Text-Transformation"></a>E.3.1.3 Transformation of
Full Text XQueryX Solution into XQuery Full Text</h5>
<p>Application of the stylesheet in <a href=
"#id-xqft-full-text-stylesheet"><b>E.2 XQueryX stylesheet for
XQuery and XPath Full Text 3.0</b></a> to the Full Text XQueryX
solution results in:</p>
<div class="xquery">
<div class="exampleInner">
<pre>
declare function local:filter($nodes as node()*, $exclude as element()*) as node()
{
( for $node in ($nodes except $exclude)
  return ( typeswitch($node)
             case $e as element()
               return element {fn:node-name($e)}
                  {( $e/child::attribute(*),
                     fn:filter( ($e/child::node() except $exclude), $exclude ) )}
             default return $node )
)
};

( for $book
    in fn:doc("http://bstore1.example.com/full-text.xml")/child::books/child::book
  let $irrelevantParts:=
  ( for $part in $book/descendant-or-self::part
    let score $score := $part contains text "usability test.*"
        using wildcards
    where ($score &lt; 0.5)
    return $part
)
  where (fn:count($irrelevantParts) &lt; fn:count($book/descendant-or-self::part))
  return local:filter($book, $irrelevantParts)
)
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="References" id="References"></a>F References</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>F.1 Normative References</h3>
<dl>
<dt class="label"><span><a name="xquery-30" id=
"xquery-30"></a>XQuery 3.0: An XML Query Language</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-30/"><cite>XQuery 3.0: An
XML Query Language</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
January 2013. This version is
http://www.w3.org/TR/2013/CR-xquery-30-20130108/. The <a href=
"http://www.w3.org/TR/xquery-30/">latest version</a> is available
at http://www.w3.org/TR/xquery-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-30" id="xpath-30"></a>XML
Path Language (XPath) 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-30/"><cite>XML Path
Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
January 2013. This version is
http://www.w3.org/TR/2013/CR-xpath-30-20130108/. The <a href=
"http://www.w3.org/TR/xpath-30/">latest version</a> is available at
http://www.w3.org/TR/xpath-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-30" id=
"xpath-functions-30"></a>XQuery and XPath Functions and Operators
3.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-30/"><cite>XQuery and XPath
Functions and Operators 3.0</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 08 January 2013. This version is
http://www.w3.org/TR/2013/CR-xpath-functions-30-20130108/. The
<a href="http://www.w3.org/TR/xpath-functions-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-datamodel-30" id=
"xpath-datamodel-30"></a>XQuery and XPath Data Model (XDM)
3.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-30/"><cite>XQuery and XPath
Data Model (XDM) 3.0</cite></a>, Norman Walsh, John Snelson,
Editors. World Wide Web Consortium, 08 January 2013. This version
is http://www.w3.org/TR/2013/CR-xpath-datamodel-30-20130108/. The
<a href="http://www.w3.org/TR/xpath-datamodel-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-30/.</div>
</dd>
<dt class="label"><span><a name="xqueryx-30" id=
"xqueryx-30"></a>XQueryX 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xqueryx-30/"><cite>XQueryX
3.0</cite></a>, Jim Melton, Editor. World Wide Web Consortium, 08
January 2013. This version is
http://www.w3.org/TR/2013/CR-xqueryx-30-20130108/. The <a href=
"http://www.w3.org/TR/xqueryx-30/">latest version</a> is available
at http://www.w3.org/TR/xqueryx-30/.</div>
</dd>
<dt class="label"><span><a name=
"xpath-full-text-30-requirements-use-cases" id=
"xpath-full-text-30-requirements-use-cases"></a>XQuery and XPath
Full Text 3.0 Requirements and Use Cases</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-full-text-30-requirements-use-cases/"><cite>
XQuery and XPath Full Text 3.0 Requirements and Use
Cases</cite></a>, Pat Case, Editor. World Wide Web Consortium,
27&#160;March&#160;2012. This version is
http://www.w3.org/TR/2012/WD-xpath-full-text-30-requirements-use-cases-20120327/.
The <a href=
"http://www.w3.org/TR/xpath-full-text-30-requirements-use-cases/">latest
version</a> is available at
http://www.w3.org/TR/xpath-full-text-30-requirements-use-cases/.</div>
</dd>
<dt class="label"><span><a name="BCP47" id="BCP47"></a>BCP
47</span></dt>
<dd>
<div>A. Phillips and M. Davis. <em>Tags for Identifying
Languages.</em> IETF BCP 47. See <a href=
"http://tools.ietf.org/html/bcp47">http://tools.ietf.org/html/bcp47</a>.
This reference leads to <a href="#RFC4646">[RFC 4646]</a> and
<a href="#RFC4647">[RFC 4647]</a> and replaces <a href=
"#RFC3066">[RFC 3066]</a>.</div>
</dd>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3066" id="RFC3066"></a>RFC
3066</span></dt>
<dd>
<div>H. Alvestrand. <em>Tags for the Identification of
Languages.</em> IETF RFC 3066. See <a href=
"http://www.ietf.org/rfc/rfc3066.txt">http://www.ietf.org/rfc/rfc3066.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC4646" id="RFC4646"></a>RFC
4646</span></dt>
<dd>
<div>A. Phillips and M. Davis. <em>Tags for Identifying
Languages.</em> IETF RFC 4646. See <a href=
"http://www.ietf.org/rfc/rfc4646.txt">http://www.ietf.org/rfc/rfc4646.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC4647" id="RFC4647"></a>RFC
4647</span></dt>
<dd>
<div>A. Phillips and M. Davis. <em>Matching of Language Tags.</em>
IETF RFC 4647. See <a href=
"http://www.ietf.org/rfc/rfc4647.txt">http://www.ietf.org/rfc/rfc4647.txt</a>.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>F.2 Non-normative References</h3>
<dl>
<dt class="label"><span><a name="iso-2788" id="iso-2788"></a>ISO
2788</span></dt>
<dd>
<div>Documentation Guidelines for the Establishment and Development
of Monolingual Thesauri, Geneva: International Organization for
Standardization, 2nd edition, 1986.</div>
</dd>
<dt class="label"><span><a name="sqlmm" id=
"sqlmm"></a>SQL/MM</span></dt>
<dd>
<div>ISO/IEC 13249-2 Information technology --- Database languages
--- SQL Multimedia and Application Packages --- Part 2: Full-Text.
Geneva: International Organization for Standardization, 2nd
edition, 2003.</div>
</dd>
<dt class="label"><span><a name="UAX29" id=
"UAX29"></a>UAX29</span></dt>
<dd>
<div>M. Davis. <em>Unicode Standard Annex #29 Text Boundaries,
revision 11, 2006.</em> See <a href=
"http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a></div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="ft-acknowledgements" id="ft-acknowledgements"></a>G
Acknowledgements (Non-Normative)</h2>
<p>We would like to thank the members of the XQuery and XPath
Full-Text group for their fruitful discussions.</p>
<p>We would like to thank the following people for their
contributions on earlier drafts of this document.</p>
<ul>
<li>
<p>Andrew Cencini, Microsoft - acencini@microsoft.com</p>
</li>
<li>
<p>Andrew Eisenberg, IBM - andrew.eisenberg@us.ibm.com</p>
</li>
<li>
<p>Nimish Khanolkar, Microsoft - nimishk@exchange.microsoft.com</p>
</li>
<li>
<p>Ashok Malhotra, Oracle - ashok.malhotra@oracle.com</p>
</li>
<li>
<p>Tapas Nayak, Microsoft - tapasnay@exchange.microsoft.com</p>
</li>
<li>
<p>Roland Seiffert, IBM - seiffert@de.ibm.com</p>
</li>
</ul>
</div>
<div class="div1">
<h2><a name="ft-glossary" id="ft-glossary"></a>H Glossary
(Non-Normative)</h2>
<dl>
<dt><a name="GLAllMatchesDef" id=
"GLAllMatchesDef"></a>AllMatches</dt>
<dd>
<p>An <b>AllMatches</b> describes the possible results of an
<b>FTSelection</b>.</p>
</dd>
<dt><a name="GLid-Distance-Operator-Restriction" id=
"GLid-Distance-Operator-Restriction"></a>Distance Operator
Restriction</dt>
<dd>
<p><b>Distance Operator Restriction.</b> FTDistance can only be
applied to an FTOr that is either a single FTWords or a combination
of FTWords involving only the operators ftand and ftor.</p>
</dd>
<dt><a name="GLFull-TextQueriesDef" id=
"GLFull-TextQueriesDef"></a>Full-TextQueries</dt>
<dd>
<p><b>Full-text queries</b> are performed on tokens and phrases.
Tokens and phrases are produced via tokenization.</p>
</dd>
<dt><a name="GLIgnoredNodesDef" id=
"GLIgnoredNodesDef"></a>IgnoredNodes</dt>
<dd>
<p><b>Ignored nodes</b> are the set of nodes whose content are
ignored.</p>
</dd>
<dt><a name="GLMatchDef" id="GLMatchDef"></a>Match</dt>
<dd>
<p>Each <b>Match</b> describes one result to the
<b>FTSelection</b>.</p>
</dd>
<dt><a name="GLid-Negation-Restriction-1" id=
"GLid-Negation-Restriction-1"></a>Negation Restriction 1</dt>
<dd>
<p><b>Negation Restriction 1.</b> An <a href=
"#doc-xquery30-FTUnaryNot">FTUnaryNot</a> expression may only
appear as a direct right operand of an "ftand" (<a href=
"#doc-xquery30-FTAnd">FTAnd</a>) operation.</p>
</dd>
<dt><a name="GLid-Negation-Restriction-2" id=
"GLid-Negation-Restriction-2"></a>Negation Restriction 2</dt>
<dd>
<p><b>Negation Restriction 2.</b> An <a href=
"#doc-xquery30-FTUnaryNot">FTUnaryNot</a> expression may not appear
as a descendant of an <a href="#doc-xquery30-FTOr">FTOr</a> that is
modified by an <a href="#doc-xquery30-FTPosFilter">FTPosFilter</a>.
(An FTOr is modified by an FTPosFilter, if it is derived using the
production for <a href="#doc-xquery30-FTSelection">FTSelection</a>
together with that FTPosFilter.)</p>
</dd>
<dt><a name="GLid-Order-Operator-Restriction" id=
"GLid-Order-Operator-Restriction"></a>Order Operator
Restriction</dt>
<dd>
<p><b>Order Operator Restriction.</b> FTOrder may only appear
directly succeeding an FTWindow or an FTDistance operator.</p>
</dd>
<dt><a name="GLParagraphDef" id="GLParagraphDef"></a>Paragraph</dt>
<dd>
<p>A <b>paragraph</b> is an ordered sequence of any number of
tokens. Beyond that, paragraphs are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support paragraphs.</p>
</dd>
<dt><a name="GLPhraseDef" id="GLPhraseDef"></a>Phrase</dt>
<dd>
<p>A <b>phrase</b> is an ordered sequence of any number of tokens.
Beyond that, phrases are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLQueryItemDef" id="GLQueryItemDef"></a>QueryItem</dt>
<dd>
<p>A <b>QueryItem</b> is a sequence of <b>QueryTokenInfo</b>s
representing the collection of tokens derived from tokenizing one
query string.</p>
</dd>
<dt><a name="GLQueryTokenInfoDef" id=
"GLQueryTokenInfoDef"></a>QueryTokenInfo</dt>
<dd>
<p>A <b>QueryTokenInfo</b> is the identity of a token inside a
query string.</p>
</dd>
<dt><a name="GLScore" id="GLScore"></a>Score</dt>
<dd>
<p>The <b>score</b> of a full-text query result expresses its
relevance to the search conditions.</p>
</dd>
<dt><a name="GLSentenceDef" id="GLSentenceDef"></a>Sentence</dt>
<dd>
<p>A <b>sentence</b> is an ordered sequence of any number of
tokens. Beyond that, sentences are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support sentences.</p>
</dd>
<dt><a name="GLid-Single-Language-Restriction" id=
"GLid-Single-Language-Restriction"></a>Single Language
Restriction</dt>
<dd>
<p><b>Single Language Restriction.</b> If a full-text query
contains more than one FTLanguageOption in its body and the prolog,
then the languages specified must be the same.</p>
</dd>
<dt><a name="GLStringExcludeDef" id=
"GLStringExcludeDef"></a>StringExclude</dt>
<dd>
<p>A <b>StringExclude</b> is a <b>StringMatch</b> that describes a
<b>TokenInfo</b> that must not be contained in the document.</p>
</dd>
<dt><a name="GLStringIncludeDef" id=
"GLStringIncludeDef"></a>StringInclude</dt>
<dd>
<p>A <b>StringInclude</b> is a <b>StringMatch</b> that describes a
<b>TokenInfo</b> that must be contained in the document.</p>
</dd>
<dt><a name="GLStringMatchDef" id=
"GLStringMatchDef"></a>StringMatch</dt>
<dd>
<p>A <b>StringMatch</b> is a possible match of a sequence of query
tokens with a corresponding sequence of tokens in a document. A
StringMatch may be a <b>StringInclude</b> or
<b>StringExclude</b>.</p>
</dd>
<dt><a name="GLTokenDef" id="GLTokenDef"></a>Token</dt>
<dd>
<p>A <b>token</b> is a non-empty sequence of characters returned by
a tokenizer as a basic unit to be searched. Beyond that, tokens are
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLTokenInfoDef" id="GLTokenInfoDef"></a>TokenInfo</dt>
<dd>
<p>A <b>TokenInfo</b> represents a contiguous collection of tokens
from an XML document.</p>
</dd>
<dt><a name="GLTokenizationDef" id=
"GLTokenizationDef"></a>Tokenization</dt>
<dd>
<p>Formally, <b>tokenization</b> is the process of converting an
XDM item to a collections of tokens, taking any structural
information of the item into account to identify token, sentence,
and paragraph boundaries. Each token is assigned a starting and
ending position.</p>
</dd>
<dt><a name="GLWeightDeclarationsDef" id=
"GLWeightDeclarationsDef"></a>WeightDeclarations</dt>
<dd>
<p>Scoring may be influenced by adding <b>weight declarations</b>
to search tokens, phrases, and expressions.</p>
</dd>
<dt><a name="GLid-Window-Operator-Restriction" id=
"GLid-Window-Operator-Restriction"></a>Window Operator
Restriction</dt>
<dd>
<p><b>Window Operator Restriction.</b> FTWindow can only be applied
to an FTOr that is either a single FTWords or a combination of
FTWords involving only the operators ftand and ftor.</p>
</dd>
<dt><a name="GLdt-anchoring-selection" id=
"GLdt-anchoring-selection"></a>anchoring selection</dt>
<dd>
<p>An <b>anchoring selection</b> consists of a full-text selection
followed by one of the postfix operators "at start", "at end", or
"entire content".</p>
</dd>
<dt><a name="GLdt-and-selection" id=
"GLdt-and-selection"></a>and-selection</dt>
<dd>
<p>An <b>and-selection</b> combines two full-text selections using
the <code>ftand</code> operator.</p>
</dd>
<dt><a name="GLdt-cardinality-selection" id=
"GLdt-cardinality-selection"></a>cardinality selection</dt>
<dd>
<p>A <b>cardinality selection</b> consist of an <a href=
"#doc-xquery30-FTWords">FTWords</a> followed by the <a href=
"#doc-xquery30-FTTimes">FTTimes</a> postfix operator.</p>
</dd>
<dt><a name="GLdt-ftcaseoption" id="GLdt-ftcaseoption"></a>case
option</dt>
<dd>
<p>A <b>case option</b> modifies the matching of tokens and phrases
by specifying how uppercase and lowercase characters are
considered.</p>
</dd>
<dt><a name="GLdt-ftdiacriticsoption" id=
"GLdt-ftdiacriticsoption"></a>diacritics option</dt>
<dd>
<p>A <b>diacritics option</b> modifies token and phrase matching by
specifying how diacritics are considered.</p>
</dd>
<dt><a name="GLdt-distance-selection" id=
"GLdt-distance-selection"></a>distance selection</dt>
<dd>
<p>A <b>distance selection</b> consists of a full-text selection
followed by one of the (complex) postfix operators derived from
<a href="#doc-xquery30-FTDistance">FTDistance</a>.</p>
</dd>
<dt><a name="GLdt-ftextensionoption" id=
"GLdt-ftextensionoption"></a>extension option</dt>
<dd>
<p>An <b>extension option</b> is a match option that acts in an
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
</dd>
<dt><a name="GLdt-extension-selection" id=
"GLdt-extension-selection"></a>extension selection</dt>
<dd>
<p>An <b>extension selection</b> is a full-text selection whose
semantics are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLdt-ftcontains" id="GLdt-ftcontains"></a>full-text
contains expression</dt>
<dd>
<p>A <b>full-text contains expression</b> is a expression that
evaluates a sequence of items against a full-text selection.</p>
</dd>
<dt><a name="GLftselection" id="GLftselection"></a>full-text
selection</dt>
<dd>
<p>A <b>full-text selection</b> specifies the conditions of a
full-text search.</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may
differ between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.</p>
</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may
differ between implementations, but must be specified by the
implementor for each particular implementation.</p>
</dd>
<dt><a name="GLdt-ftlanguageoption" id=
"GLdt-ftlanguageoption"></a>language option</dt>
<dd>
<p>A <b>language option</b> modifies token matching by specifying
the language of search tokens and phrases.</p>
</dd>
<dt><a name="GLdt-match-options" id="GLdt-match-options"></a>match
option</dt>
<dd>
<p><b>Match options</b> modify the set of tokens in the query, or
how they are matched against tokens in the text.</p>
</dd>
<dt><a name="GLdt-match-option-order" id=
"GLdt-match-option-order"></a>match option application order</dt>
<dd>
<p>The order in which effective match options for an <a href=
"#doc-xquery30-FTWords">FTWords</a> are applied is called the
<b>match option application order</b>.</p>
</dd>
<dt><a name="GLdt-match-option-group" id=
"GLdt-match-option-group"></a>match option group</dt>
<dd>
<p>Each of the alternatives of production <a href=
"#doc-xquery30-FTMatchOption">FTMatchOption</a> other than <a href=
"#doc-xquery30-FTExtensionOption">FTExtensionOption</a> corresponds
to one <b>match option group</b>.</p>
</dd>
<dt><a name="GLmay" id="GLmay"></a>may</dt>
<dd>
<p><b>MAY</b> means that an item is truly optional.</p>
</dd>
<dt><a name="GLdt-mild-not-selection" id=
"GLdt-mild-not-selection"></a>mild-not selection</dt>
<dd>
<p>A <b>mild-not selection</b> combines two full-text selections
using the <code>not in</code> operator.</p>
</dd>
<dt><a name="GLmust" id="GLmust"></a>must</dt>
<dd>
<p><b>MUST</b> means that the item is an absolute requirement of
the specification.</p>
</dd>
<dt><a name="GLdt-unary-not-selection" id=
"GLdt-unary-not-selection"></a>not-selection</dt>
<dd>
<p>A <b>not-selection</b> is a full-text selection starting with
the prefix operator <code>ftnot</code>.</p>
</dd>
<dt><a name="GLdt-or-selection" id=
"GLdt-or-selection"></a>or-selection</dt>
<dd>
<p>An <b>or-selection</b> combines two full-text selections using
the <code>ftor</code> operator.</p>
</dd>
<dt><a name="GLdt-ordered-selection" id=
"GLdt-ordered-selection"></a>ordered selection</dt>
<dd>
<p>An <b>ordered selection</b> consists of a full-text selection
followed by the postfix operator "ordered".</p>
</dd>
<dt><a name="GLdt-ftposfilter" id="GLdt-ftposfilter"></a>positional
filter</dt>
<dd>
<p><b>Positional filters</b> are postfix operators that serve to
filter matches based on various constraints on their positional
information.</p>
</dd>
<dt><a name="GLdt-ftprimary" id="GLdt-ftprimary"></a>primary
full-text selection</dt>
<dd>
<p>A <b>primary full-text selection</b> is the basic form of a
full-text selection. It specifies tokens and phrases as search
conditions (<a href="#doc-xquery30-FTWords">FTWords</a>),
optionally followed by a cardinality constraint (<a href=
"#doc-xquery30-FTTimes">FTTimes</a>). An <a href=
"#doc-xquery30-FTSelection">FTSelection</a> in parentheses and the
<a href=
"#doc-xquery30-FTExtensionSelection">FTExtensionSelection</a> are
also a primary full-text selections.</p>
</dd>
<dt><a name="GLdt-scope-selection" id=
"GLdt-scope-selection"></a>scope selection</dt>
<dd>
<p>A <b>scope selection</b> consists of a full-text selection
followed by one of the (complex) postfix operators derived from
<a href="#doc-xquery30-FTScope">FTScope</a>.</p>
</dd>
<dt><a name="GLdt-search-context" id=
"GLdt-search-context"></a>search context</dt>
<dd>
<p>Those items are called the <b>search context</b>.</p>
</dd>
<dt><a name="GLshould" id="GLshould"></a>should</dt>
<dd>
<p><b>SHOULD</b> means that there may exist valid reasons in
particular circumstances to ignore a particular item, but the full
implications must be understood and carefully weighed before
choosing a different course.</p>
</dd>
<dt><a name="GLdt-ftstemoption" id="GLdt-ftstemoption"></a>stemming
option</dt>
<dd>
<p>A <b>stemming option</b> modifies token and phrase matching by
specifying whether stemming is applied or not.</p>
</dd>
<dt><a name="GLdt-ftstopwordoption" id=
"GLdt-ftstopwordoption"></a>stop word option</dt>
<dd>
<p>A <b>stop word option</b> controls matching of tokens by
specifying whether stop words are used or not. Stop words are
tokens in the query that match any token in the text being
searched.</p>
</dd>
<dt><a name="GLdt-ftthesaurusoption" id=
"GLdt-ftthesaurusoption"></a>thesaurus option</dt>
<dd>
<p>A <b>thesaurus option</b> modifies token and phrase matching by
specifying whether a thesaurus is used or not.</p>
</dd>
<dt><a name="GLdt-ftwildcardoption" id=
"GLdt-ftwildcardoption"></a>wildcard option</dt>
<dd>
<p>A <b>wildcard option</b> modifies token and phrase matching by
specifying whether or not wildcards are recognized in query
strings.</p>
</dd>
<dt><a name="GLdt-window-selection" id=
"GLdt-window-selection"></a>window selection</dt>
<dd>
<p>A <b>window selection</b> consists of a full-text selection
followed by one of the (complex) postfix operators derived from
<a href="#doc-xquery30-FTWindow">FTWindow</a>.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="impl-def" id="impl-def"></a>I Checklist of
Implementation-Defined Features (Non-Normative)</h2>
<p>This appendix provides a summary of features defined in this
specification whose effect is explicitly <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. The
conformance rules require vendors to provide documentation that
explains how these choices have been exercised.</p>
<ol class="enumar">
<li>
<p>Tokenization, including the definition of the term "tokens",
<a title="should" href="#should">SHOULD</a> be <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.
Implementations <a title="should" href="#should">SHOULD</a> expose
the rules and sample results of tokenization as much as possible to
enable users to predict and interpret the results of
tokenization.</p>
</li>
<li>
<p>A phrase is an ordered sequence of any number of tokens. Beyond
that, phrases are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>A sentence is an ordered sequence of any number of tokens.
Beyond that, sentences are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support sentences.</p>
</li>
<li>
<p>A paragraph is an ordered sequence of any number of tokens.
Beyond that, paragraphs are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. A
tokenizer is not required to support paragraphs.</p>
</li>
<li>
<p>Implementations are free to provide <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> ways to
differentiate between markup's effect on token boundaries during
tokenization.</p>
</li>
<li>
<p>The set of expressions (of form ExprSingle) that can be assigned
to a score variable in a let-clause is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. If an
expression not supported by the scoring algorithm is passed to the
scoring algorithm, the result is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>When a sequence of query tokens is considered as a phrase, it
matches a sequence of tokens in the tokenized form of the text
being searched only if the two sequences correspond in an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
</li>
<li>
<p>The <a title="match option application order" href=
"#dt-match-option-order">match option application order</a>,
subject to the stated constraints, is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The "language" option influences tokenization, stemming, and
stop words in an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way. It
<a title="may" href="#may">MAY</a> influence the behavior of other
match options in an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
</li>
<li>
<p>The set of valid language identifiers is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>If an invalid language identifier is specified, then the
behavior is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>When a processor evaluates text in a document that is governed
by an xml:lang attribute and the portion of the full-text query
doing that evaluation contains an FTLanguageOption that specifies a
different language from the language specified by the governing
xml:lang attribute, the language-related behavior of that full-text
query is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>It is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> which
thesaurus relationships an implementation supports.</p>
</li>
<li>
<p>If a query specifies thesaurus relationships not supported by
the thesaurus, or does not specify a relationship, the behavior is
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The effect of specifying a particular range of levels in an
FTThesaurusID is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>If a query does not specify the number of levels, and the
implementation does not follow the default of querying all levels
of hierarchical relationships, then the number of levels of
hierarchical relationships queries is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>It is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> what a stem
of a token is, and whether stemming is based on an algorithm,
dictionary, or mixed approach.</p>
</li>
<li>
<p>An <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> comparison
is used to determine whether a query token appears in the
collection of stop words defined by the applicable stop word
option.</p>
</li>
<li>
<p>Normally a stop word matches exactly one token, but there may be
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> conditions,
under which a stop word may match a different number of tokens.</p>
</li>
<li>
<p>The "stop words default" option specifies that an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collection
of stop words is used.</p>
</li>
<li>
<p>An implementation recognizes an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs used to denote extension options. The effect of
each, including its error behavior, is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>An implementation recognizes an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
namespace URIs used to denote extension selection pragmas. The
effect of each, including its error behavior, is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The conditions under which tokenization of two equal items
produces different tokens is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>An implementation may impose an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> restriction
on the operand of FTIgnoreOption.</p>
</li>
<li>
<p>For certain full-text components of the static context (see
<a href="#id-xqft-static-context-components"><b>C Static Context
Components</b></a>), the default initial value of the component can
be overwritten or augmented with an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value or
values.</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="id-xqft-changelog" id="id-xqft-changelog"></a>J Change
Log (Non-Normative)</h2>
<table border="1" summary="Change Log Table">
<tbody>
<tr>
<td>Mary Holstege</td>
<td>All</td>
<td>Initial draft for 3.0</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
