<!-- http://www.w3.org/TR/owl2-syntax/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="owl.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://www.w3.org/2007/OWL/toggles.js"></script>
  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both">OWL 2 Web Ontology Language <br /><span id="short-title">Structural Specification and Functional-Style Syntax (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 11 December 2012</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/" id="this-version-url">http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/</a></dd>

<dt>Latest version (series 2):</dt>
<dd><a href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a></dd>

<dt>Latest Recommendation:</dt>
<dd><a href="http://www.w3.org/TR/owl-syntax">http://www.w3.org/TR/owl-syntax</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-owl2-syntax-20121018/">http://www.w3.org/TR/2012/PER-owl2-syntax-20121018/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd><a href="http://www.cs.ox.ac.uk/people/boris.motik/">Boris Motik</a>, University of Oxford</dd>
<dd>Peter F. Patel-Schneider, Nuance Communications</dd>
<dd><a href="http://www.cs.man.ac.uk/~bparsia/">Bijan Parsia</a>, University of Manchester</dd>
<dt>Contributors: (in alphabetical order)</dt><dd>Conrad Bock, National Institute of Standards and Technology (NIST)</dd>
<dd><a href="http://domino.research.ibm.com/comm/research_people.nsf/pages/achille.index.html">Achille Fokoue</a>, IBM Corporation</dd>
<dd><a href="http://peterhaase.org/">Peter Haase</a>, FZI Research Center for Information Technology</dd>
<dd><a href="http://www.leibnizcenter.org/~hoekstra/">Rinke Hoekstra</a>, University of Amsterdam</dd>
<dd><a href="http://www.cs.ox.ac.uk/people/ian.horrocks/">Ian Horrocks</a>, University of Oxford</dd>
<dd><a href="http://sciencecommons.org/about/whoweare/ruttenberg/">Alan Ruttenberg</a>, Science Commons (Creative Commons)</dd>
<dd><a href="http://www.cs.man.ac.uk/~sattler/">Uli Sattler</a>, University of Manchester</dd>
<dd><a href="http://www.clarkparsia.com/about/profiles/msmith">Michael Smith</a>, Clark &amp; Parsia</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2007/OWL/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/diff-from-20121018">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2012/pdf/REC-owl2-syntax-20121211.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2007/OWL/translation/owl2-syntax">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2012 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>The OWL 2 Web Ontology Language, informally OWL 2, is an ontology language for the Semantic Web with formally defined meaning.  OWL 2 ontologies provide classes, properties, individuals, and data values and are stored as Semantic Web documents.  OWL 2 ontologies can be used along with information written in RDF, and OWL 2 ontologies themselves are primarily exchanged as RDF documents.  The OWL 2 <a href="http://www.w3.org/TR/2012/REC-owl2-overview-20121211/" title="Document Overview">Document Overview</a> describes the overall state of OWL 2, and should be read before other OWL 2 documents.</p><p>The meaningful constructs provided by OWL 2 are defined in terms of their structure. As well, a functional-style syntax is defined for these constructs, with examples and informal descriptions. One can reason with OWL 2 ontologies under either the RDF-Based Semantics [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>] or the Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>]. If certain restrictions on OWL 2 ontologies are satisfied and the ontology is in OWL 2 DL, reasoning under the Direct Semantics can be implemented using techniques well known in the literature.</p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Summary of Changes</h4>

            <div>There have been no <a href="http://www.w3.org/2005/10/Process-20051014/tr#substantive-change">substantive</a> changes since the <a href="http://www.w3.org/TR/2012/PER-owl2-syntax-20121018/">previous version</a>.   For details on the minor changes see the <a href="#changelog">change log</a> and <a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/diff-from-20121018">color-coded diff</a>.</div>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-owl-comments@w3.org">public-owl-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2007/OWL/">OWL Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2007/OWL/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/41712/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<p>
</p>
<script type="text/javascript">/*&lt;![CDATA[*/

function show_short_toc() {
    set_display_by_class('li','toclevel-3','none');
    set_display_by_id('short-toc','none');
    set_display_by_id('full-toc','');
}

function show_full_toc() {
    set_display_by_class('li','toclevel-3','');
    set_display_by_id('short-toc','');
    set_display_by_id('full-toc','none');
}

var bFSSVisible=true;
var bRDFVisible=false;

function show_syntaxes(bShowFSS,bShowRDF) {
    bFSSVisible=bShowFSS;
    bRDFVisible=bShowRDF;
    if (bShowFSS)
        set_display_by_class('table','fss','');
    else
        set_display_by_class('table','fss','none');
    if (bShowRDF)
        set_display_by_class('table','rdf','');
    else
        set_display_by_class('table','rdf','none');
    /* I cannot make Mediawiki accept the ampersand character, so we implement conjunction in a roundabout way. */
    var bBothOn=true;
    if (!bShowFSS)
        bBothOn=false;
    if (!bShowRDF)
        bBothOn=false;
    if (bBothOn) {
        set_display_by_class('caption','fss','');
        set_display_by_class('caption','rdf','');
    }
    else {
        set_display_by_class('caption','fss','none');
        set_display_by_class('caption','rdf','none');
    }
}

/*]]&gt;*/</script>


<p>

</p>
<table class="toc" id="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1"><a href="#Preliminary_Definitions"><span class="tocnumber">2</span> <span class="toctext">Preliminary Definitions</span></a>
<ul>
<li class="toclevel-2"><a href="#Structural_Specification"><span class="tocnumber">2.1</span> <span class="toctext">Structural Specification</span></a></li>
<li class="toclevel-2"><a href="#BNF_Notation"><span class="tocnumber">2.2</span> <span class="toctext">BNF Notation</span></a></li>
<li class="toclevel-2"><a href="#Integers.2C_Characters.2C_Strings.2C_Language_Tags.2C_and_Node_IDs"><span class="tocnumber">2.3</span> <span class="toctext">Integers, Characters, Strings, Language Tags, and Node IDs</span></a></li>
<li class="toclevel-2"><a href="#IRIs"><span class="tocnumber">2.4</span> <span class="toctext">IRIs</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Ontologies"><span class="tocnumber">3</span> <span class="toctext">Ontologies</span></a>
<ul>
<li class="toclevel-2"><a href="#Ontology_IRI_and_Version_IRI"><span class="tocnumber">3.1</span> <span class="toctext">Ontology IRI and Version IRI</span></a></li>
<li class="toclevel-2"><a href="#Ontology_Documents"><span class="tocnumber">3.2</span> <span class="toctext">Ontology Documents</span></a></li>
<li class="toclevel-2"><a href="#Versioning_of_OWL_2_Ontologies"><span class="tocnumber">3.3</span> <span class="toctext">Versioning of OWL 2 Ontologies</span></a></li>
<li class="toclevel-2"><a href="#Imports"><span class="tocnumber">3.4</span> <span class="toctext">Imports</span></a></li>
<li class="toclevel-2"><a href="#Ontology_Annotations"><span class="tocnumber">3.5</span> <span class="toctext">Ontology Annotations</span></a></li>
<li class="toclevel-2"><a href="#Canonical_Parsing_of_OWL_2_Ontologies"><span class="tocnumber">3.6</span> <span class="toctext">Canonical Parsing of OWL 2 Ontologies</span></a></li>
<li class="toclevel-2"><a href="#Functional-Style_Syntax"><span class="tocnumber">3.7</span> <span class="toctext">Functional-Style Syntax</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Datatype_Maps"><span class="tocnumber">4</span> <span class="toctext">Datatype Maps</span></a>
<ul>
<li class="toclevel-2"><a href="#Real_Numbers.2C_Decimal_Numbers.2C_and_Integers"><span class="tocnumber">4.1</span> <span class="toctext">Real Numbers, Decimal Numbers, and Integers</span></a></li>
<li class="toclevel-2"><a href="#Floating-Point_Numbers"><span class="tocnumber">4.2</span> <span class="toctext">Floating-Point Numbers</span></a></li>
<li class="toclevel-2"><a href="#Strings"><span class="tocnumber">4.3</span> <span class="toctext">Strings</span></a></li>
<li class="toclevel-2"><a href="#Boolean_Values"><span class="tocnumber">4.4</span> <span class="toctext">Boolean Values</span></a></li>
<li class="toclevel-2"><a href="#Binary_Data"><span class="tocnumber">4.5</span> <span class="toctext">Binary Data</span></a></li>
<li class="toclevel-2"><a href="#IRIs_2"><span class="tocnumber">4.6</span> <span class="toctext">IRIs</span></a></li>
<li class="toclevel-2"><a href="#Time_Instants"><span class="tocnumber">4.7</span> <span class="toctext">Time Instants</span></a></li>
<li class="toclevel-2"><a href="#XML_Literals"><span class="tocnumber">4.8</span> <span class="toctext">XML Literals</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Entities.2C_Literals.2C_and_Anonymous_Individuals"><span class="tocnumber">5</span> <span class="toctext">Entities, Literals, and Anonymous Individuals</span></a>
<ul>
<li class="toclevel-2"><a href="#Classes"><span class="tocnumber">5.1</span> <span class="toctext">Classes</span></a></li>
<li class="toclevel-2"><a href="#Datatypes"><span class="tocnumber">5.2</span> <span class="toctext">Datatypes</span></a></li>
<li class="toclevel-2"><a href="#Object_Properties"><span class="tocnumber">5.3</span> <span class="toctext">Object Properties</span></a></li>
<li class="toclevel-2"><a href="#Data_Properties"><span class="tocnumber">5.4</span> <span class="toctext">Data Properties</span></a></li>
<li class="toclevel-2"><a href="#Annotation_Properties"><span class="tocnumber">5.5</span> <span class="toctext">Annotation Properties</span></a></li>
<li class="toclevel-2"><a href="#Individuals"><span class="tocnumber">5.6</span> <span class="toctext">Individuals</span></a>
<ul>
<li class="toclevel-3"><a href="#Named_Individuals"><span class="tocnumber">5.6.1</span> <span class="toctext">Named Individuals</span></a></li>
<li class="toclevel-3"><a href="#Anonymous_Individuals"><span class="tocnumber">5.6.2</span> <span class="toctext">Anonymous Individuals</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Literals"><span class="tocnumber">5.7</span> <span class="toctext">Literals</span></a></li>
<li class="toclevel-2"><a href="#Entity_Declarations_and_Typing"><span class="tocnumber">5.8</span> <span class="toctext">Entity Declarations and Typing</span></a>
<ul>
<li class="toclevel-3"><a href="#Typing_Constraints_of_OWL_2_DL"><span class="tocnumber">5.8.1</span> <span class="toctext">Typing Constraints of OWL 2 DL</span></a></li>
<li class="toclevel-3"><a href="#Declaration_Consistency"><span class="tocnumber">5.8.2</span> <span class="toctext">Declaration Consistency</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Metamodeling"><span class="tocnumber">5.9</span> <span class="toctext">Metamodeling</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Property_Expressions"><span class="tocnumber">6</span> <span class="toctext">Property Expressions</span></a>
<ul>
<li class="toclevel-2"><a href="#Object_Property_Expressions"><span class="tocnumber">6.1</span> <span class="toctext">Object Property Expressions</span></a>
<ul>
<li class="toclevel-3"><a href="#Inverse_Object_Properties"><span class="tocnumber">6.1.1</span> <span class="toctext">Inverse Object Properties</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Data_Property_Expressions"><span class="tocnumber">6.2</span> <span class="toctext">Data Property Expressions</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Data_Ranges"><span class="tocnumber">7</span> <span class="toctext">Data Ranges</span></a>
<ul>
<li class="toclevel-2"><a href="#Intersection_of_Data_Ranges"><span class="tocnumber">7.1</span> <span class="toctext">Intersection of Data Ranges</span></a></li>
<li class="toclevel-2"><a href="#Union_of_Data_Ranges"><span class="tocnumber">7.2</span> <span class="toctext">Union of Data Ranges</span></a></li>
<li class="toclevel-2"><a href="#Complement_of_Data_Ranges"><span class="tocnumber">7.3</span> <span class="toctext">Complement of Data Ranges</span></a></li>
<li class="toclevel-2"><a href="#Enumeration_of_Literals"><span class="tocnumber">7.4</span> <span class="toctext">Enumeration of Literals</span></a></li>
<li class="toclevel-2"><a href="#Datatype_Restrictions"><span class="tocnumber">7.5</span> <span class="toctext">Datatype Restrictions</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Class_Expressions"><span class="tocnumber">8</span> <span class="toctext">Class Expressions</span></a>
<ul>
<li class="toclevel-2"><a href="#Propositional_Connectives_and_Enumeration_of_Individuals"><span class="tocnumber">8.1</span> <span class="toctext">Propositional Connectives and Enumeration of Individuals</span></a>
<ul>
<li class="toclevel-3"><a href="#Intersection_of_Class_Expressions"><span class="tocnumber">8.1.1</span> <span class="toctext">Intersection of Class Expressions</span></a></li>
<li class="toclevel-3"><a href="#Union_of_Class_Expressions"><span class="tocnumber">8.1.2</span> <span class="toctext">Union of Class Expressions</span></a></li>
<li class="toclevel-3"><a href="#Complement_of_Class_Expressions"><span class="tocnumber">8.1.3</span> <span class="toctext">Complement of Class Expressions</span></a></li>
<li class="toclevel-3"><a href="#Enumeration_of_Individuals"><span class="tocnumber">8.1.4</span> <span class="toctext">Enumeration of Individuals</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Object_Property_Restrictions"><span class="tocnumber">8.2</span> <span class="toctext">Object Property Restrictions</span></a>
<ul>
<li class="toclevel-3"><a href="#Existential_Quantification"><span class="tocnumber">8.2.1</span> <span class="toctext">Existential Quantification</span></a></li>
<li class="toclevel-3"><a href="#Universal_Quantification"><span class="tocnumber">8.2.2</span> <span class="toctext">Universal Quantification</span></a></li>
<li class="toclevel-3"><a href="#Individual_Value_Restriction"><span class="tocnumber">8.2.3</span> <span class="toctext">Individual Value Restriction</span></a></li>
<li class="toclevel-3"><a href="#Self-Restriction"><span class="tocnumber">8.2.4</span> <span class="toctext">Self-Restriction</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Object_Property_Cardinality_Restrictions"><span class="tocnumber">8.3</span> <span class="toctext">Object Property Cardinality Restrictions</span></a>
<ul>
<li class="toclevel-3"><a href="#Minimum_Cardinality"><span class="tocnumber">8.3.1</span> <span class="toctext">Minimum Cardinality</span></a></li>
<li class="toclevel-3"><a href="#Maximum_Cardinality"><span class="tocnumber">8.3.2</span> <span class="toctext">Maximum Cardinality</span></a></li>
<li class="toclevel-3"><a href="#Exact_Cardinality"><span class="tocnumber">8.3.3</span> <span class="toctext">Exact Cardinality</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Data_Property_Restrictions"><span class="tocnumber">8.4</span> <span class="toctext">Data Property Restrictions</span></a>
<ul>
<li class="toclevel-3"><a href="#Existential_Quantification_2"><span class="tocnumber">8.4.1</span> <span class="toctext">Existential Quantification</span></a></li>
<li class="toclevel-3"><a href="#Universal_Quantification_2"><span class="tocnumber">8.4.2</span> <span class="toctext">Universal Quantification</span></a></li>
<li class="toclevel-3"><a href="#Literal_Value_Restriction"><span class="tocnumber">8.4.3</span> <span class="toctext">Literal Value Restriction</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Data_Property_Cardinality_Restrictions"><span class="tocnumber">8.5</span> <span class="toctext">Data Property Cardinality Restrictions</span></a>
<ul>
<li class="toclevel-3"><a href="#Minimum_Cardinality_2"><span class="tocnumber">8.5.1</span> <span class="toctext">Minimum Cardinality</span></a></li>
<li class="toclevel-3"><a href="#Maximum_Cardinality_2"><span class="tocnumber">8.5.2</span> <span class="toctext">Maximum Cardinality</span></a></li>
<li class="toclevel-3"><a href="#Exact_Cardinality_2"><span class="tocnumber">8.5.3</span> <span class="toctext">Exact Cardinality</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Axioms"><span class="tocnumber">9</span> <span class="toctext">Axioms</span></a>
<ul>
<li class="toclevel-2"><a href="#Class_Expression_Axioms"><span class="tocnumber">9.1</span> <span class="toctext">Class Expression Axioms</span></a>
<ul>
<li class="toclevel-3"><a href="#Subclass_Axioms"><span class="tocnumber">9.1.1</span> <span class="toctext">Subclass Axioms</span></a></li>
<li class="toclevel-3"><a href="#Equivalent_Classes"><span class="tocnumber">9.1.2</span> <span class="toctext">Equivalent Classes</span></a></li>
<li class="toclevel-3"><a href="#Disjoint_Classes"><span class="tocnumber">9.1.3</span> <span class="toctext">Disjoint Classes</span></a></li>
<li class="toclevel-3"><a href="#Disjoint_Union_of_Class_Expressions"><span class="tocnumber">9.1.4</span> <span class="toctext">Disjoint Union of Class Expressions</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Object_Property_Axioms"><span class="tocnumber">9.2</span> <span class="toctext">Object Property Axioms</span></a>
<ul>
<li class="toclevel-3"><a href="#Object_Subproperties"><span class="tocnumber">9.2.1</span> <span class="toctext">Object Subproperties</span></a></li>
<li class="toclevel-3"><a href="#Equivalent_Object_Properties"><span class="tocnumber">9.2.2</span> <span class="toctext">Equivalent Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Disjoint_Object_Properties"><span class="tocnumber">9.2.3</span> <span class="toctext">Disjoint Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Inverse_Object_Properties_2"><span class="tocnumber">9.2.4</span> <span class="toctext">Inverse Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Object_Property_Domain"><span class="tocnumber">9.2.5</span> <span class="toctext">Object Property Domain</span></a></li>
<li class="toclevel-3"><a href="#Object_Property_Range"><span class="tocnumber">9.2.6</span> <span class="toctext">Object Property Range</span></a></li>
<li class="toclevel-3"><a href="#Functional_Object_Properties"><span class="tocnumber">9.2.7</span> <span class="toctext">Functional Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Inverse-Functional_Object_Properties"><span class="tocnumber">9.2.8</span> <span class="toctext">Inverse-Functional Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Reflexive_Object_Properties"><span class="tocnumber">9.2.9</span> <span class="toctext">Reflexive Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Irreflexive_Object_Properties"><span class="tocnumber">9.2.10</span> <span class="toctext">Irreflexive Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Symmetric_Object_Properties"><span class="tocnumber">9.2.11</span> <span class="toctext">Symmetric Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Asymmetric_Object_Properties"><span class="tocnumber">9.2.12</span> <span class="toctext">Asymmetric Object Properties</span></a></li>
<li class="toclevel-3"><a href="#Transitive_Object_Properties"><span class="tocnumber">9.2.13</span> <span class="toctext">Transitive Object Properties</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Data_Property_Axioms"><span class="tocnumber">9.3</span> <span class="toctext">Data Property Axioms</span></a>
<ul>
<li class="toclevel-3"><a href="#Data_Subproperties"><span class="tocnumber">9.3.1</span> <span class="toctext">Data Subproperties</span></a></li>
<li class="toclevel-3"><a href="#Equivalent_Data_Properties"><span class="tocnumber">9.3.2</span> <span class="toctext">Equivalent Data Properties</span></a></li>
<li class="toclevel-3"><a href="#Disjoint_Data_Properties"><span class="tocnumber">9.3.3</span> <span class="toctext">Disjoint Data Properties</span></a></li>
<li class="toclevel-3"><a href="#Data_Property_Domain"><span class="tocnumber">9.3.4</span> <span class="toctext">Data Property Domain</span></a></li>
<li class="toclevel-3"><a href="#Data_Property_Range"><span class="tocnumber">9.3.5</span> <span class="toctext">Data Property Range</span></a></li>
<li class="toclevel-3"><a href="#Functional_Data_Properties"><span class="tocnumber">9.3.6</span> <span class="toctext">Functional Data Properties</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Datatype_Definitions"><span class="tocnumber">9.4</span> <span class="toctext">Datatype Definitions</span></a></li>
<li class="toclevel-2"><a href="#Keys"><span class="tocnumber">9.5</span> <span class="toctext">Keys</span></a></li>
<li class="toclevel-2"><a href="#Assertions"><span class="tocnumber">9.6</span> <span class="toctext">Assertions</span></a>
<ul>
<li class="toclevel-3"><a href="#Individual_Equality"><span class="tocnumber">9.6.1</span> <span class="toctext">Individual Equality</span></a></li>
<li class="toclevel-3"><a href="#Individual_Inequality"><span class="tocnumber">9.6.2</span> <span class="toctext">Individual Inequality</span></a></li>
<li class="toclevel-3"><a href="#Class_Assertions"><span class="tocnumber">9.6.3</span> <span class="toctext">Class Assertions</span></a></li>
<li class="toclevel-3"><a href="#Positive_Object_Property_Assertions"><span class="tocnumber">9.6.4</span> <span class="toctext">Positive Object Property Assertions</span></a></li>
<li class="toclevel-3"><a href="#Negative_Object_Property_Assertions"><span class="tocnumber">9.6.5</span> <span class="toctext">Negative Object Property Assertions</span></a></li>
<li class="toclevel-3"><a href="#Positive_Data_Property_Assertions"><span class="tocnumber">9.6.6</span> <span class="toctext">Positive Data Property Assertions</span></a></li>
<li class="toclevel-3"><a href="#Negative_Data_Property_Assertions"><span class="tocnumber">9.6.7</span> <span class="toctext">Negative Data Property Assertions</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Annotations"><span class="tocnumber">10</span> <span class="toctext">Annotations</span></a>
<ul>
<li class="toclevel-2"><a href="#Annotations_of_Ontologies.2C_Axioms.2C_and_other_Annotations"><span class="tocnumber">10.1</span> <span class="toctext">Annotations of Ontologies, Axioms, and other Annotations</span></a></li>
<li class="toclevel-2"><a href="#Annotation_Axioms"><span class="tocnumber">10.2</span> <span class="toctext">Annotation Axioms</span></a>
<ul>
<li class="toclevel-3"><a href="#Annotation_Assertion"><span class="tocnumber">10.2.1</span> <span class="toctext">Annotation Assertion</span></a></li>
<li class="toclevel-3"><a href="#Annotation_Subproperties"><span class="tocnumber">10.2.2</span> <span class="toctext">Annotation Subproperties</span></a></li>
<li class="toclevel-3"><a href="#Annotation_Property_Domain"><span class="tocnumber">10.2.3</span> <span class="toctext">Annotation Property Domain</span></a></li>
<li class="toclevel-3"><a href="#Annotation_Property_Range"><span class="tocnumber">10.2.4</span> <span class="toctext">Annotation Property Range</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Global_Restrictions_on_Axioms_in_OWL_2_DL"><span class="tocnumber">11</span> <span class="toctext">Global Restrictions on Axioms in OWL 2 DL</span></a>
<ul>
<li class="toclevel-2"><a href="#Property_Hierarchy_and_Simple_Object_Property_Expressions"><span class="tocnumber">11.1</span> <span class="toctext">Property Hierarchy and Simple Object Property Expressions</span></a></li>
<li class="toclevel-2"><a href="#The_Restrictions_on_the_Axiom_Closure"><span class="tocnumber">11.2</span> <span class="toctext">The Restrictions on the Axiom Closure</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Internet_Media_Type.2C_File_Extension.2C_and_Macintosh_File_Type"><span class="tocnumber">12</span> <span class="toctext">Appendix: Internet Media Type, File Extension, and Macintosh File Type</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Complete_Grammar_.28Normative.29"><span class="tocnumber">13</span> <span class="toctext">Appendix: Complete Grammar (Normative)</span></a>
<ul>
<li class="toclevel-2"><a href="#General_Definitions"><span class="tocnumber">13.1</span> <span class="toctext">General Definitions</span></a></li>
<li class="toclevel-2"><a href="#Definitions_of_OWL_2_Constructs"><span class="tocnumber">13.2</span> <span class="toctext">Definitions of OWL 2 Constructs</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">14</span> <span class="toctext">Appendix: Change Log (Informative)</span></a>
<ul>
<li class="toclevel-2"><a href="#Changes_Since_Recommendation"><span class="tocnumber">14.1</span> <span class="toctext">Changes Since Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Proposed_Recommendation"><span class="tocnumber">14.2</span> <span class="toctext">Changes Since Proposed Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Candidate_Recommendation"><span class="tocnumber">14.3</span> <span class="toctext">Changes Since Candidate Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Last_Call"><span class="tocnumber">14.4</span> <span class="toctext">Changes Since Last Call</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgments"><span class="tocnumber">15</span> <span class="toctext">Acknowledgments</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">16</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">16.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Nonnormative_References"><span class="tocnumber">16.2</span> <span class="toctext">Nonnormative References</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<p>
</p>
<div class="buttonpanel">
<form action=""><p>
<input id="show-sd" onclick="set_display_by_class('div','image','none'); set_display_by_id('hide-sd',''); set_display_by_id('show-sd','none');" type="button" value="Hide Diagrams" />
<input id="hide-sd" onclick="set_display_by_class('div','image',''); set_display_by_id('hide-sd','none'); set_display_by_id('show-sd','');" style="display: none" type="button" value="Show Diagrams" />
<input id="hide-bnf" onclick="set_display_by_class('div','grammar','none'); set_display_by_id('hide-bnf','none');  set_display_by_id('show-bnf','');" type="button" value="Hide Grammar" />
<input id="show-bnf" onclick="set_display_by_class('div','grammar',''); set_display_by_id('hide-bnf','');  set_display_by_id('show-bnf','none');" style="display: none" type="button" value="Show Grammar" />
<input id="hide-examples" onclick="set_display_by_class('div','anexample','none'); set_display_by_id('hide-examples','none'); set_display_by_id('show-examples','');" type="button" value="Hide Examples" />
<input id="show-examples" onclick="set_display_by_class('div','anexample',''); set_display_by_id('hide-examples',''); set_display_by_id('show-examples','none');" style="display: none" type="button" value="Show Examples" />
<input id="hide-fss" onclick="show_syntaxes(false,bRDFVisible); set_display_by_id('hide-fss','none'); set_display_by_id('show-fss','');" type="button" value="Hide FSS in Examples" />
<input id="show-fss" onclick="show_syntaxes(true,bRDFVisible); set_display_by_id('hide-fss',''); set_display_by_id('show-fss','none');" style="display: none" type="button" value="Show FSS in Examples" />
<input id="hide-rdf" onclick="show_syntaxes(bFSSVisible,false); set_display_by_id('hide-rdf','none'); set_display_by_id('show-rdf','');" style="display: none" type="button" value="Hide RDF in Examples" />
<input id="show-rdf" onclick="show_syntaxes(bFSSVisible,true); set_display_by_id('hide-rdf',''); set_display_by_id('show-rdf','none');" type="button" value="Show RDF in Examples" />
</p>
</form>
</div>
<p>

</p>
<a id="Introduction" name="Introduction"></a><h2> <span class="mw-headline">1  Introduction </span></h2>
<p>This document defines the OWL 2 language. The core part of this specification &mdash; called the <i>structural specification</i> &mdash; is independent of the concrete exchange syntaxes for OWL 2 ontologies. The structural specification describes the conceptual structure of OWL 2 ontologies and thus provides a normative abstract representation for all (normative and nonnormative) syntaxes of OWL 2. This allows for a clear separation of the essential features of the language from issues related to any particular syntax. Furthermore, such a structural specification of OWL 2 provides the foundation for the implementation of OWL 2 tools such as APIs and reasoners. Each OWL 2 ontology represented as an instance of this conceptual structure can be converted into an RDF graph [<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>]; conversely, most OWL 2 ontologies represented as RDF graphs can be converted into the conceptual structure defined in this document [<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>].
</p><p>This document also defines the <i>functional-style syntax</i>, which closely follows the structural specification and allows OWL 2 ontologies to be written in a compact form. This syntax is used in the definitions of the semantics of OWL 2 ontologies, the mappings from and into the RDF/XML exchange syntax, and the different profiles of OWL 2. Concrete syntaxes, such as the functional-style syntax, often provide features not found in the structural specification, such as a mechanism for abbreviating IRIs.
</p><p>Finally, this document defines OWL 2 DL &mdash; the subset of OWL 2 with favorable computational properties. Each RDF graph obtained by applying the RDF mapping to an OWL 2 DL ontology can be converted back into the conceptual structure defined in this document by means of the reverse RDF mapping [<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>].
</p><p>An OWL 2 ontology is a formal description of a domain of interest. OWL 2 ontologies consist of the following three different syntactic categories:
</p>
<ul><li> <i>Entities</i>, such as classes, properties, and individuals, are identified by IRIs. They form the primitive <i>terms</i> of an ontology and constitute the basic elements of an ontology. For example, a class <i>a:Person</i> can be used to represent the set of all people. Similarly, the object property <i>a:parentOf</i> can be used to represent the parent-child relationship. Finally, the individual <i>a:Peter</i> can be used to represent a particular person called <span class="name">"Peter"</span>.
</li><li> <i>Expressions</i> represent complex notions in the domain being described. For example, a <i>class expression</i> describes a set of individuals in terms of the restrictions on the individuals' characteristics.
</li><li> <i>Axioms</i> are statements that are asserted to be true in the domain being described. For example, using a <i>subclass axiom</i>, one can state that the class <i>a:Student</i> is a subclass of the class <i>a:Person</i>.
</li></ul>
<p>These three syntactic categories are used to express the <i>logical</i> part of OWL 2 ontologies &mdash; that is, they are interpreted under a precisely defined semantics that allows useful inferences to be drawn. For example, if an individual <i>a:Peter</i> is an instance of the class <i>a:Student</i>, and <i>a:Student</i> is a subclass of <i>a:Person</i>, then from the OWL 2 semantics one can derive that <i>a:Peter</i> is also an instance of <i>a:Person</i>.
</p><p>In addition, entities, axioms, and ontologies can be <i>annotated</i> in OWL 2. For example, a class can be given a human-readable label that provides a more descriptive name for the class. Annotations have no effect on the logical aspects of an ontology &mdash; that is, for the purposes of the OWL 2 semantics, annotations are treated as not being present. Instead, the use of annotations is left to the applications that use OWL 2. For example, a graphical user interface might choose to visualize a class using one of its labels.
</p><p>Finally, OWL 2 provides basic support for ontology modularization. In particular, an OWL 2 ontology <i>O</i> can import another OWL 2 ontology <i>O'</i> and thus gain access to all entities, expressions, and axioms in <i>O'</i>.
</p><p>This document defines the structural specification of OWL 2, the functional syntax for OWL 2, the behavior of datatype maps, and OWL 2 DL. Only the parts of the document related to these three purposes are normative. The examples in this document are informative and any part of the document that is specifically identified as informative is not normative. Further, the informal descriptions of the semantics of OWL 2 constructs in this document are informative; the Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] and the RDF-Based [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>] are precisely specified in separate documents.
</p><p>The italicized keywords <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em>, <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em>, <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em>, <em class="RFC2119" title="SHOULD NOT in RFC 2119 context">SHOULD NOT</em>, and <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> are used to specify normative features of OWL 2 documents and tools, and are interpreted as specified in RFC 2119 [<cite><a href="#ref-rfc-2119" title="">RFC 2119</a></cite>].
</p>
<a id="Preliminary_Definitions" name="Preliminary_Definitions"></a><h2> <span class="mw-headline">2  Preliminary Definitions </span></h2>
<p>This section presents certain preliminary definitions that are used in the rest of this document.
</p>
<a id="Structural_Specification" name="Structural_Specification"></a><h3> <span class="mw-headline">2.1  Structural Specification </span></h3>
<p>The structural specification of OWL 2 consists of all the figures in this document and the notion of structural equivalence given below. It is used throughout this document to precisely specify the structure of OWL 2 ontologies and the observable behavior of OWL 2 tools. An OWL 2 tool <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> base its APIs and/or internal storage model on the structural specification; however, it <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> also choose a completely different approach as long as its observable behavior conforms to the one specified in this document.
</p><p>The structural specification is defined using the Unified Modeling Language (UML) [<cite><a href="#ref-uml" title="">UML</a></cite>], and the notation used is compatible with the Meta-Object Facility (MOF) [<cite><a href="#ref-mof" title="">MOF</a></cite>]. This document uses only a very simple form of UML class diagrams that are expected to be easily understandable by readers familiar with the basic concepts of object-oriented systems. The following list summarizes the UML notation used in this document.
</p>
<ul><li> The names of the UML classes from the structural specification are written in bold font.
</li><li> The names of abstract UML classes (i.e., UML classes that are not intended to be instantiated) are written in bold and italic font.
</li><li> Instances of the UML classes of the structural specification are connected by associations, many of which are of the one-to-many type. Associations whose name is preceded by <span class="name">/</span> are <i>derived</i> &mdash; that is, their value is determined based on the value of other associations and attributes. Whether the objects participating in associations are ordered and whether repetitions are allowed is made clear by the following standard UML conventions:
<ul><li> By default, all associations are sets; that is, the objects in them are unordered and repetitions are disallowed.
</li><li> The <span class="name">{ ordered,nonunique }</span> attribute is placed next to the association ends that are ordered and in which repetitions are allowed. Such associations have the semantics of lists.
</li></ul>
</li></ul>
<p>The narrative in this document often refers to various parts of the structural specification. These references are mainly intended to be informal, but they can often be interpreted as statements about the instances of the UML classes from the structural specification. When precision is required, such statements are captured using the functional-style syntax, which is defined in <a href="#Functional-Style_Syntax" title="">Section 3.7</a> and other relevant parts of this document. In order to avoid confusion, the term "UML class" is used to refer to elements of the structural specification of OWL 2, whereas the term "class" is used to refer to OWL 2 classes (see <a href="#Classes" title="">Section 5.1</a>).
</p>
<div class="anexample">
<p>The sentence "The individual <span class="name">I</span> is an instance of the class <span class="name">C</span>" can be understood as a statement that <span class="name">I</span> is an instance of the UML class <span class="nonterminal">Individual</span>, <span class="name">C</span> is an instance of the UML class <span class="nonterminal">Class</span>, and there is an instance of the UML class <span class="nonterminal">ClassAssertion</span> that connects <span class="name">I</span> with <span class="name">C</span>. This statement can be captured precisely using the structural specification as <span class="name">ClassAssertion( C I )</span>.
</p>
</div>
<p>Objects <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> from the structural specification are <i>structurally equivalent</i> if the following conditions hold:
</p>
<ul><li> If <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> are atomic values, such as strings or integers, they are structurally equivalent if they are equal according to the notion of equality of the respective UML type.
</li><li> If <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> are unordered associations without repetitions, they are structurally equivalent if each element of <i>o<sub>1</sub></i> is structurally equivalent to some element of <i>o<sub>2</sub></i> and vice versa.
</li><li> If <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> are ordered associations with repetitions, they are structurally equivalent if they contain the same number of elements and each element of <i>o<sub>1</sub></i> is structurally equivalent to the element of <i>o<sub>2</sub></i> with the same index.
</li><li> If <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> are instances of UML classes from the structural specification, they are structurally equivalent if
<ul><li> both <i>o<sub>1</sub></i> and <i>o<sub>2</sub></i> are instances of the same UML class, and
</li><li> each association of <i>o<sub>1</sub></i> is structurally equivalent to the corresponding association of <i>o<sub>2</sub></i> and vice versa.
</li></ul>
</li></ul>
<p>The notion of structural equivalence is used throughout this specification to define various conditions on the structure of OWL 2 ontologies. Note that this is a syntactic, rather than a semantic notion &mdash; that is, it compares structures, rather than their meaning under a formal semantics.
</p>
<div class="anexample">
<p>The class expression
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Person</i> <i>a:Animal</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Person</i> <i>a:Animal</i> ) .
</td></tr>
</tbody></table>
<p>is structurally equivalent to the class expression
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Animal</i> <i>a:Person</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Animal</i> <i>a:Person</i> ) .
</td></tr>
</tbody></table>
<p>because the order of the elements in an unordered association is not important. In contrast, the class expression
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Person</i> ObjectComplementOf( <i>a:Person</i> ) )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Person</i> _:y ) .<br /> _:y <i>rdf:type</i> <i>owl:Class</i> .<br /> _:y <i>owl:complementOf</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
<p>is not structurally equivalent to <i>owl:Thing</i> even though the two expressions are semantically equivalent.
</p>
</div>
<p>Sets written in one of the exchange syntaxes (e.g., XML or RDF/XML) are not necessarily expected to be duplicate free. Duplicates <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be eliminated when ontology documents written in such syntaxes are converted into instances of the UML classes of the structural specification.
</p>
<div class="anexample">
<p>An ontology written in functional-style syntax can contain the following class expression:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Person</i> <i>a:Animal</i> <i>a:Animal</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Person</i> <i>a:Animal</i> <i>a:Animal</i> ) .
</td></tr>
</tbody></table>
<p>During parsing, this expression should be "flattened" to the following expression:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Person</i> <i>a:Animal</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Person</i> <i>a:Animal</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="BNF_Notation" name="BNF_Notation"></a><h3> <span class="mw-headline">2.2  BNF Notation </span></h3>
<p>Grammars in this document are written using the BNF notation, summarized in Table 1.
</p>
<div class="center">
<table border="1">
<caption> <span class="caption">Table 1.</span> The BNF Notation
</caption><tbody><tr>
<th> Construct
</th><th> Syntax
</th><th> Example
</th></tr>
<tr>
<td> terminal symbols
</td><td> enclosed in single quotes
</td><td> <span class="name">'PropertyRange'</span>
</td></tr>
<tr>
<td> a set of terminal symbols described in English
</td><td> italic
</td><td> <span class="name"><i>a finite sequence of characters<br /> matching the PNAME_LN production of [SPARQL]</i></span>
</td></tr>
<tr>
<td> nonterminal symbols
</td><td> boldface
</td><td> <span class="nonterminal">ClassExpression</span>
</td></tr>
<tr>
<td> zero or more
</td><td> curly braces
</td><td> <span class="name">{ </span><span class="nonterminal">ClassExpression</span><span class="name"> }</span>
</td></tr>
<tr>
<td> zero or one
</td><td> square brackets
</td><td> <span class="name">[ </span><span class="nonterminal">ClassExpression</span><span class="name"> ]</span>
</td></tr>
<tr>
<td> alternative
</td><td> vertical bar
</td><td> <span class="nonterminal">Assertion</span><span class="name"> | </span><span class="nonterminal">Declaration</span>
</td></tr></tbody></table>
</div>
<p>The grammar presented in this document uses the following two "special" terminal symbols, which affect the process of transforming an input sequence of characters into a sequence of regular (i.e., not "special") terminal symbols:
</p>
<ul><li> <i>whitespace</i> is a nonempty sequence of space (U+20), horizontal tab (U+9), line feed (U+A), or carriage return (U+D) characters, and
</li><li> a <i>comment</i> is a sequence of characters that starts with the <span class="name">#</span> (U+23) character and does not contain the line feed (U+A) or carriage return (U+D) characters.
</li></ul>
<p>The following characters are called <i>delimiters</i>:
</p>
<ul><li> <span class="name">=</span> (U+3D)
</li><li> <span class="name">(</span> (U+28)
</li><li> <span class="name">)</span> (U+29)
</li><li> <span class="name">&lt;</span> (U+3C)
</li><li> <span class="name">&gt;</span> (U+3E)
</li><li> <span class="name">@</span> (U+40)
</li><li> <span class="name">^</span> (U+5E) 
</li></ul>
<p>Given an input sequence of characters, an OWL 2 implementation <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> exhibit the same observable behavior as if it applied the BNF grammar rules to the sequence of terminal symbols obtained from the input as follows.
</p>
<ol><li> For each terminal symbol (including <i>whitespace</i> and <i>comment</i>) mentioned in this document, a regular expression is created that can recognize the symbol's characters.
</li><li> A pointer <span class="name">p</span> is initialized to point to the beginning of input.
</li><li> All regular expressions are matched to the characters in the input starting from <span class="name">p</span>. Matches are greedy &mdash; that is, if several regular expressions match a portion of the input, a regular expression with the longest match wins. The regular expressions corresponding to terminal symbols in this document ensure that there are no ties (i.e., it is not possible for two regular expressions to match a portion of the input of the same length); thus, at most one regular expression can be matched.
</li><li> If there is no match, the input <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be rejected. Otherwise, if the matched regular expression does not correspond to the <i>whitespace</i> or <i>comment</i> terminal symbols, the corresponding terminal symbol is emitted to the output. (In other words, the matches of <i>whitespace</i> and <i>comment</i> are ignored.)
</li><li> Pointer <span class="name">p</span> is moved to the first character after the match.
</li><li> If the terminal symbol matched in step 3 does not end with a delimiter character and <span class="name">p</span> points to a character that is not a delimiter, then the regular expressions for <i>whitespace</i> and <i>comment</i> are matched to the characters in the input starting from <span class="name">p</span>. If there is no match, the input <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be rejected; otherwise, <span class="name">p</span> is moved to the first character after the match (and thus the match is discarded).
</li><li> If <span class="name">p</span> does not point past the end of input, the process is repeated from step 3.
</li></ol>
<div class="anexample">
<p>Character sequence
</p>
<div class="fss">
<p>" #comment\" " #comment "abc"
</p>
</div>
<p>should be processed as follows. The first match is for the regular expression for the quoted string terminal symbol, producing a string containing a space, characters <span class="name">#comment"</span>, and another space. Next, the regular expression for <i>whitespace</i> is matched to a single space, and the match is discarded. Finally, the <i>comment</i> regular expression is matched to characters <span class="name">#comment "abc"</span>, and the match is discarded as well.
</p><p>In similar vein, character sequence
</p>
<div class="fss">
<p>&lt;#comment&gt;
</p>
</div>
<p>should be recognized as a full IRI with value <span class="name">#comment</span> (i.e., the occurrence of character <span class="name">#</span> in this example must not be understood as a start of a comment).
</p>
</div>
<div class="anexample">
<p>All regular expressions are matched in step 3 greedily, so character sequence
</p>
<div class="fss">
<p>SubClassOf:ABC
</p>
</div>
<p>is parsed as abbreviated IRI with value <span class="name">SubClassOf:ABC</span>. Furthermore, character sequence
</p>
<div class="fss">
<p>pref: ABC
</p>
</div>
<p>should be rejected: characters <span class="name">pref:</span> are matched as a prefix name, but then <span class="name">ABC</span> cannot be matched by any regular expression corresponding to a terminal symbol.
</p>
</div>
<div class="anexample">
<p>Character sequence
</p>
<div class="fss">
<p>10abc
</p>
</div>
<p>should be rejected: characters <span class="name">10</span> are matched by the regular expression for nonnegative integers; however, since the match does not end with a delimiter and <span class="name">a</span> is not a delimiter either, the match in step 6 fails.
</p>
</div>
<div class="anexample">
<p>Character sequences
</p>
<div class="fss">
<p>"10" ^^ xsd:integer<br />
"10"^^xsd:integer
</p>
</div>
<p>are both valid should be parsed as a quoted string, terminal symbol <span class="name">^^</span>, and an abbreviated IRI. In particular, note that the whitespace surrounding <span class="name">^^</span> in the first line is acceptable. In similar vein, character sequences
</p>
<div class="fss">
<p>"abc" @en<br />
"abc"@en
</p>
</div>
<p>are both valid and should be parsed as a quoted string and a language tag <span class="name">en</span>. In contrast, character sequence
</p>
<div class="fss">
<p>"abc"@ en
</p>
</div>
<p>should be rejected: characters <span class="name">@ en</span> do not match the regular expression for language tags.
</p>
</div>
<a id="Integers.2C_Characters.2C_Strings.2C_Language_Tags.2C_and_Node_IDs" name="Integers.2C_Characters.2C_Strings.2C_Language_Tags.2C_and_Node_IDs"></a><h3> <span class="mw-headline">2.3  Integers, Characters, Strings, Language Tags, and Node IDs </span></h3>
<p>Nonnegative integers are defined as usual.
</p>
<div class="grammar">
<p><span class="nonterminal">nonNegativeInteger</span>&nbsp;:= <i>a nonempty finite sequence of digits between 0 and 9</i>
</p>
</div>
<p>Characters and strings are defined in the same way as in [<cite><a href="#ref-rdf-plain-literal" title="">RDF:PLAINLITERAL</a></cite>]. A <i>character</i> is an atomic unit of communication. The structure of characters is not further specified in this document, other than to note that each character has a Universal Character Set (UCS) code point [<cite><a href="#ref-iso-iec-10646" title="">ISO/IEC 10646</a></cite>] (or, equivalently, a Unicode code point [<cite><a href="#ref-unicode" title="">UNICODE</a></cite>]). Each character <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> match the <a class="external text" href="http://www.w3.org/TR/xml11/#NT-Char" rel="nofollow" title="http://www.w3.org/TR/xml11/#NT-Char">Char</a> production from XML [<cite><a href="#ref-xml" title="">XML</a></cite>]. Code points are written as U+ followed by the hexadecimal value of the code point. A <i>string</i> is a finite sequence of characters, and the <i>length</i> of a string is the number of characters in it. Two strings are identical if and only if they contain exactly the same characters in exactly the same sequence. Strings are written by enclosing them in double quotes (U+22) and using a subset of the N-triples escaping mechanism [<cite><a href="#ref-rdf-testcases" title="">RDF Test Cases</a></cite>] to encode strings containing quotes. Note that the definition below allows a string to span several lines of a document.
</p>
<div class="grammar">
<p><span class="nonterminal">quotedString</span>&nbsp;:= <i>a finite sequence of characters in which " (U+22) and \ (U+5C) occur only in pairs of the form \" (U+5C, U+22) and \\ (U+5C, U+5C), enclosed in a pair of " (U+22) characters</i>
</p>
</div>
<p>Language tags are used to identify the language in which a string has been written. They are defined in the same way as in [<cite><a href="#ref-rdf-plain-literal" title="">RDF:PLAINLITERAL</a></cite>], which follows [<cite><a href="#ref-bcp-47" title="">BCP 47</a></cite>]. Language tags are written by prepending them with the <span class="name">@</span> (U+40) character.
</p>
<div class="grammar">
<p><span class="nonterminal">languageTag</span>&nbsp;:= <i>@ (U+40) followed a nonempty sequence of characters matching the langtag production from [<cite><a href="#ref-bcp-47" title="">BCP 47</a></cite>]</i>
</p>
</div>
<p>Node IDs are used to identify anonymous individuals (aka <i>blank nodes</i> in RDF [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>]).
</p>
<div class="grammar">
<p><span class="nonterminal">nodeID</span>&nbsp;:= <i>a finite sequence of characters matching the BLANK_NODE_LABEL production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]</i>
</p>
</div>
<a id="IRIs" name="IRIs"></a><h3> <span class="mw-headline">2.4  IRIs </span></h3>
<p>Ontologies and their elements are identified using Internationalized Resource Identifiers (IRIs) [<cite><a href="#ref-rfc-3987" title="">RFC3987</a></cite>]; thus, OWL 2 extends OWL 1, which uses Uniform Resource Identifiers (URIs). Each IRI <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be absolute (i.e., not relative). In the structural specification, IRIs are represented by the <span class="nonterminal">IRI</span> UML class. Two IRIs are structurally equivalent if and only if their string representations are identical.
</p><p>IRIs can be written as full IRIs by enclosing them in a pair of &lt; (U+3C) and &gt; (U+3E) characters. These characters are not part of the IRI, but are used for quotation purposes to identify an IRI as a full IRI.
</p><p>Alternatively, IRIs can be abbreviated as in SPARQL [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]. To this end, one can <i>declare</i> a <i>prefix name</i> <i>pn:</i> &mdash; that is, a possibly empty string followed by the <span class="name">:</span> (U+3A) character &mdash; by associating it with a <i>prefix IRI</i> <i>PI</i>; then, an IRI <i>I</i> whose string representation consists of <i>PI</i> followed by the remaining characters <i>rc</i> can be abbreviated as <i>pn:rc</i>. By a slight abuse of terminology, a prefix name is often used to refer to the prefix IRI that is associated with the prefix name, and phrases such as "an IRI whose string representation starts with the prefix IRI associated with the prefix name <i>pn:</i>" are typically shortened to less verbose phrases such as "an IRI with prefix <i>pn:</i>".
</p><p>If a concrete syntax uses this IRI abbreviation mechanism, it <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> provide a suitable mechanism for declaring prefix names. Furthermore, abbreviated IRIs are not represented in the structural specification of OWL 2, and OWL 2 implementations <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> exhibit the same observable behavior as if all abbreviated IRIs were expanded into full IRIs during parsing. Concrete syntaxes such as the RDF/XML Syntax [<cite><a href="#ref-rdf-syntax" title="">RDF Syntax</a></cite>] allow IRIs to be abbreviated in relation to the IRI of the document they are contained in. If used, such mechanisms are independent from the above described abbreviation mechanism. The abbreviated IRIs have the syntactic form of qualified names from the XML Namespaces specification [<cite><a href="#ref-xml-namespaces" title="">XML Namespaces</a></cite>]; therefore, it is common to refer to <i>PI</i> as a <i>namespace</i> and <i>rc</i> as a <i>local name</i>. This abbreviation mechanism, however, is independent from XML namespaces and can be understood as a simple macro mechanism that expands prefix names with the associated IRIs.
</p>
<div class="grammar">
<p><span class="nonterminal">fullIRI</span>&nbsp;:= <i>an IRI as defined in [<cite><a href="#ref-rfc-3987" title="">RFC3987</a></cite>], enclosed in a pair of &lt; (U+3C) and &gt; (U+3E) characters</i><br />
<span class="nonterminal">prefixName</span>&nbsp;:= <i>a finite sequence of characters matching the as PNAME_NS production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]</i><br />
<span class="nonterminal">abbreviatedIRI</span>&nbsp;:= <i>a finite sequence of characters matching the PNAME_LN production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]<br /></i>
<span class="nonterminal">IRI</span>&nbsp;:= <span class="nonterminal">fullIRI</span> | <span class="nonterminal">abbreviatedIRI</span>
</p>
</div>
<p>Table 2 declares the prefix names that are commonly used throughout this specification. 
</p>
<div class="center">
<table border="1">
<caption> <span class="caption">Table 2.</span> Declarations of the Standard Prefix Names
</caption><tbody><tr>
<th> Prefix name
</th><th> Prefix IRI
</th></tr>
<tr>
<td> <i>rdf:</i>
</td><td> <i>&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</i>
</td></tr>
<tr>
<td> <i>rdfs:</i>
</td><td> <i>&lt;http://www.w3.org/2000/01/rdf-schema#&gt;</i>
</td></tr>
<tr>
<td> <i>xsd:</i>
</td><td> <i>&lt;http://www.w3.org/2001/XMLSchema#&gt;</i>
</td></tr>
<tr>
<td> <i>owl:</i>
</td><td> <i>&lt;http://www.w3.org/2002/07/owl#&gt;</i>
</td></tr>
</tbody></table>
</div>
<p>IRIs with prefixes <i>rdf:</i>, <i>rdfs:</i>, <i>xsd:</i>, and <i>owl:</i> constitute the <i>reserved vocabulary</i> of OWL 2. As described in the following sections, the IRIs from the reserved vocabulary that are listed in Table 3 have special treatment in OWL 2.
</p>
<div class="center">
<table border="1">
<caption> <span class="caption">Table 3.</span> Reserved Vocabulary of OWL 2 with Special Treatment
</caption>
<tbody><tr>
<td> <i>owl:backwardCompatibleWith</i>
</td><td> <i>owl:bottomDataProperty</i>
</td><td> <i>owl:bottomObjectProperty</i>
</td><td> <i>owl:deprecated</i>
</td><td> <i>owl:incompatibleWith</i>
</td></tr>
<tr>
<td> <i>owl:Nothing</i>
</td><td> <i>owl:priorVersion</i>
</td><td> <i>owl:rational</i>
</td><td> <i>owl:real</i>
</td><td> <i>owl:versionInfo</i>
</td></tr>
<tr>
<td> <i>owl:Thing</i>
</td><td> <i>owl:topDataProperty</i>
</td><td> <i>owl:topObjectProperty</i>
</td><td> <i>rdf:langRange</i>
</td><td> <i>rdf:PlainLiteral</i>
</td></tr>
<tr>
<td> <i>rdf:XMLLiteral</i>
</td><td> <i>rdfs:comment</i>
</td><td> <i>rdfs:isDefinedBy</i>
</td><td> <i>rdfs:label</i>
</td><td> <i>rdfs:Literal</i>
</td></tr>
<tr>
<td> <i>rdfs:seeAlso</i>
</td><td> <i>xsd:anyURI</i>
</td><td> <i>xsd:base64Binary</i>
</td><td> <i>xsd:boolean</i>
</td><td> <i>xsd:byte</i>
</td></tr>
<tr>
<td> <i>xsd:dateTime</i>
</td><td> <i>xsd:dateTimeStamp</i>
</td><td> <i>xsd:decimal</i>
</td><td> <i>xsd:double</i>
</td><td> <i>xsd:float</i>
</td></tr>
<tr>
<td> <i>xsd:hexBinary</i>
</td><td> <i>xsd:int</i>
</td><td> <i>xsd:integer</i>
</td><td> <i>xsd:language</i>
</td><td> <i>xsd:length</i>
</td></tr>
<tr>
<td> <i>xsd:long</i>
</td><td> <i>xsd:maxExclusive</i>
</td><td> <i>xsd:maxInclusive</i>
</td><td> <i>xsd:maxLength</i>
</td><td> <i>xsd:minExclusive</i>
</td></tr>
<tr>
<td> <i>xsd:minInclusive</i>
</td><td> <i>xsd:minLength</i>
</td><td> <i>xsd:Name</i>
</td><td> <i>xsd:NCName</i>
</td><td> <i>xsd:negativeInteger</i>
</td></tr>
<tr>
<td> <i>xsd:NMTOKEN</i>
</td><td> <i>xsd:nonNegativeInteger</i>
</td><td> <i>xsd:nonPositiveInteger</i>
</td><td> <i>xsd:normalizedString</i>
</td><td> <i>xsd:pattern</i>
</td></tr>
<tr>
<td> <i>xsd:positiveInteger</i>
</td><td> <i>xsd:short</i>
</td><td> <i>xsd:string</i>
</td><td> <i>xsd:token</i>
</td><td> <i>xsd:unsignedByte</i>
</td></tr>
<tr>
<td> <i>xsd:unsignedInt</i>
</td><td> <i>xsd:unsignedLong</i>
</td><td> <i>xsd:unsignedShort</i>
</td><td>
</td><td>
</td></tr>
</tbody></table>
</div>
<a id="Ontologies" name="Ontologies"></a><h2> <span class="mw-headline">3  Ontologies </span></h2>
<p>An OWL 2 <span id="def_ontology"><i>ontology</i></span> is an instance <i>O</i> of the <span class="nonterminal">Ontology</span> UML class from the structural specification of OWL 2 shown in Figure 1 that satisfies certain conditions given below. The main component of an OWL 2 ontology is its set of axioms, the structure of which is described in more detail in <a href="#Axioms" title="">Section 9</a>. Because the association between an ontology and its axioms is a set, an ontology cannot contain two axioms that are structurally equivalent. Apart from axioms, ontologies can also contain ontology annotations (as described in more detail in <a href="#Ontology_Annotations" title="">Section 3.5</a>), and they can also import other ontologies (as described in <a href="#Imports" title="">Section 3.4</a>).
</p>
<div class="image">
<p><img alt="The Structure of OWL 2 Ontologies" border="0" height="274" src="Ontology.gif" width="617" /><br />
<span class="caption">Figure 1.</span> The Structure of OWL 2 Ontologies
</p>
</div>
<p>The following list summarizes all the conditions that <i>O</i> is required to satisfy to be an OWL 2 ontology.
</p>
<ul><li> <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions on the presence of the ontology IRI and version IRI from <a href="#Ontology_IRI_and_Version_IRI" title="">Section 3.1</a>.
</li><li> Each <span class="nonterminal">DataIntersectionOf</span> and <span class="nonterminal">DataUnionOf</span> in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions from <a href="#Intersection_of_Data_Ranges" title="">Section 7.1</a> and <a href="#Union_of_Data_Ranges" title="">Section 7.2</a>, respectively.
</li><li> Each <span class="nonterminal">DataSomeValuesFrom</span> and <span class="nonterminal">DataAllValuesFrom</span> class expression in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions from <a href="#Existential_Quantification_2" title="">Section 8.4.1</a> and <a href="#Universal_Quantification_2" title="">Section 8.4.2</a>, respectively.
</li><li> Each <span class="nonterminal">DataPropertyRange</span> axiom in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restriction from <a href="#Data_Property_Range" title="">Section 9.3.5</a>.
</li><li> Each <span class="nonterminal">DatatypeDefinition</span> axiom in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions from <a href="#Datatype_Definitions" title="">Section 9.4</a>.
</li><li> Each <span class="nonterminal">HasKey</span> axiom in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restriction from <a href="#Keys" title="">Section 9.5</a>.
</li><li> Each <i>O'</i> directly imported into <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy all of these restrictions as well.
</li></ul>
<p>The following list summarizes all the conditions that an OWL 2 ontology <i>O</i> is required to satisfy to be an OWL 2 DL ontology.
</p>
<ul><li> The ontology IRI and the version IRI (if present) of <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions on usage of the reserved vocabulary from <a href="#Ontology_IRI_and_Version_IRI" title="">Section 3.1</a>.
</li><li> Each datatype and each literal in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restrictions from <a href="#Datatypes" title="">Section 5.2</a> and <a href="#Literals" title="">Section 5.7</a>, respectively.
</li><li> Each entity in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> have an IRI satisfying the restrictions on the usage of the reserved vocabulary from Sections <a href="#Classes" title="">5.1</a>&ndash;<a href="#Individuals" title="">5.6</a>.
</li><li> <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the typing constraints from <a href="#Typing_Constraints_of_OWL_2_DL" title="">Section 5.8.1</a>.
</li><li> Each <span class="nonterminal">DatatypeRestriction</span> in <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the restriction on the usage of constraining facets from <a href="#Datatype_Restrictions" title="">Section 7.5</a>, respectively.
</li><li> <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the global restriction from <a href="#Global_Restrictions_on_Axioms_in_OWL_2_DL" title="">Section 11</a>.
</li><li> Each <i>O'</i> directly imported into <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy all of these restrictions as well.
</li></ul>
<p>An instance <i>O</i> of the <span class="nonterminal">Ontology</span> UML class <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> have consistent declarations as specified in <a href="#Declaration_Consistency" title="">Section 5.8.2</a>; however, this is not strictly necessary to make <i>O</i> an OWL 2 ontology. 
</p>
<a id="Ontology_IRI_and_Version_IRI" name="Ontology_IRI_and_Version_IRI"></a><h3> <span class="mw-headline">3.1  Ontology IRI and Version IRI </span></h3>
<p>Each ontology <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> have an <span id="def_ontology_iri"><i>ontology IRI</i></span>, which is used to identify an ontology. If an ontology has an ontology IRI, the ontology <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> additionally have a <span id="def_version_iri"><i>version IRI</i></span>, which is used to identify the version of the ontology. The version IRI <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> be, but need not be, equal to the ontology IRI. An ontology without an ontology IRI <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> contain a version IRI.
</p><p>IRIs from the reserved vocabulary <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used as an ontology IRI or a version IRI of an OWL 2 DL ontology.
</p><p>The following list provides conventions for choosing ontology IRIs and version IRIs in OWL 2 ontologies. This specification provides no mechanism for enforcing these constraints across the entire Web; however, OWL 2 tools <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> use them to detect problems in ontologies they process.
</p>
<ul><li> If an ontology has an ontology IRI but no version IRI, then a different ontology with the same ontology IRI but no version IRI <em class="RFC2119" title="SHOULD NOT in RFC 2119 context">SHOULD NOT</em> exist.
</li><li> If an ontology has both an ontology IRI and a version IRI, then a different ontology with the same ontology IRI and the same version IRI <em class="RFC2119" title="SHOULD NOT in RFC 2119 context">SHOULD NOT</em> exist.
</li><li> All other combinations of the ontology IRI and version IRI are not required to be unique. Thus, two different ontologies <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> have no ontology IRI and no version IRI; similarly, an ontology containing only an ontology IRI <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> coexist with another ontology with the same ontology IRI and some other version IRI.
</li></ul>
<p>The ontology IRI and the version IRI together identify a particular version from an <span id="def_ontology_series"><i>ontology series</i></span> &mdash; the set of all the versions of a particular ontology identified using a common ontology IRI. In each ontology series, exactly one ontology version is regarded as the <i>current</i> one. Structurally, a version of a particular ontology is an instance of the <span class="nonterminal">Ontology</span> UML class from the structural specification. Ontology series are not represented explicitly in the structural specification of OWL 2: they exist only as a side effect of the naming conventions described in this and the following sections.
</p>
<a id="Ontology_Documents" name="Ontology_Documents"></a><h3> <span class="mw-headline">3.2  Ontology Documents </span></h3>
<p>An OWL 2 ontology is an abstract notion defined in terms of the structural specification. Each ontology is associated with an <span id="def_ontology_document"><i>ontology document</i></span>, which physically contains the ontology stored in a particular way. The name "ontology document" reflects the expectation that a large number of ontologies will be stored in physical text documents written in one of the syntaxes of OWL 2. OWL 2 tools, however, are free to devise other types of ontology documents &mdash; that is, to introduce other ways of physically storing ontologies.
</p><p>Ontology documents are not represented in the structural specification of OWL 2, and the specification of OWL 2 makes only the following two assumptions about their nature:
</p>
<ul><li> Each ontology document can be accessed via an IRI by means of an appropriate protocol.
</li><li> Each ontology document can be converted in some well-defined way into an ontology (i.e., into an instance of the <span class="nonterminal">Ontology</span> UML class from the structural specification).
</li></ul>
<div class="anexample">
<p>An OWL 2 tool might publish an ontology as a text document written in the functional-style syntax (see <a href="#Functional-Style_Syntax" title="">Section 3.7</a>) and accessible via the IRI <i>&lt;http://www.example.com/ontology&gt;</i>. An OWL 2 tool could also devise a scheme for storing OWL 2 ontologies in a relational database. In such a case, each subset of the database representing the information about one ontology corresponds to one ontology document. To provide a mechanism for accessing these ontology documents, the OWL 2 tool should identify different database subsets with distinct IRIs.
</p>
</div>
<p>The ontology document of an ontology <i>O</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible via the IRIs determined by the following rules:
</p>
<ul><li> If <i>O</i> does not contain an ontology IRI (and, consequently, it does not contain a version IRI either), then the ontology document of <i>O</i> <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> be accessible via any IRI.
</li><li> If <i>O</i> contains an ontology IRI <i>OI</i> but no version IRI, then the ontology document of <i>O</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible via the IRI <i>OI</i>.
</li><li> If <i>O</i> contains an ontology IRI <i>OI</i> and a version IRI <i>VI</i>, then the ontology document of <i>O</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible via the IRI <i>VI</i>; furthermore, if <i>O</i> is the current version of the ontology series with the IRI <i>OI</i>, then the ontology document of <i>O</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> also be accessible via the IRI <i>OI</i>.
</li></ul>
<p>Thus, the document containing the current version of an ontology series with some IRI <i>OI</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible via <i>OI</i>. To access a particular version of <i>OI</i>, one needs to know that version's version IRI <i>VI</i>; the ontology document of the version <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> then be accessible via <i>VI</i>.
</p>
<div class="anexample">
<p>An ontology document of an ontology that contains an ontology IRI <i>&lt;http://www.example.com/my&gt;</i> but no version IRI should be accessible via the IRI <i>&lt;http://www.example.com/my&gt;</i>. In contrast, an ontology document of an ontology that contains an ontology IRI <i>&lt;http://www.example.com/my&gt;</i> and a version IRI <i>&lt;http://www.example.com/my/2.0&gt;</i> should be accessible via the IRI <i>&lt;http://www.example.com/my/2.0&gt;</i>. In both cases, the ontology document should be accessible via the respective IRIs using the HTTP protocol.
</p>
</div>
<p>OWL 2 tools will often need to implement functionality such as caching or off-line processing, where ontology documents may be stored at addresses different from the ones dictated by their ontology IRIs and version IRIs. OWL 2 tools <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> implement a <i>redirection</i> mechanism: when a tool is used to access an ontology document at IRI <i>I</i>, the tool <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> redirect <i>I</i> to a different IRI <i>DI</i> and access the ontology document via <i>DI</i> instead. The result of accessing the ontology document via <i>DI</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be the same as if the ontology were accessed via <i>I</i>. Furthermore, once the ontology document is converted into an ontology, the ontology <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> satisfy the three conditions from the beginning of this section in the same way as if it the ontology document were accessed via <i>I</i>. No particular redirection mechanism is specified &mdash; this is assumed to be implementation dependent.
</p>
<div class="anexample">
<p>To enable off-line processing, an ontology document that &mdash; according to the above rules &mdash; should be accessible via <i>&lt;http://www.example.com/my&gt;</i> might be stored in a file accessible via <i>&lt;file:///usr/local/ontologies/example.owl&gt;</i>. To access this ontology document, an OWL 2 tool might redirect the IRI <i>&lt;http://www.example.com/my&gt;</i> and actually access the ontology document via <i>&lt;file:///usr/local/ontologies/example.owl&gt;</i>. The ontology obtained after accessing the ontology document should satisfy the usual accessibility constraints: if the ontology contains only the ontology IRI, then the ontology IRI should be equal to <i>&lt;http://www.example.com/my&gt;</i>, and if the ontology contains both the ontology IRI and the version IRI, then one of them should be equal to <i>&lt;http://www.example.com/my&gt;</i>.
</p>
</div>
<a id="Versioning_of_OWL_2_Ontologies" name="Versioning_of_OWL_2_Ontologies"></a><h3> <span class="mw-headline">3.3  Versioning of OWL 2 Ontologies </span></h3>
<p>The conventions from <a href="#Ontology_Documents" title="">Section 3.2</a> provide a simple mechanism for versioning OWL 2 ontologies. An ontology series is identified using an ontology IRI, and each version in the series is assigned a different version IRI. The ontology document of the ontology representing the current version of the series <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible via the ontology IRI and, if present, via its version IRI as well; the ontology documents of the previous versions <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be accessible solely via their respective version IRIs. When a new version <i>O</i> in the ontology series is created, the ontology document of <i>O</i> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> replace the one accessible via the ontology IRI (and it <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> also be accessible via its version IRI).
</p>
<div class="anexample">
<p>The ontology document containing the current version of an ontology series might be accessible via the IRI <i>&lt;http://www.example.com/my&gt;</i>, as well as via the version-specific IRI <i>&lt;http://www.example.com/my/2.0&gt;</i>. When a new version is created, the ontology document of the previous version should remain accessible via <i>&lt;http://www.example.com/my/2.0&gt;</i>; the ontology document of the new version, called, say, <i>&lt;http://www.example.com/my/3.0&gt;</i>, should be made accessible via both <i>&lt;http://www.example.com/my&gt;</i> and <i>&lt;http://www.example.com/my/3.0&gt;</i>.
</p>
</div>
<a id="Imports" name="Imports"></a><h3> <span class="mw-headline">3.4  Imports </span></h3>
<p>An OWL 2 ontology can import other ontologies in order to gain access to their entities, expressions, and axioms, thus providing the basic facility for ontology modularization.
</p>
<div class="anexample">
<p>Assume that one wants to describe research projects about diseases. Managing information about the projects and the diseases in the same ontology might be cumbersome. Therefore, one might create a separate ontology <i>O</i> about diseases and a separate ontology <i>O'</i> about projects. The ontology <i>O'</i> would import <i>O</i> in order to gain access to the classes representing diseases; this allows one to use the diseases from <i>O</i> when writing the axioms of <i>O'</i>.
</p>
</div>
<p>From a physical point of view, an ontology contains a set of IRIs, shown in Figure 1 as the <span class="nonterminal">directlyImportsDocuments</span> association; these IRIs identify the ontology documents of the directly imported ontologies as specified in <a href="#Ontology_Documents" title="">Section 3.2</a>. The logical <i>directly imports</i> relation between ontologies, shown in Figure 1 as the <span class="nonterminal">directlyImports</span> association, is obtained by accessing the directly imported ontology documents and converting them into OWL 2 ontologies. The logical <i>imports</i> relation between ontologies, shown in Figure 1 as the <span class="nonterminal">imports</span> association, is the transitive closure of directly imports. In Figure 1, associations <span class="nonterminal">directlyImports</span> and <span class="nonterminal">imports</span> are shown as derived associations, since their values are derived from the value of the <span class="nonterminal">directlyImportsDocuments</span> association. Ontology documents usually store the <span class="nonterminal">directlyImportsDocuments</span> association. In contrast, the <span class="nonterminal">directlyImports</span> and <span class="nonterminal">imports</span> associations are typically not stored in ontology documents, but are determined during parsing as specified in <a href="#Canonical_Parsing_of_OWL_2_Ontologies" title="">Section 3.6</a>.
</p>
<div class="anexample">
<p>The following ontology document contains an ontology that directly imports an ontology contained in the ontology document accessible via the IRI <i>&lt;http://www.example.com/my/2.0&gt;</i>.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> Ontology( <i>&lt;http://www.example.com/importing-ontology&gt;</i><br /> &nbsp;&nbsp;&nbsp; Import( <i>&lt;http://www.example.com/my/2.0&gt;</i> )<br /> <br /> ...<br /> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>&lt;http://www.example.com/importing-ontology&gt;</i> <i>rdf:type</i> <i>owl:Ontology</i> .<br /> <i>&lt;http://www.example.com/importing-ontology&gt;</i> <i>owl:imports</i> <i>&lt;http://www.example.com/my/2.0&gt;</i> .<br /> ...
</td></tr>
</tbody></table>
<p>The IRIs identifying the ontology documents of the directly imported ontologies can be redirected as described in <a href="#Ontology_Documents" title="">Section 3.2</a>. For example, in order to access the above mentioned ontology document from a local cache, the IRI <i>&lt;http://www.example.com/my/2.0&gt;</i> might be redirected to <i>&lt;file:///usr/local/ontologies/imported.v20.owl&gt;</i>. Note that this can be done without changing the ontology document of the importing ontology.
</p>
</div>
<p>The <span id="def_import_closure"><i>import closure</i></span> of an ontology <i>O</i> is a set containing <i>O</i> and all the ontologies that <i>O</i> imports. The import closure of <i>O</i> <em class="RFC2119" title="SHOULD NOT in RFC 2119 context">SHOULD NOT</em> contain ontologies <i>O<sub>1</sub></i> and <i>O<sub>2</sub></i> such that
</p>
<ul><li> <i>O<sub>1</sub></i> and <i>O<sub>2</sub></i> are different ontology versions from the same ontology series, or
</li><li> <i>O<sub>1</sub></i> contains an ontology annotation <i>owl:incompatibleWith</i> with the value equal to either the ontology IRI or the version IRI of <i>O<sub>2</sub></i>.
</li></ul>
<p>The <span id="def_axiom_closure"><i>axiom closure</i></span> of an ontology <i>O</i> is the smallest set that contains all the axioms from each ontology <i>O'</i> in the import closure of <i>O</i> with all anonymous individuals <i>standardized apart</i> &mdash; that is, the anonymous individuals from different ontologies in the import closure of <i>O</i> are treated as being different; see <a href="#Anonymous_Individuals" title="">Section 5.6.2</a> for further details.
</p>
<a id="Ontology_Annotations" name="Ontology_Annotations"></a><h3> <span class="mw-headline">3.5  Ontology Annotations </span></h3>
<p>An OWL 2 ontology contains a set of annotations. These can be used to associate information with an ontology &mdash; for example the ontology creator's name. As discussed in more detail in <a href="#Annotations" title="">Section 10</a>, each annotation consists of an annotation property and an annotation value, and the latter can be a literal, an IRI, or an anonymous individual.
</p>
<div class="grammar">
<p><span class="nonterminal">ontologyAnnotations</span>&nbsp;:= { <span class="nonterminal">Annotation</span> }
</p>
</div>
<p>OWL 2 provides several built-in annotation properties for ontology annotations. The usage of these annotation properties on entities other than ontologies is discouraged.
</p>
<ul><li> The <span id="a_priorVersion"><i>owl:priorVersion</i></span> annotation property specifies the IRI of a prior version of the containing ontology.
</li><li> The <span id="a_backwardCompatibleWith"><i>owl:backwardCompatibleWith</i></span> annotation property specifies the IRI of a prior version of the containing ontology that is compatible with the current version of the containing ontology.
</li><li> The <span id="a_incompatibleWith"><i>owl:incompatibleWith</i></span> annotation property specifies the IRI of a prior version of the containing ontology that is incompatible with the current version of the containing ontology.
</li></ul>
<a id="Canonical_Parsing_of_OWL_2_Ontologies" name="Canonical_Parsing_of_OWL_2_Ontologies"></a><h3> <span class="mw-headline">3.6  Canonical Parsing of OWL 2 Ontologies </span></h3>
<p>Many OWL 2 tools need to support <span id="def_ontology_parsing"><i>ontology parsing</i></span> &mdash; the process of converting an ontology document written in a particular syntax into an OWL 2 ontology. Depending on the syntax used, the ontology parser may need to know which IRIs are used in the ontology as entities of which type. This typing information is extracted from declarations &mdash; axioms that associate IRIs with entity types. Please refer to <a href="#Entity_Declarations_and_Typing" title="">Section 5.8</a> for more information about declarations.
</p>
<div class="anexample">
<p>An ontology parser for the ontology documents written in the RDF syntax might encounter the following triples:
</p>
<div class="rdf">
<p><i>a:Father</i> <i>rdfs:subClassOf</i> _:x .<br />
_:x <i>owl:someValuesFrom</i> <i>a:Child</i> .<br />
_:x <i>owl:onProperty</i> <i>a:parentOf</i>.<br />
</p>
</div>
<p>From this axiom alone, it is not clear whether <i>a:parentOf</i> is an object or a data property, and whether <i>a:Child</i> is a class or a datatype. In order to disambiguate the types of these IRIs, the parser needs to look at the declarations in the ontology document being parsed, as well as those in the directly or indirectly imported ontology documents.
</p>
</div>
<p>In OWL 2 there is no requirement for a declaration of an entity to physically precede the entity's usage in ontology documents; furthermore, declarations for entities can be placed in imported ontology documents and imports are allowed to be cyclic. In order to precisely define the result of ontology parsing, this specification defines the notion of <i>canonical parsing</i>. An OWL 2 parser <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> implement parsing in any way it chooses, as long as it produces a result that is structurally equivalent to the result of canonical parsing.
</p><p>An OWL 2 ontology corresponding to an ontology document <i>D<sub>GI</sub></i> accessible via a given IRI <i>GI</i> can be obtained using the following <span id="def_canonical_parsing"><i>canonical parsing</i></span> process. All steps of this process <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be successfully completed.
</p>
<table class="canonicalparsing">

<tbody><tr>
<td> <b>CP&nbsp;1</b>
</td><td class="one"> Make <i>AllDoc</i> and <i>Processed</i> equal to the empty set, and make <i>ToProcess</i> equal to the set containing only the IRI <i>GI</i>.
</td></tr>
<tr>
<td> <b>CP&nbsp;2</b>
</td><td class="one"> While <i>ToProcess</i> is not empty, remove an arbitrary IRI <i>I</i> from it and, if <i>I</i> is not contained in <i>Processed</i>, perform the following steps:
</td></tr>
<tr>
<td> <b>CP&nbsp;2.1</b>
</td><td class="two"> Retrieve the ontology document <i>D<sub>I</sub></i> from <i>I</i> as specified in <a href="#Ontology_Documents" title="">Section 3.2</a>.
</td></tr>
<tr>
<td> <b>CP&nbsp;2.2</b>
</td><td class="two"> Using the rules of the relevant syntax, analyze <i>D<sub>I</sub></i> and compute the set <i>Decl(D<sub>I</sub>)</i> of declarations explicitly present in <i>D<sub>I</sub></i> and the set <i>Imp(D<sub>I</sub>)</i> of IRIs of ontology documents directly imported in <i>D<sub>I</sub></i>.
</td></tr>
<tr>
<td> <b>CP&nbsp;2.3</b>
</td><td class="two"> Add <i>D<sub>I</sub></i> to <i>AllDoc</i>, add <i>I</i> to <i>Processed</i>, and add each IRI from <i>Imp(D<sub>I</sub>)</i> to <i>ToProcess</i>.
</td></tr>
<tr>
<td> <b>CP&nbsp;3</b>
</td><td class="one"> For each ontology document <i>D</i> in <i>AllDoc</i>, perform the following steps:
</td></tr>
<tr>
<td> <b>CP&nbsp;3.1</b>
</td><td class="two"> Compute the set <i>AllDecl(D)</i> as the union of the set <i>Decl(D)</i>, the sets <i>Decl(D')</i> for each ontology document <i>D'</i> that is (directly or indirectly) imported into <i>D</i>, and the set of all declarations listed in Table 5. For an OWL 2 DL ontology, the set <i>AllDecl(D)</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the typing constraints from <a href="#Typing_Constraints_of_OWL_2_DL" title="">Section 5.8.1</a>.
</td></tr>
<tr>
<td> <b>CP&nbsp;3.2</b>
</td><td class="two"> Create an instance <i>O<sub>D</sub></i> of the <span class="nonterminal">Ontology</span> UML class from the structural specification.
</td></tr>
<tr>
<td> <b>CP&nbsp;3.3</b>
</td><td class="two"> Using the rules of the relevant syntax, analyze <i>D</i> and populate <i>O<sub>D</sub></i> by instantiating appropriate classes from the structural specification. Use the declarations in <i>AllDecl(D)</i> to disambiguate IRIs if needed; it <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be possible to disambiguate all IRIs.
</td></tr>
<tr>
<td> <b>CP&nbsp;4</b>
</td><td class="one"> For each pair of ontology documents <i>DS</i> and <i>DT</i> in <i>AllDoc</i> such that the latter is directly imported into the former, add <i>O<sub>DT</sub></i> to the <span class="nonterminal">directlyImports</span> association of <i>O<sub>DS</sub></i>.
</td></tr>
<tr>
<td> <b>CP&nbsp;5</b>
</td><td class="one"> For each ontology document <i>D</i> in <i>AllDoc</i>, set the <span class="nonterminal">imports</span> association of <i>O<sub>D</sub></i> to the transitive closure of the <span class="nonterminal">directlyImports</span> association of <i>O<sub>D</sub></i>.
</td></tr>
<tr>
<td> <b>CP&nbsp;6</b>
</td><td class="one"> For each ontology document <i>D</i> in <i>AllDoc</i>, ensure that <i>O<sub>D</sub></i> is an OWL 2 ontology &mdash; that is, <i>O<sub>D</sub></i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy all the restrictions listed in <a href="#Ontologies" title="">Section 3</a>.
</td></tr>
</tbody></table>
<p>It is important to understand that canonical parsing merely defines the result of the parsing process, and that an implementation of OWL 2 <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> optimize this process in numerous ways. In order to enable efficient parsing, OWL 2 implementations are encouraged to write ontologies into documents by placing all IRI declarations before the axioms that use these IRIs; however, this is not required for conformance.
</p>
<a id="Functional-Style_Syntax" name="Functional-Style_Syntax"></a><h3> <span class="mw-headline">3.7  Functional-Style Syntax </span></h3>
<p>A <span id="def_functional-style_syntax_ontology_document"><i>functional-style syntax ontology document</i></span> is a sequence of Unicode characters [<cite><a href="#ref-unicode" title="">UNICODE</a></cite>] accessible via some IRI by means of the standard protocols such that its text matches the <span class="nonterminal">ontologyDocument</span> production of the grammar defined in this specification document, and it can be converted into an ontology by means of the canonical parsing process described in <a href="#Canonical_Parsing_of_OWL_2_Ontologies" title="">Section 3.6</a> and other parts of this specification document. A functional-style syntax ontology document <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> use the UTF-8 encoding [<cite><a href="#ref-rfc-3629" title="">RFC 3629</a></cite>].
</p>
<div class="grammar">
<p><span class="nonterminal">ontologyDocument</span>&nbsp;:=  { <span class="nonterminal">prefixDeclaration</span> } <span class="nonterminal">Ontology</span><br />
<span class="nonterminal">prefixDeclaration</span>&nbsp;:= 'Prefix' '(' <span class="nonterminal">prefixName</span> '=' <span class="nonterminal">fullIRI</span> ')'<br />
<span class="nonterminal">Ontology</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; 'Ontology' '(' [ <span class="nonterminal">ontologyIRI</span> [ <span class="nonterminal">versionIRI</span> ] ]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">directlyImportsDocuments</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">ontologyAnnotations</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">axioms</span><br />
&nbsp;&nbsp;&nbsp; ')'<br />
<span class="nonterminal">ontologyIRI</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">versionIRI</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">directlyImportsDocuments</span>&nbsp;:= { 'Import' '(' <span class="nonterminal">IRI</span> ')' }<br />
<span class="nonterminal">axioms</span>&nbsp;:= { <span class="nonterminal">Axiom</span> }
</p>
</div>
<p>Each part of the ontology document matching the <span class="nonterminal" id="a_prefix">prefixDeclaration</span> production declares a prefix name and associates it with a prefix IRI. An ontology document <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> contain at most one such declaration per prefix name, and it <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> declare a prefix name listed in Table 2. Prefix declarations are used during parsing to expand abbreviated IRIs in the ontology document &mdash; that is, parts of the ontology document matching the <span class="nonterminal">abbreviatedIRI</span> production &mdash; into full IRIs. This is done as follows:
</p>
<ul><li> The abbreviated IRI is split into a prefix name <i>pn:</i> &mdash; the part up to and including the <span class="name">:</span> (U+3A) character &mdash; and the remaining part <i>rp</i> following the <span class="name">:</span> (U+3A) character.
</li><li> If <i>pn:</i> is not one of the standard prefix names listed in Table 2, then the prefix declarations of the ontology document being parsed <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> contain a declaration for <i>pn:</i> associating it with a prefix IRI <i>PI</i>.
</li><li> The resulting full IRI is obtained by concatenating the string representation of <i>PI</i> with <i>rp</i>. The resulting IRI <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be a valid IRI.
</li></ul>
<div class="anexample">
<p>The following is a functional-style syntax ontology document containing an ontology with the ontology IRI <i>&lt;http://www.example.com/ontology1&gt;</i>. The IRI <i>&lt;http://www.example.com/ontology1#&gt;</i> is associated with the prefix name <i>:</i> (that is, the prefix name consisting only of a colon character); this prefix is often called "empty" or "default". This ontology imports an ontology whose ontology document should be accessed via <i>&lt;http://www.example.com/ontology2&gt;</i>, and it contains an ontology annotation providing a label for the ontology and a single subclass axiom. The abbreviated IRI <i>:Child</i> is expanded into the full IRI <i>&lt;http://www.example.com/ontology1#Child&gt;</i> during parsing. The prefix name <i>owl:</i> occurs in Table 2 and therefore does not need to be explicitly declared in the ontology document.
</p>
<div class="fss">
<p>Prefix(:=<i>&lt;http://www.example.com/ontology1#&gt;</i>)<br />
Ontology( <i>&lt;http://www.example.com/ontology1&gt;</i><br />
&nbsp;&nbsp;&nbsp; Import( <i>&lt;http://www.example.com/ontology2&gt;</i> )<br />
&nbsp;&nbsp;&nbsp; Annotation( <i>rdfs:label</i> "An example" )<br />
<br />
&nbsp;&nbsp;&nbsp; SubClassOf( <i>:Child</i> <i>owl:Thing</i> )<br />
)
</p>
</div>
</div>
<a id="Datatype_Maps" name="Datatype_Maps"></a><h2> <span class="mw-headline">4  Datatype Maps </span></h2>
<p>OWL 2 ontologies can refer to data values such as strings or integers. Each kind of such values is called a <span id="def_datatype"><i>datatype</i></span>. Datatypes can be used in OWL 2 ontologies as described in <a href="#Datatypes" title="">Section 5.2</a>. Each datatype is identified by an IRI and is defined by the following components:
</p>
<ul><li> The <span id="def_value_space"><i>value space</i></span> is the set of values of the datatype. Elements of the value space are called <i>data values</i>.
</li><li> The <span id="def_lexical_space"><i>lexical space</i></span> is a set of strings that can be used to refer to data values. Each member of the lexical space is called a <i>lexical form</i>, and it is mapped to a particular data value.
</li><li> The <span id="def_facet_space"><i>facet space</i></span> is a set of pairs of the form ( <i>F</i> , <i>v</i> ) where <i>F</i> is an IRI called a <i>constraining facet</i>, and <i>v</i> is an arbitrary data value called the <i>constraining value</i>. Each such pair is mapped to a subset of the value space of the datatype.
</li></ul>
<p>A set of datatypes supported by a reasoner is called a <span id="def_datatype_map"><i>datatype map</i></span>. This is not a syntactic construct &mdash; that is, it is not used directly to construct OWL 2 ontologies in a way that, say, classes and datatypes are. Because of that, a datatype map is not represented in the structural specification of OWL 2.
</p><p>The rest of this section defines a particular datatype map called the <span id="def_OWL_2_datatype_map"><i>OWL 2 datatype map</i></span>, which lists the datatypes that can be used in OWL 2 ontologies. Most datatypes are taken from the set of XML Schema Datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], the RDF specification [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>], or the specification for plain literals [<cite><a href="#ref-rdf-plain-literal" title="">RDF:PLAINLITERAL</a></cite>]. The normative definitions of these datatypes are provided by the respective specifications, and this document merely provides guidance on how to interpret these definitions properly in the context of OWL 2. For all these datatypes, this section lists the <i>normative constraining facets</i> that OWL 2 implementations <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> support. This section also contains the complete normative definitions of the datatypes <i>owl:real</i> and <i>owl:rational</i>, as these datatypes have not been taken from other specifications.
</p>
<a id="Real_Numbers.2C_Decimal_Numbers.2C_and_Integers" name="Real_Numbers.2C_Decimal_Numbers.2C_and_Integers"></a><h3> <span class="mw-headline">4.1  Real Numbers, Decimal Numbers, and Integers </span></h3>
<p><span id="a_NumericDataTypes"> </span>
</p><p>The OWL 2 datatype map provides the following datatypes for the representation of real numbers, decimal numbers, and integers:
</p>
<ul><li> <i>owl:real</i>
</li><li> <i>owl:rational</i>
</li><li> <i>xsd:decimal</i>
</li><li> <i>xsd:integer</i>
</li><li> <i>xsd:nonNegativeInteger</i>
</li><li> <i>xsd:nonPositiveInteger</i>
</li><li> <i>xsd:positiveInteger</i>
</li><li> <i>xsd:negativeInteger</i>
</li><li> <i>xsd:long</i>
</li><li> <i>xsd:int</i>
</li><li> <i>xsd:short</i>
</li><li> <i>xsd:byte</i>
</li><li> <i>xsd:unsignedLong</i>
</li><li> <i>xsd:unsignedInt</i>
</li><li> <i>xsd:unsignedShort</i>
</li><li> <i>xsd:unsignedByte</i>
</li></ul>
<p>For each datatype from the above list that is identified by an IRI with the <i>xsd:</i> prefix, the definitions of the value space, the lexical space, and the facet space are provided by XML Schema [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>]; furthermore, the normative constraining facets for the datatype are <i>xsd:minInclusive</i>, <i>xsd:maxInclusive</i>, <i>xsd:minExclusive</i>, and <i>xsd:maxExclusive</i>. An OWL 2 implementation <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> support all lexical forms of these datatypes; however, it <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> support at least the lexical forms listed in Section 5.4 of XML Schema Datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], which can be mapped to the primitive values commonly found in modern implementation platforms.
</p><p>The datatypes <span id="a_real"><i>owl:real</i></span> and <span id="a_rational"><i>owl:rational</i></span> are defined as follows.
</p><p><b>Value Spaces.</b>
</p>
<ul><li> The value space of <i>owl:real</i> is the set of all real numbers.
</li><li> The value space of <i>owl:rational</i> is the set of all rational numbers. It is a subset of the value space of <i>owl:real</i>, and it contains the value space of <i>xsd:decimal</i> (and thus of all <i>xsd:</i> numeric datatypes listed above as well).
</li></ul>
<p><b>Lexical Spaces.</b>
</p>
<ul><li> The <i>owl:real</i> datatype does not directly provide any lexical forms.
</li><li> The <i>owl:rational</i> datatype supports lexical forms defined by the following grammar (whitespace within the grammar <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be ignored and <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be included in the lexical forms of <i>owl:rational</i>, and single quotes are used to introduce terminal symbols):<div class="indent" style="padding-top: 10px; padding-bottom: 10px"><span class="name">numerator '/' denominator</span></div> Here, <span class="name">numerator</span> is an integer with the syntax as specified for the <i>xsd:integer</i> datatype, and <span class="name">denominator</span> is a positive, nonzero integer with the syntax as specified for the <i>xsd:integer</i> datatype, not containing the plus sign. Each such lexical form of <i>owl:rational</i> is mapped to the rational number obtained by dividing the value of <span class="name">numerator</span> by the value of <span class="name">denominator</span>. An OWL 2 implementation <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> support all such lexical forms; however, it <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> support at least the lexical forms where the numerator and the denominator are in the value space of <i>xsd:long</i>.
</li></ul>
<p><b>Facet Spaces.</b> The facet spaces of <i>owl:real</i> and <i>owl:rational</i> are defined in Table 4.
</p>
<div class="center" id="a_RealFacets">
<table border="1" style="text-align: left">
<caption> <span class="caption">Table 4.</span> The Facet Spaces of <i>owl:real</i> and <i>owl:rational</i>
</caption>
<tbody><tr>
<th> Each pair of the form...
</th><th> ...is mapped to...
</th></tr>
<tr>
<td> ( <i>xsd:minInclusive</i> , <i>v</i> )<br /> where <i>v</i> is from the value space of <i>owl:real</i>
</td><td> the set of all numbers <i>x</i> from the value space of <i>DT</i> such that <i>x</i> = <i>v</i> or <i>x</i> &gt; <i>v</i>
</td></tr>
<tr>
<td> ( <i>xsd:maxInclusive</i> , <i>v</i> )<br /> where <i>v</i> is from the value space of <i>owl:real</i>
</td><td> the set of all numbers <i>x</i> from the value space of <i>DT</i> such that <i>x</i> = <i>v</i> or <i>x</i> &lt; <i>v</i>
</td></tr>
<tr>
<td> ( <i>xsd:minExclusive</i> , <i>v</i> )<br /> where <i>v</i> is from the value space of <i>owl:real</i>
</td><td> the set of all numbers <i>x</i> from the value space of <i>DT</i> such that <i>x</i> &gt; <i>v</i>
</td></tr>
<tr>
<td> ( <i>xsd:maxExclusive</i> , <i>v</i> )<br /> where <i>v</i> is from the value space of <i>owl:real</i>
</td><td> the set of all numbers <i>x</i> from the value space of <i>DT</i> such that <i>x</i> &lt; <i>v</i>
</td></tr>
<tr>
<td colspan="2"> <b>Note.</b> <i>DT</i> is either <i>owl:real</i> or <i>owl:rational</i>.
</td></tr>
</tbody></table>
</div>
<a id="Floating-Point_Numbers" name="Floating-Point_Numbers"></a><h3> <span class="mw-headline">4.2  Floating-Point Numbers </span></h3>
<p>The OWL 2 datatype map supports the following datatypes for the representation of floating-point numbers:
</p>
<ul><li> <i>xsd:double</i>
</li><li> <i>xsd:float</i>
</li></ul>
<p>As specified in XML Schema [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], the value spaces of <i>xsd:double</i>, <i>xsd:float</i>, and <i>xsd:decimal</i> are pairwise disjoint. In accordance with this principle, the value space of <i>owl:real</i> is defined as being disjoint with the value spaces of <i>xsd:double</i> and <i>xsd:float</i> as well. The normative constraining facets for these datatypes are <i>xsd:minInclusive</i>, <i>xsd:maxInclusive</i>, <i>xsd:minExclusive</i>, and <i>xsd:maxExclusive</i>.
</p>
<div class="anexample">
<p>Although floating-point values are numbers, they are not contained in the value space of <i>owl:real</i>. Thus, the value spaces of <i>xsd:double</i> and <i>xsd:float</i> can be understood as containing "fresh copies" of the appropriate subsets of the value space of <i>owl:real</i>. To understand how this impacts the consequences of OWL 2 ontologies, consider the following example.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyRange( <i>a:hasAge</i> <i>xsd:integer</i> )
  </td><td> The range of the <i>a:hasAge</i> property is <i>xsd:integer</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:double</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasAge</i> <i>rdfs:range</i> <i>xsd:integer</i> .
  </td><td> The range of the <i>a:hasAge</i> property is <i>xsd:integer</i>.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:double</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<p>The first axiom states that all values of the <i>a:hasAge</i> property must be in the value space of <i>xsd:integer</i>, but the second axiom provides a value for <i>a:hasAge</i> that is equal to the floating-point number 17. Since floating-point numbers are not contained in the value space of <i>xsd:integer</i>, the mentioned ontology is inconsistent.
</p>
</div>
<div class="anexample">
<p>According to XML Schema, the value spaces of <i>xsd:double</i> and <i>xsd:float</i> contain positive and negative zeros. These two objects are equal, but not identical. To understand this distinction, consider the following example ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:numberOfChildren</i> <i>a:Meg</i> "+0"^^<i>xsd:float</i> )
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>+0</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:numberOfChildren</i> <i>a:Meg</i> "-0"^^<i>xsd:float</i> )
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>-0</i>.
</td></tr>
<tr valign="top"><td> FunctionalDataProperty( <i>a:numberOfChildren</i> )
  </td><td> An individual can have at most one value for <i>a:numberOfChildren</i>.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>a:numberOfChildren</i> "+0"^^<i>xsd:float</i> .
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>+0</i>.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:numberOfChildren</i> "-0"^^<i>xsd:float</i> .
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>-0</i>.
</td></tr>
<tr valign="top"><td> <i>a:numberOfChildren</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> An individual can have at most one value for <i>a:numberOfChildren</i>.
</td></tr>
</tbody></table>
<p>The last axiom states that no individual should have more than one distinct value for <i>a:numberOfChildren</i>. Since positive and negative zero are not identical, the first two axioms violate the restriction of the last axiom, which makes the ontology inconsistent. In other words, equality of values from the value space of <i>xsd:double</i> and <i>xsd:float</i> has no effect on the semantics of cardinality restrictions of OWL 2; in fact, equality is used only in the definition of facets.
</p>
</div>
<div class="anexample">
<p>According to XML Schema, the semantics of facets is defined with respect to equality, and positive and negative zeros are equal. Therefore, the subset of the value space of <i>xsd:double</i> between <i>-1.0</i> and <i>1.0</i> contains both <i>+0</i> and <i>-0</i>.
</p>
</div>
<a id="Strings" name="Strings"></a><h3> <span class="mw-headline">4.3  Strings </span></h3>
<p>The OWL 2 datatype map provides the <i>rdf:PlainLiteral</i> datatype for the representation of strings in a particular language. The definitions of the value space, the lexical space, the facet space, and the necessary mappings are given in [<cite><a href="#ref-rdf-plain-literal" title="">RDF:PLAINLITERAL</a></cite>]. The normative constraining facets for <i>rdf:PlainLiteral</i> are <i>xsd:length</i>, <i>xsd:minLength</i>, <i>xsd:maxLength</i>, <i>xsd:pattern</i>, and <i>rdf:langRange</i>; furthermore, only <i>basic language ranges</i> [<cite><a href="#ref-bcp-47" title="">BCP 47</a></cite>] are supported in the <i>rdf:langRange</i> constraining facet.
</p><p>In addition, OWL 2 supports the following datatypes defined in XML Schema [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>]:
</p>
<ul><li> <i>xsd:string</i>
</li><li> <i>xsd:normalizedString</i>
</li><li> <i>xsd:token</i>
</li><li> <i>xsd:language</i>
</li><li> <i>xsd:Name</i>
</li><li> <i>xsd:NCName</i>
</li><li> <i>xsd:NMTOKEN</i>
</li></ul>
<p>As explained in [<cite><a href="#ref-rdf-plain-literal" title="">RDF:PLAINLITERAL</a></cite>], the value spaces of all of these datatypes are contained in the value space of <i>rdf:PlainLiteral</i>. Furthermore, for each datatype from the above list, the normative constraining facets are <i>xsd:length</i>, <i>xsd:minLength</i>, <i>xsd:maxLength</i>, and <i>xsd:pattern</i>.
</p>
<a id="Boolean_Values" name="Boolean_Values"></a><h3> <span class="mw-headline">4.4  Boolean Values </span></h3>
<p>The OWL 2 datatype map provides the <i>xsd:boolean</i> XML Schema datatype [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>] for the representation of Boolean values. No constraining facet is normative for this datatype.
</p>
<a id="Binary_Data" name="Binary_Data"></a><h3> <span class="mw-headline">4.5  Binary Data </span></h3>
<p>The OWL 2 datatype map provides the following XML Schema datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>] for the representation of binary data:
</p>
<ul><li> <i>xsd:hexBinary</i>
</li><li> <i>xsd:base64Binary</i> 
</li></ul>
<p>As specified in XML Schema [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], the value spaces of these two datatypes are disjoint. For each datatype from the above list, the normative constraining facets are <i>xsd:minLength</i>, <i>xsd:maxLength</i>, and <i>xsd:length</i>.
</p>
<div class="anexample">
<p>According to XML Schema, the value spaces of <i>xsd:hexBinary</i> and <i>xsd:base64Binary</i> are isomorphic copies of the set of all finite sequences of <i>octets</i> &mdash; integers between 0 and 255, inclusive. To understand the effect that the disjointness requirement has on the semantics of OWL 2, consider the following example ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyRange( <i>a:personID</i> <i>xsd:base64Binary</i> )
  </td><td> The range of the <i>a:personID</i> property is <i>xsd:base64Binary</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:personID</i> <i>a:Meg</i> "0203"^^<i>xsd:hexBinary</i> )
  </td><td> The ID of Meg is the octet sequence consisting of the octets 2 and 3.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:personID</i> <i>rdfs:range</i> <i>xsd:base64Binary</i> .
  </td><td> The range of the <i>a:personID</i> property is <i>xsd:base64Binary</i>.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:personID</i> "0203"^^<i>xsd:hexBinary</i> .
  </td><td> The ID of Meg is the octet sequence consisting of the octets 2 and 3.
</td></tr>
</tbody></table>
<p>The first axiom states that all values of the <i>a:personID</i> property must be in the value space of <i>xsd:base64Binary</i>, but the second axiom provides a value for <i>a:personID</i> that is in the value space of <i>xsd:hexBinary</i>. Since the value spaces of <i>xsd:hexBinary</i> and <i>xsd:base64Binary</i> are disjoint, the above ontology is inconsistent.
</p>
</div>
<a id="IRIs_2" name="IRIs_2"></a><h3> <span class="mw-headline">4.6  IRIs </span></h3>
<p>The OWL 2 datatype map provides the <i>xsd:anyURI</i> XML Schema datatype [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>] for the representation of IRIs. As specified in XML Schema [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], the value spaces of <i>xsd:anyURI</i> and <i>xsd:string</i> are disjoint. The normative constraining facets are <i>xsd:minLength</i>, <i>xsd:maxLength</i>, <i>xsd:length</i>, and <i>xsd:pattern</i>.
</p>
<div class="anexample">
<p>According to XML Schema, the value space of <i>xsd:anyURI</i> is the set of all IRIs. Although each IRI has a string representation, IRIs are not strings. The value space of <i>xsd:anyURI</i> can therefore be seen as an "isomorphic copy" of a subset of the value space of <i>xsd:string</i>.
</p>
</div>
<p>The lexical forms of <i>xsd:anyURI</i> include relative IRIs. If an OWL 2 syntax employs rules for the resolution of relative IRIs (e.g., the OWL 2 XML Syntax [<cite><a href="#ref-owl-2-xml-serialization" title="">OWL 2 XML Serialization</a></cite>] uses <i>xml:base</i> for that purpose), such rules do not apply to <i>xsd:anyURI</i> lexical forms that represent relative IRIs; that is, the lexical forms representing relative IRIs <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be parsed as they are.
</p>
<a id="Time_Instants" name="Time_Instants"></a><h3> <span class="mw-headline">4.7  Time Instants </span></h3>
<p>The OWL 2 datatype map provides the following XML Schema datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>] for the representation of time instants with and without time zone offsets:
</p>
<ul><li> <i>xsd:dateTime</i>
</li><li> <i>xsd:dateTimeStamp</i>
</li></ul>
<p>For each datatype from the above list, the normative constraining facets are <i>xsd:minInclusive</i>, <i>xsd:maxInclusive</i>, <i>xsd:minExclusive</i>, and <i>xsd:maxExclusive</i>. An OWL 2 implementation <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> support all lexical forms of these datatypes; however, it <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> support at least the lexical forms listed in Section 5.4 of XML Schema Datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>].
</p>
<div class="anexample">
<p>According to XML Schema, two <i>xsd:dateTime</i> values representing the same time instant but with different time zone offsets are equal, but not identical. The consequences of this definition are demonstrated by the following example ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalDataProperty( <i>a:birthDate</i> )
  </td><td> Each object can have at most one birth date.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:birthDate</i> <i>a:Peter</i><br /> &nbsp;&nbsp;&nbsp; "1956-06-25T04:00:00-05:00"^^<i>xsd:dateTime</i> )
  </td><td> Peter was born on June 25th, 1956, at 4am EST.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:birthDate</i> <i>a:Peter</i><br /> &nbsp;&nbsp;&nbsp; "1956-06-25T10:00:00+01:00"^^<i>xsd:dateTime</i> )
  </td><td> Peter was born on June 25th, 1956, at 10am CET.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:birthDate</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one birth date.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:birthDate</i> "1956-06-25T04:00:00-05:00"^^<i>xsd:dateTime</i> .
  </td><td> Peter was born on June 25th, 1956, at 4am EST.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:birthDate</i> "1956-06-25T10:00:00+01:00"^^<i>xsd:dateTime</i> .
  </td><td> Peter was born on June 25th, 1956, at 10am CET.
</td></tr>
</tbody></table>
<p>June 25th, 1956, 4am EST and June 25th, 1956, 10am CET denote the same time instants, but have different time zone offsets. Consequently, the two <i>xsd:dateTime</i> literals are mapped to two equal, but nonidentical data values. Consequently, <i>a:Peter</i> is connected by the property <i>a:birthDate</i> to two distinct data values, which violates the functionality requirement on <i>a:birthDate</i> and makes the ontology inconsistent.
</p>
</div>
<div class="anexample">
<p>The semantics of constraining facets on <i>xsd:dateTime</i> is defined with respect to equality and ordering on time instants. For example, the following datatype restriction contains all time instants that are larger than or equal to the time instant corresponding to the lexical form <span class="name">"1956-01-01T04:00:00-05:00"</span>.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DatatypeRestriction( <i>xsd:dateTime</i> <i>xsd:minInclusive</i> "1956-01-01T04:00:00-05:00"^^<i>xsd:dateTime</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:onDatatype</i> <i>xsd:dateTime</i> .<br /> _:x <i>owl:withRestrictions</i> ( _:y ) .<br /> _:y <i>xsd:minInclusive</i> "1956-01-01T04:00:00-05:00"^^<i>xsd:dateTime</i> .
</td></tr>
</tbody></table>
<p>According to XML Schema datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>], time instants are compared with respect to their <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value, which roughly corresponds to the number of seconds elapsed from the origin of the proleptic Gregorian calendar. Thus, the above data range contains the time instants corresponding to the lexical forms <span class="name">"1956-06-25T04:00:00-05:00"</span> and <span class="name">"1956-06-25T10:00:00+01:00"</span> despite the fact that the time zone offset of the latter does not match the one used in the datatype restriction.
</p><p>A time instant might not contain a time zone offset, in which case comparisons are slightly more involved. Let <i>T<sub>1</sub></i> and <i>T<sub>2</sub></i> be time instants with and without time zone offsets, respectively. Then, <i>T<sub>1</sub></i> is not equal to <i>T<sub>2</sub></i>, and comparisons are defined as follows:
</p>
<ul><li> <i>T<sub>1</sub></i> is smaller than <i>T<sub>2</sub></i> if the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>1</sub></i> is smaller than the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>2</sub><sup>low</sup></i>, where <i>T<sub>2</sub><sup>low</sup></i> is the time instant equal to <i>T<sub>2</sub></i> but with the time zone offset equal to <span class="name">"+14:00"</span>.
</li><li> <i>T<sub>1</sub></i> is greater than <i>T<sub>2</sub></i> if the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>1</sub></i> is greater than the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>2</sub><sup>high</sup></i>, where <i>T<sub>2</sub><sup>high</sup></i> is the time instant equal to <i>T<sub>2</sub></i> but with the time zone offset equal to <span class="name">"-14:00"</span>.
</li></ul>
<p>Thus, for <i>T<sub>1</sub></i> to be smaller than <i>T<sub>2</sub></i>, the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>1</sub></i> should be smaller than the <i><a class="external text" href="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/#vp-dt-timeOnTimeline">timeOnTimeline</a></i> value of <i>T<sub>2</sub></i> even if we substitute the largest positive time zone offset in <i>T<sub>2</sub></i>; the definition of "greater than" is analogous. Note that, for certain <i>T<sub>1</sub></i> and <i>T<sub>2</sub></i>, it is possible that neither condition holds, in which case <i>T<sub>1</sub></i> and <i>T<sub>2</sub></i> are incomparable.
</p><p>According to this definition, the datatype restriction mentioned earlier in this example contains the time instant corresponding to the lexical form <span class="name">"1956-01-01T10:00:00Z"</span>, but not the one corresponding to <span class="name">"1956-01-01T10:00:00"</span>; the latter is the case because the time instant corresponding to <span class="name">"1956-01-01T10:00:00+14:00"</span> is not greater than or equal to the one corresponding to <span class="name">"1956-01-01T04:00:00-05:00"</span>.
</p>
</div>
<a id="XML_Literals" name="XML_Literals"></a><h3> <span class="mw-headline">4.8  XML Literals </span></h3>
<p>The OWL 2 datatype map provides the <i>rdf:XMLLiteral</i> datatype for the representation of XML content in OWL 2 ontologies. The datatype is defined in Section 5.1 of the RDF specification [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>]. It has no normative constraining facets.
</p>
<a id="Entities.2C_Literals.2C_and_Anonymous_Individuals" name="Entities.2C_Literals.2C_and_Anonymous_Individuals"></a><h2> <span class="mw-headline">5  Entities, Literals, and Anonymous Individuals </span></h2>
<p>Entities are the fundamental building blocks of OWL 2 ontologies, and they define the vocabulary &mdash; the named terms &mdash; of an ontology. In logic, the set of entities is usually said to constitute the <i>signature</i> of an ontology. Apart from entities, OWL 2 ontologies typically also contain literals, such as strings or integers.
</p><p>The structure of entities and literals in OWL 2 is shown in Figure 2. Classes, datatypes, object properties, data properties, annotation properties, and named individuals are entities, and they are all uniquely identified by an IRI. Classes represent sets of individuals; datatypes are sets of literals such as strings or integers; object and data properties can be used to represent relationships in the domain; annotation properties can be used to associate nonlogical information with ontologies, axioms, and entities; and named individuals can be used to represent actual objects from the domain. Apart from named individuals, OWL 2 also provides for anonymous individuals &mdash; that is, individuals that are analogous to blank nodes in RDF [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>] and that are accessible only from within the ontology they are used in. Finally, OWL 2 provides for literals, which consist of a string called a <i>lexical form</i> and a datatype specifying how to interpret this string.
</p>
<div class="image">
<p><img alt="The Hierarchy of Entities in OWL 2" border="0" height="335" src="C_entities.gif" width="790" /><br />
<span class="caption">Figure 2.</span> Entities, Literals, and Anonymous Individuals in OWL 2
</p>
</div>
<a id="Classes" name="Classes"></a><h3> <span class="mw-headline">5.1  Classes </span></h3>
<p><span id="def_class"><i>Classes</i></span> can be understood as sets of individuals.
</p>
<div class="grammar">
<p><span class="nonterminal">Class</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<p>The classes with the IRIs <i>owl:Thing</i> and <i>owl:Nothing</i> are available in OWL 2 as built-in classes with a predefined semantics:
</p>
<ul><li> The class with IRI <span id="a_Thing"><i>owl:Thing</i></span> represents the set of all individuals. (In the DL literature this is often called the top concept.)
</li><li> The class with IRI <span id="a_Nothing"><i>owl:Nothing</i></span> represents the empty set. (In the DL literature this is often called the bottom concept.)
</li></ul>
<p>IRIs from the reserved vocabulary other than <i>owl:Thing</i> and <i>owl:Nothing</i> <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used to identify classes in an OWL 2 DL ontology.
</p>
<div class="anexample">
<p>Classes <i>a:Child</i> and <i>a:Person</i> can be used to represent the set of all children and persons, respectively, in the application domain, and they can be used in an axiom such as the following one:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubClassOf( <i>a:Child</i> <i>a:Person</i> )
  </td><td> Each child is a person.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Child</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
  </td><td> Each child is a person.
</td></tr>
</tbody></table>
</div>
<a id="Datatypes" name="Datatypes"></a><h3> <span class="mw-headline">5.2  Datatypes </span></h3>
<p><i>Datatypes</i> are entities that refer to sets of data values. Thus, datatypes are analogous to classes, the main difference being that the former contain data values such as strings and numbers, rather than individuals. Datatypes are a kind of data range, which allows them to be used in restrictions. As explained in <a href="#Data_Ranges" title="">Section 7</a>, each data range is associated with an arity; for datatypes, the arity is always one. The built-in datatype <i>rdfs:Literal</i> denotes any set of data values that contains the union of the value spaces of all datatypes.
</p><p>An IRI used to identify a datatype in an OWL 2 DL ontology <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em>
</p>
<ul><li> be <i>rdfs:Literal</i>, or
</li><li> identify a datatype in the OWL 2 datatype map (see <a href="#Datatype_Maps" title="">Section 4</a>), or
</li><li> not be in the reserved vocabulary of OWL 2 (see <a href="#IRIs" title="">Section 2.4</a>).
</li></ul>
<p>The conditions from the previous paragraph and the restrictions on datatypes in <a href="#The_Restrictions_on_the_Axiom_Closure" title="">Section 11.2</a> require each datatype in an OWL 2 DL ontology to be <i>rdfs:Literal</i>, one of the datatypes from <a href="#Datatype_Maps" title="">Section 4</a>, or a datatype defined by means of a datatype definition (see <a href="#Datatype_Definitions" title="">Section 9.4</a>).
</p>
<div class="grammar">
<p><span class="nonterminal">Datatype</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<div class="anexample">
<p>The datatype <i>xsd:integer</i> denotes the set of all integers. It can be used in axioms such as the following one:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyRange( <i>a:hasAge</i> <i>xsd:integer</i> )
  </td><td> The range of the <i>a:hasAge</i> data property is <i>xsd:integer</i>.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasAge</i> <i>rdfs:range</i> <i>xsd:integer</i> .
  </td><td> The range of the <i>a:hasAge</i> data property is <i>xsd:integer</i>.
</td></tr>
</tbody></table>
</div>
<a id="Object_Properties" name="Object_Properties"></a><h3> <span class="mw-headline">5.3  Object Properties </span></h3>
<p><span id="def_object_property"><i>Object properties</i></span> connect pairs of individuals.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectProperty</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<p>The object properties with the IRIs <i>owl:topObjectProperty</i> and <i>owl:bottomObjectProperty</i> are available in OWL 2 as built-in object properties with a predefined semantics:
</p>
<ul><li> The object property with IRI <span id="a_topObjectProperty"><i>owl:topObjectProperty</i></span> connects all possible pairs of individuals.
</li><li> The object property with IRI <span id="a_bottomObjectProperty"><i>owl:bottomObjectProperty</i></span> does not connect any pair of individuals.
</li></ul>
<p>IRIs from the reserved vocabulary other than <i>owl:topObjectProperty</i> and <i>owl:bottomObjectProperty</i> <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used to identify object properties in an OWL 2 DL ontology.
</p>
<div class="anexample">
<p>The object property <i>a:parentOf</i> can be used to represent the parenthood relationship between individuals. It can be used in axioms such as the following one:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:parentOf</i> <i>a:Peter</i> <i>a:Chris</i> )
  </td><td> Peter is a parent of Chris.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:parentOf</i> <i>a:Chris</i> .
  </td><td> Peter is a parent of Chris.
</td></tr>
</tbody></table>
</div>
<a id="Data_Properties" name="Data_Properties"></a><h3> <span class="mw-headline">5.4  Data Properties </span></h3>
<p><span id="def_data_property"><i>Data properties</i></span> connect individuals with literals. In some knowledge representation systems, functional data properties are called <i>attributes</i>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataProperty</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<p>The data properties with the IRIs <i>owl:topDataProperty</i> and <i>owl:bottomDataProperty</i> are available in OWL 2 as built-in data properties with a predefined semantics:
</p>
<ul><li> The data property with IRI <span id="a_topDataProperty"><i>owl:topDataProperty</i></span> connects all possible individuals with all literals.
</li><li> The data property with IRI <span id="a_bottomDataProperty"><i>owl:bottomDataProperty</i></span> does not connect any individual with a literal.
</li></ul>
<p>IRIs from the reserved vocabulary other than <i>owl:topDataProperty</i> and <i>owl:bottomDataProperty</i> <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used to identify data properties in an OWL 2 DL ontology.
</p>
<div class="anexample">
<p>The data property <i>a:hasName</i> can be used to associate a name with each person. It can be used in axioms such as the following one:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter Griffin" )
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter Griffin" .
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
</div>
<a id="Annotation_Properties" name="Annotation_Properties"></a><h3> <span class="mw-headline">5.5  Annotation Properties </span></h3>
<p><span id="def_annotation_property"><i>Annotation properties</i></span> can be used to provide an annotation for an ontology, axiom, or an IRI. The structure of annotations is further described in <a href="#Annotations" title="">Section 10</a>.
</p>
<div class="grammar">
<p><span class="nonterminal">AnnotationProperty</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<p>The annotation properties with the IRIs listed below are available in OWL 2 as built-in annotation properties with a predefined semantics:
</p>
<ul><li> The <span id="a_label"><i>rdfs:label</i></span> annotation property can be used to provide an IRI with a human-readable label.
</li><li> The <span id="a_comment"><i>rdfs:comment</i></span> annotation property can be used to provide an IRI with a human-readable comment.
</li><li> The <span id="a_seeAlso"><i>rdfs:seeAlso</i></span> annotation property can be used to provide an IRI with another IRI such that the latter provides additional information about the former.
</li><li> The <span id="a_isDefinedBy"><i>rdfs:isDefinedBy</i></span> annotation property can be used to provide an IRI with another IRI such that the latter provides information about the definition of the former; the way in which this information is provided is not described by this specification.
</li><li> An annotation with the <span id="a_deprecated"><i>owl:deprecated</i></span> annotation property and the value equal to <span class="name">"true"^^<i>xsd:boolean</i></span> can be used to specify that an IRI is deprecated.
</li><li> The <span id="a_versionInfo"><i>owl:versionInfo</i></span> annotation property can be used to provide an IRI with a string that describes the IRI's version.
</li><li> The <i>owl:priorVersion</i> annotation property is described in more detail in <a href="#Ontology_Annotations" title="">Section 3.5</a>.
</li><li> The <i>owl:backwardCompatibleWith</i> annotation property is described in more detail in <a href="#Ontology_Annotations" title="">Section 3.5</a>.
</li><li> The <i>owl:incompatibleWith</i> annotation property is described in more detail in <a href="#Ontology_Annotations" title="">Section 3.5</a>.
</li></ul>
<p>IRIs from the reserved vocabulary other than the ones listed above <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used to identify annotation properties in an OWL 2 DL ontology.
</p>
<div class="anexample">
<p>The comment provided by the following annotation assertion axiom might, for example, be used by an OWL 2 tool to display additional information about the IRI <i>a:Peter</i>.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> AnnotationAssertion( <i>rdfs:comment</i> <i>a:Peter</i> "The father of the Griffin family from Quahog." )
  </td><td> This axiom provides a comment for the IRI <i>a:Peter</i>.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>rdfs:comment</i> "The father of the Griffin family from Quahog." .
  </td><td> This axiom provides a comment for the IRI <i>a:Peter</i>.
</td></tr>
</tbody></table>
</div>
<a id="Individuals" name="Individuals"></a><h3> <span class="mw-headline">5.6  Individuals </span></h3>
<p><span id="def_individual"><i>Individuals</i></span> in the OWL 2 syntax represent actual objects from the domain. There are two types of individuals in the syntax of OWL 2. <i>Named individuals</i> are given an explicit name that can be used in any ontology to refer to the same object. <i>Anonymous individuals</i> do not have a global name and are thus local to the ontology they are contained in.
</p>
<div class="grammar">
<p><span class="nonterminal">Individual</span>&nbsp;:= <span class="nonterminal">NamedIndividual</span> | <span class="nonterminal">AnonymousIndividual</span>
</p>
</div>
<a id="Named_Individuals" name="Named_Individuals"></a><h4> <span class="mw-headline">5.6.1  Named Individuals </span></h4>
<p><span id="def_named_individual"><i>Named individuals</i></span> are identified using an IRI. Since they are given an IRI, named individuals are entities.
</p><p>IRIs from the reserved vocabulary <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> be used to identify named individuals in an OWL 2 DL ontology.
</p>
<div class="grammar">
<p><span class="nonterminal">NamedIndividual</span>&nbsp;:= <span class="nonterminal">IRI</span>
</p>
</div>
<div class="anexample">
<p>The individual <i>a:Peter</i> can be used to represent a particular person. It can be used in axioms such as the following one:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Person</i> <i>a:Peter</i> )
  </td><td> Peter is a person.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
  </td><td> Peter is a person.
</td></tr>
</tbody></table>
</div>
<a id="Anonymous_Individuals" name="Anonymous_Individuals"></a><h4> <span class="mw-headline">5.6.2  Anonymous Individuals </span></h4>
<p>If an individual is not expected to be used outside a particular ontology, one can use an <span id="def_anonymous_individual"><i>anonymous individual</i></span>, which is identified by a local node ID rather than a global IRI. Anonymous individuals are analogous to blank nodes in RDF [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>].
</p>
<div class="grammar">
<p><span class="nonterminal">AnonymousIndividual</span>&nbsp;:= <span class="nonterminal">nodeID</span>
</p>
</div>
<div class="anexample">
<p>Anonymous individuals can be used, for example, to represent objects whose identity is of no relevance, such as the address of a person.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:livesAt</i> <i>a:Peter</i> _:a1 )
  </td><td> Peter lives at some (unknown) address.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:city</i> _:a1 <i>a:Quahog</i> )
  </td><td> This unknown address is in the city of Quahog and...
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:state</i> _:a1 <i>a:RI</i> )
  </td><td> ...in the state of Rhode Island.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:livesAt</i> _:a1 .
  </td><td> Peter lives at some (unknown) address.
</td></tr>
<tr valign="top"><td> _:a1 <i>a:city</i> <i>a:Quahog</i> .
  </td><td> This unknown address is in the city of Quahog and...
</td></tr>
<tr valign="top"><td> _:a1 <i>a:state</i> <i>a:RI</i> .
  </td><td> ...in the state of Rhode Island.
</td></tr>
</tbody></table>
</div>
<p>Special treatment is required in case anonymous individuals with the same node ID occur in two different ontologies. In particular, these two individuals are structurally equivalent (because they have the same node ID); however, they are not treated as identical in the semantics of OWL 2 (because anonymous individuals are local to an ontology they are used in). The latter is achieved by <i>standardizing anonymous individuals apart</i> when constructing the axiom closure of an ontology <i>O</i>: if anonymous individuals with the same node ID occur in two different ontologies in the import closure of <i>O</i>, then one of these individuals <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be replaced in the axiom closure of <i>O</i> with a fresh anonymous individual (i.e., an anonymous individual whose node ID is unique in the import closure of <i>O</i>).
</p>
<div class="anexample">
<p>Assume that ontologies <i>O<sub>1</sub></i> and <i>O<sub>2</sub></i> both use <i>_:a5</i>, and that <i>O<sub>1</sub></i> imports <i>O<sub>2</sub></i>. Although they both use the same local node ID, the individual <i>_:a5</i> in <i>O<sub>1</sub></i> may be different from the individual <i>_:a5</i> in <i>O<sub>2</sub></i>.
</p><p>At the level of the structural specification, individual <i>_:a5</i> in <i>O<sub>1</sub></i> is structurally equivalent to individual <i>_:a5</i> in <i>O<sub>2</sub></i>. This might be important, for example, for tools that use structural equivalence to define the semantics of axiom retraction.
</p><p>In order to ensure that these individuals are treated differently by the semantics they are standardized apart when computing the axiom closure of <i>O<sub>1</sub></i> &mdash; either <i>_:a5</i> in <i>O<sub>1</sub></i> is replaced with a fresh anonymous individual, or this is done for <i>_:a5</i> in <i>O<sub>2</sub></i>.
</p>
</div>
<a id="Literals" name="Literals"></a><h3> <span class="mw-headline">5.7  Literals </span></h3>
<p><span id="def_literal"><i>Literals</i></span> represent data values such as particular strings or integers. They are analogous to typed RDF literals [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>] and can also be understood as individuals denoting data values. Each literal consists of a lexical form, which is a string, and a datatype; the datatypes supported in OWL 2 are described in more detail in <a href="#Datatype_Maps" title="">Section 4</a>. A literal consisting of a lexical form <span class="name">"abc"</span> and a datatype identified by the IRI <span class="name"><i>datatypeIRI</i></span> is written as <span class="name">"abc"^^<i>datatypeIRI</i></span>. Furthermore, literals whose datatype is <i>rdf:PlainLiteral</i> can be abbreviated in functional-style syntax ontology documents as plain RDF literals [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>]. These abbreviations are purely syntactic shortcuts and are thus not reflected in the structural specification of OWL 2. The observable behavior of OWL 2 implementation <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be as if these shortcuts were expanded during parsing.
</p>
<ul><li> Literals of the form <span class="name">"abc@"^^<i>rdf:PlainLiteral</i></span> <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be abbreviated in functional-style syntax ontology documents to <span class="name">"abc"</span> whenever possible.
</li><li> Literals of the form <span class="name">"abc@langTag"^^<i>rdf:PlainLiteral</i></span> where <span class="name">"langTag"</span> is not empty <em class="RFC2119" title="SHOULD in RFC 2119 context">SHOULD</em> be abbreviated in functional-style syntax documents to <span class="name">"abc"@langTag</span> whenever possible.
</li></ul>
<p>The lexical form of each literal occurring in an OWL 2 DL ontology <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> belong to the lexical space of the literal's datatype.
</p>
<div class="grammar">
<p><span class="nonterminal">Literal</span>&nbsp;:= <span class="nonterminal">typedLiteral</span> | <span class="nonterminal">stringLiteralNoLanguage</span> | <span class="nonterminal">stringLiteralWithLanguage</span><br />
<span class="nonterminal">typedLiteral</span>&nbsp;:= <span class="nonterminal">lexicalForm</span> '^^' <span class="nonterminal">Datatype</span><br />
<span class="nonterminal">lexicalForm</span>&nbsp;:= <span class="nonterminal">quotedString</span><br />
<span class="nonterminal">stringLiteralNoLanguage</span>&nbsp;:= <span class="nonterminal">quotedString</span><br />
<span class="nonterminal">stringLiteralWithLanguage</span>&nbsp;:= <span class="nonterminal">quotedString</span> <span class="nonterminal">languageTag</span>
</p>
</div>
<div class="anexample">
<p><span class="name">"1"^^<i>xsd:integer</i></span> is a literal that represents the integer 1.
</p>
</div>
<div class="anexample">
<p><span class="name">"Family Guy"</span> is an abbreviation for <span class="name">"Family Guy@"^^<i>rdf:PlainLiteral</i></span> &mdash; a literal with the lexical form <span class="name">"Family Guy@"</span> and the datatype <i>rdf:PlainLiteral</i> &mdash; which denotes a string <span class="name">"Family Guy"</span> without a language tag.
</p><p>Furthermore, <span class="name">"Padre de familia"@es</span> is an abbreviation for the literal <span class="name">"Padre de familia@es"^^<i>rdf:PlainLiteral</i></span>, which denotes a pair consisting of the string <span class="name">"Padre de familia"</span> and the language tag <span class="name">es</span>.
</p>
</div>
<p>Two literals are structurally equivalent if and only if both the lexical form and the datatype are structurally equivalent; that is, literals denoting the same data value are structurally different if either their lexical form or the datatype is different.
</p>
<div class="anexample">
<p>Even though literals <span class="name">"1"^^<i>xsd:integer</i></span> and <span class="name">"+1"^^<i>xsd:integer</i></span> are interpreted as the integer 1, these two literals are not structurally equivalent because their lexical forms are not identical. Similarly, <span class="name">"1"^^<i>xsd:integer</i></span> and <span class="name">"1"^^xsd:positiveInteger</span> are not structurally equivalent because their datatypes are not identical.
</p>
</div>
<a id="Entity_Declarations_and_Typing" name="Entity_Declarations_and_Typing"></a><h3> <span class="mw-headline">5.8  Entity Declarations and Typing </span></h3>
<p>Each IRI <i>I</i> used in an OWL 2 ontology <i>O</i> can be, and sometimes even needs to be, declared in <i>O</i>; roughly speaking, this means that the axiom closure of <i>O</i> must contain an appropriate declaration for <i>I</i>. A declaration for <i>I</i> in <i>O</i> serves two purposes:
</p>
<ul><li> A declaration says that <i>I</i> exists &mdash; that is, it says that <i>I</i> is part of the vocabulary of <i>O</i>.
</li><li> A declaration associates with <i>I</i> an entity type &mdash; that is, it says whether <i>I</i> is used in <i>O</i> as a class, datatype, object property, data property, annotation property, an individual, or a combination thereof.
</li></ul>
<div class="anexample">
<p>An ontology might contain a class declaration for the IRI <i>a:Person</i>. Such a declaration introduces the class <i>a:Person</i> into the ontology, and it states that the IRI <i>a:Person</i> is used to name a class in the ontology. An ontology editor might use declarations to implement functions such as "Add New Class".
</p>
</div>
<p>In OWL 2, declarations are a type of axiom; thus, to declare an entity in an ontology, one can simply include the appropriate axiom in the ontology. These axioms are nonlogical in the sense that they do not affect the consequences of an OWL 2 ontology. The structure of entity declarations is shown in Figure 3.
</p>
<div class="image">
<p><img alt="Entity Declarations in OWL 2" border="0" height="190" src="A_declaration.gif" width="246" /><br />
<span class="caption">Figure 3.</span> Entity Declarations in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">Declaration</span>&nbsp;:= 'Declaration' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Entity</span> ')'<br />
<span class="nonterminal">Entity</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; 'Class' '(' <span class="nonterminal">Class</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'Datatype' '(' <span class="nonterminal">Datatype</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'ObjectProperty' '(' <span class="nonterminal">ObjectProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'DataProperty' '(' <span class="nonterminal">DataProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'AnnotationProperty' '(' <span class="nonterminal">AnnotationProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'NamedIndividual' '(' <span class="nonterminal">NamedIndividual</span> ')'
</p>
</div>
<div class="anexample">
<p>The following axioms state that the IRI <i>a:Person</i> is used as a class and that the IRI <i>a:Peter</i> is used as an individual.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2">Declaration( Class( <i>a:Person</i> ) )
</td></tr>
<tr valign="top"><td colspan="2">Declaration( NamedIndividual( <i>a:Peter</i> ) )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Person</i> <i>rdf:type</i> <i>owl:Class</i> .
</td></tr>
<tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>rdf:type</i> <i>owl:NamedIndividual</i> .
</td></tr>
</tbody></table>
</div>
<p>Declarations for the built-in entities of OWL 2, listed in Table 5, are implicitly present in every OWL 2 ontology.
</p>
<div class="center">
<table border="1" class="allname" style="text-align: left">
<caption> <span class="caption">Table 5.</span> Declarations of Built-In Entities
</caption>
<tbody><tr>
<td colspan="2"> Declaration( Class( <i>owl:Thing</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( Class( <i>owl:Nothing</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( ObjectProperty( <i>owl:topObjectProperty</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( ObjectProperty( <i>owl:bottomObjectProperty</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( DataProperty( <i>owl:topDataProperty</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( DataProperty( <i>owl:bottomDataProperty</i> ) )
</td></tr>
<tr>
<td colspan="2"> Declaration( Datatype( <i>rdfs:Literal</i> ) )
</td></tr>
<tr>
<td> Declaration( Datatype( <i>I</i> ) )
</td><td> for each IRI <i>I</i> of a datatype in the OWL 2 datatype map (see <a href="#Datatype_Maps" title="">Section 4</a>)
</td></tr>
<tr>
<td> Declaration( AnnotationProperty( <i>I</i> ) )
</td><td> for each IRI <i>I</i> of a built-in annotation property listed in <a href="#Annotation_Properties" title="">Section 5.5</a>
</td></tr>
</tbody></table>
</div>
<a id="Typing_Constraints_of_OWL_2_DL" name="Typing_Constraints_of_OWL_2_DL"></a><h4> <span class="mw-headline">5.8.1  Typing Constraints of OWL 2 DL </span></h4>
<p>Let <i>Ax</i> be a set of axioms. An IRI <i>I</i> is <i>declared</i> to be of type <i>T</i> in <i>Ax</i> if a declaration axiom of type <i>T</i> for <i>I</i> is contained in <i>Ax</i> or in the set of built-in declarations listed in Table 5. The set <i>Ax</i> satisfies the <i>typing constraints</i> of OWL 2 DL if all of the following conditions are satisfied:
</p>
<ul><li> Property typing constraints:
<ul><li> If an object property with an IRI <i>I</i> occurs in some axiom in <i>Ax</i>, then <i>I</i> is declared in <i>Ax</i> as an object property.
</li><li> If a data property with an IRI <i>I</i> occurs in some axiom in <i>Ax</i>, then <i>I</i> is declared in <i>Ax</i> as a data property.
</li><li> If an annotation property with an IRI <i>I</i> occurs in some axiom in <i>Ax</i>, then <i>I</i> is declared in <i>Ax</i> as an annotation property.
</li><li> No IRI <i>I</i> is declared in <i>Ax</i> as being of more than one type of property; that is, no <i>I</i> is declared in <i>Ax</i> to be both object and data, object and annotation, or data and annotation property.
</li></ul>
</li><li> Class/datatype typing constraints:
<ul><li> If a class with an IRI <i>I</i> occurs in some axiom in <i>Ax</i>, then <i>I</i> is declared in <i>Ax</i> as a class.
</li><li> If a datatype with an IRI <i>I</i> occurs in some axiom in <i>Ax</i>, then <i>I</i> is declared in <i>Ax</i> as a datatype.
</li><li> No IRI <i>I</i> is declared in <i>ax</i> to be both a class and a datatype.
</li></ul>
</li></ul>
<p>The axiom closure <i>Ax</i> of each OWL 2 DL ontology <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the typing constraints of OWL 2 DL.
</p><p>The typing constraints thus ensure that the sets of IRIs used as object, data, and annotation properties in <i>O</i> are disjoint and that, similarly, the sets of IRIs used as classes and datatypes in <i>O</i> are disjoint as well. These constraints are used for disambiguating the types of IRIs when reading ontologies from external transfer syntaxes. All other declarations are optional.
</p>
<div class="anexample">
<p>An IRI <i>I</i> can be used as an individual in <i>O</i> even if <i>I</i> is not declared as an individual in <i>O</i>.
</p>
</div>
<p>Declarations are often omitted in the examples in this document in cases where the types of entities are clear.
</p>
<a id="Declaration_Consistency" name="Declaration_Consistency"></a><h4> <span class="mw-headline">5.8.2  Declaration Consistency </span></h4>
<p>Although declarations are not always required, they can be used to catch obvious errors in ontologies.
</p>
<div class="anexample">
<p>The following ontology erroneously refers to the individual <i>a:Petre</i> instead of the individual <i>a:Peter</i>.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> Ontology( <i>&lt;http://www.my.example.com/example&gt;</i><br /> &nbsp;&nbsp;&nbsp; Declaration( Class( <i>a:Person</i> ) )<br /> &nbsp;&nbsp;&nbsp; ClassAssertion( <i>a:Person</i> <i>a:Petre</i> )<br /> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>&lt;http://www.my.example.com/example&gt;</i> <i>rdf:type</i> <i>owl:Ontology</i> .<br /> <i>a:Person</i> <i>rdf:type</i> <i>owl:Class</i> .<br /> <i>a:Petre</i> <i>rdf:type</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
<p>There is no way of telling whether <i>a:Petre</i> was used by mistake. If, in contrast, all individuals in an ontology were by convention required to be declared, this error could be caught by a simple tool.
</p>
</div>
<p>An ontology <i>O</i> is said to have <i>consistent declarations</i> if each IRI <i>I</i> occurring in the axiom closure of <i>O</i> in position of an entity with a type <i>T</i> is declared in <i>O</i> as having type <i>T</i>. OWL 2 ontologies are not required to have consistent declarations: an ontology <em class="RFC2119" title="MAY in RFC 2119 context">MAY</em> be used even if its declarations are not consistent.
</p>
<div class="anexample">
<p>The ontology from the previous example fails this check: <i>a:Petre</i> is used as an individual but the ontology does not declare <i>a:Petre</i> to be an individual. In contrast, the following ontology satisfies this condition.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> Ontology( <i>&lt;http://www.my.example.com/example&gt;</i><br /> &nbsp;&nbsp;&nbsp; Declaration( Class( <i>a:Person</i> ) )<br /> &nbsp;&nbsp;&nbsp; Declaration( NamedIndividual( <i>a:Peter</i> ) )<br /> &nbsp;&nbsp;&nbsp; ClassAssertion( <i>a:Person</i> <i>a:Peter</i> )<br /> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>&lt;http://www.my.example.com/example&gt;</i> <i>rdf:type</i> <i>owl:Ontology</i> .<br /> <i>a:Person</i> <i>rdf:type</i> <i>owl:Class</i> .<br /> <i>a:Peter</i> <i>rdf:type</i> <i>owl:NamedIndividual</i> .<br /> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
</div>
<a id="Metamodeling" name="Metamodeling"></a><h3> <span class="mw-headline">5.9  Metamodeling </span></h3>
<p>An IRI <i>I</i> can be used in an OWL 2 ontology to refer to more than one type of entity. Such usage of <i>I</i> is often called <i>metamodeling</i>, because it can be used to state facts about classes and properties themselves. In such cases, the entities that share the same IRI <i>I</i> should be understood as different "views" of the same underlying notion identified by the IRI <i>I</i>.
</p>
<div class="anexample">
<p>Consider the following ontology.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Species</i> <i>a:Dog</i> )
  </td><td> Dog is a species.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Dog</i> <i>rdf:type</i> <i>a:Species</i> .
  </td><td> Dog is a species.
</td></tr>
</tbody></table>
<p>In the first axiom, the IRI <i>a:Dog</i> is used as a class, while in the second axiom, it is used as an individual; thus, the class <i>a:Species</i> acts as a metaclass for the class <i>a:Dog</i>. The individual <i>a:Dog</i> and the class <i>a:Dog</i> should be understood as two "views" of one and the same IRI &mdash; <i>a:Dog</i>. Under the OWL 2 Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>], these two views are interpreted independently: the class view of <i>a:Dog</i> is interpreted as a unary predicate, while the individual view of <i>a:Dog</i> is interpreted as a constant.
</p>
</div>
<p>Both metamodeling and annotations provide means to associate additional information with classes and properties. The following rule-of-the-thumb can be used to determine when to use which construct:
</p>
<ul><li> Metamodeling should be used when the information attached to entities should be considered a part of the domain.
</li><li> Annotations should be used when the information attached to entities should not be considered a part of the domain and when it should not contribute to the logical consequences of an ontology.
</li></ul>
<div class="anexample">
<p>Consider the following ontology.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:PetAnimals</i> <i>a:Dog</i> )
  </td><td> Dogs are pet animals.
</td></tr>
<tr valign="top"><td> AnnotationAssertion( <i>a:addedBy</i> <i>a:Dog</i> "Seth MacFarlane" )
  </td><td> The IRI <i>a:Dog</i> has been added to the ontology by Seth MacFarlane.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Dog</i> <i>rdf:type</i> <i>a:PetAnimals</i> .
  </td><td> Dogs are pet animals.
</td></tr>
<tr valign="top"><td>  <i>a:Dog</i> <i>a:addedBy</i> "Seth MacFarlane" .
  </td><td> The IRI <i>a:Dog</i> has been added to the ontology by Seth MacFarlane.
</td></tr>
</tbody></table>
<p>The facts that Brian is a dog and that dogs are pet animals are statements about the domain. Therefore, these facts are represented in the above ontology via metamodeling. In contrast, the information about who added the IRI <i>a:Dog</i> to the ontology does not describe the actual domain, but might be interesting from a management point of view. Therefore, this information is represented using an annotation.
</p>
</div>
<a id="Property_Expressions" name="Property_Expressions"></a><h2> <span class="mw-headline">6  Property Expressions </span></h2>
<p>Properties can be used in OWL 2 to form property expressions.
</p>
<a id="Object_Property_Expressions" name="Object_Property_Expressions"></a><h3> <span class="mw-headline">6.1  Object Property Expressions </span></h3>
<p>Object properties can by used in OWL 2 to form object property expressions, which represent relationships between pairs of individuals. They are represented in the structural specification of OWL 2 by <span class="nonterminal">ObjectPropertyExpression</span>, and their structure is shown in Figure 4.
</p>
<div class="image">
<p><img alt="Object Property Expressions in OWL 2" border="0" height="206" src="C_objectproperty.gif" width="373" /><br />
<span class="caption">Figure 4.</span> Object Property Expressions in OWL 2
</p>
</div>
<p>As one can see from the figure, OWL 2 supports only two kinds of object property expressions. Object properties are the simplest form of object property expressions, and inverse object properties allow for bidirectional navigation in class expressions and axioms.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectProperty</span> | <span class="nonterminal">InverseObjectProperty</span>
</p>
</div>
<a id="Inverse_Object_Properties" name="Inverse_Object_Properties"></a><h4> <span class="mw-headline">6.1.1  Inverse Object Properties </span></h4>
<p>An inverse object property expression <span class="name">ObjectInverseOf( P )</span> connects an individual <span class="name">I<sub>1</sub></span> with <span class="name">I<sub>2</sub></span> if and only if the object property <span class="name">P</span> connects <span class="name">I<sub>2</sub></span> with <span class="name">I<sub>1</sub></span>.
</p>
<div class="grammar">
<p><span class="nonterminal">InverseObjectProperty</span>&nbsp;:= 'ObjectInverseOf' '(' <span class="nonterminal">ObjectProperty</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following assertion.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
</tbody></table>
<p>This ontology entails that <i>a:Stewie</i> is connected by the following object property expression to <i>a:Peter</i>:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectInverseOf( <i>a:fatherOf</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x owl:inverseOf <i>a:fatherOf</i> .
</td></tr>
</tbody></table>
</div>
<a id="Data_Property_Expressions" name="Data_Property_Expressions"></a><h3> <span class="mw-headline">6.2  Data Property Expressions </span></h3>
<p>For symmetry with object property expressions, the structural specification of OWL 2 also introduces data property expressions, which represent relationships between an individual and a literal. The structure of data property expressions is shown in Figure 5. The only allowed data property expression is a data property; thus, <span class="nonterminal">DataPropertyExpression</span> in the structural specification of OWL 2 can be seen as a place-holder for possible future extensions.
</p>
<div class="image">
<p><img alt="Data Property Expressions in OWL 2" border="0" height="210" src="C_dataproperty.gif" width="273" /><br />
<span class="caption">Figure 5.</span> Data Property Expressions in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataProperty</span>
</p>
</div>
<a id="Data_Ranges" name="Data_Ranges"></a><h2> <span class="mw-headline">7  Data Ranges </span></h2>
<p>Datatypes, such as <i>xsd:string</i> or <i>xsd:integer</i>, and literals such as "1"^^<i>xsd:integer</i>, can be used to express data ranges &mdash; sets of tuples of literals, where tuples consisting of only one literal are identified with the literal itself. Each data range is associated with a positive arity, which determines the size of the tuples in the data range. All datatypes have arity one. This specification currently does not define data ranges of arity more than one; however, by allowing for <i>n</i>-ary data ranges, the syntax of OWL 2 provides a "hook" allowing implementations to introduce extensions such as comparisons and arithmetic.
</p><p>Data ranges can be used in restrictions on data properties, as discussed in Sections <a href="#Data_Property_Restrictions" title="">8.4</a> and <a href="#Data_Property_Cardinality_Restrictions" title="">8.5</a>. The structure of data ranges in OWL 2 is shown in Figure 6. The simplest data ranges are datatypes. The <span class="nonterminal">DataIntersectionOf</span>, <span class="nonterminal">DataUnionOf</span>, and <span class="nonterminal">DataComplementOf</span> data ranges provide for the standard set-theoretic operations on data ranges; in logical languages these are usually called conjunction, disjunction, and negation, respectively. The <span class="nonterminal">DataOneOf</span> data range consists of exactly the specified set of literals. Finally, the <span class="nonterminal">DatatypeRestriction</span> data range restricts the value space of a datatype by a constraining facet.
</p>
<div class="image">
<p><img alt="Data Ranges in OWL 2" border="0" height="357" src="C_datarange.gif" width="801" /><br />
<span class="caption">Figure 6.</span> Data Ranges in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DataRange</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">Datatype</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataIntersectionOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataUnionOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataComplementOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataOneOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DatatypeRestriction</span>
</p>
</div>
<a id="Intersection_of_Data_Ranges" name="Intersection_of_Data_Ranges"></a><h3> <span class="mw-headline">7.1  Intersection of Data Ranges </span></h3>
<p>An intersection data range <span class="name">DataIntersectionOf( DR<sub>1</sub> ... DR<sub>n</sub> )</span> contains all tuples of literals that are contained in each data range <span class="name">DR<sub>i</sub></span> for 1 &le; i &le; n. All data ranges <span class="name">DR<sub>i</sub></span> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be of the same arity, and the resulting data range is of that arity as well.
</p>
<div class="grammar">
<p><span class="nonterminal">DataIntersectionOf</span>&nbsp;:= 'DataIntersectionOf' '(' <span class="nonterminal">DataRange</span> <span class="nonterminal">DataRange</span> { <span class="nonterminal">DataRange</span> } ')'
</p>
</div>
<div class="anexample">
<p>The following data range contains exactly the integer 0:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataIntersectionOf( <i>xsd:nonNegativeInteger</i> <i>xsd:nonPositiveInteger</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:intersectionOf</i> ( <i>xsd:nonNegativeInteger</i> <i>xsd:nonPositiveInteger</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="Union_of_Data_Ranges" name="Union_of_Data_Ranges"></a><h3> <span class="mw-headline">7.2  Union of Data Ranges </span></h3>
<p>A union data range <span class="name">DataUnionOf( DR<sub>1</sub> ... DR<sub>n</sub> )</span> contains all tuples of literals that are contained in the at least one data range <span class="name">DR<sub>i</sub></span> for 1 &le; i &le; n. All data ranges <span class="name">DR<sub>i</sub></span> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be of the same arity, and the resulting data range is of that arity as well.
</p>
<div class="grammar">
<p><span class="nonterminal">DataUnionOf</span>&nbsp;:= 'DataUnionOf' '(' <span class="nonterminal">DataRange</span> <span class="nonterminal">DataRange</span> { <span class="nonterminal">DataRange</span> } ')'
</p>
</div>
<div class="anexample">
<p>The following data range contains all strings and all integers:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataUnionOf( <i>xsd:string</i> <i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2">  _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:unionOf</i> ( <i>xsd:string</i> <i>xsd:integer</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="Complement_of_Data_Ranges" name="Complement_of_Data_Ranges"></a><h3> <span class="mw-headline">7.3  Complement of Data Ranges </span></h3>
<p>A complement data range <span class="name">DataComplementOf( DR )</span> contains all tuples of literals that are not contained in the data range <span class="name">DR</span>. The resulting data range has the arity equal to the arity of <span class="name">DR</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataComplementOf</span>&nbsp;:= 'DataComplementOf' '(' <span class="nonterminal">DataRange</span> ')'
</p>
</div>
<div class="anexample">
<p>The following complement data range contains literals that are not positive integers:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataComplementOf( <i>xsd:positiveInteger</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:complementOf</i> <i>xsd:positiveInteger</i> .
</td></tr>
</tbody></table>
<p>In particular, this data range contains the integer zero and all negative integers; however, it also contains all strings (since strings are not positive integers).
</p>
</div>
<a id="Enumeration_of_Literals" name="Enumeration_of_Literals"></a><h3> <span class="mw-headline">7.4  Enumeration of Literals </span></h3>
<p>An enumeration of literals <span class="name">DataOneOf( lt<sub>1</sub> ... lt<sub>n</sub> )</span> contains exactly the explicitly specified literals <span class="name">lt<sub>i</sub></span> with 1 &le; i &le; n. The resulting data range has arity one.
</p>
<div class="grammar">
<p><span class="nonterminal">DataOneOf</span>&nbsp;:= 'DataOneOf' '(' <span class="nonterminal">Literal</span> { <span class="nonterminal">Literal</span> } ')'
</p>
</div>
<div class="anexample">
<p>The following data range contains exactly two literals: the string <span class="name">"Peter"</span> and the integer one.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataOneOf( "Peter" "1"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:oneOf</i> ( "Peter" "1"^^<i>xsd:integer</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="Datatype_Restrictions" name="Datatype_Restrictions"></a><h3> <span class="mw-headline">7.5  Datatype Restrictions </span></h3>
<p>A datatype restriction <span class="name">DatatypeRestriction( DT F<sub>1</sub> lt<sub>1</sub> ... F<sub>n</sub> lt<sub>n</sub> )</span> consists of a unary datatype <span class="name">DT</span> and <span class="name">n</span> pairs <span class="name">( F<sub>i</sub> , lt<sub>i</sub> )</span>. The resulting data range is unary and is obtained by restricting the value space of <span class="name">DT</span> according to the semantics of all <span class="name">( F<sub>i</sub> , v<sub>i</sub> )</span> (multiple pairs are interpreted conjunctively), where <span class="name">v<sub>i</sub></span> are the data values of the literals <span class="name">lt<sub>i</sub></span>.
</p><p>In an OWL 2 DL ontology, each pair <span class="name">( F<sub>i</sub> , v<sub>i</sub> )</span> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be contained in the facet space of <span class="name">DT</span> (see <a href="#Datatype_Maps" title="">Section 4</a>).
</p>
<div class="grammar">
<p><span class="nonterminal">DatatypeRestriction</span>&nbsp;:= 'DatatypeRestriction' '(' <span class="nonterminal">Datatype</span> <span class="nonterminal">constrainingFacet</span> <span class="nonterminal">restrictionValue</span> { <span class="nonterminal">constrainingFacet</span> <span class="nonterminal">restrictionValue</span> } ')'<br />
<span class="nonterminal">constrainingFacet</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">restrictionValue</span>&nbsp;:= <span class="nonterminal">Literal</span>
</p>
</div>
<div class="anexample">
<p>The following data range contains exactly the integers 5, 6, 7, 8, and 9:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DatatypeRestriction( <i>xsd:integer</i> <i>xsd:minInclusive</i> "5"^^<i>xsd:integer</i> <i>xsd:maxExclusive</i> "10"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:onDatatype</i> <i>xsd:integer</i> .<br /> _:x <i>owl:withRestrictions</i> ( _:y _:z ) .<br /> _:y <i>xsd:minInclusive</i> "5"^^<i>xsd:integer</i> .<br /> _:z <i>xsd:maxExclusive</i> "10"^^<i>xsd:integer</i> .
</td></tr>
</tbody></table>
</div>
<a id="Class_Expressions" name="Class_Expressions"></a><h2> <span class="mw-headline">8  Class Expressions </span></h2>
<p>In OWL 2, classes and property expressions are used to construct <span id="def_class_expression"><i>class expressions</i></span>, sometimes also called <i>descriptions</i>, and, in the description logic literature, <i>complex concepts</i>. Class expressions represent sets of individuals by formally specifying conditions on the individuals' properties; individuals satisfying these conditions are said to be <i>instances</i> of the respective class expressions.  In the structural specification of OWL 2, class expressions are represented by <span class="nonterminal">ClassExpression</span>.
</p>
<div class="anexample">
<p>A class expression can be used to represent the set of "people that have at least one child". If an ontology additionally contains statements that "Peter is a person" and that "Peter has child Chris", then Peter can be classified as an instance of the mentioned class expression.
</p>
</div>
<p>OWL 2 provides a rich set of primitives that can be used to construct class expressions. In particular, it provides the well known Boolean connectives <i>and</i>, <i>or</i>, and <i>not</i>; a restricted form of universal and existential quantification; number restrictions; enumeration of individuals; and a special <i>self</i>-restriction.
</p><p>As shown in Figure 2, classes are the simplest form of class expressions. The other, complex, class expressions, are described in the following sections.
</p>
<div class="grammar">
<p><span class="nonterminal">ClassExpression</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">Class</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectIntersectionOf</span> | <span class="nonterminal">ObjectUnionOf</span> | <span class="nonterminal">ObjectComplementOf</span> | <span class="nonterminal">ObjectOneOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectSomeValuesFrom</span> | <span class="nonterminal">ObjectAllValuesFrom</span> | <span class="nonterminal">ObjectHasValue</span> | <span class="nonterminal">ObjectHasSelf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectMinCardinality</span> | <span class="nonterminal">ObjectMaxCardinality</span> | <span class="nonterminal">ObjectExactCardinality</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataSomeValuesFrom</span> | <span class="nonterminal">DataAllValuesFrom</span> | <span class="nonterminal">DataHasValue</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataMinCardinality</span> | <span class="nonterminal">DataMaxCardinality</span> | <span class="nonterminal">DataExactCardinality</span>
</p>
</div>
<a id="Propositional_Connectives_and_Enumeration_of_Individuals" name="Propositional_Connectives_and_Enumeration_of_Individuals"></a><h3> <span class="mw-headline">8.1  Propositional Connectives and Enumeration of Individuals </span></h3>
<p>OWL 2 provides for enumeration of individuals and all standard Boolean connectives, as shown in Figure 7. The <span class="nonterminal">ObjectIntersectionOf</span>, <span class="nonterminal">ObjectUnionOf</span>, and <span class="nonterminal">ObjectComplementOf</span> class expressions provide for the standard set-theoretic operations on class expressions; in logical languages these are usually called conjunction, disjunction, and negation, respectively. The <span class="nonterminal">ObjectOneOf</span> class expression contains exactly the specified individuals.
</p>
<div class="image">
<p><img alt="Propositional Connectives and Enumeration of Individuals in OWL 2" border="0" height="401" src="C_propositional.gif" width="598" /><br />
<span class="caption">Figure 7.</span> Propositional Connectives and Enumeration of Individuals in OWL 2
</p>
</div>
<a id="Intersection_of_Class_Expressions" name="Intersection_of_Class_Expressions"></a><h4> <span class="mw-headline">8.1.1  Intersection of Class Expressions </span></h4>
<p>An intersection class expression <span class="name">ObjectIntersectionOf( CE<sub>1</sub> ... CE<sub>n</sub> )</span> contains all individuals that are instances of all class expressions <span class="name">CE<sub>i</sub></span> for 1 &le; i &le; n.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectIntersectionOf</span>&nbsp;:= 'ObjectIntersectionOf' '(' <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:CanTalk</i> <i>a:Brian</i> )
  </td><td> Brian can talk.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:CanTalk</i> .
  </td><td> Brian can talk.
</td></tr>
</tbody></table>
<p>The following class expression describes all dogs that can talk; furthermore, <i>a:Brian</i> is classified as its instance.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectIntersectionOf( <i>a:Dog</i> <i>a:CanTalk</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> ( <i>a:Dog</i> <i>a:CanTalk</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="Union_of_Class_Expressions" name="Union_of_Class_Expressions"></a><h4> <span class="mw-headline">8.1.2  Union of Class Expressions </span></h4>
<p>A union class expression <span class="name">ObjectUnionOf( CE<sub>1</sub> ... CE<sub>n</sub> )</span> contains all individuals that are instances of at least one class expression <span class="name">CE<sub>i</sub></span> for 1 &le; i &le; n.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectUnionOf</span>&nbsp;:= 'ObjectUnionOf' '(' <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Man</i> <i>a:Peter</i> )
  </td><td> Peter is a man.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Woman</i> <i>a:Lois</i> )
  </td><td> Lois is a woman.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:Man</i> .
  </td><td> Peter is a man.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>rdf:type</i> <i>a:Woman</i> .
  </td><td> Lois is a woman.
</td></tr>
</tbody></table>
<p>The following class expression describes all individuals that are instances of either <i>a:Man</i> or <i>a:Woman</i>; furthermore, both <i>a:Peter</i> and <i>a:Lois</i> are classified as its instances:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectUnionOf( <i>a:Man</i> <i>a:Woman</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:unionOf</i> ( <i>a:Man</i> <i>a:Woman</i> ) .
</td></tr>
</tbody></table>
</div>
<a id="Complement_of_Class_Expressions" name="Complement_of_Class_Expressions"></a><h4> <span class="mw-headline">8.1.3  Complement of Class Expressions </span></h4>
<p>A complement class expression <span class="name">ObjectComplementOf( CE )</span> contains all individuals that are not instances of the class expression <span class="name">CE</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectComplementOf</span>&nbsp;:= 'ObjectComplementOf' '(' <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DisjointClasses( <i>a:Man</i> <i>a:Woman</i> )
  </td><td> Nothing can be both a man and a woman.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Woman</i> <i>a:Lois</i> )
  </td><td> Lois is a woman.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Man</i> <i>owl:disjointWith</i> <i>a:Woman</i> .
  </td><td> Nothing can be both a man and a woman.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>rdf:type</i> <i>a:Woman</i> .
  </td><td> Lois is a woman.
</td></tr>
</tbody></table>
<p>The following class expression describes all things that are not instances of <i>a:Man</i>:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectComplementOf( <i>a:Man</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> <i>a:Man</i> .
</td></tr>
</tbody></table>
<p>Since <i>a:Lois</i> is known to be a woman and nothing can be both a man and a woman, then <i>a:Lois</i> is necessarily not a <i>a:Man</i>; therefore, <i>a:Lois</i> is classified as an instance of this complement class expression.
</p>
</div>
<div class="anexample">
<p>OWL 2 has <i>open-world</i> semantics, so negation in OWL 2 is the same as in classical (first-order) logic. To understand open-world semantics, consider the ontology consisting of the following assertion.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
</tbody></table>
<p>One might expect <i>a:Brian</i> to be classified as an instance of the following class expression:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectComplementOf( <i>a:Bird</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> <i>a:Bird</i> .
</td></tr>
</tbody></table>
<p>Intuitively, the ontology does not explicitly state that <i>a:Brian</i> is an instance of <i>a:Bird</i>, so this statement seems to be false. In OWL 2, however, this is not the case: it is true that the ontology does not state that <i>a:Brian</i> is an instance of <i>a:Bird</i>; however, the ontology does not state the opposite either. In other words, this ontology simply does not contain enough information to answer the question whether <i>a:Brian</i> is an instance of <i>a:Bird</i> or not: it is perfectly possible that the information to that effect is actually true but it has not been included in the ontology.
</p><p>The ontology from the previous example (in which <i>a:Lois</i> has been classified as <i>a:Man</i>), however, contains sufficient information to draw the expected conclusion. In particular, we know for sure that <i>a:Lois</i> is an instance of <i>a:Woman</i> and that <i>a:Man</i> and <i>a:Woman</i> do not share instances. Therefore, any additional information that does not lead to inconsistency cannot lead to a conclusion that <i>a:Lois</i> is an instance of <i>a:Man</i>; furthermore, if one were to explicitly state that <i>a:Lois</i> is an instance of <i>a:Man</i>, the ontology would be inconsistent and, by definition, it  then entails all possible conclusions.
</p>
</div>
<a id="Enumeration_of_Individuals" name="Enumeration_of_Individuals"></a><h4> <span class="mw-headline">8.1.4  Enumeration of Individuals </span></h4>
<p>An enumeration of individuals <span class="name">ObjectOneOf( a<sub>1</sub> ... a<sub>n</sub> )</span> contains exactly the individuals <span class="name">a<sub>i</sub></span> with 1 &le; i &le; n.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectOneOf</span>&nbsp;:= 'ObjectOneOf' '(' <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> }')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> EquivalentClasses( <i>a:GriffinFamilyMember</i><br /> &nbsp;&nbsp;&nbsp; ObjectOneOf( <i>a:Peter</i> <i>a:Lois</i> <i>a:Stewie</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Brian</i> )<br /> )
  </td><td> The Griffin family consists exactly of Peter, Lois, Stewie, Meg, Chris, and Brian.
</td></tr>
<tr valign="top"><td> DifferentIndividuals( <i>a:Quagmire</i> <i>a:Peter</i> <i>a:Lois</i> <i>a:Stewie</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Brian</i> )
  </td><td> Quagmire, Peter, Lois, Stewie, Meg, Chris, and Brian are all different from each other.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:GriffinFamilyMember</i> <i>owl:equivalentClass</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:oneOf</i> ( <i>a:Peter</i> <i>a:Lois</i> <i>a:Stewie</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Brian</i> ) .
  </td><td> The Griffin family consists exactly of Peter, Lois, Stewie, Meg, and Brian.
</td></tr>
<tr valign="top"><td> _:y <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:y <i>owl:members</i> ( <i>a:Quagmire</i> <i>a:Peter</i> <i>a:Lois</i> <i>a:Stewie</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Brian</i> ) .
  </td><td> Quagmire, Peter, Lois, Stewie, Meg, Chris, and Brian are all different from each other.
</td></tr>
</tbody></table>
<p>The class <i>a:GriffinFamilyMember</i> now contains exactly the six explicitly listed individuals. Since we also know that <i>a:Quagmire</i> is different from these six individuals, this individual is classified as an instance of the following class expression:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectComplementOf( <i>a:GriffinFamilyMember</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:z <i>rdf:type</i> <i>owl:Class</i> .<br /> _:z <i>owl:complementOf</i> <i>a:GriffinFamilyMember</i> .
</td></tr>
</tbody></table>
<p>The last axiom in the ontology is necessary to derive the mentioned conclusion; without it, the open-world semantics of OWL 2 would allow for situations where <i>a:Quagmire</i> is the same as <i>a:Peter</i>, <i>a:Lois</i>, <i>a:Stewie</i>, <i>a:Meg</i>, <i>a:Chris</i>, or <i>a:Brian</i>.
</p>
</div>
<div class="anexample">
<p>To understand how the open-world semantics affects enumerations of individuals, consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Peter</i> )
  </td><td> Peter is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Lois</i> )
  </td><td> Lois is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Stewie</i> )
  </td><td> Stewie is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Meg</i> )
  </td><td> Meg is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Chris</i> )
  </td><td> Chris is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Brian</i> )
  </td><td> Brian is a member of the Griffin Family.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Peter is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Lois is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Stewie is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Meg is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Chris is a member of the Griffin Family.
</td></tr>
<tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Brian is a member of the Griffin Family.
</td></tr>
</tbody></table>
<p>The class <i>a:GriffinFamilyMember</i> now also contains the mentioned six individuals, just as in the previous example. The main difference to the previous example, however, is that the extension of <i>a:GriffinFamilyMember</i> is not closed: the semantics of OWL 2 assumes that information about a potential instance of <i>a:GriffinFamilyMember</i> may be missing. Therefore, <i>a:Quagmire</i> is now not classified as an instance of the following class expression, and this does not change even if we add the axiom stating that all of these six individuals are different from each other:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectComplementOf( <i>a:GriffinFamilyMember</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> <i>a:GriffinFamilyMember</i> .
</td></tr>
</tbody></table>
</div>
<a id="Object_Property_Restrictions" name="Object_Property_Restrictions"></a><h3> <span class="mw-headline">8.2  Object Property Restrictions </span></h3>
<p>Class expressions in OWL 2 can be formed by placing restrictions on object property expressions, as shown in Figure 8. The <span class="nonterminal">ObjectSomeValuesFrom</span> class expression allows for existential quantification over an object property expression, and it contains those individuals that are connected through an object property expression to at least one instance of a given class expression. The <span class="nonterminal">ObjectAllValuesFrom</span> class expression allows for universal quantification over an object property expression, and it contains those individuals that are connected through an object property expression only to instances of a given class expression. The <span class="nonterminal">ObjectHasValue</span> class expression contains those individuals that are connected by an object property expression to a particular individual. Finally, the <span class="nonterminal">ObjectHasSelf</span> class expression contains those individuals that are connected by an object property expression to themselves.
</p>
<div class="image">
<p><img alt="Restricting Object Property Expressions in OWL 2" border="0" height="406" src="C_objectmodal.gif" width="645" /><br />
<span class="caption">Figure 8.</span> Restricting Object Property Expressions in OWL 2
</p>
</div>
<a id="Existential_Quantification" name="Existential_Quantification"></a><h4> <span class="mw-headline">8.2.1  Existential Quantification </span></h4>
<p>An existential class expression <span class="name">ObjectSomeValuesFrom( OPE CE )</span> consists of an object property expression <span class="name">OPE</span> and a class expression <span class="name">CE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to an individual that is an instance of <span class="name">CE</span>. Provided that <span class="name">OPE</span> is <i>simple</i> according to the definition in <a href="#Global_Restrictions_on_Axioms_in_OWL_2_DL" title="">Section 11</a>, such a class expression can be seen as a syntactic shortcut for the class expression <span class="name">ObjectMinCardinality( 1 OPE CE )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectSomeValuesFrom</span>&nbsp;:= 'ObjectSomeValuesFrom' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Man</i> <i>a:Stewie</i> )
  </td><td> Stewie is a man.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Man</i> .
  </td><td> Stewie is a man.
</td></tr>
</tbody></table>
<p>The following existential expression contains those individuals that are connected by the <i>a:fatherOf</i> property to individuals that are instances of <i>a:Man</i>; furthermore, <i>a:Peter</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectSomeValuesFrom( <i>a:fatherOf</i> <i>a:Man</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br />  _:x <i>owl:onProperty</i> <i>a:fatherOf</i> .<br /> _:x <i>owl:someValuesFrom</i> <i>a:Man</i> .
</td></tr>
</tbody></table>
</div>
<a id="Universal_Quantification" name="Universal_Quantification"></a><h4> <span class="mw-headline">8.2.2  Universal Quantification </span></h4>
<p>A universal class expression <span class="name">ObjectAllValuesFrom( OPE CE )</span> consists of an object property expression <span class="name">OPE</span> and a class expression <span class="name">CE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> only to individuals that are instances of <span class="name">CE</span>. Provided that <span class="name">OPE</span> is <i>simple</i> according to the definition in <a href="#Global_Restrictions_on_Axioms_in_OWL_2_DL" title="">Section 11</a>, such a class expression can be seen as a syntactic shortcut for the class expression <span class="name">ObjectMaxCardinality( 0 OPE ObjectComplementOf( CE ) )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectAllValuesFrom</span>&nbsp;:= 'ObjectAllValuesFrom' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasPet</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion( ObjectMaxCardinality( 1 <i>a:hasPet</i> ) <i>a:Peter</i> )
  </td><td> Peter has at most one pet.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasPet</i> <i>a:Brian</i> .
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> "1"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasPet</i> .
  </td><td> Peter has at most one pet.
</td></tr>
</tbody></table>
<p>The following universal expression contains those individuals that are connected through the <i>a:hasPet</i> property only with individuals that are instances of <i>a:Dog</i> &mdash; that is, it contains individuals that have only dogs as pets:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectAllValuesFrom( <i>a:hasPet</i> <i>a:Dog</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:y <i>rdf:type</i> <i>owl:Restriction</i> .<br />  _:y <i>owl:onProperty</i> <i>a:hasPet</i> .<br /> _:y <i>owl:allValuesFrom</i> <i>a:Dog</i> .
</td></tr>
</tbody></table>
<p>The ontology axioms clearly state that <i>a:Peter</i> is connected by <i>a:hasPet</i> only to instances of <i>a:Dog</i>: it is impossible to connect <i>a:Peter</i> by <i>a:hasPet</i> to an individual different from <i>a:Brian</i> without making the ontology inconsistent. Therefore, <i>a:Peter</i> is classified as an instance of the mentioned class expression.
</p><p>The last axiom &mdash; that is, the one stating that <i>a:Peter</i> has at most one pet &mdash; is critical for the inference from the previous paragraph due to the open-world semantics of OWL 2. Without this axiom, the ontology might not have listed all the individuals to which <i>a:Peter</i> is connected by <i>a:hasPet</i>. In such a case <i>a:Peter</i> would not be classified as an instance of the mentioned class expression.
</p>
</div>
<a id="Individual_Value_Restriction" name="Individual_Value_Restriction"></a><h4> <span class="mw-headline">8.2.3  Individual Value Restriction </span></h4>
<p>A has-value class expression <span class="name">ObjectHasValue( OPE a )</span> consists of an object property expression <span class="name">OPE</span> and an individual <span class="name">a</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to <span class="name">a</span>. Each such class expression can be seen as a syntactic shortcut for the class expression <span class="name">ObjectSomeValuesFrom( OPE ObjectOneOf( a ) )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectHasValue</span>&nbsp;:= 'ObjectHasValue' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">Individual</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
</tbody></table>
<p>The following has-value class expression contains those individuals that are connected through the <i>a:fatherOf</i> property with the individual <i>a:Stewie</i>; furthermore, <i>a:Peter</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectHasValue( <i>a:fatherOf</i> <i>a:Stewie</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:fatherOf</i> .<br /> _:x <i>owl:hasValue</i> <i>a:Stewie</i> .
</td></tr>
</tbody></table>
</div>
<a id="Self-Restriction" name="Self-Restriction"></a><h4> <span class="mw-headline">8.2.4  Self-Restriction </span></h4>
<p>A self-restriction <span class="name">ObjectHasSelf( OPE )</span> consists of an object property expression <span class="name">OPE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to themselves.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectHasSelf</span>&nbsp;:= 'ObjectHasSelf' '(' <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:likes</i> <i>a:Peter</i> <i>a:Peter</i> )
  </td><td> Peter likes Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:likes</i> <i>a:Peter</i> .
  </td><td> Peter likes Peter.
</td></tr>
</tbody></table>
<p>The following self-restriction contains those individuals that like themselves; furthermore, <i>a:Peter</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectHasSelf( <i>a:likes</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:likes</i> .<br /> _:x <i>owl:hasSelf</i> "true"^^<i>xsd:boolean</i> .
</td></tr>
</tbody></table>
</div>
<a id="Object_Property_Cardinality_Restrictions" name="Object_Property_Cardinality_Restrictions"></a><h3> <span class="mw-headline">8.3  Object Property Cardinality Restrictions </span></h3>
<p>Class expressions in OWL 2 can be formed by placing restrictions on the cardinality of object property expressions, as shown in Figure 9. All cardinality restrictions can be qualified or unqualified: in the former case, the cardinality restriction only applies to individuals that are connected by the object property expression and are instances of the qualifying class expression; in the latter case the restriction applies to all individuals that are connected by the object property expression (this is equivalent to the qualified case with the qualifying class expression equal to <i>owl:Thing</i>). The class expressions <span class="nonterminal">ObjectMinCardinality</span>, <span class="nonterminal">ObjectMaxCardinality</span>, and <span class="nonterminal">ObjectExactCardinality</span> contain those individuals that are connected by an object property expression to at least, at most, and exactly a given number of instances of a specified class expression, respectively.
</p>
<div class="image">
<p><img alt="Restricting the Cardinality of Object Property Expressions in OWL 2" border="0" height="353" src="C_objectcardinality.gif" width="579" /><br />
<span class="caption">Figure 9.</span> Restricting the Cardinality of Object Property Expressions in OWL 2
</p>
</div>
<a id="Minimum_Cardinality" name="Minimum_Cardinality"></a><h4> <span class="mw-headline">8.3.1  Minimum Cardinality </span></h4>
<p>A minimum cardinality expression <span class="name">ObjectMinCardinality( n OPE CE )</span> consists of a nonnegative integer <span class="name">n</span>, an object property expression <span class="name">OPE</span>, and a class expression <span class="name">CE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to at least <span class="name">n</span> different individuals that are instances of <span class="name">CE</span>. If <span class="name">CE</span> is missing, it is taken to be <i>owl:Thing</i>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectMinCardinality</span>&nbsp;:= 'ObjectMinCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Man</i> <i>a:Stewie</i> )
  </td><td> Stewie is a man.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Chris</i> )
  </td><td> Peter is Chris's father.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Man</i> <i>a:Chris</i> )
  </td><td> Chris is a man.
</td></tr>
<tr valign="top"><td> DifferentIndividuals( <i>a:Chris</i> <i>a:Stewie</i> )
  </td><td> Chris and Stewie are different from each other.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Man</i> .
  </td><td> Stewie is a man.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Chris</i> .
  </td><td> Peter is Chris's father.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>rdf:type</i> <i>a:Man</i> .
  </td><td> Chris is a man.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>owl:differentFrom</i> <i>a:Stewie</i> .
  </td><td> Chris and Stewie are different from each other.
</td></tr>
</tbody></table>
<p>The following minimum cardinality expression contains those individuals that are connected by <i>a:fatherOf</i> to at least two different instances of <i>a:Man</i>:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectMinCardinality( 2 <i>a:fatherOf</i> <i>a:Man</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2">  _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minQualifiedCardinality</i> "2"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:fatherOf</i> .<br /> _:x <i>owl:onClass</i> <i>a:Man</i> .
</td></tr>
</tbody></table>
<p>Since <i>a:Stewie</i> and <i>a:Chris</i> are both instances of <i>a:Man</i> and are different from each other, <i>a:Peter</i> is classified as an instance of this class expression.
</p><p>Due to the open-world semantics, the last axiom &mdash; the one stating that <i>a:Chris</i> and <i>a:Stewie</i> are different from each other &mdash; is necessary for this inference: without this axiom, it is possible that <i>a:Chris</i> and <i>a:Stewie</i> are actually the same individual.
</p>
</div>
<a id="Maximum_Cardinality" name="Maximum_Cardinality"></a><h4> <span class="mw-headline">8.3.2  Maximum Cardinality </span></h4>
<p>A maximum cardinality expression <span class="name">ObjectMaxCardinality( n OPE CE )</span> consists of a nonnegative integer <span class="name">n</span>, an object property expression <span class="name">OPE</span>, and a class expression <span class="name">CE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to at most <span class="name">n</span> different individuals that are instances of <span class="name">CE</span>. If <span class="name">CE</span> is missing, it is taken to be <i>owl:Thing</i>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectMaxCardinality</span>&nbsp;:= 'ObjectMaxCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasPet</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> ClassAssertion( ObjectMaxCardinality( 1 <i>a:hasPet</i> ) <i>a:Peter</i> )
  </td><td> Peter has at most one pet.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasPet</i> <i>a:Brian</i> .
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> "1"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasPet</i> .
  </td><td> Peter has at most one pet.
</td></tr>
</tbody></table>
<p>The following maximum cardinality expression contains those individuals that are connected by <i>a:hasPet</i> to at most two individuals:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectMaxCardinality( 2 <i>a:hasPet</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:y <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:y <i>owl:maxCardinality</i> "2"^^<i>xsd:nonNegativeInteger</i> .<br /> _:y <i>owl:onProperty</i> <i>a:hasPet</i> .
</td></tr>
</tbody></table>
<p>Since <i>a:Peter</i> is known to be connected by <i>a:hasPet</i> to at most one individual, it is certainly also connected by <i>a:hasPet</i> to at most two individuals so, consequently, <i>a:Peter</i> is classified as an instance of this class expression.
</p><p>The example ontology explicitly names only <i>a:Brian</i> as being connected by <i>a:hasPet</i> from <i>a:Peter</i>, so one might expect <i>a:Peter</i> to be classified as an instance of the mentioned class expression even without the second axiom. This, however, is not the case due to the open-world semantics. Without the last axiom, it is possible that <i>a:Peter</i> is connected by <i>a:hasPet</i> to other individuals. The second axiom closes the set of individuals that <i>a:Peter</i> is connected to by <i>a:hasPet</i>.
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDaughter</i> <i>a:Peter</i> <i>a:Meg</i> )
  </td><td> Meg is a daughter of Peter.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDaughter</i> <i>a:Peter</i> <i>a:Megan</i> )
  </td><td> Megan is a daughter of Peter.
</td></tr>
<tr valign="top"><td> ClassAssertion( ObjectMaxCardinality( 1 <i>a:hasDaughter</i> ) <i>a:Peter</i> )
  </td><td> Peter has at most one daughter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasDaughter</i> <i>a:Meg</i> .
  </td><td> Meg is a daughter of Peter.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasDaughter</i> <i>a:Megan</i> .
  </td><td> Megan is a daughter of Peter.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> "1"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasDaughter</i> .
  </td><td> Peter has at most one daughter.
</td></tr>
</tbody></table>
<p>One might expect this ontology to be inconsistent: on the one hand, it says that <i>a:Meg</i> and <i>a:Megan</i> are connected to <i>a:Peter</i> by <i>a:hasDaughter</i>, but, on the other hand, it says that <i>a:Peter</i> is connected by <i>a:hasDaughter</i> to at most one individual. This ontology, however, is not inconsistent because the semantics of OWL 2 does not make the <i>unique name assumption</i> &mdash; that is, it does not assume distinct individuals to be necessarily different. For example, the ontology does not explicitly say that <i>a:Meg</i> and <i>a:Megan</i> are different individuals; therefore, since <i>a:Peter</i> can be connected by <i>a:hasDaughter</i> to at most one distinct individual, <i>a:Meg</i> and <i>a:Megan</i> must be the same. This example ontology thus entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SameIndividual( <i>a:Meg</i> <i>a:Megan</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>owl:sameAs</i> <i>a:Megan</i> .
</td></tr>
</tbody></table>
<p>One can axiomatize the unique name assumption in OWL 2 by explicitly stating that all individuals are different from each other. This can be done by adding the following axiom, which makes the example ontology inconsistent.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DifferentIndividuals( <i>a:Peter</i> <i>a:Meg</i> <i>a:Megan</i> )
  </td><td> Peter, Meg, and Megan are all different from each other.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> _:y <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:y <i>owl:members</i> ( <i>a:Peter</i> <i>a:Meg</i> <i>a:Megan</i> ) .
  </td><td> Peter, Meg, and Megan are all different from each other.
</td></tr>
</tbody></table>
</div>
<a id="Exact_Cardinality" name="Exact_Cardinality"></a><h4> <span class="mw-headline">8.3.3  Exact Cardinality </span></h4>
<p>An exact cardinality expression <span class="name">ObjectExactCardinality( n OPE CE )</span> consists of a nonnegative integer <span class="name">n</span>, an object property expression <span class="name">OPE</span>, and a class expression <span class="name">CE</span>, and it contains all those individuals that are connected by <span class="name">OPE</span> to exactly <span class="name">n</span> different individuals that are instances of <span class="name">CE</span>. If <span class="name">CE</span> is missing, it is taken to be <i>owl:Thing</i>. Such an expression is actually equivalent to the expression
</p>
<div class="indent">
<p><span class="name">ObjectIntersectionOf( ObjectMinCardinality( n OPE CE ) ObjectMaxCardinality( n OPE CE ) )</span>.
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ObjectExactCardinality</span>&nbsp;:= 'ObjectExactCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasPet</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion(<br /> &nbsp;&nbsp;&nbsp; ObjectAllValuesFrom( <i>a:hasPet</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectUnionOf(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectOneOf( <i>a:Brian</i> )<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectComplementOf( <i> a:Dog</i> )<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; <i>a:Peter</i><br /> )
  </td><td> Each pet of Peter is either Brian or it is not a dog.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasPet</i> <i>a:Brian</i> .
  </td><td> Brian is a pet of Peter.
</td></tr>
<tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasPet</i> .<br /> _:x <i>owl:allValuesFrom</i> _:y .<br /> _:y <i>rdf:type</i> <i>owl:Class</i> .<br /> _:y <i>owl:unionOf</i> ( _:z1 _:z2 ) .<br /> _:z1 <i>rdf:type</i> <i>owl:Class</i> .<br /> _:z1 <i>owl:oneOf</i> ( <i>a:Brian</i> ) .<br /> _:z2 <i>rdf:type</i> <i>owl:Class</i> .<br /> _:z2 <i>owl:complementOf</i> <i>a:Dog</i> .
  </td><td> Each pet of Peter is either Brian or it is not a dog.
</td></tr>
</tbody></table>
<p>The following exact cardinality expression contains those individuals that are connected by <i>a:hasPet</i> to exactly one instance of <i>a:Dog</i>; furthermore, <i>a:Peter</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectExactCardinality( 1 <i>a:hasPet</i> <i>a:Dog</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:w <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:w <i>owl:qualifiedCardinality</i> "1"^^<i>xsd:nonNegativeInteger</i> .<br /> _:w <i>owl:onProperty</i> <i>a:hasPet</i> .<br /> _:w <i>owl:onClass</i> <i>a:Dog</i> .
</td></tr>
</tbody></table>
<p>This is because the first two axioms say that <i>a:Peter</i> is connected to <i>a:Brian</i> by <i>a:hasPet</i> and that <i>a:Brian</i> is an instance of <i>a:Dog</i>, and the last axiom says that any individual different from <i>a:Brian</i> that is connected to <i>a:Peter</i> by <i>a:hasPet</i> is not an instance of <i>a:Dog</i>; hence, <i>a:Peter</i> is connected to exactly one instance of <i>a:Dog</i> by <i>a:hasPet</i>.
</p>
</div>
<a id="Data_Property_Restrictions" name="Data_Property_Restrictions"></a><h3> <span class="mw-headline">8.4  Data Property Restrictions </span></h3>
<p>Class expressions in OWL 2 can be formed by placing restrictions on data property expressions, as shown in Figure 10. These are similar to the restrictions on object property expressions, the main difference being that the expressions for existential and universal quantification allow for <i>n</i>-ary data ranges. All data ranges explicitly supported by this specification are unary; however, the provision of <i>n</i>-ary data ranges in existential and universal quantification allows OWL 2 tools to support extensions such as value comparisons and, consequently, class expressions such as "individuals whose width is greater than their height". Thus, the <span class="nonterminal">DataSomeValuesFrom</span> class expression allows for a restricted existential quantification over a list of data property expressions, and it contains those individuals that are connected through the data property expressions to at least one literal in the given data range. The <span class="nonterminal">DataAllValuesFrom</span> class expression allows for a restricted universal quantification over a list of data property expressions, and it contains those individuals that are connected through the data property expressions only to literals in the given data range. Finally, the <span class="nonterminal">DataHasValue</span> class expression contains those individuals that are connected by a data property expression to a particular literal.
</p>
<div class="image">
<p><img alt="Restricting Data Property Expressions in OWL 2" border="0" height="414" src="C_datamodal.gif" width="684" /><br />
<span class="caption">Figure 10.</span> Restricting Data Property Expressions in OWL 2
</p>
</div>
<a id="Existential_Quantification_2" name="Existential_Quantification_2"></a><h4> <span class="mw-headline">8.4.1  Existential Quantification </span></h4>
<p>An existential class expression <span class="name">DataSomeValuesFrom( DPE<sub>1</sub> ... DPE<sub>n</sub> DR )</span> consists of <span class="name">n</span> data property expressions <span class="name">DPE<sub>i</sub></span>, 1 &le; i &le; n, and a data range <span class="name">DR</span> whose arity <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be n. Such a class expression contains all those individuals that are connected by <span class="name">DPE<sub>i</sub></span> to literals <span class="name">lt<sub>i</sub></span>, 1 &le; i &le; n, such that the tuple <span class="name">( lt<sub>1</sub> , ..., lt<sub>n</sub> )</span> is in <span class="name">DR</span>. A class expression of the form <span class="name">DataSomeValuesFrom( DPE DR )</span> can be seen as a syntactic shortcut for the class expression <span class="name">DataMinCardinality( 1 DPE DR )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataSomeValuesFrom</span>&nbsp;:= 'DataSomeValuesFrom' '(' <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } <span class="nonterminal">DataRange</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:integer</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:integer</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<p>The following existential class expression contains all individuals that are connected by <i>a:hasAge</i> to an integer strictly less than 20 so; furthermore, <i>a:Meg</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataSomeValuesFrom( <i>a:hasAge</i> DatatypeRestriction( <i>xsd:integer</i> <i>xsd:maxExclusive</i> "20"^^<i>xsd:integer</i> ) )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasAge</i> .<br /> _:x <i>owl:someValuesFrom</i> _:y .<br /> _:y rdf:type rdfs:Datatype .<br /> _:y <i>owl:onDatatype</i> <i>xsd:integer</i> .<br /> _:y <i>owl:withRestrictions</i> ( _:z ) .<br /> _:z xsd:maxExclusive "20"^^xsd:integer .
</td></tr>
</tbody></table>
</div>
<a id="Universal_Quantification_2" name="Universal_Quantification_2"></a><h4> <span class="mw-headline">8.4.2  Universal Quantification </span></h4>
<p>A universal class expression <span class="name">DataAllValuesFrom( DPE<sub>1</sub> ... DPE<sub>n</sub> DR )</span> consists of <span class="name">n</span> data property expressions <span class="name">DPE<sub>i</sub></span>, 1 &le; i &le; n, and a data range <span class="name">DR</span> whose arity <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be n. Such a class expression contains all those individuals that are connected by <span class="name">DPE<sub>i</sub></span> only to literals <span class="name">lt<sub>i</sub></span>, 1 &le; i &le; n, such that each tuple <span class="name">( lt<sub>1</sub> , ..., lt<sub>n</sub> )</span> is in <span class="name">DR</span>. A class expression of the form <span class="name">DataAllValuesFrom( DPE DR )</span> can be seen as a syntactic shortcut for the class expression <span class="name">DataMaxCardinality( 0 DPE DataComplementOf( DR ) )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataAllValuesFrom</span>&nbsp;:= 'DataAllValuesFrom' '(' <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } <span class="nonterminal">DataRange</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasZIP</i> _:a1 "02903"^^<i>xsd:integer</i> )
  </td><td> The ZIP code of _:a1 is the integer 02903.
</td></tr>
<tr valign="top"><td> FunctionalDataProperty( <i>a:hasZIP</i> )
  </td><td> Each object can have at most one ZIP code.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> _:a1 <i>a:hasZIP</i> "02903"^^<i>xsd:integer</i>
  </td><td> The ZIP code of _:a1 is the integer 02903.
</td></tr>
<tr valign="top"><td> <i>a:hasZIP</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one ZIP code.
</td></tr>
</tbody></table>
<p>In United Kingdom and Canada, ZIP codes are strings (i.e., they can contain characters and not just numbers). Hence, one might use the following universal expression to identify those individuals that have only integer ZIP codes (and therefore have non-UK and non-Canadian addresses):
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataAllValuesFrom( <i>a:hasZIP</i> <i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasZIP</i> .<br /> _:x <i>owl:allValuesFrom</i> <i>xsd:integer</i> .
</td></tr>
</tbody></table>
<p>The anonymous individual _:a1 is by the first axiom connected by <i>a:hasZIP</i> to an integer, and the second axiom ensures that _:a1 is not connected by <i>a:hasZIP</i> to other literals; therefore, _:a1 is classified as an instance of the mentioned class expression.
</p><p>The last axiom &mdash; the one stating that <i>a:hasZIP</i> is functional &mdash; is critical for the inference from the previous paragraph due to the open-world semantics of OWL 2. Without this axiom, the ontology is not guaranteed to list all literals that _:a1 is connected to by <i>a:hasZIP</i>; hence, without this axiom _:a1 would not be classified as an instance of the mentioned class expression.
</p>
</div>
<a id="Literal_Value_Restriction" name="Literal_Value_Restriction"></a><h4> <span class="mw-headline">8.4.3  Literal Value Restriction </span></h4>
<p>A has-value class expression <span class="name">DataHasValue( DPE lt )</span> consists of a data property expression <span class="name">DPE</span> and a literal <span class="name">lt</span>, and it contains all those individuals that are connected by <span class="name">DPE</span> to <span class="name">lt</span>. Each such class expression can be seen as a syntactic shortcut for the class expression <span class="name">DataSomeValuesFrom( DPE DataOneOf( lt ) )</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataHasValue</span>&nbsp;:= 'DataHasValue' '(' <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">Literal</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:integer</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:integer</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<p>The following has-value expression contains all individuals that are connected by <i>a:hasAge</i> to the integer 17; furthermore, <i>a:Meg</i> is classified as its instance:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataHasValue( <i>a:hasAge</i> "17"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasAge</i> .<br /> _:x <i>owl:hasValue</i> "17"^^<i>xsd:integer</i> .
</td></tr>
</tbody></table>
</div>
<a id="Data_Property_Cardinality_Restrictions" name="Data_Property_Cardinality_Restrictions"></a><h3> <span class="mw-headline">8.5  Data Property Cardinality Restrictions </span></h3>
<p>Class expressions in OWL 2 can be formed by placing restrictions on the cardinality of data property expressions, as shown in Figure 11. These are similar to the restrictions on the cardinality of object property expressions. All cardinality restrictions can be qualified or unqualified: in the former case, the cardinality restriction only applies to literals that are connected by the data property expression and are in the qualifying data range; in the latter case it applies to all literals that are connected by the data property expression (this is equivalent to the qualified case with the qualifying data range equal to <i>rdfs:Literal</i>). The class expressions <span class="nonterminal">DataMinCardinality</span>, <span class="nonterminal">DataMaxCardinality</span>, and <span class="nonterminal">DataExactCardinality</span> contain those individuals that are connected by a data property expression to at least, at most, and exactly a given number of literals in the specified data range, respectively.
</p>
<div class="image">
<p><img alt="Restricting the Cardinality of Data Property Expressions in OWL 2" border="0" height="507" src="C_datacardinality.gif" width="619" /><br />
<span class="caption">Figure 11.</span> Restricting the Cardinality of Data Property Expressions in OWL 2
</p>
</div>
<a id="Minimum_Cardinality_2" name="Minimum_Cardinality_2"></a><h4> <span class="mw-headline">8.5.1  Minimum Cardinality </span></h4>
<p>A minimum cardinality expression <span class="name">DataMinCardinality( n DPE DR )</span> consists of a nonnegative integer <span class="name">n</span>, a data property expression <span class="name">DPE</span>, and a unary data range <span class="name">DR</span>, and it contains all those individuals that are connected by <span class="name">DPE</span> to at least <span class="name">n</span> different literals in <span class="name">DR</span>. If <span class="name">DR</span> is not present, it is taken to be <i>rdfs:Literal</i>. 
</p>
<div class="grammar">
<p><span class="nonterminal">DataMinCardinality</span>&nbsp;:= 'DataMinCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Meg</i> "Meg Griffin" )
  </td><td>Meg's name is <span class="name">"Meg Griffin"</span>.</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Meg</i> "Megan Griffin" )
  </td><td>Meg's name is <span class="name">"Megan Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>a:hasName</i> "Meg Griffin" .
  </td><td>Meg's name is <span class="name">"Meg Griffin"</span>.</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasName</i> "Megan Griffin" .
  </td><td>Meg's name is <span class="name">"Megan Griffin"</span>.</td></tr>
</tbody></table>
<p>The following minimum cardinality expression contains those individuals that are connected by <i>a:hasName</i> to at least two different literals:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataMinCardinality( 2 <i>a:hasName</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:minCardinality</i> "2"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasName</i> .
</td></tr>
</tbody></table>
<p>Different string literals are distinct, so <span class="name">"Meg Griffin"</span> and <span class="name">"Megan Griffin"</span> are different; thus, the individual <i>a:Meg</i> is classified as an instance of the mentioned class expression.
</p>
</div>
<p>Note that some datatypes from the OWL 2 datatype map distinguish between equal and identical data values, and that the semantics of cardinality restrictions in OWL 2 is defined with respect to the latter. For an example demonstrating the effects such such a definition, please refer to <a href="#Functional_Data_Properties" title="">Section 9.3.6</a>.
</p>
<a id="Maximum_Cardinality_2" name="Maximum_Cardinality_2"></a><h4> <span class="mw-headline">8.5.2  Maximum Cardinality </span></h4>
<p>A maximum cardinality expression <span class="name">DataMaxCardinality( n DPE DR )</span> consists of a nonnegative integer <span class="name">n</span>, a data property expression <span class="name">DPE</span>, and a unary data range <span class="name">DR</span>, and it contains all those individuals that are connected by <span class="name">DPE</span> to at most <span class="name">n</span> different literals in <span class="name">DR</span>. If <span class="name">DR</span> is not present, it is taken to be <i>rdfs:Literal</i>. 
</p>
<div class="grammar">
<p><span class="nonterminal">DataMaxCardinality</span>&nbsp;:= 'DataMaxCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalDataProperty( <i>a:hasName</i> )
  </td><td> Each object can have at most one name.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasName</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one name.
</td></tr>
</tbody></table>
<p>The following maximum cardinality expression contains those individuals that are connected by <i>a:hasName</i> to at most two different literals:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataMaxCardinality( 2 <i>a:hasName</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:maxCardinality</i> "2"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasName</i> .
</td></tr>
</tbody></table>
<p>Since the ontology axiom restricts <i>a:hasName</i> to be functional, all individuals in the ontology are instances of this class expression.
</p>
</div>
<p>Note that some datatypes from the OWL 2 datatype map distinguish between equal and identical data values, and that the semantics of cardinality restrictions in OWL 2 is defined with respect to the latter. For an example demonstrating the effects such such a definition, please refer to <a href="#Functional_Data_Properties" title="">Section 9.3.6</a>.
</p>
<a id="Exact_Cardinality_2" name="Exact_Cardinality_2"></a><h4> <span class="mw-headline">8.5.3  Exact Cardinality </span></h4>
<p>An exact cardinality expression <span class="name">DataExactCardinality( n DPE DR )</span> consists of a nonnegative integer <span class="name">n</span>, a data property expression <span class="name">DPE</span>, and a unary data range <span class="name">DR</span>, and it contains all those individuals that are connected by <span class="name">DPE</span> to exactly <span class="name">n</span> different literals in <span class="name">DR</span>. If <span class="name">DR</span> is not present, it is taken to be <i>rdfs:Literal</i>. 
</p>
<div class="grammar">
<p><span class="nonterminal">DataExactCardinality</span>&nbsp;:= 'DataExactCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Brian</i> "Brian Griffin" )
  </td><td>Brian's name is <span class="name">"Brian Griffin"</span>.</td></tr>
<tr valign="top"><td> FunctionalDataProperty( <i>a:hasName</i> )
  </td><td> Each object can have at most one name.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>a:hasName</i> "Brian Griffin" .
  </td><td>Brian's name is <span class="name">"Brian Griffin"</span>.</td></tr>
<tr valign="top"><td> <i>a:hasName</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one name.
</td></tr>
</tbody></table>
<p>The following exact cardinality expression contains those individuals that are connected by <i>a:hasName</i> to exactly one literal:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataExactCardinality( 1 <i>a:hasName</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:cardinality</i> "1"^^<i>xsd:nonNegativeInteger</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasName</i> .
</td></tr>
</tbody></table>
<p>Since the ontology axiom restricts <i>a:hasName</i> to be functional and <i>a:Brian</i> is connected by <i>a:hasName</i> to <span class="name">"Brian Griffin"</span>, it is classified as an instance of this class expression.
</p>
</div>
<p>Note that some datatypes from the OWL 2 datatype map distinguish between equal and identical data values, and that the semantics of cardinality restrictions in OWL 2 is defined with respect to the latter. For an example demonstrating the effects such such a definition, please refer to <a href="#Functional_Data_Properties" title="">Section 9.3.6</a>.
</p>
<a id="Axioms" name="Axioms"></a><h2> <span class="mw-headline">9  Axioms </span></h2>
<p>The main component of an OWL 2 ontology is a set of <span id="def_axiom"><i>axioms</i></span> &mdash; statements that say what is true in the domain. OWL 2 provides an extensive set of axioms, all of which extend the <span class="nonterminal">Axiom</span> class in the structural specification. As shown in Figure 12, axioms in OWL 2 can be declarations, axioms about classes, axioms about object or data properties, datatype definitions, keys, assertions (sometimes also called <i>facts</i>), and axioms about annotations.
</p>
<div class="image">
<p><img alt="The Axioms of OWL 2" border="0" height="277" src="Axioms.gif" width="595" /><br />
<span class="caption">Figure 12.</span> The Axioms of OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">Axiom</span>&nbsp;:= <span class="nonterminal">Declaration</span> | <span class="nonterminal">ClassAxiom</span> | <span class="nonterminal">ObjectPropertyAxiom</span> | <span class="nonterminal">DataPropertyAxiom</span> | <span class="nonterminal">DatatypeDefinition</span> | <span class="nonterminal">HasKey</span> | <span class="nonterminal">Assertion</span> | <span class="nonterminal">AnnotationAxiom</span><br />
<br />
<span class="nonterminal">axiomAnnotations</span>&nbsp;:= { <span class="nonterminal">Annotation</span> }
</p>
</div>
<p>As shown in Figure 1, OWL 2 axioms can contain axiom annotations, the structure of which is defined in <a href="#Annotations" title="">Section 10</a>. Axiom annotations have no effect on the semantics of axioms &mdash; that is, they do not affect the logical consequences of OWL 2 ontologies. In contrast, axiom annotations do affect structural equivalence: axioms will not be structurally equivalent if their axiom annotations are not structurally equivalent.
</p>
<div class="anexample">
<p>The following axiom contains a comment that explains the purpose of the axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SubClassOf( Annotation( <i>rdfs:comment</i> "Male people are people." ) <i>a:Man</i> <i>a:Person</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Man</i> <i>rdfs:subClassOf</i> <i>a:Person</i><br /> _:x <i>rdf:type</i> <i>owl:Annotation</i> .<br /> _:x <i>owl:annotatedSource</i> <i>a:Man</i> .<br /> _:x <i>owl:annotatedProperty</i> <i>rdfs:subClassOf</i> .<br /> _:x <i>owl:annotatedTarget</i> <i>a:Person</i> .<br /> _:x <i>rdfs:comment</i> "Male people are people." .
</td></tr>
</tbody></table>
<p>Since annotations affect structural equivalence between axioms, the previous axiom is not structurally equivalent with the following axiom, even though these two axioms are semantically equivalent.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SubClassOf( <i>a:Man</i> <i>a:Person</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Man</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
</div>
<a id="Class_Expression_Axioms" name="Class_Expression_Axioms"></a><h3> <span class="mw-headline">9.1  Class Expression Axioms </span></h3>
<p>OWL 2 provides axioms that allow relationships to be established between class expressions, as shown in Figure 13. The <span class="nonterminal">SubClassOf</span> axiom allows one to state that each instance of one class expression is also an instance of another class expression, and thus to construct a hierarchy of classes. The <span class="nonterminal">EquivalentClasses</span> axiom allows one to state that several class expressions are equivalent to each other. The <span class="nonterminal">DisjointClasses</span> axiom allows one to state that several class expressions are pairwise disjoint &mdash; that is, that they have no instances in common. Finally, the <span class="nonterminal">DisjointUnion</span> class expression allows one to define a class as a disjoint union of several class expressions and thus to express covering constraints.
</p>
<div class="image">
<p><img alt="The Class Axioms of OWL 2" border="0" height="550" src="A_classes.gif" width="549" /><br />
<span class="caption">Figure 13.</span> The Class Axioms of OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ClassAxiom</span>&nbsp;:= <span class="nonterminal">SubClassOf</span> | <span class="nonterminal">EquivalentClasses</span> | <span class="nonterminal">DisjointClasses</span> | <span class="nonterminal">DisjointUnion</span>
</p>
</div>
<a id="Subclass_Axioms" name="Subclass_Axioms"></a><h4> <span class="mw-headline">9.1.1  Subclass Axioms </span></h4>
<p>A subclass axiom <span class="name">SubClassOf( CE<sub>1</sub> CE<sub>2</sub> )</span> states that the class expression <span class="name">CE<sub>1</sub></span> is a subclass of the class expression <span class="name">CE<sub>2</sub></span>. Roughly speaking, this states that <span class="name">CE<sub>1</sub></span> is more specific than <span class="name">CE<sub>2</sub></span>. Subclass axioms are a fundamental type of axioms in OWL 2 and can be used to construct a class hierarchy. Other kinds of class expression axiom can be seen as syntactic shortcuts for one or more subclass axioms.
</p>
<div class="grammar">
<p><span class="nonterminal">SubClassOf</span>&nbsp;:= 'SubClassOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subClassExpression</span> <span class="nonterminal">superClassExpression</span> ')'<br />
<span class="nonterminal">subClassExpression</span>&nbsp;:= <span class="nonterminal">ClassExpression</span><br />
<span class="nonterminal">superClassExpression</span>&nbsp;:= <span class="nonterminal">ClassExpression</span>
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubClassOf( <i>a:Baby</i> <i>a:Child</i> )
  </td><td> Each baby is a child.
</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Child</i> <i>a:Person</i> )
  </td><td> Each child is a person.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Baby</i> <i>a:Stewie</i> )
  </td><td> Stewie is a baby.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Baby</i> <i>rdfs:subClassOf</i> <i>a:Child</i> .
  </td><td> Each baby is a child.
</td></tr>
<tr valign="top"><td> <i>a:Child</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
  </td><td> Each child is a person.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Baby</i> .
  </td><td> Stewie is a baby.
</td></tr>
</tbody></table>
<p>Since <i>a:Stewie</i> is an instance of <i>a:Baby</i>, by the first subclass axiom <i>a:Stewie</i> is classified as an instance of <i>a:Child</i> as well. Similarly, by the second subclass axiom <i>a:Stewie</i> is classified as an instance of <i>a:Person</i>. This style of reasoning can be applied to any instance of <i>a:Baby</i> and not just <i>a:Stewie</i>; therefore, one can conclude that <i>a:Baby</i> is a subclass of <i>a:Person</i>. In other words, this ontology entails the following axiom:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SubClassOf( <i>a:Baby</i> <i>a:Person</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Baby</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubClassOf( <i>a:PersonWithChild</i><br /> &nbsp;&nbsp;&nbsp; ObjectSomeValuesFrom( <i>a:hasChild</i> ObjectUnionOf( <i>a:Boy</i> <i>a:Girl</i> ) )<br /> )
  </td><td> A person that has a child has either at least one boy or a girl.
</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Boy</i> <i>a:Child</i> )
  </td><td> Each boy is a child.
</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Girl</i> <i>a:Child</i> )
  </td><td> Each girl is a child.
</td></tr>
<tr valign="top"><td> SubClassOf( ObjectSomeValuesFrom( <i>a:hasChild</i> <i>a:Child</i>  ) <i>a:Parent</i> )
  </td><td> If some object has a child, then this object is a parent.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:PersonWithChild</i> <i>rdfs:subClassOf</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br />  _:x <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:x <i>owl:someValuesFrom</i> _:y .<br /> _:y <i>rdf:type</i> <i>owl:Class</i> .<br /> _:y <i>owl:unionOf</i> ( <i>a:Boy</i> <i>a:Girl</i> ) .
  </td><td> A person that has a child has either at least one boy or a girl.
</td></tr>
<tr valign="top"><td> <i>a:Boy</i> <i>rdfs:subClassOf</i> <i>a:Child</i> .
  </td><td> Each boy is a child.
</td></tr>
<tr valign="top"><td> <i>a:Girl</i> <i>rdfs:subClassOf</i> <i>a:Child</i> .
  </td><td> Each girl is a child.
</td></tr>
<tr valign="top"><td> _:z <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:z <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:z <i>owl:someValuesFrom</i> <i>a:Child</i> .<br /> _:z <i>rdfs:subClassOf</i> <i>a:Parent</i> .
  </td><td> If some object has a child, then this object is a parent.
</td></tr>
</tbody></table>
<p>The first axiom states that each instance of <i>a:PersonWithChild</i> is connected to an individual that is an instance of either <i>a:Boy</i> or <i>a:Girl</i>. (Because of the open-world semantics of OWL 2, this does not mean that there must be only one such individual or that all such individuals must be instances of either <i>a:Boy</i> or of <i>a:Girl</i>.) Furthermore, each instance of <i>a:Boy</i> or <i>a:Girl</i> is an instance of <i>a:Child</i>. Finally, the last axiom says that all individuals that are connected by <i>a:hasChild</i> to an instance of <i>a:Child</i> are instances of <i>a:Parent</i>. Since this reasoning holds for each instance of <i>a:PersonWithChild</i>, each such instance is also an instance of <i>a:Parent</i>. In other words, this ontology entails the following axiom:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SubClassOf( <i>a:PersonWithChild</i> <i>a:Parent</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:PersonWithChild</i> <i>rdfs:subClassOf</i> <i>a:Parent</i> .
</td></tr>
</tbody></table>
</div>
<a id="Equivalent_Classes" name="Equivalent_Classes"></a><h4> <span class="mw-headline">9.1.2  Equivalent Classes </span></h4>
<p>An equivalent classes axiom <span class="name">EquivalentClasses( CE<sub>1</sub> ... CE<sub>n</sub> )</span> states that all of the class expressions <span class="name">CE<sub>i</sub></span>, 1 &le; i &le; n, are semantically equivalent to each other. This axiom allows one to use each <span class="name">CE<sub>i</sub></span> as a synonym for each <span class="name">CE<sub>j</sub></span> &mdash; that is, in any expression in the ontology containing such an axiom, <span class="name">CE<sub>i</sub></span> can be replaced with <span class="name">CE<sub>j</sub></span> without affecting the meaning of the ontology. An axiom <span class="name">EquivalentClasses( CE<sub>1</sub> CE<sub>2</sub> )</span> is equivalent to the following two axioms:
</p>
<div class="indent">
<p><span class="name">SubClassOf( CE<sub>1</sub> CE<sub>2</sub> )</span><br />
<span class="name">SubClassOf( CE<sub>2</sub> CE<sub>1</sub> )</span>
</p>
</div>
<p>Axioms of the form <span class="name">EquivalentClasses( C CE )</span>, where <span class="name">C</span> is a class and <span class="name">CE</span> is a class expression, are often called <i>definitions</i>, because they define the class <span class="name">C</span> in terms of the class expression <span class="name">CE</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">EquivalentClasses</span>&nbsp;:= 'EquivalentClasses' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> EquivalentClasses( <i>a:Boy</i> ObjectIntersectionOf( <i>a:Child</i> <i>a:Man</i> ) )
  </td><td> A boy is a male child.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Child</i> <i>a:Chris</i> )
  </td><td> Chris is a child.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Man</i> <i>a:Chris</i> )
  </td><td> Chris is a man.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Boy</i> <i>a:Stewie</i> )
  </td><td> Stewie is a boy.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Boy</i> <i>owl:equivalentClass</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:intersectionOf</i> ( <i>a:Child</i> <i>a:Man</i> ) .
  </td><td> A boy is a male child.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>rdf:type</i> <i>a:Child</i> .
  </td><td> Chris is a child.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>rdf:type</i> <i>a:Man</i> .
  </td><td> Chris is a man.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Boy</i> .
  </td><td> Stewie is a boy.
</td></tr>
</tbody></table>
<p>The first axiom defines the class <i>a:Boy</i> as an intersection of the classes <i>a:Child</i> and <i>a:Man</i>; thus, the instances of <i>a:Boy</i> are exactly those instances that are both an instance of <i>a:Child</i> and an instance of <i>a:Man</i>. Such a definition consists of two directions. The first direction implies that each instance of <i>a:Child</i> and <i>a:Man</i> is an instance of <i>a:Boy</i>; since <i>a:Chris</i> satisfies these two conditions, it is classified as an instance of <i>a:Boy</i>. The second direction implies that each <i>a:Boy</i> is an instance of <i>a:Child</i> and of <i>a:Man</i>; thus, <i>a:Stewie</i> is classified as an instance of <i>a:Man</i> and of <i>a:Boy</i>.
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> EquivalentClasses( <i>a:MongrelOwner</i> ObjectSomeValuesFrom( <i>a:hasPet</i> <i>a:Mongrel</i> ) )
  </td><td> A mongrel owner has a pet that is a mongrel.
</td></tr>
<tr valign="top"><td> EquivalentClasses( <i>a:DogOwner</i> ObjectSomeValuesFrom( <i>a:hasPet</i> <i>a:Dog</i> ) )
  </td><td> A dog owner has a pet that is a dog.
</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Mongrel</i> <i>a:Dog</i> )
  </td><td> Each mongrel is a dog.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:MongrelOwner</i> <i>a:Peter</i> )
  </td><td> Peter is a mongrel owner.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:MongrelOwner</i> <i>owl:equivalentClass</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasPet</i> .<br /> _:x <i>owl:someValuesFrom</i> <i>a:Mongrel</i> .
  </td><td> A mongrel owner has a pet that is a mongrel.
</td></tr>
<tr valign="top"><td> <i>a:DogOwner</i> <i>owl:equivalentClass</i> _:y .<br /> _:y <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:y <i>owl:onProperty</i> <i>a:hasPet</i> .<br /> _:y <i>owl:someValuesFrom</i> <i>a:Dog</i> .
  </td><td> A dog owner has a pet that is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Mongrel</i> <i>rdfs:subClassOf</i> <i>a:Dog</i> .
  </td><td> Each mongrel is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:MongrelOwner</i> .
  </td><td> Peter is a mongrel owner.
</td></tr>
</tbody></table>
<p>By the first axiom, each instance <span class="name">x</span> of <i>a:MongrelOwner</i> must be connected via  <i>a:hasPet</i> to an instance of <i>a:Mongrel</i>; by the third axiom, this individual is an instance of <i>a:Dog</i>; thus, by the second axiom, <span class="name">x</span> is an instance of <i>a:DogOwner</i>. In other words, this ontology entails the following axiom:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SubClassOf( <i>a:MongrelOwner</i> <i>a:DogOwner</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:MongrelOwner</i> <i>rdfs:subClassOf</i> <i>a:DogOwner</i> .
</td></tr>
</tbody></table>
<p>By the fourth axiom, <i>a:Peter</i> is then classified as an instance of <i>a:DogOwner</i>.
</p>
</div>
<a id="Disjoint_Classes" name="Disjoint_Classes"></a><h4> <span class="mw-headline">9.1.3  Disjoint Classes </span></h4>
<p>A disjoint classes axiom <span class="name">DisjointClasses( CE<sub>1</sub> ... CE<sub>n</sub> )</span> states that all of the class expressions <span class="name">CE<sub>i</sub></span>, 1 &le; i &le; n, are pairwise disjoint; that is, no individual can be at the same time an instance of both <span class="name">CE<sub>i</sub></span> and <span class="name">CE<sub>j</sub></span> for i &ne; j. An axiom <span class="name">DisjointClasses( CE<sub>1</sub> CE<sub>2</sub> )</span> is equivalent to the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( CE<sub>1</sub> ObjectComplementOf( CE<sub>2</sub> ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DisjointClasses</span>&nbsp;:= 'DisjointClasses' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DisjointClasses( <i>a:Boy</i> <i>a:Girl</i> )
  </td><td> Nothing can be both a boy and a girl.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Boy</i> <i>a:Stewie</i> )
  </td><td> Stewie is a boy.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Boy</i> <i>owl:disjointWith</i> <i>a:Girl</i> .
  </td><td> Nothing can be both a boy and a girl.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Boy</i> .
  </td><td> Stewie is a boy.
</td></tr>
</tbody></table>
<p>The axioms in this ontology imply that <i>a:Stewie</i> can be classified as an instance of the following class expression:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectComplementOf( <i>a:Girl</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> <i>a:Girl</i> .
</td></tr>
</tbody></table>
<p>Furthermore, if the ontology were extended with the following assertion, the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Girl</i> <i>a:Stewie</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Girl</i> .
</td></tr>
</tbody></table>
</div>
<a id="Disjoint_Union_of_Class_Expressions" name="Disjoint_Union_of_Class_Expressions"></a><h4> <span class="mw-headline">9.1.4  Disjoint Union of Class Expressions </span></h4>
<p>A disjoint union axiom <span class="name">DisjointUnion( C CE<sub>1</sub> ... CE<sub>n</sub> )</span> states that a class <span class="name">C</span> is a disjoint union of the class expressions <span class="name">CE<sub>i</sub></span>, 1 &le; i &le; n, all of which are pairwise disjoint. Such axioms are sometimes referred to as <i>covering</i> axioms, as they state that the extensions of all <span class="name">CE<sub>i</sub></span> exactly cover the extension of <span class="name">C</span>. Thus, each instance of <span class="name">C</span> is an instance of exactly one <span class="name">CE<sub>i</sub></span>, and each instance of <span class="name">CE<sub>i</sub></span> is an instance of <span class="name">C</span>. Each such axiom can be seen as a syntactic shortcut for the following two axioms:
</p>
<div class="indent">
<p><span class="name">EquivalentClasses( C ObjectUnionOf( CE<sub>1</sub> ... CE<sub>n</sub> ) )</span><br /> <span class="name">DisjointClasses( CE<sub>1</sub> ... CE<sub>n</sub> )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DisjointUnion</span>&nbsp;:= 'DisjointUnion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Class</span> <span class="nonterminal">disjointClassExpressions</span> ')'<br />
<span class="nonterminal">disjointClassExpressions</span>&nbsp;:= <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> }
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DisjointUnion( <i>a:Child</i> <i>a:Boy</i> <i>a:Girl</i> )
  </td><td> Each child is either a boy or a girl, each boy is a child, each girl is a child, and nothing can be both a boy and a girl.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Child</i> <i>a:Stewie</i> )
  </td><td> Stewie is a child.
</td></tr>
<tr valign="top"><td> ClassAssertion( ObjectComplementOf( <i>a:Girl</i> ) <i>a:Stewie</i> )
  </td><td> Stewie is not a girl.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Child</i> <i>owl:disjointUnionOf</i> ( <i>a:Boy</i> <i>a:Girl</i> ) .
  </td><td> Each child is either a boy or a girl, each boy is a child, each girl is a child, and nothing can be both a boy and a girl.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> <i>a:Child</i> .
  </td><td> Stewie is a child.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Class</i> .<br /> _:x <i>owl:complementOf</i> <i>a:Girl</i> .
  </td><td> Stewie is not a girl.
</td></tr>
</tbody></table>
<p>By the first two axioms, <i>a:Stewie</i> is either an instance of <i>a:Boy</i> or <i>a:Girl</i>. The last assertion eliminates the second possibility, so <i>a:Stewie</i> is classified as an instance of <i>a:Boy</i>.
</p>
</div>
<a id="Object_Property_Axioms" name="Object_Property_Axioms"></a><h3> <span class="mw-headline">9.2  Object Property Axioms </span></h3>
<p>OWL 2 provides axioms that can be used to characterize and establish relationships between object property expressions. For clarity, the structure of these axioms is shown in two separate figures, Figure 14 and Figure 15. The <span class="nonterminal">SubObjectPropertyOf</span> axiom allows one to state that the extension of one object property expression is included in the extension of another object property expression. The <span class="nonterminal">EquivalentObjectProperties</span> axiom allows one to state that the extensions of several object property expressions are the same. The <span class="nonterminal">DisjointObjectProperties</span> axiom allows one to state that the extensions of several object property expressions are pairwise disjoint &mdash; that is, that they do not share pairs of connected individuals. The <span class="nonterminal">InverseObjectProperties</span> axiom can be used to state that two object property expressions are the inverse of each other. The <span class="nonterminal">ObjectPropertyDomain</span> and <span class="nonterminal">ObjectPropertyRange</span> axioms can be used to restrict the first and the second individual, respectively, connected by an object property expression to be instances of the specified class expression.
</p>
<div class="image">
<p><img alt="Object Property Axioms in OWL 2, Part I" border="0" height="618" src="A_objectproperty1.gif" width="960" /><br />
<span class="caption">Figure 14.</span> Object Property Axioms in OWL 2, Part I
</p>
</div>
<p>The <span class="nonterminal">FunctionalObjectProperty</span> axiom allows one to state that an object property expression is functional &mdash; that is, that each individual can have at most one outgoing connection of the specified object property expression. The <span class="nonterminal">InverseFunctionalObjectProperty</span> axiom allows one to state that an object property expression is inverse-functional &mdash; that is, that each individual can have at most one incoming connection of the specified object property expression. Finally, the <span class="nonterminal">ReflexiveObjectProperty</span>, <span class="nonterminal">IrreflexiveObjectProperty</span>, <span class="nonterminal">SymmetricObjectProperty</span>, <span class="nonterminal">AsymmetricObjectProperty</span>, and <span class="nonterminal">TransitiveObjectProperty</span> axioms allow one to state that an object property expression is reflexive, irreflexive, symmetric, asymmetric, or transitive, respectively.
</p>
<div class="image">
<p><img alt="Axioms Defining Characteristics of Object Properties in OWL 2, Part II" border="0" height="615" src="A_objectproperty2.gif" width="943" /><br />
<span class="caption">Figure 15.</span> Axioms Defining Characteristics of Object Properties in OWL 2, Part II
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ObjectPropertyAxiom</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SubObjectPropertyOf</span> | <span class="nonterminal">EquivalentObjectProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DisjointObjectProperties</span> | <span class="nonterminal">InverseObjectProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectPropertyDomain</span> | <span class="nonterminal">ObjectPropertyRange</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">FunctionalObjectProperty</span> | <span class="nonterminal">InverseFunctionalObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ReflexiveObjectProperty</span> | <span class="nonterminal">IrreflexiveObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SymmetricObjectProperty</span> | <span class="nonterminal">AsymmetricObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">TransitiveObjectProperty</span>
</p>
</div>
<a id="Object_Subproperties" name="Object_Subproperties"></a><h4> <span class="mw-headline">9.2.1  Object Subproperties </span></h4>
<p>Object subproperty axioms are analogous to subclass axioms, and they come in two forms.
</p><p>The basic form is <span class="name" id="a_SubObjectPropertyOf">SubObjectPropertyOf( OPE<sub>1</sub> OPE<sub>2</sub> )</span>. This axiom states that the object property expression <span class="name">OPE<sub>1</sub></span> is a subproperty of the object property expression <span class="name">OPE<sub>2</sub></span> &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">OPE<sub>1</sub></span> to an individual <span class="name">y</span>, then <span class="name">x</span> is also connected by <span class="name">OPE<sub>2</sub></span> to <span class="name">y</span>.
</p><p>The more complex form is <span class="name" id="a_SubObjectPropertyOfChain">SubObjectPropertyOf( ObjectPropertyChain( OPE<sub>1</sub> ... OPE<sub>n</sub> ) OPE )</span>. This axiom states that, if an individual <span class="name">x</span> is connected by a sequence of object property expressions <span class="name">OPE<sub>1</sub></span>, ..., <span class="name">OPE<sub>n</sub></span> with an individual <span class="name">y</span>, then <span class="name">x</span> is also connected with <span class="name">y</span> by the object property expression <span class="name">OPE</span>. Such axioms are also known as <i>complex role inclusions</i> [<cite><a href="#ref-sroiq" title="">SROIQ</a></cite>].
</p>
<div class="grammar">
<p><span class="nonterminal">SubObjectPropertyOf</span>&nbsp;:= 'SubObjectPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subObjectPropertyExpression</span> <span class="nonterminal">superObjectPropertyExpression</span> ')'<br />
<span class="nonterminal">subObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectPropertyExpression</span> | <span class="nonterminal">propertyExpressionChain</span><br />
<span class="nonterminal">propertyExpressionChain</span>&nbsp;:= 'ObjectPropertyChain' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'<br />
<span class="nonterminal">superObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectPropertyExpression</span>
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( <i>a:hasDog</i> <i>a:hasPet</i> )
  </td><td> Having a dog implies having a pet.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDog</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasDog</i> <i>rdfs:subPropertyOf</i> <i>a:hasPet</i> .
  </td><td> Having a dog implies having a pet.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasDog</i> <i>a:Brian</i> .
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<p>Since <i>a:hasDog</i> is a subproperty of <i>a:hasPet</i>, each tuple of individuals connected by the former property expression is also connected by the latter property expression. Therefore, this ontology entails that <i>a:Peter</i> is connected to <i>a:Brian</i> by <i>a:hasPet</i>; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasPet</i> <i>a:Peter</i> <i>a:Brian</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:hasPet</i> <i>a:Brian</i> .
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasMother</i> <i>a:hasSister</i> ) <i>a:hasAunt</i> )
  </td><td> The sister of someone's mother is that person's aunt.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasMother</i> <i>a:Stewie</i> <i>a:Lois</i> )
  </td><td> Lois is the mother of Stewie.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasSister</i> <i>a:Lois</i> <i>a:Carol</i> )
  </td><td> Carol is a sister of Lois.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasAunt</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasMother</i> <i>a:hasSister</i> ) .
  </td><td> The sister of someone's mother is that person's aunt.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasMother</i> <i>a:Lois</i> .
  </td><td> Lois is the mother of Stewie.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>a:hasSister</i> <i>a:Carol</i> .
  </td><td> Carol is a sister of Lois.
</td></tr>
</tbody></table>
<p>The axioms in this ontology imply that <i>a:Stewie</i> is connected by <i>a:hasAunt</i> with <i>a:Carol</i>; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasAunt</i> <i>a:Stewie</i> <i>a:Carol</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Stewie</i> <i>a:hasAunt</i> <i>a:Carol</i> .
</td></tr>
</tbody></table>
</div>
<a id="Equivalent_Object_Properties" name="Equivalent_Object_Properties"></a><h4> <span class="mw-headline">9.2.2  Equivalent Object Properties </span></h4>
<p>An equivalent object properties axiom <span class="name">EquivalentObjectProperties( OPE<sub>1</sub> ... OPE<sub>n</sub> )</span> states that all of the object property expressions <span class="name">OPE<sub>i</sub></span>, 1 &le; i &le; n, are semantically equivalent to each other. This axiom allows one to use each <span class="name">OPE<sub>i</sub></span> as a synonym for each <span class="name">OPE<sub>j</sub></span> &mdash; that is, in any expression in the ontology containing such an axiom, <span class="name">OPE<sub>i</sub></span> can be replaced with <span class="name">OPE<sub>j</sub></span> without affecting the meaning of the ontology. The axiom <span class="name">EquivalentObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )</span> is equivalent to the following two axioms:
</p>
<div class="indent">
<p><span class="name">SubObjectPropertyOf( OPE<sub>1</sub> OPE<sub>2</sub> )</span><br />
<span class="name">SubObjectPropertyOf( OPE<sub>2</sub> OPE<sub>1</sub> )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">EquivalentObjectProperties</span>&nbsp;:= 'EquivalentObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> EquivalentObjectProperties( <i>a:hasBrother</i> <i>a:hasMaleSibling</i> )
  </td><td> Having a brother is the same as having a male sibling.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasBrother</i> <i>a:Chris</i> <i>a:Stewie</i> )
  </td><td> Stewie is a brother of Chris.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasMaleSibling</i> <i>a:Stewie</i> <i>a:Chris</i> )
  </td><td> Chris is a male sibling of Stewie.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasBrother</i> <i>owl:equivalentProperty</i> <i>a:hasMaleSibling</i> .
  </td><td> Having a brother is the same as having a male sibling.
</td></tr>
<tr valign="top"><td> <i>a:Chris</i> <i>a:hasBrother</i> <i>a:Stewie</i> .
  </td><td> Stewie is a brother of Chris.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasMaleSibling</i> <i>a:Chris</i> .
  </td><td> Chris is a male sibling of Stewie.
</td></tr>
</tbody></table>
<p>Since <i>a:hasBrother</i> and <i>a:hasMaleSibling</i> are equivalent properties, this ontology entails that <i>a:Chris</i> is connected by <i>a:hasMaleSibling</i> with <i>a:Stewie</i> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasMaleSibling</i> <i>a:Chris</i> <i>a:Stewie</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Chris</i> <i>a:hasMaleSibling</i> <i>a:Stewie</i> .
</td></tr>
</tbody></table>
<p>Furthermore, the ontology also entails that that <i>a:Stewie</i> is connected by <i>a:hasBrother</i> with <i>a:Chris</i> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasBrother</i> <i>a:Stewie</i> <i>a:Chris</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Stewie</i> <i>a:hasBrother</i> <i>a:Chris</i> .
</td></tr>
</tbody></table>
</div>
<a id="Disjoint_Object_Properties" name="Disjoint_Object_Properties"></a><h4> <span class="mw-headline">9.2.3  Disjoint Object Properties </span></h4>
<p>A disjoint object properties axiom <span class="name">DisjointObjectProperties( OPE<sub>1</sub> ... OPE<sub>n</sub> )</span> states that all of the object property expressions <span class="name">OPE<sub>i</sub></span>, 1 &le; i &le; n, are pairwise disjoint; that is, no individual <span class="name">x</span> can be connected to an individual <span class="name">y</span> by both <span class="name">OPE<sub>i</sub></span> and <span class="name">OPE<sub>j</sub></span> for i &ne; j.
</p>
<div class="grammar">
<p><span class="nonterminal">DisjointObjectProperties</span>&nbsp;:= 'DisjointObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DisjointObjectProperties( <i>a:hasFather</i> <i>a:hasMother</i> )
  </td><td> Fatherhood is disjoint with motherhood.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasFather</i> <i>a:Stewie</i> <i>a:Peter</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasMother</i> <i>a:Stewie</i> <i>a:Lois</i> )
  </td><td> Lois is the mother of Stewie.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasFather</i> <i>owl:propertyDisjointWith</i> <i>a:hasMother</i> .
  </td><td> Fatherhood is disjoint with motherhood.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasFather</i> <i>a:Peter</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasMother</i> <i>a:Lois</i> .
  </td><td> Lois is the mother of Stewie.
</td></tr>
</tbody></table>
<p>In this ontology, the disjointness axiom is satisfied. If, however, one were to add the following assertion, the disjointness axiom would be invalidated and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasMother</i> <i>a:Stewie</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Stewie</i> <i>a:hasMother</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Inverse_Object_Properties_2" name="Inverse_Object_Properties_2"></a><h4> <span class="mw-headline">9.2.4  Inverse Object Properties </span></h4>
<p>An inverse object properties axiom <span class="name">InverseObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )</span> states that the object property expression <span class="name">OPE<sub>1</sub></span> is an inverse of the object property expression <span class="name">OPE<sub>2</sub></span>. Thus, if an individual <span class="name">x</span> is connected by <span class="name">OPE<sub>1</sub></span> to an individual <span class="name">y</span>, then <span class="name">y</span> is also connected by <span class="name">OPE<sub>2</sub></span> to <span class="name">x</span>, and vice versa. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">EquivalentObjectProperties( OPE<sub>1</sub> ObjectInverseOf( OPE<sub>2</sub> ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">InverseObjectProperties</span>&nbsp;:= 'InverseObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> InverseObjectProperties( <i>a:hasFather</i> <i>a:fatherOf</i> )
  </td><td> Having a father is the opposite of being a father of someone.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasFather</i> <i>a:Stewie</i> <i>a:Peter</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Chris</i> )
  </td><td> Peter is Chris's father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasFather</i> <i>owl:inverseOf</i> <i>a:fatherOf</i> .
  </td><td> Having a father is the opposite of being a father of someone.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasFather</i> <i>a:Peter</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Chris</i> .
  </td><td> Peter is Chris's father.
</td></tr>
</tbody></table>
<p>This ontology entails that <i>a:Peter</i> is connected by <i>a:fatherOf</i> with <i>a:Stewie</i> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
</td></tr>
</tbody></table>
<p>Furthermore, the ontology also entails that <i>a:Chris</i> is connected by <i>a:hasFather</i> with <i>a:Peter</i> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasFather</i> <i>a:Chris</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Chris</i> <i>a:hasFather</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Object_Property_Domain" name="Object_Property_Domain"></a><h4> <span class="mw-headline">9.2.5  Object Property Domain </span></h4>
<p>An object property domain axiom <span class="name">ObjectPropertyDomain( OPE CE )</span> states that the domain of the object property expression <span class="name">OPE</span> is the class expression <span class="name">CE</span> &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">OPE</span> with some other individual, then <span class="name">x</span> is an instance of <span class="name">CE</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( ObjectSomeValuesFrom( OPE <i>owl:Thing</i> ) CE )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ObjectPropertyDomain</span>&nbsp;:= 'ObjectPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyDomain( <i>a:hasDog</i> <i>a:Person</i> )
  </td><td> Only people can own dogs.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDog</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasDog</i> <i>rdfs:domain</i> <i>a:Person</i> .
  </td><td> Only people can own dogs.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasDog</i> <i>a:Brian</i> .
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<p>By the first axiom, each individual that has an outgoing <i>a:hasDog</i> connection must be an instance of <i>a:Person</i>. Therefore, <i>a:Peter</i> can be classified as an instance of <i>a:Person</i>; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Person</i> <i>a:Peter</i>  )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
<p>Domain axioms in OWL 2 have a standard first-order semantics that is somewhat different from the semantics of such axioms in databases and object-oriented systems, where such axioms are interpreted as checks. The domain axiom from the example ontology would in such systems be interpreted as a <i>constraint</i> saying that <i>a:hasDog</i> can point only from individuals that are known to be instances of <i>a:Person</i>; furthermore, since the example ontology does not explicitly state that <i>a:Peter</i> is an instance of <i>a:Person</i>, one might expect the domain constraint to be invalidated. This, however, is not the case in OWL 2: as shown in the previous paragraph, the missing type is <i>inferred</i> from the domain constraint.
</p>
</div>
<a id="Object_Property_Range" name="Object_Property_Range"></a><h4> <span class="mw-headline">9.2.6  Object Property Range </span></h4>
<p>An object property range axiom <span class="name">ObjectPropertyRange( OPE CE )</span> states that the range of the object property expression <span class="name">OPE</span> is the class expression <span class="name">CE</span> &mdash; that is, if some individual is connected by <span class="name">OPE</span> with an individual <span class="name">x</span>, then <span class="name">x</span> is an instance of <span class="name">CE</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> ObjectAllValuesFrom( OPE CE ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ObjectPropertyRange</span>&nbsp;:= 'ObjectPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyRange( <i>a:hasDog</i> <i>a:Dog</i> )
  </td><td> The range of the <i>a:hasDog</i> property is the class <i>a:Dog</i>.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDog</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasDog</i> <i>rdfs:range</i> <i>a:Dog</i> .
  </td><td> The range of the <i>a:hasDog</i> property is the class <i>a:Dog</i>.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasDog</i> <i>a:Brian</i> .
  </td><td> Brian is a dog of Peter.
</td></tr>
</tbody></table>
<p>By the first axiom, each individual that has an incoming <i>a:hasDog</i> connection must be an instance of <i>a:Dog</i>. Therefore, <i>a:Brian</i> can be classified as an instance of <i>a:Dog</i>; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
</td></tr>
</tbody></table>
<p>Range axioms in OWL 2 have a standard first-order semantics that is somewhat different from the semantics of such axioms in databases and object-oriented systems, where such axioms are interpreted as checks. The range axiom from the example ontology would in such systems be interpreted as a <i>constraint</i> saying that <i>a:hasDog</i> can point only to individuals that are known to be instances of <i>a:Dog</i>; furthermore, since the example ontology does not explicitly state that <i>a:Brian</i> is an instance of <i>a:Dog</i>, one might expect the range constraint to be invalidated. This, however, is not the case in OWL 2: as shown in the previous paragraph, the missing type is <i>inferred</i> from the range constraint.
</p>
</div>
<a id="Functional_Object_Properties" name="Functional_Object_Properties"></a><h4> <span class="mw-headline">9.2.7  Functional Object Properties </span></h4>
<p>An object property functionality axiom <span class="name">FunctionalObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is functional &mdash; that is, for each individual <span class="name">x</span>, there can be at most one distinct individual <span class="name">y</span> such that <span class="name">x</span> is connected by <span class="name">OPE</span> to <span class="name">y</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> ObjectMaxCardinality( 1 OPE ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">FunctionalObjectProperty</span>&nbsp;:= 'FunctionalObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalObjectProperty( <i>a:hasFather</i> )
  </td><td> Each object can have at most one father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasFather</i> <i>a:Stewie</i> <i>a:Peter</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasFather</i> <i>a:Stewie</i> <i>a:Peter_Griffin</i> )
  </td><td> Peter Griffin is Stewie's father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasFather</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one father.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasFather</i> <i>a:Peter</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Stewie</i> <i>a:hasFather</i> <i>a:Peter_Griffin</i> .
  </td><td> Peter Griffin is Stewie's father.
</td></tr>
</tbody></table>
<p>By the first axiom, <i>a:hasFather</i> can point from <i>a:Stewie</i> to at most one distinct individual, so <i>a:Peter</i> and <i>a:Peter_Griffin</i> must be equal; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SameIndividual( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter_Griffin</i> <i>owl:sameAs</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
<p>One might expect the previous ontology to be inconsistent, since the <i>a:hasFather</i> property points to two different values for <i>a:Stewie</i>. OWL 2, however, does not make the unique name assumption, so <i>a:Peter</i> and <i>a:Peter_Griffin</i> are not necessarily distinct individuals. If the ontology were extended with the following assertion, then it would indeed become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DifferentIndividuals( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:differentFrom</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
</div>
<a id="Inverse-Functional_Object_Properties" name="Inverse-Functional_Object_Properties"></a><h4> <span class="mw-headline">9.2.8  Inverse-Functional Object Properties </span></h4>
<p>An object property inverse functionality axiom <span class="name">InverseFunctionalObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is inverse-functional &mdash; that is, for each individual <span class="name">x</span>, there can be at most one individual <span class="name">y</span> such that <span class="name">y</span> is connected by <span class="name">OPE</span> with <span class="name">x</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> ObjectMaxCardinality( 1 ObjectInverseOf( OPE ) ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">InverseFunctionalObjectProperty</span>&nbsp;:= 'InverseFunctionalObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> InverseFunctionalObjectProperty( <i>a:fatherOf</i> )
  </td><td> Each object can have at most one father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter_Griffin</i> <i>a:Stewie</i> )
  </td><td> Peter Griffin is Stewie's father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:fatherOf</i> <i>rdf:type</i> <i>owl:InverseFunctionalProperty</i> .
  </td><td> Each object can have at most one father.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> <i>a:Peter_Griffin</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter Griffin is Stewie's father.
</td></tr>
</tbody></table>
<p>By the first axiom, at most one distinct individual can point by <i>a:fatherOf</i> to <i>a:Stewie</i>, so <i>a:Peter</i> and <i>a:Peter_Griffin</i> must be equal; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SameIndividual( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:sameAs</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
<p>One might expect the previous ontology to be inconsistent, since there are two individuals that <i>a:Stewie</i> is connected to by <i>a:fatherOf</i>. OWL 2, however, does not make the unique name assumption, so <i>a:Peter</i> and <i>a:Peter_Griffin</i> are not necessarily distinct individuals. If the ontology were extended with the following assertion, then it would indeed become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DifferentIndividuals( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:differentFrom</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
</div>
<a id="Reflexive_Object_Properties" name="Reflexive_Object_Properties"></a><h4> <span class="mw-headline">9.2.9  Reflexive Object Properties </span></h4>
<p>An object property reflexivity axiom <span class="name">ReflexiveObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is reflexive &mdash; that is, each individual is connected by <span class="name">OPE</span> to itself. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> ObjectHasSelf( OPE ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">ReflexiveObjectProperty</span>&nbsp;:= 'ReflexiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ReflexiveObjectProperty( <i>a:knows</i> )
  </td><td> Everybody knows themselves.
</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Person</i> <i>a:Peter</i> )
  </td><td> Peter is a person.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:knows</i> <i>rdf:type</i> <i>owl:ReflexiveProperty</i> .
  </td><td> Everybody knows themselves.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
  </td><td> Peter is a person.
</td></tr>
</tbody></table>
<p>By the first axiom, <i>a:Peter</i> must be connected by <i>a:knows</i> to itself; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:knows</i> <i>a:Peter</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:knows</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Irreflexive_Object_Properties" name="Irreflexive_Object_Properties"></a><h4> <span class="mw-headline">9.2.10  Irreflexive Object Properties </span></h4>
<p>An object property irreflexivity axiom <span class="name">IrreflexiveObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is irreflexive &mdash; that is, no individual is connected by <span class="name">OPE</span> to itself. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( ObjectHasSelf( OPE ) <i>owl:Nothing</i> )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">IrreflexiveObjectProperty</span>&nbsp;:= 'IrreflexiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> IrreflexiveObjectProperty( <i>a:marriedTo</i> )
  </td><td> Nobody can be married to themselves.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:marriedTo</i> <i>rdf:type</i> <i>owl:IrreflexiveProperty</i> .
  </td><td> Nobody can be married to themselves.
</td></tr>
</tbody></table>
<p>If this ontology were extended with the following assertion, the irreflexivity axiom would be contradicted and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:marriedTo</i> <i>a:Peter</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:marriedTo</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Symmetric_Object_Properties" name="Symmetric_Object_Properties"></a><h4> <span class="mw-headline">9.2.11  Symmetric Object Properties </span></h4>
<p>An object property symmetry axiom <span class="name">SymmetricObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is symmetric &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">OPE</span> to an individual <span class="name">y</span>, then <span class="name">y</span> is also connected by <span class="name">OPE</span> to <span class="name">x</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubObjectPropertyOf( OPE ObjectInverseOf( OPE ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">SymmetricObjectProperty</span>&nbsp;:= 'SymmetricObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SymmetricObjectProperty( <i>a:friend</i> )
  </td><td> If x is a friend of y, then y is a friend of x.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:friend</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a friend of Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:friend</i> <i>rdf:type</i> <i>owl:SymmetricProperty</i> .
  </td><td> If x is a friend of y, then y is a friend of x.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:friend</i> <i>a:Brian</i> .
  </td><td> Brian is a friend of Peter.
</td></tr>
</tbody></table>
<p>Since <i>a:friend</i> is symmetric, <i>a:Peter</i> must be connected by <i>a:friend</i> to <i>a:Brian</i>; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:friend</i> <i>a:Brian</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Brian</i> <i>a:friend</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Asymmetric_Object_Properties" name="Asymmetric_Object_Properties"></a><h4> <span class="mw-headline">9.2.12  Asymmetric Object Properties </span></h4>
<p>An object property asymmetry axiom <span class="name">AsymmetricObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is asymmetric &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">OPE</span> to an individual <span class="name">y</span>, then <span class="name">y</span> cannot be connected by <span class="name">OPE</span> to <span class="name">x</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">AsymmetricObjectProperty</span>&nbsp;:= 'AsymmetricObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> AsymmetricObjectProperty( <i>a:parentOf</i> )
  </td><td> If x is a parent of y, then y is not a parent of x.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:parentOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is a parent of Stewie.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:parentOf</i> <i>rdf:type</i> <i>rdf:AsymmetricProperty</i> .
  </td><td> If x is a parent of y, then y is not a parent of x.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:parentOf</i> <i>a:Stewie</i> .
  </td><td> Peter is a parent of Stewie.
</td></tr>
</tbody></table>
<p>If this ontology were extended with the following assertion, the asymmetry axiom would be invalidated and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:parentOf</i> <i>a:Stewie</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Stewie</i> <i>a:parentOf</i> <i>a:Peter</i> .
</td></tr>
</tbody></table>
</div>
<a id="Transitive_Object_Properties" name="Transitive_Object_Properties"></a><h4> <span class="mw-headline">9.2.13  Transitive Object Properties </span></h4>
<p>An object property transitivity axiom <span class="name">TransitiveObjectProperty( OPE )</span> states that the object property expression <span class="name">OPE</span> is transitive &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">OPE</span> to an individual <span class="name">y</span> that is connected by <span class="name">OPE</span> to an individual <span class="name">z</span>, then <span class="name">x</span> is also connected by <span class="name">OPE</span> to <span class="name">z</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubObjectPropertyOf( ObjectPropertyChain( OPE OPE ) OPE )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">TransitiveObjectProperty</span>&nbsp;:= 'TransitiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> TransitiveObjectProperty( <i>a:ancestorOf</i> )
  </td><td> If x is an ancestor of y and y is an ancestor of z, then x is an ancestor of z.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:ancestorOf</i> <i>a:Carter</i> <i>a:Lois</i> )
  </td><td> Carter is an ancestor of Lois.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:ancestorOf</i> <i>a:Lois</i> <i>a:Meg</i> )
  </td><td> Lois is an ancestor of Meg.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:ancestorOf</i> <i>rdf:type</i> <i>owl:TransitiveProperty</i> .
  </td><td> If x is an ancestor of y and y is an ancestor of z, then x is an ancestor of z.
</td></tr>
<tr valign="top"><td> <i>a:Carter</i> <i>a:ancestorOf</i> <i>a:Lois</i> .
  </td><td> Carter is an ancestor of Lois.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>a:ancestorOf</i> <i>a:Meg</i> .
  </td><td> Lois is an ancestor of Meg.
</td></tr>
</tbody></table>
<p>Since <i>a:ancestorOf</i> is transitive, <i>a:Carter</i> must be connected by <i>a:ancestorOf</i> to <i>a:Meg</i> &mdash; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:ancestorOf</i> <i>a:Carter</i> <i>a:Meg</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Carter</i> <i>a:ancestorOf</i> <i>a:Meg</i> .
</td></tr>
</tbody></table>
</div>
<a id="Data_Property_Axioms" name="Data_Property_Axioms"></a><h3> <span class="mw-headline">9.3  Data Property Axioms </span></h3>
<p>OWL 2 also provides for data property axioms. Their structure is similar to object property axioms, as shown in Figure 16. The <span class="nonterminal">SubDataPropertyOf</span> axiom allows one to state that the extension of one data property expression is included in the extension of another data property expression. The <span class="nonterminal">EquivalentDataProperties</span> allows one to state that several data property expressions have the same extension. The <span class="nonterminal">DisjointDataProperties</span> axiom allows one to state that the extensions of several data property expressions are disjoint with each other &mdash; that is, they do not share individual&ndash;literal pairs. The <span class="nonterminal">DataPropertyDomain</span> axiom can be used to restrict individuals connected by a property expression to be instances of the specified class; similarly, the <span class="nonterminal">DataPropertyRange</span> axiom can be used to restrict the literals pointed to by a property expression to be in the specified unary data range. Finally, the <span class="nonterminal">FunctionalDataProperty</span> axiom allows one to state that a data property expression is functional &mdash; that is, that each individual can have at most one outgoing connection of the specified data property expression. 
</p>
<div class="image">
<p><img alt="Data Property Axioms of OWL 2" border="0" height="611" src="A_dataproperty.gif" width="949" /><br />
<span class="caption">Figure 16.</span> Data Property Axioms of OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DataPropertyAxiom</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SubDataPropertyOf</span> | <span class="nonterminal">EquivalentDataProperties</span> | <span class="nonterminal">DisjointDataProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataPropertyDomain</span> | <span class="nonterminal">DataPropertyRange</span> | <span class="nonterminal">FunctionalDataProperty</span>
</p>
</div>
<a id="Data_Subproperties" name="Data_Subproperties"></a><h4> <span class="mw-headline">9.3.1  Data Subproperties </span></h4>
<p>A data subproperty axiom <span class="name">SubDataPropertyOf( DPE<sub>1</sub> DPE<sub>2</sub> )</span> states that the data property expression <span class="name">DPE<sub>1</sub></span> is a subproperty of the data property expression <span class="name">DPE<sub>2</sub></span> &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">DPE<sub>1</sub></span> to a literal <span class="name">y</span>, then <span class="name">x</span> is connected by <span class="name">DPE<sub>2</sub></span> to <span class="name">y</span> as well.
</p>
<div class="grammar">
<p><span class="nonterminal">SubDataPropertyOf</span>&nbsp;:= 'SubDataPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subDataPropertyExpression</span> <span class="nonterminal">superDataPropertyExpression</span> ')'<br />
<span class="nonterminal">subDataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataPropertyExpression</span><br />
<span class="nonterminal">superDataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataPropertyExpression</span>
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubDataPropertyOf( <i>a:hasLastName</i> <i>a:hasName</i> )
  </td><td> A last name of someone is his/her name as well.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasLastName</i> <i>a:Peter</i> "Griffin" )
  </td><td>Peter's last name is <span class="name">"Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasLastName</i> <i>rdfs:subPropertyOf</i> <i>a:hasName</i> .
  </td><td> A last name of someone is his/her name as well.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasLastName</i> "Griffin" .
  </td><td>Peter's last name is <span class="name">"Griffin"</span>.</td></tr>
</tbody></table>
<p>Since <i>a:hasLastName</i> is a subproperty of <i>a:hasName</i>, each individual connected by the former property to a literal is also connected by the latter property to the same literal. Therefore, this ontology entails that <i>a:Peter</i> is connected to <span class="name">"Griffin"</span> through <i>a:hasName</i>; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Griffin" )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:hasName</i> "Griffin" .
</td></tr>
</tbody></table>
</div>
<a id="Equivalent_Data_Properties" name="Equivalent_Data_Properties"></a><h4> <span class="mw-headline">9.3.2  Equivalent Data Properties </span></h4>
<p>An equivalent data properties axiom <span class="name">EquivalentDataProperties( DPE<sub>1</sub> ... DPE<sub>n</sub> )</span> states that all the data property expressions <span class="name">DPE<sub>i</sub></span>, 1 &le; i &le; n, are semantically equivalent to each other. This axiom allows one to use each <span class="name">DPE<sub>i</sub></span> as a synonym for each <span class="name">DPE<sub>j</sub></span> &mdash; that is, in any expression in the ontology containing such an axiom, <span class="name">DPE<sub>i</sub></span> can be replaced with <span class="name">DPE<sub>j</sub></span> without affecting the meaning of the ontology. The axiom <span class="name">EquivalentDataProperties( DPE<sub>1</sub> DPE<sub>2</sub> )</span> can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubDataPropertyOf( DPE<sub>1</sub> DPE<sub>2</sub> )</span><br />
<span class="name">SubDataPropertyOf( DPE<sub>2</sub> DPE<sub>1</sub> )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">EquivalentDataProperties</span>&nbsp;:= 'EquivalentDataProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> EquivalentDataProperties( <i>a:hasName</i> <i>a:seLlama</i> )
  </td><td> <i>a:hasName</i> and <i>a:seLlama</i> (in Spanish) are synonyms.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Meg</i> "Meg Griffin" )
  </td><td>Meg's name is <span class="name">"Meg Griffin"</span>.</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:seLlama</i> <i>a:Meg</i> "Megan Griffin" )
  </td><td>Meg's name is <span class="name">"Megan Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasName</i> <i>owl:equivalentProperty</i> <i>a:seLlama</i> .
  </td><td> <i>a:hasName</i> and <i>a:seLlama</i> (in Spanish) are synonyms.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasName</i> "Meg Griffin" .
  </td><td>Meg's name is <span class="name">"Meg Griffin"</span>.</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:seLlama</i> "Megan Griffin" .
  </td><td>Meg's name is <span class="name">"Megan Griffin"</span>.</td></tr>
</tbody></table>
<p>Since <i>a:hasName</i> and <i>a:seLlama</i> are equivalent properties, this ontology entails that <i>a:Meg</i> is connected by <i>a:seLlama</i> with <span class="name">"Meg Griffin"</span> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:seLlama</i> <i>a:Meg</i> "Meg Griffin" )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>a:seLlama</i> "Meg Griffin" .
</td></tr>
</tbody></table>
<p>Furthermore, the ontology also entails that <i>a:Meg</i> is also connected by <i>a:hasName</i> with <span class="name">"Megan Griffin"</span> &mdash; that is, it entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasName</i> <i>a:Meg</i> "Megan Griffin" )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>a:hasName</i> "Megan Griffin" .
</td></tr>
</tbody></table>
</div>
<a id="Disjoint_Data_Properties" name="Disjoint_Data_Properties"></a><h4> <span class="mw-headline">9.3.3  Disjoint Data Properties </span></h4>
<p>A disjoint data properties axiom <span class="name">DisjointDataProperties( DPE<sub>1</sub> ... DPE<sub>n</sub> )</span> states that all of the data property expressions <span class="name">DPE<sub>i</sub></span>, 1 &le; i &le; n, are pairwise disjoint; that is, no individual <span class="name">x</span> can be connected to a literal <span class="name">y</span> by both <span class="name">DPE<sub>i</sub></span> and <span class="name">DPE<sub>j</sub></span> for i &ne; j.
</p>
<div class="grammar">
<p><span class="nonterminal">DisjointDataProperties</span>&nbsp;:= 'DisjointDataProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DisjointDataProperties( <i>a:hasName</i> <i>a:hasAddress</i> )
  </td><td> Someone's name must be different from his address.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter Griffin" )
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAddress</i> <i>a:Peter</i> "Quahog, Rhode Island" )
  </td><td>Peter's address is <span class="name">"Quahog, Rhode Island"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasName</i> <i>owl:propertyDisjointWith</i> <i>a:hasAddress</i> .
  </td><td> Someone's name must be different from his address.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter Griffin" .
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasAddress</i> "Quahog, Rhode Island" .
  </td><td>Peter's address is <span class="name">"Quahog, Rhode Island"</span>.</td></tr>
</tbody></table>
<p>In this ontology, the disjointness axiom is satisfied. If, however, one were to add the following assertion, the disjointness axiom would be invalidated and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasAddress</i> <i>a:Peter</i> "Peter Griffin" )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:hasAddress</i> "Peter Griffin" .
</td></tr>
</tbody></table>
</div>
<a id="Data_Property_Domain" name="Data_Property_Domain"></a><h4> <span class="mw-headline">9.3.4  Data Property Domain </span></h4>
<p>A data property domain axiom <span class="name">DataPropertyDomain( DPE CE )</span> states that the domain of the data property expression <span class="name">DPE</span> is the class expression <span class="name">CE</span> &mdash; that is, if an individual <span class="name">x</span> is connected by <span class="name">DPE</span> with some literal, then <span class="name">x</span> is an instance of <span class="name">CE</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( DataSomeValuesFrom( DPE <i>rdfs:Literal</i>) CE )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DataPropertyDomain</span>&nbsp;:= 'DataPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyDomain( <i>a:hasName</i> <i>a:Person</i> )
  </td><td> Only people can have names.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter Griffin" )
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasName</i> <i>rdfs:domain</i> <i>a:Person</i> .
  </td><td> Only people can have names.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter Griffin" .
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
<p>By the first axiom, each individual that has an outgoing <i>a:hasName</i> connection must be an instance of <i>a:Person</i>. Therefore, <i>a:Peter</i> can be classified as an instance of <i>a:Person</i> &mdash; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Person</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
</td></tr>
</tbody></table>
<p>Domain axioms in OWL 2 have a standard first-order semantics that is somewhat different from the semantics of such axioms in databases and object-oriented systems, where such axioms are interpreted as checks. Thus, the domain axiom from the example ontology would in such systems be interpreted as a <i>constraint</i> saying that <i>a:hasName</i> can point only from individuals that are known to be instances of <i>a:Person</i>; furthermore, since the example ontology does not explicitly state that <i>a:Peter</i> is an instance of <i>a:Person</i>, one might expect the domain constraint to be invalidated. This, however, is not the case in OWL 2: as shown in the previous paragraph, the missing type is <i>inferred</i> from the domain constraint.
</p>
</div>
<a id="Data_Property_Range" name="Data_Property_Range"></a><h4> <span class="mw-headline">9.3.5  Data Property Range </span></h4>
<p>A data property range axiom <span class="name">DataPropertyRange( DPE DR )</span> states that the range of the data property expression <span class="name">DPE</span> is the data range <span class="name">DR</span> &mdash; that is, if some individual is connected by <span class="name">DPE</span> with a literal <span class="name">x</span>, then <span class="name">x</span> is in <span class="name">DR</span>. The arity of <span class="name">DR</span> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be one. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> DataAllValuesFrom( DPE DR ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DataPropertyRange</span>&nbsp;:= 'DataPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataRange</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyRange( <i>a:hasName</i> <i>xsd:string</i> )
  </td><td> The range of the <i>a:hasName</i> property is <i>xsd:string</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter Griffin" )
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasName</i> <i>rdfs:range</i> <i>xsd:string</i> .
  </td><td> The range of the <i>a:hasName</i> property is <i>xsd:string</i>.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter Griffin" .
  </td><td>Peter's name is <span class="name">"Peter Griffin"</span>.</td></tr>
</tbody></table>
<p>By the first axiom, each literal that has an incoming <i>a:hasName</i> link must be in <i>xsd:string</i>. In the example ontology, this axiom is satisfied. If, however, the ontology were extended with the following assertion, then the range axiom would imply that the literal <span class="name">"42"^^<i>xsd:integer</i></span> is in <i>xsd:string</i>, which is a contradiction and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "42"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:hasName</i> "42"^^<i>xsd:integer</i> .
</td></tr>
</tbody></table>
</div>
<a id="Functional_Data_Properties" name="Functional_Data_Properties"></a><h4> <span class="mw-headline">9.3.6  Functional Data Properties </span></h4>
<p>A data property functionality axiom <span class="name">FunctionalDataProperty( DPE )</span> states that the data property expression <span class="name">DPE</span> is functional &mdash; that is, for each individual <span class="name">x</span>, there can be at most one distinct literal <span class="name">y</span> such that <span class="name">x</span> is connected by <span class="name">DPE</span> with <span class="name">y</span>. Each such axiom can be seen as a syntactic shortcut for the following axiom:
</p>
<div class="indent">
<p><span class="name">SubClassOf( <i>owl:Thing</i> DataMaxCardinality( 1 DPE ) )</span>
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">FunctionalDataProperty</span>&nbsp;:= 'FunctionalDataProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalDataProperty( <i>a:hasAge</i> )
  </td><td> Each object can have at most one age.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:integer</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasAge</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one age.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:integer</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<p>By the first axiom, <i>a:hasAge</i> can point from <i>a:Meg</i> to at most one distinct literal. In this example ontology, this axiom is satisfied. If, however, the ontology were extended with the following assertion, the semantics of functionality axioms would imply that <span class="name">"15"^^<i>xsd:integer</i></span> is equal to <span class="name">"17"^^<i>xsd:integer</i></span>, which is a contradiction and the ontology would become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "15"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>a:hasAge</i> "15"^^<i>xsd:integer</i> .
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>Note that some datatypes from the OWL 2 datatype map distinguish between equal and identical data values, and that the semantics of cardinality restrictions and functional data properties in OWL 2 is defined with respect to the latter. Consider the following example:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalDataProperty( <i>a:hasAge</i> )
  </td><td> Each object can have at most one age.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:integer</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17.0"^^<i>xsd:decimal</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "+17"^^<i>xsd:int</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasAge</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> Each object can have at most one age.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:integer</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17.0"^^<i>xsd:decimal</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "+17"^^<i>xsd:int</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
</tbody></table>
<p>Literals <span class="name">"17"^^<i>xsd:integer</i></span>, <span class="name">"17.0"^^<i>xsd:decimal</i></span>, and <span class="name">"+17"^^<i>xsd:int</i></span> are all mapped to the identical data value &mdash; the integer 17. Therefore, the individual <i>a:Meg</i> is connected by the <i>a:hasAge</i> property to one distinct data value, so this ontology is satisfiable.
</p><p>In contrast, consider the following ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> FunctionalDataProperty( <i>a:numberOfChildren</i> )
  </td><td> An individual can have at most one value for <i>a:numberOfChildren</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:numberOfChildren</i> <i>a:Meg</i> "+0"^^<i>xsd:float</i> )
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>+0</i>.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:numberOfChildren</i> <i>a:Meg</i> "-0"^^<i>xsd:float</i> )
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>-0</i>.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:numberOfChildren</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
  </td><td> An individual can have at most one value for <i>a:numberOfChildren</i>.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:numberOfChildren</i> "+0"^^<i>xsd:float</i> .
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>+0</i>.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:numberOfChildren</i> "-0"^^<i>xsd:float</i> .
  </td><td> The value of <i>a:numberOfChildren</i> for <i>a:Meg</i> is <i>-0</i>.
</td></tr>
</tbody></table>
<p>Literals <span class="name">"+0"^^<i>xsd:float</i></span> and <span class="name">"-0"^^<i>xsd:float</i></span> are mapped to distinct data values <i>+0</i> and <i>-0</i> in the value space of <i>xsf:float</i>; these data values are equal, but not identical. Therefore, the individual <i>a:Meg</i> is connected by the <i>a:numberOfChildren</i> property to two distinct data values, which violates the functionality restriction on <i>a:numberOfChildren</i> and makes the ontology unsatisfiable.
</p>
</div>
<a id="Datatype_Definitions" name="Datatype_Definitions"></a><h3> <span class="mw-headline">9.4  Datatype Definitions </span></h3>
<p>A datatype definition <span class="name">DatatypeDefinition( DT DR )</span> defines a new datatype <span class="name">DT</span> as being semantically equivalent to the data range <span class="name">DR</span>; the latter <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be a unary data range. This axiom allows one to use the <i>defined</i> datatype <span class="name">DT</span> as a synonym for <span class="name">DR</span> &mdash; that is, in any expression in the ontology containing such an axiom, <span class="name">DT</span> can be replaced with <span class="name">DR</span> without affecting the meaning of the ontology. The structure of such axiom is shown in Figure 17.
</p>
<div class="image">
<p><img alt="Datatype Definitions in OWL 2" border="0" height="218" src="A_datatypedefinition.gif" width="434" /><br />
<span class="caption">Figure 17.</span> Datatype Definitions in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">DatatypeDefinition</span>&nbsp;:= 'DatatypeDefinition' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Datatype</span> <span class="nonterminal">DataRange</span> ')'
</p>
</div>
<p>The datatypes defined by datatype definition axioms support no facets so they <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> occur in datatype restrictions. Furthermore, such datatypes have empty lexical spaces and therefore they <em class="RFC2119" title="MUST NOT in RFC 2119 context">MUST NOT</em> occur in literals. Finally, datatype definitions are not substitutes for declarations: if an OWL 2 ontology is to satisfy the typing constraints of OWL 2 DL from <a href="#Typing_Constraints_of_OWL_2_DL" title="">Section 5.8.1</a>, it <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> explicitly declare all datatypes that occur in datatype definitions.
</p>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> Declaration( Datatype( <i>a:SSN</i> ) )
  </td><td> <i>a:SSN</i> is a datatype.
</td></tr>
<tr valign="top"><td> DatatypeDefinition(<br /> &nbsp;&nbsp;&nbsp; <i>a:SSN</i><br /> &nbsp;&nbsp;&nbsp; DatatypeRestriction( <i>xsd:string</i> <i>xsd:pattern</i> "[0-9]{3}-[0-9]{2}-[0-9]{4}" )<br /> )
  </td><td> A social security number is a string that matches the given regular expression.
</td></tr>
<tr valign="top"><td> DataPropertyRange( <i>a:hasSSN</i> <i>a:SSN</i> )
  </td><td> The range of the <i>a:hasSSN</i> property is <i>a:SSN</i>.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:SSN</i> <i>rdf:type</i> <i>rdfs:Datatype</i> .
  </td><td> <i>a:SSN</i> is a datatype.
</td></tr>
<tr valign="top"><td> <i>a:SSN</i> <i>owl:equivalentClass</i> _:x .<br /> _:x <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x <i>owl:onDatatype</i> <i>xsd:string</i> .<br /> <i>_:x owl:withRestrictions</i> ( _:y ) .<br /> _:y <i>xsd:pattern</i> "[0-9]{3}-[0-9]{2}-[0-9]{4}" .
  </td><td> A social security number is a string that matches the given regular expression.
</td></tr>
<tr valign="top"><td> <i>a:hasSSN</i> <i>rdfs:range</i> <i>a:SSN</i> .
  </td><td> The range of the <i>a:hasSSN</i> property is <i>a:SSN</i>.
</td></tr>
</tbody></table>
<p>The second axiom defines <i>a:SSN</i> as an abbreviation for a datatype restriction on <i>xsd:string</i>. In order to satisfy the typing restrictions from <a href="#Typing_Constraints_of_OWL_2_DL" title="">Section 5.8.1</a>, the first axiom explicitly declares <i>a:SSN</i> to be a datatype. The datatype <i>a:SSN</i> can be used just like any other datatype; for example, it is used in the third axiom to define the range of the <i>a:hasSSN</i> property. The only restriction is that <i>a:SSN</i> supports no facets and therefore cannot be used in datatype restrictions, and that there can be no literals of datatype <i>a:SSN</i>.
</p>
</div>
<a id="Keys" name="Keys"></a><h3> <span class="mw-headline">9.5  Keys </span></h3>
<p>A key axiom <span class="name">HasKey( CE ( OPE<sub>1</sub> ... OPE<sub>m</sub> ) ( DPE<sub>1</sub> ... DPE<sub>n</sub> ) )</span> states that each (named) instance of the class expression <span class="name">CE</span> is uniquely identified by the object property expressions <span class="name">OPE<sub>i</sub></span> and/or the data property experssions <span class="name">DPE<sub>j</sub></span> &mdash; that is, no two distinct (named) instances of <span class="name">CE</span> can coincide on the values of all object property expressions <span class="name">OPE<sub>i</sub></span> and all data property expressions <span class="name">DPE<sub>j</sub></span>. In each such axiom in an OWL ontology, <span class="name">m</span> or <span class="name">n</span> (or both) <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> be larger than zero. A key axiom of the form <span class="name">HasKey( <i>owl:Thing</i> ( OPE ) () )</span> is similar to the axiom <span class="name">InverseFunctionalObjectProperty( OPE )</span>, the main differences being that the former axiom is applicable only to individuals that are explicitly named in an ontology, while the latter axiom is also applicable to anonymous individuals and individuals whose existence is implied by existential quantification. The structure of such axiom is shown in Figure 18.
</p>
<div class="image">
<p><img alt="Key Axioms in OWL 2" border="0" height="288" src="A_keys.gif" width="572" /><br />
<span class="caption">Figure 18.</span> Key Axioms in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">HasKey</span>&nbsp;:= 'HasKey' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> '(' { <span class="nonterminal">ObjectPropertyExpression</span> } ')' '(' { <span class="nonterminal">DataPropertyExpression</span> } ')' ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> HasKey( <i>owl:Thing</i> () ( <i>a:hasSSN</i> ) )
  </td><td> Each object is uniquely identified by its social security number.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasSSN</i> <i>a:Peter</i> "123-45-6789" )
  </td><td>Peter's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasSSN</i> <i>a:Peter_Griffin</i> "123-45-6789" )
  </td><td>Peter Griffin's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>owl:Thing</i> <i>owl:hasKey</i> ( <i>a:hasSSN</i> ) .
  </td><td> Each object is uniquely identified by its social security number.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasSSN</i> "123-45-6789" .
  </td><td>Peter's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter_Griffin</i> <i>a:hasSSN</i> "123-45-6789" .
  </td><td>Peter Griffin's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
</tbody></table>
<p>The first axiom makes <i>a:hasSSN</i> the key for instances of the <i>owl:Thing</i> class; thus, only one individual can have a particular value for <i>a:hasSSN</i>. Since the values of <i>a:hasSSN</i> are the same for the individuals <i>a:Peter</i> and <i>a:Peter_Griffin</i>, these two individuals are equal &mdash; that is, this ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SameIndividual( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:sameAs</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
<p>One might expect the previous ontology to be inconsistent, since the <i>a:hasSSN</i> has the same value for two individuals <i>a:Peter</i> and <i>a:Peter_Griffin</i>. However, OWL 2 does not make the unique name assumption, so <i>a:Peter</i> and <i>a:Peter_Griffin</i> are not necessarily distinct individuals. If the ontology were extended with the following assertion, then it would indeed become inconsistent:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DifferentIndividuals( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:differentFrom</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>The effect of a key axiom can be "localized" to instances of a particular class expression. Consider the following example:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> HasKey( <i>a:GriffinFamilyMember</i> () ( <i>a:hasName</i> ) )
  </td><td> Each member of the Griffin family is uniquely identified by its name.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter" )
  </td><td>Peter's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Peter</i> )
  </td><td> Peter is a member of the Griffin family.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter_Griffin</i> "Peter" )
  </td><td>Peter Griffin's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Peter_Griffin</i> )
  </td><td> Peter Griffin is a member of the Griffin family.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:StPeter</i> "Peter" )
  </td><td>St. Peter's name is <span class="name">"Peter"</span>.</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:GriffinFamilyMember</i> <i>owl:hasKey</i> ( <i>a:hasName</i> ) .
  </td><td> Each member of the Griffin family is uniquely identified by its name.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter" .
  </td><td>Peter's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Peter is a member of the Griffin family.
</td></tr>
<tr valign="top"><td> <i>a:Peter_Griffin</i> <i>a:hasName</i> "Peter" .
  </td><td>Peter Griffin's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter_Griffin</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Peter Griffin is a member of the Griffin family.
</td></tr>
<tr valign="top"><td> <i>a:StPeter</i> <i>a:hasName</i> "Peter" .
  </td><td>St. Peter's name is <span class="name">"Peter"</span>.</td></tr>
</tbody></table>
<p>The effects of the first key axiom are "localized" to the class <i>a:GriffinFamilyMember</i> &mdash; that is, the data property <i>a:hasName</i> uniquely identifies only instances of that class. The individuals <i>a:Peter</i> and <i>a:Peter_Griffin</i> are instances of <i>a:GriffinFamilyMember</i>, so the key axiom implies that <i>a:Peter</i> and <i>a:Peter_Griffin</i> are the same individuals &mdash; that is, the ontology implies the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> SameIndividual( <i>a:Peter</i> <i>a:Peter_Griffin</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>owl:sameAs</i> <i>a:Peter_Griffin</i> .
</td></tr>
</tbody></table>
<p>The individual <i>a:StPeter</i>, however, is not an instance of <i>a:GriffinFamilyMember</i>, so the key axiom is not applicable to it. Therefore, the ontology implies neither that <i>a:Peter</i> and <i>a:StPeter</i> are the same individuals, nor does it imply that <i>a:Peter_Griffin</i> and <i>a:StPeter</i> are the same. Keys can be made global by "localizing" them to the <i>owl:Thing</i> class, as shown in the previous example.
</p>
</div>
<div class="anexample">
<p>A key axiom does not make all the properties used in it functional. Consider the following example:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> HasKey( <i>a:GriffinFamilyMember</i> () ( <i>a:hasName</i> ) )
  </td><td> Each member of the Griffin family is uniquely identified by its name.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Peter" )
  </td><td>Peter's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasName</i> <i>a:Peter</i> "Kichwa-Tembo" )
  </td><td>Peter's name is <span class="name">"Kichwa-Tembo"</span>.</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:GriffinFamilyMember</i> <i>a:Peter</i> )
  </td><td> Peter is a member of the Griffin family.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:GriffinFamilyMember</i> <i>owl:hasKey</i> ( <i>a:hasName</i> ) .
  </td><td> Each member of the Griffin family is uniquely identified by its name.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Peter" .
  </td><td>Peter's name is <span class="name">"Peter"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasName</i> "Kichwa-Tembo" .
  </td><td>Peter's name is <span class="name">"Kichwa-Tembo"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:GriffinFamilyMember</i> .
  </td><td> Peter is a member of the Griffin family.
</td></tr>
</tbody></table>
<p>This ontology is consistent &mdash; that is, the fact that the individual <i>a:Peter</i> has two distinct values for <i>a:hasName</i> does not cause an inconsistency since the <i>a:hasName</i> data property is not necessarily functional.
</p><p>If desired, the properties used in a key axiom can always be made functional explicitly. Thus, if the example ontology were extended with the following axiom, it would become inconsistent.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> FunctionalDataProperty( <i>a:hasName</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:hasName</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
</td></tr>
</tbody></table>
</div>
<p>The semantics of key axioms is specific in that these axioms apply only to individuals explicitly introduced in the ontology by name, and not to unnamed individuals (i.e., the individuals whose existence is implied by existential quantification). This makes key axioms equivalent to a variant of DL-safe rules <cite><a href="#ref-dl-safe" title="">DL-Safe</a></cite>]. Thus, key axioms will typically not affect class-based inferences such as the computation of the subsumption hierarchy, but they will play a role in answering queries about individuals.
</p>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> HasKey( <i>a:Person</i> () ( <i>a:hasSSN</i> ) )
  </td><td> Each person is uniquely identified by their social security number.
</td></tr>
<tr valign="top"><td> DataPropertyAssertion( <i>a:hasSSN</i> <i>a:Peter</i> "123-45-6789" )
  </td><td>Peter's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> ClassAssertion( <i>a:Person</i> <i>a:Peter</i> )
  </td><td> Peter is a person.
</td></tr>
<tr valign="top"><td> ClassAssertion(<br /> &nbsp;&nbsp;&nbsp; ObjectSomeValuesFrom(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>a:marriedTo</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectIntersectionOf( <i>a:Man</i> DataHasValue( <i>a:hasSSN</i> "123-45-6789" ) )<br /> &nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; <i>a:Lois</i><br /> )
  </td><td>Lois is married to some man whose social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Man</i> <i>a:Person</i> )
  </td><td> Each man is a person.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Person</i> <i>owl:hasKey</i> ( <i>a:hasSSN</i> ) .
  </td><td> Each person is uniquely identified by their social security number.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:hasSSN</i> "123-45-6789" .
  </td><td>Peter's social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>rdf:type</i> <i>a:Person</i> .
  </td><td> Peter is a person.
</td></tr>
<tr valign="top"><td> <i>a:Lois</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:marriedTo</i> .<br /> _:x <i>owl:someValuesFrom</i> _:y .<br /> _:y <i>rdf:type</i> <i>owl:Class</i> .<br /> _:y <i>owl:intersectionOf</i> SEQ( <i>a:Man</i> _:z ) .<br /> _:z <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:z <i>owl:onProperty</i> <i>a:hasSSN</i> .<br /> _:z <i>owl:hasValue</i> "123-45-6789" .
  </td><td>Lois is married to some man whose social security number is <span class="name">"123-45-6789"</span>.</td></tr>
<tr valign="top"><td> <i>a:Man</i> <i>rdfs:subClassOf</i> <i>a:Person</i> .
  </td><td> Each man is a person.
</td></tr>
</tbody></table>
<p>The fourth axiom implies existence of some individual <span class="name">x</span> that is an instance of <i>a:Man</i> and whose value for the <i>a:hasSSN</i> data property is <span class="name">"123-45-6789"</span>; by the fifth axiom, <span class="name">x</span> is an instance of <i>a:Person</i> as well. Furthermore, the second and the third axiom say that <i>a:Peter</i> is an instance of <i>a:Person</i> and that the value of <i>a:hasSSN</i> for <i>a:Peter</i> is <span class="name">"123-45-6789"</span>. Finally, the first axiom says that <i>a:hasSSN</i> is a key property for instances of <i>a:Person</i>. Thus, one might expect <span class="name">x</span> to be equal to <i>a:Peter</i>, and for the ontology to entail the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Man</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>rdf:type</i> <i>a:Man</i> .
</td></tr>
</tbody></table>
<p>The inferences in the previous paragraph, however, cannot be drawn because of the DL-safe semantics of key axioms: <span class="name">x</span> is an individual that has not been explicitly named in the ontology; therefore, the semantics of key axioms does not apply to <span class="name">x</span>. Therefore, this OWL 2 ontology does not entail the mentioned assertion.
</p>
</div>
<a id="Assertions" name="Assertions"></a><h3> <span class="mw-headline">9.6  Assertions </span></h3>
<p>OWL 2 supports a rich set of axioms for stating <i>assertions</i> &mdash; axioms about individuals that are often also called <i>facts</i>. For clarity, different types of assertions are shown in three separate figures, Figure 19, 20, and 21. The <span class="nonterminal">SameIndividual</span> assertion allows one to state that several individuals are all equal to each other, while the <span class="nonterminal">DifferentIndividuals</span> assertion allows for the opposite &mdash; that is, to state that several individuals are all different from each other. (More precisely, that the several different individuals in the syntax are also semantically different.) The <span class="nonterminal">ClassAssertion</span> axiom allows one to state that an individual is an instance of a particular class.
</p>
<div class="image">
<p><img alt="Class and Individual (In)Equality Assertions in OWL 2" border="0" height="450" src="A_abox1.gif" width="605" /><br />
<span class="caption">Figure 19.</span> Class and Individual (In)Equality Assertions in OWL 2
</p>
</div>
<p>The <span class="nonterminal">ObjectPropertyAssertion</span> axiom allows one to state that an individual is connected by an object property expression to an individual, while <span class="nonterminal">NegativeObjectPropertyAssertion</span> allows for the opposite &mdash; that is, to state that an individual is not connected by an object property expression to an individual.
</p>
<div class="image">
<p><img alt="Object Property Assertions in OWL 2" border="0" height="542" src="A_abox2.gif" width="528" /><br />
<span class="caption">Figure 20.</span> Object Property Assertions in OWL 2
</p>
</div>
<p>The <span class="nonterminal">DataPropertyAssertion</span> axiom allows one to state that an individual is connected by a data property expression to a literal, while <span class="nonterminal">NegativeDataPropertyAssertion</span> allows for the opposite &mdash; that is, to state that an individual is not connected by a data property expression to a literal.
</p>
<div class="image">
<p><img alt="Data Property Assertions in OWL 2" border="0" height="618" src="A_abox3.gif" width="574" /><br />
<span class="caption">Figure 21.</span> Data Property Assertions in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">Assertion</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SameIndividual</span> | <span class="nonterminal">DifferentIndividuals</span> | <span class="nonterminal">ClassAssertion</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectPropertyAssertion</span> | <span class="nonterminal">NegativeObjectPropertyAssertion</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataPropertyAssertion</span> | <span class="nonterminal">NegativeDataPropertyAssertion</span><br />
<br />
<span class="nonterminal">sourceIndividual</span>&nbsp;:= <span class="nonterminal">Individual</span><br />
<span class="nonterminal">targetIndividual</span>&nbsp;:= <span class="nonterminal">Individual</span><br />
<span class="nonterminal">targetValue</span>&nbsp;:= <span class="nonterminal">Literal</span>
</p>
</div>
<a id="Individual_Equality" name="Individual_Equality"></a><h4> <span class="mw-headline">9.6.1  Individual Equality </span></h4>
<p>An individual equality axiom <span class="name">SameIndividual( a<sub>1</sub> ... a<sub>n</sub> )</span> states that all of the individuals a<sub>i</sub>, 1 &le; i &le; n, are equal to each other. This axiom allows one to use each <span class="name">a<sub>i</sub></span> as a synonym for each <span class="name">a<sub>j</sub></span> &mdash; that is, in any expression in the ontology containing such an axiom, <span class="name">a<sub>i</sub></span> can be replaced with <span class="name">a<sub>j</sub></span> without affecting the meaning of the ontology.
</p>
<div class="grammar">
<p><span class="nonterminal">SameIndividual</span>&nbsp;:= 'SameIndividual' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Individual</span> <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SameIndividual( <i>a:Meg</i> <i>a:Megan</i> )
  </td><td> Meg and Megan are the same objects.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasBrother</i> <i>a:Meg</i> <i>a:Stewie</i> )
  </td><td> Meg has a brother Stewie.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>owl:sameAs</i> <i>a:Megan</i> .
  </td><td> Meg and Megan are the same objects.
</td></tr>
<tr valign="top"><td> <i>a:Meg</i> <i>a:hasBrother</i> <i>a:Stewie</i> .
  </td><td> Meg has a brother Stewie.
</td></tr>
</tbody></table>
<p>Since <i>a:Meg</i> and <i>a:Megan</i> are equal, one individual can always be replaced with the other one. Therefore, this ontology entails that <i>a:Megan</i> is connected by <i>a:hasBrother</i> with <i>a:Stewie</i> &mdash; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasBrother</i> <i>a:Megan</i> <i>a:Stewie</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Megan</i> <i>a:hasBrother</i> <i>a:Stewie</i> .
</td></tr>
</tbody></table>
</div>
<a id="Individual_Inequality" name="Individual_Inequality"></a><h4> <span class="mw-headline">9.6.2  Individual Inequality </span></h4>
<p>An individual inequality axiom <span class="name">DifferentIndividuals( a<sub>1</sub> ... a<sub>n</sub> )</span> states that all of the individuals <span class="name">a<sub>i</sub></span>, 1 &le; i &le; n, are different from each other; that is, no individuals <span class="name">a<sub>i</sub></span> and <span class="name">a<sub>j</sub></span> with i &ne; j can be derived to be equal. This axiom can be used to axiomatize the <i>unique name assumption</i> &mdash; the assumption that all different individual names denote different individuals.
</p>
<div class="grammar">
<p><span class="nonterminal">DifferentIndividuals</span>&nbsp;:= 'DifferentIndividuals' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Individual</span> <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> } ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Meg</i> )
  </td><td> Peter is Meg's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Chris</i> )
  </td><td> Peter is Chris's father.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:fatherOf</i> <i>a:Peter</i> <i>a:Stewie</i> )
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> DifferentIndividuals( <i>a:Peter</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Stewie</i> )
  </td><td> Peter, Meg, Chris, and Stewie are all different from each other.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Meg</i> .
  </td><td> Peter is Meg's father.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Chris</i> .
  </td><td> Peter is Chris's father.
</td></tr>
<tr valign="top"><td> <i>a:Peter</i> <i>a:fatherOf</i> <i>a:Stewie</i> .
  </td><td> Peter is Stewie's father.
</td></tr>
<tr valign="top"><td> _:x <i>rdf:type</i> <i>owl:AllDifferent</i> .<br /> _:x <i>owl:members</i> ( <i>a:Peter</i> <i>a:Meg</i> <i>a:Chris</i> <i>a:Stewie</i> ) .
  </td><td> Peter, Meg, Chris, and Stewie are all different from each other.
</td></tr>
</tbody></table>
<p>The last axiom in this example ontology axiomatizes the unique name assumption (but only for the four names in the axiom). If the ontology were extended with the following axiom stating that <i>a:fatherOf</i> is functional, then this axiom would imply that <i>a:Meg</i>, <i>a:Chris</i>, and <i>a:Stewie</i> are all equal, thus invalidating the unique name assumption and making the ontology inconsistent.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> FunctionalObjectProperty( <i>a:fatherOf</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:fatherOf</i> <i>rdf:type</i> <i>owl:FunctionalProperty</i> .
</td></tr>
</tbody></table>
</div>
<a id="Class_Assertions" name="Class_Assertions"></a><h4> <span class="mw-headline">9.6.3  Class Assertions </span></h4>
<p>A class assertion <span class="name">ClassAssertion( CE a )</span> states that the individual <span class="name">a</span> is an instance of the class expression <span class="name">CE</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ClassAssertion</span>&nbsp;:= 'ClassAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">Individual</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ClassAssertion( <i>a:Dog</i> <i>a:Brian</i> )
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> SubClassOf( <i>a:Dog</i> <i>a:Mammal</i> )
  </td><td> Each dog is a mammal.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Brian</i> <i>rdf:type</i> <i>a:Dog</i> .
  </td><td> Brian is a dog.
</td></tr>
<tr valign="top"><td> <i>a:Dog</i> <i>rdfs:subClassOf</i> <i>a:Mammal</i> .
  </td><td> Each dog is a mammal.
</td></tr>
</tbody></table>
<p>The first axiom states that <i>a:Brian</i> is an instance of the class <i>a:Dog</i>. By the second axiom, each instance of <i>a:Dog</i> is an instance of <i>a:Mammal</i>. Therefore, this ontology entails that <i>a:Brian</i> is an instance of <i>a:Mammal</i> &mdash; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Mammal</i> <i>a:Brian</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Brian</i> <i>rdf:type</i> <i>a:Mammal</i> .
</td></tr>
</tbody></table>
</div>
<a id="Positive_Object_Property_Assertions" name="Positive_Object_Property_Assertions"></a><h4> <span class="mw-headline">9.6.4  Positive Object Property Assertions </span></h4>
<p>A positive object property assertion <span class="name">ObjectPropertyAssertion( OPE a<sub>1</sub> a<sub>2</sub> )</span> states that the individual <span class="name">a<sub>1</sub></span> is connected by the object property expression <span class="name">OPE</span> to the individual <span class="name">a<sub>2</sub></span>.
</p>
<div class="grammar">
<p><span class="nonterminal">ObjectPropertyAssertion</span>&nbsp;:= 'ObjectPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetIndividual</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasDog</i> <i>a:Peter</i> <i>a:Brian</i> )
  </td><td> Brian is a dog of Peter.
</td></tr>
<tr valign="top"><td> SubClassOf( ObjectSomeValuesFrom( <i>a:hasDog</i> <i>owl:Thing</i> ) <i>a:DogOwner</i> )
  </td><td> Objects that have a dog are dog owners.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Peter</i> <i>a:hasDog</i> <i>a:Brian</i> .
  </td><td> Brian is a dog of Peter.
</td></tr>
<tr valign="top"><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasDog</i> .<br /> _:x <i>owl:someValuesFrom</i> <i>owl:Thing</i> .<br /> _:x <i>rdfs:subClassOf</i> <i>a:DogOwner</i> .
  </td><td> Objects that have a dog are dog owners.
</td></tr>
</tbody></table>
<p>The first axiom states that <i>a:Peter</i> is connected by <i>a:hasDog</i> to <i>a:Brian</i>. By the second axiom, each individual connected by <i>a:hasDog</i> to an individual is an instance of <i>a:DogOwner</i>. Therefore, this ontology entails that <i>a:Peter</i> is an instance of <i>a:DogOwner</i> &mdash; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:DogOwner</i> <i>a:Peter</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>rdf:type</i> <i>a:DogOwner</i> .
</td></tr>
</tbody></table>
</div>
<a id="Negative_Object_Property_Assertions" name="Negative_Object_Property_Assertions"></a><h4> <span class="mw-headline">9.6.5  Negative Object Property Assertions </span></h4>
<p>A negative object property assertion <span class="name">NegativeObjectPropertyAssertion( OPE a<sub>1</sub> a<sub>2</sub> )</span> states that the individual <span class="name">a<sub>1</sub></span> is not connected by the object property expression <span class="name">OPE</span> to the individual <span class="name">a<sub>2</sub></span>.
</p>
<div class="grammar">
<p><span class="nonterminal">NegativeObjectPropertyAssertion</span>&nbsp;:= 'NegativeObjectPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetIndividual</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> NegativeObjectPropertyAssertion( <i>a:hasSon</i> <i>a:Peter</i> <i>a:Meg</i> )
  </td><td> Meg is not a son of Peter.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> <i>a:Peter</i> .<br /> _:x <i>owl:assertionProperty</i> <i>a:hasSon</i> .<br /> _:x <i>owl:targetIndividual</i> <i>a:Meg</i> .
  </td><td> Meg is not a son of Peter.
</td></tr>
</tbody></table>
<p>The ontology would become inconsistent if it were extended with the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasSon</i> <i>a:Peter</i> <i>a:Meg</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Peter</i> <i>a:hasSon</i> <i>a:Meg</i> .
</td></tr>
</tbody></table>
</div>
<a id="Positive_Data_Property_Assertions" name="Positive_Data_Property_Assertions"></a><h4> <span class="mw-headline">9.6.6  Positive Data Property Assertions </span></h4>
<p>A positive data property assertion <span class="name">DataPropertyAssertion( DPE a lt )</span> states that the individual <span class="name">a</span> is connected by the data property expression <span class="name">DPE</span> to the literal <span class="name">lt</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">DataPropertyAssertion</span>&nbsp;:= 'DataPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetValue</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axioms.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "17"^^<i>xsd:integer</i> )
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> SubClassOf(<br /> &nbsp;&nbsp;&nbsp; DataSomeValuesFrom( <i>a:hasAge</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DatatypeRestriction( <i>xsd:integer</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>xsd:minInclusive</i> "13"^^<i>xsd:integer</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>xsd:maxInclusive</i> "19"^^<i>xsd:integer</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; <i>a:Teenager</i><br /> )
  </td><td> Objects that are older than 13 and younger than 19 (both inclusive) are teenagers.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Meg</i> <i>a:hasAge</i> "17"^^<i>xsd:integer</i> .
  </td><td> Meg is seventeen years old.
</td></tr>
<tr valign="top"><td> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasAge</i> .<br /> _:x <i>owl:someValuesFrom</i> _:y .<br /> _:y <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:y <i>owl:onDatatype</i> <i>xsd:intege</i>r .<br /> _:y <i>owl:withRestrictions</i> ( _:z _:w ) .<br /> _:z <i>xsd:minInclusive</i> "13"^^<i>xsd:integer</i> .<br /> _:w <i>xsd:maxInclusive</i> "19"^^<i>xsd:integer</i> .<br /> _:x <i>rdfs:subClassOf</i> <i>a:Teenager</i> .
  </td><td> Objects that are often than 13 and younger than 19 (both inclusive) are teenagers.
</td></tr>
</tbody></table>
<p>The first axiom states that <i>a:Meg</i> is connected by <i>a:hasAge</i> to the literal <span class="name">"17"^^<i>xsd:integer</i></span>. By the second axiom, each individual connected by <i>a:hasAge</i> to an integer between 13 and 19 is an instance of <i>a:Teenager</i>. Therefore, this ontology entails that <i>a:Meg</i> is an instance of <i>a:Teenager</i> &mdash; that is, the ontology entails the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion( <i>a:Teenager</i> <i>a:Meg</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>rdf:type</i> <i>a:Teenager</i> .
</td></tr>
</tbody></table>
</div>
<a id="Negative_Data_Property_Assertions" name="Negative_Data_Property_Assertions"></a><h4> <span class="mw-headline">9.6.7  Negative Data Property Assertions </span></h4>
<p>A negative data property assertion <span class="name">NegativeDataPropertyAssertion( DPE a lt )</span> states that the individual <span class="name">a</span> is not connected by the data property expression <span class="name">DPE</span> to the literal <span class="name">lt</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">NegativeDataPropertyAssertion</span>&nbsp;:= 'NegativeDataPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetValue</span> ')'
</p>
</div>
<div class="anexample">
<p>Consider the ontology consisting of the following axiom.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> NegativeDataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "5"^^<i>xsd:integer</i> )
  </td><td> Meg is not five years old.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> _:x <i>rdf:type</i> <i>owl:NegativePropertyAssertion</i> .<br /> _:x <i>owl:sourceIndividual</i> <i>a:Meg</i> .<br /> _:x <i>owl:assertionProperty</i> <i>a:hasAge</i> .<br /> _:x <i>owl:targetValue</i> "5"^^<i>xsd:integer</i> .
  </td><td> Meg is not five years old.
</td></tr>
</tbody></table>
<p>The ontology would become inconsistent if it were extended with the following assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> DataPropertyAssertion( <i>a:hasAge</i> <i>a:Meg</i> "5"^^<i>xsd:integer</i> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Meg</i> <i>a:hasAge</i> "5"^^<i>xsd:integer</i> .
</td></tr>
</tbody></table>
</div>
<a id="Annotations" name="Annotations"></a><h2> <span class="mw-headline">10  Annotations </span></h2>
<p>OWL 2 applications often need ways to associate additional information with ontologies, entities, and axioms. To this end, OWL 2 provides for <span id="def_annotations"><i>annotations</i></span> on ontologies, axioms, and entities.
</p>
<div class="anexample">
<p>One might want to associate human-readable labels with IRIs and use them when visualizing an ontology. To this end, one might use the <i>rdfs:label</i> annotation property to associate such labels with ontology IRIs.
</p>
</div>
<p>Various OWL 2 syntaxes, such as the functional-style syntax, provide a mechanism for embedding comments into ontology documents. The structure of such comments is, however, dependent on the syntax, so these are simply discarded during parsing. In contrast, annotations are "first-class citizens" in the structural specification of OWL 2, and their structure is independent of the underlying syntax.
</p>
<div class="anexample">
<p>Since it is based on XML, the OWL 2 XML Syntax [<cite><a href="#ref-owl-2-xml-serialization" title="">OWL 2 XML Serialization</a></cite>] allows the embedding of the standard XML comments into ontology documents. Such comments are not represented in the structural specification of OWL 2 and, consequently, they should be ignored during document parsing.
</p>
</div>
<a id="Annotations_of_Ontologies.2C_Axioms.2C_and_other_Annotations" name="Annotations_of_Ontologies.2C_Axioms.2C_and_other_Annotations"></a><h3> <span class="mw-headline">10.1  Annotations of Ontologies, Axioms, and other Annotations </span></h3>
<p>Ontologies, axioms, and annotations themselves can be annotated using annotations shown in Figure 22. As shown in the figure, such annotations consist of an annotation property and an annotation value, where the latter can be anonymous individuals, IRIs, and literals.
</p>
<div class="image">
<p><img alt="Annotations of Ontologies and Axioms in OWL 2" border="0" height="372" src="Annotations.gif" width="485" /><br />
<span class="caption">Figure 22.</span> Annotations of Ontologies and Axioms in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">Annotation</span>&nbsp;:= 'Annotation' '(' <span class="nonterminal">annotationAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">AnnotationValue</span> ')'<br />
<span class="nonterminal">annotationAnnotations</span> &nbsp;:= { <span class="nonterminal">Annotation</span> }<br />
<span class="nonterminal">AnnotationValue</span>&nbsp;:= <span class="nonterminal">AnonymousIndividual</span> | <span class="nonterminal">IRI</span> | <span class="nonterminal">Literal</span>
</p>
</div>
<a id="Annotation_Axioms" name="Annotation_Axioms"></a><h3> <span class="mw-headline">10.2  Annotation Axioms </span></h3>
<p>OWL 2 provides means to state several types of axioms about annotation properties, as shown in Figure 23. These statements are treated as axioms only in order to simplify the structural specification of OWL 2.
</p>
<div class="image">
<p><img alt="Annotations of IRIs and Anonymous Individuals in OWL 2" border="0" height="634" src="A_annotation.gif" width="996" /><br />
<span class="caption">Figure 23.</span> Annotations of IRIs and Anonymous Individuals in OWL 2
</p>
</div>
<div class="grammar">
<p><span class="nonterminal">AnnotationAxiom</span>&nbsp;:= <span class="nonterminal">AnnotationAssertion</span> | <span class="nonterminal">SubAnnotationPropertyOf</span> | <span class="nonterminal">AnnotationPropertyDomain</span> | <span class="nonterminal">AnnotationPropertyRange</span>
</p>
</div>
<a id="Annotation_Assertion" name="Annotation_Assertion"></a><h4> <span class="mw-headline">10.2.1  Annotation Assertion </span></h4>
<p>An annotation assertion <span class="name">AnnotationAssertion( AP as av )</span> states that the annotation subject <span class="name">as</span> &mdash; an IRI or an anonymous individual &mdash; is annotated with the annotation property <span class="name">AP</span> and the annotation value <span class="name">av</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">AnnotationAssertion</span>&nbsp;:= 'AnnotationAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">AnnotationSubject</span> <span class="nonterminal">AnnotationValue</span> ')'<br />
<span class="nonterminal">AnnotationSubject</span>&nbsp;:= <span class="nonterminal">IRI</span> | <span class="nonterminal">AnonymousIndividual</span>
</p>
</div>
<div class="anexample">
<p>The following axiom assigns a human-readable comment to the IRI <i>a:Person</i>.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> AnnotationAssertion( <i>rdfs:label</i> <i>a:Person</i> "Represents the set of all people." )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Person</i> <i>rdfs:label</i> "Represents the set of all people." .
</td></tr>
</tbody></table>
<p>Since the annotation is assigned to an IRI, it applies to all entities with the given IRI. Thus, if an ontology contains both a class and an individual <i>a:Person</i>, the above comment applies to both entities.
</p>
</div>
<a id="Annotation_Subproperties" name="Annotation_Subproperties"></a><h4> <span class="mw-headline">10.2.2  Annotation Subproperties </span></h4>
<p>An annotation subproperty axiom <span class="name">SubAnnotationPropertyOf( AP<sub>1</sub> AP<sub>2</sub> )</span> states that the annotation property <span class="name">AP<sub>1</sub></span> is a subproperty of the annotation property <span class="name">AP<sub>2</sub></span>.
</p>
<div class="grammar">
<p><span class="nonterminal">SubAnnotationPropertyOf</span>&nbsp;:= 'SubAnnotationPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subAnnotationProperty</span> <span class="nonterminal">superAnnotationProperty</span> ')'<br />
<span class="nonterminal">subAnnotationProperty</span>&nbsp;:= <span class="nonterminal">AnnotationProperty</span><br />
<span class="nonterminal">superAnnotationProperty</span>&nbsp;:= <span class="nonterminal">AnnotationProperty</span>
</p>
</div>
<a id="Annotation_Property_Domain" name="Annotation_Property_Domain"></a><h4> <span class="mw-headline">10.2.3  Annotation Property Domain </span></h4>
<p>An annotation property domain axiom <span class="name">AnnotationPropertyDomain( AP U )</span> states that the domain of the annotation property <span class="name">AP</span> is the IRI <span class="name">U</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">AnnotationPropertyDomain</span>&nbsp;:= 'AnnotationPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">IRI</span> ')'
</p>
</div>
<a id="Annotation_Property_Range" name="Annotation_Property_Range"></a><h4> <span class="mw-headline">10.2.4  Annotation Property Range </span></h4>
<p>An annotation property range axiom <span class="name">AnnotationPropertyRange( AP U )</span> states that the range of the annotation property <span class="name">AP</span> is the IRI <span class="name">U</span>.
</p>
<div class="grammar">
<p><span class="nonterminal">AnnotationPropertyRange</span>&nbsp;:= 'AnnotationPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">IRI</span> ')'
</p>
</div>
<a id="Global_Restrictions_on_Axioms_in_OWL_2_DL" name="Global_Restrictions_on_Axioms_in_OWL_2_DL"></a><h2> <span class="mw-headline">11  Global Restrictions on Axioms in OWL 2 DL </span></h2>
<p>The axiom closure <i>Ax</i> (with anonymous individuals standardized apart as explained in <a href="#Anonymous_Individuals" title="">Section 5.6.2</a>) of each OWL 2 DL ontology <i>O</i> <em class="RFC2119" title="MUST in RFC 2119 context">MUST</em> satisfy the <i>global restrictions</i> defined in this section. As explained in the literature [<cite><a href="#ref-sroiq" title="">SROIQ</a></cite>], this restriction is necessary in order to obtain a decidable language. The formal definition of these conditions is rather technical, so it is split into two parts. <a href="#Property_Hierarchy_and_Simple_Object_Property_Expressions" title="">Section 11.1</a> first introduces the notions of a property hierarchy and of <i>simple</i> object property expressions. These notions are then used in <a href="#The_Restrictions_on_the_Axiom_Closure" title="">Section 11.2</a> to define the actual conditions on <i>Ax</i>.
</p>
<a id="Property_Hierarchy_and_Simple_Object_Property_Expressions" name="Property_Hierarchy_and_Simple_Object_Property_Expressions"></a><h3> <span class="mw-headline">11.1  Property Hierarchy and Simple Object Property Expressions </span></h3>
<p>For an object property expression <span class="name">OPE</span>, the <i>inverse property expression</i> <span class="name">INV(OPE)</span> is defined as follows:
</p>
<ul><li> If <span class="name">OPE</span> is an object property <span class="name">OP</span>, then <span class="name">INV(OPE)</span> = <span class="name">ObjectInverseOf( OP )</span>.
</li><li> if <span class="name">OPE</span> is of the form <span class="name">ObjectInverseOf( OP )</span> for <span class="name">OP</span> an object property, then <span class="name">INV(OPE)</span> = <span class="name">OP</span>.
</li></ul>
<p>The set <i>AllOPE(Ax)</i> of all object property expressions w.r.t. <i>Ax</i> is the smallest set containing <span class="name">OP</span> and <span class="name">INV(OP)</span> for each object property <span class="name">OP</span> occurring in <i>Ax</i>.
</p><p>An object property expression <span class="name">OPE</span> is <i>composite</i> in the set of axioms <i>Ax</i> if 
</p>
<ul><li> <span class="name">OPE</span> is equal to <i>owl:topObjectProperty</i> or <i>owl:bottomObjectProperty</i>, or
</li><li> <i>Ax</i> contains an axiom of the form
<ul><li> <span class="name">SubObjectPropertyOf( ObjectPropertyChain( OPE<sub>1</sub> ... OPE<sub>n</sub> ) OPE )</span> with n &gt; 1, or
</li><li> <span class="name">SubObjectPropertyOf( ObjectPropertyChain( OPE<sub>1</sub> ... OPE<sub>n</sub> ) INV(OPE) )</span> with n &gt; 1, or
</li><li> <span class="name">TransitiveObjectProperty( OPE )</span>, or
</li><li> <span class="name">TransitiveObjectProperty( INV(OPE) )</span>.
</li></ul>
</li></ul>
<p>The relation &rarr; is the smallest relation on <i>AllOPE(Ax)</i> for which the following conditions hold (<span class="name">A</span> &rarr; <span class="name">B</span> means that &rarr; holds for <span class="name">A</span> and <span class="name">B</span>):
</p>
<ul><li> if <i>Ax</i> contains an axiom <span class="name">SubObjectPropertyOf( OPE<sub>1</sub> OPE<sub>2</sub> )</span>, then <span class="name">OPE<sub>1</sub></span> &rarr; <span class="name">OPE<sub>2</sub></span> holds; and
</li><li> if <i>Ax</i> contains an axiom <span class="name">EquivalentObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )</span>, then <span class="name">OPE<sub>1</sub></span> &rarr; <span class="name">OPE<sub>2</sub></span> and <span class="name">OPE<sub>2</sub></span> &rarr; <span class="name">OPE<sub>1</sub></span> hold; and
</li><li> if <i>Ax</i> contains an axiom <span class="name">InverseObjectProperties( OPE<sub>1</sub> OPE<sub>2</sub> )</span>, then <span class="name">OPE<sub>1</sub></span> &rarr; <span class="name">INV(OPE<sub>2</sub>)</span> and <span class="name">INV(OPE<sub>2</sub>)</span> &rarr; <span class="name">OPE<sub>1</sub></span> hold; and
</li><li> if <i>Ax</i> contains an axiom <span class="name">SymmetricObjectProperty(OPE)</span>, then <span class="name">OPE</span> &rarr; <span class="name">INV(OPE)</span> holds; and
</li><li> if <span class="name">OPE<sub>1</sub></span> &rarr; <span class="name">OPE<sub>2</sub></span> holds, then <span class="name">INV(OPE<sub>1</sub>)</span> &rarr; <span class="name">INV(OPE<sub>2</sub>)</span> holds as well.
</li></ul>
<p>The <i>property hierarchy</i> relation &rarr;<sup>*</sup> is the reflexive-transitive closure of &rarr;.
</p><p>An object property expression <span class="name">OPE</span> is <span id="def_simple"><i>simple</i></span> in <i>Ax</i> if, for each object property expression <span class="name">OPE'</span> such that <span class="name">OPE'</span> &rarr;<sup>*</sup> <span class="name">OPE</span> holds, <span class="name">OPE'</span> is not composite.
</p>
<div class="anexample">
<p>Roughly speaking, a simple object property expression has no direct or indirect subproperties that are either transitive or are defined by means of property chains, where the notion of indirect subproperties is captured by the property hierarchy. Consider the following axioms:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasFather</i> <i>a:hasBrother</i> ) <i>a:hasUncle</i> )
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> SubObjectPropertyOf( <i>a:hasUncle</i> <i>a:hasRelative</i> )
  </td><td> Having an uncle implies having a relative.
</td></tr>
<tr valign="top"><td> SubObjectPropertyOf( <i>a:hasBiologicalFather</i> <i>a:hasFather</i> )
  </td><td> Having a biological father implies having a father.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasUncle</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasFather</i> <i>a:hasBrother</i> ) .
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> <i>a:hasUncle</i> <i>rdfs:subPropertyOf</i> <i>a:hasRelative</i> .
  </td><td> Having an uncle implies having a relative.
</td></tr>
<tr valign="top"><td> <i>a:hasBiologicalFather</i> <i>rdfs:subPropertyOf</i> <i>a:hasFather</i> .
  </td><td> Having a biological father implies having a father.
</td></tr>
</tbody></table>
<p>The object property <i>a:hasUncle</i> occurs in an object subproperty axiom involving a property chain, so it is not simple. Consequently, the object property <i>a:hasRelative</i> is not simple either, because <i>a:hasUncle</i> is a subproperty of <i>a:hasRelative</i> and <i>a:hasUncle</i> is not simple. In contrast, the object property <i>a:hasBiologicalFather</i> is simple, and so is <i>a:hasFather</i>.
</p>
</div>
<a id="The_Restrictions_on_the_Axiom_Closure" name="The_Restrictions_on_the_Axiom_Closure"></a><h3> <span class="mw-headline">11.2  The Restrictions on the Axiom Closure </span></h3>
<p>The set of axioms <i>Ax</i> satisfies the <span id="def_global_restrictions"><i>global restrictions</i></span> of OWL 2 DL if all of the following conditions hold.
</p><p><b>Restriction on <i>owl:topDataProperty</i>.</b> The <i>owl:topDataProperty</i> property occurs in <i>Ax</i> only in the <span class="nonterminal">superDataPropertyExpression</span> part of <span class="nonterminal">SubDataPropertyOf</span> axioms.
</p><p>Without this restriction, <i>owl:topDataProperty</i> could be used to write axioms about datatypes, which would invalidate Theorem DS1 from the OWL 2 Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>]. That is, the consequences of an ontology would then not necessarily depend only on the datatypes used in the ontology, but would also depend on the datatypes selected in the OWL 2 datatype map. Thus, if an implementation or a future revision of OWL decided to extend the set of supported datatypes, it would run the risk of possibly changing the consequences of certain ontologies.
</p><p><b>Restrictions on Datatypes.</b>
</p>
<ul><li> Each datatype occurring in <i>Ax</i> satisfies exactly one of the following conditions: it is <i>rdfs:Literal</i>, or it is contained in the OWL 2 datatype map, or it is defined by a single datatype definition axiom in <i>Ax</i>.
</li><li> A strict partial order (i.e., an irreflexive and transitive relation) &lt; on the set of all datatypes in <i>Ax</i> exists such that, for each axiom of the form <span class="name">DatatypeDefinition( DT DR )</span> and each datatype <span class="name">DT<sub>1</sub></span> occurring in <span class="name">DR</span>, we have <span class="name">DT<sub>1</sub></span> &lt; <span class="name">DT</span>.
</li></ul>
<div class="anexample">
<p>The first condition ensures that all datatypes in <i>Ax</i> are given a well-defined interpretation and that datatype definitions do not redefine the datatypes from the OWL 2 datatype map. The second condition ensures that datatype definitions are acyclic &mdash; that is, if a datatype <span class="name">DT<sub>1</sub></span> is used in a definition of <span class="name">DT</span>, then <span class="name">DT</span> is not allowed to be used in the definition of <span class="name">DT<sub>1</sub></span> &mdash; and it is illustrated by the following example:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> Declaration( Datatype( <i>a:SSN</i> ) )
  </td><td> <i>a:SSN</i> is a datatype.
</td></tr>
<tr valign="top"><td> Declaration( Datatype( <i>a:TIN</i> ) )
  </td><td> <i>a:TIN</i> is a datatype.
</td></tr>
<tr valign="top"><td> Declaration( Datatype( <i>a:TaxNumber</i> ) )
  </td><td> <i>a:TaxNumber</i> is a datatype.
</td></tr>
<tr valign="top"><td> DatatypeDefinition(<br /> &nbsp;&nbsp;&nbsp; <i>a:SSN</i><br /> &nbsp;&nbsp;&nbsp; DatatypeRestriction( <i>xsd:string</i> <i>xsd:pattern</i> "[0-9]{3}-[0-9]{2}-[0-9]{4}" )<br /> )
  </td><td> A social security number is a string that matches the given regular expression.
</td></tr>
<tr valign="top"><td> DatatypeDefinition(<br /> &nbsp;&nbsp;&nbsp; <i>a:TIN</i><br /> &nbsp;&nbsp;&nbsp; DatatypeRestriction( <i>xsd:string</i> <i>xsd:pattern</i> "[0-9]{11}" )<br /> )
  </td><td> A TIN &mdash; a tax identification number used in Germany &mdash; is a string consisting of 11 digits.
</td></tr>
<tr valign="top"><td> DatatypeDefinition( <i>a:TaxNumber</i> DataUnionOf( <i>a:SSN</i> <i>a:TIN</i> ) )
  </td><td> A tax number is either a social security number of a TIN.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:SSN</i> <i>rdf:type</i> <i>rdfs:Datatype</i> .
  </td><td> <i>a:SSN</i> is a datatype.
</td></tr>
<tr valign="top"><td> <i>a:TIN</i> <i>rdf:type</i> <i>rdfs:Datatype</i> .
  </td><td> <i>a:TIN</i> is a datatype.
</td></tr>
<tr valign="top"><td> <i>a:TaxNumber</i> <i>rdf:type</i> <i>rdfs:Datatype</i> .
  </td><td> <i>a:TaxNumber</i> is a datatype.
</td></tr>
<tr valign="top"><td> <i>a:SSN</i> <i>owl:equivalentClass</i> _:x1 .<br /> _:x1 <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:x1 <i>owl:onDatatype</i> <i>xsd:string</i> .<br /> <i>_:x1 owl:withRestrictions</i> ( _:x2 ) .<br /> _:x2 <i>xsd:pattern</i> "[0-9]{3}-[0-9]{2}-[0-9]{4}" .
  </td><td> A social security number is a string that matches the given regular expression.
</td></tr>
<tr valign="top"><td> <i>a:TIN</i> <i>owl:equivalentClass</i> _:y1 .<br /> _:y1 <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:y1 <i>owl:onDatatype</i> <i>xsd:string</i> .<br /> <i>_:y1 owl:withRestrictions</i> ( _:y2 ) .<br /> _:y2 <i>xsd:pattern</i> "[0-9]{11}" .
  </td><td> A TIN &mdash; a tax identification number used in Germany &mdash; is a string consisting of 11 digits.
</td></tr>
<tr valign="top"><td> <i>a:TaxNumber</i> <i>owl:equivalentClass</i> _:z .<br /> _:z <i>rdf:type</i> <i>rdfs:Datatype</i> .<br /> _:z <i>owl:unionOf</i> ( <i>a:SSN</i> <i>a:TIN</i> ) .
  </td><td> A tax number is either a social security number of a TIN.
</td></tr>
</tbody></table>
<p>These datatype definitions are acyclic: <i>a:SSN</i> and <i>a:TIN</i> are defined in terms of <i>xsd:string</i>, and <i>a:TaxNumber</i> is defined in terms of <i>a:SSN</i> and <i>a:TIN</i>. To verify this condition formally, it suffices to find one strict partial order &lt; on these datatypes such that each datatype is defined only in terms of the datatypes that are smaller w.r.t. &lt;. For example, it can be readily verified that the partial order &lt; given below fulfills the above conditions.
</p>
<div class="indent">
<p><i>xsd:string</i> &nbsp; &lt; &nbsp; <i>a:SSN</i> &nbsp; &lt; &nbsp; <i>a:TaxNumber</i><br />
<i>xsd:string</i> &nbsp; &lt; &nbsp; <i>a:TIN</i> &nbsp; &lt; &nbsp; <i>a:TaxNumber</i>
</p>
</div>
<p>Note that order &lt; is allowed to be partial &mdash; that is, some datatypes can be incomparable under &lt;. In the above example, datatypes <i>a:SSN</i> and <i>a:TIN</i> are incomparable under &lt;. Since neither of these two datatypes is defined in terms of the other datatype, the order between the two datatypes is irrelevant.
</p><p>The restriction on datatypes is necessary to ensure validity of Theorem DS1 from the OWL 2 Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>]. Furthermore, the restriction is natural given that data ranges describe the set of values exactly. For example, if an axiom defining <i>a:SSN</i> in terms of <i>a:TIN</i> and <i>a:TaxNumber</i> were added to the above axioms, then datatypes <i>a:SSN</i>, <i>a:TIN</i>, and <i>a:TaxNumber</i> could not be simply "unfolded", which is contrary to the intended meaning of these datatypes. This situation, however, is disallowed since no ordering &lt; satisfying the mentioned restrictions exists for the extended axiom set.
</p>
</div>
<p><b>Restriction on Simple Roles.</b> Each class expression and each axiom in <i>Ax</i> of type from the following two lists contains only simple object properties.
</p>
<ul><li> <span class="nonterminal">ObjectMinCardinality</span>, <span class="nonterminal">ObjectMaxCardinality</span>, <span class="nonterminal">ObjectExactCardinality</span>, and <span class="nonterminal">ObjectHasSelf </span>.
</li><li> <span class="nonterminal">FunctionalObjectProperty</span>, <span class="nonterminal">InverseFunctionalObjectProperty</span>, <span class="nonterminal">IrreflexiveObjectProperty</span>, <span class="nonterminal">AsymmetricObjectProperty</span>, and <span class="nonterminal">DisjointObjectProperties</span>.
</li></ul>
<p>This restriction is necessary in order to guarantee decidability of the basic reasoning problems for OWL 2 DL [<cite><a href="#ref-description-logics" title="">Description Logics</a></cite>].
</p><p><b>Restriction on the Property Hierarchy.</b> A strict partial order (i.e., an irreflexive and transitive relation) &lt; on <i>AllOPE(Ax)</i> exists that fulfills the following conditions:
</p>
<ul><li> <span class="name">OP<sub>1</sub></span> &lt; <span class="name">OP<sub>2</sub></span> if and only if <span class="name">INV(OP<sub>1</sub>)</span> &lt; <span class="name">OP<sub>2</sub></span> for all object properties <span class="name">OP<sub>1</sub></span> and <span class="name">OP<sub>2</sub></span> occurring in <i>AllOPE(Ax)</i>.
</li><li> If <span class="name">OPE<sub>1</sub></span> &lt; <span class="name">OPE<sub>2</sub></span> holds, then <span class="name">OPE<sub>2</sub></span> &rarr;<sup>*</sup> <span class="name">OPE<sub>1</sub></span> does not hold;
</li><li> Each axiom in <i>Ax</i> of the form <span class="name">SubObjectPropertyOf( ObjectPropertyChain( OPE<sub>1</sub> ... OPE<sub>n</sub> ) OPE )</span> with n &ge; 2 fulfills the following conditions:
<ul><li> <span class="name">OPE</span> is equal to <i>owl:topObjectProperty</i>, or
</li><li> n = 2 and <span class="name">OPE<sub>1</sub></span> = <span class="name">OPE<sub>2</sub></span> = <span class="name">OPE</span>, or
</li><li> <span class="name">OPE<sub>i</sub></span> &lt; <span class="name">OPE</span> for each 1 &le; i &le; n, or
</li><li> <span class="name">OPE<sub>1</sub></span> = <span class="name">OPE</span> and <span class="name">OPE<sub>i</sub></span> &lt; <span class="name">OPE</span> for each 2 &le; i &le; n, or
</li><li> <span class="name">OPE<sub>n</sub></span> = <span class="name">OPE</span> and <span class="name">OPE<sub>i</sub></span> &lt; <span class="name">OPE</span> for each 1 &le; i &le; n-1.
</li></ul>
</li></ul>
<p>This restriction is necessary in order to guarantee decidability of the basic reasoning problems for OWL 2 DL [<cite><a href="#ref-description-logics" title="">Description Logics</a></cite>].
</p>
<div class="anexample">
<p>The main goal of this restriction is to prevent cyclic definitions involving object subproperty axioms with property chains. Consider the following ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasFather</i> <i>a:hasBrother</i> ) <i>a:hasUncle</i> )
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasUncle</i> <i>a:hasWife</i> ) <i>a:hasAuntInLaw</i> )
  </td><td> The wife of someone's uncle is that person's aunt-in-law.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasUncle</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasFather</i> <i>a:hasBrother</i> ) .
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> <i>a:hasAuntInLaw</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasUncle</i> <i>a:hasWife</i> ) .
  </td><td> The wife of someone's uncle is that person's aunt-in-law.
</td></tr>
</tbody></table>
<p>The first axiom defines <i>a:hasUncle</i> in terms of <i>a:hasFather</i> and <i>a:hasBrother</i>, and the second axiom defines <i>a:hasAuntInLaw</i> in terms of <i>a:hasUncle</i> and <i>a:hasWife</i>. The second axiom depends on the first one, but not vice versa; hence, these axioms are not cyclic and can occur together in the axiom closure of an OWL 2 DL ontology. To verify this condition formally, it suffices to find one strict partial order &lt; on object properties such that each property is defined only in terms of the properties that are smaller w.r.t. &lt;. For example, it can be readily verified that the partial order &lt; given below fulfills the above conditions.
</p>
<div class="indent">
<p><i>a:hasFather</i> &nbsp; &lt; &nbsp; <i>a:hasUncle</i><br />
<i>a:hasBrother</i> &nbsp; &lt; &nbsp; <i>a:hasUncle</i><br />
<i>a:hasUncle</i> &nbsp; &lt; &nbsp; <i>a:hasAuntInLaw</i><br />
<i>a:hasWife</i> &nbsp; &lt; &nbsp; <i>a:hasAuntInLaw</i>
</p>
</div>
<p>The first two conditions on &lt; are needed to satisfy the first axiom, while the remaining two conditions on &lt; are needed to satisfy the second axiom from the example OWL 2 DL ontology.
</p>
</div>
<div class="anexample">
<p>In contrast to the previous example, the following axioms are cyclic and do not satisfy the restriction on the property hierarchy.
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasFather</i> <i>a:hasBrother</i> ) <i>a:hasUncle</i> )
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasChild</i> <i>a:hasUncle</i> ) <i>a:hasBrother</i> )
  </td><td> The uncle of someone's child is that person's brother.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasUncle</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasFather</i> <i>a:hasBrother</i> ) .
  </td><td> The brother of someone's father is that person's uncle.
</td></tr>
<tr valign="top"><td> <i>a:hasBrother</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasChild</i> <i>a:hasUncle</i> ) .
  </td><td> The uncle of someone's child is that person's brother.
</td></tr>
</tbody></table>
<p>The first axiom defines <i>a:hasUncle</i> in terms of <i>a:hasBrother</i>, while the second axiom defines <i>a:hasBrother</i> in terms of <i>a:hasUncle</i>; these two definitions are thus cyclic and cannot occur together in the axiom closure of an OWL 2 DL ontology. To verify this condition formally, note that, for &lt; to satisfy the third subcondition of the third condition, we need <i>a:hasBrother</i> &lt; <i>a:hasUncle</i> (due to the first axiom) and <i>a:hasUncle</i> &lt; <i>a:hasBrother</i> (due to the second axiom); by transitivity of &lt; we then have <i>a:hasUncle</i> &lt; <i>a:hasUncle</i> and <i>a:hasBrother</i> &lt; <i>a:hasBrother</i>; however, this contradicts the requirement that &lt; is irreflexive. Thus, an order &lt; satisfying all the required conditions does not exist.
</p>
</div>
<div class="anexample">
<p>A particular kind of cyclic definitions is known not to lead to decidability problems. Consider the following ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> SubObjectPropertyOf( ObjectPropertyChain( <i>a:hasChild</i> <i>a:hasSibling</i> ) <i>a:hasChild</i> )
  </td><td> The sibling of someone's child is that person's child.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:hasChild</i> <i>owl:propertyChainAxiom</i> ( <i>a:hasChild</i> <i>a:hasSibling</i> ) .
  </td><td> The sibling of someone's child is that person's child.
</td></tr>
</tbody></table>
<p>The above definition is cyclic, since the object property <i>a:hasChild</i> occurs in both the subproperty chain and as a superproperty. As per the fourth and the fifth subcondition of the third condition, however, axioms of this form do not violate the restriction on the property hierarchy.
</p>
</div>
<p><b>Restrictions on the Usage of Anonymous Individuals.</b>
</p>
<ul><li> No anonymous individual occurs in <i>Ax</i> in an axiom of type from the following list:
<ul><li> <span class="nonterminal">SameIndividual</span>, <span class="nonterminal">DifferentIndividuals</span>, <span class="nonterminal">NegativeObjectPropertyAssertion</span>, or <span class="nonterminal">NegativeDataPropertyAssertion</span>.
</li></ul>
</li><li> No anonymous individual occurs in <i>Ax</i> in a class expression of type from the following list:
<ul><li> <span class="nonterminal">ObjectOneOf</span> or <span class="nonterminal">ObjectHasValue</span>.
</li></ul>
</li><li> The <i>anonymous individual graph</i> for <i>Ax</i> is the undirected graph <i>F</i> whose vertices are anonymous individuals occurring in <i>Ax</i>, and that contains an (undirected) edge between each pair of anonymous individuals <span class="name">_:x</span> and <span class="name">_:y</span> for each assertion in <i>Ax</i> of the form <span class="name">ObjectPropertyAssertion( OPE _:x _:y )</span>. Such <i>F</i> is required to satisfy all of the following conditions:
<ul><li> <i>F</i> is a forest &mdash; that is, it should be possible to partition <i>F</i> into zero or more disjoint undirected trees;
</li><li> for each pair of anonymous individuals <span class="name">_:x</span> and <span class="name">_:y</span> connected by an edge in <i>F</i>, the set <i>Ax</i> contains at most one assertion of the form <span class="name">ObjectPropertyAssertion( OPE _:x _:y )</span> or <span class="name">ObjectPropertyAssertion( OPE _:y _:x )</span>; and
</li><li> each tree in <i>F</i> contains at least one anonymous individual <span class="name">_:x</span> such that the set <i>Ax</i> contains at most one assertion of the form <span class="name">ObjectPropertyAssertion( OPE _:x a )</span> or <span class="name">ObjectPropertyAssertion( OPE a _:x )</span> with <span class="name">a</span> a named individual.
</li></ul>
</li></ul>
<div class="anexample">
<p>These restrictions ensure that each OWL 2 DL ontology with anonymous individuals can be transformed to an equivalent ontology without anonymous individuals. Roughly speaking, this is possible if property assertions connect anonymous individuals in a tree-like way. Consider the following ontology:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasChild</i> <i>a:Francis</i> _:a1 )
  </td><td> Francis has some (unknown) child.
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasChild</i> _:a1 <i>a:Meg</i> )
  </td><td> This unknown child has Meg...
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasChild</i> _:a1 <i>a:Chris</i> )
  </td><td> ...Chris...
</td></tr>
<tr valign="top"><td> ObjectPropertyAssertion( <i>a:hasChild</i> _:a1 <i>a:Stewie</i> )
  </td><td> ...and Stewie as children.
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td> <i>a:Francis</i> <i>a:hasChild</i> _:a1 .
  </td><td> Francis has some (unknown) child.
</td></tr>
<tr valign="top"><td> _:a1 <i>a:hasChild</i> <i>a:Meg</i> .
  </td><td> This unknown child has Meg...
</td></tr>
<tr valign="top"><td> _:a1 <i>a:hasChild</i> <i>a:Chris</i> .
  </td><td> ...Chris...
</td></tr>
<tr valign="top"><td> _:a1 <i>a:hasChild</i> <i>a:Stewie</i> .
  </td><td> ...and Stewie as children.
</td></tr>
</tbody></table>
<p>The connections between individuals <i>a:Francis</i>, <i>a:Meg</i>, <i>a:Chris</i>, and <i>a:Stewie</i> can be understood as a tree that contains <span class="name">_:a1</span> as its root. Because of that, the anonymous individuals can be "rolled up"; that is, these four assertions can be replaced by the following equivalent assertion:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ClassAssertion(<br /> &nbsp;&nbsp;&nbsp; ObjectSomeValuesFrom( <i>a:hasChild</i><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectIntersectionOf(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectHasValue( <i>a:hasChild</i> <i>a:Meg</i> )<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectHasValue( <i>a:hasChild</i> <i>a:Chris</i> )<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectHasValue( <i>a:hasChild</i> <i>a:Stewie</i> )<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; )<br /> &nbsp;&nbsp;&nbsp; <i>a:Francis</i><br /> )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> <i>a:Francis</i> <i>rdf:type</i> _:x .<br /> _:x <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:x <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:x <i>owl:someValuesFrom</i> _:y .<br /> _:y <i>rdf:type</i> <i>owl:Class</i> .<br /> _:y <i>owl:intersectionOf</i> ( _:z1 _:z2 _:z3 ) .<br /> _:z1 <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:z1 <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:z1 <i>owl:hasValue</i> <i>a:Meg</i> .<br /> _:z2 <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:z2 <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:z2 <i>owl:hasValue</i> <i>a:Chris</i> .<br /> _:z3 <i>rdf:type</i> <i>owl:Restriction</i> .<br /> _:z3 <i>owl:onProperty</i> <i>a:hasChild</i> .<br /> _:z3 <i>owl:hasValue</i> <i>a:Stewie</i> .
</td></tr>
</tbody></table>
</div>
<div class="anexample">
<p>Unlike in the previous example, the following ontology does not satisfy the restrictions on the usage of anonymous individuals:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasSibling</i> _:b1 _:b2 )
</td></tr>
<tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasSibling</i> _:b2 _:b3 )
</td></tr>
<tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasSibling</i> _:b3 _:b1 )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:b1 <i>a:hasSibling</i> _:b2 .
</td></tr>
<tr valign="top"><td colspan="2"> _:b2 <i>a:hasSibling</i> _:b3 .
</td></tr>
<tr valign="top"><td colspan="2"> _:b3 <i>a:hasSibling</i> _:b1 .
</td></tr>
</tbody></table>
<p>The following ontology does not satisfy these restrictions either:
</p>
<table class="fss">
<caption class="fss" style="display: none">Functional-Style Syntax:</caption>
<tbody><tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasChild</i> _:b1 _:b2 )
</td></tr>
<tr valign="top"><td colspan="2"> ObjectPropertyAssertion( <i>a:hasDaughter</i> _:b1 _:b2 )
</td></tr>
</tbody></table>
<table class="rdf" style="display: none">
<caption class="rdf">RDF:</caption>
<tbody><tr valign="top"><td colspan="2"> _:b1 <i>a:hasChild</i> _:b2 .
</td></tr>
<tr valign="top"><td colspan="2"> _:b1 <i>a:hasDaughter</i> _:b2 .
</td></tr>
</tbody></table>
<p>In both of these examples, the anonymous individuals are connected by property assertions in a non-tree-like way. These assertions can therefore not be replaced with class expressions, which can lead to the undecidability of the basic reasoning problems.
</p>
</div>
<a id="Appendix:_Internet_Media_Type.2C_File_Extension.2C_and_Macintosh_File_Type" name="Appendix:_Internet_Media_Type.2C_File_Extension.2C_and_Macintosh_File_Type"></a><h2> <span class="mw-headline">12  Appendix: Internet Media Type, File Extension, and Macintosh File Type  </span></h2>
<dl><dt> Contact</dt><dd>
</dd><dd> Ivan Herman / Sandro Hawke
</dd><dt> See also</dt><dd>
</dd><dd> How to Register a Media Type for a W3C Specification [<cite><a href="#ref-register-mime" title="">Register MIME</a></cite>] and Internet Media Type registration, consistency of use [<cite><a href="#ref-mime-consistency" title="">MIME Consistency</a></cite>].
</dd></dl>
<p>The Internet Media Type / MIME Type for the OWL functional-style Syntax is <tt>text/owl-functional</tt>.
</p><p>It is recommended that OWL functional-style Syntax files have the extension <tt>.ofn</tt> (all lowercase) on all platforms.
</p><p>It is recommended that OWL functional-style Syntax files stored on Macintosh HFS file systems be given a file type of <tt>TEXT</tt>.
</p><p>The information that follows will be submitted to the IESG for review, approval, and registration with IANA.
</p>
<dl><dt> Type name</dt><dd>
</dd><dd>    text
</dd><dt> Subtype name</dt><dd>
</dd><dd>    owl-functional
</dd><dt> Required parameters</dt><dd>
</dd><dd>   None
</dd><dt> Optional parameters</dt><dd>
</dd><dd>   charset  This parameter may be required when transfering non-ASCII data across some protocols. If present, the value of charset should be UTF-8.  
</dd><dt> Encoding considerations</dt><dd>
</dd><dd>    The syntax of the OWL functional-style Syntax is expressed over code points in Unicode [<cite><a href="#ref-unicode" title="">UNICODE</a></cite>]. The encoding should be UTF-8 [<cite><a href="#ref-rfc-3629" title="">RFC 3629</a></cite>], but other encodings are allowed.
</dd><dt> Security considerations</dt><dd>
</dd><dd>    The OWL functional-style Syntax uses IRIs as term identifiers. Applications interpreting data expressed in the OWL functional-style Syntax should address the security issues of Internationalized Resource Identifiers (IRIs) [<cite><a href="#ref-rfc-3987" title="">RFC3987</a></cite>] Section 8, as well as Uniform Resource Identifiers (URI): Generic Syntax [<cite><a href="#ref-rfc-3986" title="">RFC 3986</a></cite>] Section 7. Multiple IRIs may have the same appearance. Characters in different scripts may look similar (a Cyrillic "o" may appear similar to a Latin "o"). A character followed by combining characters may have the same visual representation as another character (LATIN SMALL LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E WITH ACUTE). Any person or application that is writing or interpreting data in the OWL functional-style Syntax must take care to use the IRI that matches the intended semantics, and avoid IRIs that may look similar. Further information about matching of similar characters can be found in Unicode Security Considerations [<cite><a href="#ref-unisec" title="">UNISEC</a></cite>] and Internationalized Resource Identifiers (IRIs) [<cite><a href="#ref-rfc-3987" title="">RFC3987</a></cite>] Section 8.
</dd><dt> Interoperability considerations</dt><dd>
</dd><dd>    There are no known interoperability issues.
</dd><dt> Published specification</dt><dd>
</dd><dd>    This specification.
</dd><dt> Applications which use this media type</dt><dd>
</dd><dd>     No widely deployed applications are known to currently use this media type. It is expected that OWL tools will use this media type in the future. 
</dd><dt> Additional information</dt><dd>
</dd><dd>     None.
</dd><dt> Magic number(s)</dt><dd>
</dd><dd>    OWL functional-style Syntax documents may have the strings "Prefix" or "Ontology" (case dependent) near the beginning of the document.
</dd><dt> File extension(s)</dt><dd>
</dd><dd>    ".ofn"
</dd><dt> Base IRI</dt><dd>
</dd><dd>   There are no constructs in the OWL functional-style Syntax to change the Base IRI.
</dd><dt> Macintosh file type code(s)</dt><dd>
</dd><dd>    "TEXT"
</dd><dt> Person &amp; email address to contact for further information</dt><dd>
</dd><dd>    Ivan Herman, ivan@w3.org / Sandro Hawke, sandro@w3.org. Please send technical comments and questions about OWL to public-owl-comments@w3.org, a mailing list with a public archive at <a class="external free" href="http://lists.w3.org/Archives/Public/public-owl-comments/" rel="nofollow" title="http://lists.w3.org/Archives/Public/public-owl-comments/">http://lists.w3.org/Archives/Public/public-owl-comments/</a>
</dd><dt> Intended usage</dt><dd>
</dd><dd>     COMMON
</dd><dt> Restrictions on usage</dt><dd>
</dd><dd>     None
</dd><dt> Author/Change controller</dt><dd>
</dd><dd>   The OWL functional-style Syntax is the product of the W3C OWL Working Group; W3C reserves change control over this specification.
</dd></dl>
<a id="Appendix:_Complete_Grammar_.28Normative.29" name="Appendix:_Complete_Grammar_.28Normative.29"></a><h2> <span class="mw-headline">13  Appendix: Complete Grammar (Normative) </span></h2>
<p>This section contains the complete grammar of the functional-style syntax defined in this specification document. For easier reference, the grammar has been split into two parts.
</p>
<a id="General_Definitions" name="General_Definitions"></a><h3> <span class="mw-headline">13.1  General Definitions </span></h3>
<div class="grammar">
<p><span class="nonterminal">nonNegativeInteger</span>&nbsp;:= <i>a nonempty finite sequence of digits between 0 and 9</i><br />
<span class="nonterminal">quotedString</span>&nbsp;:= <i>a finite sequence of characters in which " (U+22) and \ (U+5C) occur only in pairs of the form \" (U+5C, U+22) and \\ (U+5C, U+5C), enclosed in a pair of " (U+22) characters</i><br />
<span class="nonterminal">languageTag</span>&nbsp;:= <i>@ (U+40) followed a nonempty sequence of characters matching the langtag production from [<cite><a href="#ref-bcp-47" title="">BCP 47</a></cite>]</i><br />
<span class="nonterminal">nodeID</span>&nbsp;:= <i>a finite sequence of characters matching the BLANK_NODE_LABEL production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]</i><br />
<br />
<br />
<br />
<span class="nonterminal">fullIRI</span>&nbsp;:= <i>an IRI as defined in [<cite><a href="#ref-rfc-3987" title="">RFC3987</a></cite>], enclosed in a pair of &lt; (U+3C) and &gt; (U+3E) characters</i><br />
<span class="nonterminal">prefixName</span>&nbsp;:= <i>a finite sequence of characters matching the as PNAME_NS production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]</i><br />
<span class="nonterminal">abbreviatedIRI</span>&nbsp;:= <i>a finite sequence of characters matching the PNAME_LN production of [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]<br /></i>
<span class="nonterminal">IRI</span>&nbsp;:= <span class="nonterminal">fullIRI</span> | <span class="nonterminal">abbreviatedIRI</span><br />
<br />
<br />
<br />
<span class="nonterminal">ontologyDocument</span>&nbsp;:=  { <span class="nonterminal">prefixDeclaration</span> } <span class="nonterminal">Ontology</span><br />
<span class="nonterminal">prefixDeclaration</span>&nbsp;:= 'Prefix' '(' <span class="nonterminal">prefixName</span> '=' <span class="nonterminal">fullIRI</span> ')'<br />
<span class="nonterminal">Ontology</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; 'Ontology' '(' [ <span class="nonterminal">ontologyIRI</span> [ <span class="nonterminal">versionIRI</span> ] ]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">directlyImportsDocuments</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">ontologyAnnotations</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nonterminal">axioms</span><br />
&nbsp;&nbsp;&nbsp; ')'<br />
<span class="nonterminal">ontologyIRI</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">versionIRI</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">directlyImportsDocuments</span>&nbsp;:= { 'Import' '(' <span class="nonterminal">IRI</span> ')' }<br />
<span class="nonterminal">ontologyAnnotations</span>&nbsp;:= { <span class="nonterminal">Annotation</span> }<br />
<span class="nonterminal">axioms</span>&nbsp;:= { <span class="nonterminal">Axiom</span> }<br />
<br />
<br />
<br />
<span class="nonterminal">Declaration</span>&nbsp;:= 'Declaration' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Entity</span> ')'<br />
<span class="nonterminal">Entity</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; 'Class' '(' <span class="nonterminal">Class</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'Datatype' '(' <span class="nonterminal">Datatype</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'ObjectProperty' '(' <span class="nonterminal">ObjectProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'DataProperty' '(' <span class="nonterminal">DataProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'AnnotationProperty' '(' <span class="nonterminal">AnnotationProperty</span> ')' |<br />
&nbsp;&nbsp;&nbsp; 'NamedIndividual' '(' <span class="nonterminal">NamedIndividual</span> ')'<br />
<br />
<br />
<br />
<span class="nonterminal">AnnotationSubject</span>&nbsp;:= <span class="nonterminal">IRI</span> | <span class="nonterminal">AnonymousIndividual</span><br />
<span class="nonterminal">AnnotationValue</span>&nbsp;:= <span class="nonterminal">AnonymousIndividual</span> | <span class="nonterminal">IRI</span> | <span class="nonterminal">Literal</span><br />
<span class="nonterminal">axiomAnnotations</span>&nbsp;:= { <span class="nonterminal">Annotation</span> }<br />
<br />
<span class="nonterminal">Annotation</span>&nbsp;:= 'Annotation' '(' <span class="nonterminal">annotationAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">AnnotationValue</span> ')'<br />
<span class="nonterminal">annotationAnnotations</span> &nbsp;:= { <span class="nonterminal">Annotation</span> }<br />
<br />
<span class="nonterminal">AnnotationAxiom</span>&nbsp;:= <span class="nonterminal">AnnotationAssertion</span> | <span class="nonterminal">SubAnnotationPropertyOf</span> | <span class="nonterminal">AnnotationPropertyDomain</span> | <span class="nonterminal">AnnotationPropertyRange</span><br />
<br />
<span class="nonterminal">AnnotationAssertion</span>&nbsp;:= 'AnnotationAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">AnnotationSubject</span> <span class="nonterminal">AnnotationValue</span> ')'<br />
<br />
<span class="nonterminal">SubAnnotationPropertyOf</span>&nbsp;:= 'SubAnnotationPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subAnnotationProperty</span> <span class="nonterminal">superAnnotationProperty</span> ')'<br />
<span class="nonterminal">subAnnotationProperty</span>&nbsp;:= <span class="nonterminal">AnnotationProperty</span><br />
<span class="nonterminal">superAnnotationProperty</span>&nbsp;:= <span class="nonterminal">AnnotationProperty</span><br />
<br />
<span class="nonterminal">AnnotationPropertyDomain</span>&nbsp;:= 'AnnotationPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">IRI</span> ')'<br />
<br />
<span class="nonterminal">AnnotationPropertyRange</span>&nbsp;:= 'AnnotationPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">AnnotationProperty</span> <span class="nonterminal">IRI</span> ')'
</p>
</div>
<a id="Definitions_of_OWL_2_Constructs" name="Definitions_of_OWL_2_Constructs"></a><h3> <span class="mw-headline">13.2  Definitions of OWL 2 Constructs </span></h3>
<div class="grammar">
<p><span class="nonterminal">Class</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">Datatype</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">ObjectProperty</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">DataProperty</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">AnnotationProperty</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">Individual</span>&nbsp;:= <span class="nonterminal">NamedIndividual</span> | <span class="nonterminal">AnonymousIndividual</span><br />
<br />
<span class="nonterminal">NamedIndividual</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<br />
<span class="nonterminal">AnonymousIndividual</span>&nbsp;:= <span class="nonterminal">nodeID</span><br />
<br />
<span class="nonterminal">Literal</span>&nbsp;:= <span class="nonterminal">typedLiteral</span> | <span class="nonterminal">stringLiteralNoLanguage</span> | <span class="nonterminal">stringLiteralWithLanguage</span><br />
<span class="nonterminal">typedLiteral</span>&nbsp;:= <span class="nonterminal">lexicalForm</span> '^^' <span class="nonterminal">Datatype</span><br />
<span class="nonterminal">lexicalForm</span>&nbsp;:= <span class="nonterminal">quotedString</span><br />
<span class="nonterminal">stringLiteralNoLanguage</span>&nbsp;:= <span class="nonterminal">quotedString</span><br />
<span class="nonterminal">stringLiteralWithLanguage</span>&nbsp;:= <span class="nonterminal">quotedString</span> <span class="nonterminal">languageTag</span><br />
<br />
<br />
<br />
<span class="nonterminal">ObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectProperty</span> | <span class="nonterminal">InverseObjectProperty</span><br />
<br />
<span class="nonterminal">InverseObjectProperty</span>&nbsp;:= 'ObjectInverseOf' '(' <span class="nonterminal">ObjectProperty</span> ')'<br />
<br />
<span class="nonterminal">DataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataProperty</span><br />
<br />
<br />
<br />
<span class="nonterminal">DataRange</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">Datatype</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataIntersectionOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataUnionOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataComplementOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataOneOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DatatypeRestriction</span><br />
<br />
<span class="nonterminal">DataIntersectionOf</span>&nbsp;:= 'DataIntersectionOf' '(' <span class="nonterminal">DataRange</span> <span class="nonterminal">DataRange</span> { <span class="nonterminal">DataRange</span> } ')'<br />
<br />
<span class="nonterminal">DataUnionOf</span>&nbsp;:= 'DataUnionOf' '(' <span class="nonterminal">DataRange</span> <span class="nonterminal">DataRange</span> { <span class="nonterminal">DataRange</span> } ')'<br />
<br />
<span class="nonterminal">DataComplementOf</span>&nbsp;:= 'DataComplementOf' '(' <span class="nonterminal">DataRange</span> ')'<br />
<br />
<span class="nonterminal">DataOneOf</span>&nbsp;:= 'DataOneOf' '(' <span class="nonterminal">Literal</span> { <span class="nonterminal">Literal</span> } ')'<br />
<br />
<span class="nonterminal">DatatypeRestriction</span>&nbsp;:= 'DatatypeRestriction' '(' <span class="nonterminal">Datatype</span> <span class="nonterminal">constrainingFacet</span> <span class="nonterminal">restrictionValue</span> { <span class="nonterminal">constrainingFacet</span> <span class="nonterminal">restrictionValue</span> } ')'<br />
<span class="nonterminal">constrainingFacet</span>&nbsp;:= <span class="nonterminal">IRI</span><br />
<span class="nonterminal">restrictionValue</span>&nbsp;:= <span class="nonterminal">Literal</span><br />
<br />
<br />
<br />
<span class="nonterminal">ClassExpression</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">Class</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectIntersectionOf</span> | <span class="nonterminal">ObjectUnionOf</span> | <span class="nonterminal">ObjectComplementOf</span> | <span class="nonterminal">ObjectOneOf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectSomeValuesFrom</span> | <span class="nonterminal">ObjectAllValuesFrom</span> | <span class="nonterminal">ObjectHasValue</span> | <span class="nonterminal">ObjectHasSelf</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectMinCardinality</span> | <span class="nonterminal">ObjectMaxCardinality</span> | <span class="nonterminal">ObjectExactCardinality</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataSomeValuesFrom</span> | <span class="nonterminal">DataAllValuesFrom</span> | <span class="nonterminal">DataHasValue</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataMinCardinality</span> | <span class="nonterminal">DataMaxCardinality</span> | <span class="nonterminal">DataExactCardinality</span><br />
<br />
<span class="nonterminal">ObjectIntersectionOf</span>&nbsp;:= 'ObjectIntersectionOf' '(' <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'<br />
<br />
<span class="nonterminal">ObjectUnionOf</span>&nbsp;:= 'ObjectUnionOf' '(' <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'<br />
<br />
<span class="nonterminal">ObjectComplementOf</span>&nbsp;:= 'ObjectComplementOf' '(' <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">ObjectOneOf</span>&nbsp;:= 'ObjectOneOf' '(' <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> }')'<br />
<br />
<span class="nonterminal">ObjectSomeValuesFrom</span>&nbsp;:= 'ObjectSomeValuesFrom' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">ObjectAllValuesFrom</span>&nbsp;:= 'ObjectAllValuesFrom' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">ObjectHasValue</span>&nbsp;:= 'ObjectHasValue' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">Individual</span> ')'<br />
<br />
<span class="nonterminal">ObjectHasSelf</span>&nbsp;:= 'ObjectHasSelf' '(' <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">ObjectMinCardinality</span>&nbsp;:= 'ObjectMinCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'<br />
<br />
<span class="nonterminal">ObjectMaxCardinality</span>&nbsp;:= 'ObjectMaxCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'<br />
<br />
<span class="nonterminal">ObjectExactCardinality</span>&nbsp;:= 'ObjectExactCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">ObjectPropertyExpression</span> [ <span class="nonterminal">ClassExpression</span> ] ')'<br />
<br />
<span class="nonterminal">DataSomeValuesFrom</span>&nbsp;:= 'DataSomeValuesFrom' '(' <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } <span class="nonterminal">DataRange</span> ')'<br />
<br />
<span class="nonterminal">DataAllValuesFrom</span>&nbsp;:= 'DataAllValuesFrom' '(' <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } <span class="nonterminal">DataRange</span> ')'<br />
<br />
<span class="nonterminal">DataHasValue</span>&nbsp;:= 'DataHasValue' '(' <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">Literal</span> ')'<br />
<br />
<span class="nonterminal">DataMinCardinality</span>&nbsp;:= 'DataMinCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'<br />
<br />
<span class="nonterminal">DataMaxCardinality</span>&nbsp;:= 'DataMaxCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'<br />
<br />
<span class="nonterminal">DataExactCardinality</span>&nbsp;:= 'DataExactCardinality' '(' <span class="nonterminal">nonNegativeInteger</span> <span class="nonterminal">DataPropertyExpression</span> [ <span class="nonterminal">DataRange</span> ] ')'<br />
<br />
<br />
<br />
<span class="nonterminal">Axiom</span>&nbsp;:= <span class="nonterminal">Declaration</span> | <span class="nonterminal">ClassAxiom</span> | <span class="nonterminal">ObjectPropertyAxiom</span> | <span class="nonterminal">DataPropertyAxiom</span> | <span class="nonterminal">DatatypeDefinition</span> | <span class="nonterminal">HasKey</span> | <span class="nonterminal">Assertion</span> | <span class="nonterminal">AnnotationAxiom</span><br />
<br />
<br />
<br />
<span class="nonterminal">ClassAxiom</span>&nbsp;:= <span class="nonterminal">SubClassOf</span> | <span class="nonterminal">EquivalentClasses</span> | <span class="nonterminal">DisjointClasses</span> | <span class="nonterminal">DisjointUnion</span><br />
<br />
<span class="nonterminal">SubClassOf</span>&nbsp;:= 'SubClassOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subClassExpression</span> <span class="nonterminal">superClassExpression</span> ')'<br />
<span class="nonterminal">subClassExpression</span>&nbsp;:= <span class="nonterminal">ClassExpression</span><br />
<span class="nonterminal">superClassExpression</span>&nbsp;:= <span class="nonterminal">ClassExpression</span><br />
<br />
<span class="nonterminal">EquivalentClasses</span>&nbsp;:= 'EquivalentClasses' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'<br />
<br />
<span class="nonterminal">DisjointClasses</span>&nbsp;:= 'DisjointClasses' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> } ')'<br />
<br />
<span class="nonterminal">DisjointUnion</span>&nbsp;:= 'DisjointUnion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Class</span> <span class="nonterminal">disjointClassExpressions</span> ')'<br />
<span class="nonterminal">disjointClassExpressions</span>&nbsp;:= <span class="nonterminal">ClassExpression</span> <span class="nonterminal">ClassExpression</span> { <span class="nonterminal">ClassExpression</span> }<br />
<br />
<br />
<br />
<span class="nonterminal">ObjectPropertyAxiom</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SubObjectPropertyOf</span> | <span class="nonterminal">EquivalentObjectProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DisjointObjectProperties</span> | <span class="nonterminal">InverseObjectProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectPropertyDomain</span> | <span class="nonterminal">ObjectPropertyRange</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">FunctionalObjectProperty</span> | <span class="nonterminal">InverseFunctionalObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ReflexiveObjectProperty</span> | <span class="nonterminal">IrreflexiveObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SymmetricObjectProperty</span> | <span class="nonterminal">AsymmetricObjectProperty</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">TransitiveObjectProperty</span><br />
<br />
<span class="nonterminal">SubObjectPropertyOf</span>&nbsp;:= 'SubObjectPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subObjectPropertyExpression</span> <span class="nonterminal">superObjectPropertyExpression</span> ')'<br />
<span class="nonterminal">subObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectPropertyExpression</span> | <span class="nonterminal">propertyExpressionChain</span><br />
<span class="nonterminal">propertyExpressionChain</span>&nbsp;:= 'ObjectPropertyChain' '(' <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'<br />
<span class="nonterminal">superObjectPropertyExpression</span>&nbsp;:= <span class="nonterminal">ObjectPropertyExpression</span><br />
<br />
<span class="nonterminal">EquivalentObjectProperties</span>&nbsp;:= 'EquivalentObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'<br />
<br />
<span class="nonterminal">DisjointObjectProperties</span>&nbsp;:= 'DisjointObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> { <span class="nonterminal">ObjectPropertyExpression</span> } ')'<br />
<br />
<span class="nonterminal">ObjectPropertyDomain</span>&nbsp;:= 'ObjectPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">ObjectPropertyRange</span>&nbsp;:= 'ObjectPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">InverseObjectProperties</span>&nbsp;:= 'InverseObjectProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">FunctionalObjectProperty</span>&nbsp;:= 'FunctionalObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">InverseFunctionalObjectProperty</span>&nbsp;:= 'InverseFunctionalObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">ReflexiveObjectProperty</span>&nbsp;:= 'ReflexiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">IrreflexiveObjectProperty</span>&nbsp;:= 'IrreflexiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">SymmetricObjectProperty</span>&nbsp;:= 'SymmetricObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">AsymmetricObjectProperty</span>&nbsp;:= 'AsymmetricObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<span class="nonterminal">TransitiveObjectProperty</span>&nbsp;:= 'TransitiveObjectProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> ')'<br />
<br />
<br />
<br />
<span class="nonterminal">DataPropertyAxiom</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SubDataPropertyOf</span> | <span class="nonterminal">EquivalentDataProperties</span> | <span class="nonterminal">DisjointDataProperties</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataPropertyDomain</span> | <span class="nonterminal">DataPropertyRange</span> | <span class="nonterminal">FunctionalDataProperty</span><br />
<br />
<span class="nonterminal">SubDataPropertyOf</span>&nbsp;:= 'SubDataPropertyOf' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">subDataPropertyExpression</span> <span class="nonterminal">superDataPropertyExpression</span> ')'<br />
<span class="nonterminal">subDataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataPropertyExpression</span><br />
<span class="nonterminal">superDataPropertyExpression</span>&nbsp;:= <span class="nonterminal">DataPropertyExpression</span><br />
<br />
<span class="nonterminal">EquivalentDataProperties</span>&nbsp;:= 'EquivalentDataProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } ')'<br />
<br />
<span class="nonterminal">DisjointDataProperties</span>&nbsp;:= 'DisjointDataProperties' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataPropertyExpression</span> { <span class="nonterminal">DataPropertyExpression</span> } ')'<br />
<br />
<span class="nonterminal">DataPropertyDomain</span>&nbsp;:= 'DataPropertyDomain' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">ClassExpression</span> ')'<br />
<br />
<span class="nonterminal">DataPropertyRange</span>&nbsp;:= 'DataPropertyRange' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">DataRange</span> ')'<br />
<br />
<span class="nonterminal">FunctionalDataProperty</span>&nbsp;:= 'FunctionalDataProperty' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> ')'<br />
<br />
<br />
<br />
<span class="nonterminal">DatatypeDefinition</span>&nbsp;:= 'DatatypeDefinition' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Datatype</span> <span class="nonterminal">DataRange</span> ')'<br />
<br />
<br />
<br />
<span class="nonterminal">HasKey</span>&nbsp;:= 'HasKey' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> '(' { <span class="nonterminal">ObjectPropertyExpression</span> } ')' '(' { <span class="nonterminal">DataPropertyExpression</span> } ')' ')'<br />
<br />
<br />
<br />
<span class="nonterminal">Assertion</span>&nbsp;:=<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">SameIndividual</span> | <span class="nonterminal">DifferentIndividuals</span> | <span class="nonterminal">ClassAssertion</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">ObjectPropertyAssertion</span> | <span class="nonterminal">NegativeObjectPropertyAssertion</span> |<br />
&nbsp;&nbsp;&nbsp; <span class="nonterminal">DataPropertyAssertion</span> | <span class="nonterminal">NegativeDataPropertyAssertion</span><br />
<br />
<span class="nonterminal">sourceIndividual</span>&nbsp;:= <span class="nonterminal">Individual</span><br />
<span class="nonterminal">targetIndividual</span>&nbsp;:= <span class="nonterminal">Individual</span><br />
<span class="nonterminal">targetValue</span>&nbsp;:= <span class="nonterminal">Literal</span><br />
<br />
<span class="nonterminal">SameIndividual</span>&nbsp;:= 'SameIndividual' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Individual</span> <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> } ')'<br />
<br />
<span class="nonterminal">DifferentIndividuals</span>&nbsp;:= 'DifferentIndividuals' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">Individual</span> <span class="nonterminal">Individual</span> { <span class="nonterminal">Individual</span> } ')'<br />
<br />
<span class="nonterminal">ClassAssertion</span>&nbsp;:= 'ClassAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ClassExpression</span> <span class="nonterminal">Individual</span> ')'<br />
<br />
<span class="nonterminal">ObjectPropertyAssertion</span>&nbsp;:= 'ObjectPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetIndividual</span> ')'<br />
<br />
<span class="nonterminal">NegativeObjectPropertyAssertion</span>&nbsp;:= 'NegativeObjectPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">ObjectPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetIndividual</span> ')'<br />
<br />
<span class="nonterminal">DataPropertyAssertion</span>&nbsp;:= 'DataPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetValue</span> ')'<br />
<br />
<span class="nonterminal">NegativeDataPropertyAssertion</span>&nbsp;:= 'NegativeDataPropertyAssertion' '(' <span class="nonterminal">axiomAnnotations</span> <span class="nonterminal">DataPropertyExpression</span> <span class="nonterminal">sourceIndividual</span> <span class="nonterminal">targetValue</span> ')'
</p>
</div>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">14  Appendix: Change Log (Informative) </span></h2>
<a id="Changes_Since_Recommendation" name="Changes_Since_Recommendation"></a><h3> <span class="mw-headline">14.1  Changes Since Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/">Recommendation of 27 October 2009</a>.
</p>
<ul><li> With the publication of the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">Recommendation of 5 April 2012</a>, the elements of OWL 2 which are based on XSD 1.1 are now considered required, and the note detailing the optional dependency on the XSD 1.1 <a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">Candidate Recommendation of 30 April, 2009</a> has been removed from the "Status of this Document" section.
</li><li> References to and dependencies on the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">Candidate Recommendation of 30 April, 2009</a> were amended to reflect the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">Recommendation of 5 April 2012</a>.
</li><li> The document parsing specification in <a href="#BNF_Notation" title="">Section 2.2</a> was made more precise by the addition of a canonical process (showing how a sequence of characters should be converted into a sequence of terminal symbols) and several examples.
</li><li> The restrictions on the axiom closure specified in <a href="#The_Restrictions_on_the_Axiom_Closure" title="">Section 11.2</a> were explained in more detail.
</li><li> Minor typographical errors were corrected as detailed on the <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Errata" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Errata">OWL 2 Errata</a> page.
</li></ul>
<a id="Changes_Since_Proposed_Recommendation" name="Changes_Since_Proposed_Recommendation"></a><h3> <span class="mw-headline">14.2  Changes Since Proposed Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/PR-owl2-syntax-20090922/" rel="nofollow" title="http://www.w3.org/TR/2009/PR-owl2-syntax-20090922/">Proposed Recommendation of 22 September, 2009</a>.
</p>
<ul><li> Some minor editorial changes were made.
</li></ul>
<a id="Changes_Since_Candidate_Recommendation" name="Changes_Since_Candidate_Recommendation"></a><h3> <span class="mw-headline">14.3  Changes Since Candidate Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/CR-owl2-syntax-20090611/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-owl2-syntax-20090611/">Candidate Recommendation of 11 June, 2009</a>.
</p>
<ul><li> The "Feature At Risk" warnings w.r.t. the owl:rational and rdf:XMLLiteral datatypes were removed: implementation support has been adequately demonstrated, and the features are no longer considered at risk (see <a class="external text" href="http://www.w3.org/2007/OWL/meeting/2009-08-05#resolution_5" rel="nofollow" title="http://www.w3.org/2007/OWL/meeting/2009-08-05#resolution_5">Resolution 5</a> and <a class="external text" href="http://www.w3.org/2007/OWL/meeting/2009-08-05#resolution_6" rel="nofollow" title="http://www.w3.org/2007/OWL/meeting/2009-08-05#resolution_6">Resolution 6</a>, 05 August 2009).
</li><li> The definition of the OWL 2 datatype map was strengthened so as to make it clear that OWL 2 DL ontologies can include only the specified datatypes, facets and values.
</li><li> The definition of <span class="nonterminal">HasKey</span> axioms was fixed to make it clear that each such axiom must involve at least one property.
</li><li> The restrictions in <a href="#Datatypes" title="">Section 5.2</a> on the usage of datatypes in an OWL 2 DL ontology were clarified.
</li><li> The restrictions in <a href="#Literals" title="">Section 5.7</a> on the allowed lexical forms of literals were weakened to apply to OWL 2 DL ontologies only.
</li><li> The restrictions in <a href="#Datatype_Restrictions" title="">Section 7.5</a> on the allowed facets in facet restrictions were weakened to apply to OWL 2 DL ontologies only.
</li><li> The restrictions in <a href="#The_Restrictions_on_the_Axiom_Closure" title="">Section 11.2</a> on the usage of datatypes were rephrased for clarity.
</li><li> The restrictions in <a href="#The_Restrictions_on_the_Axiom_Closure" title="">Section 11.2</a> on the usage of anonymous individuals were rephrased for clarity.
</li><li> Sundry small editorial changes were made.
</li></ul>
<a id="Changes_Since_Last_Call" name="Changes_Since_Last_Call"></a><h3> <span class="mw-headline">14.4  Changes Since Last Call </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/WD-owl2-syntax-20090421/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-owl2-syntax-20090421/">Last Call Working Draft of 21 April, 2009</a>.
</p>
<ul><li> Per the warning in an "at-risk" comment, the name of <i>owl:dateTime</i> was changed to <i>xsd:dateTime</i> to conform to the name that will be part of XML Schema.
</li><li> The name of rdf:text was changed to rdf:PlainLiteral.
</li><li> Two of the examples were fixed.
</li><li> Some minor editorial changes were made.
</li></ul>
</div>
<a id="Acknowledgments" name="Acknowledgments"></a><h2> <span class="mw-headline">15  Acknowledgments </span></h2>
<p>The starting point for the development of OWL 2 was the <a class="external text" href="http://www.w3.org/Submission/2006/10/" rel="nofollow" title="http://www.w3.org/Submission/2006/10/">OWL1.1 member submission</a>, itself a result of user and developer feedback, and in particular of information gathered during the <a class="external text" href="http://www.webont.org/owled/" rel="nofollow" title="http://www.webont.org/owled/">OWL Experiences and Directions (OWLED) Workshop series</a>. The working group also considered <a class="external text" href="http://www.w3.org/2001/sw/WebOnt/webont-issues.html" rel="nofollow" title="http://www.w3.org/2001/sw/WebOnt/webont-issues.html">postponed issues</a> from the <a class="external text" href="http://www.w3.org/2004/OWL/" rel="nofollow" title="http://www.w3.org/2004/OWL/">WebOnt Working Group</a>.
</p><p>This document has been produced by the OWL Working Group (see below), and its contents reflect extensive discussions within the Working Group as a whole.
The editors extend special thanks to
Bernardo Cuenca Grau (Oxford University Computing Laboratory),
Ivan Herman (W3C/ERCIM),
Mike Smith (Clark &amp; Parsia) and
Vojtech Svatek (K-Space)
for their thorough reviews.
</p><p>The regular attendees at meetings of the OWL Working Group at the time of publication of this document were:
Jie Bao (RPI),
Diego Calvanese (Free University of Bozen-Bolzano),
Bernardo Cuenca Grau (Oxford University Computing Laboratory),
Martin Dzbor (Open University),
Achille Fokoue (IBM Corporation),
Christine Golbreich (Universit&eacute; de Versailles St-Quentin and LIRMM),
Sandro Hawke (W3C/MIT),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Ian Horrocks (Oxford University Computing Laboratory),
Elisa Kendall (Sandpiper Software),
Markus Kr&ouml;tzsch (FZI),
Carsten Lutz (Universit&auml;t Bremen),
Deborah L. McGuinness (RPI),
Boris Motik (Oxford University Computing Laboratory),
Jeff Pan (University of Aberdeen),
Bijan Parsia (University of Manchester),
Peter F. Patel-Schneider (Bell Labs Research, Alcatel-Lucent),
Sebastian Rudolph (FZI),
Alan Ruttenberg (Science Commons),
Uli Sattler (University of Manchester),
Michael Schneider (FZI),
Mike Smith (Clark &amp; Parsia),
Evan Wallace (NIST),
Zhe Wu (Oracle Corporation), and
Antoine Zimmermann (DERI Galway).
We would also like to thank past members of the working group:
Jeremy Carroll,
Jim Hendler, and
Vipul Kashyap.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">16  References </span></h2>
<a id="Normative_References" name="Normative_References"></a><h3> <span class="mw-headline">16.1  Normative References </span></h3>
<dl><dt> <span id="ref-bcp-47">[BCP 47]</span>
</dt><dd> <cite><a class="external text" href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt" rel="nofollow" title="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47 - Tags for Identifying Languages</a></cite>. A. Phillips and M. Davis, eds.  IETF, September 2006. http://www.rfc-editor.org/rfc/bcp/bcp47.txt
</dd><dt> <span id="ref-iso-8601-2004">[ISO 8601:2004]</span>
</dt><dd> <cite>ISO 8601:2004. Representations of dates and times.</cite> ISO (International Organization for Standardization).
</dd><dt> <span id="ref-iso-iec-10646">[ISO/IEC 10646]</span>
</dt><dd> <cite>ISO/IEC 10646-1:2000. Information technology &mdash; Universal Multiple-Octet Coded Character Set (UCS) &mdash; Part 1: Architecture and Basic Multilingual Plane and ISO/IEC 10646-2:2001. Information technology &mdash; Universal Multiple-Octet Coded Character Set (UCS) &mdash; Part 2: Supplementary Planes, as, from time to time, amended, replaced by a new edition or expanded by the addition of new parts. [Geneva]: International Organization for Standardization.</cite> ISO (International Organization for Standardization).
</dd><dt> <span id="ref-rfc-2119">[RFC 2119]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc2119.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</a></cite>. Network Working Group, S. Bradner. IETF, March 1997, http://www.ietf.org/rfc/rfc2119.txt
</dd><dt> <span id="ref-rfc-3629">[<a class="external" href="http://tools.ietf.org/html/rfc3629" title="http://tools.ietf.org/html/rfc3629">RFC 3629</a>]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc3629.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629: UTF-8, a transformation format of ISO 10646</a></cite>.  F. Yergeau.  IETF, November 2003, http://www.ietf.org/rfc/rfc3629.txt
</dd><dt> <span id="ref-rfc-3987">[RFC 3987]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987: Internationalized Resource Identifiers (IRIs)</a></cite>. M. Duerst and M. Suignard. IETF, January 2005, http://www.ietf.org/rfc/rfc3987.txt
</dd><dt> <span id="ref-rdf-concepts">[RDF Concepts]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a></cite>. Graham Klyne and Jeremy J. Carroll, eds. W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/.  Latest version available as http://www.w3.org/TR/rdf-concepts/.
</dd><dt> <span id="ref-rdf-testcases">[RDF Test Cases]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/">RDF Test Cases</a></cite>. Jan Grant and Dave Beckett, eds.  W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/.  Latest version available as http://www.w3.org/TR/rdf-testcases/.
</dd><dt> <span id="ref-rdf-plain-literal">[RDF:PLAINLITERAL]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-rdf-plain-literal-20121211/"><span>rdf:PlainLiteral: A Datatype for RDF Plain Literals (Second Edition)</span></a></cite> Jie Bao, Sandro Hawke, Boris Motik, Peter F. Patel-Schneider, Axel Polleres, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-rdf-plain-literal-20121211/">http://www.w3.org/TR/2012/REC-rdf-plain-literal-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/rdf-plain-literal-1/">http://www.w3.org/TR/rdf-plain-literal-1/</a>.</span></dd><dt> <span id="ref-sparql">[SPARQL]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/" rel="nofollow" title="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for RDF</a></cite>. Eric Prud'hommeaux and Andy Seaborne, eds. W3C Recommendation, 15 January 2008, http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/.  Latest version available as http://www.w3.org/TR/rdf-sparql-query/.
</dd><dt> <span id="ref-uml">[UML]</span>
</dt><dd> <cite><a class="external text" href="http://www.omg.org/spec/UML/2.1.2/Infrastructure/PDF/" rel="nofollow" title="http://www.omg.org/spec/UML/2.1.2/Infrastructure/PDF/">OMG Unified Modeling Language (OMG UML), Infrastructure, V2.1.2</a></cite>. Object Management Group, OMG Available Specification, November 2007, http://www.omg.org/spec/UML/2.1.2/Infrastructure/PDF/.
</dd><dt> <span id="ref-unicode">[UNICODE]</span>
</dt><dd> <cite><a class="external text" href="http://www.unicode.org/unicode/standard/" rel="nofollow" title="http://www.unicode.org/unicode/standard/">The Unicode Standard</a></cite>. The Unicode Consortium, Version 5.1.0, <a class="internal" href="http://www.w3.org/2007/OWL/wiki/Special:BookSources/0321480910">ISBN 0-321-48091-0</a>, as updated from time to time by the publication of new versions. (See <a class="external free" href="http://www.unicode.org/unicode/standard/versions/" rel="nofollow" title="http://www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database).
</dd><dt> <span id="ref-xml">[XML]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2008/REC-xml-20081126/" rel="nofollow" title="http://www.w3.org/TR/2008/REC-xml-20081126/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a></cite>. Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, and Fran&ccedil;ois Yergeau, eds. W3C Recommendation, 26 November 2008, http://www.w3.org/TR/2008/REC-xml-20081126/.  Latest version available as http://www.w3.org/TR/xml/.
</dd><dt> <span id="ref-xml-schema-datatypes">[XML Schema Datatypes]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>. David Peterson, Shudi (Sandy) Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and Henry S. Thompson, eds. (Version 1.1) and Paul V. Biron, and Ashok Malhotra, eds. (Version 1.0). W3C Recommendation, 5 April 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/</a>. Latest version available as <a class="external free" href="http://www.w3.org/TR/xmlschema11-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
</dd></dl>
<a id="Nonnormative_References" name="Nonnormative_References"></a><h3> <span class="mw-headline">16.2  Nonnormative References </span></h3>
<dl><dt> <span id="ref-description-logics">[Description Logics]</span>
</dt><dd> <a class="external text" href="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254" rel="nofollow" title="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254"><cite>The Description Logic Handbook: Theory, Implementation, and Applications, second edition</cite></a>. Franz Baader, Diego Calvanese, Deborah L. McGuinness, Daniele Nardi, and Peter F. Patel-Schneider, eds. Cambridge University Press, 2007.  Also see the <a class="external text" href="http://dl.kr.org/" rel="nofollow" title="http://dl.kr.org/"><cite>Description Logics Home Page</cite></a>.
</dd><dt> <span id="ref-dl-safe">[DL-Safe]</span>
</dt><dd> <cite><a class="external text" href="http://www.websemanticsjournal.org/index.php/ps/article/view/63" rel="nofollow" title="http://www.websemanticsjournal.org/index.php/ps/article/view/63">Query Answering for OWL-DL with Rules</a></cite>. Boris Motik, Ulrike Sattler and Rudi Studer. Journal of Web Semantics: Science, Services and Agents on the World Wide Web, 3(1):41&ndash;60, 2005.
</dd><dt> <span id="ref-mime-consistency">[MIME Consistency]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/2001/tag/2004/0430-mime" rel="nofollow" title="http://www.w3.org/2001/tag/2004/0430-mime">Internet Media Type registration, consistency of use</a></cite>. Tim Bray, ed. W3C TAG Finding, 30 April 2004.
</dd><dt> <span id="ref-mof">[MOF]</span>
</dt><dd> <cite><a class="external text" href="http://www.omg.org/spec/MOF/2.0/PDF/" rel="nofollow" title="http://www.omg.org/spec/MOF/2.0/PDF/">Meta Object Facility (MOF) Core Specification, version 2.0</a></cite>. Object Management Group, OMG Available Specification January 2006, http://www.omg.org/spec/MOF/2.0/PDF/.
</dd><dt> <span id="ref-owl-2-rdf-mapping">[OWL 2 RDF Mapping]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">OWL 2 Web Ontology Language: <span>Mapping to RDF Graphs (Second Edition)</span></a></cite> Peter F. Patel-Schneider, Boris Motik, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-mapping-to-rdf/">http://www.w3.org/TR/owl2-mapping-to-rdf/</a>.</span></dd><dt> <span id="ref-owl-2-direct-semantics">[OWL 2 Direct Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">OWL 2 Web Ontology Language: <span>Direct Semantics (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bernardo Cuenca Grau, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-direct-semantics/">http://www.w3.org/TR/owl2-direct-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-rdf-semantics">[OWL 2 RDF-Based Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">OWL 2 Web Ontology Language: <span>RDF-Based Semantics (Second Edition)</span></a></cite> Michael Schneider, editor. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-rdf-based-semantics/">http://www.w3.org/TR/owl2-rdf-based-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-conformance">[OWL 2 Conformance]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">OWL 2 Web Ontology Language: <span>Conformance (Second Edition)</span></a></cite> Michael Smith, Ian Horrocks, Markus Kr&ouml;tzsch, Birte Glimm, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-conformance/">http://www.w3.org/TR/owl2-conformance/</a>.</span></dd><dt> <span id="ref-owl-2-xml-serialization">[OWL 2 XML Serialization]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">OWL 2 Web Ontology Language: <span>XML Serialization (Second Edition)</span></a></cite> Boris Motik, Bijan Parsia, Peter F. Patel-Schneider, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-xml-serialization/">http://www.w3.org/TR/owl2-xml-serialization/</a>.</span></dd><dt> <span id="ref-rdf-syntax">[RDF Syntax]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">RDF/XML Syntax Specification (Revised)</a></cite>. Dave Beckett, ed. W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/.  Latest version available as http://www.w3.org/TR/rdf-syntax-grammar/.
</dd><dt> <span id="ref-register-mime">[Register MIME]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/2002/06/registering-mediatype" rel="nofollow" title="http://www.w3.org/2002/06/registering-mediatype">Register an Internet Media Type for a W3C Spec</a></cite>. Philippe Le H&eacute;garet, ed. W3C Guidebook.
</dd><dt> <span id="ref-rfc-3986">[<a class="external" href="http://tools.ietf.org/html/rfc3986" title="http://tools.ietf.org/html/rfc3986">RFC 3986</a>]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc3986.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</a></cite>. T. Berners-Lee, R. Fielding, and L. Masinter. IETF, January 2005, http://www.ietf.org/rfc/rfc3986.txt
</dd><dt> <span id="ref-sroiq">[SROIQ]</span>
</dt><dd> <cite><a class="external text" href="http://www.cs.man.ac.uk/~sattler/publications/sroiq-TR.pdf" rel="nofollow" title="http://www.cs.man.ac.uk/~sattler/publications/sroiq-TR.pdf">The Even More Irresistible SROIQ</a></cite>. Ian Horrocks, Oliver Kutz, and Uli Sattler. In Proc. of the 10th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2006). AAAI Press, 2006.
</dd><dt> <span id="ref-unisec">[UNISEC]</span>
</dt><dd> <cite><a class="external text" href="http://www.unicode.org/reports/tr36/tr36-7.html" rel="nofollow" title="http://www.unicode.org/reports/tr36/tr36-7.html">Unicode Security Considerations</a></cite>.  Mark Davis and Michel Suignard.  Unicode technical report 36, 23 July 2008, http://www.unicode.org/reports/tr36/tr36-7.html.  Latest version available as http://www.unicode.org/reports/tr36/.
</dd><dt> <span id="ref-xml-namespaces">[XML Namespaces]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names-20060816/" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names-20060816/">Namespaces in XML 1.0 (Second Edition)</a></cite>. Tim Bray, Dave Hollander, Andrew Layman, and Richard Tobin, eds. W3C Recommendation, 16 August 2006, http://www.w3.org/TR/2006/REC-xml-names-20060816/. Latest version available as http://www.w3.org/TR/REC-xml-names/.
</dd></dl>


</body>
</html>