<!-- http://www.w3.org/TR/rif-rdf-owl/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF RDF and OWL Compatibility (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF RDF and OWL Compatibility (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/" id="this-version-url">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-rif-rdf-owl-20121211/">http://www.w3.org/TR/2012/PER-rif-rdf-owl-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Jos de Bruijn, Vienna University of Technology</dd>
<dd>Chris Welty, IBM Research</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2010/rif/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/REC-rif-rdf-owl-20130205.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2010/rif/translation/rif-rdf-owl">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div>Rules interchanged using the Rule Interchange Format RIF may depend on or be used in combination with RDF data and RDF Schema or OWL ontologies.  This document, developed by the <a class="external text" href="http://www.w3.org/2005/rules/wg" rel="nofollow" title="http://www.w3.org/2005/rules/wg">Rule Interchange Format (RIF) Working Group</a>, specifies the interoperation between RIF and the data and ontology languages RDF, RDF Schema, and OWL.</div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a>  (this document)</li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a></li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/PER-rif-rdf-owl-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Overview_of_RDF_and_OWL_Compatibility"><span class="tocnumber">1</span> <span class="toctext">Overview of RDF and OWL Compatibility</span></a></li>
<li class="toclevel-1"><a href="#Symbols_in_RIF_versus_RDF.2FOWL_.28Informative.29"><span class="tocnumber">2</span> <span class="toctext">Symbols in RIF versus RDF/OWL (Informative)</span></a></li>
<li class="toclevel-1"><a href="#RDF_Compatibility"><span class="tocnumber">3</span> <span class="toctext">RDF Compatibility</span></a>
<ul>
<li class="toclevel-2"><a href="#Syntax_of_RIF-RDF_Combinations"><span class="tocnumber">3.1</span> <span class="toctext">Syntax of RIF-RDF Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#RDF_Vocabularies_and_Graphs"><span class="tocnumber">3.1.1</span> <span class="toctext">RDF Vocabularies and Graphs</span></a></li>
<li class="toclevel-3"><a href="#RIF-RDF_Combinations"><span class="tocnumber">3.1.2</span> <span class="toctext">RIF-RDF Combinations</span></a></li>
<li class="toclevel-3"><a href="#Datatypes_and_Typed_Literals"><span class="tocnumber">3.1.3</span> <span class="toctext">Datatypes and Typed Literals</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Semantics_of_RIF-RDF_Combinations"><span class="tocnumber">3.2</span> <span class="toctext">Semantics of RIF-RDF Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#Interpretations"><span class="tocnumber">3.2.1</span> <span class="toctext">Interpretations</span></a>
<ul>
<li class="toclevel-4"><a href="#RDF_and_RIF_Interpretations"><span class="tocnumber">3.2.1.1</span> <span class="toctext">RDF and RIF Interpretations</span></a></li>
<li class="toclevel-4"><a href="#RDF_Lists"><span class="tocnumber">3.2.1.2</span> <span class="toctext">RDF Lists</span></a></li>
<li class="toclevel-4"><a href="#Common_RIF-RDF_Interpretations"><span class="tocnumber">3.2.1.3</span> <span class="toctext">Common RIF-RDF Interpretations</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#Satisfaction_and_Models"><span class="tocnumber">3.2.2</span> <span class="toctext">Satisfaction and Models</span></a></li>
<li class="toclevel-3"><a href="#Entailment"><span class="tocnumber">3.2.3</span> <span class="toctext">Entailment</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#OWL_Compatibility"><span class="tocnumber">4</span> <span class="toctext">OWL Compatibility</span></a>
<ul>
<li class="toclevel-2"><a href="#Syntax_of_RIF-OWL_Combinations"><span class="tocnumber">4.1</span> <span class="toctext">Syntax of RIF-OWL Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#Safeness_Restrictions"><span class="tocnumber">4.1.1</span> <span class="toctext">Safeness Restrictions</span></a></li>
<li class="toclevel-3"><a href="#Datatypes_in_OWL_2"><span class="tocnumber">4.1.2</span> <span class="toctext">Datatypes in OWL 2</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Semantics_of_RIF-OWL_Combinations"><span class="tocnumber">4.2</span> <span class="toctext">Semantics of RIF-OWL Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#OWL_RDF-Based_Semantics"><span class="tocnumber">4.2.1</span> <span class="toctext">OWL RDF-Based Semantics</span></a></li>
<li class="toclevel-3"><a href="#OWL_Direct_Semantics"><span class="tocnumber">4.2.2</span> <span class="toctext">OWL Direct Semantics</span></a>
<ul>
<li class="toclevel-4"><a href="#Modified_Semantics_for_RIF_Subclass.2C_Membership.2C_and_Frame_Formulas"><span class="tocnumber">4.2.2.1</span> <span class="toctext">Modified Semantics for RIF Subclass, Membership, and Frame Formulas</span></a></li>
<li class="toclevel-4"><a href="#Semantics_of_RIF-OWL_DL_Combinations"><span class="tocnumber">4.2.2.2</span> <span class="toctext">Semantics of RIF-OWL DL Combinations</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Importing_RDF_and_OWL_in_RIF"><span class="tocnumber">5</span> <span class="toctext">Importing RDF and OWL in RIF</span></a>
<ul>
<li class="toclevel-2"><a href="#Profiles_of_Imports"><span class="tocnumber">5.1</span> <span class="toctext">Profiles of Imports</span></a>
<ul>
<li class="toclevel-3"><a href="#Specific_Profiles"><span class="tocnumber">5.1.1</span> <span class="toctext">Specific Profiles</span></a></li>
<li class="toclevel-3"><a href="#Generic_Profile"><span class="tocnumber">5.1.2</span> <span class="toctext">Generic Profile</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Interpretation_of_Profiles"><span class="tocnumber">5.2</span> <span class="toctext">Interpretation of Profiles</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_Clauses"><span class="tocnumber">6</span> <span class="toctext">Conformance Clauses</span></a></li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">7</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">8.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Informational_References"><span class="tocnumber">8.2</span> <span class="toctext">Informational References</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Embeddings_.28Informative.29"><span class="tocnumber">9</span> <span class="toctext">Appendix: Embeddings (Informative)</span></a>
<ul>
<li class="toclevel-2"><a href="#Embedding_RIF-RDF_Combinations"><span class="tocnumber">9.1</span> <span class="toctext">Embedding RIF-RDF Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#Embedding_Symbols"><span class="tocnumber">9.1.1</span> <span class="toctext">Embedding Symbols</span></a></li>
<li class="toclevel-3"><a href="#Embedding_Triples_and_Graphs"><span class="tocnumber">9.1.2</span> <span class="toctext">Embedding Triples and Graphs</span></a></li>
<li class="toclevel-3"><a href="#Embedding_Simple_Entailment"><span class="tocnumber">9.1.3</span> <span class="toctext">Embedding Simple Entailment</span></a></li>
<li class="toclevel-3"><a href="#Embedding_RDF_Entailment"><span class="tocnumber">9.1.4</span> <span class="toctext">Embedding RDF Entailment</span></a></li>
<li class="toclevel-3"><a href="#Embedding_RDFS_Entailment"><span class="tocnumber">9.1.5</span> <span class="toctext">Embedding RDFS Entailment</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Embedding_RIF-OWL_2_RL_Combinations"><span class="tocnumber">9.2</span> <span class="toctext">Embedding RIF-OWL 2 RL Combinations</span></a>
<ul>
<li class="toclevel-3"><a href="#Embedding_RIF_DL-document_formulas_into_RIF_BLD"><span class="tocnumber">9.2.1</span> <span class="toctext">Embedding RIF DL-document formulas into RIF BLD</span></a></li>
<li class="toclevel-3"><a href="#Embedding_OWL_2_RL_into_RIF_BLD"><span class="tocnumber">9.2.2</span> <span class="toctext">Embedding OWL 2 RL into RIF BLD</span></a>
<ul>
<li class="toclevel-4"><a href="#Normalization_of_OWL_2_RL"><span class="tocnumber">9.2.2.1</span> <span class="toctext">Normalization of OWL 2 RL</span></a></li>
<li class="toclevel-4"><a href="#Embedding_Normalized_OWL_2_RL"><span class="tocnumber">9.2.2.2</span> <span class="toctext">Embedding Normalized OWL 2 RL</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Change_log_.28Informative.29"><span class="tocnumber">10</span> <span class="toctext">Appendix: Change log (Informative)</span></a></li>
<li class="toclevel-1"><a href="#End_Notes"><span class="tocnumber">11</span> <span class="toctext">End Notes</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Overview_of_RDF_and_OWL_Compatibility" name="Overview_of_RDF_and_OWL_Compatibility"></a><h2> <span class="mw-headline">1  Overview of RDF and OWL Compatibility </span></h2>
<p>The Rule Interchange Format (RIF) is a format for interchanging rules over the Web. Rules that are exchanged using RIF may refer to external data sources and may be based on data models that are represented using a language different from RIF.  The Resource Description Framework <a class="external text" href="http://www.w3.org/RDF/" rel="nofollow" title="http://www.w3.org/RDF/">RDF</a> [<a href="#ref-rdf-concepts" title="">RDF-Concepts</a>] is a Web-based language for the representation and exchange of data; <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/">RDF Schema</a> (RDFS) [<a href="#ref-rdf-schema" title="">RDF-Schema</a>] and the <a class="external text" href="http://www.w3.org/2007/OWL/" rel="nofollow" title="http://www.w3.org/2007/OWL/">OWL</a> Web Ontology Language [<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>] are Web-based languages for representing and exchanging ontologies.  This document specifies how combinations of RIF documents and RDF data and RDFS and OWL ontologies are interpreted; i.e., it specifies how RIF interoperates with RDF, RDFS, and OWL.  We consider here OWL 2  [<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>], which is an extension of OWL 1  [<a href="#ref-owl-reference" title="">OWL-Reference</a>]. Therefore, the notions defined in this document also apply to combinations of RIF documents with OWL 1 ontologies.
</p><p>We consider here the RIF Basic Logic Dialect (BLD) [<a href="#ref-rif-bld" title="">RIF-BLD</a>] and RIF Core [<a href="#ref-rif-core" title="">RIF-Core</a>], a subset of RIF BLD. 
The RIF Production Rule Dialect (PRD) [<a href="#ref-rif-prd" title="">RIF-PRD</a>] is an extension of RIF Core. Interoperability between RIF and RDF/OWL is only defined for the Core subset of PRD. In the remainder, when speaking about RIF documents and rules, we refer to RIF Core and BLD. 
</p><p>RDF data and RDFS and OWL ontologies can be represented using <i>RDF graphs</i>. There exist several alternative syntaxes for OWL ontologies; however, for exchange purposes it is assumed they are represented using RDF graphs.  
</p><p>Several syntaxes have been proposed for the exchange of RDF graphs, the normative syntax being RDF/XML [<a href="#ref-rdf-syntax" title="">RDF-Syntax</a>].  RIF does not provide a format for exchanging RDF graphs; it is assumed that RDF graphs are exchanged using RDF/XML, or any other syntax that can be used for representing or exchanging RDF graphs. 
</p><p>A typical scenario for the use of RIF with RDF/OWL is the exchange of rules that use RDF data and/or RDFS or OWL ontologies: an interchange partner <i>A</i> has a rules language that is RDF/OWL-aware, i.e., it supports the use of RDF data, it uses an RDFS or OWL ontology, or it extends RDF(S)/OWL. <i>A</i> sends its rules using RIF, possibly with references to the appropriate RDF graph(s), to partner <i>B</i>.  <i>B</i> receives the rules and retrieves the referenced RDF graph(s). The rules are translated to the internal rules language of <i>B</i> and are processed, together with the RDF graphs, using the RDF/OWL-aware rule engine of  <i>B</i>.  The use case <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/#Vocabulary_Mapping_for_Data_Integration" title="UCR">Vocabulary Mapping for Data Integration</a> [<a href="#ref-rif-ucr" title="">RIF-UCR</a>] is an example of the interchange of RIF rules that use RDF data and RDFS ontologies.
</p><p>A specialization of this scenario is the publication of RIF rules that refer to RDF graphs; publication is a special kind of interchange: one to many, rather than one-to-one.  When a rule publisher <i>A</i> publishes its rules on the Web, there may be several consumers that retrieve the RIF rules and RDF graphs from the Web, translate the RIF rules to their respective rules languages, and process them together with the RDF graphs in their own rules engines. The use case <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/#Publishing_Rules_for_Interlinked_Metadata" title="UCR">Publishing Rules for Interlinked Metadata</a> [<a href="#ref-rif-ucr" title="">RIF-UCR</a>] illustrates the publication scenario.
</p><p>Another specialization of the exchange scenario is the <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/#Interchanging_Rule_Extensions_to_OWL" title="UCR">Interchange of Rule Extensions to OWL</a> [<a href="#ref-rif-ucr" title="">RIF-UCR</a>].  The intention of the rule publisher in this scenario is to extend an OWL ontology with rules: interchange partner <i>A</i> has a rules language that extends OWL.  <i>A</i> splits its ontology+rules description into a separate OWL ontology and a RIF document, publishes the OWL ontology, and sends (or publishes) the RIF document, which includes a reference to the OWL ontology.  A consumer of the rules retrieves the OWL ontology and translates the ontology and document into a combined ontology+rules description in its own rule extension of OWL.
</p><p><br />
A RIF document that refers to (<i>imports</i>) RDF graphs and/or RDFS/OWL ontologies, or any use of a RIF document with RDF graphs, is viewed as a combination of a document and a number of graphs and ontologies. This document specifies how, in such a combination, the document and the graphs and ontologies interoperate in a technical sense, i.e., the conditions under which the combination is satisfiable (i.e., consistent), as well as the entailments (i.e., logical consequences) of the combination. 
The interaction between RIF and RDF/OWL is realized by connecting the model theory of RIF [<a href="#ref-rif-bld" title="">RIF-BLD</a>] with the model theories of RDF [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>] and OWL [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>], respectively.
</p><p><br />
The notation of certain symbols in RIF, particularly IRIs and plain literals, is slightly different from the notation in RDF/OWL.  These differences are illustrated in the Section <a href="#sec-swc-symbols-rdf-owl" title="">Symbols in RIF Versus RDF/OWL</a>.
</p><p>The RDF Semantics specification [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>] defines four normative notions of entailment for RDF graphs: Simple, RDF, RDFS, and Datatype entailment. OWL 2 specifies two different semantics, with corresponding notions of entailment: the Direct Semantics [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>] and the RDF-Based Semantics [<a href="#ref-owl2-rdf-based-semantics" title="">OWL2-RDF-Based-Semantics</a>]. This document specifies the interaction between RIF and RDF/OWL for all six notions. The Section <a href="#RDF_Compatibility" title="">RDF Compatibility</a> is concerned with the combination of RIF and RDF/RDFS.  The combination of RIF and OWL is addressed in the Section <a href="#OWL_Compatibility" title="">OWL Compatibility</a>. The semantics of the interaction between RIF and the OWL 2 Direct Semantics is close in spirit to [<a href="#ref-swrl" title="">SWRL</a>].
</p><p>RIF provides a mechanism for referring to (importing) RDF graphs and a means for specifying the <i>profile</i> of this import, which corresponds to the intended entailment regime. The Section <a href="#Importing_RDF_and_OWL_in_RIF" title="">Importing RDF and OWL in RIF</a> specifies how such import statements are used for representing RIF-RDF and RIF-OWL combinations.
</p><p>The <a href="#Appendix:_Embeddings_.28Informative.29" title="">Appendix: Embeddings (Informative)</a> describes how reasoning with combinations of RIF rules with RDF and OWL 2 RL (a subset of OWL 2 DL) can be reduced to reasoning with RIF documents. This reduction can be seen as an implementation hint for interchange partners who do not have RDF/OWL-aware rule systems, but want to process RIF rules that import RDF graphs and OWL ontologies. In terms of the aforementioned scenario: if the interchange partner <i>B</i> does not have an RDF/OWL-aware rule system, but <i>B</i> can process RIF rules, then the appendix explains how the rule system of <i>B</i> could be used for processing RIF-RDF/OWL combinations.
</p><p>Throughout this document the following conventions are used when writing RIF and RDF statements in examples and definitions.
</p>
<ul><li> All RIF statements are written using the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#Direct_Specification_of_RIF-BLD_Presentation_Syntax" title="BLD">RIF presentation syntax</a> [<a href="#ref-rif-bld" title="">RIF-BLD</a>].  Where possible, this document uses the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#Constants_and_Symbol_Spaces" title="DTB">shortcut syntax for IRIs and strings</a> as defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</li><li> RDF triples are written using the Turtle syntax [<a href="#ref-turtle" title="">Turtle</a>]: triples are written as <tt>s p o</tt>, where <tt>s</tt>, <tt>p</tt>, and <tt>o</tt> are blank nodes <tt>_:<i>x</i></tt>, IRIs delimited with '<tt>&lt;</tt>' and '<tt>&gt;</tt>', compact IRIs <tt><i>prefix</i>:<i>localname</i></tt>, plain literals without language tags <tt>"<i>literal</i>"</tt>, plain literals with language tags <tt>"<i>literal</i>"@<i>lang</i></tt>, or typed literals <tt>"<i>literal</i>"^^<i>datatype-IRI</i></tt>.
</li><li> The following namespace prefixes are used throughout this document: <tt>ex</tt> refers to <tt>http://example.org/example#</tt>, <tt>xs</tt> refers to <tt>http://www.w3.org/2001/XMLSchema#</tt>, <tt>rdf</tt> refers to <tt>http://www.w3.org/1999/02/22-rdf-syntax-ns#</tt>, <tt>rdfs</tt> refers to <tt>http://www.w3.org/2000/01/rdf-schema#</tt>, <tt>owl</tt> refers to <tt>http://www.w3.org/2002/07/owl#</tt>, and <tt>rif</tt> refers to <tt>http://www.w3.org/2007/rif#</tt>.
</li></ul>
<p><span class="anchor" id="sec-swc-symbols-rdf-owl"></span>
</p>
<a id="Symbols_in_RIF_versus_RDF.2FOWL_.28Informative.29" name="Symbols_in_RIF_versus_RDF.2FOWL_.28Informative.29"></a><h2> <span class="mw-headline">2  Symbols in RIF versus RDF/OWL (Informative) </span></h2>
<p>Where RDF/OWL has four kinds of constants: <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">URI references</a> (i.e., IRIs), <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">plain literals without language tags</a>, <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">plain literals with language tags</a> and <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">typed literals</a> (i.e., Unicode sequences with datatype IRIs) [<a href="#ref-rdf-concepts" title="">RDF-Concepts</a>], RIF has one kind of constants: Unicode sequences with symbol space IRIs [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. 
</p><p><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-symspace" title="DTB">Symbol spaces</a> can be seen as groups of constants. Every datatype is a symbol space, but there are symbol spaces that are not datatypes.  For example, the symbol space <tt>rif:iri</tt> groups all IRIs.  
The correspondence between constant symbols in RDF graphs and RIF documents is explained in <a href="#tab-rif-rdf-symbol-correspondence" title="">Table 1</a>.
</p>
<table border="1" id="tab-rif-rdf-symbol-correspondence">	
<caption>Table 1. Correspondence between RDF and RIF symbols.</caption>	
<tr>	
<th>RDF Symbol</th>	
<th>Example</th>	
<th>RIF Symbol</th>	
<th>Example</th>	
</tr>	
<tr>	
<td>IRI</td>	
<td><tt>&lt;http://www.w3.org/2007/rif&gt;</tt></td>	
<td>Constant in the <tt>rif:iri</tt> symbol space</td>	
<td><tt>"http://www.w3.org/2007/rif"^^rif:iri</tt></td>	
</tr>	
<tr>	
<td>Plain literal without language tag</td>	
<td><tt>"literal string"</tt></td>	
<td>Constant in the <tt>rdf:PlainLiteral</tt> symbol space</td>	
<td><tt>"literal string@"^^rdf:PlainLiteral</tt></td>	
</tr>	
<tr>	
<td>Plain literal with language tag</td>	
<td><tt>"literal string"@en</tt></td>	
<td>Constant in the <tt>rdf:PlainLiteral</tt> symbol space</td>	
<td><tt>"literal string@en"^^rdf:PlainLiteral</tt></td>	
</tr>	
<tr>	
<td>Typed literal</td>	
<td><tt>"1"^^xs:integer</tt></td>	
<td>Constant with symbol space</td>	
<td><tt>"1"^^xs:integer</tt></td>	
</tr>	
</table>
<p>The <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#Constants_and_Symbol_Spaces" title="DTB">shortcut syntax for IRIs and strings</a> [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], used throughout this document, corresponds to the syntax for IRIs and plain literals in Turtle [<a href="#ref-turtle" title="">Turtle</a>], a commonly used syntax for RDF.
</p>
<ul><li> IRIs, i.e., constants of the form <tt>"<i>IRI</i>"^^rif:iri</tt>, may be written as <tt>&lt;<i>IRI</i>&gt;</tt> or as compact IRIs [<a href="#ref-curie" title="">CURIE</a>], i.e., as <tt><i>prefix</i>:<i>localname</i></tt>, where <tt><i>prefix</i></tt> is understood to refer to an IRI <tt><i>namespace-IRI</i></tt>, and <tt><i>prefix</i>:<i>localname</i></tt> stands for the IRI (<tt><i>IRI</i></tt>) obtained by concatenating <tt><i>namespace-IRI</i></tt> and <tt><i>localname</i></tt>.
</li><li> Plain literals without language tags, i.e., constants of the form <tt>"<i>my string@</i>"^^rdf:PlainLiteral</tt> may be written as <tt>"<i>my string</i>"</tt>.
</li></ul>
<p>RIF does not have a notion corresponding exactly to RDF <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-blank-nodes" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-blank-nodes">blank nodes</a>.  RIF <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#Constants_and_Symbol_Spaces" title="DTB">local symbols</a>, written <tt>_<i>symbolname</i></tt>, have some commonality with blank nodes; like the blank node label, the name of a local symbol is not exposed outside of the document.  However, in contrast to blank nodes, which are essentially existentially quantified variables, RIF local symbols are <i>constant</i> symbols. In many applications and deployment scenarios, this difference may be     inconsequential.  However the results will differ when such symbols are used in a non-assertional context, such as in a query pattern or rule body.
</p><p>Finally, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-alphabet" title="BLD">variables</a> in the bodies of RIF rules or in query patterns may be existentially quantified, and are thus similar to blank nodes; however, RIF BLD does not allow existentially quantified variables to occur in rule heads.
</p>
<a id="RDF_Compatibility" name="RDF_Compatibility"></a><h2> <span class="mw-headline">3  RDF Compatibility </span></h2>
<p>This section specifies how a RIF document interacts with a set of RDF graphs in a RIF-RDF combination.  In other words, how rules can "access" data in the RDF graphs.
</p><p>There is a correspondence between statements in RDF graphs and certain kinds of formulas in RIF.  Namely, there is a correspondence between RDF triples of the form <tt>s p o</tt> and RIF frame formulas of the form <tt>s'[p' -&gt; o']</tt>, where <tt>s'</tt>, <tt>p'</tt>, and <tt>o'</tt> are RIF symbols corresponding to the RDF symbols <tt>s</tt>, <tt>p</tt>, and <tt>o</tt>, respectively. This means that whenever a triple <tt>s p o</tt> is satisfied, the corresponding RIF frame formula <tt>s'[p' -&gt; o']</tt> is satisfied, and vice versa. 
</p><p>Consider, for example, a combination of an RDF graph that contains the triples 
</p>
<pre>ex:john ex:brotherOf ex:jack . 
ex:jack ex:parentOf ex:mary . 
</pre>
<p>saying that <tt>ex:john</tt> is a brother of <tt>ex:jack</tt> and <tt>ex:jack</tt> is a parent of <tt>ex:mary</tt>,
and a RIF document that contains the rule
</p>
<pre>Forall&nbsp;?x&nbsp;?y&nbsp;?z (?x[ex:uncleOf -&gt;&nbsp;?z]&nbsp;:- 
     And(?x[ex:brotherOf -&gt;&nbsp;?y]&nbsp;?y[ex:parentOf -&gt;&nbsp;?z]))
</pre>
<p>which says that whenever some <tt>x</tt> is a brother of some <tt>y</tt> and <tt>y</tt> is a parent of some <tt>z</tt>, then <tt>x</tt> is an uncle of <tt>z</tt>.  From this combination the RIF frame formula <tt>:john[:uncleOf -&gt;&nbsp;:mary]</tt>, as well as the RDF triple <tt>:john&nbsp;:uncleOf&nbsp;:mary</tt>, are consequences of this combination.
</p><p>Note that blank nodes cannot be referenced directly from RIF rules, since blank nodes are local to a specific RDF graph.  Variables in RIF rules do, however, range over objects denoted by blank nodes.  So, it is possible to "access" an object denoted by a blank node from a RIF rule using a variable in a rule.
</p><p>The following example illustrates the interaction between RDF and RIF in the face of blank nodes.
</p><p>Consider a combination of an RDF graph that contains the triple 
</p>
<pre>_:x ex:hasName "John" . 
</pre>
<p>saying that there is something, denoted here by a blank node, which has the name <tt>"John"</tt>, and a RIF document that contains the rules
</p>
<pre>Forall&nbsp;?x&nbsp;?y (&nbsp;?x[rdf:type -&gt; ex:named]&nbsp;:-&nbsp;?x[ex:hasName -&gt;&nbsp;?y] )
Forall&nbsp;?x&nbsp;?y ( &lt;http://a&gt;[&lt;http://p&gt; -&gt; ?y] :- ?x[ex:hasName -&gt; ?y] )
</pre>
<p>which says that whenever there is some <tt>x</tt> that has some name <tt>y</tt>, then <tt>x</tt> is of type <tt>ex:named</tt> and <tt>http://a</tt> has a property <tt>http://p</tt> with value <tt>y</tt>.  
</p><p>From this combination the following RIF condition formulas  can be derived:
</p>
<pre>Exists ?z (?z[rdf:type -&gt; ex:named])
&lt;http://a&gt;[&lt;http://p&gt; -&gt; "John"]
</pre>
<p>as can the following RDF triples:
</p>
<pre>_:y rdf:type ex:named .
&lt;http://a&gt; &lt;http://p&gt; "John" . 
</pre>
<p>However, there is no RIF constant symbol <tt>t</tt> such that <tt>t[rdf:type -&gt; ex:named]</tt> can be derived, because there is no constant that represents the named individual.
</p><p><br />
Note that, even when considering <a href="#def-simple-entails" title="">Simple entailment</a>, not every combination is satisfiable.  In fact, not every RIF document has a model.  For example, the RIF BLD document consisting of the fact
</p>
<pre>"a"="b"
</pre>
<p>does not have a model, since the symbols <tt>"a"</tt> and <tt>"b"</tt> are mapped to the (distinct) character strings "a" and "b", respectively, in every semantic structure.
</p><p><br />
<span id="ex-difference-in-entailment">One consequence of the difference of the alphabets of RDF and RIF is that IRIs of the form <tt>http://iri</tt> and typed literals of the form <tt>"http://iri"^^rif:iri</tt> that occur in an RDF graph are treated the same in RIF-RDF combinations, even if the RIF document is empty. However, documents importing RDF graphs containing typed literals of the form <tt>"http://iri"^^rif:iri</tt> must be rejected.</span> 
</p><p><span id="ex-strings">Plain literals without language tags of the form <tt>"mystring"</tt> and typed literals of the form <tt>"mystring"^^xs:string</tt> also correspond. For example, consider the combination of an empty document and an RDF graph that contains the triple</span>
</p>
<pre>&lt;http://a&gt; &lt;http://p&gt; "abc" .
 
</pre>
<p>This combination entails, among other things, the following frame formula:
</p>
<pre>&lt;http://a&gt;[&lt;http://p&gt; -&gt; "abc"^^xs:string]
</pre>
<p>as well as the following triple:
</p>
<pre>&lt;http://a&gt; &lt;http://p&gt; "abc"^^xs:string .
</pre>
<p>These entailments are sanctioned by the semantics of plain literals and <tt>xs:string</tt>s. 
</p><p><br />
Lists in RDF (also called <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-primer-20040210/#collections" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-primer-20040210/#collections">collections</a>) have a natural correspondence to RIF lists. For example, the RDF list <tt>_:l1 rdf:first ex:b .  _:l1 rdf:rest rdf:nil .</tt> corresponds to the RIF list <tt>List(ex:b)</tt>. And so, the combination of the empty RIF document with the RDF graph
</p>
<pre>ex:a ex:p _:l1 .
_:l1 rdf:first ex:b .
_:l1 rdf:rest rdf:nil .
</pre>
<p>entails the formula
</p>
<pre>ex:a[ex:p -&gt; List(ex:b)].
</pre>
<p><br />
Likewise, the combination of the empty RDF graph with the RIF fact
</p>
<pre>ex:p(List(ex:a))
</pre>
<p>entails the triples
</p>
<pre>_:l1 rdf:first ex:a .
_:l1 rdf:rest rdf:nil .
</pre>
<p>as well as the formula
</p>
<pre>Exists&nbsp;?x (And(ex:p(?x)&nbsp;?x[rdf:first -&gt; ex:a]&nbsp;?x[rdf:rest -&gt; rdf:nil])).
</pre>
<p><br />
The remainder of this section formally defines combinations of RIF rules with RDF graphs and the semantics of such combinations. A combination consists of a RIF document and a set of RDF graphs. The semantics of combinations is defined in terms of combined models, which are pairs of RIF and RDF interpretations. The interaction between the two interpretations is defined through a number of conditions.  Entailment is defined as model inclusion, as usual.
</p>
<a id="Syntax_of_RIF-RDF_Combinations" name="Syntax_of_RIF-RDF_Combinations"></a><h3> <span class="mw-headline">3.1  Syntax of RIF-RDF Combinations </span></h3>
<p>This section first reviews the definitions of RDF Vocabularies and RDF graphs, after which RIF-RDF combinations are formally defined. The section concludes with a review of definitions related to datatypes and typed literals. 
</p>
<a id="RDF_Vocabularies_and_Graphs" name="RDF_Vocabularies_and_Graphs"></a><h4> <span class="mw-headline">3.1.1  RDF Vocabularies and Graphs </span></h4>
<p>An RDF <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defvocab" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defvocab">Vocabulary</a> <i>V</i> consists of the following sets of <i>names</i>:
</p>
<ul><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-Graph-URIref" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-Graph-URIref">IRIs</a> <i>V<sub>U</sub></i>, (corresponds to the Concepts and Abstract Syntax term "<i><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">RDF URI references</a></i>"; see the <a href="#note-rdf-uri-references" title="">End note on RDF URI references</a>)
</li></ul>
<ul><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">plain literals</a>  <i>V<sub>PL</sub></i> (i.e., character strings with an optional language tag), and 
</li></ul>
<ul><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">typed literals</a> <i>V<sub>TL</sub></i> (i.e., pairs of character strings and datatype IRIs).
</li></ul>
<p>In addition, there is an infinite set of <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank nodes</a>, which is disjoint from the sets of names. See <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF Concepts and Abstract Syntax</a> [<a href="#ref-rdf-concepts" title="">RDF-Concepts</a>] for precise definitions of these concepts. 
</p><p><b>Definition.</b> Given an RDF Vocabulary <i>V</i>, a <i><b>generalized RDF triple</b></i> of <i>V</i> is a statement of the form <tt>s p o</tt>, where <tt>s</tt>,  <tt>p</tt> and <tt>o</tt> are names in <i>V</i> or blank nodes.  &nbsp;&nbsp;☐
</p><p><b>Definition.</b> Given an RDF Vocabulary <i>V</i>, a <span id="def-generalized-rdf-graph"><i><b>generalized RDF graph</b></i></span> is a set of <i><b>generalized RDF triples</b></i> of  <i>V</i>.  &nbsp;&nbsp;☐
</p><p>(See the <a href="#note-generalized-rdf-graphs" title="">End note on generalized RDF graphs</a>)
</p>
<a id="RIF-RDF_Combinations" name="RIF-RDF_Combinations"></a><h4> <span class="mw-headline">3.1.2  RIF-RDF Combinations </span></h4>
<p>A RIF-RDF combination consists of a RIF document and zero or more RDF graphs.  Formally:
</p><p><b>Definition.</b> A <span id="def-rif-rdf-combination"><i><b>RIF-RDF combination</b></i></span> is a pair &lt; <i>R</i>,<b>S</b>&gt;, where <i>R</i> is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">RIF document</a> and <b>S</b> is a set of <a href="#def-generalized-rdf-graph" title="">generalized RDF graphs</a> of a Vocabulary <i>V</i>.  &nbsp;&nbsp;☐
</p><p>When clear from the context, RIF-RDF combinations are referred to simply as <i><b>combinations</b></i>.
</p>
<a id="Datatypes_and_Typed_Literals" name="Datatypes_and_Typed_Literals"></a><h4> <span class="mw-headline">3.1.3  Datatypes and Typed Literals </span></h4>
<p>Even though RDF allows the use of arbitrary datatype IRIs in typed literals, not all such datatype IRIs are recognized in the semantics.  In fact, Simple entailment does not recognize any datatype and RDF and RDFS entailment recognize only the datatype <tt><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-XMLLiteral" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-XMLLiteral">rdf:XMLLiteral</a></tt>. To facilitate discussing datatypes, and specifically datatypes supported in specific contexts (required for RIF-D-entailment), the notion of datatype maps [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>] is used.
</p><p>A <i><b><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap">datatype map</a></b></i> is a partial mapping from IRIs to <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-datatype" title="DTB">datatypes</a>. 
</p><p>RDFS, specifically RIF-D-entailment, allows the use of arbitrary datatype maps, as long as <tt>rdf:XMLLiteral</tt> is in the domain of the map.  RIF BLD requires a number of additional datatypes to be included; these are the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-required-datatypes" title="DTB"><i>RIF-required datatypes</i></a> [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>When checking consistency of a <a href="#def-rif-rdf-combination" title="">combination</a> &lt; <i>R</i>,<b>S</b>&gt; or entailment of a graph <i>S</i> or RIF formula &phi; by a combination &lt; <i>R</i>,<b>S</b>&gt;, the set of <span id="def-considered-datatypes"><i><b>considered datatypes</b></i></span> is the union of the set of <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-required-datatypes" title="DTB">RIF-required datatypes</a> and the sets of datatypes referenced in <i>R</i>, the documents <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-imported-doc" title="BLD">imported into</a> <i>R</i>, and &phi; (when considering entailment of &phi;).
</p><p><b>Definition.</b> Let DTS be a set of <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-datatype" title="DTB">datatypes</a>. A <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap">datatype map</a> D is <span id="def-conforming-datatype-map"><i><b>conforming</b></i></span> with DTS if it satisfies the following conditions:
</p>
<ol><li> Every IRI identifying a datatype in DTS is in the domain of D. 
</li><li> D maps each IRI in its domain to the datatype identified by that IRI in DTS. &nbsp;&nbsp;☐
</li></ol>
<p>Note that it follows from the definition that every datatype used in the RIF document in the combination or the entailed RIF formula (when considering entailment questions) is included in any datatype map conforming to the set of considered datatypes.  There may be datatypes used in an RDF graph in the combination that are not included in such a datatype map.
</p><p><b>Definition.</b> Given a datatype map D, a typed literal (<tt>s</tt>, <tt>d</tt>) is a <span id="def-well-typed-literal"><i><b>well-typed literal</b></i></span> if
</p>
<ol><li> <tt>d</tt> is in the domain of D and <tt>s</tt> is in the lexical space of D(<tt>d</tt>) or
</li><li> <tt>d</tt> is the IRI of a <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-symspace" title="DTB">symbol space</a> required by RIF BLD and <tt>s</tt> is in the lexical space of the symbol space. &nbsp;&nbsp;☐
</li></ol>
<a id="Semantics_of_RIF-RDF_Combinations" name="Semantics_of_RIF-RDF_Combinations"></a><h3> <span class="mw-headline">3.2  Semantics of RIF-RDF Combinations </span></h3>
<p>The semantics of RIF-RDF combinations is defined through a combination of the RIF and RDF model theories, using a notion of <i>common models</i>. These models are then used to define satisfiability and entailment in the usual way. Combined entailment extends both entailment in RIF and entailment in RDF.
</p><p>The RDF Semantics document [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>] defines four normative kinds of interpretations, as well as corresponding notions of satisfiability and entailment: 
</p>
<ul><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#sinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#sinterp">Simple interpretations</a>, which do not impose any conditions on the RDF and RDFS Vocabularies, 
</li><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef">RDF interpretations</a>, which impose additional conditions on the interpretation of the RDF Vocabulary, 
</li><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef">RDFS interpretations</a>, which impose additional conditions on the interpretation of the RDF and RDFS Vocabularies, and 
</li><li> <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp">D-interpretations</a>, which impose additional conditions on the treatment of datatypes, relative to a <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDatatypeMap">datatype map</a> D. 
</li></ul>
<p>Those four types of interpretations are reflected in the definitions of satisfaction and entailment in this section.
</p>
<a id="Interpretations" name="Interpretations"></a><h4> <span class="mw-headline">3.2.1  Interpretations </span></h4>
<p>This section defines the notion of <i>common-RIF-RDF-interpretation</i>, which is an interpretation of a RIF-RDF combination.  This common-RIF-RDF-interpretation is the basis for the definitions of satisfaction and entailment in the following sections. 
</p><p>The correspondence between <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-sem-struct" title="BLD">RIF semantic structures</a> (interpretations) and <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp">RDF interpretations</a> is defined through a number of conditions that ensure the correspondence in the interpretation of names (i.e., IRIs and literals) and formulas, i.e., the correspondence between RDF triples of the form <tt>s p o</tt> and RIF frames of the form <tt>s'[p' -&gt; o']</tt>, where <tt>s'</tt>, <tt>p'</tt>, and <tt>o'</tt> are RIF symbols corresponding to the RDF symbols <tt>s</tt>, <tt>p</tt>, and <tt>o</tt>, respectively (cf. the Section <a href="#sec-swc-symbols-rdf-owl" title="">Symbols in RIF Versus RDF/OWL</a>).
</p>
<a id="RDF_and_RIF_Interpretations" name="RDF_and_RIF_Interpretations"></a><h5> <span class="mw-headline">3.2.1.1  RDF and RIF Interpretations </span></h5>
<p>The notions of RDF interpretation and RIF semantic structure (interpretation) are briefly reviewed below.
</p><p>As defined in [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>], a <i><b><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp">Simple interpretation</a></b></i> of a Vocabulary <i>V</i> is a tuple I=&lt; IR, IP, IEXT, IS, IL, LV &gt;, where 
</p>
<ul><li> IR is a non-empty set of resources (the domain), 
</li><li> IP is a set of properties, 
</li><li> IEXT is an extension function, which is a mapping from IP into the power set of IR &times; IR, 
</li><li> IS is a mapping from IRIs in <i>V</i> into (IR union IP), 
</li><li> IL is a mapping from typed literals in <i>V</i> into IR, and 
</li><li> LV is the set of literal values, which is a subset of IR, and includes all plain literals in <i>V</i>.
</li></ul>
<p>RDF-, RDFS-, and D-interpretations are Simple interpretations that satisfy certain conditions:
</p>
<ul><li> A Simple interpretation I of a Vocabulary <i>V</i> is an <i><b><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef">RDF-interpretation</a></b></i> if <i>V</i> includes the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defRDFV" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defRDFV">RDF Vocabulary</a> and I satisfies the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples">RDF axiomatic triples</a> and the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1">RDF semantic conditions</a>.
</li><li> An RDF-interpretation I of a Vocabulary <i>V</i> is an <i><b><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef">RDFS-interpretation</a></b></i> if <i>V</i> includes the RDFS Vocabulary and I satisfies the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples">RDFS axiomatic triples</a> and the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfssemcond1" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfssemcond1">RDFS semantic conditions</a>.
</li><li> Given a datatype map D, an RDFS-interpretation I of a Vocabulary <i>V</i> is a <i><b><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp">D-interpretation</a></b></i> if <i>V</i> includes the IRIs in the domain of D and I satisfies the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp">general semantic conditions for datatypes</a> for every pair &lt;d, D(d)&gt; such that d is in the domain of D.
</li></ul>
<p>As defined in [<a href="#ref-rif-bld" title="">RIF-BLD</a>], a <i><b><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-sem-struct" title="BLD">semantic structure</a></b></i> <i><b>I</b></i> is a tuple of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>,
<i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>,
<i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;. The specification of RIF-RDF compatibility is only concerned with <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, and <i><b>I</b></i><sub>truth</sub>.  The other mappings that are parts of a semantic structure are not used in the definition of combinations.
</p><p>Recall that <tt>Const</tt> is the set of <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-alphabet" title="BLD">constant symbols</a> and <tt>Var</tt> is the set of <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-alphabet" title="BLD">variable symbols</a> in RIF.
</p>
<ul><li> <i><b>DTS</b></i> is the set of datatypes, which have associated datatype identifiers,
</li><li> <i><b>D</b></i> is a set (the domain), 
</li><li> <i><b>D</b></i><sub>ind</sub> is a non-empty subset of <i><b>D</b></i>, 
</li><li> <i><b>D</b></i><sub>func</sub> is a non-empty subset of <i><b>D</b></i>, 
</li><li> <i><b>I</b></i><sub>C</sub> is a mapping from constants to <i><b>D</b></i> such that constants in individual position are mapped to <i><b>D</b></i><sub>ind</sub> and constants in function positions are mapped to <i><b>D</b></i><sub>func</sub>, 
</li><li> <i><b>I</b></i><sub>V</sub> is a mapping from <tt>Var</tt> to <i><b>D</b></i><sub>ind</sub>, 
</li><li> <i><b>I</b></i><sub>list</sub> is an injective mapping from <i><b>D</b></i><sub>ind</sub><sup>*</sup> to <i><b>D</b></i><sub>ind</sub>,
</li><li> <i><b>I</b></i><sub>tail</sub> is a mapping from <i><b>D</b></i><sub>ind</sub><sup>+</sup>&times;<i><b>D</b></i><sub>ind</sub> to <i><b>D</b></i><sub>ind</sub>,
</li><li> <i><b>I</b></i><sub>frame</sub> is a mapping from <i><b>D</b></i><sub>ind</sub> to functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>) &rarr; <i><b>D</b></i>, 
</li><li> <i><b>I</b></i><sub>sub</sub> is a mapping from <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> to <i><b>D</b></i>, 
</li><li> <i><b>I</b></i><sub>isa</sub> is a mapping from <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> to <i><b>D</b></i>, and
</li><li> <i><b>I</b></i><sub>truth</sub> is a mapping from <i><b>D</b></i> to <i><b>TV</b></i>.
</li></ul>
<p>For the purpose of the interpretation of imported documents, RIF BLD defines the notion of <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-semantic-multistruct" title="BLD"><i><b>semantic multi-structures</b></i></a>, which are nonempty sets of semantic structures of the form {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, ...} that differ only in interpretation of local constants. The structure <i><b>I</b></i> in the above is used to interpret document formulas, and will be used to specify RIF combinations.
</p>
<a id="RDF_Lists" name="RDF_Lists"></a><h5> <span class="mw-headline">3.2.1.2  RDF Lists </span></h5>
<p>Syntactically speaking, an RDF list is a set of triples of the form
</p>
<pre> i1 rdf:first d1 .
 i1 rdf:rest i2 .
 ...
 in rdf:first dn .
 in rdf:rest rdf:nil .
</pre>
<p><br />
Here, <tt>i1</tt> ... <tt>in</tt> provide the structure of the linked list and <tt>d1</tt> ... <tt>dn</tt> are the items. The above list would be written in RIF syntax as <tt>List(d1 ... dn)</tt>.
</p><p>Given an RDF interpretation I=&lt; IR, IP, IEXT, IS, IL, LV &gt;, we say that an element <tt>l1</tt> &isin; IR refers to an <span id="def-rdf-list"><i><b>RDF list</b></i></span> (<tt>y1</tt>,...,<tt>yn</tt>) if  <tt>l1</tt>=IS(<tt>rdf:nil</tt>), in case <tt>n=0</tt>; otherwise,  &exist; <tt>l2</tt>, ..., <tt>ln</tt> such that
&lt;<tt>l1</tt>,<tt>y1</tt>&gt; &isin; IEXT(IS(rdf:first)),  &lt;<tt>l1</tt>,<tt>l2</tt>&gt; &isin; IEXT(IS(rdf:rest)), ...,
&lt;<tt>ln</tt>,<tt>yn</tt>&gt; &isin; IEXT(IS(rdf:first)),  and &lt;<tt>ln</tt>,IS(rdf:nil)&gt; &isin; IEXT(IS(rdf:rest)).
</p><p>Note that, if <tt>n &gt; 0</tt>, there may be several lists referred to by <tt>l1</tt>, since there is no restriction, in general, on the <tt>rdf:first</tt> elements and the <tt>rdf:rest</tt> successors.
</p>
<a id="Common_RIF-RDF_Interpretations" name="Common_RIF-RDF_Interpretations"></a><h5> <span class="mw-headline">3.2.1.3  Common RIF-RDF Interpretations </span></h5>
<p><b>Definition.</b> A <span id="def-common-rif-rdf-interpretation"><i><b>common-RIF-RDF-interpretation</b></i></span> is a pair (<i><b>&Icirc;</b></i>, I), where <i><b>&Icirc;</b></i> is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-semantic-multistruct" title="BLD">semantic multi-structure</a> of the form {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, ...}, and I is a <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp">Simple interpretation</a> of a Vocabulary <i>V</i>, such that the following conditions hold:
</p>
<ol><li> (IR union IP) = <i><b>D</b></i><sub>ind</sub>;
</li><li> IP is a superset of the set of all <tt>k</tt> in <i><b>D</b></i><sub>ind</sub> such that there exist some <tt>a</tt>, <tt>b</tt> in <i><b>D</b></i><sub>ind</sub> and <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>a</tt>)(<tt>k</tt>,<tt>b</tt>))=<b>t</b>;
</li><li> LV is a superset of (union of the value spaces of all <a href="#def-considered-datatypes" title="">considered datatypes</a>);
</li><li> IEXT(<tt>k</tt>) = the set of all pairs (<tt>a</tt>, <tt>b</tt>), with <tt>a</tt>, <tt>b</tt>, and <tt>k</tt> in <i><b>D</b></i><sub>ind</sub>, such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>a</tt>)(<tt>k</tt>,<tt>b</tt>))=<b>t</b>;
</li><li> IS(<tt>i</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>&lt;i&gt;</tt>) for every IRI <tt>i</tt> in <i>V<sub>U</sub></i>;
</li><li> IL((<tt>s</tt>, <tt>d</tt>)) = <i><b>I</b></i><sub>C</sub>(<tt>"s"^^d</tt>) for every <a href="#def-well-typed-literal" title="">well-typed literal</a> (<tt>s</tt>, <tt>d</tt>) in <i>V<sub>TL</sub></i>;
</li><li> IEXT(IS(<tt>rdf:type</tt>)) is equal to the set of all pairs (<tt>a</tt>, <tt>b</tt>) in <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>isa</sub>(<tt>a</tt>,<tt>b</tt>))=<b>t</b>; and
</li><li> IEXT(IS(<tt>rdfs:subClassOf</tt>)) is a superset of the set of all pairs (<tt>a</tt>, <tt>b</tt>) in <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>sub</sub>(<tt>a</tt>,<tt>b</tt>))=<b>t</b>;
</li><li> For any nonnegative integer <tt>n</tt> and any <tt>y1</tt>,...,<tt>yn</tt> &isin; IR, if some <tt>l1</tt> &isin; IR refers to the <a href="#def-rdf-list" title="">RDF list</a> (<tt>y1</tt>,...,<tt>yn</tt>), then <i><b>I</b></i><sub>list</sub>(<tt>y1</tt>,...,<tt>yn</tt>)=<tt>l1</tt>; and
</li><li> For any nonnegative integer <tt>n</tt> and any sequence of elements <tt>y1</tt>,...,<tt>yn</tt> &isin; IR, an element <tt>l1</tt> &isin; IR refers to the <a href="#def-rdf-list" title="">RDF list</a> (<tt>y1</tt>,...,<tt>yn</tt>) iff <i><b>I</b></i><sub>list</sub>(<tt>y1</tt>,...,<tt>yn</tt>)=<tt>l1</tt>. &nbsp;&nbsp;☐
</li></ol>
<p>Condition 1 ensures that the combination of resources and properties corresponds exactly to the RIF domain; note that if I is an RDF-, RDFS-, or D-interpretation, IP is a subset of IR, and thus IR=<i><b>D</b></i><sub>ind</sub>.  Condition 2 ensures that the set of RDF properties at least includes all elements that are used as properties in frames in the RIF domain. Condition 3 ensures that all concrete values in <i><b>D</b></i><sub>ind</sub> are included in LV (by definition, the value spaces of all considered datatypes are included in <i><b>D</b></i><sub>ind</sub>).  Condition 4 ensures that RDF triples are interpreted in the same way as frame formulas.  Condition 5 ensures that IRIs are interpreted in the same way.  Condition 6 ensures that typed literals are interpreted in the same way.  Note that no correspondences are defined for the mapping of names in RDF that are not symbols of RIF, e.g., ill-typed literals and RDF URI references that are not absolute IRIs. Condition 7 ensures that typing in RDF and typing in RIF correspond, i.e., <tt>a rdf:type b</tt> is true iff <tt>a # b</tt> is true.  Condition 8 ensures that whenever a RIF subclass statement holds, the corresponding RDF subclass statement holds as well, i.e., <tt>a rdfs:subClassOf b</tt> is true if <tt>a ## b</tt> is true. Finally, condition 9 requires the existence of an RIF list for every RDF list and condition 10 in addition requires the existence of an RDF list for every RIF list.
</p>
<a id="Satisfaction_and_Models" name="Satisfaction_and_Models"></a><h4> <span class="mw-headline">3.2.2  Satisfaction and Models </span></h4>
<p>The notion of satisfiability refers to the conditions under which a common-RIF-RDF-interpretation (<i><b>&Icirc;</b></i>, I) is a model of a combination &lt; <i>R</i>, <b>S</b>&gt;. The notion of satisfiability is defined for all four entailment regimes of RDF (i.e., Simple, RDF, RDFS, and D).  The definitions are all analogous.  Intuitively, a common-RIF-RDF-interpretation (<i><b>&Icirc;</b></i>, I) satisfies a combination &lt; <i>R</i>, <b>S</b>&gt; if <i><b>&Icirc;</b></i> is a model of <i>R</i> and I satisfies <b>S</b>. Formally:
</p><p><b>Definition.</b> A <a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a> (<i><b>&Icirc;</b></i>, I) <i><b><span id="def-rif-rdf-satisfies">satisfies</span></b></i> a <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt; <i>R</i>, <b>S</b> &gt; if <i><b>&Icirc;</b></i> is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-model-formula" title="BLD">model</a> of <i>R</i> and I <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defsatis" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defsatis">satisfies</a> every RDF graph <i>S</i> in <b>S</b>; in this case  (<i><b>&Icirc;</b></i>, I) is called a <span id="def-simple-model"><i><b>RIF-Simple-model</b></i></span>, or <i><b>model</b></i>, of C, and C is <i><b>satisfiable</b></i>.  (<i><b>&Icirc;</b></i>, I) satisfies a <a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a> <i>S</i> if I satisfies <i>S</i>. (<i><b>&Icirc;</b></i>, I) satisfies a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a> &phi; if <i>TVal</i><sub>&Icirc;</sub>(&phi;)=<i>t</i>. &nbsp;&nbsp;☐
</p><p>RDF-, RDFS-, and RIF-D-satisfiability are defined through additional restrictions on I:
</p><p><b>Definition.</b> A <a href="#def-simple-model" title="">model</a> (<i><b>&Icirc;</b></i>, I) of a combination C is an <span id="def-rdf-model"><i><b>RIF-RDF-model</b></i></span> of C if I is an <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfinterpdef">RDF-interpretation</a>; in this case  C is <i><b><span id="def-rdf-satisfiable">RIF-RDF-satisfiable</span></b></i>.  
</p><p>A <a href="#def-simple-model" title="">model</a> (<i><b>&Icirc;</b></i>, I) of a combination C is an <span id="def-rdfs-model"><i><b>RIF-RDFS-model</b></i></span> of C if I is an <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsinterpdef">RDFS-interpretation</a>; in this case  C is <i><b><span id="def-rdfs-satisfiable">RIF-RDFS-satisfiable</span></b></i>. 
</p><p>Let (<i><b>&Icirc;</b></i>, I) be a <a href="#def-simple-model" title="">model</a>  of a combination C and let D be a datatype map <a href="#def-conforming-datatype-map" title="">conforming</a> with the set <i><b>DTS</b></i> of datatypes in <i><b>I</b></i>. (<i><b>&Icirc;</b></i>, I) is a <span id="def-d-model"><i><b>RIF-D-model</b></i></span> of C if I is a <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp">D-interpretation</a>; in this case C is <i><b><span id="def-d-satisfiable">RIF-D-satisfiable</span></b></i>. &nbsp;&nbsp;☐
</p>
<a id="Entailment" name="Entailment"></a><h4> <span class="mw-headline">3.2.3  Entailment </span></h4>
<p>Using the notions of models defined above, entailment is defined in the usual way, i.e.,  through inclusion of sets of models.
</p><p><b>Definition.</b> Let C be a RIF-RDF combination, let <i>S</i> be a <a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a>, let &phi; be a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a>, and let D be a datatype map <a href="#def-conforming-datatype-map" title="">conforming</a> with the set of <a href="#def-considered-datatypes" title="">considered datatypes</a>. C <span id="def-d-entails"><i><b>RIF-D-entails</b></i></span> <i>S</i> if every <a href="#def-d-model" title="">RIF-D-model</a> of C <a href="#def-rif-rdf-satisfies" title="">satisfies</a> <i>S</i>. Likewise, C <i><b>RIF-D-entails</b></i> &phi; if every <a href="#def-d-model" title="">RIF-D-model</a> of C <a href="#def-rif-rdf-satisfies" title="">satisfies</a> &phi;. &nbsp;&nbsp;☐
</p><p>The other notions of entailment are defined analogously:
</p><p><b>Definition.</b> A combination  C <span id="def-simple-entails"><i><b>RIF-Simple-entails</b></i></span> <i>S</i> (resp., &phi;) if every <a href="#def-simple-model" title="">Simple model</a> of C <a href="#def-rif-rdf-satisfies" title="">satisfies</a> <i>S</i> (resp., &phi;). 
</p><p>A combination  C <span id="def-rdf-entails"><i><b>RIF-RDF-entails</b></i></span> <i>S</i> (resp., &phi;) if every <a href="#def-rdf-model" title="">RIF-RDF-model</a> of C <a href="#def-rif-rdf-satisfies" title="">satisfies</a> <i>S</i> (resp., &phi;). 
</p><p>A combination  C <span id="def-rdfs-entails"><i><b>RIF-RDFS-entails</b></i></span> <i>S</i> (resp., &phi;) if every <a href="#def-rdfs-model" title="">RIF-RDFS-model</a> of C <a href="#def-rif-rdf-satisfies" title="">satisfies</a> <i>S</i> (resp., &phi;). &nbsp;&nbsp;☐
</p><p>Note that simple entailment in combination with an empty ruleset is not the same as simple entailment in RDF, since certain entailments involving datatypes are enforced by the RIF semantics in combinations, cf. the <a href="#ex-strings" title="">example</a> involving strings and plain literals above.
</p>
<a id="OWL_Compatibility" name="OWL_Compatibility"></a><h2> <span class="mw-headline">4  OWL Compatibility </span></h2>
<p>This section specifies how a RIF document interacts with a set
of OWL ontologies in a RIF-OWL combination. The semantics of
combinations is defined for OWL 2
[<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>]. Since OWL
2 is an extension of OWL 1
[<a href="#ref-owl-reference" title="">OWL-Reference</a>], the
specification in this section applies also to combinations of
RIF documents with OWL 1 ontologies.
</p><p>OWL 2 specifies two different variants of the language: OWL 2 DL
[<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>] and OWL 2 Full
[<a href="#ref-owl2-rdf-based-semantics" title="">OWL2-RDF-Based-Semantics</a>], where the latter are RDF graphs that use OWL Vocabulary; the RDF representation of an OWL 2 DL ontology is also an OWL 2 Full ontology.
<a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/#OWLLite" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/#OWLLite">OWL 1 Lite</a> and
<a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/#OWLDL" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/#OWLDL">OWL 1 DL</a> [<a href="#ref-owl-reference" title="">OWL-Reference</a>],
which are sublanguages of OWL 1, can be seen as syntactical
subsets of OWL 2 DL. OWL 2 ontologies may be interpreted under one of two semantics:  the Direct Semantics
[<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>], which is only defined for OWL 2 DL and is
based on standard Description Logic semantics, and the RDF-Based Semantics [<a href="#ref-owl2-rdf-based-semantics" title="">OWL2-RDF-Based-Semantics</a>], which is defined for arbitrary OWL 2 Full ontologies.
</p><p>The syntax of OWL 2 DL is defined in terms of a Structural
Specification, and there is a mapping to an RDF representation
for interchange. The RDF representation of OWL 2 DL [<a href="#ref-owl2-rdf-mapping" title="">OWL2-RDF-Mapping</a>] does not
extend the RDF syntax, but rather restricts it: every OWL 2 DL
ontology in RDF form is an RDF graph, but not every RDF graph
is an OWL 2 DL ontology.  OWL 2 Full and RDF have the same
syntax: every RDF graph is an OWL 2 Full ontology and vice
versa.  This syntactical difference is reflected in the
definition of RIF-OWL compatibility: combinations of RIF with
OWL 2 DL are based on the OWL 2 Structural Specification, whereas
combinations with OWL 2 Full are based on the RDF syntax.
</p><p>Since the OWL 2 Full syntax is the same as the RDF syntax and
the OWL 2 RDF-Based Semantics is an extension of the RDF Semantics,
the definition of RIF-OWL 2 Full compatibility is an extension
of RIF-RDF compatibility. However, defining RIF-OWL DL
compatibility in the same way would entail losing certain
properties of the Direct Semantics. One of the main reasons for
this is the difference in the way classes and properties are
interpreted in the RDF-Based and Direct Semantics. In the RDF-Based Semantics,
classes and properties are interpreted as objects in the domain
of interpretation, which are then associated with subsets of,
respectively binary relations over the domain of
interpretation, using the <tt>rdf:type</tt> property and the
extension function IEXT, as in RDF.  In the Direct Semantics, classes
and properties are directly interpreted as subsets of,
respectively binary relations over the domain.  This is a key
property of the first-order logic nature of Description Logic
semantics and enables the use of Description Logic reasoning
techniques for processing OWL 2 DL descriptions.  Defining
RIF-OWL DL compatibility as an extension of RIF-RDF
compatibility would define a correspondence between OWL 2 DL
statements and RIF frame formulas.  Since RIF frame formulas
are interpreted using an extension function, as in RDF,
defining the correspondence between them and OWL 2 DL
statements would change the semantics of OWL statements, even
if the RIF document were empty.
</p><p>A RIF-OWL combination that is faithful to the first-order
nature of the OWL 2 Direct Semantics requires interpreting classes
and properties as sets and binary relations, respectively,
suggesting that a correspondence could be defined with unary
and binary predicates.  It is, however, also desirable that
there be uniform syntax for the RIF component of both RIF-OWL 2 DL
and RIF-RDF/OWL 2 Full combinations, because one may not know at
the time of constructing the rules which type of inference will
be used.  Consider, for example, an RDF graph S consisting of
the following statements
</p>
<pre>_:x rdf:type owl:Ontology .
a rdf:type C .
</pre>
<p>and a RIF document with the rule
</p>
<pre>Forall&nbsp;?x (?x[rdf:type -&gt; D]&nbsp;:-&nbsp;?x[rdf:type -&gt; C])
</pre>
<p>The combination of the two, according to the specification of
<a href="#RDF_Compatibility" title="">RDF Compatibility</a>, allows deriving the
triple
</p>
<pre>a rdf:type D .
</pre>
<p>Now, the RDF graph S is also an OWL 2 DL ontology.  Therefore,
one would expect the triple to be implied according to the
semantics of RIF-OWL DL combinations as well.
</p><p>To ensure that the RIF-OWL DL combination is faithful to the
OWL 2 Direct Semantics and to enable using the same, or similar,
RIF rules in combinations with both OWL 2 DL and RDF/OWL 2
Full, the interpretation of frame formulas <tt>s[p -&gt; o]</tt>
in RIF-OWL DL combinations is slightly different from
their interpretation in RIF and syntactical restrictions are
imposed on the use of variables and function terms in frame
formulas.
</p><p><br />
The remainder of this section formally defines combinations of
RIF rules with OWL 2 DL and OWL 2 Full ontologies and the
semantics of such combinations. A combination consists of a RIF
document and a set of OWL ontologies. The semantics of
combinations is defined in terms of combined models, which are
pairs of RIF semantic multi-structures and OWL 2 Direct, respectively OWL 2 RDF-Based interpretations. The interaction between the structures and interpretations is defined through a number of conditions.  Entailment is defined as model inclusion, as usual.
</p>
<a id="Syntax_of_RIF-OWL_Combinations" name="Syntax_of_RIF-OWL_Combinations"></a><h3> <span class="mw-headline">4.1  Syntax of RIF-OWL Combinations </span></h3>
<p>Since RDF graphs and OWL 2 Full ontologies cannot be
distinguished, the syntax of RIF-OWL 2 Full combinations is the
same as the syntax of <a href="#def-rif-rdf-combination" title="">RIF-RDF combinations</a>.
</p><p>The syntax of <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_ontology" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_ontology">OWL ontologies</a> in RIF-OWL DL combinations is
given by the Structural Specification of OWL 2 and the restrictions on OWL 2 DL ontologies [<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>]. Certain
restrictions are imposed on the syntax of the RIF rules in
combinations with OWL 2 DL. Specifically, the only terms
allowed in class and property positions in class membership frame formulas are
constant symbols. A DL-frame formula is a frame formula
<tt>a[b<sub>1</sub> -&gt; c<sub>1</sub> ... b<sub>n</sub> -&gt;
c<sub>n</sub>]</tt> such that <tt>n</tt>&ge;1 and for every
<tt>b<sub>i</sub></tt>, with 1&le;<tt>i</tt>&le;<tt>n</tt>, it
holds that <tt>b<sub>i</sub></tt> is a constant symbol and if
<tt>b<sub>i</sub> </tt>=<tt> rdf:type</tt>, then
<tt>c<sub>i</sub></tt> is a constant symbol. A DL-class membership formula is a class membership formula <tt>a#b</tt> such that <tt>b</tt> is a constant symbol.
A DL-subclass formula is a subclass formula <tt>b##c</tt> such that <tt>b</tt> and <tt>c</tt> are constant symbols.
</p><p>We do not allow subclass formulas in rule conditions in RIF-OWL DL combinations, since at the time of writing there are no known effective and efficient ways of dealing with such subclass formulas in conditions in reasoners.
</p><p><br />
<b>Definition.</b> A <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a>
&phi; is a <span id="def-dl-condition"><i><b>DL-condition</b></i></span> if every
frame formula in &phi; is a DL-frame formula, every class membership formula
in &phi; is a DL-class membership formula, and &phi;  does not contain subclass formulas.
</p><p>A <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-rif-bld-document" title="BLD">RIF-BLD document formula</a> <i>R</i>
is a <span id="def-dl-document"><i><b>RIF-BLD DL-document formula</b></i></span> if every frame formula in <i>R</i> is a
DL-frame formula, every class membership formula
in <i>R</i> is a DL-class membership formula, every subclass formula
in <i>R</i> is a DL-subclass formula, and <i>R</i>does not contain any rules with subclass formulas.
</p><p>A <span id="def-rif-owl-dl-combination"><i><b>RIF-OWL DL-combination</b></i></span>
is a pair &lt; <i>R</i>,<b>O</b>&gt;, where <i>R</i> is a
<a href="#def-dl-document" title="">RIF-BLD DL-document formula</a> and <b>O</b> is
a set of
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_ontology" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_ontology">OWL 2 DL ontologies</a> of a
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_vocabulary" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_vocabulary">Vocabulary</a> <i>V</i> over an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a> <i>D</i>.
&nbsp;&nbsp;☐
</p><p>When clear from the context, RIF-OWL DL-combinations are
referred to simply as <i>combinations</i>.
</p><p><br />
</p>
<a id="Safeness_Restrictions" name="Safeness_Restrictions"></a><h4> <span class="mw-headline">4.1.1  Safeness Restrictions </span></h4>
<p>In the literature, several restrictions on the use of variables
in combinations of rules and Description Logics have been
identified [<a href="#ref-motik05" title="">Motik05</a>,
<a href="#ref-rosati06" title="">Rosati06</a>] for the purpose of decidable
reasoning.  This section specifies such safeness restrictions
for RIF-OWL DL combinations.
</p><p>Given a set of OWL 2 DL ontologies <b>O</b>, a variable
<tt>?x</tt> in a RIF rule <b>Q</b> <i>H</i>&nbsp;:- <i>B</i> is
<i><b>DL-safe</b></i> if it occurs in an atomic formula in <i>B</i>
that is not of the form <tt><i>s</i>[<i>P</i> -&gt; <i>o</i>]</tt> or <tt><i>s</i>[rdf:type -&gt;
<i>A</i>]</tt>, where <tt><i>s</i></tt>, <tt><i>P</i></tt>, <tt><i>o</i></tt>, and <tt><i>A</i></tt> are terms (possibly including <tt>?x</tt>) and  <tt><i>P</i></tt> or <tt><i>A</i></tt> occurs in one of the
ontologies in <b>O</b>.  A disjunction-free RIF rule <b>Q</b> (<i>H</i>&nbsp;:- <i>B</i>) is
<i><b>DL-safe</b></i>, given <b>O</b>, if every variable that occurs
in <i>H</i>&nbsp;:- <i>B</i> is DL-safe. A disjunction-free RIF rule <b>Q</b> (<i>H</i>&nbsp;:- <i>B</i>)
is <i><b>weakly DL-safe</b></i>, given <b>O</b>, if every variable
that occurs in <i>H</i> is DL-safe.
</p><p><b>Definition.</b> A
<a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> &lt;<i>R</i>,<b>O</b>&gt; is <i><b>DL-safe</b></i> if every rule in <i>R</i>
is DL-safe, given <b>O</b>. A
<a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> &lt;<i>R</i>,<b>O</b>&gt; is <i><b>weakly DL-safe</b></i> if every rule in
<i>R</i> is weakly DL-safe, given <b>O</b>. &nbsp;&nbsp;☐
</p>
<a id="Datatypes_in_OWL_2" name="Datatypes_in_OWL_2"></a><h4> <span class="mw-headline">4.1.2  Datatypes in OWL 2 </span></h4>
<p>Compared with RDF and the RIF, OWL 2 uses a slightly extended
notion of datatype.
</p><p>In the remainder of this section, a <span id="def-extended-datatype">datatype</span> <i>d</i> contains, in
addition to the lexical space, value space, and
lexical-to-value mapping, a <i><b>facet space</b></i>, which is a
set of pairs of the form (<i>F</i>, <i>v</i>), where <i>F</i> is an IRI
and <i>v</i> is a data value, and a <i><b>facet-to-value mapping</b></i>,
which is a mapping from facets to subsets of the value space of
<i>d</i>.
</p><p>An <span id="def-owl2-datatype-map"><i><b>OWL 2 datatype map</b></i></span> D is a datatype map that maps the IRIs of the
datatypes specified in
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#Datatype_Maps" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#Datatype_Maps">Section 4</a> of
[<a href="#ref-owl2-syntax" title="">OWL2-Syntax</a>] to the
corresponding datatypes such that the domain of D does not
include <tt>rdfs:Literal</tt>.
</p><p><br />
We note here that the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_datatype_map" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_datatype_map">definitions of datatype and datatype map in the OWL 2 Direct Semantics</a> specification
[<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>] are somewhat different.
There, a datatype is some entity with some associated IRIs, and
the datatype map assigns lexical value, and facet spaces, as
well as lexical-to-value and facet-to-value mappings.  The
definitions of datatype and datatype map we use are isomorphic,
and, indeed, the same as in the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#def-owldatatypemap" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#def-owldatatypemap">OWL 2 RDF-Based Semantics</a>
specification
[<a href="#ref-owl2-rdf-based-semantics" title="">OWL2-RDF-Based-Semantics</a>].
The latter does not preclude the use of <tt>rdfs:Literal</tt>
in datatype maps. Note that we do not restrict the use of
<tt>rdfs:Literal</tt> in OWL 2 ontologies or RDF graphs.
</p>
<a id="Semantics_of_RIF-OWL_Combinations" name="Semantics_of_RIF-OWL_Combinations"></a><h3> <span class="mw-headline">4.2  Semantics of RIF-OWL Combinations </span></h3>
<p>The semantics of RIF-OWL 2 Full combinations is a
straightforward extension of the <a href="#Semantics_of_RIF-RDF_Combinations" title="">Semantics of RIF-RDF Combinations</a>.
</p><p>The semantics of RIF-OWL 2 DL combinations cannot
straightforwardly extend the semantics of RIF-RDF combinations,
because the OWL 2 Direct Semantics does not extend the RDF Semantics.  In order
to keep the syntax of the rules uniform between RIF-OWL 2 Full
and RIF-OWL DL combinations, the semantics of RIF frame
formulas is slightly altered in RIF-OWL DL combinations.
</p>
<a id="OWL_RDF-Based_Semantics" name="OWL_RDF-Based_Semantics"></a><h4> <span class="mw-headline">4.2.1  OWL RDF-Based Semantics </span></h4>
<p>Given an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map D</a> and a
Vocabulary <i>V</i> that includes the domain of D and the OWL 2
RDF-Based Vocabulary
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#Vocabulary" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#Vocabulary">Vocabulary</a>, a
<a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defDinterp">D-interpretation</a> I is an <i><b>OWL 2 RDF-Based Interpretation</b></i>
of <i>V</i> with respect to D if it satisfies the semantic
conditions in 
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#Semantic_Conditions" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#Semantic_Conditions">Section 5</a> of
[<a href="#ref-owl2-rdf-based-semantics" title="">OWL2-RDF-Based-Semantics</a>].
</p><p>The semantics of RIF-OWL 2 Full combinations is a
straightforward extension of the semantics of RIF-RDF
combinations.  It is based on the same notion of
<a href="#def-common-rif-rdf-interpretation" title="">common interpretations</a>,
but defines additional notions of satisfiability and
entailment.
</p><p><b>Definition.</b> Let (<i><b>&Icirc;</b></i>, I) be a
<a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a>
that is a <a href="#def-simple-model" title="">model</a>  of a
<a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt; <i>R</i>,
<b>S</b> &gt; and let D be an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a> <a href="#def-conforming-datatype-map" title="">conforming</a>
with the set of datatypes in <i><b>I</b></i>. (<i><b>&Icirc;</b></i>, I) is
an <span id="def-owl-full-model"><i><b>RIF-OWL RDF-Based-model</b></i></span> of C
if I is an
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#def-owlinterpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/#def-owlinterpretation">OWL 2 RDF-Based Interpretation</a> with respect to D; in this case C is
<span id="def-owl-full-satisfiable"><i><b>RIF-OWL RDF-Based-satisfiable</b></i></span>
with respect to D.
</p><p>Let C be a RIF-RDF combination, let <i>S</i> be a
<a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a>, let &phi;
be a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a>, and let D be
an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map D</a>
<a href="#def-conforming-datatype-map" title="">conforming</a> with the set of
<a href="#def-considered-datatypes" title="">considered datatypes</a>. C <span id="def-owl-full-entails"><i><b>RIF-OWL RDF-Based-entails</b></i></span>
<i>S</i> with respect to D if every
<a href="#def-owl-full-model" title="">RIF-OWL RDF-Based-model</a> of C
<a href="#def-rif-rdf-satisfies" title="">satisfies</a> <i>S</i>. Likewise, C
<i><b>RIF-OWL RDF-Based-entails</b></i> &phi; with respect to D if every
<a href="#def-owl-full-model" title="">RIF-OWL RDF-Based-model</a> of C
<a href="#def-rif-rdf-satisfies" title="">satisfies</a> &phi;. &nbsp;&nbsp;☐
</p>
<a id="OWL_Direct_Semantics" name="OWL_Direct_Semantics"></a><h4> <span class="mw-headline">4.2.2  OWL Direct Semantics </span></h4>
<p>The semantics of RIF-OWL DL-combinations is similar in spirit
to the semantics of RIF-RDF combinations.  Analogous to
common-RIF-RDF-interpretations, there is the notion of
common-RIF-OWL Direct-interpretations, which are pairs of RIF and
OWL 2 Direct interpretations, and which define a number of
conditions that relate these interpretations to each other.
</p>
<a id="Modified_Semantics_for_RIF_Subclass.2C_Membership.2C_and_Frame_Formulas" name="Modified_Semantics_for_RIF_Subclass.2C_Membership.2C_and_Frame_Formulas"></a><h5> <span class="mw-headline">4.2.2.1  Modified Semantics for RIF Subclass, Membership, and Frame Formulas </span></h5>
<p>The modification of the semantics of RIF subclass, membership, and frame formulas is
achieved by modifying the respective mapping functions (<i><b>I</b></i><sub>sub</sub>), (<i><b>I</b></i><sub>isa</sub>) and
(<i><b>I</b></i><sub>frame</sub>). In addition, a new mapping function for constants (<i><b>I</b></i><sub>C'</sub>) is used whenever constants appear in class or property positions.
</p><p>Frame formulas of the form <tt>s[rdf:type -&gt; o]</tt> and class membership formulas of the form <tt>s#o</tt> are interpreted as membership of <tt>s</tt> in the set denoted by <tt>o</tt> and frame formulas of the form <tt>s[p -&gt; o]</tt>, where <tt>p</tt> is not <tt>rdf:type</tt>, as
membership of the pair (<tt>s, o</tt>) in the binary relation
denoted by <tt>p</tt>.
</p><p><br />
<b>Definition.</b> A <i><b><span id="def-rif-dl-struct">dl-semantic structure</span></b></i> is a
tuple <i><b>I</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>C'</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt;, where
</p>
<ul><li> <i><b>I</b></i><sub>C'</sub> is a mapping from <tt>Const</tt> to <i><b>D</b></i>;
</li><li> <i><b>I</b></i><sub>frame</sub> is a mapping from <i><b>D</b></i><sub>ind</sub> to total functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i> &times; <i><b>D</b></i>) &rarr; <i><b>D</b></i> such that for each pair (<tt>u, v</tt>)&nbsp;&isin;&nbsp;<tt>SetOfFiniteBags</tt>(<i><b>D</b></i> &times; <i><b>D</b></i>) it holds that if <tt>u</tt>&nbsp;&ne;&nbsp;<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>), then <tt>v</tt>&nbsp;&isin;&nbsp;<i><b>D</b></i><sub>ind</sub>;
</li><li> <i><b>I</b></i><sub>sub</sub> is a mapping <i><b>D</b></i> &times; <i><b>D</b></i> &rarr; <i><b>D</b></i>;
</li><li> <i><b>I</b></i><sub>isa</sub> is a mapping <i><b>D<sub>ind</sub></b></i> &times; <i><b>D</b></i> &rarr; <i><b>D</b></i>;
</li><li> all other elements of the structure are defined as in <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-sem-struct" title="BLD">RIF semantic structures</a>.
</li></ul>
<p>The mapping <i><b>I</b></i> from terms to <i><b>D</b></i> is defined as follows:
</p>
<ul><li> <i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>))({&lt;<i><b>I</b></i><sub>C'</sub>(<tt>a<sub>1</sub></tt>),<i><b>I</b></i><sub><tt>a<sub>1</sub></tt></sub>(<tt>v<sub>1</sub></tt>)&gt;, ..., &lt;<i><b>I</b></i><sub>C'</sub>(<tt>a<sub>n</sub></tt>),<i><b>I</b></i><sub><tt>a<sub>n</sub></tt></sub>(<tt>v<sub>n</sub></tt>)&gt;}), where <i><b>I</b></i><sub><tt>a<sub>i</sub></tt></sub>=<i><b>I</b></i><sub>C'</sub> if <tt>a<sub>i</sub></tt>=<tt>rdf:type</tt>; otherwise <i><b>I</b></i><sub><tt>a<sub>i</sub></tt></sub>=<i><b>I</b></i>.
</li><li> <i><b>I</b></i>(<tt>c1##c2</tt>) = <i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i><sub>C'</sub>(<tt>c1</tt>), <i><b>I</b></i><sub>C'</sub>(<tt>c2</tt>)).
</li><li> <i><b>I</b></i>(<tt>o#c</tt>) = <i><b>I</b></i><sub>isa</sub>(<i><b>I</b></i>(<tt>o</tt>), <i><b>I</b></i><sub>C'</sub>(<tt>c</tt>))
</li><li> the mapping of other terms is defined as in <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-sem-struct" title="BLD">RIF semantic structures</a>.
</li></ul>
<p>The truth valuation function <i>TVal</i><sub>I</sub> is defined
as in <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#Semantic_Structures" title="BLD">BLD semantic structures</a>.
</p><p>Dl-semantic multi-structures are defined analogous to <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-semantic-multistruct" title="BLD">RIF-BLD semantic multi-structures</a> [<a href="#ref-rif-bld" title="">RIF-BLD</a>]. Formally, a <i><b><span id="def-rif-dl-multi-struct">dl-semantic multi-structure</span></b></i> <b>&Icirc;</b> is a set of dl-semantic structures  {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, ...}, where
</p>
<ul>
  <li>
     <i><b>I</b></i> and <i><b>J</b></i> are dl-semantic structures; and
  </li>
  <li>  
    <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, etc., are dl-semantic structures <i><b>adorned</b></i> with the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#ref-locator" title="BLD">locators</a> of <i>distinct</i> RIF-BLD formulas (one can think of these adorned structures as locator-structure pairs).
  </li>
</ul>
<p>All the structures in <b>&Icirc;</b> (adorned and non-adorned) are identical in all respects except for the following:
</p>
<ul>       
  <li>
   The mappings <i><b>J</b></i><sub>C</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>C</sub><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sub>C</sub><sup><tt>i<sub>2</sub></tt></sup>, ... may differ on the constants in <tt>Const</tt> that belong to the <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> symbol space.
  </li>
  <li>
   The mappings <i><b>J</b></i><sub>V</sub>, <i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>V</sub><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sub>V</sub><sup><tt>i<sub>2</sub></tt></sup> may differ. 
  </li>
</ul>
<p>The truth valuation function <i>TVal</i><sub>&Icirc;</sub> is defined
as in <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#Semantic_Structures" title="BLD">BLD semantic structures</a>.
</p><p><b>Definition.</b> A <a href="#def-rif-dl-multi-struct" title="">dl-semantic multi-structure</a> <i><b>&Icirc;</b></i> is a <span id="def-dl-model"><i><b>model</b></i></span> of a
<a href="#def-dl-document" title="">RIF-BLD DL-document formula</a> <i>R</i> if
<i>TVal</i><sub>&Icirc;</sub>(<i>R</i>)=<b>t</b>. &nbsp;&nbsp;☐
</p>
<a id="Semantics_of_RIF-OWL_DL_Combinations" name="Semantics_of_RIF-OWL_DL_Combinations"></a><h5> <span class="mw-headline">4.2.2.2  Semantics of RIF-OWL DL Combinations </span></h5>
<p>As defined in
[<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>], an
<i><b><a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation">interpretation</a></b></i> for a Vocabulary <i>V</i> over a datatype map
D is a tuple <i>I</i>=&lt; IR, LV, C, OP, DP, I, DT, LT, FA &gt;,
where
</p>
<ul><li> IR is a non-empty set, called the object domain,
</li><li> LV is a non-empty set, called the data domain, which includes all value spaces of the datatypes in the range of D,
</li><li> C is a mapping from classes to subsets of IR,
</li><li> OP is a mapping from object properties to subsets of IR &times; IR,
</li><li> DP is a mapping from object properties to subsets of IR &times; LV,
</li><li> I is a mapping from individuals into IR,
</li><li> DT is a mapping from datatypes to subsets of LV,
</li><li> LT is a mapping from typed literals in <i>V</i> into LV, and
</li><li> FA is a mapping from IRI, literal pairs to subsets of value spaces in D.
</li></ul>
<p>The OWL semantics imposes a number of
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations">further restrictions</a> on the mapping functions to ensure the
interpretation of datatypes, literals, and facets conforms with
the given datatype map D and to define the semantics of
built-in classes and properties (e.g., <tt>owl:Thing</tt>).
The mappings DT, LT, and FA are essentially given by the
datatype map.
</p><p><b>Definition.</b> Given a Vocabulary <i>V</i> over an
<a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a> D, a <span id="def-common-dl-interpretation"><i><b>common-RIF-OWL Direct-interpretation</b></i></span>
for <i>V</i> over D is a pair (<i><b>&Icirc;</b></i>, <i>I</i>), where
<i><b>&Icirc;</b></i> is a <a href="#def-rif-dl-multi-struct" title="">dl-semantic multi-structure</a> of the form {<i><b>J</b></i>,<i><b>I</b></i>; <i><b>I</b></i><sup><tt>i<sub>1</sub></tt></sup>, <i><b>I</b></i><sup><tt>i<sub>2</sub></tt></sup>, ...}, and <i>I</i> is an
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation">interpretation</a> for <i>V</i> over D, such that the following
conditions hold. 
</p>
<ol><li> D is conforming with the datatypes in <i><b>I</b></i>; 
</li><li> (IR union LV) is <i><b>D<sub>ind</sub></b></i>&nbsp;; 
</li><li> C(<tt>c</tt>) is the set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)({(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))})) = <b>t</b>, for every IRI <tt>c</tt> identifying a class in <i>V</i>; 
</li><li> DT(<tt>c</tt>) is the set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)({(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))})) = <b>t</b>, for every IRI <tt>c</tt> identifying a datatype in <i>V</i>; 
</li><li> OP(<tt>p</tt>) is the set of all pairs (<tt>k</tt>, <tt>l</tt>) such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)({(<i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt>)})) = <b>t</b> (true), for every IRI <tt>p</tt> identifying an object property in <i>V</i>; 
</li><li> DP(<tt>p</tt>) is the set of all pairs (<tt>k</tt>, <tt>l</tt>) such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)({(<i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt>)})) = <b>t</b> (true), for every IRI <tt>p</tt> identifying a data property in <i>V</i>; 
</li><li> I(<tt>i</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>&lt;i&gt;</tt>) for every IRI <tt>i</tt> identifying an individual in <i>V</i>;
</li><li> C(<tt>c</tt>) is the set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>isa</sub>(<tt>k</tt>,<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))) = <b>t</b>, for every IRI <tt>c</tt> identifying a class in <i>V</i>;
</li><li> DT(<tt>c</tt>) is the set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>isa</sub>(<tt>k</tt>,<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))) = <b>t</b>, for every IRI <tt>c</tt> identifying a datatype in <i>V</i>;
</li><li> C(<tt>c</tt>) is a subset of C(<tt>d</tt>) whenever <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>&lt;d&gt;</tt>))) = <b>t</b>, for any two IRIs <tt>c</tt> and <tt>d</tt> identifying classes in <i>V</i>.&nbsp;&nbsp;☐
</li></ol>
<p>Condition 2 ensures that the relevant parts of the domains of
interpretation are the same.  Conditions 3 and 4 ensures that the
interpretation (extension) of an OWL class or datatype identified by an IRI
<tt>u</tt> corresponds to the interpretation of frames of the
form  <tt>?x[rdf:type -&gt; &lt;u&gt;]</tt>.  Conditions 5 and 6
ensure that the interpretation (extension) of an OWL object or
data property identified by an IRI <tt>u</tt> corresponds to
the interpretation of frames of the form  <tt>?x[&lt;u&gt; -&gt;
?y]</tt>. Condition 7 ensures that individual
identifiers in the OWL ontologies and the RIF documents are
interpreted in the same way. Conditions 8 and 9 ensure that typing in OWL and typing in RIF correspond, i.e., <tt>ClassAssertion(b a)</tt> is true iff <tt>a # b</tt> is true. Finally, 10 ensures that whenever a RIF subclass statement holds, the corresponding OWL subclass statement holds as well, i.e., <tt>SubClassOf(a b)</tt> is true if <tt>a ## b</tt> is true. 
</p><p><br />
Using the definition of common-RIF-OWL Direct-interpretation,
satisfaction, models, and entailment are defined in the usual
way:
</p><p><b>Definition.</b> A
<a href="#def-common-dl-interpretation" title="">common-RIF-OWL Direct-interpretation</a>
(<i><b>&Icirc;</b></i>, <i>I</i>) for a Vocabulary <i>V</i> over an
<a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a> D is an  <span id="def-owl-direct-model"><i><b>RIF-OWL Direct-model</b></i></span> of a
<a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> C=&lt;
<i>R</i>, <b>O</b> &gt; if <i><b>&Icirc;</b></i> is a <a href="#def-dl-model" title="">model</a>
of <i>R</i> and <i>I</i> is a <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Models" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Models">model</a> of every ontology <i>O</i> in
<b>O</b>; in this case C is <i><b><span id="def-owl-direct-satisfiable">RIF-OWL Direct-satisfiable</span></b></i> for
<i>V</i> over D.   (<i><b>&Icirc;</b></i>, <i>I</i>) is an
<i><b>RIF-OWL Direct-model</b></i> of an OWL 2 DL ontology <i>O</i> if <i>I</i> is a
<a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Models" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Models">model</a> of <i>O</i>. (<i><b>&Icirc;</b></i>, <i>I</i>) is an
<i><b>RIF-OWL DL-model</b></i> of a <a href="#def-dl-condition" title="">DL-condition formula</a> &phi; if <i>TVal</i><sub>&Icirc;</sub>(&phi;)=<b>t</b>.
</p><p>Let C be a RIF-OWL DL-combination, let <i>O</i> be an OWL 2 DL
ontology, let &phi; be a <a href="#def-dl-condition" title="">DL-condition
formula</a>, and let D be an <a href="#def-owl2-datatype-map" title="">OWL 2
datatype map</a> <a href="#def-conforming-datatype-map" title="">conforming</a> with
the set of <a href="#def-considered-datatypes" title="">considered datatypes</a>,
and let <i>V</i> be a Vocabulary over D for every ontology in C
and for <i>O</i>. C <span id="def-owl-direct-entails"><i><b>RIF-OWL Direct-entails</b></i></span> <i>O</i>
with respect to D if every common-RIF-OWL Direct-interpretation
for <i>V</i> over D that is an <a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a>
of C is an <a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a> of <i>O</i>.
Likewise, C <i><b>RIF-OWL Direct-entails</b></i> &phi; with respect to D
if every common-RIF-OWL Direct-interpretation for <i>V</i> over D
that is an <a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a> of C is an
<a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a> of &phi;.
&nbsp;&nbsp;☐
</p><p><br />
<b>Example.</b> In the OWL 2 Direct Semantics, the domains for interpreting
individuals respectively, literals (data values), are disjoint.
The disjointness entails that data values cannot be members of
a class and individuals cannot be members of a datatype.
</p><p>RIF does not make such distinctions; variable quantification
ranges over the entire domain.  So, the same variable may be
assigned to an abstract individual or a concrete data value.
Additionally, RIF constants (e.g., IRIs) denoting individuals
can be written in place of a data value, such as the value of a
data-valued property or in datatype membership statements;
similarly for constants denoting data values.  Such statements
cannot be satisfied in any common-RIF-OWL Direct-interpretation.
The following example illustrates several such statements.
</p><p>Consider the datatype <tt>xs:string</tt> and a RIF-OWL DL
combination consisting of the set containing only an OWL 2 DL ontology that contains
</p>
<pre>ex:myiri rdf:type ex:A .
</pre>
<p>and a RIF document containing the following fact
</p>
<pre>ex:myiri[rdf:type -&gt; xs:string]
</pre>
<p>This combination is not
<a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiable</a>, because
ex:myiri is an individual identifier and S maps individual
identifiers to elements in O, which is disjoint from the
elements in the datatype <tt>xs:string</tt>.
</p><p>Consider a RIF-OWL DL combination consisting of the set
containing only the OWL 2 DL ontology
</p>
<pre>ex:hasChild rdf:type owl:ObjectProperty .
</pre>
<p>and a RIF document containing the following fact
</p>
<pre>ex:myiri[ex:hasChild -&gt; "John"]
</pre>
<p>This combination is not
<a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiable</a>, because
ex:hasChild is an object property, and values of object
properties may not be concrete data values.
</p><p>Consider a RIF-OWL DL combination consisting of the OWL DL
ontology
</p>
<pre>SubClassof(ex:A ex:B)
</pre>
<p>and a RIF document containing the following rule
</p>
<pre>Forall&nbsp;?x (?x[rdf:type -&gt; ex:A])
</pre>
<p>This combination is not
<a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiable</a>, because the
rule requires every element, including every concrete data
value, to be a member of the class <tt>ex:A</tt>. However,
since every OWL interpretation requires every member of
<tt>ex:A</tt> to be an element of the object domain, concrete
data values cannot be members of the object domain.&nbsp;&nbsp;☐
</p>
<a id="Importing_RDF_and_OWL_in_RIF" name="Importing_RDF_and_OWL_in_RIF"></a><h2> <span class="mw-headline">5  Importing RDF and OWL in RIF </span></h2>
<p>In the preceding sections, <a href="#RIF-RDF_Combinations" title="">RIF-RDF Combinations</a> and <a href="#Syntax_of_RIF-OWL_Combinations" title="">RIF-OWL combinations</a> were defined in an abstract way, as pairs consisting of a RIF document and a set of RDF graphs/OWL ontologies.  In addition, different semantics were specified based on the various RDF and OWL entailment regimes.
RIF provides a mechanism for explicitly referring to (importing) RDF graphs from documents and specifying the intended profile (entailment regime) through the use of <tt>Import</tt> statements.
</p><p>This section specifies how RIF documents with such import statements must be interpreted.
</p><p><br />
A <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">RIF document</a> contains a number of <tt>Import</tt> statements.  Unary <tt>Import</tt> statements are used for importing RIF documents, and the interpretation of these statements is defined in <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#Interpretation_of_Documents" title="BLD">Section 3.5</a> of [<a href="#ref-rif-bld" title="">RIF-BLD</a>].  This section defines the interpretation of binary <tt>Import</tt> statements:
</p>
<pre>Import(&lt;t1&gt; &lt;p1&gt;)
  ...
Import(&lt;tn&gt; &lt;pn&gt;)
  
</pre>
<p>Here, <tt>ti</tt> is an absolute IRI referring to an RDF graph to be imported and <tt>pi</tt> is an absolute IRI denoting the profile to be used for the import. 
</p><p>The profile determines which notions of model, satisfiability and entailment must be used.  For example, if a RIF document <i>R</i> imports an RDF graph <i>S</i> with the profile <i>RDFS</i>, the notions of <a href="#def-rdfs-model" title="">RIF-RDFS-model</a>, <a href="#def-rdfs-satisfiable" title="">RIF-RDFS-satisfiability</a>, and <a href="#def-rdfs-entails" title="">RIF-RDFS-entailment</a> must be used for the combination &lt;<i>R</i>, {<i>S</i>}&gt;.
</p><p>Profiles are ordered as specified in <a href="#Specific_Profiles" title="">Section 5.1.1</a>. If several graphs are imported in a document, and these imports specify different profiles, the highest of these profiles is used. For example, if a RIF document <i>R</i> imports an RDF graph <i>S</i><sub>1</sub> with the profile <i>RDF</i> and an RDF graph <i>S</i><sub>2</sub> with the profile <i>OWL RDF-Based</i>, the notions of <a href="#def-owl-full-model" title="">RIF-OWL RDF-Based-model</a>, <a href="#def-owl-full-satisfiable" title="">RIF-OWL RDF-Based-satisfiability</a>, and <a href="#def-owl-full-entails" title="">RIF-OWL RDF-Based-entailment</a> must be used with the combination &lt;<i>R</i>, {<i>S</i><sub>1</sub>, <i>S</i><sub>2</sub>}&gt;.
</p><p>Finally, if a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">RIF document</a> <i>R</i> imports an RDF graph <i>S</i> with the profile <i>OWL Direct</i>, <i>R</i> must be a <a href="#def-dl-document" title="">RIF-BLD DL-document formula</a>, <i>S</i> must be
the <a class="external text" href="http://www.w3.org/TR/2008/WD-owl2-mapping-to-rdf-20081202/#Mapping_from_the_Structural_Specification_to_RDF_Graphs" rel="nofollow" title="http://www.w3.org/TR/2008/WD-owl2-mapping-to-rdf-20081202/#Mapping_from_the_Structural_Specification_to_RDF_Graphs">RDF representation</a> of an OWL 2 DL ontology <i>O</i>, and the notions of <a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a>, <a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiability</a>, and <a href="#def-owl-direct-entails" title="">RIF-OWL Direct-entailment</a> must be used with the combination &lt;<i>R</i>, {<i>O</i>}&gt;.
</p>
<a id="Profiles_of_Imports" name="Profiles_of_Imports"></a><h3> <span class="mw-headline">5.1  Profiles of Imports </span></h3>
<p>RIF defines specific profiles for the different notions of model, satisfiability and entailment of combinations, as well as one generic profile.  The use of a specific profile specifies how a combination should be interpreted. If a specific profile cannot be handled by a receiver, the combination should be rejected. The use of a generic profile implies that a receiver may interpret the combination to the best of its ability.
</p><p>The use of profiles is not restricted to the profiles specified in this document.  Any specific profile that is used with RIF must specify an IRI that identifies it, as well as associated notions of model, satisfiability, and entailment for combinations.
</p>
<a id="Specific_Profiles" name="Specific_Profiles"></a><h4> <span class="mw-headline">5.1.1  Specific Profiles </span></h4>
<p>The following table lists the specific profiles defined by RIF, the IRIs of these profiles, and the notions of model, satisfiability, and entailment that must be used with the profile.
</p>
<table border="1" id="tab-specific-profiles">
<caption>Specific profiles in RIF.</caption>
<tr>
  <th>Profile</th>
  <th>IRI of the Profile</th>
  <th>Model</th>
  <th>Satisfiability</th>
  <th>Entailment</th>
</tr>
<tr>
  <td>Simple</td>
  <td>http://www.w3.org/ns/entailment/Simple</td>
  <td><a href="#def-simple-model" title="">RIF-Simple-model</a></td>
  <td><a href="#def-rif-rdf-satisfies" title="">satisfiability</a></td>
  <td><a href="#def-simple-entails" title="">RIF-Simple-entailment</a></td>
</tr>
<tr>
  <td>RDF</td>
  <td>http://www.w3.org/ns/entailment/RDF</td>
  <td><a href="#def-rdf-model" title="">RIF-RDF-model</a></td>
  <td><a href="#def-rdf-satisfiable" title="">RIF-RDF-satisfiability</a></td>
  <td><a href="#def-rdf-entails" title="">RIF-RDF-entailment</a></td>
</tr>
<tr>
  <td>RDFS</td>
  <td>http://www.w3.org/ns/entailment/RDFS</td>
  <td><a href="#def-rdfs-model" title="">RIF-RDFS-model</a></td>
  <td><a href="#def-rdfs-satisfiable" title="">RIF-RDFS-satisfiability</a></td>
  <td><a href="#def-rdfs-entails" title="">RIF-RDFS-entailment</a></td>
</tr>
<tr>
  <td>D</td>
  <td>http://www.w3.org/ns/entailment/D</td>
  <td><a href="#def-d-model" title="">RIF-D-model</a></td>
  <td><a href="#def-d-satisfiable" title="">RIF-D-satisfiability</a></td>
  <td><a href="#def-d-entails" title="">RIF-D-entailment</a></td>
</tr>
<tr>
  <td>OWL Direct</td>
  <td>http://www.w3.org/ns/entailment/OWL-Direct</td>
  <td><a href="#def-owl-direct-model" title="">RIF-OWL Direct-model</a></td>
  <td><a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiability</a></td>
  <td><a href="#def-owl-direct-entails" title="">RIF-OWL Direct-entailment</a></td>
</tr>
<tr>
  <td>OWL RDF-Based</td>
  <td>http://www.w3.org/ns/entailment/OWL-RDF-Based</td>
  <td><a href="#def-owl-full-model" title="">RIF-OWL RDF-Based-model</a></td>
  <td><a href="#def-owl-full-satisfiable" title="">RIF-OWL RDF-Based-satisfiability</a></td>
  <td><a href="#def-owl-full-entails" title="">RIF-OWL RDF-Based-entailment</a></td>
</tr>
</table>
<p>Profiles that are defined for combinations of DL-document formulas and OWL ontologies in abstract syntax form are called <i>DL profiles</i>. Of the mentioned profiles, the profile <i>OWL Direct</i> is a DL profile.
</p><p>The profiles are ordered as follows, where '<tt>&lt;</tt>' reads "is lower than":
</p><p>Simple <tt> &lt; </tt> RDF <tt> &lt; </tt> RDFS <tt> &lt; </tt> D <tt> &lt; </tt> OWL RDF-Based
</p><p>OWL Direct <tt> &lt; </tt> OWL RDF-Based
</p>
<a id="Generic_Profile" name="Generic_Profile"></a><h4> <span class="mw-headline">5.1.2  Generic Profile </span></h4>
<p>RIF specifies one generic profile.  The use of the generic profile does not imply the use of a specific notion of model, satisfiability, and entailment.
</p>
<table border="1" id="tab-generic-profiles">
<caption>Generic profile in RIF.</caption>
<tr>
  <th>Profile</th>
  <th>IRI of the Profile</th>
</tr>
<tr>
  <td>Generic</td>
  <td>&lt;http://www.w3.org/2007/rif-import-profile#Generic&gt;</td>
</tr>
</table>
<a id="Interpretation_of_Profiles" name="Interpretation_of_Profiles"></a><h3> <span class="mw-headline">5.2  Interpretation of Profiles </span></h3>
<p>Let <i>R</i> be a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">RIF document</a> such that
</p>
<pre>Import(&lt;u1&gt; &lt;p1&gt;)
  ...
Import(&lt;un&gt; &lt;pn&gt;)
</pre>
<p>are all the two-ary import statements in <i>R</i> and the documents <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-imported-doc" title="BLD">imported</a> into <i>R</i> and let <tt>Profile</tt> be the set of profiles corresponding to the IRIs <tt>p1,...,pn</tt>.
</p><p>If <tt>pi</tt>, <tt>1 &le; i &le; n</tt>, corresponds to a DL profile and <tt>ui</tt> refers to an RDF graph that is not the RDF representation of an OWL (2) DL ontology, the document should be rejected.
</p><p>If <tt>ui</tt>, <tt>1 &le; i &le; n</tt>, refers to an RDF graph that uses a typed literal of the form <tt>"s"^^rif:iri</tt> or <tt>"s"^^rdf:PlainLiteral</tt>, the document must be rejected.
</p><p>If <tt>Profile</tt> contains only specific profiles, then:
</p>
<ul><li> If <tt>Profile</tt> does not have a single highest profile, the document must be rejected.
</li></ul>
<ul><li> If <tt>Profile</tt> contains only DL profiles and <i>R</i> is not a DL-document formula, it must be rejected.
</li></ul>
<ul><li> If <tt>Profile</tt> contains only DL profiles and the RDF graphs referred to by <tt>u<sub>1</sub>,...,u<sub>n</sub></tt> are RDF representations of the OWL 2 ontologies <i>O</i><sub>1</sub>,....,<i>O</i><sub>n</sub>, then the combination C=&lt;<i>R</i>,{<i>O</i><sub>1</sub>,....,<i>O</i><sub>n</sub>}&gt; must be interpreted according to the highest among the profiles in  <tt>Profile</tt>.
</li></ul>
<ul><li> Otherwise, the combination C=&lt;<i>R</i>,{<i>S</i><sub>1</sub>,....,<i>S</i><sub>n</sub>}&gt;, where <i>S</i><sub>1</sub>,....,<i>S</i><sub>n</sub> are the RDF graphs referred to by <tt>u<sub>1</sub>,...,u<sub>n</sub></tt>, must be interpreted according to the highest among the profiles in <tt>Profile</tt>.
</li></ul>
<p>If <tt>Profile</tt> contains a generic profile, then the combination C=&lt;<i>R</i>,{<i>S</i><sub>1</sub>,....,<i>S</i><sub>n</sub>}&gt;, where <i>S</i><sub>1</sub>,....,<i>S</i><sub>n</sub> are the RDF graphs referred to by <tt>u<sub>1</sub>,...,u<sub>n</sub></tt>, may be interpreted according to the highest among the specific profiles in <tt>Profile</tt>, if there is one.
</p>
<a id="Conformance_Clauses" name="Conformance_Clauses"></a><h2> <span class="mw-headline">6  Conformance Clauses </span></h2>
<p>We define notions of conformance for RIF-RDF and RIF-OWL combinations.  We define these notions both for the RIF Core [<a href="#ref-rif-core" title="">RIF-Core</a>] and RIF BLD [<a href="#ref-rif-bld" title="">RIF-BLD</a>] dialects.
</p><p>Conformance is described in terms of semantics-preserving transformations between the native syntax of a compliant processor and the XML syntax of RIF Core and BLD.
</p><p>We say that an RDF graph <i>S</i> is a <i>standard RDF graph</i> if for every triple <tt>s p o</tt> in <i>S</i>,  <tt>s</tt> is an IRI or blank node, <tt>p</tt> is an IRI, and <tt>o</tt> is an IRI, literal, or blank node. A combination &lt; <i>R</i>, <b>S</b> &gt; is <i>standard</i> if every graph in <b>S</b> is standard.
</p><p>Each RIF processor has sets &Tau;, of supported datatypes and symbol spaces that include the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#Symbol_Spaces" title="DTB">symbol spaces</a> listed in
[<a href="#ref-rif-dtb" title="">RIF-DTB</a>], and &Epsilon;, of supported external terms that include the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. The datatype map of a RIF processor is the smallest datatype map conforming with the set of datatypes in &Tau;. 
</p><p>Now, let <tt>P</tt> &isin; {Simple, RDF, RDFS, D, OWL RDF-Based} be a <a href="#Specific_Profiles" title="">specific RDF profile</a>. A <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt; <i>R</i>, <b>S</b> &gt; is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combination if <i>R</i> is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formula and C is a <i>Core</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combination if <i>R</i> is a <i>Core</i><sub>&Tau;,&Epsilon;</sub> formula. 
</p><p>A <a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> C=&lt;
<i>R</i>, <b>O</b> &gt; is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-OWL Direct combination if <i>R</i> is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formula and C is a <i>Core</i><sub>&Tau;,&Epsilon;</sub>-OWL Direct combination if <i>R</i> is a <i>Core</i><sub>&Tau;,&Epsilon;</sub> formula. 
</p><p><span class="anchor" id="def-conformance"></span>
A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> <i><b>consumer</b></i>, for <tt>P</tt> &isin; {Simple, RDF, RDFS, D, OWL Direct, OWL RDF-Based}, iff it implements a <span class="anchor" id="def-sem-preserving-map-to"><i>semantics-preserving mapping</i></span>, &mu;, from the set of standard <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combinations, standard RDF graphs, OWL 2 ontologies, and <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formulas to the language <i>L</i> of the processor (&mu; does not need to be an "onto" mapping) and, in case <tt>P</tt> &isin; {OWL Direct, OWL RDF-Based}, its datatype map is an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a>.
</p><p>We say that a RIF document <i>R</i> is list-safe if <i>R</i> is <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/#Safeness" title="Core">safe</a> and it contains no occurrences of <tt>rdf:first</tt>, <tt>rdf:rest</tt>, or <tt>rdf:nil</tt> in rule consequents. An RDF graph <i>S</i> is list-safe if it contains no occurrences of <tt>rdf:first</tt> or <tt>rdf:rest</tt> outside of the property positions, it contains no occurrences of <tt>rdf:nil</tt> outside of triples of the form <tt>... rdf:rest rdf:nil</tt>, and there are no two triples <tt>s rdf:first o1 . s rdf:first o2 .</tt> or <tt>s rdf:rest o1 . s rdf:rest o2 .</tt> in <i>S</i>, where <tt>s, o1, o2</tt> are RDF terms and <tt>o1&ne;o2</tt>. A combination  &lt; <i>R</i>, <b>S</b> &gt; is <i><b>list-safe</b></i> if <i>R</i> is list-safe and the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defmerge" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#defmerge">merge</a> of the graphs in <b>S</b> is list-safe.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>Core</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> <i><b>consumer</b></i>, for <tt>P</tt> &isin; {Simple, RDF, RDFS, D, OWL Direct, OWL RDF-Based}, iff it implements a <span class="anchor" id="def-sem-preserving-map-to2"><i>semantics-preserving mapping</i></span>, &mu;, from the set of  standard list-safe <i>Core</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combinations, standard RDF graphs, OWL 2 ontologies, and <i>Core</i><sub>&Tau;,&Epsilon;</sub> formulas to the language <i>L</i> of the processor (&mu; does not need to be an "onto" mapping) and, in case <tt>P</tt> &isin; {OWL Direct, OWL RDF-Based}, its datatype map is an <a href="#def-owl2-datatype-map" title="">OWL 2 datatype map</a>.
</p><p>Formally, this means that for any pair (&phi;, &psi;), where &phi; is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combination and &psi; is an RDF graph, OWL 2 ontology, or <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formula such that &phi; |=<sub><tt>P</tt></sub> &psi; is defined, &phi; |=<sub><tt>P</tt></sub> &psi; iff  &mu;(&phi;) |=<sub><tt><i>L</i></tt></sub> &mu;(&psi;). Here |=<sub><tt>P</tt></sub> denotes <tt>P</tt>-entailment and |=<sub><tt><i>L</i></tt></sub> denotes the logical entailment in the language <i>L</i> of the RIF processor.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> <i><b>producer</b></i> iff it implements a <span class="anchor" id="def-sem-preserving-map-from"><i>semantics-preserving mapping</i></span>, &nu;, from the language <i>L</i> of the processor to the set of all <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formulas, RDF graphs, OWL 2 ontologies, and <i>BLD</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combinations (&nu; does not need to be an "onto" mapping).
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>Core</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> <i><b>producer</b></i> iff it implements a <span class="anchor" id="def-sem-preserving-map-from2"><i>semantics-preserving mapping</i></span>, &nu;, from the language <i>L</i> of the processor to the set of all <i>Core</i><sub>&Tau;,&Epsilon;</sub> formulas, RDF graphs, OWL 2 ontologies, and <i>Core</i><sub>&Tau;,&Epsilon;</sub>-<tt>P</tt> combinations (&nu; does not need to be an "onto" mapping).
</p><p>Formally, this means that for any pair (&phi;, &psi;) of formulas in <i>L</i> such that &phi; |=<sub><tt><i>L</i></tt></sub> &psi; is defined, &phi; |=<sub><tt><i>L</i></tt></sub> &psi; iff  &nu;(&phi;) |=<sub><tt>P</tt></sub> &nu;(&psi;). Here |=<sub><tt>P</tt></sub> denotes <tt>P</tt>-entailment and |=<sub><tt><i>L</i></tt></sub> denotes the logical entailment in the language <i>L</i> of the RIF processor.
</p>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">7  Acknowledgements </span></h2>
<p>This document is the product of the Rules Interchange Format (RIF) Working Group (see below), 
the members of which deserve recognition for their time and commitment
to RIF.  The editors extend special thanks to: Mike Dean, Michael Kifer, Stella Mitchell, Axel Polleres, and  Dave Reynolds, for their thorough reviews and insightful discussions; 
the working group chairs, Chris Welty and Christian de Sainte-Marie, for their invaluable technical help and inspirational leadership; and W3C staff contact Sandro Hawke, a constant source of ideas, help, and feedback.
</p><p>The following members of the joint RIF-OWL task force have contributed to the <a href="#OWL_Compatibility" title="">OWL Compatibility</a> section in this document: Mike Dean, Peter F. Patel-Schneider, and Ulrike Sattler. 
</p><p><br />
The regular attendees at meetings of the Rule Interchange Format (RIF) Working Group at the time of the publication were:
Adrian Paschke (Freie Universitaet Berlin), 
Axel Polleres (DERI),
Chris Welty (IBM), 
Christian de Sainte Marie (IBM), 
Dave Reynolds (HP), 
Gary Hallmark (ORACLE), 
Harold Boley (NRC), 
Jos de Bruijn (FUB),
Leora Morgenstern (IBM), 
Michael Kifer (Stony Brook), 
Mike Dean (BBN), 
Sandro Hawke (W3C/MIT), and
Stella Mitchell (IBM).
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">8  References </span></h2>
<a id="Normative_References" name="Normative_References"></a><h3> <span class="mw-headline">8.1  Normative References </span></h3>
<dl><dt><span id="ref-owl2-rdf-based-semantics">[OWL2-RDF-Based-Semantics]</span></dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">OWL 2 Web Ontology Language: RDF-Based Semantics (Second Edition)</a></cite> Michael Schneider, editor. W3C Recommendation, 11 December 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/</a>.  Latest version available at <a class="external free" href="http://www.w3.org/TR/owl2-rdf-based-semantics/" rel="nofollow" title="http://www.w3.org/TR/owl2-rdf-based-semantics/">http://www.w3.org/TR/owl2-rdf-based-semantics/</a>.
</dd><dt><span id="ref-owl2-semantics">[OWL2-Semantics]</span></dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">OWL 2 Web Ontology Language: Direct Semantics (Second Edition)</a></cite> Boris Motik, Peter F. Patel-Schneider, Bernardo Cuenca Grau, eds. W3C Recommendation, 11 December 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/</a>.  Latest version available at <a class="external free" href="http://www.w3.org/TR/owl2-direct-semantics" rel="nofollow" title="http://www.w3.org/TR/owl2-direct-semantics">http://www.w3.org/TR/owl2-direct-semantics</a>.
</dd><dt><span id="ref-owl2-syntax">[OWL2-Syntax]</span></dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">OWL 2 Web Ontology Language: Structural Specification and Functional-Style Syntax (Second Edition)</a></cite> Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, 11 December 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/</a>.  Latest version available at <a class="external free" href="http://www.w3.org/TR/owl2-syntax/" rel="nofollow" title="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>.
</dd><dt><span id="ref-rdf-concepts">[RDF-Concepts]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a></i>, G. Klyne, J. Carrol, Editors, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>.
</dd><dt><span id="ref-rdf-semantics">[RDF-Semantics]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF Semantics</a></i>, P. Hayes, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">http://www.w3.org/TR/2004/REC-rdf-mt-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/rdf-mt/" rel="nofollow" title="http://www.w3.org/TR/rdf-mt/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/rdf-mt/" rel="nofollow" title="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/</a>.
</dd><dt><span id="ref-rif-core">[RIF-Core]</span></dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/"><span>RIF Core Dialect (Second Edition)</span></a></cite> Harold Boley, Gary Hallmark, Michael Kifer, Adrian Paschke, Axel Polleres, Dave Reynolds, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a>.</span></dd><dt><span id="ref-rif-bld">[RIF-BLD]</span></dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/"><span>RIF Basic Logic Dialect (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a>.</span></dd><dt><span id="ref-rif-dtb">[RIF-DTB]</span></dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<a id="Informational_References" name="Informational_References"></a><h3> <span class="mw-headline">8.2  Informational References </span></h3>
<dl><dt><span id="ref-curie">[CURIE]</span></dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">CURIE Syntax 1.0</a></cite>, S. McCarron, M. Birbeck,  Editors, W3C Working Group Note, 16 December 2010, <a class="external free" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">http://www.w3.org/TR/2010/NOTE-curie-20101216</a> . Latest version available at <a class="external free" href="http://www.w3.org/TR/curie" rel="nofollow" title="http://www.w3.org/TR/curie">http://www.w3.org/TR/curie</a>.
</dd><dt><span id="ref-dlp">[DLP]</span></dt><dd> <i><a class="external text" href="http://www.cs.man.ac.uk/~horrocks/Publications/download/2003/p117-grosof.pdf" rel="nofollow" title="http://www.cs.man.ac.uk/~horrocks/Publications/download/2003/p117-grosof.pdf">Description Logic Programs: Combining Logic Programs with Description Logics</a></i>, B. Grosof, R. Volz, I. Horrocks, S. Decker. In Proc. of the 12th International World Wide Web Conference (WWW 2003), 2003. 
</dd><dt><span id="ref-motik05">[Motik05]</span></dt><dd> <i>Query Answering for OWL-DL with rules</i>, B. Motik, U. Sattler, R. Studer, Journal of Web Semantics 3(1): 41-60, 2005.
</dd><dt><span id="ref-owl-reference">[OWL-Reference]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web Ontology Language Reference</a></i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">http://www.w3.org/TR/2004/REC-owl-ref-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd><dt><span id="ref-owl-semantics">[OWL-Semantics]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-owl-semantics-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-semantics-20040210/">OWL Web Ontology Language Semantics and Abstract Syntax</a></i>, P. F. Patel-Schneider, P. Hayes, I. Horrocks, Editors, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-owl-semantics-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-semantics-20040210/">http://www.w3.org/TR/2004/REC-owl-semantics-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/owl-semantics/" rel="nofollow" title="http://www.w3.org/TR/owl-semantics/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/owl-semantics/" rel="nofollow" title="http://www.w3.org/TR/owl-semantics/">http://www.w3.org/TR/owl-semantics/</a>.
</dd><dt><span id="ref-owl2-profiles">[OWL2-Profiles]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/">OWL 2 Web Ontology Language: Profiles</a></i>, B. Motik, B. Cuenca Grau, I. Horrocks, Z. Wu, A. Fokoue, C. Lutz, Editors, W3C Recommendation, 27 October 2009, <a class="external free" href="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/">http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/</a>. <a class="external text" href="http://www.w3.org/TR/owl2-profiles/" rel="nofollow" title="http://www.w3.org/TR/owl2-profiles/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/owl2-profiles/" rel="nofollow" title="http://www.w3.org/TR/owl2-profiles/">http://www.w3.org/TR/owl2-profiles/</a>.
</dd><dt><span id="ref-owl2-rdf-mapping">[OWL2-RDF-Mapping]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/">OWL 2 Web Ontology Language: Mapping to RDF Graphs</a></i>, P. F. Patel-Schneider, B. Motik, Editors, W3C Recommendation, 27 October 2009, <a class="external free" href="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/">http://www.w3.org/TR/2009/REC-owl2-mapping-to-rdf-20091027/</a>. <a class="external text" href="http://www.w3.org/TR/owl2-mapping-to-rdf/" rel="nofollow" title="http://www.w3.org/TR/owl2-mapping-to-rdf/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/owl2-mapping-to-rdf/" rel="nofollow" title="http://www.w3.org/TR/owl2-mapping-to-rdf/">http://www.w3.org/TR/owl2-mapping-to-rdf/</a>.
</dd><dt><span id="ref-rdf-schema">[RDF-Schema]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/">RDF Vocabulary Description Language 1.0: RDF Schema</a></i>, D. Brickley, R.V. Guha, Editors, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/">http://www.w3.org/TR/2004/REC-rdf-schema-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/rdf-schema/" rel="nofollow" title="http://www.w3.org/TR/rdf-schema/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/rdf-schema/" rel="nofollow" title="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a>.
</dd><dt><span id="ref-rdf-syntax">[RDF-Syntax]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">RDF/XML Syntax Specification (Revised)</a></i>, D.  Beckett, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/</a>. <a class="external text" href="http://www.w3.org/TR/rdf-syntax-grammar/" rel="nofollow" title="http://www.w3.org/TR/rdf-syntax-grammar/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TR/rdf-syntax-grammar/" rel="nofollow" title="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a>.
</dd><dt><span id="ref-rfc-3066">[RFC-3066]</span></dt><dd> <i><a class="external text" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">RFC 3066 - Tags for the Identification of Languages</a></i>, H. Alvestrand, IETF, January 2001. This document is at <a class="external free" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">http://www.ietf.org/rfc/rfc3066</a>.
</dd><dt><span id="ref-rif-prd">[RIF-PRD]</span></dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/"><span>RIF Production Rule Dialect (Second Edition)</span></a></cite> Christian de Sainte Marie, Gary Hallmark, Adrian Paschke, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a>.</span></dd><dt><span id="ref-rif-ucr">[RIF-UCR]</span></dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/"><span>RIF Use Cases and Requirements (Second Edition)</span></a></cite> Adrian Paschke, Leora Morgenstern, David Hirtle, Allen Ginsberg, Paula-Lavinia Patranjan, Frank McCabe, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-ucr/">http://www.w3.org/TR/rif-ucr/</a>.</span></dd><dt><span id="ref-rosati06">[Rosati06]</span></dt><dd> <i>DL+log: Tight Integration of Description Logics and Disjunctive Datalog</i>, R. Rosati, Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning, pp. 68-78, 2005.
</dd><dt><span id="ref-swrl">[SWRL]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/Submission/2004/SUBM-SWRL-20040521/" rel="nofollow" title="http://www.w3.org/Submission/2004/SUBM-SWRL-20040521/">SWRL: A Semantic Web Rule Language Combining OWL and RuleML</a></i>, I. Horrocks, P. F. Patel-Schneider, H. Boley, S. Tabet, B., M. Dean, W3C Member Submission, 21 May 2004, <a class="external free" href="http://www.w3.org/Submission/2004/SUBM-SWRL-20040521/" rel="nofollow" title="http://www.w3.org/Submission/2004/SUBM-SWRL-20040521/">http://www.w3.org/Submission/2004/SUBM-SWRL-20040521/</a>. <a class="external text" href="http://www.w3.org/Submission/SWRL/" rel="nofollow" title="http://www.w3.org/Submission/SWRL/">Latest version</a> available at <a class="external free" href="http://www.w3.org/Submission/SWRL/" rel="nofollow" title="http://www.w3.org/Submission/SWRL/">http://www.w3.org/Submission/SWRL/</a>.
</dd><dt><span id="ref-turtle">[Turtle]</span></dt><dd> <i><a class="external text" href="http://www.w3.org/TeamSubmission/2008/SUBM-turtle-20080114/" rel="nofollow" title="http://www.w3.org/TeamSubmission/2008/SUBM-turtle-20080114/">Turtle - Terse RDF Triple Language</a></i>, D. Beckett, T. Berners-Lee, W3C Team Submission, 14 January 2008, <a class="external free" href="http://www.w3.org/TeamSubmission/2008/SUBM-turtle-20080114/" rel="nofollow" title="http://www.w3.org/TeamSubmission/2008/SUBM-turtle-20080114/">http://www.w3.org/TeamSubmission/2008/SUBM-turtle-20080114/</a>. <a class="external text" href="http://www.w3.org/TeamSubmission/turtle/" rel="nofollow" title="http://www.w3.org/TeamSubmission/turtle/">Latest version</a> available at <a class="external free" href="http://www.w3.org/TeamSubmission/turtle/" rel="nofollow" title="http://www.w3.org/TeamSubmission/turtle/">http://www.w3.org/TeamSubmission/turtle/</a>.
</dd><dt> <span id="ref-xml-schema2">[XML Schema Datatypes]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>. David Peterson, Shudi Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and Henry S. Thompson, eds.  W3C Recommendation, 5 April 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/</a>.  Latest version available as <a class="external free" href="http://www.w3.org/TR/xmlschema11-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
</dd></dl>
<a id="Appendix:_Embeddings_.28Informative.29" name="Appendix:_Embeddings_.28Informative.29"></a><h2> <span class="mw-headline">9  Appendix: Embeddings (Informative) </span></h2>
<p>RIF-RDF combinations can be embedded into RIF documents in a fairly straightforward way, thereby demonstrating how a RIF-compliant translator without native support for RDF can process RIF-RDF combinations.
</p><p>RIF-OWL combinations cannot be embedded in RIF, in the general case.  However, there is a subset of OWL 2 DL, namely the OWL 2 RL profile [<a href="#ref-owl2-profiles" title="">OWL2-Profiles</a>], for which RIF-OWL combinations that can be embedded.
</p><p>Simple, RDF, RDFS and OWL 2 RL entailment for RIF-RDF combinations are 
embedded in RIF BLD.
</p><p>Note that Simple, RDF and RDFS entailments are superficially embeddable 
within RIF Core. However, condition 7 of the semantics of RIF-RDF 
combinations cannot be axiomatized in RIF Core due to restrictions on 
the use isa (#) in rule heads. OWL 2 RL is not embeddable in RIF Core 
due the the need for equality reasoning.
</p><p>The embeddings are defined using an embedding function tr that maps symbols, triples, and RDF graphs/OWL ontologies to RIF symbols, statements, and documents, respectively.
</p><p>To embed consistency checking in RDF(S) and OWL, we use a special 0-ary predicate symbol <tt>rif:error</tt>, which is assumed not to be used in the RIF documents in the combination.
</p><p><br />
Besides the namespace prefixes defined in the <a href="#Overview_of_RDF_and_OWL_Compatibility" title="">Overview</a>, the following namespace prefix is used in this appendix: <tt>pred</tt> refers to the RIF namespace for built-in predicates <tt>http://www.w3.org/2007/rif-builtin-predicate#</tt> [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>To facilitate the definition of the embeddings we define the notion of a <i>merge</i> of RIF formulas.
</p><p><b>Definition.</b> Let <b>R</b>={<i>R</i><sub>1</sub>,...,<i>R</i><sub>n</sub>} be a set of <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-wff" title="BLD">document, group, and rule formulas</a>, such that there are no prefix or base directives, or relative IRIs in <b>R</b> and <tt><em>directive<sub>11</sub></em></tt>, ..., <tt><em>directive<sub>nm</sub></em></tt> are all the <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-directives" title="BLD">import directives</a> occurring in document formulas in <b>R</b>. 
The <span id="def-merge"><i><b>merge</b></i></span> of <b>R</b>, denoted merge(<b>R</b>), is defined as <tt>Document(<em>directive<sub>11</sub></em></tt> ...  <tt><em>directive</em><sub>nm</sub> Group(</tt><i>R*</i><sub>1</sub> ... <i>R*</i><sub>n</sub><tt>))</tt>, where <i>R*</i><sub>i</sub> is obtained from <i>R</i><sub>i</sub> in the following way: 
</p>
<ul><li> if <i>R</i><sub>i</sub> is a document formula of the form <tt>Document(<em>directive<sub>i1</sub></em> ... <em>directive<sub>im</sub></em> &Gamma;)</tt>, then <i>R*</i><sub>i</sub>=<tt>&Gamma;</tt> and
</li><li> if <i>R</i><sub>i</sub> is a non-document formula (i.e., fact, rule, or group), then <i>R*</i><sub>i</sub>=<i>R</i><sub>i</sub>. &nbsp;&nbsp;☐
</li></ul>
<p>Note that the requirement that no prefix or based directives, or relative IRIs are included in any of the formulas to be merged is not a limitation, since compact IRIs can be rewritten to absolutes IRIs, as can relative IRIs, by exploiting prefix and base directives, and the location of the document. 
</p>
<a id="Embedding_RIF-RDF_Combinations" name="Embedding_RIF-RDF_Combinations"></a><h3> <span class="mw-headline">9.1  Embedding RIF-RDF Combinations </span></h3>
<p>RIF-RDF combinations are embedded by combining the RIF rules with embeddings of the RDF graphs and an axiomatization of Simple, RDF, and RDFS entailment.
</p><p>The embedding is not defined for combinations that include infinite RDF graphs and for combinations that include RDF graphs with RDF URI references that are not absolute IRIs (see the <a href="#note-rdf-uri-references" title="">End note on RDF URI references</a>) or plain literals without language tags that are not in the lexical space of the <tt><a class="external text" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#string" rel="nofollow" title="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#string">xs:string</a></tt> datatype [<a href="#ref-xml-schema2" title="">XML-Schema2</a>]. Also, the embedding is not defined for RDF lists. 
</p><p>We define a list-free combination as a combination that does not contain any mention of the symbols <tt>rdf:first</tt>, <tt>rdf:rest</tt>, or <tt>rdf:nil</tt>.
</p><p>In the remainder of this section we first define the embedding of symbols, triples, and graphs, after which we define the axiomatization of Simple, RDF, and RDFS entailment of combinations and, finally, demonstrate faithfulness of the embeddings.
</p>
<a id="Embedding_Symbols" name="Embedding_Symbols"></a><h4> <span class="mw-headline">9.1.1  Embedding Symbols </span></h4>
<p>Given a <a href="#def-rif-rdf-combination" title="">combination</a> C=&lt; <i>R</i>,<b>S</b>&gt;, the function tr maps RDF symbols of a Vocabulary <i>V</i> and a set of blank nodes <i>B</i> to RIF symbols, as defined in the following table. It is assumed that the Vocabulary <i>V</i> includes all the IRIs and literals used in the RIF documents and condition formulas under consideration.
</p><p>In the table, the mapping tr' is
an injective function that maps typed literals to new constants in the <tt>rif:local</tt> symbol space, where a new constant is a constant that is not used in the document or its vicinity (i.e., imported or entailed formula, or entailing combination).  It "generates" a new constant from a typed literal. 
</p>
<table border="1">
<caption>Mapping RDF symbols to RIF.</caption>
<tr>
  <th>RDF Symbol</th>
  <th>RIF Symbol</th>
  <th>Mapping</th>
</tr>
<tr><td>IRI <tt>i</tt> in <em>V<sub>U</sub></em></td><td>Constant with symbol space <tt>rif:iri</tt></td><td>tr(<tt>i</tt>) = <tt>&lt;i&gt;</tt></td></tr>
<tr><td>Blank node <tt>_:x</tt> in <em>B</em></td><td>Variable symbol <tt>?x</tt></td><td>tr(<tt>_:x</tt>) = <tt>?x</tt></td></tr>
<tr><td>Plain literal without a language tag <tt>xxx</tt>  in <em>V<sub>PL</sub></em></td><td>Constant with the datatype <tt>xs:string</tt></td><td>tr(<tt>"xxx"</tt>) = <tt>"xxx"</tt></td></tr>
<tr><td>Plain literal with a language tag  <tt>"xxx"@lang</tt> in <em>V<sub>PL</sub></em></td><td>Constant with the datatype <tt>rdf:PlainLiteral</tt></td><td>tr(<tt>"xxx"@lang</tt>) = <tt>"xxx@lang"^^rdf:PlainLiteral</tt></td></tr>
<tr><td>Well-typed literal <tt>"s"^^u</tt> in <em>V<sub>TL</sub></em></td><td>Constant with the symbol space <tt>u</tt></td><td>tr(<tt>"s"^^u</tt>) = <tt>"s"^^u</tt></td></tr>
<tr><td>Non-well-typed literal <tt>"s"^^u</tt> in <em>V<sub>TL</sub></em></td><td>Local constant <tt>s-u'</tt> that is not used in C and is obtained from  <tt>"s"^^u</tt></td><td>tr(<tt>"s"^^u</tt>) = tr'(<tt>"s"^^u</tt>)</td></tr>
</table>
<a id="Embedding_Triples_and_Graphs" name="Embedding_Triples_and_Graphs"></a><h4> <span class="mw-headline">9.1.2  Embedding Triples and Graphs </span></h4>
<p>This section extends the mapping function tr to triples
and defines two embedding functions for RDF graphs.   In one embedding (tr<sub>R</sub>), graphs are embedded as RIF documents and variables (originating from blank nodes) are skolemized, i.e., replaced with new constant symbols.  In the other embedding (tr<sub>Q</sub>), graphs are embedded as condition formulas and variables (originating from blank nodes) are existentially quantified.  The following sections show how these embeddings can be used for reasoning with combinations.
</p><p>For skolemization we assume a function sk that takes as argument a formula &phi; and returns a formula &phi;' that is obtained from &phi; by replacing every variable symbol <tt>?</tt><i>x</i> with <tt>&lt;new-iri&gt;</tt>, where <tt>new-iri</tt> is a new globally unique IRI, i.e., it does not occur in the graph or its vicinity (i.e., entailing combination or entailed graph/formula).
</p>
<table border="1">
<tr>
  <th>RDF Construct</th>
  <th>RIF Construct</th>
  <th>Mapping</th>
</tr>
<tr>
  <td>Triple <tt>s p o .</tt></td>
  <td>Frame formula tr(<tt>s</tt>)<tt>[</tt>tr(<tt>p</tt>) <tt>-&gt;</tt> tr(<tt>o</tt>)<tt>]</tt></td>
  <td>tr(<tt>s p o .</tt>) = tr(<tt>s</tt>)<tt>[</tt>tr(<tt>p</tt>) <tt>-&gt;</tt> tr(<tt>o</tt>)<tt>]</tt></td>
</tr>
<tr>
  <td>Graph <i>S</i></td>
  <td>Group formula tr<sub>R</sub>(<i>S</i>)</td>
  <td>tr<sub>R</sub>(<i>S</i>) = sk(<tt>Document (Group (</tt>tr(<tt>t<sub>1</sub></tt>)<tt> ... </tt>tr(<tt>t<sub>m</sub></tt>)<tt>) )</tt>), where <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>m</sub></tt> are the triples in <i>S</i></td>
</tr>
<tr>
  <td>Graph <i>S</i></td>
  <td>Condition formula tr<sub>Q</sub>(<i>S</i>)</td>
  <td>tr<sub>Q</sub>(<i>S</i>) = <tt>Exists </tt>tr(<tt>x<sub>1</sub></tt>)<tt> ... </tt> tr(<tt>x<sub>n</sub></tt>) <tt>(And(</tt>tr(<tt>t<sub>1</sub></tt>)<tt> ... </tt>tr(<tt>t<sub>m</sub></tt>)<tt>))</tt>, where <tt>x<sub>1</sub></tt>, ..., <tt>x<sub>n</sub></tt> are the blank nodes occurring in <i>S</i> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>m</sub></tt> are the triples in <i>S</i></td>
</tr>
</table>
<a id="Embedding_Simple_Entailment" name="Embedding_Simple_Entailment"></a><h4> <span class="mw-headline">9.1.3  Embedding Simple Entailment </span></h4>
<p>The semantics of the RDF Vocabulary does not need to be axiomatized for Simple entailment.  Nonetheless, the connection between RIF class membership and subclass statements and the RDF type and subclass statements needs  axiomatization. We define:
</p>
<table border="1">
<tr valign="top">
  <td><em>R<sup>Simple</sup></em></td><td>=</td><td> <tt>Document( Group(</tt><br />
<p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y (?x[rdf:type -&gt;&nbsp;?y]&nbsp;:-&nbsp;?x #&nbsp;?y)</tt><br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y (?x #&nbsp;?y&nbsp;:-&nbsp;?x[rdf:type -&gt;&nbsp;?y])</tt><br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y (?x[rdfs:subClassOf -&gt;&nbsp;?y]&nbsp;:-&nbsp;?x ##&nbsp;?y]) ))</tt>
</p>
</td></tr>
</table>
<p>The following theorem shows how checking RIF-Simple-entailment of combinations can be reduced to checking entailment of RIF conditions by using the embeddings of RDF graphs defined above.
</p><p><b>Theorem</b> A list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt;<i>R</i>, <i>R<sup>Simple</sup></i>,{<i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>}&gt; <a href="#def-simple-entails" title="">RIF-Simple-entails</a> a <a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a> <i>T</i> if and only if merge({<i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> tr<sub>Q</sub>(<i>T</i>); 
C <a href="#def-simple-entails" title="">RIF-Simple-entails</a> a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a> &phi; if and only if merge({<i>R</i>, <i>R<sup>Simple</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> &phi;.
</p>
<blockquote> <span id="proof-simple-entailment"><b>Proof.</b></span> We prove both directions through contraposition. We first consider condition formulas (the second part of the theorem), after which we consider graphs (the first part of the theorem). <br />

In the proof we abbreviate merge({<i>R</i>, <i>R<sup>Simple</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) with R'.
<br />
<br />
(=&gt;) Assume R' does not entail &phi;.  This means there is some semantic multi-structure <i><b>&Icirc;</b></i> that is a model of R', but not of &phi;.

Consider the pair (<i><b>&Icirc;</b></i>, I), where I is the interpretation defined as follows: 
<ul><li> IR is <i><b>D</b></i><sub>ind</sub>, 
</li><li> IP is the set of all <tt>k</tt> in <i><b>D</b></i><sub>ind</sub> such that there exist some <tt>a</tt>,  <tt>b</tt> in <i><b>D</b></i><sub>ind</sub> and <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>a</tt>)(<tt>k</tt>,<tt>b</tt>))=<b>t</b>,
</li><li> LV is the union of the value spaces of all considered datatypes, 
</li><li> IEXT(<tt>k</tt>) is the set of all pairs (<tt>a</tt>, <tt>b</tt>), with <tt>a</tt>, <tt>b</tt>, and <tt>k</tt> in <i><b>D</b></i><sub>ind</sub>, such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>a</tt>)(<tt>k</tt>,<tt>b</tt>))=<b>t</b>,
</li><li> IS(<tt>i</tt>) is <i><b>I</b></i><sub>C</sub>(<tt>&lt;i&gt;</tt>), for every absolute IRI <tt>i</tt> in <i>V<sub>U</sub></i>, and
</li><li> IL((<tt>s</tt>, <tt>d</tt>)) is <i><b>I</b></i><sub>C</sub>(tr(<tt>"s"^^d</tt>)), for every typed literal (<tt>s</tt>, <tt>d</tt>) in <i>V<sub>TL</sub></i>.
</li></ul>

Clearly, (<i><b>&Icirc;</b></i>, I) is a <a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a>: conditions 1-6 in the definition are satisfied by construction of I and conditions 7 and 8 are satisfied by condition 4 and by the fact that <i><b>&Icirc;</b></i> is a model of <i>R<sup>Simple</sup></i>.
<br />
<br />
Consider a graph <i>S<sub>i</sub></i> in <i>{S<sub>1</sub>,...,S<sub>n</sub>}</i>. Let <i>x<sub>1</sub>,..., x<sub>m</sub></i> be the blank nodes in <i>S<sub>i</sub></i> and let <i>u<sub>1</sub>,..., u<sub>m</sub></i> be the new IRIs that were obtained from the variables <i>?x<sub>1</sub>,...,&nbsp;?x<sub>m</sub></i> through the skolemization in tr<sub>R</sub>(<i>S<sub>i</sub></i>), i.e., <i>u<sub>i</sub></i>=sk(<i>?x<sub>i</sub></i>).  Now, let A be a mapping from blank nodes to elements in <i><b>D</b></i><sub>ind</sub> such that A(<i>x<sub>j</sub></i>)=<i><b>I</b></i><sub>C</sub>(<i>u<sub>j</sub></i>) for every blank node <i>x<sub>j</sub></i> in <i>S<sub>i</sub></i>. From the fact that <i><b>I</b></i> is a model of tr<sub>R</sub>(<i>S<sub>i</sub></i>) and by construction of I it follows that [I+A] <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#unlabel" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#unlabel">satisfies</a> <i>S<sub>i</sub></i> (see <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#unlabel" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#unlabel">Section 1.5</a> of [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>])), and so I satisfies <i>S<sub>i</sub></i>.
<br />
<br />
We have that <i><b>&Icirc;</b></i> is a model of <i>R</i>, by assumption.  So, (<i><b>&Icirc;</b></i>, I) satisfies C. Again, by assumption,  <i><b>I</b></i> is not a model of &phi;.  Therefore, C does not entail &phi;.
<br />
<br />
Assume now that R' does not entail tr<sub>Q</sub>(<i>T</i>), which means there is a semantic multi-structure <i><b>&Icirc;</b></i> that is a model of R', but not of tr<sub>Q</sub>(<i>T</i>). The common-RIF-RDF-interpretation (<i><b>&Icirc;</b></i>, I) is obtained in the same way as above, and so it satisfies C.
<br /><br />
We proceed by contradiction. Assume I satisfies <i>T</i>.  This means there is some mapping A from the blank nodes <i>x<sub>1</sub>,...,x<sub>m</sub></i> in <i>T</i> to objects in <i><b>D</b></i><sub>ind</sub> such that [I+A] satisfies <i>T</i>. 
Consider now the semantic multi-structure <i><b>&Icirc;*</b></i>, which is the same as <i><b>&Icirc;</b></i>, with the exception of the mapping <i><b>I*</b></i><sub>V</sub> on the variables <i>?x<sub>1</sub>,...,?x<sub>m</sub></i>, which is defined as follows: <i><b>&Icirc;*</b></i><sub>V</sub>(<i>?x<sub>j</sub></i>)=A(<i>x<sub>j</sub></i>) for each blank node <i>x<sub>j</sub></i> in <i>S</i>. By construction of I and since [I+A] satisfies <i>T</i> we can conclude that <i><b>I*</b></i> is a model of <tt>And(</tt>tr(<tt>t<sub>1</sub></tt>)... tr(<tt>t<sub>m</sub></tt>)<tt>)</tt>, and so  <i><b>I</b></i> is a model of tr<sub>Q</sub>(<i>T</i>), violating the assumption that it is not. Therefore, (<i><b>&Icirc;</b></i>, I) does not satisfy <i>T</i> and C does not entail <i>T</i>.
<br />
<br />
(&lt;=) Assume C does not Simple-entail &phi;.  This means there is some common-RIF-RDF-interpretation (<i><b>&Icirc;</b></i>, I) that satisfies C such that <i><b>I</b></i> is not a model of &phi;.
<br />
<br />
Consider the semantic multi-structure <i><b>&Icirc;'</b></i>, which is like <i><b>&Icirc;</b></i>, except for the mapping  <i><b>I'</b></i><sub>C</sub> on the new IRIs that were introduced by the skolemization mapping sk(). The mapping of these new IRIs is defined as follows:<br />
For each graph <i>S<sub>i</sub></i> in <i>{S<sub>1</sub>,...,S<sub>n</sub>}</i>, let <i>x<sub>1</sub>,..., x<sub>m</sub></i> be the blank nodes in <i>S<sub>i</sub></i> and let <i>u<sub>1</sub>,..., u<sub>m</sub></i> be the new IRIs that were obtained from the variables <i>?x<sub>1</sub>,...,&nbsp;?x<sub>m</sub></i> through the skolemization in tr<sub>R</sub>(<i>S<sub>i</sub></i>), i.e., <i>u<sub>j</sub></i>=sk(<i>?x<sub>j</sub></i>).  Now, since I satisfies <i>S<sub>i</sub></i>, there must be a mapping A from blank nodes to elements in <i><b>D</b></i><sub>ind</sub> such that [I+A] satisfies <i>S<sub>i</sub></i>. We define <i><b>I'</b></i><sub>C</sub>(<i>u<sub>j</sub></i>)=A(<i>x<sub>j</sub></i>) for every blank node <i>x<sub>j</sub></i> in <i>S<sub>i</sub></i>. 
<br />
<br />
By assumption, <i><b>&Icirc;'</b></i> is a model of <i>R</i> (recall that <i><b>&Icirc;'</b></i> differs from <i><b>&Icirc;</b></i> only on the new IRIs, which are not in <i>R</i>).  Clearly, <i><b>I'</b></i> is also a model of <i>R<sup>Simple</sup></i>, by conditions 7, 8, and 4 in the definition of <a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a>.
From the fact that I satisfies <i>S<sub>i</sub></i> and by construction of <i><b>I'</b></i> it follows that <i><b>I'</b></i> is a model of tr<sub>R</sub>(<i>S<sub>i</sub></i>). So, <i><b>I'</b></i> is a model of R'.  Since <i><b>I</b></i> is not a model of &phi; and &phi; does not contain any of the new IRIs, <i><b>I'</b></i> is not the model of &phi;. Therefore, R' does not entail &phi;.
<br />
<br />
Assume now that C does not entail <i>T</i>, which means there is a common-RIF-RDF-interpretation  (<i><b>&Icirc;</b></i>, I) that satisfies C, but I does not satisfy <i>T</i>. We obtain <i><b>I'</b></i> from <i><b>I</b></i> in the same way as above, and so it satisfies R'. It can be shown analogous to the (=&gt;) direction that if <i><b>I'</b></i> is a model of tr<sub>Q</sub>(<i>T</i>), then there is a blank node mapping A such that [I+A] satisfies <i>T</i>, and thus I satisfies <i>T</i>, violating the assumption that it does not. Therefore, <i><b>I'</b></i> is not a model of tr<sub>Q</sub>(<i>T</i>) and thus R' does not entail tr<sub>Q</sub>(<i>T</i>). &nbsp;&nbsp;☐
</blockquote>
<p><b>Theorem</b> A list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> &lt;<i>R</i>,{<i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>}&gt; is <a href="#def-rif-rdf-satisfies" title="">satisfiable</a> iff there is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-semantic-multistruct" title="BLD">semantic multi-structure</a> <i><b>&Icirc;</b></i> that is a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-model-formula" title="BLD">model</a> of merge({<i>R</i>, <i>R<sup>Simple</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}).
</p>
<blockquote> <b>Proof.</b> The theorem follows immediately from the previous theorem and the observation that a combination (respectively, RIF  document) is satisfiable (respectively, has a model) if and only if it does not entail the condition formula <tt>"a"="b"</tt>. &nbsp;&nbsp;☐
</blockquote>
<a id="Embedding_RDF_Entailment" name="Embedding_RDF_Entailment"></a><h4> <span class="mw-headline">9.1.4  Embedding RDF Entailment </span></h4>
<p>We axiomatize the semantics of the RDF Vocabulary using the following RIF rules. 
</p><p>To finitely embed RDF entailment, we need to consider a subset of the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples">RDF axiomatic triples</a>. Given a combination C, the <i>context</i> of C includes C and its vicinity (i.e., all graphs/formulas considered for entailment checking).  The set of <i>RDF finite-axiomatic triples</i> is the smallest set such that:
</p>
<ul><li> every RDF axiomatic triple not of the form <tt>rdf:_<i>i</i> rdf:type rdf:Property</tt> is an RDF finite-axiomatic triple, where <tt><i>i</i></tt> is a positive integer,
</li><li> one triple <tt>rdf:_<i>m</i> rdf:type rdf:Property</tt>, for some positive integer <tt><i>m</i></tt> such that <tt>rdf:_<i>m</i></tt> does not occur in the context of C, is an RDF finite-axiomatic triple, and
</li><li> if <tt>rdf:_<i>j</i></tt> occurs in the context of C, for some positive integer <tt><i>j</i></tt>, then <tt>rdf:_<i>j</i> rdf:type rdf:Property</tt> is an RDF finite-axiomatic triple.
</li></ul>
<p>We assume that none of unary predicate symbols <tt>ex:wellxml</tt> and <tt>ex:illxml</tt> and no datatypes beyond those found in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] are used in the context of the given combination and <tt>pred:is-literal-anyURI ... pred:is-literal-XMLLiteral</tt> are the positive guard predicates defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p>
<table border="1">
<tr valign="top">
  <td><em>R<sup>RDF</sup></em></td><td>=</td><td>merge ((<em>R<sup>Simple</sup>)</em> union <br />
<p>((<tt></tt>tr(<tt>s p o .</tt>)) for every RDF finite-axiomatic triple <tt>s p o .</tt>) union<br />
((<tt>ex:illxml(</tt>tr(<tt>"s"^^rdf:XMLLiteral</tt>)<tt>)</tt>) for every  non-<a href="#def-well-typed-literal" title="">well-typed literal</a> of the form (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) in <i>V<sub>TL</sub></i>) union<br />
((<tt>ex:wellxml(</tt>tr(<tt>"s"^^rdf:XMLLiteral</tt>)<tt>)</tt>) for every  <a href="#def-well-typed-literal" title="">well-typed literal</a> of the form (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) in <i>V<sub>TL</sub></i>) union<br />(<br />
&nbsp;<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdf:Property]&nbsp;:- Exists&nbsp;?y&nbsp;?z (?y[?x -&gt;&nbsp;?z]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdf:XMLLiteral]&nbsp;:- ex:wellxml(?x))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (rif:error&nbsp;:- And(?x[rdf:type -&gt; rdf:XMLLiteral] ex:illxml(?x)))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (rif:error&nbsp;:- And(ex:illxml(?x) Or(pred:is-literal-anyURI(?x) ... pred:is-literal-XMLLiteral(?x))))</tt><br />)
</p>
</td></tr>
</table>
<p>Here, inconsistencies may occur if non-well-typed XML literals, axiomatized using the <tt>ex:illxml</tt> predicate, are in the class extension of <tt>rdf:XMLLiteral</tt>.  If this situation occurs, <tt>rif:error</tt> is derived, which signifies an inconsistency in the combination.
</p><p><b>Theorem</b> An RIF-RDF-satisfiable list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt;<i>R</i>,{<i>S<sub>1</sub>,...,S<sub>n</sub></i>}&gt; <a href="#def-rdf-entails" title="">RIF-RDF-entails</a> a <a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a> <i>T</i> iff merge({<i>R<sup>RDF</sup></i>, <i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> tr<sub>Q</sub>(<i>T</i>).
C <a href="#def-rdf-entails" title="">RIF-RDF-entails</a> a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a> &phi; iff merge({<i>R<sup>RDF</sup></i>, <i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> &phi;.
</p>
<blockquote> <span id="proof-rdf-entailment"><b>Proof.</b></span>
In the proof we abbreviate merge({<i>R<sup>RDF</sup></i>, <i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) with R'.
<br />
The proof is obtained from the <a href="#proof-simple-entailment" title="">proof of correspondence for Simple entailment</a> in the previous section with the following modifications: (*) in the (=&gt;) direction we additionally need to ensure that <i><b>I</b></i> does not satisfy <tt>rif:error</tt>, extend I to ensure it satisfies the RDF axiomatic triples and show that I is an RDF-interpretation, and (**) in the (&lt;=) direction we need to slightly extend the definition of <i><b>I'</b></i> to account for <tt>ex:wellxml</tt> and <tt>ex:illxml</tt>, and show that <i><b>I'</b></i> is a model of <i>R<sup>RDF</sup></i>.
<br />
<br />
(*) We assume that, for every non-well-typed literal of the form (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) in <i>V<sub>TL</sub></i>, <i><b>I</b></i><sub>C</sub>(tr(<tt>"s"^^rdf:XMLLiteral</tt>)) is not in the value space of any of the considered datatypes and tr(<tt>"s"^^rdf:XMLLiteral</tt>)<tt>[rdf:type -&gt; rdf:XMLLiteral]</tt> is not satisfied in <i><b>I</b></i>. Since C is RIF-RDF-satisfiable, one can verify that this does not compromise satisfaction of R'. Finally, we may assume, without loss of generality, that <i><b>I</b></i> does not satisfy <tt>rif:error</tt>. See also the proof of the following theorem.
<br />
<br />
For any positive integer <tt><i>j</i></tt> such that <tt>rdf:_<i>j</i></tt> does not occur in the context of C, I and <i><b>I</b></i> are extended such that IS(<tt>rdf:_<i>j</i></tt>)=<i><b>I</b></i><sub>C</sub>(<tt>rdf:_<i>j</i></tt>)=<i><b>I</b></i><sub>C</sub>(<tt>rdf:_<i>m</i></tt>) (see the definition of finite-axiomatic triples above for the definition of <tt><i>m</i></tt>).  Clearly, this does not affect satisfaction of R' or non-satisfaction of &phi; and tr<sub>Q</sub>(<i>T</i>).
<br />
<br />
To show that I is an RDF-interpretation, we need to show that I satisfies the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDF_axiomatic_triples">RDF axiomatic triples</a> and the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1">RDF semantic conditions</a>.
<br />
Satisfaction of the axiomatic triples follows immediately from the inclusion of tr(<tt>t</tt>) in <i>R<sup>RDF</sup></i> for every RDF finite-axiomatic triple <tt>t</tt>, the fact that <i><b>I</b></i> is a model of <i>R<sup>RDF</sup></i>, and construction of I. Consider the three <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfsemcond1">RDF semantic conditions</a>:
<br />

<table border="1" summary="RDF semantic conditions">
    <tr> 
<td>1</td>
      <td>x is 
        in IP if and only if &lt;x, I(<tt>rdf:Property</tt>)&gt; is in IEXT(I(<tt>rdf:type</tt>))</td>
    </tr>
    <tr> 
<td>2</td>
      <td>If <tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt> is in <em>V</em> and xxx is a well-typed XML literal string, then <br />
<p>(a) IL(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>) is the XML <span>value</span> of xxx;<br />
(b) IL(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>) is in LV;<br />
(c) IEXT(I(<tt>rdf:type</tt>)) contains &lt;IL(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>), I(<tt>rdf:XMLLiteral</tt>)&gt;
</p>
      </td>
    </tr>
    <tr> 
<td>3</td>
      <td>If <tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt> is in <em>V</em> and xxx is an ill-typed XML literal string, then<br />
<p>(a) IL(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>) is not in LV;<br />
</p>
(b) IEXT(I(<tt>rdf:type</tt>)) does not contain &lt;IL(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>), I(<tt>rdf:XMLLiteral</tt>)&gt;. </td>
    </tr>
</table>
<p>Satisfaction of condition 1 follows from satisfaction of the first rule in <i>R<sup>RDF</sup></i> in <i><b>I</b></i> and construction of I; specifically, the second bullet in the definition.<br />
Consider a well-typed XML literal <tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>. By the definition of satisfaction in RIF BLD, <i><b>I</b></i><sub>C</sub>(<tt>"</tt>xxx<tt>"^^rdf:XMLLiteral</tt>)  is the XML value of xxx (condition 2a), and is clearly in LV (condition 2b), by definition of I. Condition 2c is satisfied by satisfaction of the second rule in <i>R<sup>RDF</sup></i> in <i><b>I</b></i>.<br />
Satisfaction of 3a  and 3b follows straightforwardly from our assumptions on <i><b>I</b></i>. This establishes the fact that I is an RDF-interpretation.
<br />
<br />
(**) Recall that, by assumption, <tt>ex:wellxml</tt> and <tt>ex:illxml</tt> are not used in <i>R</i>. Therefore, changing satisfaction of atomic formulas involving <tt>ex:wellxml</tt> and <tt>ex:illxml</tt> does not affect satisfaction of <i>R</i>. We assume that <i><b>I'</b></i><sub>C</sub>(<tt>ex:wellxml</tt>)=<tt>k</tt> and <i><b>I'</b></i><sub>C</sub>(<tt>ex:illxml</tt>)=<tt>l</tt> are distinct unique elements, i.e., no other constants is mapped to <tt>k</tt> and <tt>l</tt>.<br />
We define <i><b>I'</b></i><sub>F</sub>(<tt>k</tt>) and <i><b>I'</b></i><sub>F</sub>(<tt>l</tt>) as follows: 
For every typed literal of the form (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) such that <i><b>I'</b></i><sub>C</sub>(tr(<tt>s^^rdf:XMLLiteral</tt>))=<tt>u</tt>, if (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) is well-typed,  <i><b>I</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>k</tt>)(<tt>u</tt>))=<b>t</b> and <i><b>I</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>l</tt>)(<tt>u</tt>))=<b>f</b>, otherwise <i><b>I</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>k</tt>)(<tt>u</tt>))=<b>f</b> and  <i><b>I</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>l</tt>)(<tt>u</tt>))=<b>t</b>; <i><b>I'</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>k</tt>)(v))=<i><b>I</b></i><sub>truth</sub>(<i><b>I'</b></i><sub>F</sub>(<tt>l</tt>)(<tt>v</tt>))=<b>f</b> for every other object <tt>v</tt> in <i><b>D</b></i><sub>ind</sub>.
</p><p>Consider <i>R<sup>RDF</sup></i>.  Satisfaction of <i>R<sup>Simple</sup></i> was established in the proof in the previous section.  Satisfaction of the facts corresponding to the RDF axiomatic triples in <i><b>I'</b></i> follows immediately from the definition of <a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a> and the fact that I is an RDF-interpretation, and thus satisfies all RDF axiomatic triples. <br />
Satisfaction of the <tt>ex:wellxml</tt> and <tt>ex:illxml</tt> facts in <i>R<sup>RDF</sup></i> follows immediately from the definition of <i><b>I'</b></i>.  Finally, satisfaction of the rules in  <i>R<sup>RDF</sup></i> follow straightforwardly from the RDF semantic conditions 1, 2, and 3. This establishes the fact that <i><b>I'</b></i> is a model of <i>R<sup>RDF</sup></i>. &nbsp;&nbsp;☐
</p>
</blockquote>
<p><br />
<b>Theorem</b> A list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> &lt;<i>R</i>,{<i>S<sub>1</sub>,...,S<sub>n</sub></i>}&gt; is <a href="#def-rdf-satisfiable" title="">RIF-RDF-satisfiable</a> iff merge({<i>R<sup>RDF</sup></i>, <i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) does not <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entail</a> <tt>rif:error</tt>.
</p>
<blockquote> <b>Proof.</b> Recall that we assume <tt>rif:error</tt> does not occur in <i>R</i>. If &lt;<i>R</i>,{<i>S<sub>1</sub>,...,S<sub>n</sub></i>}&gt; is not RIF-RDF-satisfiable, then either merge({<i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) is not consistent, or condition 3a or 3b (see previous proof) is violated. In either case, <tt>rif:error</tt> is entailed.

If <tt>rif:error</tt> is entailed, either merge({<i>R<sup>RDF</sup></i>, <i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) is inconsistent, which means merge({<i>R</i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) is not consistent and thus &lt;<i>R</i>,{<i>S<sub>1</sub>,...,S<sub>n</sub></i>}&gt; is not RIF-RDF-satisfiable, or the body of the second or third rule in <i>R<sup>RDF</sup></i> is satisfied in every model, which means either condition 3a or 3b is violated, and so &lt;<i>R</i>,{<i>S<sub>1</sub>,...,S<sub>n</sub></i>}&gt; is not RIF-RDF-satisfiable. &nbsp;&nbsp;☐
</blockquote>
<a id="Embedding_RDFS_Entailment" name="Embedding_RDFS_Entailment"></a><h4> <span class="mw-headline">9.1.5  Embedding RDFS Entailment </span></h4>
<p>We axiomatize the semantics of the RDF(S) Vocabulary using the following RIF rules.
</p><p>Similar to the RDF case, the set of <i>RDFS finite-axiomatic triples</i> is the smallest set such that:
</p>
<ul><li> every <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples">RDFS axiomatic triple</a> not of the form <tt>rdf:_<i>i</i> ... ...</tt>, where <tt><i>i</i></tt> is a positive integer, is an RDFS finite-axiomatic triple,
</li><li> the triples <tt>rdf:_<i>m</i> rdf:type rdfs:ContainerMembershipProperty</tt>, <tt>rdf:_<i>m</i> rdfs:domain rdfs:Resource</tt>, and <tt>rdf:_<i>m</i> rdfs:range rdfs:Resource</tt>, for some positive integer <tt><i>m</i></tt> such that <tt>rdf:_<i>m</i></tt> does not occur in the context of C, are RDFS finite-axiomatic triples, and
</li><li> if <tt>rdf:_<i>j</i></tt> occurs in the context of the combination C, for some positive integer <tt><i>j</i></tt>, then <tt>rdf:_<i>j</i> rdf:type rdfs:ContainerMembershipProperty</tt>, <tt>rdf:_<i>j</i> rdfs:domain rdfs:Resource</tt>, and <tt>rdf:_<i>j</i> rdfs:range rdfs:Resource</tt> are RDFS finite-axiomatic triples.
</li></ul>
<p>We assume that the unary predicate symbol <tt>ex:welllit</tt> is not used in the context of the given combination.
</p>
<table border="1">
<tr valign="top">
  <td><em>R<sup>RDFS</sup></em></td><td>=</td><td>merge((<em>R<sup>RDF</sup></em>) union<br />
<p>((<tt></tt>tr(<tt>s p o .</tt>) for every RDFS finite-axiomatic triple <tt>s p o .</tt>) union<br />
((<tt>ex:welllit("s"^^u)</tt>) for every well-typed literal (<tt>s</tt>,<tt>u</tt>) in <i>V<sub>TL</sub></i>) union<br />
((sk(tr(<tt>s</tt>))<tt>[rdf:type -&gt; rdfs:Resource</tt>) for every name or blank node <tt>s</tt>) union<br />
(<br />
&nbsp;<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdfs:Resource]&nbsp;:- Exists&nbsp;?y&nbsp;?z (?x[?y -&gt;&nbsp;?z]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdfs:Resource]&nbsp;:- Exists&nbsp;?y&nbsp;?z (?z[?y -&gt;&nbsp;?x]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?u&nbsp;?v&nbsp;?x&nbsp;?y (?u[rdf:type -&gt;&nbsp;?y]&nbsp;:- And(?x[rdfs:domain -&gt;&nbsp;?y]&nbsp;?u[?x -&gt;&nbsp;?v]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?u&nbsp;?v&nbsp;?x&nbsp;?y (?v[rdf:type -&gt;&nbsp;?y]&nbsp;:- And(?x[rdfs:range -&gt;&nbsp;?y]&nbsp;?u[?x -&gt;&nbsp;?v]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdfs:subPropertyOf -&gt;&nbsp;?x]&nbsp;:-&nbsp;?x[rdf:type -&gt; rdf:Property])</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z (?x[rdfs:subPropertyOf -&gt;&nbsp;?z]&nbsp;:- And (?x[rdfs:subPropertyOf -&gt;&nbsp;?y]&nbsp;?y[rdfs:subPropertyOf -&gt;&nbsp;?z]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z1&nbsp;?z2 (?z1[?y -&gt;&nbsp;?z2]&nbsp;:- And (?x[rdfs:subPropertyOf -&gt;&nbsp;?y]&nbsp;?z1[?x -&gt;&nbsp;?z2]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdfs:subClassOf -&gt; rdfs:Resource]&nbsp;:-&nbsp;?x[rdf:type -&gt; rdfs:Class])</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z (?z[rdf:type -&gt;&nbsp;?y]&nbsp;:- And (?x[rdfs:subClassOf -&gt;&nbsp;?y]&nbsp;?z[rdf:type -&gt;&nbsp;?x]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdfs:subClassOf -&gt;&nbsp;?x]&nbsp;:-&nbsp;?x[rdf:type -&gt; rdfs:Class])</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z (?x[rdfs:subClassOf -&gt;&nbsp;?z]&nbsp;:- And (?x[rdfs:subClassOf -&gt;&nbsp;?y]&nbsp;?y[rdfs:subClassOf -&gt;&nbsp;?z]))</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdfs:subPropertyOf -&gt; rdfs:member]&nbsp;:-&nbsp;?x[rdf:type -&gt; rdfs:ContainerMembershipProperty])</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdfs:subClassOf -&gt; rdfs:Literal]&nbsp;:-&nbsp;?x[rdf:type -&gt; rdfs:Datatype])</tt>,<br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (rif:error&nbsp;:- And(?x[rdf:type -&gt; rdfs:Literal] ex:illxml(?x)))</tt><br />
</p><p>&nbsp;<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdfs:Literal]&nbsp;:- ex:welllit(?x))</tt><br />
</p>
)</td></tr>
</table>
<p>In the following theorems it is assumed that, in combinations C=&lt;<i>R</i>,{<i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>}&gt;, <i>R</i> does not have mentions of <tt>rdfs:Resource</tt>, <i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i> do not have mentions of <tt>rdfs:Resource</tt> beyond triples of the form <tt>xxx rdf:type rdfs:Resource</tt>, and entailed graphs <i>T</i> and formulas &phi; do not have mentions of <tt>rdfs:Resource</tt>.
</p><p><b>Theorem</b> A RIF-RDFS-satisfiable list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> C=&lt;<i>R</i>,{<i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>}&gt; <a href="#def-rdfs-entails" title="">RIF-RDFS-entails</a> a <a href="#def-generalized-rdf-graph" title="">generalized RDF graph</a> <i>T</i> if and only if merge({<i>R</i>, <i>R<sup>RDFS</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> tr<sub>Q</sub>(<i>T</i>);
C <a href="#def-rdfs-entails" title="">RIF-RDFS-entails</a> a <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-condition" title="BLD">condition formula</a> &phi; if and only if merge({<i>R</i>, <i>R<sup>RDFS</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> &phi;.
</p>
<blockquote> <span id="proof-rdfs-entailment"><b>Proof.</b></span>

In the proof we abbreviate merge({<i>R</i>, <i>R<sup>RDFS</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) with R'.

<br />

The proof is then obtained from the <a href="#proof-rdf-entailment" title="">proof of correspondence for RDF entailment</a> in the previous section with the following modifications: (*) in the (=&gt;) direction we need to slightly amend the definition of I to account for <tt>rdfs:Literal</tt> and <tt>rdfs:Resource</tt>, and show that I is an RDFS-interpretation and (**) in the (&lt;=) direction we need to show that <i><b>I'</b></i> is a model of <i>R<sup>RDFS</sup></i>.

<br />

<br />

(*) In addition to the earlier assumptions about <i><b>I</b></i>, we assume that tr(<tt>"s"^^rdf:XMLLiteral</tt>)<tt>[rdf:type -&gt; rdfs:Literal]</tt> is not satisfied in <i><b>I</b></i>, for any typed literal of the form (<tt>s</tt>, <tt>rdf:XMLLiteral</tt>) in <i>V<sub>TL</sub></i>.



We amend the definition of I by changing the definitions of LV and IEXT to the following:

<ul><li> LV is (union of the value spaces of all considered datatypes) union (set of all <tt>k</tt> in <i><b>D</b></i><sub>ind</sub> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C</sub>(<tt>rdfs:Literal</tt>)))=<b>t</b>). 
</li></ul>

Clearly, this change does not affect satisfaction of the RDF axiomatic triples and the semantic conditions 1 and 2. To see that condition 3 is still satisfied, consider some non-well-typed XML literal <tt>t</tt>.  By assumption, tr(<tt>t</tt>)<tt>[rdf:type -&gt; rdfs:Literal]</tt> is not satisfied and thus IL(<tt>t</tt>) is not in ICEXT(<tt>rdfs:Literal</tt>).  And, since IL(<tt>t</tt>) is not in the value space of any considered datatype, it is not in LV.

<ul><li> For every <tt>k</tt>, <tt>a</tt>, and <tt>b</tt> &isin; <i><b>D</b></i><sub>ind</sub> such that <tt>k</tt>&ne;<i><b>I</b></i><sub>C</sub>(<tt>rdf:type</tt>) or <tt>b</tt>&ne;<i><b>I</b></i><sub>C</sub>(<tt>rdfs:Resource</tt>), (<tt>a</tt>, <tt>b</tt>) &isin;  IEXT(<tt>k</tt>) iff <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>a</tt>)(<tt>k</tt>,<tt>b</tt>))=<b>t</b>;
</li><li> for every <tt>a</tt> &isin; <i><b>D</b></i><sub>ind</sub>, (<tt>a</tt>, <i><b>I</b></i><sub>C</sub>(<tt>rdfs:Resource</tt>)) &isin;  IEXT(<i><b>I</b></i><sub>C</sub>(<tt>rdf:type</tt>)).
</li></ul>

Clearly, this change does not affect satisfaction of the RDF axiomatic triples and semantic conditions, nor does it affect satisfaction of the graphs <i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>. It also does not affect satisfaction of the entailed graph or condition, since (by assumption) this does not contain a mention of <tt>rdfs:Resource</tt>.

To show that I is an RDFS-interpretation, we need to show that I satisfies the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#RDFS_axiomatic_triples">RDFS axiomatic triples</a> and the <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfssemcond1" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#rdfssemcond1">RDFS semantic conditions</a>.

<br />

Satisfaction of the axiomatic triples follows immediately from the inclusion of tr(<tt>t</tt>) in <i>R<sup>RDFS</sup></i> for every RDFS finite-axiomatic triple <tt>t</tt>, the fact that <i><b>I</b></i> is a model of <i>R<sup>RDFS</sup></i>, construction of I, and the extension of I in the <a href="#proof-rdf-entailment" title="SWC">proof of the RDF entailment embedding</a>. Consider the RDFS semantic conditions:

<br />



  <table border="1" summary="RDFS semantic conditions">

    <tr><td>1</td>
    <td>(a) x is in ICEXT(y) if and only if &lt;x,y&gt; is in IEXT(I(<tt>rdf:type</tt>))<br />(b) IC = ICEXT(I(<tt>rdfs:Class</tt>))<br />(c) IR = ICEXT(I(<tt>rdfs:Resource</tt>))<br />(d) LV = ICEXT(I(<tt>rdfs:Literal</tt>))</td>
    </tr>

    <tr>  <td>2</td>
    <td>If &lt;x,y&gt; is in IEXT(I(<tt>rdfs:domain</tt>)) and &lt;u,v&gt; is in IEXT(x) then u is in ICEXT(y)</td>
    </tr>

    <tr> <td>3</td>
    <td>If &lt;x,y&gt; is in IEXT(I(<tt>rdfs:range</tt>)) and &lt;u,v&gt; is in IEXT(x) then v is in ICEXT(y)</td>
    </tr>

    <tr>   <td>4</td>
    <td>IEXT(I(<tt>rdfs:subPropertyOf</tt>)) is transitive and reflexive on IP</td>
    </tr>

    <tr>  <td>5</td>
    <td>If &lt;x,y&gt; is in IEXT(I(<tt>rdfs:subPropertyOf</tt>)) then x and y are in IP and IEXT(x) is a subset of IEXT(y)
</td>

    </tr>

    <tr> <td>6</td>
    <td>If x is in IC then &lt;x, I(<tt>rdfs:Resource</tt>)&gt; is in IEXT(I(<tt>rdfs:subClassOf</tt>))</td>
    </tr>

    <tr> <td>7</td>
    <td>If &lt;x,y&gt; is in IEXT(I(<tt>rdfs:subClassOf</tt>)) then x and y are in IC and ICEXT(x) is a subset of ICEXT(y)</td>
    </tr>

    <tr> <td>8</td>
    <td>IEXT(I(<tt>rdfs:subClassOf</tt>)) is transitive and reflexive on IC</td>
    </tr>

    <tr> <td>9</td>
      <td>If x is in ICEXT(I(<tt>rdfs:ContainerMembershipProperty</tt>)) then:<br />
&lt; x, I(<tt>rdfs:member</tt>)&gt; is in IEXT(I(<tt>rdfs:subPropertyOf</tt>))</td>

    </tr>

    <tr> <td>10</td>
    <td>If x is in ICEXT(I(<tt>rdfs:Datatype</tt>)) then <span>&lt;x, I(<tt>rdfs:Literal</tt>)&gt; is in IEXT(I(<tt>rdfs:subClassOf</tt>))</span></td>
    </tr>

  </table>
<p>Conditions 1a and 1b are simply definitions of ICEXT and IC, respectively.  By definition it is the case that every element <tt>k</tt> in <i><b>D</b></i><sub>ind</sub> is in ICEXT(I(<tt>rdfs:Resource</tt>)).  Since IR=<i><b>D</b></i><sub>ind</sub>, it follows that IR = ICEXT(I(<tt>rdfs:Resource</tt>)), establishing 1c. Clearly, every object in ICEXT(I(<tt>rdfs:Literal</tt>)) is in LV, by definition. Consider any value <tt>k</tt> in LV. By definition, either <tt>k</tt> is in the value space of some considered datatype or <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C</sub>(<tt>rdfs:Literal</tt>)))=<b>t</b>.  In the latter case, clearly <tt>k</tt> is in ICEXT(I(<tt>rdfs:Literal</tt>)).  In the former case, <tt>k</tt> is in the value space of some datatype with some label <i>D</i>, and thus <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<i><b>I</b></i><sub>C</sub>(<tt>pred:is<i>D</i></tt>))(<tt>k</tt>))=<b>t</b>.  By the last rule in <i>R<sup>RDFS</sup></i>, it must consequently be the case that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C</sub>(<tt>rdfs:Literal</tt>)))=<b>t</b>, and thus <tt>k</tt> is in ICEXT(I(<tt>rdfs:Literal</tt>)).  This establishes satisfaction of condition 1d in I.
</p><p><br />
</p><p>Satisfaction in I of conditions 2 through 10 follows immediately from satisfaction in <i><b>I</b></i> of the 2nd through the 12th rule in the definition of  <i>R<sup>RDFS</sup></i>.
</p><p>This establishes the fact that I is an RDFS-interpretation.
</p><p><br />
</p><p><br />
</p><p>(**) Consider <i>R<sup>RDFS</sup></i>.  Satisfaction of <i>R<sup>RDF</sup></i> was established in the <a href="#proof-rdf-entailment" title="SWC">proof</a> in the previous section.  Satisfaction of the facts corresponding to the RDFS axiomatic triples in <i><b>I'</b></i> follows immediately from the definition of <a href="#def-common-rif-rdf-interpretation" title="">common-RIF-RDF-interpretation</a> and the fact that I is an RDFS-interpretation, and thus satisfies all RDFS axiomatic triples. <br />
</p><p>Satisfaction of the 1st through the 12th rule in  <i>R<sup>RDFS</sup></i> follow straightforwardly from the RDFS semantic conditions 1 through 10. Satisfaction of the 13th rule follows from the fact that, given an ill-typed XML literal <tt>t</tt>, IL(<tt>t</tt>)  is not in LV (by RDF semantic condition 3), ICEXT(<tt>rdfs:Literal</tt>)=LV, and the fact that the <tt>ex:illxml</tt> predicate is only true for ill-typed XML literals.  Finally, satisfaction of the last rule in <i>R<sup>RDFS</sup></i> follows from the fact that ICEXT(<tt>rdfs:Literal</tt>)=LV, the definition of LV as a superset of the union of the value spaces of all datatypes, and the definition of the <tt>pred:is<i>D</i></tt> predicates. This establishes the fact that <i><b>I'</b></i> is a model of <i>R<sup>RDFS</sup></i>. &nbsp;&nbsp;☐
</p>
</blockquote>
<p><br />
<b>Theorem</b> A list-free <a href="#def-rif-rdf-combination" title="">RIF-RDF combination</a> &lt;<i>R</i>,{<i>S<sub>1</sub></i>,...,<i>S<sub>n</sub></i>}&gt; is <a href="#def-rdfs-satisfiable" title="">RIF-RDFS-satisfiable</a>  if and only if merge({<i>R</i>, <i>R<sup>RDFS</sup></i>, tr<sub>R</sub>(<i>S<sub>1</sub></i>), ..., tr<sub>R</sub>(<i>S<sub>n</sub></i>)}) does not entail <tt>rif:error</tt>.
</p>
<blockquote> <b>Proof.</b> The theorem follows immediately from the previous theorem and the observations in the proof of the second theorem in the previous section. &nbsp;&nbsp;☐
</blockquote>
<a id="Embedding_RIF-OWL_2_RL_Combinations" name="Embedding_RIF-OWL_2_RL_Combinations"></a><h3> <span class="mw-headline">9.2  Embedding RIF-OWL 2 RL Combinations </span></h3>
<p>It is known that expressive Description Logic languages such as OWL 2 DL cannot be straightforwardly embedded into typical rules languages such as RIF BLD [<a href="#ref-rif-bld" title="">RIF-BLD</a>], because of features such as disjunction and negation.
</p><p>In this section we consider a subset of OWL 2 DL in RIF-OWL DL combinations, namely, the OWL 2 RL profile [<a href="#ref-owl2-profiles" title="">OWL2-Profiles</a>], and show how reasoning with RIF-OWL 2 RL combinations can be reduced to reasoning with RIF.
</p><p>The embedding of RIF-OWL 2 RL combinations is not defined for combinations that include infinite OWL ontologies.
</p><p>Since OWL 2 RL includes equality through <tt>ObjectMaxCardinality</tt> and <tt>DataMaxCardinality</tt> restrictions, as well as <tt>FunctionalObjectProperty</tt> <tt>UniverseFunctionalObjectProperty</tt>, <tt>SameIndividual</tt>, and <tt>HasKey</tt> axioms, and there is non-trivial interaction between such equality and the predicates in the RIF rules in the combination, embedding RIF-OWL 2 RL combinations into RIF requires equality.  Therefore, the embedding presented in this appendix is not in RIF Core, even if the RIF document in the combination is. If the ontologies in the combination do not contain any of the mentioned constructs, the embedding is in Core. Also, it is well-known that adding equality to a rules language does not increase its expressiveness in the absence of function symbols: one can replace equality <tt>=</tt> with a new binary predicate symbol, and add rules for reflexivity and the principle of substitutivity (also called the replacement property).
</p>
<a id="Embedding_RIF_DL-document_formulas_into_RIF_BLD" name="Embedding_RIF_DL-document_formulas_into_RIF_BLD"></a><h4> <span class="mw-headline">9.2.1  Embedding RIF DL-document formulas into RIF BLD </span></h4>
<p>Recall that the semantics of frame formulas in <a href="#def-dl-document" title="">DL-document formulas</a> is different from the semantics of frame formulas in RIF documents.
Nonetheless,  DL-document formulas can be embedded  into  RIF documents, by translating frame formulas to predicate formulas.
The mapping tr is the identity mapping on all RIF formulas, with the exception of frame formulas, as defined in the following table.  
</p><p>In the table, the mapping tr' is
an injective function that maps constants to new constants, i.e., constants that are not used in the original document or its vicinity (i.e., imported, entailed or  entailing formula).  It "generates" a new constant from an existing one. 
</p>
<table border="1" id="tab-rif-dl-rif-mapping">
<caption>Mapping RIF DL-document formulas to RIF documents.</caption>
<tr>
  <th>RIF Construct</th>
  <th>Mapping</th>
</tr>
<tr>
  <td>Term <tt>t</tt></td>
  <td>tr(<tt>t</tt>)=<tt>t</tt></td>
</tr>
<tr>
  <td>Atomic formula &phi; that is not a frame formula</td>
  <td>tr(&phi;)=&phi;</td>
</tr>
<tr>
  <td><tt>a[b<sub>1</sub>-&gt;c<sub>1</sub> ... b<sub>n</sub>-&gt;c<sub>n</sub>]</tt>, with <tt>n</tt>&ge;2</td>
  <td>tr(<tt>a[b<sub>1</sub>-&gt;c<sub>1</sub> ... b<sub>n</sub>-&gt;c<sub>n</sub>]</tt>)=<tt>And(</tt> tr(<tt>a[b<sub>1</sub>-&gt;c<sub>1</sub>]</tt>) ... tr(<tt>a[b<sub>n</sub>-&gt;c<sub>n</sub>]</tt>)<tt>)</tt></td>
</tr>
<tr>
  <td><tt>a[b -&gt; c]</tt>, where <tt>a</tt> and <tt>c</tt> are terms and <tt>b</tt> &ne; <tt>rdf:type</tt> is a constant</td>
  <td>tr(<tt>a[b -&gt; c]</tt>)=tr'(<tt>b</tt>)<tt>(a c)</tt></td>
</tr>
<tr>
  <td><tt>a[rdf:type -&gt; c]</tt>, where <tt>a</tt> is a term and <tt>c</tt> is a constant</td>
  <td>tr(<tt>a[rdf:type -&gt; c]</tt>)=tr'(<tt>c</tt>)<tt>(a)</tt></td>
</tr>
<tr>
  <td><tt>a#c</tt>, where <tt>a</tt> is a term and <tt>c</tt> is a constant</td>
  <td>tr(<tt>a#c</tt>)=tr'(<tt>c</tt>)<tt>(a)</tt></td>
</tr>
<tr>
  <td><tt>b##c</tt>, where <tt>a,b</tt> are constants</td>
  <td>tr(<tt>b##c</tt>) = <tt>Forall&nbsp;?x (</tt>tr'(<tt>c</tt>)<tt>(?x)&nbsp;:- </tt>tr'(<tt>b</tt>)<tt>(?x))</tt></td>
</tr>
<tr>
  <td><tt>Exists&nbsp;?V1 ...&nbsp;?Vn(&phi;)</tt></td>
  <td>tr(<tt>Exists&nbsp;?V1 ...&nbsp;?Vn(&phi;)</tt>)=<tt>Exists&nbsp;?V1 ...&nbsp;?Vn(</tt>tr<tt>(&phi;))</tt></td>
</tr>
<tr>
  <td><tt>And(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt></td>
  <td>tr(<tt>And(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>)=<tt>And(</tt>tr<tt>(&phi;<sub>1</sub>) ... </tt>tr<tt>(&phi;<sub>n</sub>))</tt></td>
</tr>
<tr>
  <td><tt>Or(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt></td>
  <td>tr(<tt>Or(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>)=<tt>Or(</tt>tr<tt>(&phi;<sub>1</sub>) ... </tt>tr<tt>(&phi;<sub>n</sub>))</tt></td>
</tr>
<tr>
  <td><tt>&phi;<sub>1</sub>&nbsp;:- &phi;<sub>2</sub></tt></td>
  <td>tr(<tt>&phi;<sub>1</sub>&nbsp;:- &phi;<sub>2</sub></tt>)=<tt></tt>tr<tt>(&phi;<sub>1</sub>)&nbsp;:- </tt>tr<tt>(&phi;<sub>2</sub></tt>)</td>
</tr>
<tr>
  <td><tt>Forall&nbsp;?V1 ...&nbsp;?Vn(&phi;)</tt></td>
  <td>tr(<tt>Forall&nbsp;?V1 ...&nbsp;?Vn(&phi;)</tt>)=<tt>Forall&nbsp;?V1 ...&nbsp;?Vn(</tt>tr<tt>(&phi;))</tt></td>
</tr>
<tr>
  <td><tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt></td>
  <td>tr(<tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>)=<tt>Group(</tt>tr<tt>(&phi;<sub>1</sub>) ... </tt>tr<tt>(&phi;<sub>n</sub>))</tt></td>
</tr>
<tr>
  <td><tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> &Gamma;)</tt></td>
  <td>tr(<tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> &Gamma;)</tt>)=<tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> </tt>tr<tt>(&Gamma;))</tt></td>
</tr>
</table>
<p>For the purpose of making statements about this embedding, we define a notion of entailment for DL-document formulas.
</p><p><b>Definition.</b> A <a href="#def-dl-document" title="">RIF-BLD DL-document formula</a> <i>R</i> <span id="def-dl-entails"><i><b>dl-entails</b></i></span> a <a href="#def-dl-condition" title="">DL-condition</a> &phi; if for every dl-semantic multi-structure <i><b>&Icirc;</b></i> that is a <a href="#def-dl-model" title="">model</a> of <i>R</i> it holds that <i>TVal</i><sub>&Icirc;</sub>(&phi;)=<b>t</b>. &nbsp;&nbsp;☐
</p><p>The following lemma establishes faithfulness with respect to entailment of the embedding.
</p><p><span id="lem-dl-document"><b>RIF-BLD DL-document formula Lemma</b></span> A <a href="#def-dl-document" title="">RIF-BLD DL-document formula</a> <i>R</i> <a href="#def-dl-entails" title="">dl-entails</a> a <a href="#def-dl-condition" title="">DL-condition</a> &phi; if and only if tr(<i>R</i>) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> tr(&phi;).
</p>
<blockquote>
<span id="proof-lem-dl-document"><b>Proof.</b></span> We prove both directions by contraposition. 
<br />
<br />
(=&gt;) Assume tr(<i>R</i>) does not entail tr(&phi;).  This means there is some semantic multi-structure <i><b>&Icirc;</b></i> that is a model of tr(R'), but <i><b>I</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, 
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt; is not a model of tr(&phi;).
<br />
Consider the dl-semantic multi-structure <i><b>&Icirc;*</b></i>, which is obtained from <i><b>&Icirc;</b></i> as follows: <i><b>I*</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I*</b></i><sub>C</sub>, <i><b>I*</b></i><sub>C'</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I*</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I*</b></i><sub>sub</sub>, <i><b>I*</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt;, with <i><b>I*</b></i><sub>C'</sub>, <i><b>I*</b></i><sub>frame</sub>, <i><b>I*</b></i><sub>sub</sub>, and <i><b>I*</b></i><sub>isa</sub> defined as follows:  Let <tt>t</tt> be an element in <i><b>D</b></i> such that <i><b>I</b></i><sub>truth</sub>(<tt>t</tt>)=<b>t</b>  and let <tt>f</tt> in <i><b>D</b></i> be such that <i><b>I</b></i><sub>truth</sub>(<tt>f</tt>)=<b>f</b>.
<ul><li> for every constant <tt>c</tt>, with <tt>c'</tt>=tr'(<tt>c</tt>), <i><b>I*</b></i><sub>C'</sub>(<tt>c</tt>)=<i><b>I</b></i><sub>C</sub>(<tt>c'</tt>);
</li><li> for every constant <tt>c'</tt> used as unary predicate symbol in tr(<i>R</i>) or tr(&phi;) such that <tt>c'</tt>=tr'(<tt>c</tt>) for some constant <tt>c</tt>, and every object <tt>k</tt> in <i><b>D</b></i><sub>ind</sub>, <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<i><b>I</b></i><sub>C</sub>(<tt>c'</tt>))(<tt>k</tt>))=<b>t</b> iff <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)((<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>), <i><b>I</b></i><sub>C'</sub>(<tt>c</tt>))=<tt>t</tt>;
</li><li> for every constant <tt>b'</tt> used as binary predicate symbol in tr(<i>R</i>) or tr(&phi;) such that <tt>b'</tt>=tr'(<tt>b</tt>) for some constant <tt>b</tt>, and every pair (<tt>k, l</tt>) in <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>, <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<i><b>I</b></i><sub>C</sub>(<tt>b'</tt>))(<tt>k</tt>,<tt>l</tt>))=<b>t</b> iff <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)((<i><b>I</b></i><sub>C'</sub>(<tt>b</tt>),<tt>l</tt>))=<tt>t</tt>, 
</li><li> if <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)((<i>b<sub>1</sub></i>,...,<i>b<sub>n</sub></i>))=<tt>t</tt> and <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)((<i>c<sub>1</sub></i>,...,<i>c<sub>m</sub></i>))=<tt>t</tt> for any two finite bags (<i>b<sub>1</sub></i>,...,<i>b<sub>n</sub></i>) and (<i>c<sub>1</sub></i>,...,<i>c<sub>m</sub></i>), then <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)((<i>b<sub>1</sub></i>,...,<i>b<sub>n</sub></i>,<i>c<sub>1</sub></i>,...,<i>c<sub>m</sub></i>))=<tt>t</tt>;
</li><li> <i><b>I*</b></i><sub>frame</sub>(b)=<tt>f</tt> for any other bag b;
</li><li> for any two <tt>k</tt>, <tt>l</tt> &isin; <i><b>D</b></i>, <i><b>I*</b></i><sub>sub</sub>(<tt>k</tt>,<tt>l</tt>)=<tt>t</tt> if for every <tt>u</tt> &isin; <i><b>D</b></i>, <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<tt>k</tt>)(<tt>u</tt>))=<b>t</b> implies <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<tt>l</tt>)(<tt>u</tt>))=<b>t</b>, otherwise <i><b>I*</b></i><sub>sub</sub>(<tt>k</tt>,<tt>l</tt>)=<tt>f</tt>;
</li><li> for any two <tt>k</tt>, <tt>l</tt> &isin; <i><b>D</b></i>, <i><b>I*</b></i><sub>isa</sub>(<tt>k</tt>,<tt>l</tt>)=<tt>t</tt> if <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<tt>k</tt>)(<tt>u</tt>))=<b>t</b>, otherwise <i><b>I*</b></i><sub>isa</sub>(<tt>k</tt>,<tt>l</tt>)=<tt>f</tt>.
</li></ul>


Observe that tr(<i>R</i>) and tr(&phi;) do not include frame formulas. 
<br />
To show that <i><b>&Icirc;*</b></i> is a model of <i>R</i> and <i><b>I*</b></i> is not a model of &phi;, we only need to show that (+) for any frame formula <tt>a[b -&gt; c]</tt> that is a DL-condition, <i><b>I*</b></i> is a model of <tt>a[b -&gt; c]</tt> iff <i><b>I</b></i> is a model of tr(<tt>a[b -&gt; c]</tt>). This argument straightforwardly extends to the case of frames with multiple <tt>b<sub>i</sub></tt>s and <tt>c<sub>i</sub></tt>s, since in RIF semantic structures the following condition is required to hold: <i>TVal</i><sub>I</sub>(<tt>a[b<sub>1</sub>-&gt;c<sub>1</sub> ... b<sub>n</sub>-&gt;c<sub>n</sub>]</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(<tt>a[b<sub>1</sub>-&gt;c<sub>1</sub>]</tt>) = ... = <i>TVal</i><sub>I</sub>(<tt>a[b<sub>n</sub>-&gt;c<sub>n</sub>]</tt>) = <b>t</b> [<a href="#ref-rif-bld" title="">RIF-BLD</a>]. The argument for formulas <tt>a # b</tt> and <tt>a ## b</tt> is analogous.
<br />
<br />
Consider the case <tt>b</tt>=<tt>rdf:type</tt>.  Then,
<br />
<i><b>I*</b></i> is a model of <tt>a[b -&gt; c]</tt> iff <i><b>I</b></i><sub>truth</sub>(<i><b>I*</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>a</tt>))(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>)))=<b>t</b>.
<br />
From the definition of <i><b>I*</b></i> we obtain
<br /> 
<i><b>I</b></i><sub>truth</sub>(<i><b>I*</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>a</tt>))(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>)))=<b>t</b> iff <i><b>I*</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>a</tt>))(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>))=<tt>t</tt>.
<br />
By definition of the embedding, we know that tr'(<tt>c</tt>) is used as unary predicate symbol in tr(<i>R</i>) or tr(&phi;).  From the definition of <i><b>I*</b></i> we obtain
<br />
<i><b>I*</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>a</tt>))(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>))=<tt>t</tt> iff <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<i><b>I</b></i><sub>C</sub>(tr'(<tt>c</tt>)))(<i><b>I</b></i>(<tt>a</tt>)))=<b>t</b>.
<br />
Finally, since tr(<tt>a[b -&gt; c]</tt>)=tr'(<tt>c</tt>)<tt>(a)</tt>, we obtain
<br />
<i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>F</sub>(<i><b>I</b></i><sub>C</sub>(tr'(<tt>c</tt>)))(<i><b>I</b></i>(<tt>a</tt>)))=<b>t</b> iff <i><b>I</b></i>  is a model of tr(<tt>a[b -&gt; c]</tt>).
<br />
From this chain of equivalences follows that <i><b>I*</b></i> is a model of <tt>a[b -&gt; c]</tt> iff <i><b>I</b></i> is a model of tr(<tt>a[b -&gt; c]</tt>).
<br />
<br />
The argument for the case <tt>b</tt>&ne;<tt>rdf:type</tt> is analogous, thereby obtaining (+).
<br />
<br />
(&lt;=) Assume <i>R</i> does not dl-entail &phi;.  This means there is some dl-semantic multi-structure <i><b>&Icirc;</b></i> that is a model of <i>R</i>, but <i><b>I</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>C'</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt;, is not a model of &phi;. Let <i><tt>B</tt></i> be the set of constant symbols occurring in the frame formulas of the forms <tt>a[rdf:type -&gt; b]</tt> and <tt>a[b -&gt; c]</tt> in <i>R</i> or &phi;.
<br />
Consider the semantic multi-structure <i><b>&Icirc;*</b></i>, which is obtained from <i><b>&Icirc;</b></i> as follows: <i><b>I*</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I*</b></i><sub>C</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I*</b></i><sub>F</sub>,
<i><b>I*</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt;.  Let <tt>t</tt> and <tt>f</tt> in <i><b>D</b></i> be such that <i><b>I</b></i><sub>truth</sub>(<tt>t</tt>)=<b>t</b> and <i><b>I</b></i><sub>truth</sub>(<tt>f</tt>)=<b>f</b>. We define <i><b>I*</b></i><sub>C</sub>, <i><b>I*</b></i><sub>frame</sub>, and <i><b>I*</b></i><sub>F</sub> as follows:
<ul><li> <i><b>I*</b></i><sub>C</sub>(tr'(<tt>c</tt>))=<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>) and <i><b>I*</b></i><sub>C</sub>(<tt>c</tt>)=<i><b>I</b></i><sub>C</sub>(<tt>c</tt>), for any constant <tt>c</tt> not in the range of tr';
</li><li> <i><b>I*</b></i><sub>frame</sub>(b)=<tt>f</tt> for any finite bag b of <i><b>D</b></i>, and
</li><li> <i><b>I*</b></i><sub>F</sub> is defined as follows:
<ul><li> for every constant <tt>c</tt>, given an object <tt>k</tt> in <i><b>D</b></i><sub>ind</sub>, if <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)((<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>), <i><b>I</b></i><sub>C'</sub>(<tt>c</tt>)))=<b>t</b>, <i><b>I*</b></i><sub>F</sub>(<i><b>I*</b></i><sub>C</sub>(tr'(<tt>c</tt>)))(<tt>k</tt>)=<tt>t</tt>; <i><b>I*</b></i><sub>F</sub>(<i><b>I*</b></i><sub>C</sub>(tr'(<tt>c</tt>)))(<tt>k'</tt>)=<tt>f</tt> for any other <tt>k'</tt> in <i><b>D</b></i><sub>ind</sub>,
</li><li> for every constant <tt>c</tt>, given a pair (<tt>k, l</tt>) in <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>, if <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)((<i><b>I</b></i><sub>C'</sub>(<tt>c</tt>),<tt>l</tt>)))=<b>t</b>, <i><b>I*</b></i><sub>F</sub>(tr'(<tt>c</tt>))(<tt>k</tt>,<tt>l</tt>)=<tt>t</tt>;<i><b>I*</b></i><sub>F</sub>(tr'(<tt>c</tt>))(<tt>k'</tt>,<tt>l'</tt>)=<tt>f</tt> for any other pair (<tt>k', l'</tt>) in <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>, and
</li><li> <i><b>I*</b></i><sub>F</sub>(<tt>c</tt>)=<i><b>I</b></i><sub>F</sub>(<tt>c</tt>) for every other constant <tt>c</tt>.
</li></ul>
</li></ul>

Observe that <i>R</i> and &phi; do not include predicate formulas involving derived constant symbols tr'(<tt>c</tt>). The remainder of the proof is analogous to the (=&gt;) direction.
&nbsp;&nbsp;☐
</blockquote>
<a id="Embedding_OWL_2_RL_into_RIF_BLD" name="Embedding_OWL_2_RL_into_RIF_BLD"></a><h4> <span class="mw-headline">9.2.2  Embedding OWL 2 RL into RIF BLD </span></h4>
<p>The embedding of OWL 2 RL into RIF BLD has two stages: normalization and embedding. 
</p><p>The OWL 2 syntax is given in terms of a Structural Specification, and there is a functional-style syntax that is a serialization of this Structural Specification.  For convenience, normalization and embedding in this section are done in terms of the functional-style syntax. That is, the normalization mapping takes as input a functional-style syntax ontology document and produces a normalized ontology document.  The embedding mapping takes as input a normalized ontology document and produces an RIF document.  We refer to <a class="external text" href="http://www.w3.org/TR/2008/WD-owl2-profiles-20081202/#Profile_Specification_3" rel="nofollow" title="http://www.w3.org/TR/2008/WD-owl2-profiles-20081202/#Profile_Specification_3">Section 4.2</a> of [<a href="#ref-owl2-profiles" title="">OWL2-Profiles</a>] for the specification of the OWL 2 RL syntax.
</p>
<a id="Normalization_of_OWL_2_RL" name="Normalization_of_OWL_2_RL"></a><h5> <span class="mw-headline">9.2.2.1  Normalization of OWL 2 RL </span></h5>
<p>Normalization splits the OWL axioms so that the later mapping to RIF of the individual axioms results in rules. Additionally, it simplifies the axioms and removes annotations.
</p><p>It is assumed that the normalization process is preceded by a simplification process that removes all namespace prefixes, turns all CURIEs and relative IRIs into absolute IRIs, and removes all annotations, import statements, entity declarations, and annotation axioms.
</p><p>We note here that, strictly speaking, simplified OWL 2 RL ontologies are not OWL 2 RL ontologies in the general case, because certain entity declarations are required (e.g., those distinguishing data from object properties).  It is assumed that such entity declarations are present implicitly, i.e., they do not appear explicitly in the simplified ontology, but they are known. 
We also note that removing import statements in the simplification does not prohibit importing ontologies in practice; since combinations contain sets of ontologies, all imported ontologies may be added to these sets.
The normalization mapping tr<sub>N</sub> takes as input a simplified ontology O and produces an equivalent normalized ontology O'.
</p><p>The names of variables used in the mapping generally correspond to the names of productions in the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/#OWL_2_RL_2" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-profiles-20091027/#OWL_2_RL_2">OWL 2 RL grammar</a>.
</p>
<table border="1" id="tab-owl-normalization">
<caption>Normalization of OWL 2 RL ontologies.</caption>
<tr>
  <th>#</th>
  <th>Statement</th>
  <th>Normalized Statement</th>
  <th>Condition on translation</th>
</tr>
<tr>
<td>1</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>&nbsp;Ontology( [ ontologyIRI [ versionIRI ] ] <br />
&nbsp;<span>axiom<sub>1</sub><br />
&nbsp;&nbsp;... <br />
&nbsp;axiom<sub>n</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>Ontology( </tt><br />
tr<sub>N</sub>(<tt>axiom<sub>1</sub></tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>axiom<sub>n</sub></tt>)<br />
<tt>)</tt>
</p>
</td>
</tr>
<tr>
  <td>2</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SubClassOf(subClassExpression <br />
&nbsp;...ObjectIntersectionOf(<br />
&nbsp;&nbsp;<span>superClassExpression<sub>1</sub> <br />
&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;superClassExpression<sub>n</sub></span><br />
&nbsp;)...)</tt>
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(subClassExpression ...superClassExpression<sub>1</sub>...)</tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubClassOf(subClassExpression ...superClassExpression<sub>n</sub>...)</tt>)
</p>
</td>
</tr>
<tr>
  <td>3</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SubClassOf(subClassExpression<sub>1</sub> ObjectComplementOf(<span>subClassExpression<sub>1</sub></span>))</tt>
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(ObjectIntersectionof(subClassExpression<sub>1</sub> subClassExpression<sub>2</sub>) owl:Nothing)</tt>)
</p>
</td>
</tr>
<tr>
  <td>4</td>
  <td>tr<sub>N</sub>(<tt>SubClassOf(subClassExpression <i>X</i>)</tt>)</td>
  <td>
<p><tt>SubClassOf(subClassExpression <i>X</i>)</tt>
</p>
</td>
<td><i>X</i> is a superClassExpression that does not contain <tt>ObjectIntersectionOf</tt> or <tt>ObjectComplementOf</tt></td>
</tr>
<tr>
  <td>5</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>EquivalentClasses(<br />
&nbsp;<span>equivClassExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;equivClassExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(equivClassExpression<sub>1</sub> equivClassExpression<sub>2</sub>)</tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubClassOf(equivClassExpression<sub>m-1</sub> equivClassExpression<sub>m</sub>)</tt>)<br />
tr<sub>N</sub>(<tt>SubClassOf(equivClassExpression<sub>m</sub> equivClassExpression<sub>1</sub>)</tt>)
</p>
</td>
</tr>
<tr>
  <td>6</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DisjointClasses(<br />
&nbsp;<span>subClassExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;subClassExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>tr<sub>N</sub>(<tt>SubClassOf(ObjectIntersectionOf(subClassExpression<sub>1</sub> subClassExpression<sub>2</sub>) owl:Nothing)</tt>)<br />
<p><tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubClassOf(ObjectIntersectionOf(subClassExpression<sub>1</sub> subClassExpression<sub>m</sub>) owl:Nothing)</tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubClassOf(ObjectIntersectionOf(subClassExpression<sub>m-1</sub> subClassExpression<sub>m</sub>) owl:Nothing)</tt>)
</p>
</td>
</tr>
<tr>
  <td>7</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SubObjectPropertyOf(<br />
&nbsp;<span>subPropertyExpression <br />
&nbsp;superPropertyExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>SubObjectPropertyOf(<br />
&nbsp;<span>subPropertyExpression <br />
&nbsp;superPropertyExpression</span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>8</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SubDataPropertyOf(<br />
&nbsp;<span>subPropertyExpression <br />
&nbsp;superPropertyExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>SubDataPropertyOf(<br />
&nbsp;<span>subPropertyExpression <br />
&nbsp;superPropertyExpression</span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>9</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>EquivalentObjectProperties(<br />
&nbsp;<span>ObjectPropertyExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;ObjectPropertyExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubObjectPropertyOf(ObjectPropertyExpression<sub>1</sub> ObjectPropertyExpression<sub>2</sub>)</tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubObjectPropertyOf(ObjectPropertyExpression<sub>m-1</sub> ObjectPropertyExpression<sub>m</sub>)</tt>)<br />
tr<sub>N</sub>(<tt>SubObjectPropertyOf(ObjectPropertyExpression<sub>m</sub> ObjectPropertyExpression<sub>1</sub>)</tt>)
</p>
</td>
</tr>
<tr>
  <td>10</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>EquivalentDataProperties(<br />
&nbsp;<span>DataPropertyExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;DataPropertyExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubDataPropertyOf(PropertyExpression<sub>1</sub> DataPropertyExpression<sub>2</sub>)</tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>N</sub>(<tt>SubDataPropertyOf(PropertyExpression<sub>m-1</sub> DataPropertyExpression<sub>m</sub>)</tt>)<br />
tr<sub>N</sub>(<tt>SubDataPropertyOf(PropertyExpression<sub>m</sub> DataPropertyExpression<sub>1</sub>)</tt>)
</p>
</td>
</tr>
<tr>
  <td>11</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DisjointObjectProperties(<br />
&nbsp;<span>ObjectPropertyExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;ObjectPropertyExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>DisjointObjectProperties(ObjectPropertyExpression<sub>1</sub> ObjectPropertyExpression<sub>2</sub>)</tt><br />
<tt>&nbsp;&nbsp;...</tt><br />
<tt>DisjointObjectProperties(ObjectPropertyExpression<sub>1</sub> ObjectPropertyExpression<sub>m</sub>)</tt><br />
<tt>&nbsp;&nbsp;...</tt><br />
<tt>DisjointObjectProperties(ObjectPropertyExpression<sub>m-1</sub> ObjectPropertyExpression<sub>m</sub>)</tt>
</p>
</td>
</tr>
<tr>
  <td>12</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DisjointDataProperties(<br />
&nbsp;<span>DataPropertyExpression<sub>1</sub><br />
&nbsp;&nbsp;...<br />
&nbsp;DataPropertyExpression<sub>m</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>DisjointDataProperties(DataPropertyExpression<sub>1</sub> DataPropertyExpression<sub>2</sub>)</tt><br />
<tt>&nbsp;&nbsp;...</tt><br />
<tt>DisjointDataProperties(DataPropertyExpression<sub>1</sub> DataPropertyExpression<sub>m</sub>)</tt><br />
<tt>&nbsp;&nbsp;...</tt><br />
<tt>DisjointDataProperties(DataPropertyExpression<sub>m-1</sub> DataPropertyExpression<sub>m</sub>)</tt>
</p>
</td>
</tr>
<tr>
  <td>13</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>InverseObjectProperties(<br />
&nbsp;<span>PropertyExpression<sub>1</sub> <br />
&nbsp;PropertyExpression<sub>2</sub></span> )</tt><br />
</p>
)</td>
  <td>
<p><tt>InverseObjectProperties(<br />
&nbsp;<span>PropertyExpression<sub>1</sub> <br />
&nbsp;PropertyExpression<sub>2</sub></span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>14</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>ObjectPropertyDomain(<br />
&nbsp;<span>PropertyExpression <br />
&nbsp;superClassExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(<br />
&nbsp;<span>ObjectSomeValuesFrom(PropertyExpression owl:Thing) <br />
&nbsp;superClassExpression</span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>15</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DataPropertyDomain(<br />
&nbsp;<span>DataProperty <br />
&nbsp;superClassExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(<br />
&nbsp;<span>ObjectSomeValuesFrom(DataProperty owl:Thing) <br />
&nbsp;superClassExpression</span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>16</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>ObjectPropertyRange(<br />
&nbsp;<span>ObjectInverseOf(Property) <br />
&nbsp;superClassExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(<br />
&nbsp;<span>ObjectSomeValuesFrom(Property owl:Thing) <br />
&nbsp;superClassExpression</span> )</tt>
</p>
</td>
</tr>
<tr>
  <td>17</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>ObjectPropertyRange(<br />
&nbsp;<span>Property <br />
&nbsp;superClassExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(<br />
&nbsp;<span>ObjectSomeValuesFrom(ObjectInverseOf(Property) owl:Thing) <br />
&nbsp;superClassExpression</span> )</tt>
</p>
</td>
<td><tt>Property</tt>  is not an inverse property expression</td>
</tr>
<tr>
  <td>18</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DataPropertyRange(<br />
&nbsp;<span>DataProperty <br />
&nbsp;superClassExpression</span> )</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>N</sub>(<tt>SubClassOf(<br />
&nbsp;<span>owl:Thing <br />
&nbsp;DataAllValuesFrom(DataProperty superClassExpression)</span> )</tt>
</p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
  <td>19</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>FunctionalObjectProperty(<br />
&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>FunctionalObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>20</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>FunctionalDataProperty(</tt><br />
<tt>&nbsp;DataProperty )</tt><br />
</p>
)</td>
  <td>
<p><tt>FunctionalDataProperty(</tt><br />
</p>
<tt>&nbsp;DataProperty )</tt></td>
</tr>
<tr>
  <td>21</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>InverseFunctionalObjectProperty(</tt><br />
<tt>&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>InverseFunctionalObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>22</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>IrreflexiveObjectProperty(</tt><br />
<tt>&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>IrreflexiveObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>23</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SymmetricObjectProperty(</tt><br />
<tt>&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>SymmetricObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>24</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>AsymmetricObjectProperty(</tt><br />
<tt>&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>AsymmetricObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>25</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>TransitiveObjectProperty(</tt><br />
<tt>&nbsp;PropertyExpression )</tt><br />
</p>
)</td>
  <td>
<p><tt>TransitiveObjectProperty(</tt><br />
</p>
<tt>&nbsp;PropertyExpression )</tt></td>
</tr>
<tr>
  <td>26</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DatatypeDefinition(&nbsp;... )</tt><br />
</p>
)</td>
  <td>
<tt>DatatypeDefinition(&nbsp;... )</tt></td>
</tr>
<tr>
  <td>27</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>HasKey(&nbsp;... )</tt><br />
</p>
)</td>
  <td>
<tt>HasKey(&nbsp;... )</tt></td>
</tr>
<tr>
  <td>28</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>SameIndividual(</tt><br />
<tt>&nbsp;Individual<sub>1</sub> </tt><br />
<tt>&nbsp;&nbsp;... </tt><br />
<tt>&nbsp;Individual<sub>m</sub>)</tt><br />
</p>
)</td>
  <td>
<p><tt>SameIndividual(Individual<sub>1</sub> Individual<sub>2</sub>)</tt><br />
<tt>&nbsp;&nbsp;... </tt><br />
<tt>SameIndividual(Individual<sub>m-1</sub> Individual<sub>m</sub>)</tt><br />
</p>
<tt>SameIndividual(Individual<sub>m</sub> Individual<sub>1</sub>)</tt></td>
</tr>
<tr>
  <td>29</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DifferentIndividuals(</tt><br />
<tt>&nbsp;Individual<sub>1</sub> </tt><br />
<tt>&nbsp;&nbsp;... </tt><br />
<tt>&nbsp;Individual<sub>m</sub>)</tt><br />
</p>
)</td>
  <td>
<p><tt>DifferentIndividuals(Individual<sub>1</sub> Individual<sub>2</sub>)</tt><br />
<tt>&nbsp;&nbsp;... </tt><br />
<tt>SameIndividual(Individual<sub>1</sub> Individual<sub>m</sub>)</tt><br />
<tt>&nbsp;&nbsp;... </tt><br />
</p>
<tt>SameIndividual(Individual<sub>m-1</sub> Individual<sub>m</sub>)</tt></td>
</tr>
<tr>
  <td>30</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>ClassAssertion(</tt><br />
<tt>&nbsp;superClassExpression </tt><br />
<tt>&nbsp;Individual)</tt><br />
</p>
)</td>
  <td>
<tt>SubClassOf(ObjectOneOf( Individual ) superClassExpression )</tt></td>
</tr>
<tr>
  <td>31</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>ObjectPropertyAssertion(</tt><br />
<tt>&nbsp;ObjectPropertyExpression </tt><br />
<tt>&nbsp;source</tt><br />
<tt>&nbsp;target)</tt><br />
</p>
)</td>
  <td>
<tt>SubClassOf(ObjectOneOf( source ) ObjectHasValue(ObjectPropertyExpression target) )</tt></td>
</tr>
<tr>
  <td>32</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>NegativeObjectPropertyAssertion(</tt><br />
<tt>&nbsp;ObjectPropertyExpression </tt><br />
<tt>&nbsp;source</tt><br />
<tt>&nbsp;target)</tt><br />
</p>
)</td>
  <td>
<tt>SubClassOf(ObjectOneOf( source ) ObjectComplementOf(ObjectHasValue(ObjectPropertyExpression target) ) )</tt></td>
</tr>
<tr>
  <td>33</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>DataPropertyAssertion(</tt><br />
<tt>&nbsp;DataProperty </tt><br />
<tt>&nbsp;source</tt><br />
<tt>&nbsp;target)</tt><br />
</p>
)</td>
  <td>
<tt>SubClassOf(ObjectOneOf( source ) DataHasValue(DataProperty target) )</tt></td>
</tr>
<tr>
  <td>34</td>
  <td>tr<sub>N</sub>(<br />
<p><tt>NegativeDataPropertyAssertion(</tt><br />
<tt>&nbsp;DataProperty </tt><br />
<tt>&nbsp;source</tt><br />
<tt>&nbsp;target)</tt><br />
</p>
)</td>
  <td>
<tt>SubClassOf(ObjectOneOf( source ) ObjectComplementOf(DataHasValue(DataProperty target) ) )</tt></td>
</tr>
</table>
<p>We note that normalized OWL 2 RL ontologies are not necessarily OWL 2 RL ontologies, since <tt>owl:Thing</tt> may appear in subclass expressions, as a result of the transformation of <tt>DataPropertyRange</tt> axioms.
</p><p>The following lemma establishes the fact that, for the purpose of entailment, the ontologies in a combination may be replaced with their normalization.
</p><p><span id="lem-normalization"><b>Normalization Lemma</b></span> Given a combination C=&lt;<i>R</i>,{<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}&gt;, where <i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i> are simplified OWL 2 RL ontologies that do not import ontologies, C RIF-OWL Direct-entails &phi; iff C'=&lt;<i>R</i>,{tr<sub>N</sub>(<i>O<sub>1</sub></i>),...,tr<sub>N</sub>(<i>O<sub>n</sub></i>)}&gt; RIF-OWL Direct-entails &phi;.
</p>
<blockquote> <b>Proof.</b> We prove both directions by contradiction: if the entailment does not hold on the one side, we show that it also does not hold on the other.

<br />

<br />

(=&gt;) Assume C' does not RIF-OWL Direct-entail &phi;.  This means there is a common-RIF-OWL Direct-interpretation (<i><b>&Icirc;</b></i>, I) that is a model of C', but <i><b>I</b></i> is not a model of &phi;. 

<br />

By the definition of satisfaction of axioms and assertions in <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Satisfaction_in_an_Interpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Satisfaction_in_an_Interpretation">Section 2.3</a> and the interpretation of object property, data range, and class expressions in <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations">Section 2.2</a> in [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>] it is easy to verify that, if for every axiom d appearing in {<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}, I satisfies tr<sub>N</sub>(d), then I satisfies <i>O<sub>1</sub></i>,..., and <i>O<sub>n</sub></i>, and thus (<i><b>I</b></i>, I) satisfies C. Since <i><b>I</b></i> is not a model of &phi;, C does not RIF-OWL Direct-entail &phi;.

<br />

<br />

(&lt;=) Assume C does not RIF-OWL Direct-entail &phi;.  This means there is a common-RIF-OWL Direct-interpretation (<i><b>&Icirc;</b></i>, I) that is a model of C, but <i><b>I</b></i> is not a model of &phi;. It is easy to verify, by the definition of satisfaction of axioms and assertions in <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Satisfaction_in_an_Interpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Satisfaction_in_an_Interpretation">Section 2.3</a> and the interpretation of object property, data range, and class expressions in <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Interpretations">Section 2.2</a> in [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>], that I satisfies tr<sub>N</sub>(<i>O<sub>1</sub></i>),..., and tr<sub>N</sub>(<i>O<sub>n</sub></i>).  So, (<i><b>&Icirc;</b></i>, I) is a model of C', and thus C' does not RIF-OWL Direct-entail &phi;.
&nbsp;&nbsp;☐</blockquote>
<a id="Embedding_Normalized_OWL_2_RL" name="Embedding_Normalized_OWL_2_RL"></a><h5> <span class="mw-headline">9.2.2.2  Embedding Normalized OWL 2 RL </span></h5>
<p>We now proceed with the embedding of normalized OWL 2 RL ontologies into RIF DL-document formulas. The embedding function tr<sub>O</sub> takes as input a normalized OWL 2 RL ontology and returns a RIF-BLD DL-document formula. The embeddings of IRIs and literals is as defined in Section 9.1.1 <a href="#Embedding_Symbols" title="">Embedding Symbols</a>. It is assumed that the Vocabulary <i>V</i> of the ontologies includes all the constants used in the RIF documents and condition formulas under consideration. 
</p>
<table border="1" id="tab-owl-embedding">
<caption>Embedding Normalized OWL 2 RL</caption>
<tr>
  <th>#</th>
  <th>Normalized OWL</th>
  <th>RIF-BLD DL-document formula</th>
  <th>Condition on translation</th>
</tr>
<tr>
  <td>1</td>
  <td>tr<sub>O</sub>(<br />
<p><tt>Ontology(<br />
&nbsp;<span>axiom<sub>1</sub><br />
&nbsp;&nbsp;... <br />
&nbsp;axiom<sub>n</sub></span><br />
)</tt><br />
</p>
)</td>
  <td><tt>Document(Group(</tt><br />
<p>tr<sub>O</sub>(<tt>axiom<sub>1</sub></tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
tr<sub>O</sub>(<tt>axiom<sub>n</sub></tt>)<br />
</p>
<tt>))</tt></td>
</tr>
<tr>
  <td>2</td>
  <td>tr<sub>O</sub>(<br />
<p><tt>SubClassOf(subClassExpression superClassExpression)</tt><br />
</p>
)</td>
  <td>
<p>tr<sub>O</sub>(<tt>subClassExpression</tt>,<tt>superClassExpression</tt>)
</p>
  </td>
</tr>
<tr>
  <td>3</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>[Object|Data]AllValuesFrom(property<sub>1</sub> ...[Object|Data]AllValuesFrom(property<sub>n</sub> <i>X</i>) ...)</tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub> ...&nbsp;?y<sub>n</sub> (</tt>tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?y<sub>n</sub></tt>) <tt>:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>2</sub></tt>, <tt>?y<sub>1</sub></tt>, <tt>?y<sub>2</sub></tt>)<br />
&nbsp;&nbsp;...<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>n</sub></tt>, <tt>?y<sub>n-1</sub></tt>, <tt>?y<sub>n</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?y<sub>n</sub></tt>)<tt>))</tt>
</p>
  </td>
  <td><tt>n</tt>&ge;1 and <tt><i>X</i></tt> is not an <tt>[Object|Data]AllValuesFrom</tt> or <tt>[Object|Data]MaxCardinality</tt> expression.</td>
</tr>
<tr>
  <td>3a</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt><i>X</i></tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x (</tt>tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?y<sub>n</sub></tt>) <tt>:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression<sub>1</sub></tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?x</tt>)<tt>))</tt>
</p>
  </td>
  <td><tt><i>X</i></tt> is not an <tt>[Object|Data]AllValuesFrom</tt> or <tt>[Object|Data]MaxCardinality</tt> expression.</td>
</tr>
<tr>
  <td>4</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>[Object|Data]AllValuesFrom(property<sub>1</sub> ...[Object|Data]AllValuesFrom(property<sub>n</sub> [Object|Data]MaxCardinality(0 PropertyExpression ClassExpression) ...)</tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub> ...&nbsp;?y<sub>n</sub>&nbsp;?z (rif:error:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>2</sub></tt>, <tt>?y<sub>1</sub></tt>, <tt>?y<sub>2</sub></tt>)<br />
&nbsp;&nbsp;...<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>n</sub></tt>, <tt>?y<sub>n-1</sub></tt>, <tt>?y<sub>n</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y<sub>n</sub></tt>, <tt>?z</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?z</tt>)<tt>))</tt>
</p>
  </td>
  <td><tt>n</tt>&ge;1.</td>
</tr>
<tr>
  <td>4a</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>[Object|Data]MaxCardinality(0 PropertyExpression ClassExpression)</tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (rif:error&nbsp;:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?y</tt>)<tt>))</tt>
</p>
  </td>
</tr>
<tr>
  <td>5</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>[Object|Data]AllValuesFrom(property<sub>1</sub> ...[Object|Data]AllValuesFrom(property<sub>n</sub> [Object|Data]MaxCardinality(1 PropertyExpression ClassExpression) ...)</tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub> ...&nbsp;?y<sub>n</sub>&nbsp;?z<sub>1</sub>&nbsp;?z<sub>2</sub> (?z<sub>1</sub>=?z<sub>2</sub>&nbsp;:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>2</sub></tt>, <tt>?y<sub>1</sub></tt>, <tt>?y<sub>2</sub></tt>)<br />
<tt>&nbsp;&nbsp;...</tt><br />
&nbsp;tr<sub>O</sub>(<tt>property<sub>n</sub></tt>, <tt>?y<sub>n-1</sub></tt>, <tt>?y<sub>n</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y<sub>n</sub></tt>, <tt>?z<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y<sub>n</sub></tt>, <tt>?z<sub>2</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?z<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?z<sub>2</sub></tt>)<tt>))</tt>
</p>
  </td>
  <td><tt>n</tt>&ge;1.</td>
</tr>
<tr>
  <td>5a</td>
  <td>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>[Object|Data]MaxCardinality(1 PropertyExpression ClassExpression)</tt>)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub>&nbsp;?y<sub>2</sub> (?y<sub>1</sub>=?y<sub>2</sub>&nbsp;:- And( </tt><br /> &nbsp;tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y<sub>2</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?y<sub>2</sub></tt>)<tt>))</tt>
</p>
  </td>
</tr>
<tr>
  <td>6</td>
  <td>tr<sub>O</sub>(<tt>A</tt>,<tt>?<i>x</i></tt>)</td>
  <td>
<p><tt>?<i>x</i>[rdf:type -&gt; </tt>tr(<tt>A</tt>)<tt>]</tt>
</p>
  </td>
  <td><tt>A</tt> is a Class or Datatype; <tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>7</td>
  <td>tr<sub>O</sub>(<tt>[Object|Data]IntersectionOf(ClassExpression<sub>1</sub> ... ClassExpression<sub>n</sub>)</tt>, <tt>?<i>x</i></tt>)</td>
  <td>
<p><tt>And(</tt>tr<sub>O</sub>(<tt>ClassExpression<sub>1</sub></tt>, <tt>?<i>x</i></tt>) ... tr<sub>O</sub>(<tt>ClassExpression<sub>n</sub></tt>, <tt>?<i>x</i></tt>)<tt>)</tt>
</p>
  </td>
  <td><tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>8</td>
  <td>tr<sub>O</sub>(<tt>ObjectUnionOf(ClassExpression<sub>1</sub> ... ClassExpression<sub>n</sub>)</tt>, <tt>?<i>x</i></tt>)</td>
  <td>
<p><tt>Or(</tt>tr<sub>O</sub>(<tt>ClassExpression<sub>1</sub></tt>, <tt>?<i>x</i></tt>) ... tr<sub>O</sub>(<tt>ClassExpression<sub>n</sub></tt>, <tt>?<i>x</i></tt>)<tt>)</tt>
</p>
  </td>
  <td><tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>9</td>
  <td>tr<sub>O</sub>(<tt>[Object|Data]OneOf(Individual<sub>1</sub> ... Individual<sub>n</sub>)</tt>, <tt>?<i>x</i></tt>)</td>
  <td>
<p><tt>Or(&nbsp;?<i>x</i> =</tt> tr(<tt>Individual<sub>1</sub></tt>) <tt> ...&nbsp;?<i>x</i> =</tt> tr(<tt>Individual<sub>n</sub></tt>)<tt>)</tt>
</p>
  </td>
  <td><tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>10</td>
  <td>tr<sub>O</sub>(<tt>[Object|Data]SomeValuesFrom(PropertyExpression ClassExpression))</tt>, <tt>?<i>x</i></tt>)</td>
  <td>
<p><tt>Exists&nbsp;?y(And(</tt> tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?<i>x</i></tt>, <tt>?y</tt>)<tt>]</tt> tr<sub>O</sub>(<tt>ClassExpression</tt>, <tt>?y</tt>) <tt>))</tt>
</p>
  </td>
  <td><tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>11</td>
  <td>tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?<i>x</i></tt>, <tt>?<i>y</i></tt>)</td>
  <td>
<p><tt>?<i>x</i>[</tt>tr(<tt><i>X</i></tt>) <tt>-&gt;&nbsp;?<i>y</i>]</tt>
</p>
  </td>
  <td><tt><i>X</i></tt> is a Property; <tt><i>x</i>, <i>y</i></tt> are variable names</td>
</tr>
<tr>
  <td>12</td>
  <td>tr<sub>O</sub>(<tt>ObjectInverseOf(<i>X</i>)</tt>, <tt>?<i>x</i></tt>, <tt>?<i>y</i></tt>)</td>
  <td>
<p><tt>?<i>y</i>[</tt>tr(<tt><i>X</i></tt>) <tt>-&gt;&nbsp;?<i>x</i>]</tt>
</p>
  </td>
  <td><tt><i>X</i></tt> is a Property; <tt><i>x</i>, <i>y</i></tt> are variable names</td>
</tr>
<tr>
  <td>13</td>
  <td>tr<sub>O</sub>(<tt>[Object|Data]HasValue(PropertyExpression value)</tt>, <tt>?<i>x</i></tt>)</td>
  <td>
<p>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?<i>x</i></tt>, tr(<tt>value</tt>))
</p>
  </td>
  <td><tt><i>x</i></tt> is a variable name</td>
</tr>
<tr>
  <td>14</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>SubObjectPropertyOf(ObjectPropertyChain(PropertyExpression<sub>1</sub> ... PropertyExpression<sub>m</sub>) PropertyExpression<sub>0</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub> ...&nbsp;?y<sub>m</sub> (</tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y<sub>m</sub></tt>) <tt>&nbsp;:- And(</tt><br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>)<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression<sub>2</sub></tt>, <tt>?y<sub>1</sub></tt>, <tt>?y<sub>2</sub></tt>) <br />
&nbsp;&nbsp;...<br />
&nbsp;tr<sub>O</sub>(<tt>PropertyExpression<sub>m</sub></tt>, <tt>?y<sub>m-1</sub></tt>, <tt>?y<sub>m</sub></tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>15</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>Sub[Object|Data]PropertyOf(PropertyExpression<sub>1</sub> PropertyExpression<sub>2</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (</tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>2</sub></tt>, <tt>?x</tt>, <tt>?y</tt>) <tt>&nbsp;:- </tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y</tt>)<tt>)</tt>
</p>
</td>
<td><tt>PropertyExpression<sub>1</sub></tt> contains no mention of <tt>ObjectPropertyChain</tt></td>
</tr>
<tr>
  <td>16</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>Disjoint[Object|Data]Properties(PropertyExpression<sub>1</sub> PropertyExpression<sub>2</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (rif:error&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y</tt>) tr<sub>O</sub>(<tt>PropertyExpression<sub>2</sub></tt>, <tt>?x</tt>, <tt>?y</tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>17</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>InverseObjectProperties(PropertyExpression<sub>1</sub> PropertyExpression<sub>2</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (</tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>2</sub></tt>, <tt>?y</tt>, <tt>?x</tt>) <tt>&nbsp;:- </tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?y</tt>)<tt>)</tt><br />
<tt>Forall&nbsp;?x&nbsp;?y (</tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?y</tt>, <tt>?x</tt>) <tt>&nbsp;:- </tt>tr<sub>O</sub>(<tt>PropertyExpression<sub>2</sub></tt>, <tt>?x</tt>, <tt>?y</tt>)<tt>)</tt>
</p>
</td>
</tr>
<tr>
  <td>18</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>Functional[Object|Data]Property(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y<sub>1</sub>&nbsp;?y<sub>2</sub> (?y<sub>1</sub>=?y<sub>2</sub>&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y<sub>1</sub></tt>) tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y<sub>2</sub></tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>19</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>InverseFunctional[Object|Data]Property(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x<sub>1</sub>&nbsp;?x<sub>2</sub>&nbsp;?y (?x<sub>1</sub>=?x<sub>2</sub>&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x<sub>1</sub></tt>, <tt>?y</tt>) tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x<sub>2</sub></tt>, <tt>?y</tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>20</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>IrreflexiveObjectProperty(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x (rif:error&nbsp;:- </tt> tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?x</tt>)<tt>)</tt>
</p>
</td>
</tr>
<tr>
  <td>21</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>SymmetricObjectProperty(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y</tt>, <tt>?x</tt>)<tt>&nbsp;:- </tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y</tt>)<tt>)</tt>
</p>
</td>
</tr>
<tr>
  <td>22</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>AsymmetricObjectProperty(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y (rif:error&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y</tt>) tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y</tt>, <tt>?x</tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>23</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>TransitiveObjectProperty(PropertyExpression)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z (</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?z</tt>)<tt>&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?x</tt>, <tt>?y</tt>) tr<sub>O</sub>(<tt>PropertyExpression</tt>, <tt>?y</tt>, <tt>?z</tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>24</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>DatatypeDefinition(datatypeIRI DataRange)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x (?x[rdf:type -&gt; </tt>tr(<tt>datatypeIRI</tt>)<tt>]&nbsp;:- </tt>tr<sub>O</sub>(<tt>DataRange</tt>, <tt>?x</tt>)<tt>)</tt><br />
<tt>Forall&nbsp;?x ( </tt>tr<sub>O</sub>(<tt>DataRange</tt>, <tt>?x</tt>)<tt>:-&nbsp;?x[rdf:type -&gt; </tt>tr(<tt>datatypeIRI</tt>)<tt>] )</tt>
</p>
</td>
</tr>
<tr>
  <td>25</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>HasKey(subClassExpression PropertyExpression<sub>1</sub> ... PropertyExpression<sub>m</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>Forall&nbsp;?x&nbsp;?y&nbsp;?z<sub>1</sub> ...&nbsp;?z<sub>m</sub> (?x=?y&nbsp;:- And(</tt>tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?x</tt>) tr<sub>O</sub>(<tt>subClassExpression</tt>, <tt>?y</tt>) tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?z<sub>1</sub></tt>) ... tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?x</tt>, <tt>?z<sub>m</sub></tt>) tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?y</tt>, <tt>?z<sub>1</sub></tt>) ... tr<sub>O</sub>(<tt>PropertyExpression<sub>1</sub></tt>, <tt>?y</tt>, <tt>?z<sub>m</sub></tt>)<tt>))</tt>
</p>
</td>
</tr>
<tr>
  <td>26</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>SameIndividual(Individual<sub>1</sub> Individual<sub>2</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p>tr(<tt>Individual<sub>1</sub></tt>)<tt>=</tt>tr(<tt>Individual<sub>2</sub></tt>)
</p>
</td>
</tr>
<tr>
  <td>27</td>
  <td>tr<sub>O</sub>(<br />
<p><tt><span>DifferentIndividuals(Individual<sub>1</sub> Individual<sub>2</sub>)</span></tt><br />
</p>
)</td>
  <td>
<p><tt>rif:error</tt>&nbsp;:- tr(<tt>Individual<sub>1</sub></tt>)<tt>=</tt>tr(<tt>Individual<sub>2</sub></tt>)
</p>
</td>
</tr>
</table>
<p>Besides the embedding in the previous table, we also need an axiomatization of some of the aspects of the OWL 2 Direct Semantics, e.g., separation between individual and datatype domains. This axiomatization is defined relative to an OWL Vocabulary <i>V</i>, which includes all well-typed literals used in the rules, and a datatype map D, which includes all considered datatypes. In the table, for a given datatype d, L2V(d) is the lexical-to-value mapping of d.
</p>
<table border="1">
<tr valign="top">
<td><em>R<sup>OWL-Direct</sup></em>(<i>V</i>,<i>R</i>)</td><td>=</td>
<td>merge({<br />
<p>(i) (<tt>Forall&nbsp;?x (rif:error&nbsp;:-&nbsp;?x[rdf:type -&gt; owl:Nothing])</tt>,<br />
(ii) <tt>Forall&nbsp;?x (rif:error&nbsp;:- And(?x[rdf:type -&gt; rdfs:Literal]&nbsp;?x[rdf:type -&gt; owl:Thing]))</tt>,<br />
(iii) (<tt>Forall&nbsp;?x (?x[rdf:type -&gt; owl:Thing]&nbsp;:-&nbsp;?x[rdf:type -&gt; C])</tt>) for every class ID <tt>C</tt>,<br />
(iv) (<tt>Forall&nbsp;?x&nbsp;?y (?x[rdf:type -&gt; owl:Thing]&nbsp;:-&nbsp;?x[P -&gt;&nbsp;?y])</tt>) for every property ID <tt>P</tt>,<br />
(v) (<tt>Forall&nbsp;?x&nbsp;?y (?y[rdf:type -&gt; owl:Thing]&nbsp;:-&nbsp;?x[P -&gt;&nbsp;?y])</tt>) for every object property ID <tt>P</tt>,<br />
(vi) (<tt>Forall&nbsp;?x&nbsp;?y (?y[rdf:type -&gt; rdfs:Literal]&nbsp;:-&nbsp;?x[P -&gt;&nbsp;?y])</tt>) for every data property ID <tt>P</tt>,<br />
(vii) (tr(<tt>i</tt>)<tt>[rdf:type -&gt; owl:Thing]</tt>) for every IRI <tt>i</tt> in <i>V</i>,<br />
(viii) (tr(<tt>s^^u</tt>)<tt>[rdf:type -&gt; u']</tt>) for every well-typed literal <tt>s^^u</tt> and datatype identifier <tt>u'</tt> in <i>V</i> such that L2V(D(<tt>u</tt>))(<tt>s</tt>) is in the value space of <tt>u'</tt>,<br />
(ix) (<tt>rif:error&nbsp;:- </tt>tr(<tt>s^^u</tt>)<tt>[rdf:type -&gt; u']</tt>) for every well-typed literal <tt>s^^u</tt> and datatype identifier <tt>u'</tt> in <i>V</i> such that L2V(D(<tt>u</tt>))(<tt>s</tt>) is not in the value space of <tt>u'</tt>,<br />
(x) (<tt>Forall&nbsp;?x (?x[rdf:type -&gt; rdfs:Literal]&nbsp;:-&nbsp;?x[rdf:type -&gt; <i>Diri</i>])</tt>) for every datatype in D with identifier <i>Diri</i>,<br />
(xi) <tt>"a"="b"&nbsp;:- rif:error</tt>})
</p>
</td></tr>
</table>
<p>We call an OWL 2 RL ontology <i>O</i> <i>normalized</i> if it is the same as its normalization, i.e., <i>O</i>=tr<sub>N</sub>(<i>O</i>).
</p><p>The following lemma establishes faithfulness of the embedding.
</p><p><span id="lem-normalized-embedding"><b>Normalized Combination Embedding Lemma</b></span> Given a datatype map D conforming with T, a <a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> C=&lt;<i>R</i>,{<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}&gt;, where {<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>} is an imports-closed set of normalized OWL 2 RL ontologies with vocabulary <i>V</i>, <a href="#def-owl-direct-entails" title="">RIF-OWL Direct-entails</a> a DL-condition &phi; with respect to D iff merge({<i>R'</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>), tr<sub>O</sub>(<i>O<sub>1</sub></i>), ..., tr<sub>O</sub>(<i>O<sub>n</sub></i>)}) <a href="#def-dl-entails" title="">dl-entails</a> &phi;, where <i>R'</i> is like <i>R</i>, except that every subformula of the form <tt>a#b</tt> has been replaced with <tt>a[rdf:type -&gt; b]</tt>.
</p><p><br />
</p>
<blockquote> <b>Proof.</b> 
We prove both directions by contraposition. 

<br />

In the proof we abbreviate merge({<i>R'</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>), tr<sub>O</sub>(<i>O<sub>1</sub></i>), ..., tr<sub>O</sub>(<i>O<sub>n</sub></i>)} with R*.

<br />

<br />

(=&gt;) Assume R* does not dl-entail &phi;.  This means there is a dl-semantic multi-structure <i><b>&Icirc;</b></i> that is a model of R* but <i><b>I</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>C'</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt; is not a model of &phi;. 

<br />

We call a structure <i><b>I</b></i> <i>named for R*</i> if for every object <tt>k</tt> &isin; <i><b>D</b></i><sub>ind</sub> that is not in the value space of some datatype in <i><b>DTS</b></i>, <tt>k</tt>=<i><b>I</b></i><sub>C</sub>(<tt>c</tt>), where <tt>c</tt> is either an IRI identifying an individual in <i>V</i> or a constant appearing as an individual in <i>R</i>. This definition extends naturally to dl-semantic multi-structures.

<br />

We now show that there is a named dl-semantic multi-structure <i><b>&Icirc;'</b></i> that is a model of R* such that <i><b>I'</b></i> is not a model of &phi;. 

<br />

The set of unnamed individuals in <i><b>I</b></i> is the set of objects <tt>k</tt> &isin; <i><b>D</b></i><sub>ind</sub> that are not in the value space of some datatype in <i><b>DTS</b></i>, and there is no IRI <tt>c</tt> identifying an individual in <i>V</i> or constant <tt>c</tt> appearing as an individual in <i>R</i> such that <tt>k</tt>=<i><b>I</b></i><sub>C</sub>(<tt>c</tt>).

<br />

Let <i><b>&Icirc;'</b></i> be obtained from <i><b>&Icirc;</b></i> by removing all unnamed individuals from <i><b>D</b></i><sub>ind</sub> and removing the corresponding tuples in the domains and ranges of the various mapping functions in the structures in <i><b>&Icirc;</b></i>. Clearly, <i><b>I'</b></i> is not a model of &phi;: condition formulas do not contain negation, and so every condition formula that is satisfied by <i><b>I'</b></i> is also satisfied by <i><b>I</b></i>.

<br />

Consider any rule r in R*. If r is a variable-free rule implication or atomic formula it is clearly satisfied <i><b>&Icirc;'</b></i>, by satisfaction of r in <i><b>&Icirc;</b></i> are construction of <i><b>&Icirc;'</b></i>. A universal fact can be seen as a rule with the empty condition <tt>And()</tt>. Let r be a rule with a condition &psi; that is satisfied by <i><b>I'</b></i>. Since &psi; does not contain negation, &psi; is also satisfied by <i><b>I</b></i>. Now, if every variable in the conclusion of r appears also in the condition &psi;, every variable is mapped to a named individual, and thus the conclusion is satisfied by satisfaction in <i><b>I</b></i> and construction of <i><b>I'</b></i>. Now, if there is a variable <tt>?x</tt> in the conclusion that does not appear in &psi;, <i><b>I</b></i> satisfies the conclusion for every assignment of <tt>?x</tt> to any element in <i><b>D</b></i><sub>ind</sub>. Since the individual domain of <i><b>I'</b></i> is a strict subset of <i><b>D</b></i><sub>ind</sub>, the conclusion is also satisfied in <i><b>I'</b></i>. Therefore, <i><b>&Icirc;'</b></i> is a model of R*. In the remainder we assume <i><b>&Icirc;</b></i>=<i><b>&Icirc;'</b></i>.

<br />

We define CExt(<tt>c</tt>)={<tt>u</tt> | <tt>u</tt> &isin; <i><b>D</b></i><sub>ind</sub> and <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>u</tt>)(<tt>rdf:type</tt>, <i><b>I</b></i><sub>C</sub>(<tt>c</tt>)))=<b>t</b>} as the class extension of the constant <tt>c</tt>. Furthermore, we define <i><b>D</b></i><sub>D</sub>=(union of the value spaces of all datatypes in D). 

<br />

Consider the pair (<i><b>&Icirc;*</b></i>,I), where <i><b>&Icirc;*</b></i> is obtained from <i><b>&Icirc;</b></i> as follows: <i><b>I*</b></i> = &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>,
<i><b>D*</b></i>, <i><b>D*</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I*</b></i><sub>C</sub>, <i><b>I</b></i><sub>C'</sub>,
<i><b>I</b></i><sub>V</sub>, <i><b>I</b></i><sub>F</sub>,
<i><b>I*</b></i><sub>frame</sub>, <i><b>I</b></i><sub>NF</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>,
<i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>,
<i><b>I</b></i><sub>truth</sub>&gt;, where <tt>t</tt>, <tt>f</tt> &isin; <i><b>D*</b></i> such that <i><b>I</b></i><sub>truth</sub>(<tt>t</tt>)=<b>t</b> and <i><b>I*</b></i><sub>truth</sub>(<tt>f</tt>)=<b>f</b>, and

<ul><li> <i><b>D*</b></i><sub>ind</sub>=<i><b>D</b></i><sub>ind</sub> union (union of the value spaces of all datatypes in D);
</li><li> <i><b>D*</b></i>=<i><b>D</b></i> union <i><b>D*</b></i><sub>ind</sub>;
</li><li> <i><b>I*</b></i><sub>C</sub> is like <i><b>I</b></i><sub>C</sub> except that it maps all constants with symbol spaces in D\<i><b>DTS</b></i> to the values in the in the corresponding datatypes, according to the respective lexical-to-value mappings;
</li><li> <i><b>I*</b></i><sub>frame</sub> is defined as follows:
<ul><li> <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>rdfs:Literal</tt>))=<tt>t</tt> if <tt>k</tt> &isin; <i><b>D</b></i><sub>D</sub>, otherwise <i><b>I*</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>rdfs:Literal</tt>))=<tt>f</tt>,
</li><li> otherwise <i><b>I*</b></i><sub>frame</sub> is like <i><b>I</b></i><sub>frame</sub>;
</li></ul>
</li></ul>

and I=&lt; IR, LV, C, OP, DP, I, DT, LT, FA &gt; is a tuple defined as follows:

<ul><li> LV=<i><b>D</b></i><sub>D</sub>,
</li><li> IR=<i><b>D</b></i><sub>ind</sub>\LV,
</li><li> DT(<tt>rdfs:Literal</tt>)=LV,
</li><li> DT(<tt>d'</tt>) = the value space of D(<tt>d'</tt>), if <tt>d'</tt> is a datatype identifier in <i>V</i> in the domain of D,
</li><li> DT(<tt>d'</tt>) = set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))) = <b>t</b>, for every datatype identifier <tt>d'</tt> in <i>V</i>, not in the domain of D,
</li><li> C(<tt>c</tt>) = set of all objects <tt>k</tt> such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)(<i><b>I</b></i><sub>C'</sub>(<tt>rdf:type</tt>),<i><b>I</b></i><sub>C'</sub>(<tt>&lt;c&gt;</tt>))) = <b>t</b>, for every class identifier in <i>V</i>,
</li><li> OP(<tt>p</tt>) = set of all pairs (<tt>k</tt>, <tt>l</tt>) such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)( <i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt> ))) = <b>t</b> (true), for every object property identifier <tt>p</tt> in <i>V</i> and  not in {<tt>owl:topObjectProperty</tt>,<tt>owl:bottomObjectProperty</tt>};
</li><li> OP(<tt>owl:topObjectProperty</tt>) = IR &times; IR;
</li><li> OP(<tt>owl:bottomObjectProperty</tt>) = { };
</li><li> DP(<tt>p</tt>) = set of all pairs (<tt>k</tt>, <tt>l</tt>) such that <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)( <i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt> ))) = <b>t</b> (true), for every datatype property identifier <tt>p</tt> in <i>V</i> and not in {<tt>owl:topDataProperty</tt>,<tt>owl:bottomDataProperty</tt>};
</li><li> OP(<tt>owl:topDataProperty</tt>) = IR &times; LV;
</li><li> OP(<tt>owl:bottomDataProperty</tt>) = { };
</li><li> LT((<tt>s</tt>, <tt>d</tt>)) = <i><b>I</b></i><sub>C</sub>(<tt>"s"^^d</tt>) for every <a href="#def-well-typed-literal" title="">well-typed literal</a> (<tt>s</tt>, <tt>d</tt>) in <i>V</i>;
</li><li> I(<tt>i</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>&lt;i&gt;</tt>) for every IRI <tt>i</tt> identifying an individual in <i>V</i>;
</li><li> FA is the empty mapping.
</li></ul>

When referring to rules in the remainder we mean rules in <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>), unless otherwise specified.

<br />

We have that <i><b>I*</b></i> has a separation between the object and data domains: (+) each object is either in CExt(<tt>owl:Thing</tt>) or in CExt(<tt>rdfs:Literal</tt>) and <i><b>D</b></i><sub>D</sub>: each non-data value in <i><b>D</b></i><sub>ind</sub> is in CExt(<tt>owl:Thing</tt>) by rule (vii) and the fact that <i><b>I*</b></i> is a named structure, and each data value is in CExt(<tt>rdfs:Literal</tt>) by construction of <i><b>I*</b></i>. The two sets are distinct by satisfaction of rule (ii) in <i><b>I</b></i>.

<br />

It is straightforward to see that <i><b>&Icirc;*</b></i> is a model of R* and <i><b>I*</b></i> is not a model of &phi;.

<br />

According to its definition, an <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#def_interpretation">interpretation</a> with respect to a datatype map D must fulfill the following conditions, where L(d) denotes the lexical space, V(d) denotes the value space and L2V(d) denotes to lexical-to-value mapping of a datatype d:

<ol><li> IR is a nonempty set,
</li><li> LV  is a nonempty set disjoint with IR and including the value spaces of all datatypes in D,
</li><li> C&nbsp;: <i>V<sub>C</sub></i> &rarr; 2<sup>IR</sup> 
</li><li> DT&nbsp;: <i>V<sub>D</sub></i> &rarr;  2<sup>LV</sup>, where DT is the same as in D for each datatype d
</li><li> OP&nbsp;: <i>V<sub>IP</sub></i> &rarr; 2<sup>IR&times;IR</sup> 
</li><li> DP&nbsp;: <i>V<sub>DP</sub></i> &rarr; 2<sup>IR&times;LV</sup> 
</li><li> LT &nbsp;: TL &rarr; LV, where TL is the set of typed literals in <i>V<sub>L</sub></i> and LT((s,d))=L2V(d)(s), for every typed literal (s,d) &isin; <i>V<sub>L</sub></i>
</li><li> I &nbsp;: <i>V<sub>I</sub></i> &rarr; IR 
</li><li> C(<tt>owl:Thing</tt>) = IR
</li><li> C(<tt>owl:Nothing</tt>) = { } 
</li><li> OP(<tt>owl:topObjectProperty</tt>) = IR &times; IR
</li><li> DP(<tt>owl:topDataProperty</tt>) = IR &times; LV
</li><li> OP(<tt>owl:bottomObjectProperty</tt>) = { }
</li><li> DP(<tt>owl:bottomDataProperty</tt>) = { }
</li><li> DT(<tt>rdfs:Literal</tt>) = LV 
</li></ol>


Condition 1 is met because <i><b>D<sub>ind</sub></b></i> is a nonempty set. Clearly LV disjoint with IR and contains the value space for each datatype in D; therefore, condition 2 is met. Conditions 3 through 9 and 11 through 15 are met by the definitions of <i><b>I*</b></i> and I, and the property (+). Finally, condition 10 is satisfied by satisfaction of rule (i) in <i><b>I</b></i>.
This establishes the fact that I is an interpretation.

<br />

<br />

Consider now any ontology <i>O</i> in {<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}. To establish that I satisfies <i>O</i>, we need to establish that each axiom in the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_axiom_closure" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/#def_axiom_closure">axiom closure</a> of <i>O</i> is satisfied in I w.r.t. <i>O</i>. Note that, since <i>O</i> is normalized, it does not contain import statements, and thus the axiom closure of <i>O</i> is equal to <i>O</i>.

<br />

Consider any axiom d in <i>O</i>; d has one of the following forms (cf. the second column of Table <a href="#tab-owl-normalization" title="">Normalization of OWL 2 RL ontologies</a>):

<ol><li> subproperty statement,
</li><li> disjoint properties statement,
</li><li> inverse property statement,
</li><li> functional property statement,
</li><li> symmetric property statement,
</li><li> transitive property statement, 
</li><li> datatype definition,
</li><li> has-key statement,
</li><li> same-individual statement,
</li><li> different-individuals statement, or
</li><li> subclass statement <tt>SubClassOf(<i>X</i> <i>Y</i>)</tt>.
</li></ol>


Consider a subproperty statement <tt>SubObjectPropertyOf(p q)</tt> and a pair (<tt>k, l</tt>) in OP(<tt>&lt;p&gt;</tt>). Then, by construction of I, <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)( <i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt> ))) = <b>t</b>.  But, by tr(d), it must be the case that also <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)( <i><b>I</b></i><sub>C'</sub>(<tt>&lt;q&gt;</tt>), <tt>l</tt> ))) = <b>t</b>.  But then, (<tt>k,l</tt>) must be in OP(<tt>&lt;q&gt;</tt>), by construction of I. This argument extends straightforwardly to subproperty statements with inverse or property-chain expressions.  So, I satisfies d. Similar for statements of the forms 2--6.

<br />

Consider a datatype definition <tt>DatatypeDefinition( d e )</tt>, with <tt>d</tt>, <tt>e</tt> IRIs. This axiom is satisfied in I if <i>DT(d) = DT(e)</i>. This definition is translated to the rules
 Forall&nbsp;?x (?x[rdf:type -&gt; e]&nbsp;:-&nbsp;?x[rdf:type -&gt; d])
 Forall&nbsp;?x (?x[rdf:type -&gt; d]&nbsp;:-&nbsp;?x[rdf:type -&gt; e])
By satisfaction of these rules in <i><b>I*</b></i> and construction of I we have that I satisfies the datatype definition. This argument straightforwardly extends to more complex datatype definitions; recall that the only construct available in OWL 2 RL datatype definitions is intersection.

<br />

Consider a has-key axiom d. We have that every object in <i><b>D*</b></i><sub>ind</sub>, and thus also every object in IR is named. It is then straightforward to verify that if tr<sub><i>O</i></sub>(d) is satisfied in <i><b>I*</b></i>, the condition in <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Keys" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Keys">Section 2.3.5</a> of [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>] is satisfied. Analogous for same-individual and different-individual axioms.

<br />

Consider the case that d is a subclass statement <tt>SubClassOf(<i>X</i> <i>Y</i>)</tt> and consider any <tt>k</tt> in C(<tt><i>X</i></tt>), where C is as in the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Class_Expressions" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/#Class_Expressions">Class Expressions Table</a> in [<a href="#ref-owl2-semantics" title="">OWL2-Semantics</a>]. We show, by induction, that <i><b>I*</b></i> satisfies tr<sub>O</sub>(<tt><i>X</i></tt>) when <tt>?x</tt> is assigned to <tt>k</tt>.

<br />

If <tt><i>X</i></tt> is a classID, then satisfaction of tr(<tt><i>X</i></tt>) follows by an analogous argument as that for directives of form 1.  Similar for value restrictions. If <tt><i>X</i></tt> is a some-value restriction of type <tt><i>Z</i></tt> on a property <tt>p</tt>, then there must be some object <tt>l</tt> such that (<tt>k</tt>,<tt>l</tt>) in OP(<tt>p</tt>) such that <tt>l</tt> is in C(<tt><i>Z</i></tt>).

By induction we have satisfaction of tr(<tt><i>Z</i></tt>) for some variable assignment. Then, by definition of I, we have <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>frame</sub>(<tt>k</tt>)( <i><b>I</b></i><sub>C'</sub>(<tt>&lt;p&gt;</tt>), <tt>l</tt> )) = <b>t</b> (true), thereby establishing satisfaction of tr<sub>O</sub>(<tt><i>X</i></tt>) in <i><b>I*</b></i>. This extends straightforwardly to union, intersection, and one-of descriptions.

<br />

By satisfaction of tr<sub>O</sub>(d), we have that tr<sub>O</sub>(<tt><i>Y</i></tt>) is necessarily satisfied for <tt>?x</tt> assigned to <tt>k</tt>.  By an argument analogous to the argument above, we obtain that <tt>k</tt> is in C(<tt><i>Y</i></tt>).

<br />

This establishes satisfaction of d in I.

<br />

<br />

We obtain that every directive is satisfied in I. Therefore, <i>O</i>, and thus every ontology in C, is satisfied in I.  We have established earlier that <i><b>I*</b></i> satisfies <i>R</i> and not &phi;, so (<i><b>I*</b></i>, I) satisfies <i>R</i> and not &phi;.  We conclude that C does not entail &phi;.

<br />

<br />

(&lt;=) Assume C does not RIF-OWL Direct-entail &phi;.  This means there is a common-RIF-OWL Direct-interpretation (<i><b>&Icirc;</b></i>, I) that is a RIF-OWL Direct-model of C, but <i><b>I</b></i> is not a model of &phi;.  To show that R* does not entail &phi;, we show that <i><b>I</b></i> is a model of R*.

<br />

<i>R</i> is satisfied in <i><b>I</b></i> by assumption. Satisfaction of tr<sub>O</sub>(<i>O<sub>i</sub></i>) can be shown analogously to establishment of satisfaction in I of <i>O<sub>i</sub></i> in the (=&gt;) direction.  We now establish satisfaction of the rules in <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>).

<br />

(i) follows immediately from the fact that C(<tt>owl:Nothing</tt>)={}. (ii) follows from conditions 2, 9, and 15 on interpretations.  (iii) follows from conditions 3 and 9.  (iv) follows from conditions 5, 6 and 9. (v) follows from conditions 5 and 9.  (vi) follows from conditions 6 and 15. (vii) follows from conditions 8 and 9.  (viii) and (ix) follow from condition 7.  (x) follows from conditions 4 and 15. 

<br />

<br />

This establishes satisfaction of <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>), and thus R*, in <i><b>I</b></i>.  Therefore, R* does not entail &phi;.

&nbsp;&nbsp;☐

</blockquote>
<p>The following theorems establish faithfulness of the full embedding of RIF-OWL 2 RL combinations into RIF.
</p><p><b>Theorem</b> Given a datatype map D conforming with T, a  <a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> C=&lt;<i>R</i>,{<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}&gt;, where {<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>} is an imports-closed set of OWL 2 RL ontologies with Vocabulary <i>V</i>, <a href="#def-owl-direct-entails" title="">RIF-OWL Direct-entails</a> a DL-condition formula &phi; with respect to D iff tr(merge({<i>R</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>), tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>1</sub></i>)), ..., tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>n</sub></i>))})) <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/#def-bld-entail" title="BLD">entails</a> tr(&phi;).
</p>
<blockquote> <b>Proof.</b> 
By the <a href="#lem-dl-document" title="">RIF-BLD DL-document formula Lemma</a>, 

<br />

tr(merge({<i>R</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>), tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>1</sub></i>)), ..., tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>n</sub></i>))})) entails tr(&phi;) iff merge({<i>R</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>), tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>1</sub></i>)), ..., tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>n</sub></i>))}) dl-entails &phi;. 

<br />

Observe that the mapping tr() does not distinguish between frame formulas of the form <tt>a[rdf:type -&gt; b]</tt> and membership formulas <tt>a#b</tt>. We may thus safely assume that <i>R</i> has no occurrences of the latter.

Then, by the <a href="#lem-normalized-embedding" title="">Normalized Combination Embedding Lemma</a>, 

<br />

merge({<i>R</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>,<i>R</i>), tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>1</sub></i>)), ..., tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>n</sub></i>))}) dl-entails &phi; iff &lt;<i>R</i>,{tr<sub>N</sub>(<i>O<sub>1</sub></i>),...,tr<sub>N</sub>(<i>O<sub>n</sub></i>)}&gt; RIF-OWL Direct-entails &phi;.

<br />

Finally, by the <a href="#lem-normalization" title="">Normalization Lemma</a>, 

<br />

&lt;<i>R</i>,{tr<sub>N</sub>(<i>O<sub>1</sub></i>),...,tr<sub>N</sub>(<i>O<sub>n</sub></i>)}&gt; RIF-OWL Direct-entails &phi; iff C=&lt;<i>R</i>,{<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}&gt; RIF-OWL Direct-entails &phi;.

<br />


This chain of equivalences establishes the theorem. &nbsp;&nbsp;☐
</blockquote>
<p><b>Theorem</b> Given a datatype map D conforming with T, a <a href="#def-rif-owl-dl-combination" title="">RIF-OWL DL-combination</a> &lt;<i>R</i>,{<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>}&gt;, where {<i>O<sub>1</sub></i>,...,<i>O<sub>n</sub></i>} is an imports-closed set of OWL 2 RL ontologies with Vocabulary <i>V</i>, is <a href="#def-owl-direct-satisfiable" title="">RIF-OWL Direct-satisfiable</a> with respect to D iff tr(merge({<i>R</i>, <i>R<sup>OWL-Direct</sup></i>(<i>V</i>), tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>1</sub></i>)), ..., tr<sub>O</sub>(tr<sub>N</sub>(<i>O<sub>n</sub></i>))}) does not entail <tt>rif:error</tt>.
</p>
<blockquote> <b>Proof.</b> 
The theorem follows immediately from the previous theorem and the observation that a combination (respectively, document) is RIF-OWL Direct-satisfiable (respectively, has a model) if and only if it does not entail the condition formula <tt>"a"="b"</tt>. &nbsp;&nbsp;☐
</blockquote>
<div id="changelog">
<a id="Appendix:_Change_log_.28Informative.29" name="Appendix:_Change_log_.28Informative.29"></a><h2> <span class="mw-headline">10  Appendix: Change log (Informative) </span></h2>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/2010/PR-rif-rdf-owl-20100511/" rel="nofollow" title="http://www.w3.org/TR/2010/PR-rif-rdf-owl-20100511/">11 May 2010 Proposed Recommendation</a>.
</p><p>In the table in Section <a href="#Embedding_Normalized_OWL_2_RL" title="">9.2.2.2</a>:
The expression tr<sub>O</sub>(<tt><i>X</i></tt>, <tt>?y<sub>n</sub></tt>) has been added to the third row, second column; omitting this expression had been an oversight. Rows 3--5 did not account for inverse properties; this had been rectified. For the purpose of understandability, rows 3a, 4a, 5a have been added to make the case <tt>n</tt>=0 of rows 3, 4, 5 explicit.
</p><p>Changes since the <a class="external text" href="http://www.w3.org/TR/2010/REC-rif-rdf-owl-20100622/" rel="nofollow" title="http://www.w3.org/TR/2010/REC-rif-rdf-owl-20100622/">22 June 2010 Recommendation</a>.
</p><p>Added a clarification to Section 9 on the restriction for subclass preventing embedding.
</p>
<a id="End_Notes" name="End_Notes"></a><h2> <span class="mw-headline">11  End Notes </span></h2>
<p><span id="note-rdf-uri-references">
<b>RDF URI References</b></span>: There are certain RDF URI references that are not IRIs (e.g., those containing spaces). It is possible to use such RDF URI references in RDF graphs that are combined with RIF rules. However, such URI references cannot be represented in RIF rules and their use in RDF is discouraged.
</p><p><span id="note-generalized-rdf-graphs">
<b>Generalized RDF graphs</b></span>: Standard <a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-rdf-graph" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-rdf-graph">RDF graphs</a>, as defined in [<a href="#ref-rdf-concepts" title="">RDF-Concepts</a>], do not allow the use of literals in subject and predicate positions and blank nodes in predicate positions. The <a class="external text" href="http://www.w3.org/2001/sw/RDFCore/" rel="nofollow" title="http://www.w3.org/2001/sw/RDFCore/">RDF Core</a> working group has listed two <a class="external text" href="http://www.w3.org/2000/03/rdf-tracking/" rel="nofollow" title="http://www.w3.org/2000/03/rdf-tracking/">issues</a> questioning the restrictions that <a class="external text" href="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects" rel="nofollow" title="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">literals may not occur in subject</a> and <a class="external text" href="http://www.w3.org/2000/03/rdf-tracking/#rdf-bnode-predicates" rel="nofollow" title="http://www.w3.org/2000/03/rdf-tracking/#rdf-bnode-predicates">blank nodes may not occur in predicate</a> positions in triples.  Anticipating lifting of these restrictions in a possible future version of RDF, we use the more liberal notion of <i>generalized</i> RDF graph.  We note that the definitions of interpretations, models, and entailment in the  RDF Semantics document [<a href="#ref-rdf-semantics" title="">RDF-Semantics</a>] also apply to such generalized RDF graphs. 
</p><p>We note that every standard RDF graph is a generalized RDF graph.  Therefore, our definition of combinations applies to standard RDF graphs as well.
</p>
We note also that the notion of generalized RDF graphs is more liberal than the notion of RDF graphs used by <a class="external text" href="http://www.w3.org/TR/rdf-sparql-query/#QSynTriples" rel="nofollow" title="http://www.w3.org/TR/rdf-sparql-query/#QSynTriples">SPARQL</a>; generalized RDF graphs additionally allow blank nodes and literals in predicate positions.</div>


</body>
</html>