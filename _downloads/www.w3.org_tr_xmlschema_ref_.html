<!-- http://www.w3.org/TR/xmlschema-ref/ -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>W3C XML Schema Definition Language (XSD): Component Designators</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }
div.issue {font-weight: bold; color: red}
.out {text-decoration: line-through; background-color: #DB9;}

div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
</style><link type="text/css" rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-CR.css" /></head><body><div class="head"><p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="http://www.w3.org/Icons/w3c_home" /></a></p>
<h1><a id="title" name="title" />W3C XML Schema Definition Language (XSD): Component Designators</h1>
<h2><a id="w3c-doctype" name="w3c-doctype" />W3C Candidate Recommendation 19 January 2010</h2><dl><dt>This version:</dt><dd>   
     <a href="http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/">http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/</a>
   </dd><dt>Latest version:</dt><dd>   
     <a href="http://www.w3.org/TR/xmlschema-ref/">http://www.w3.org/TR/xmlschema-ref/</a>   
   </dd><dt>Previous versions:</dt><dd>   
     <a href="http://www.w3.org/TR/2008/WD-xmlschema-ref-20081117/">http://www.w3.org/TR/2008/WD-xmlschema-ref-20081117/</a>   
     <a href="http://www.w3.org/TR/2008/WD-xmlschema-ref-20080910/">http://www.w3.org/TR/2008/WD-xmlschema-ref-20080910/</a>   
     <a href="http://www.w3.org/TR/2005/WD-xmlschema-ref-20050329/">http://www.w3.org/TR/2005/WD-xmlschema-ref-20050329/</a>   
     <a href="http://www.w3.org/TR/2004/WD-xmlschema-ref-20040716/">http://www.w3.org/TR/2004/WD-xmlschema-ref-20040716/</a>   
     <a href="http://www.w3.org/TR/2004/WD-xmlschema-ref-20040309/">http://www.w3.org/TR/2004/WD-xmlschema-ref-20040309/</a>   
     <a href="http://www.w3.org/TR/2003/WD-xmlschema-ref-20030109/">http://www.w3.org/TR/2003/WD-xmlschema-ref-20030109/</a>   
   </dd><dt>Editors:</dt><dd>Mary Holstege, Mark Logic Corporation</dd><dd>Asir S. Vedamuthu, webMethods (until May 2005)</dd></dl><p>This document is also available in these non-normative formats: <a href="scds.xml">XML</a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2010 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr /><div>
<h2><a id="abstract" name="abstract" />Abstract</h2><p>XML Schema: Component Designators defines a scheme for identifying XML   
Schema components as specified by   
<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">XML Schema Part 1: Structures</a> and   
<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes</a>.   
</p></div><div>
<h2><a id="status" name="status" />Status of this Document</h2><p><em>This section describes the status of this document at the   
      time of its publication. Other documents may supersede this document.   
      A list of current W3C publications and the latest revision of this   
      technical report can be found in the   
      <a href="http://www.w3.org/TR/">W3C technical reports index</a> at   
      http://www.w3.org/TR/.</em></p><p>
<span>
This W3C Candidate Recommendation specified W3C XML Schema Definition Language
(XSD) Component Designators. It is here made available for review by W3C
members and the public. </span>
It has been    
produced by the <a href="http://www.w3.org/XML/Schema">W3C XML Schema Working   
Group</a> (WG) as part of the <a href="http://www.w3.org/XML/Activity">XML Activity</a>.   
It incorporates all Working Group decisions through 
2008-10-31.   
It has been reviewed by the Working Group and the Working Group has agreed to   
publication as a Last Call Working Draft.  
 </p><p>   
The <span>Candidate Recommendation</span> review period for this document extends until <span>1 March 2010</span>.
    Comments on this document should be made in   
    W3C's public installation of Bugzilla, specifying "XML Schema" as the   
    product. Instructions can be found at <a href="http://www.w3.org/XML/2006/01/public-bugzilla">http://www.w3.org/XML/2006/01/public-bugzilla</a>. If access to   
    Bugzilla is not feasible, please send your comments to the W3C XML   
    Schema comments mailing list, <a href="mailto:www-xml-schema-comments@w3.org">www-xml-schema-comments@w3.org</a>    
    (<a href="http://lists.w3.org/Archives/Public/www-xml-schema-comments/">archive</a>).   
    Each Bugzilla entry and email message should contain only one   
    comment.</p><p>
Any feature mentioned as a "feature at risk" may be retained as is or dropped,
depending on the feedback received from readers, schema authors, schema users,
and implementors. The only feature at risk is support for axes and components 
that are dependent on the XML Schema 1.1 component model rather than the 
XML Schema 1.0 component model.
</p><p>Publication as a <span>Candidate Recommendation</span> does not imply endorsement by the W3C   
Membership. This is a draft document and may be updated, replaced or obsoleted   
by other documents at any time. It is inappropriate to cite this document as   
other than work in progress.</p><p>
The W3C XML Schema Working Group intends to request advancement of this
specification and publication as a Proposed Recommendation (possibly with
editorial changes, and possibly removing features identified as being at risk)
as soon after 1 March 2010 as the exit criteria for the current
phase have been met.
</p><p>
This specification does not define any criteria for conformance and relies on
other specifications to specify criteria for conformance of implementations.
Nevertheless a <a href="http://dev.w3.org/2009/xmlschema-ref-test-suite/">test suite</a> is under development that
identifies the set of canonical schema component paths that should be generated
for particular test schemas, and that relates certain non-canonical component
paths to the corresponding canonical schema component paths.
</p><p>
The W3C XML Schema Working Group has agreed on the following specific CR exit criteria:
</p><ul><li><p>A test suite is available which provides cases for each 
axis and component
type, both for the XML Schema 1.0 component model and the XML Schema 1.1
component model.</p></li><li><p>Generation or interpretation of canonical schema component 
paths have been
implemented successfully by at least two independent implementations.</p></li><li><p>Generation or interpretation of each axis and component for 
non-canonical
schema component paths has been implemented successfully by at least two
independent implementations.</p></li><li><p>The Working Group has responded formally to all issues 
raised against this
document during the Candidate Recommendation period. </p></li></ul><p>At the time this Candidate Recommendation was published, no 
interoperability or implementation report had yet been prepared.  
</p><p>This document has been produced by the W3C XML Schema Working Group as part of
the W3C XML Activity. The authors of this document are the members
of the XML Schema Working Group. 
</p><p>The following changes were made since the last public Working Draft:</p><ul><li><p>As resolution for issue <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=6450">6450</a>: make EBNF for Predicate more precise.</p></li><li><p>As resolution for issue <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=6451">6451</a>: clarify that predicate
counting starts at 1.</p></li><li><p>As resolution for issue <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=6452">6452</a>: Make the rules such that
unprefixed axis names are in no null namespace and are reserved,
that the component kinds are part of a the namespace
"http://www.w3.org/2009/xmlschema-ref", and redefine 
component-kind() to be returning expanded names.</p></li></ul><p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February   
     2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/19482/status">public list of   
     any patent disclosures</a> made in connection with the deliverables   
    of the group; that page also includes instructions for disclosing a   
    patent. An individual who has actual knowledge of a patent which the   
    individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance   
     with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.   
   </p></div><div class="toc">
<h2><a id="contents" name="contents" />Table of Contents</h2><p class="toc">1 <a href="#section-introduction">Introduction (Non-Normative)</a><br />
2 <a href="#section-goals">Goals and Use Cases (Non-Normative)</a><br />
    2.1 <a href="#section-requirements">Requirements</a><br />
    2.2 <a href="#section-usecases">Use Cases</a><br />
3 <a href="#section-scds">Schema Component Designators</a><br />
    3.1 <a href="#section-scd-syntax">Schema Component Designator Syntax</a><br />
    3.2 <a href="#section-canonical">Canonical Schema Component Designators</a><br />
    3.3 <a href="#section-equality">Equality of Schema Component Designators</a><br />
4 <a href="#section-path">Schema Component Paths</a><br />
    4.1 <a href="#section-path-traversal">Schema Component Graph Traversal</a><br />
    4.2 <a href="#section-path-syntax">Schema Component Path Syntax</a><br />
    4.3 <a href="#section-path-interpret">Interpretation of Schema Component Paths</a><br />
    4.4 <a href="#section-axis">Schema Component Path Axes</a><br />
    4.5 <a href="#section-accessors">Accessors</a><br />
    4.6 <a href="#section-canonical-path">Canonical Schema Component Paths</a><br />
    4.7 <a href="#section-equality-path">Equality of Schema Component Paths</a><br />
5 <a href="#section-conformance">Conformance</a><br />
    5.1 <a href="#scp-conformance">Schema Component Path Conformance</a><br />
    5.2 <a href="#scds-conformance">Schema Component Designator Conformance</a><br />
    5.3 <a href="#N1136D">Extensibility</a><br />
6 <a href="#section-example">Examples (Non-Normative)</a><br />
    6.1 <a href="#section-primer-example">Extended Primer Example</a><br />
    6.2 <a href="#section-example-more">Additional Examples</a><br />
    6.3 <a href="#section-examples-abbreviations">Examples with component and elided-component Axes (Non-Normative)</a><br />
</p>
<h3><a id="appendices" name="appendices" />Appendices</h3><p class="toc">A <a href="#properties">Schema Component Properties (Non-Normative)</a><br />
B <a href="#axis-summary">Summary of Component Axes (Non-Normative)</a><br />
C <a href="#normative-glossary">Glossary (Non-Normative)</a><br />
D <a href="#references">References</a><br />
    D.1 <a href="#N11ED1">Normative References</a><br />
    D.2 <a href="#N11FE7">Non-normative Informational References</a><br />
</p></div><hr /><div class="body"><div class="div1">
<h2><a id="section-introduction" name="section-introduction" />1 Introduction (Non-Normative)</h2><p>This document defines a system for designating XML Schema components. Part 1   
of the W3C XML Schema Definition Language (XSD) recommendation    
<a href="#xsd1">[XSD1]</a> defines these    
schema components.    
<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#concepts-data-model">Section 2.2</a>   
lays out the inventory of schema components into   
three classes:   
</p><ul><li><p>Primary components: simple and complex type definitions, attribute   
declarations, and element declarations</p></li><li><p>Secondary components: attribute and model group definitions,   
identity-constraint definitions, and notation declarations</p></li><li><p>"Helper" components: annotations, model groups, particles, wildcards, and   
attribute uses</p></li></ul><p>In addition there is a master schema component, the schema component   
representing the schema as a whole. This component will be   
referred to as the schema description component in this specification.   
</p><p>Finally, there are schema components for the facets defined in Part 2 of the   
W3C XML Schema Definition Language (XSD)   
recommendation <a href="#xsd2">[XSD2]</a>:</p><ul><li><p><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#rf-fund-facets">Fundamental Facets</a>: ordered, bounded, cardinality, numeric</p></li><li><p><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#rf-facets">Constraining Facets</a>: whiteSpace, minInclusive, maxInclusive, minExclusive,   
    maxExclusive, totalDigits, fractionDigits, length, minLength, maxLength,   
    pattern, enumeration   
</p></li></ul><p>Version 1.1 of the W3C XML Schema Definition Language (XSD)   
recommendation     
<a href="#xsd11_1">[XSD11_1]</a><a href="#xsd11_2">[XSD11_2]</a> adds additional components and   
makes modifications to existing components, as well as introducing the notion   
of "property records" to capture more complex structured values.   
</p><p>At first blush, a QName (prefix:localname) may seem sufficient to the   
task of designating any schema component.    
This is not the case for various   
reasons:   
</p><ol class="enumar"><li><p>A QName is only meaningful in the context of particular namespace   
bindings so that the QName can be resolved to a particular    
<a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a>, i.e. a {namespace name, local name}   
pair.    
</p></li><li><p>The same <a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a> can be used in a particular schema to refer
to an
element declaration, an attribute declaration, a complex type or   
simple type definition, a model group definition, an attribute group   
definition, an identity constraint definition, and a notation declaration.   
</p></li><li><p>Locally scoped element and attribute declarations cannot    
necessarily be uniquely   
named by an <a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a>.   
</p></li><li><p>Anonymous type definitions have no    
<a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a>, or they have an    
<a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a> that    
may vary with the   
particular schema processor interpreting the schema.   
</p></li><li><p>Certain schema components (annotation,   
particle, wildcard) are invariably subordinate to   
some other schema component, and    
have no name of their own.</p></li><li><p>Certain schema components (attribute use and model group)   
are subordinate to some other schema component, and any name they might be   
construed to have is a reference to some other schema component (attribute   
declaration and model group definition, respectively).   
</p></li><li><p>The schema   
description schema component has no name at all.</p></li></ol><p>A key technical challenge to obtaining a useful   
system of naming XML Schema components is to address these issues or decide   
that certain cases need not be addressed. In particular:   
</p><ol class="enumar"><li><p>Designators must either include full <a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a>, or define   
namespace bindings.</p></li><li><p>Designators must distinguish named components in   
different symbol spaces from one another.</p></li><li><p>Designators must provide a means of distinguishing locally scoped   
element and attribute declarations with the same name.</p></li><li><p>Designators must provide for any designatable unnamed components, such   
as anonymous type definitions, wildcards, and the   
schema   
description    
component.</p></li><li><p>Designators must function in the face of redefinitions.</p></li></ol><p>The schema description schema component may represent the amalgamation of   
several distinct schema documents, or none at all. It may be associated with   
any number of target namespaces, including none at all. It may have been   
obtained for a particular schema assessment episode by de-referencing URIs given   
in schemaLocation attributes, or by an association with the target namespace or   
by some other application-specific means. In short, there are substantial   
technical challenges to defining a reliable designator for the   
schema description, particularly if that designator is expected to serve as a   
starting point for the other components encompassed by that schema.   
</p><p>This specification divides the problem of constructing schema component   
designators into two parts: defining a designator for an assembled schema, and   
defining a designator for a particular schema component or schema components,   
understood relative to a designated schema. The first task   
is discussed in <a href="#section-scds"><b>3 Schema Component Designators</b></a>, although this specification does   
not define a specific rule for how to construct a single URI for an assembled   
schema. The second task is addressed in detail    
in <a href="#section-path"><b>4 Schema Component Paths</b></a>.     
</p></div><div class="div1">
<h2><a id="section-goals" name="section-goals" />2 Goals and Use Cases (Non-Normative)</h2><div class="div2">
<h3><a id="section-requirements" name="section-requirements" />2.1 Requirements</h3><dl><dt class="label">Basic Functionality</dt><dd><ol class="enumar"><li><p>   
  Each component should have at least one unambiguous designator   
  that designates that component and no other.  However, certain   
  abbreviation and wildcarding constructs may designate collections   
  of components.   
  </p></li><li><p>It should be possible to designate any schema component within a   
  schema. However, some exceptions will be made for certain of the helper   
  components.   
  </p></li><li><p>Designators should provide (or assure) a URI for the unique identification of a schema.   
  </p></li><li><p>If there is more than one designator for a construct, there should be   
  exactly one canonical form of the designator.</p></li><li><p>Designators should be usable for either the XML Schema   
  1.0 or the XML Schema 1.1 component model   
  </p></li></ol></dd><dt class="label">Properties of the Designator</dt><dd><ol class="enumar"><li><p>Designators should be human-readable.</p></li><li><p>Given a designator, it should be possible to get the <a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a> for the   
  designated component, if one exists for that component.   
  </p></li><li><p>It should be possible to    
   generate   
  the canonical designator for each component    
  algorithmically and consistently,    
  either against an assembled   
  schema or as the schema is assembled.</p></li><li><p>Designators should be parsable with compositional semantics (or, in   
other words, they should have <em>expressive notation</em>).</p></li><li><p>There should be a formal specification of what constitutes a legal designator.</p></li></ol></dd><dt class="label">Compatibility</dt><dd><ol class="enumar"><li><p>Designators should be URI references.</p></li><li><p>Designators should work well in a RDDL environment.</p></li></ol></dd><dt class="label">Non-goals</dt><dd><ol class="enumar"><li><p>It is not a requirement to designate particle components as distinct   
  from terms.</p></li><li><p>It is not a requirement that it be possible to   
construct designators to refer to arbitrary schema components without any   
knowledge of schema internals.</p></li><li><p>It is not a requirement to be able to tell, from a schema component   
designator for an element declaration, whether instances of that element   
declaration must appear in document instances with qualified or unqualified   
names.</p></li><li><p>It is not a requirement that it be   
  possible to uniquely assign schema   
  component designators    
  (element, attribute, and type designators) to information   
  items in a document instance given only a set of schema component   
  designators.   
  </p></li></ol></dd></dl></div><div class="div2">
<h3><a id="section-usecases" name="section-usecases" />2.2 Use Cases</h3><dl><dt class="label">Type references</dt><dd><p>In general Schema Component Designators can be used to provide references to   
arbitrary types, whether they are named global types or local or anonymous   
types. These use cases all benefit from being able to refer to any type   
declaration.</p><ul><li><p>Describing the type of an expression, where the type might be an   
  anonymous or local type and a QName is therefore inadequate.   
  There are a number of examples   
  where this could be valuable in type-aware languages that operate on   
  schema-validated XML:   
  </p><ul><li><p>Naming the type of something that has been selected.   
  </p></li><li><p>For use wherever types are named, for example to specify a type in   
  a query expression.</p></li><li><p>Enabling interfaces like those described   
  in <a href="#dom3">[DOM3]</a>    
   to expose anonymous types.</p></li></ul></li><li><p>Identifying types for casting, specifically wrt anonymous   
  and local types.</p></li><li><p>Identifying types for function signatures.   
  </p></li></ul></dd><dt class="label">Element declaration references</dt><dd><p>These use cases benefit from being able to refer to any element declaration.   
</p><ul><li><p>Referring to a local element declaration, with or without   
  knowledge of the names of the scoping types and elements.   
  </p></li></ul></dd><dt class="label">Stand-off schema annotation</dt><dd><p>Schema component designators can be used to refer to specific parts of a   
schema to provide an out-of-band annotation capability, for commentary, error   
reporting, or the association of layered semantics with schema components.   
</p><ul><li><p>Writing error messages. There are two classes of error messages in   
view: errors in an instance and errors in the schema. For example, if an   
instance has a quantity which violates the constraints of a particular type,   
such as a range constraint, it is valuable for the error message to be able to   
name and refer to the specific type whose constraints were violated, even if   
that is the anonymous type of a local element   
declaration. An example of a schema    
error would be that one type is not a valid restriction of another type.   
This use case benefits from being able to name and refer to type, element, and   
attribute declarations, as well as element and attribute uses, groups, and   
possibly facets and particles. It is unclear whether being able to   
refer separately   
to particles versus groups is important. Being able to    
refer separately   
to attribute and element uses versus attribute and element declarations may be   
important.   
</p></li><li><p>Schema documentation. The transfer syntax for W3C XML Schema allows   
  for documentation to be attached to components in-line. In many cases it may   
  be preferable to keep the documentation separate from the active definitions,   
  to save bandwidth, to provide for alternative documentation for different   
  communities, and so on. Being able to refer to any schema component that can   
  support an annotation (all but annotation itself) supports this use case.   
  </p></li><li><p>Commentary on schemas, such as best practices documents, reviews and   
  comparisons of particular schemas, and so on.   
  </p></li><li><p>Associating an additional layer of semantics with schema   
  components, for example, providing information to programming language or   
  application environments to identify code to execute. For example, certain   
  XML data binding frameworks today reference complex types and elements using   
  their own path syntax for the purpose.   
</p></li></ul></dd><dt class="label">Miscellaneous text-based uses within schema-based tools</dt><dd><p>Having a simple textual way to refer to the abstract components of a schema   
enables certain kinds of text-based schema-related processing.</p><ul><li><p>A tool that creates interlinked HTML pages describing a schema.</p></li><li><p>String-based tests of type equivalence. Such tests can be used for   
  comparing serialized PSVIs to provide for interoperable tests of type   
  equivalence and processor comparisons.   
  </p></li><li><p>String-based comparisons of processors generally, making it   
  possible, for example, to ask and   
  answer the question "Did two validations of the same document on   
  different machines use the same type for a given element?"   
   </p></li><li><p>input/output</p></li><li><p>user reports</p></li><li><p>glue/interfaces</p></li></ul></dd><dt class="label">Other</dt><dd><ul><li><p>Simple selection queries, such as "the type that is the base   
  type of X" without knowledge of its name.</p></li><li><p>Creation or initial drafting of a new schema or schema document by   
  selecting components from existing schema.   
  </p></li><li><p>Using XSD simple types as the   
  datatype of RDF literals.</p></li><li><p>Describing XSD Components   
  within RDF, including    
  the use of XSD simple types as RDF   
  classes.</p></li><li><p>   
Formal description requires unique identifier for each declaration and   
definition component used within the context of the validation episode.   
  </p></li><li><p>Enumerating dependencies among schema components. For example, where   
  one complex type restricts another, the local elements in one depend on the   
  local elements of the other.</p></li></ul></dd></dl></div></div><div class="div1">
<h2><a id="section-scds" name="section-scds" />3 Schema Component Designators</h2><p>Schema component designators rely on a layered model of schema   
component reference. Schema component paths designate components in the context   
of a particular schema assembly and depend on a namespace   
binding context.    
Full blown schema designators consist of two parts: a URI   
without a fragment identifier part, which identifies the schema, and a   
fragment identifier which encapsulates a schema component path to designate a   
set of components in the context of that schema.   
   
Schema component paths may be used in contexts other than   
schema component designators, given appropriate specification of the namespace   
binding context and the target schema.     
</p><p>This section describes schema component designators as a whole. The details   
of schema component paths are described in <a href="#section-path"><b>4 Schema Component Paths</b></a>.</p><p>[<a title="schema designator" id="key-sd" name="key-sd">Definition</a>: A <b>schema   
designator</b> is a single URI for a resource representing an   
assembled schema.]   
</p><p>Many possible conventions for obtaining a single URI to refer to a schema   
are possible.   
In the simplest case, where there is one root schema document, the URI of   
that document suffices. In other cases a schema may have been assembled from   
multiple schema documents, or from components obtained via other   
representations, and some   
representation of that collection or of the assembled results will be required.   
</p><p>We expect that it will be   
highly desirable for the community to evolve one convention for referring   
to an assembled schema to   
ensure consistency of global schema component designators. This specification   
declines to specify what that one way should be.   
</p><div class="note"><p class="prefix"><b>Note:</b></p><p>   
Like any resource, the schema denoted by a URI may be   
represented in a variety of forms, with different media types.  When a URI is   
dereferenced, the form and resolution of any fragment identifier depend (as   
specified by <a href="#rfc3986">[RFC 3986]</a>) on the media type of the representation   
obtained.   
The representation of a resource obtained by dereferencing a schema URI   
must therefore allow for the fragment identifier   
syntax defined here in order for schema component   
designators to successfully resolve to components.    
Whatever representation of a schema is used,    
the media type should allow for the fragment identifier syntax defined here.   
This will be true for any XML representation of the schema, since the XPointer   
framework <a href="#xptrframework">[XPTR]</a> is defined for all XML media   
types. Other media types must explicitly specify a compatible fragment   
identifier syntax.   
   
   
</p></div><p>The schema component reference core defines reference to a schema component   
in the context of an assembled XML Schema. <a href="#section-path"><b>4 Schema Component Paths</b></a>   
defines this   
relationship between an assemblage of schema components and component paths.   
Schema assembly is described in   
<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#composition">Section   
4 of XML Schema Part 1: Structures</a>.   
</p><p>For the purposes of component paths, a    
missing component    
(see <a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#conformance-missing">   
Section 5.3 of XML Schema Part 1: Structures</a>)   
cannot be used to   
construct a valid path; nor can a schema component be successfully referenced   
through a path that references a missing component.   
</p><p>[<a title="absolute schema component designator" id="key-scd" name="key-scd">Definition</a>: An   
<b>absolute schema component designator</b> identifies   
a particular schema component; it   
consists of two parts: a designator   
for the assembled schema (a <a title="schema designator" href="#key-sd">schema designator</a>), and a designator for a   
particular schema component or schema components relative (a <a title="relative schema component designator" href="#key-relative-scd">relative   
schema component designator</a>) to that assembled schema.]   
</p><p>Syntactically, the first part is a URI without a fragment   
identifier, and the second part   
is an XPointer fragment identifier. An absolute schema component designator   
therefore is a URI reference.  
For example:    
http://example.org/schemas/po.xsd#xscd(/type::purchaseOrderType)     
</p><p>   
Note that a schema component designator may contain Unicode characters    
that are not allowed in URIs. Any such characters must be encoded and escaped   
to obtain a URI suitable for retrieval, if retrieval is required.   
</p><p>[<a title="relative schema component designator" id="key-relative-scd" name="key-relative-scd">Definition</a>: A   
    <b>relative schema component designator</b>    
    identifies a particular schema component relative to   
    some current assembled schema; it   
    is expressed as an <a href="http://www.w3.org/TR/xptr-framework/#scheme">XPointer scheme</a>   
    <code> xscd()</code> that uses a <a title="schema component path" href="#key-scp">schema component path</a>   
    as the <a href="http://www.w3.org/TR/xptr-framework/#NT-SchemeData">scheme data</a>.]  This   
    XPointer scheme may be used in combination with the   
    <a href="http://www.w3.org/TR/xptr-xmlns/#NT-XmlnsSchemeData"><span>XPointer   
    <code>xmlns()</code> scheme</span></a>   
    <a href="#xptrxmlns">[XPTR XMLNS]</a>.   
    It is not   
    designed to be used in   
    combination with other XPointer schemes.   
 The construction and syntax of schema component paths are described in   
    <a href="#section-path"><b>4 Schema Component Paths</b></a>.   
 </p><div class="div2">
<h3><a id="section-scd-syntax" name="section-scd-syntax" />3.1 Schema Component Designator Syntax</h3>
<h5><a id="N1034B" name="N1034B" />EBNF</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-SchemaComponentDesignator" name="NT-SchemaComponentDesignator" />[1]   </td><td><code>SchemaComponentDesignator</code></td><td>   ::=   </td><td><code><a href="#NT-AbsoluteSchemaComponentDesignator">AbsoluteSchemaComponentDesignator</a> |   
        <a href="#NT-RelativeSchemaComponentDesignator">   
            RelativeSchemaComponentDesignator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbsoluteSchemaComponentDesignator" name="NT-AbsoluteSchemaComponentDesignator" />[2]   </td><td><code>AbsoluteSchemaComponentDesignator</code></td><td>   ::=   </td><td><code><a href="#NT-SchemaDesignator">SchemaDesignator</a> '#'   
        <a href="#NT-RelativeSchemaComponentDesignator">   
            RelativeSchemaComponentDesignator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-SchemaDesignator" name="NT-SchemaDesignator" />[3]   </td><td><code>SchemaDesignator</code></td><td>   ::=   </td><td><code><a href="#NT-AnyURI">AnyURI</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AnyURI" name="NT-AnyURI" />[4]   </td><td><code>AnyURI</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a>*</code></td><td><i>/* IRI reference: no fragment identifier */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-RelativeSchemaComponentDesignator" name="NT-RelativeSchemaComponentDesignator" />[5]   </td><td><code>RelativeSchemaComponentDesignator</code></td><td>   ::=   </td><td><code><a href="#NT-XmlnsPointerPart">XmlnsPointerPart</a>*   
        <a href="#NT-XscdPointerPart">XscdPointerPart</a>   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-XmlnsPointerPart" name="NT-XmlnsPointerPart" />[6]   </td><td><code>XmlnsPointerPart</code></td><td>   ::=   </td><td><code>   
    'xmlns' '(' <a href="http://www.w3.org/TR/xptr-xmlns/#NT-XmlnsSchemeData">XmlnsSchemeData</a> ')'   
    </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-XscdPointerPart" name="NT-XscdPointerPart" />[7]   </td><td><code>XscdPointerPart</code></td><td>   ::=   </td><td><code>'xscd' '(' <a href="#NT-SchemaComponentPath">SchemaComponentPath</a> ')'   
   </code></td></tr></tbody></table></div><div class="div2">
<h3><a id="section-canonical" name="section-canonical" />3.2 Canonical Schema Component Designators</h3><p>[<a title="canonical schema component designator" id="key-canonical-scd" name="key-canonical-scd">Definition</a>:    
A <b>canonical schema component designator</b>   
is an absolute schema component designator that is a URI   
that has been mapped from a LEIRI to an IRI in accordance 
with the rules given in <a href="#leiri">[LEIRI]</a>, mapped from an IRI to a URI in 
accordance with  
the rules given in RFC 3987<a href="#rfc3987">[RFC 3987]</a>, and 
normalized according to the rules of 
syntax-based normalization given there;
and where the relative schema component designator consists of an 
<code>xmlns</code> XPointer pointer part (if required) followed   
by a <a title="canonicalized xscd XPointer pointer part" href="#key-canonicalized-xscd"><span>canonicalized <code>xscd</code> XPointer pointer part</span></a>.   
]</p><p>   
[<a title="canonicalized xscd XPointer pointer part" id="key-canonicalized-xscd" name="key-canonicalized-xscd">Definition</a>:    
A <b><span>canonicalized <code>xscd</code> XPointer pointer part</span></b> is   
  an <code>xscd</code> XPointer pointer part whose   
  pointer data is a canonical schema    
component path.    
]   
</p></div><div class="div2">
<h3><a id="section-equality" name="section-equality" />3.3 Equality of Schema Component Designators</h3><p>Many use cases for schema component designators call for them to be compared   
for equality. A simple string comparison    
   
may fail to correctly recognize equivalent   
designators    
with this scheme   
because namespace prefixes may vary. However, comparison is still   
straightforward.    
</p><p>[<a title="schema component designators are equal" id="key-equal-scd" name="key-equal-scd">Definition</a>: Two   
<b>schema component designators are equal</b> if they are absolute   
and their URIs are equal or if they are relative to the   
same schema, and their <a title="schema component paths are equal" href="#key-equal-path">schema component paths are   
equal</a>.]   
</p></div></div><div class="div1">
<h2><a id="section-path" name="section-path" />4 Schema Component Paths</h2><p>An assembled schema forms a rooted graph of   
schema components and property records, where   
certain schema component and property record   
properties contain other schema components and property   
records as their    
values (or part of their values). The graph arcs are   
directed and    
labelled. The graph may have cycles in it.   
Schema component paths can be regarded as being   
constructed step-by-step by traversing the schema component properties,   
starting at the schema description schema component. Within this graph there may   
be more than one path to a particular schema component.    
This section describes   
   
how paths are interpreted, and then   
defines which paths are the canonical    
ones.    
</p><p>For the purposes of schema component paths, presume the   
existence of an {identity constraint definitions} property of   
the schema description component whose value is the union of all identity   
constraint components in the assembled schema.   
    
The XML Schema 1.1 specification defines   
this property.    
</p><div class="div2">
<h3><a id="section-path-traversal" name="section-path-traversal" />4.1 Schema Component Graph Traversal</h3><p>An assembled schema consists of a graph of schema components.    
Schema property records and helper components are included   
in the graph, but a schema component path never refers to them.  Traversal   
in the graph passes <em>through</em> property records.   
   
   
A schema component property that has other schema   
components as its value   
or as part of its value creates links in the graph which may be traversed    
through one of the defined axes to construct a schema component path.   
   
</p><p>[<a title="arc" id="key-arc" name="key-arc">Definition</a>: A traversal from one component to another   
takes place across some particular component property. This property is    
the <b>arc</b> of traversal.   
]</p><p>[<a title="default arc" id="key-default-arc" name="key-default-arc">Definition</a>: A <b>default   
arc</b> is a privileged    
arc of traversal.   
]   
The default arcs are:   
</p><blockquote><p>{type definition}<br />{content type}<br />{particle}<br />{simple type definition}<br />{attribute declaration}<br />{attribute uses}<br />{model group}<br />{particles}<br />{term}<br />{element declarations}<br />{facets}</p></blockquote><p><a href="#properties"><b>A Schema Component Properties (Non-Normative)</b></a> includes a summary of which    
arcs act   
as defaults and when.</p></div><div class="div2">
<h3><a id="section-path-syntax" name="section-path-syntax" />4.2 Schema Component Path Syntax</h3><div class="div3">
<h4><a id="section-scd-namespaces" name="section-scd-namespaces" />4.2.1 Namespaces</h4><p>The schema component axes defined in this document are considered to be
   names in no namespace.  They are always unprefixed and their names are
   considered reserved.  That is: no extension axis is permitted to have the
   same expanded name as any of the component axes specifically enumerated in
   <a href="#NT-Axis">Axis</a> production.</p><p>The schema component kinds defined in this document are contained in the
   namespace with the URI <code>http://www.w3.org/2009/xmlschema-ref</code>,
   which for the purposes of this specification is taken to be bound to the
   prefix <code>xscd</code>. 
   </p></div><div class="div3">
<h4><a id="section-path-ebnf" name="section-path-ebnf" />4.2.2 EBNF for Schema Component Path Syntax</h4>
<h5><a id="N10443" name="N10443" />Path EBNF</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-SchemaComponentPath" name="NT-SchemaComponentPath" />[8]   </td><td><code>SchemaComponentPath</code></td><td>   ::=   </td><td><code>( <a href="#NT-SchemaStep">SchemaStep</a> |    
          <a href="#NT-StepSeparator">StepSepator</a>   
          <a href="#NT-RelativeSchemaComponentPath">RelativeSchemaComponentPath</a> ) ('/' <a href="#NT-ExtensionAccessor">ExtensionAccessor</a>)? 
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-SchemaStep" name="NT-SchemaStep" />[9]   </td><td><code>SchemaStep</code></td><td>   ::=   </td><td><code>'/'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-RelativeSchemaComponentPath" name="NT-RelativeSchemaComponentPath" />[10]   </td><td><code>RelativeSchemaComponentPath</code></td><td>   ::=   </td><td><code><a href="#NT-Step">Step</a> |   
        <a href="#NT-Step">Step</a>    
        <a href="#NT-StepSeparator">StepSeparator</a>   
        <a href="#NT-RelativeSchemaComponentPath">RelativeSchemaComponentPath</a>   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-StepSeparator" name="NT-StepSeparator" />[11]   </td><td><code>StepSeparator</code></td><td>   ::=   </td><td><code>'/' |    
        <a href="#NT-ComponentAxisSeparator">ComponentAxisSeparator</a>   
    </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-ComponentAxisSeparator" name="NT-ComponentAxisSeparator" />[12]   </td><td><code>ComponentAxisSeparator</code></td><td>   ::=   </td><td><code>'//'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-Step" name="NT-Step" />[13]   </td><td><code>Step</code></td><td>   ::=   </td><td><code><a href="#NT-Axis">Axis</a>    
        <a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>? |   
        <a href="#NT-AbbrevStep">AbbrevStep</a>    
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbbrevStep" name="NT-AbbrevStep" />[14]   </td><td><code>AbbrevStep</code></td><td>   ::=   </td><td><code><a href="#NT-AbbrevAttributeStep">AbbrevAttributeStep</a> |   
        <a href="#NT-AbbrevElementStep">AbbrevElementStep</a> |   
        <a href="#NT-AbbrevTypeStep">AbbrevTypeStep</a> |   
        <a href="#NT-AbbrevCurrentComponentStep">AbbrevCurrentComponentStep</a> |   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbbrevAttributeStep" name="NT-AbbrevAttributeStep" />[15]   </td><td><code>AbbrevAttributeStep</code></td><td>   ::=   </td><td><code>'@' <a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbbrevElementStep" name="NT-AbbrevElementStep" />[16]   </td><td><code>AbbrevElementStep</code></td><td>   ::=   </td><td><code><a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?    
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbbrevTypeStep" name="NT-AbbrevTypeStep" />[17]   </td><td><code>AbbrevTypeStep</code></td><td>   ::=   </td><td><code>'~' <a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-AbbrevCurrentComponentStep" name="NT-AbbrevCurrentComponentStep" />[18]   </td><td><code>AbbrevCurrentComponentStep</code></td><td>   ::=   </td><td><code>'.' <a href="#NT-Predicate">Predicate</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-Axis" name="NT-Axis" />[19]   </td><td><code>Axis</code></td><td>   ::=   </td><td><code>   
      'schemaAttribute' '::' | 'schemaElement' '::' |    
      'type' '::' |   
      'attributeGroup' '::' | 'group' '::' |   
      'identityConstraint' '::' |   
      'assertion' '::' | 'alternative' '::' |   
      'notation' '::' |   
      'model' '::' |   
      'anyAttribute' '::' | 'any' '::' |   
      'facet' '::' |   
      'scope' '::' | 'context' '::' |   
      'substitutionGroup' '::' |   
      'baseType' '::' | 'itemType' '::' | 'memberType' '::' | 'primitiveType' '::' |    
      'key' '::' |   
      'annotation' '::' |   
      'component' '::' | 'currentComponent' '::' |   
      'attributeUse' '::' | 'particle' '::' |   
      <a href="#NT-ExtensionAxis">ExtensionAxis</a>   
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-NameTest" name="NT-NameTest" />[20]   </td><td><code>NameTest</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> |   
   <a href="#NT-WildcardNameTest">WildcardNameTest</a> | '0'    
   </code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-WildcardNameTest" name="NT-WildcardNameTest" />[21]   </td><td><code>WildcardNameTest</code></td><td>   ::=   </td><td><code>'*'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-ExtensionAccessor" name="NT-ExtensionAccessor" />[22]   </td><td><code>ExtensionAccessor</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> '(' ')'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-ExtensionAxis" name="NT-ExtensionAxis" />[23]   </td><td><code>ExtensionAxis</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> '::'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="NT-Predicate" name="NT-Predicate" />[24]   </td><td><code>Predicate</code></td><td>   ::=   </td><td><code>'[' [0]*[1-9][0-9]* ']'</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The EBNF above defines a syntax for invoking an accessor after the   
last step of the path and for using extension axes.  This syntax is included for   
extensibility. A specification that wishes to make use of these extensions must   
define the detailed syntax and semantics    
(see <a href="#section-conformance"><b>5 Conformance</b></a>).   
</p></div></div><div class="div3">
<h4><a id="section-path-examples" name="section-path-examples" />4.2.3 Examples of Schema Component Paths (Non-Normative)</h4><p>The following examples assume the namespace prefixes have been properly   
bound.</p><p>A schema component path referring to the type (either simple or complex)   
whose local name is <code>title</code> and which is in the namespace denoted by   
the prefix <code>my</code>:</p><div class="exampleInner"><pre>/type::my:title</pre></div><p>A schema component path referring to the globally declared element whose   
local name is <code>title</code> and which is in the namespace denoted by the   
prefix <code>my</code>:</p><div class="exampleInner"><pre>/schemaElement::my:title</pre></div><p>A schema component path referring to the globally declared attribute whose   
local name is <code>title</code> and which is in the namespace denoted by the   
prefix <code>my</code>:</p><div class="exampleInner"><pre>/schemaAttribute::my:title</pre></div><p>A schema component path referring to the globally declared attribute group   
whose local name is <code>title</code> and which is in the namespace denoted by   
the prefix <code>my</code>:</p><div class="exampleInner"><pre>/attributeGroup::my:title</pre></div><p>A schema component path referring to the pattern facet of the globally   
declared simple type whose local name is <code>title</code> which is in the   
namespace denoted by <code>my</code>:   
</p><div class="exampleInner"><pre>/type::my:title/facet::pattern</pre></div><p>Given this schema fragment for a schema whose target namespace is denoted by   
the prefix <code>my</code>:</p><div class="exampleInner"><pre>   
&lt;xs:complexType name="articleType"&gt;   
   &lt;xs:sequence&gt;   
      &lt;xs:element ref="my:section"/&gt;   
      &lt;xs:element name="appendix" type="my:sectionType"/&gt;   
   &lt;/xs:sequence&gt;   
&lt;/xs:complexType&gt;   
   
&lt;xs:element name="chapter"&gt;   
   &lt;xs:complexType&gt;   
      &lt;xs:sequence&gt;   
         &lt;xs:element ref="my:title" minOccurs="0" maxOccurs="unbounded"/&gt;   
         &lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;   
      &lt;/xs:sequence&gt;   
      &lt;xs:attribute name="name" type="xs:string"/&gt;   
      &lt;xs:anyAttribute namespace="##other" use="optional"/&gt;   
   &lt;/xs:complexType&gt;   
&lt;/xs:element&gt;   
</pre></div><p>The following schema component path refers to the first element of the named   
complex type:</p><div class="exampleInner"><pre>/type::my:articleType/model::sequence/schemaElement::my:section</pre></div><p>And the following schema component path refers to the second:</p><div class="exampleInner"><pre>/type::my:articleType/model::sequence/schemaElement::my:appendix</pre></div><p>A schema component path referring to the (anonymous) complex type of the   
globally defined element:</p><div class="exampleInner"><pre>/schemaElement::my:chapter/type::0</pre></div><p>A schema component path that refers to the wildcard in the globally defined   
element:</p><div class="exampleInner"><pre>/schemaElement::my:chapter/type::0/model::sequence/any::*</pre></div><p>A schema component path that refers to the attribute of the globally defined   
element:</p><div class="exampleInner"><pre>/schemaElement::my:chapter/type::0/schemaAttribute::name</pre></div></div></div><div class="div2">
<h3><a id="section-path-interpret" name="section-path-interpret" />4.3 Interpretation of Schema Component Paths</h3><p>[<a title="schema component path" id="key-scp" name="key-scp">Definition</a>: A   
<b>schema component path</b> selects a sequence of   
schema components in the context of an assembled schema; it is a series   
of <a title="step" href="#key-scp-step">steps</a> separated by    
'<code>/</code>' or '<code>//</code>'.  Complete schema component paths always   
start with either '<code>/</code>' or '<code>//</code>'.    
]   
</p><p>   
[<a title="step" id="key-scp-step" name="key-scp-step">Definition</a>: A <b>step</b>    
consists of a <a title="axis" href="#key-scp-axis">schema component   
axis</a> and a <a title="schema component name test" href="#key-scp-nametest">schema component name   
test</a> and    
an optional <a title="schema component positional predicate" href="#key-scp-pospred">positional predicate</a>.   
It selects a sequence of schema components that are linked to a   
source component through an arc that matches the axis, pass the name test,   
and are selected by the positional predicate, if any.   
]   
Schema component axes are described in <a href="#section-axis"><b>4.4 Schema Component Path Axes</b></a>.   
</p><p>In general the syntax of a step of the schema component path has the   
following form:   
</p><p>The predicate is optional and there are abbreviated forms for some steps.</p><p>[<a title="schema component name test" id="key-scp-nametest" name="key-scp-nametest">Definition</a>: A    
<b>schema component name   
test</b> is a condition on name of the components selected by the schema   
component path step.] A schema component name test    
either gives a localname, possibly with a namespace prefix, or consists of a   
just the wildcard character ('<code>*</code>'), or just the character zero   
('<code>0</code>').   
</p><p>A schema component name test of this form is true if the QName formed from   
the namespace name and local name specified in the the schema component name   
test is equal to the value of the component-name() accessor of the schema   
component. For more information on namespace binding for QName interpretation   
see <a href="#section-namespaces"><b>4.3.2 Namespaces</b></a>.</p><p>A schema component name test of this form is true   
for anonymous type definitions.  An anonymous type definition's   
component-name() accessor returns "0".   
This name cannot have any conflict with any possible named component, as 0 is   
not a valid name start character.   
</p><p>A schema component name test of this form is true for all linked components   
matching the given axis.</p><p>[<a title="schema component positional predicate" id="key-scp-pospred" name="key-scp-pospred">Definition</a>:     
A <b>schema component positional predicate</b> is a condition on the    
relative position of the component in the sequence of matching components from   
the schema component path step.] A schema component position predicate   
is true if the position of the target component in the sequence of   
components selected by the axis and name test is equal     
to the positive integer given in the predicate.   <span>Counting
starts at 1.</span>
</p><p>   
A path consisting of just '<code>/</code>' selects the schema description   
component.    
</p><p>   
A path of the form <code>/<var>S1</var></code> selects    
components linked to the schema description component in accordance with the   
step <code><var>S1</var></code>.   
</p><p>   
A path of the form <code><var>S1</var>/<var>S2</var></code> is interpreted    
by gathering the sequence of source components and then selecting any    
schema component that is linked to one of the source components in accordance   
with the step <code><var>S2</var></code>.  The sequence of source components   
consists of the sequence of components selected by <code><var>S1</var></code>   
followed by the components selected by the elided-component   
axis on those components.   
</p><p>   
A path of the form <code><var>S1</var>//<var>S2</var></code> is also   
interpreted by gathering the sequence of source components and then selecting   
any schema component that is linked to one of the source components in   
accordance with the step <code><var>S2</var></code>.  In this case the   
sequence of source components consists of the sequence of components selected   
by <code><var>S1</var></code> followed by the application of    
the component axis on members of that sequence.   
</p><p>A path of the form <code><var>S1</var></code> selects all schema components   
linked to the initial source component in accordance with the step   
<code><var>S1</var></code>.    
</p><p>Implementations will have to exercise care to   
properly handle circularities in the component graph in determining the set of   
components matched by a path.   
</p><div class="div3">
<h4><a id="section-incomplete-paths" name="section-incomplete-paths" />4.3.1 Incomplete Schema Component Paths</h4><p>Incomplete schema component paths may be constructed starting at   
some specific source component following the construction rules given here.   
Such paths will not start with a leading slash. Correct interpretation of   
such incomplete (relative) paths depends on the initial source component.   
External specifications sanctioning relative schema component paths must   
therefore define the initial source component to use to interpret the schema   
component path.  In this specification, "schema component path"   
always refers to a complete schema component path starting at the root   
schema description component, unless explicitly stated otherwise.    
</p><p>To emphasize the incompleteness of such paths, the current component step   
syntax may be used (<code>.</code>) for the head step. For example, if   
the initial source component is a complex type, the following paths are   
equivalent and   
designate the element declaration with the QName <code>my:section</code>   
within the sequence model group of that type:   
</p><div class="exampleInner"><pre>model::sequence/schemaElement::my:section</pre></div><div class="exampleInner"><pre>./model::sequence/schemaElement::my:section</pre></div></div><div class="div3">
<h4><a id="section-namespaces" name="section-namespaces" />4.3.2 Namespaces</h4><p>Schema component paths use QNames to refer to schema components.   
Interpretation of these QNames therefore depends on namespace bindings.   
When schema component paths are used in the context of schema component   
designators (<a href="#section-scds"><b>3 Schema Component Designators</b></a>), the <code>xmlns()</code> XPointer   
scheme defines those namespace bindings.  In the context of an XML document the   
namespace prefixes will be bound in the conventional way (using the [in-scope namespaces] property of the element information item). Other host languages and   
some XML applications will define their own namespace binding rules.    
While the <code>xmlns()</code> scheme does not provide for defining a   
default namespace, other mechanisms may do so.  In such contexts, schema   
component paths allow and apply the default namespace.   
</p><p>Note also that the <code>form</code> (and <code>elementFormDefault</code>   
and <code>attributeFormDefault</code>) values apply as well. Since, for example,   
a local attribute declaration component with the form <code>unqualified</code>   
will have an empty <code>{target namespace}</code>, the QName for that   
declaration will have no prefix.   
</p><p>For example, consider the path:</p><div class="exampleInner"><pre>//quantity</pre></div><p>This path   
designates global or local element declarations whose local   
name is <code>quantity</code> and which are either in no   
namespace, are local elements whose form is <code>unqualified</code>,   
or are in the default namespace (assuming there is a such a namespace   
binding).</p><p>For types, form is not relevant.</p><div class="exampleInner"><pre>/~Items//quantity</pre></div><p>This path designates global or local element declarations whose local name   
is <code>quantity</code>, where these declarations   
are in the subgraph represented by the global complex type component whose   
local name is <code>Items</code>.  As in the previous   
example, the element declaration may either be in schema with no target   
namespace, in the default namespace, or a local element declaration with the   
form <code>unqualified</code>. The complex type <code>Items</code> must be in    
the default namespace or in a schema with no target namespace.   
</p><p>This path designates global or local attribute    
declarations whose local name is <code>partNum</code> where these declarations   
are in the subgraph represented by the global complex type component whose   
local name is <code>Items</code>.  Again, the complex type is either in the   
default namespace or in a schema with no target namespace, and the attribute   
declaration must be global attributes in a schema with no target namespace, in   
the default namespace, or be local declarations with the form   
<code>unqualified</code>.    
</p><div class="exampleInner"><pre>/~Items//@partNum</pre></div></div></div><div class="div2">
<h3><a id="section-axis" name="section-axis" />4.4 Schema Component Path Axes</h3><p>   
[<a title="axis" id="key-scp-axis" name="key-scp-axis">Definition</a>: A schema component path <b>axis</b>   
contains specific components linked to the   
current context component through certain kinds of arcs.   
Unless otherwise indicated, an axis applied to   
a component that has no arc of the required kind designates no components.   
]   
</p><div class="div3">
<h4><a id="section-axis-currentComponent" name="section-axis-currentComponent" />4.4.1 The currentComponent Axis</h4><p>[<a title="currentComponent axis" id="axis-currentComponent" name="axis-currentComponent">Definition</a>: The   
<b><span><code>currentComponent</code></span></b> axis contains the current component.   
]   
</p>
<h5><a id="N106EB" name="N106EB" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-CurrentComponentAxis" name="NT-CurrentComponentAxis" />[25]   </td><td><code>CurrentComponentAxis</code></td><td>   ::=   </td><td><code>'currentComponent' '::</code></td></tr></tbody><tbody><tr valign="baseline"><td>[18]   </td><td><a href="#NT-AbbrevCurrentComponentStep"><code>AbbrevCurrentComponentStep</code></a></td><td>   ::=   </td><td><code>'.' <a href="#NT-Predicate">Predicate</a>?</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-annotation" name="section-axis-annotation" />4.4.2 The annotation Axis</h4><p>[<a title="annotation axis" id="axis-annotation" name="axis-annotation">Definition</a>: The   
<b><span><code>annotation</code></span></b> axis contains annotation    
components linked to the current component through {annotation} or   
{annotations} arcs, which are the components returned   
by the annotations() accessor.   
]   
</p>
<h5><a id="N10706" name="N10706" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AnnotationAxis" name="NT-AnnotationAxis" />[26]   </td><td><code>AnnotationAxis</code></td><td>   ::=   </td><td><code>'annotation' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-schemaAttribute" name="section-axis-schemaAttribute" />4.4.3 The schemaAttribute Axis</h4><p>[<a title="schemaAttribute axis" id="axis-schemaAttribute" name="axis-schemaAttribute">Definition</a>: The    
<b><span><code>schemaAttribute</code></span></b> axis contains attribute   
declaration components linked to the current component through   
{attribute declaration} or {attribute declarations} arcs,   
which are those components returned by the component-linked() accessor whose   
component-kind() is equal to <code><span>xscd:</span>attribute-declaration</code>.   
]   
</p>
<h5><a id="N10725" name="N10725" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-SchemaAttributeAxis" name="NT-SchemaAttributeAxis" />[27]   </td><td><code>SchemaAttributeAxis</code></td><td>   ::=   </td><td><code>'schemaAttribute' '::'</code></td></tr></tbody><tbody><tr valign="baseline"><td>[15]   </td><td><a href="#NT-AbbrevAttributeStep"><code>AbbrevAttributeStep</code></a></td><td>   ::=   </td><td><code>'@' <a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?   
   </code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-schemaElement" name="section-axis-schemaElement" />4.4.4 The schemaElement Axis</h4><p>[<a title="schemaElement axis" id="axis-schemaElement" name="axis-schemaElement">Definition</a>: The   
<b><span><code>schemaElement</code></span></b> axis contains element    
declaration components linked to the current component through   
{element declarations}, {term}, {particle},   
{particles}, or {content type}, which are the components returned by the   
term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>element-declaration</code>, together with {element declarations}.   
]   
</p>
<h5><a id="N10746" name="N10746" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-SchemaElementAxis" name="NT-SchemaElementAxis" />[28]   </td><td><code>SchemaElementAxis</code></td><td>   ::=   </td><td><code>'schemaElement' '::'</code></td></tr></tbody><tbody><tr valign="baseline"><td>[16]   </td><td><a href="#NT-AbbrevElementStep"><code>AbbrevElementStep</code></a></td><td>   ::=   </td><td><code><a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?    
   </code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-type" name="section-axis-type" />4.4.5 The type Axis</h4><p>[<a title="type axis" id="axis-type" name="axis-type">Definition</a>: The <b><span><code>type</code></span></b>   
axis contains simple type definition    
and complex type definition components linked to the current component through   
{type definition}, {type definitions}, {content type},   
or {simple type definition} arcs, which are the components    
returned by the component-children() accessor whose    
component-kind() is equal to either   
<code><span>xscd:</span>complex-type-definition</code> or    
<code><span>xscd:</span>simple-type-definition</code>.]   
</p>
<h5><a id="N1076D" name="N1076D" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-TypeAxis" name="NT-TypeAxis" />[29]   </td><td><code>TypeAxis</code></td><td>   ::=   </td><td><code>'type' '::'</code></td></tr></tbody><tbody><tr valign="baseline"><td>[17]   </td><td><a href="#NT-AbbrevTypeStep"><code>AbbrevTypeStep</code></a></td><td>   ::=   </td><td><code>'~' <a href="#NT-NameTest">NameTest</a>    
        <a href="#NT-Predicate">Predicate</a>?   
   </code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-agroup" name="section-axis-agroup" />4.4.6 The attributeGroup Axis</h4><p>[<a title="attributeGroup axis" id="axis-attributeGroup" name="axis-attributeGroup">Definition</a>: The   
<b><span><code>attributeGroup</code></span></b> axis contains     
attribute group definition components linked to the current component through   
{attribute group definitions} arcs, which are those components   
returned by the component-linked() accessor whose component-kind() is equal to   
<code><span>xscd:</span>attribute-group-definition</code>.]    
</p>
<h5><a id="N1078E" name="N1078E" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AttributeGroupAxis" name="NT-AttributeGroupAxis" />[30]   </td><td><code>AttributeGroupAxis</code></td><td>   ::=   </td><td><code>'attributeGroup' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-groupdef" name="section-axis-groupdef" />4.4.7 The group Axis</h4><p>[<a title="group axis" id="axis-group" name="axis-group">Definition</a>: The   
<b><span><code>group</code></span></b> axis contains     
model group definition components linked to the current component through   
{model group definitions} arcs, which are those components returned   
by the component-linked() accessor whose component-kind() is equal to   
<code><span>xscd:</span>model-group-definition</code>.    
]   
</p>
<h5><a id="N107AD" name="N107AD" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-GroupAxis" name="NT-GroupAxis" />[31]   </td><td><code>GroupAxis</code></td><td>   ::=   </td><td><code>'group' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-idc" name="section-axis-idc" />4.4.8 The identityConstraint Axis</h4><p>[<a title="identityConstraint axis" id="axis-identityConstraint" name="axis-identityConstraint">Definition</a>: The   
<b><span><code>identityConstraint</code></span></b> axis contains    
identity constraint definition components linked to the current component   
through {identity constraint definitions} arcs, which are those   
components returned by the component-linked() accessor whose component-kind()   
is equal to <code><span>xscd:</span>identity-constraint-definition</code>.   
]   
</p>
<h5><a id="N107CC" name="N107CC" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-IdentityConstraintAxis" name="NT-IdentityConstraintAxis" />[32]   </td><td><code>IdentityConstraintAxis</code></td><td>   ::=   </td><td><code>'identityConstraint' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-assertion" name="section-axis-assertion" />4.4.9 The assertion Axis</h4><p>[<a title="assertion axis" id="axis-assertion" name="axis-assertion">Definition</a>: The   
<b><span><code>assertion</code></span></b> axis contains    
assertion components linked to the current component   
through {assertions}, {value}, or {facets} arcs, which are those components   
returned by the assertions() accessor.]   
</p>
<h5><a id="N107E5" name="N107E5" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AssertionAxis" name="NT-AssertionAxis" />[33]   </td><td><code>AssertionAxis</code></td><td>   ::=   </td><td><code>'assertion' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-alternative" name="section-axis-alternative" />4.4.10 The alternative Axis</h4><p>[<a title="alternative-axis" id="axis-alternatives" name="axis-alternatives">Definition</a>: The    
<b><span><code>alternative</code></span></b> axis   
contains    
type alternative components linked to the current component   
through {alternatives}, {default type definition}, or {type table} arcs,   
which are those components    
returned by the component-linked() accessor whose component-kind() is   
equal to <code><span>xscd:</span>type-alternative</code>.    
]   
</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The {default type definition} of the type alternatives table of an   
element declaration is actually a type alternative component and will be   
selected by the alternative axis. </p></div>
<h5><a id="N10807" name="N10807" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AlternativeAxis" name="NT-AlternativeAxis" />[34]   </td><td><code>AlternativeAxis</code></td><td>   ::=   </td><td><code>'alternative' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-notation" name="section-axis-notation" />4.4.11 The notation Axis</h4><p>[<a title="notation axis" id="axis-notation" name="axis-notation">Definition</a>: The   
<b><span><code>notation</code></span></b> axis contains    
notation declaration components linked to the current component   
through {notation declarations}   
arcs, which are the components returned by the component-linked() accessor   
whose component-kind() is equal to <code><span>xscd:</span>notation-declaration</code>.]   
</p>
<h5><a id="N10826" name="N10826" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-NotationAxis" name="NT-NotationAxis" />[35]   </td><td><code>NotationAxis</code></td><td>   ::=   </td><td><code>'notation' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-model" name="section-axis-model" />4.4.12 The model Axis</h4><p>[<a title="model axis" id="axis-model" name="axis-model">Definition</a>: The   
<b><span><code>model</code></span></b> axis contains    
model group components linked to the current component   
through {model group}, {term}, {particle}, {particles}, or {content type}   
arcs, which are the components returned by the term() accessor   
whose component-kind() is equal to <code><span>xscd:</span>model-group</code>.   
]   
</p>
<h5><a id="N10845" name="N10845" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ModelAxis" name="NT-ModelAxis" />[36]   </td><td><code>ModelAxis</code></td><td>   ::=   </td><td><code>'model' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-anyAttribute" name="section-axis-anyAttribute" />4.4.13 The anyAttribute Axis</h4><p>[<a title="anyAttribute axis" id="axis-anyAttribute" name="axis-anyAttribute">Definition</a>: The   
<b><span><code>anyAttribute</code></span></b> axis contains    
wildcard components linked to the current component   
through {attribute wildcard} arcs.]   
</p>
<h5><a id="N1085E" name="N1085E" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AnyAttributeAxis" name="NT-AnyAttributeAxis" />[37]   </td><td><code>AnyAttributeAxis</code></td><td>   ::=   </td><td><code>'anyAttribute' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-any" name="section-axis-any" />4.4.14 The any Axis</h4><p>[<a title="any axis" id="axis-any" name="axis-any">Definition</a>: The <b><span><code>any</code></span></b>   
axis contains    
wildcard components linked to the current component   
through {wildcard}, {term}, {particle}, {particles}, {content type}, or   
{open content} arcs, which is the components returned by the   
term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>wildcard</code>. ]   
</p>
<h5><a id="N1087D" name="N1087D" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AnyAxis" name="NT-AnyAxis" />[38]   </td><td><code>AnyAxis</code></td><td>   ::=   </td><td><code>'any' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-facet" name="section-axis-facet" />4.4.15 The facet Axis</h4><p>[<a title="facet axis" id="axis-facet" name="axis-facet">Definition</a>: The   
<b><span><code>facet</code></span></b> axis contains   
facet components linked to the current component   
through {facets} or {fundamental facets} arcs, which is the components returned   
by component-linked() whose component-kind() is equal   
to <code><span>xscd:</span>facet</code>.    
]</p>
<h5><a id="N1089B" name="N1089B" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-FacetAxis" name="NT-FacetAxis" />[39]   </td><td><code>FacetAxis</code></td><td>   ::=   </td><td><code>'facet' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-scope" name="section-axis-scope" />4.4.16 The scope Axis</h4><p>[<a title="scope axis" id="axis-scope" name="axis-scope">Definition</a>: The   
<b><span><code>scope</code></span></b> axis contains    
complex type definition, attribute group definition, or   
model group definition components linked to the current component   
through {scope} and {parent} arcs, which are the components returned from    
the component-scope() accessor.   
]   
</p>
<h5><a id="N108B4" name="N108B4" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ScopeAxis" name="NT-ScopeAxis" />[40]   </td><td><code>ScopeAxis</code></td><td>   ::=   </td><td><code>'scope' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-context" name="section-axis-context" />4.4.17 The context Axis</h4><p>[<a title="context axis" id="axis-context" name="axis-context">Definition</a>: The   
<b><span><code>context</code></span></b> axis contains    
complex type definition, attribute declaration, or   
element declaration components linked to the current component   
through {context} arcs.   
]   
</p>
<h5><a id="N108CD" name="N108CD" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ContextAxis" name="NT-ContextAxis" />[41]   </td><td><code>ContextAxis</code></td><td>   ::=   </td><td><code>'context' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-substitutionGroup" name="section-axis-substitutionGroup" />4.4.18 The substitutionGroup Axis</h4><p>[<a title="substitutionGroup axis" id="axis-substitutionGroup" name="axis-substitutionGroup">Definition</a>: The    
<b><span><code>substitutionGroup</code></span></b> axis contains   
element declaration components linked to the current component   
through {substitution group affiliation} and {substitution group affiliations}    
arcs.   
]   
</p>
<h5><a id="N108E6" name="N108E6" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-SubstitutionGroupAxis" name="NT-SubstitutionGroupAxis" />[42]   </td><td><code>SubstitutionGroupAxis</code></td><td>   ::=   </td><td><code>'substitutionGroup' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-baseType" name="section-axis-baseType" />4.4.19 The baseType Axis</h4><p>[<a title="baseType axis" id="axis-baseType" name="axis-baseType">Definition</a>: The    
<b><span><code>baseType</code></span></b> axis contains   
simple type definition and complex type definition components linked to the   
current component through {base type definition} arcs.   
]   
</p>
<h5><a id="N108FF" name="N108FF" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-BaseTypeAxis" name="NT-BaseTypeAxis" />[43]   </td><td><code>BaseTypeAxis</code></td><td>   ::=   </td><td><code>'baseType' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-itemType" name="section-axis-itemType" />4.4.20 The itemType Axis</h4><p>[<a title="itemType axis" id="axis-itemType" name="axis-itemType">Definition</a>: The   
<b><span><code>itemType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {item type definition} arcs.   
]   
</p>
<h5><a id="N10918" name="N10918" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ItemTypeAxis" name="NT-ItemTypeAxis" />[44]   </td><td><code>ItemTypeAxis</code></td><td>   ::=   </td><td><code>'itemType' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-memberType" name="section-axis-memberType" />4.4.21 The memberType Axis</h4><p>[<a title="memberType axis" id="axis-memberType" name="axis-memberType">Definition</a>: The    
<b><span><code>memberType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {member type definitions}    
arcs. ]   
</p>
<h5><a id="N10931" name="N10931" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-MemberTypeAxis" name="NT-MemberTypeAxis" />[45]   </td><td><code>MemberTypeAxis</code></td><td>   ::=   </td><td><code>'memberType' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-primitiveType" name="section-axis-primitiveType" />4.4.22 The primitiveType Axis</h4><p>[<a title="primitiveType axis" id="axis-primitiveType" name="axis-primitiveType">Definition</a>: The    
<b><span><code>primitiveType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {primitive type definition}    
arcs.]</p>
<h5><a id="N10949" name="N10949" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-PrimitiveTypeAxis" name="NT-PrimitiveTypeAxis" />[46]   </td><td><code>PrimitiveTypeAxis</code></td><td>   ::=   </td><td><code>'primitiveType' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-referencedKey" name="section-axis-referencedKey" />4.4.23 The key Axis</h4><p>[<a title="key axis" id="axis-key" name="axis-key">Definition</a>: The <b><span><code>key</code></span></b>   
axis contains   
identity constraint definition components linked to the   
current component through {referenced key}    
arcs.]   
</p>
<h5><a id="N10962" name="N10962" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-KeyAxis" name="NT-KeyAxis" />[47]   </td><td><code>KeyAxis</code></td><td>   ::=   </td><td><code>'key' '::'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-attributeUse" name="section-axis-attributeUse" />4.4.24 The attributeUse Axis</h4><p>[<a title="attributeUse axis" id="axis-attributeUse" name="axis-attributeUse">Definition</a>: The   
<b><span><code>attributeUse</code></span></b> axis contains attribute use components   
linked to the current component through {attribute uses}.   
]   
</p>
<h5><a id="N1097B" name="N1097B" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-AttributeUseAxis" name="NT-AttributeUseAxis" />[48]   </td><td><code>AttributeUseAxis</code></td><td>   ::=   </td><td><code>'attributeUse' '::</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-particle" name="section-axis-particle" />4.4.25 The particle Axis</h4><p>[<a title="particle axis" id="axis-particle" name="axis-particle">Definition</a>: The   
<b><span><code>particle</code></span></b> axis contains particle components   
linked to the current component through {particles}.   
]   
</p>
<h5><a id="N10994" name="N10994" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ParticleAxis" name="NT-ParticleAxis" />[49]   </td><td><code>ParticleAxis</code></td><td>   ::=   </td><td><code>'particle' '::</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-component" name="section-axis-component" />4.4.26 The component Axis</h4><p>[<a title="component axis" id="axis-component" name="axis-component">Definition</a>: The   
<b><span><code>component</code></span></b> axis contains the transitive closure of   
schema    
components that are either linked to the schema description component or that   
are linked to current component through default arcs.  That is, it contains    
the transitive   
closure of the component-children() accessor, as well as   
component-linked()    
accessor if the schema description is the current component.   
]</p>
<h5><a id="N109AC" name="N109AC" /></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="NT-ComponentAxis" name="NT-ComponentAxis" />[50]   </td><td><code>ComponentAxis</code></td><td>   ::=   </td><td><code>'component' '::'</code></td></tr></tbody><tbody><tr valign="baseline"><td>[12]   </td><td><a href="#NT-ComponentAxisSeparator"><code>ComponentAxisSeparator</code></a></td><td>   ::=   </td><td><code>'//'</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="section-axis-elided-component" name="section-axis-elided-component" />4.4.27 The elided-component Axis</h4><p>[<a title="elided-component axis" id="axis-elided-component" name="axis-elided-component">Definition</a>: The    
<b><span><code>elided-component</code></span></b> axis contains complex type   
definitions    
linked to the current component through the {type definition} arc and the   
transitive closure of all model group components linked to the current   
component. That is, it contains the transitive closure of components returned   
from the term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>model-group</code>, as well as components linked to the current component   
through the {type definition} arc.   
]   
</p><p>There is no syntax for this axis: it is used to define the semantics of   
certain paths.</p></div></div><div class="div2">
<h3><a id="section-accessors" name="section-accessors" />4.5 Accessors</h3><p>A set of accessors is defined on schema components.  For consistency, each   
accessor is defined for every kind of schema component,   
although several accessors return a constant empty value on some kinds of   
schema components.</p><p>Where accessors return sequences, the order of components   
accessed on one arc is as defined by the schema component model.  Components   
accessed through default arcs precede components accessed through non-default   
arcs.  Components are otherwise ordered as if arcs were accessed in the   
following order:    
</p><ul><li><p>{type definitions}</p></li><li><p>{type definition}</p></li><li><p>{base type definition}</p></li><li><p>{item type definition}</p></li><li><p>{member type definitions}</p></li><li><p>{primitive type definition}</p></li><li><p>{type table}</p></li><li><p>{alternatives}</p></li><li><p>{default type definition}</p></li><li><p>{simple type definition}</p></li><li><p>{element declarations}</p></li><li><p>{substitution group affiliations}</p></li><li><p>{substitution group affiliation}</p></li><li><p>{attribute declarations}</p></li><li><p>{attribute declaration}</p></li><li><p>{model group definitions}</p></li><li><p>{attribute group definitions}</p></li><li><p>{scope}</p></li><li><p>{parent}</p></li><li><p>{context}</p></li><li><p>{content type}</p></li><li><p>{particles}</p></li><li><p>{particle}</p></li><li><p>{term}</p></li><li><p>{model group}</p></li><li><p>{attribute uses}</p></li><li><p>{open content}</p></li><li><p>{wildcard}</p></li><li><p>{attribute wildcard}</p></li><li><p>{identity constraint definitions}</p></li><li><p>{referenced key}</p></li><li><p>{assertions}</p></li><li><p>{notation declarations}</p></li><li><p>{facets}</p></li><li><p>{fundamental facets}</p></li><li><p>{annotation}</p></li><li><p>{annotations}</p></li></ul><div class="div3">
<h4><a id="accessor-component-kind" name="accessor-component-kind" />4.5.1 component-kind Accessor</h4><p>The component-kind accessor returns <span>an <a href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/#dt-expname">expanded name</a></span>
identifying the kind of the schema component. </p><table border="0" cellspacing="5" summary="component-kind accessor details"><thead><tr><th align="left">Component</th><th align="left">Result of component-kind()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top"><span>xscd:</span>attribute-declaration</td></tr><tr><td valign="top">Element Declaration</td><td valign="top"><span>xscd:</span>element-declaration</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top"><span>xscd:</span>complex-type-definition</td></tr><tr><td valign="top">Attribute Use</td><td valign="top"><span>xscd:</span>attribute-use</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top"><span>xscd:</span>attribute-group-definition</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top"><span>xscd:</span>model-group-definition</td></tr><tr><td valign="top">Model Group</td><td valign="top"><span>xscd:</span>model-group</td></tr><tr><td valign="top">Particle</td><td valign="top"><span>xscd:</span>particle</td></tr><tr><td valign="top">Wildcard</td><td valign="top"><span>xscd:</span>wildcard</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top"><span>xscd:</span>identity-constraint-definition</td></tr><tr><td valign="top">Type Alternative</td><td valign="top"><span>xscd:</span>type-alternative</td></tr><tr><td valign="top">Assertion</td><td valign="top"><span>xscd:</span>assertion</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top"><span>xscd:</span>notation-declaration</td></tr><tr><td valign="top">Annotation</td><td valign="top"><span>xscd:</span>annotation</td></tr><tr><td valign="top">Schema</td><td valign="top"><span>xscd:</span>schema</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top"><span>xscd:</span>simple-type-definition</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top"><span>xscd:</span>facet</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top"><span>xscd:</span>facet</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-component-name" name="accessor-component-name" />4.5.2 component-name Accessor</h4><p>The component-name accessor returns zero or one xs:QName values giving the   
name of the component.</p><table border="0" cellspacing="5" summary="component-name accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of component-name()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">the xs:QName formed   
from the {name} and {target namespace} properties</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">the xs:QName formed   
from the {name} and {target namespace} properties</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">the xs:QName   
formed from the {name} and {target namespace} properties; "0", if   
{name} is absent</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">the xs:QName   
formed from the {name} and {target namespace} properties</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top">the xs:QName formed   
from the {name} and {target namespace} properties</td></tr><tr><td valign="top">Model Group</td><td valign="top">the xs:QName formed from   
an empty namespace name and the value of the component-variety() accessor as   
the local name</td></tr><tr><td valign="top">Particle</td><td valign="top">empty</td></tr><tr><td valign="top">Wildcard</td><td valign="top">empty</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top">the xs:QName   
formed from the {name} and {target namespace} properties</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">empty</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">the xs:QName formed   
from the {name} and {target namespace} properties; "0", if {name} is   
absent    
</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">the xs:QName   
formed with an empty namespace name and the value of the component-variety()   
accessor as the local name</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">the xs:QName formed   
with an empty namespace name and the value of the component-variety() accessor   
as the local name</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-component-variety" name="accessor-component-variety" />4.5.3 component-variety Accessor</h4><p>The component-variety accessor returns zero or one strings identifying the   
specific variety of that component kind.   
</p><table border="0" cellspacing="5" summary="component-variety accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of component-variety()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">   
"global"   
if {scope} is "global" or if the value of the   
{variety} property of {scope} is "global" (1.1);    
"local" otherwise</td></tr><tr><td valign="top">Element Declaration </td><td valign="top">"global"   
if {scope} is "global" or if the value of the {variety} property of {scope} is   
"global" (1.1);    
"local" otherwise</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">the value of   
the {variety} property of the {content type} (1.1). Under the XML Schema 1.0   
component model, there is no such property; instead returns "empty"   
if the {content type} property has the value "empty",   
"simple" if the {content type} property has a simple type declaration   
as its value, "element-only" or "mixed" if the {content type} has a pair as a   
value and that string is a member of the pair</td></tr><tr><td valign="top">Attribute Use </td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group Definition </td><td valign="top">empty</td></tr><tr><td valign="top">Model Group </td><td valign="top">the value of the   
{compositor} property, one of "sequence", "choice", and "all"</td></tr><tr><td valign="top">Particle</td><td valign="top">empty</td></tr><tr><td valign="top">Wildcard</td><td valign="top">the value of the    
{process contents} property, one of "strict", "lax", and "skip"   
</td></tr><tr><td valign="top">Identity‑Constraint Definition </td><td valign="top">the value   
of the {identity-constraint category} property, one of "key",   
"keyref", and "unique"</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">empty</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration </td><td valign="top">empty</td></tr><tr><td valign="top">Annotation </td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">empty</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">the value of the   
{variety} property, one of "atomic", "union", and "list"</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">the facet variety,   
e.g. "minLength" for the minLength facet, and so on</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">the facet variety,   
e.g. "numeric" for the numeric facet, and so on</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-component-children" name="accessor-component-children" />4.5.4 component-children Accessor</h4><p>The component-children accessor returns a sequence of schema components   
consisting of all the components immediately accessible through default axes,   
skipping minor components that produce no steps in the schema component path.   
</p><table border="0" cellspacing="5" summary="component-children accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of component-children()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">the value of {type definition}</td></tr><tr><td valign="top">Element Declaration </td><td valign="top">the value of {type definition}</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">   
the value of {attribute uses} and;   
if the value of the component-variety() accessor is "empty" then empty,   
if the value of the component-variety() accessor is "simple" then the value of   
{simple type definition} (1.1) or the value of {content type} (1.0);    
otherwise the value of the term() accessor   
</td></tr><tr><td valign="top">Attribute Use </td><td valign="top">the value of {attribute declaration}</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">the    
value {attribute declaration} for each Attribute Use in {attribute uses}   
</td></tr><tr><td valign="top">Model Group Definition </td><td valign="top">the value of   
{model group}</td></tr><tr><td valign="top">Model Group </td><td valign="top">the value of   
the {term} of each Particle in {particles}</td></tr><tr><td valign="top">Particle</td><td valign="top">the value of {term}</td></tr><tr><td valign="top">Wildcard</td><td valign="top">empty</td></tr><tr><td valign="top">Identity‑Constraint Definition </td><td valign="top">empty</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">the value of {type definition}</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration </td><td valign="top">empty</td></tr><tr><td valign="top">Annotation </td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">the value of {element declarations}</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">the value of {facets}</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">empty</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-component-linked" name="accessor-component-linked" />4.5.5 component-linked Accessor</h4><p>The component-linked accessor returns a sequence of schema components   
immediately accessible using any axis, skipping minor components that produce   
no steps in the schema component path.   
</p><table border="0" cellspacing="5" summary="component-linked accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of component-linked()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">   
the value of the component-children() and annotations() accessors,    
together with the {scope} (1.0) or the {parent} of {scope} (1.1)    
</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">   
the value of the component-children() and annotations() accessors,   
together with the value of {scope} and {substitution group affiliation}    
(1.0) or the value of {substitution group affiliations}, the value of the   
{parent} of {scope},    
the value of the {alternatives} and {default type definition} of {type table}   
(1.1), along with the value of {identity constraint definitions}   
</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">   
the value of component-children() and annotations() accessors,   
together with the value of {base type definition}, {context},    
{attribute wildcard}, and {assertions} and the value of {wildcard} of    
{open content} of {content type}   
</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">   
the value of the component-children() and annotations() accessors   
</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">the    
value of the component-children() and annotations() accessors,   
as well as the value of {attribute wildcard}   
</td></tr><tr><td valign="top">Model Group Definition </td><td valign="top">   
the value of the component-children() and annotations() accessors   
</td></tr><tr><td valign="top">Model Group</td><td valign="top">the value of   
the component-children() and annotations() accessors</td></tr><tr><td valign="top">Particle</td><td valign="top">the value of the   
component-children() accessor</td></tr><tr><td valign="top">Wildcard</td><td valign="top">the value of the   
annotations() accessor</td></tr><tr><td valign="top">Identity‑Constraint Definition </td><td valign="top">the value of the annotations() accessor, together with the value   
of {referenced key}</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">the value of   
the component-childrenl() and annotations() accessors</td></tr><tr><td valign="top">Assertion</td><td valign="top">the value of the   
annotations() accessor</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">the value of   
the annotations() accessor</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">   
the value of the component-children() and annotations() accessors, as well as   
the value of {type definitions}, {attribute declarations}, {attribute group   
definitions}, {model group definitions}, {notation declarations}, and   
{identity-constraint definitions}</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">the value of   
the component-children() and annotations() accessors, together with the value   
of {context}, {base type definition}, {fundamental facets}, {primitive type   
definition}, {item type definition}, and {member type definitions}</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">the value of the   
annotations() accessor, together with the value of {value} in the case that the   
facet is the "assertions" facet</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-term" name="accessor-term" />4.5.6 term Accessor</h4><p>The term accessor returns term components linked through the   
{model group} or {term} arcs, possibly via {particle}, {particles}, or {content   
type} arcs.</p><table border="0" cellspacing="5" summary="term accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of term()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">   
the value of {term} of {particle} of {content type} (1.1) or the value of   
{term} of {content type} (1.0),    
together with the value of {wildcard} of    
{open content} of {content type}   
</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top">value of {model group}</td></tr><tr><td valign="top">Model Group</td><td valign="top">empty</td></tr><tr><td valign="top">Particle</td><td valign="top">the value of {term}</td></tr><tr><td valign="top">Wildcard</td><td valign="top">empty</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">empty</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">empty</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">empty</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-component-scope" name="accessor-component-scope" />4.5.7 component-scope Accessor</h4><p>The component-scope accessor returns components linked through the   
{scope} possibly via {parent} arcs.</p><table border="0" cellspacing="5" summary="component-scope accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of component-context()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">   
if component-variety() is "global" then empty; otherwise   
the value of {parent} of {scope} (1.1) or the value of {scope} (1.0)   
</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">   
if component-variety() is "global" then empty; otherwise   
the value of {parent} of {scope} (1.1) or the value of {scope} (1.0)   
</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group</td><td valign="top">empty</td></tr><tr><td valign="top">Particle</td><td valign="top">empty</td></tr><tr><td valign="top">Wildcard</td><td valign="top">empty</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">empty</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">empty</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">empty</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-assertions" name="accessor-assertions" />4.5.8 assertions Accessor</h4><p>The assertions accessor returns assertions components linked through the   
{assertions} or {value} arcs. The assertions   
accessor is always empty for the 1.0 schema component model.</p><table border="0" cellspacing="5" summary="assertions accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of assertions()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">the value of {assertions}</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">empty</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Model Group</td><td valign="top">empty</td></tr><tr><td valign="top">Particle</td><td valign="top">empty</td></tr><tr><td valign="top">Wildcard</td><td valign="top">empty</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">empty</td></tr><tr><td valign="top">Assertion</td><td valign="top">empty</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">empty</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">empty</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">empty</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">empty</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty unless   
the facet name is "assertions"; the value of {value} otherwise</td></tr></tbody></table></div><div class="div3">
<h4><a id="accessor-annotations" name="accessor-annotations" />4.5.9 annotations Accessor</h4><p>The annotations accessor returns annotations components linked through the   
{annotation} or {annotations} arc.   
</p><table border="0" cellspacing="5" summary="annotations accessor details"><thead><tr><th align="left" valign="top">Component</th><th align="left" valign="top">Result of annotations()</th></tr></thead><tbody><tr><td valign="top">Attribute Declaration</td><td valign="top">the value of   
{annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Element Declaration</td><td valign="top">the value of   
{annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Complex Type Definition</td><td valign="top">   
the value of {annotations}   
</td></tr><tr><td valign="top">Attribute Use</td><td valign="top">the value of   
{annotations}</td></tr><tr><td valign="top">Attribute Group Definition</td><td valign="top">the value of {annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Model Group Definition</td><td valign="top">the   
value of {annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Model Group</td><td valign="top">the value of   
{annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Particle</td><td valign="top">the value of {annotations}</td></tr><tr><td valign="top">Wildcard</td><td valign="top">the value of {annotation}   
(1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Identity‑Constraint Definition</td><td valign="top">the value of {annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Type Alternative</td><td valign="top">the value of {annotations}</td></tr><tr><td valign="top">Assertion</td><td valign="top">the value of {annotations}</td></tr><tr><td valign="top">Notation Declaration</td><td valign="top">the value   
of {annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Annotation</td><td valign="top">empty</td></tr><tr><td valign="top">Schema</td><td valign="top">the value of {annotations}</td></tr><tr><td valign="top">Simple Type Definition</td><td valign="top">the   
value of {annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Constraining Facet</td><td valign="top">the value of   
{annotation} (1.0) or {annotations} (1.1)</td></tr><tr><td valign="top">Fundamental Facet</td><td valign="top">empty</td></tr></tbody></table></div></div><div class="div2">
<h3><a id="section-canonical-path" name="section-canonical-path" />4.6 Canonical Schema Component Paths</h3><p>[<a title="canonical schema component path" id="key-canonical-schema-component-path" name="key-canonical-schema-component-path">Definition</a>: The <b>canonical schema   
component path</b> of a component is a distinguished valid component path   
that uniquely identifies that particular component, that has as few steps as   
possible, and that can be deterministically constructed starting from the schema description component, and that contains no   
extension axes or accessors.   
]</p><p>The remainder of this section consists of a constructive definition of   
canonical schema component paths: a path produced by this construction will be   
the canonical one.</p><p>[<a title="current schema component" id="key-current-component" name="key-current-component">Definition</a>: The   
    <b>current schema component</b> is a schema component for which   
    there is a valid canonical path through the schema component graph.]</p><p>[<a title="target schema component" id="key-target-component" name="key-target-component">Definition</a>: The   
    <b>target schema component</b> is a schema component linked to the   
    current schema component via one of the schema component properties   
    defined previously.]</p><p>[<a title="component relationship" id="key-component-relationship" name="key-component-relationship">Definition</a>: The   
    <b>component relationship</b> is the name of the schema component   
    property on the current schema component which references the target schema   
    component.   
]</p><p>[<a title="ancestor set" id="key-ancestor-set" name="key-ancestor-set">Definition</a>: The   
    <b>ancestor set</b> of the target schema component is the set of schema   
    components on the valid canonical path to the current schema component   
    together with the current schema component.]</p><p>[<a title="base type set" id="key-base-type-set" name="key-base-type-set">Definition</a>:    
The <b>base type set</b> of a schema component is the set   
consisting of the {base type definition} of that schema component and   
the {base type definition} of every member of the set.   
]</p><p>Constructively,  this set can be computed by adding the   
{base type definition} to the set, and iterating on that type component, until   
you see a component whose {target namespace} property is   
"http://www.w3.org/2001/XMLSchema" and whose {name} property is   
"anyType".   
</p><p>[<a title="extended base type set" id="key-extended-base-type-set" name="key-extended-base-type-set">Definition</a>: The <b>extended base type   
set</b> of a schema component is   
the set consisting of the {base type definition} of that schema component if   
its {derivation} method is "extension" and the {base type definition} of   
every member of the set whose {derivation} method is "extension".   
]   
</p><p>[<a title="base facet set" id="key-base-facet-set" name="key-base-facet-set">Definition</a>: The <b>base facet set</b> of a schema   
component is the set consisting of all members of the {facets} property of   
members of the base type set of that schema component.]   
</p><p>[<a title="same (facets)" id="key-same-facet" name="key-same-facet">Definition</a>: Two facets are <b>the same</b> if they   
are the same kind of component (e.g. both are length facets) and their {value}   
properties have identical values.]</p><p>[<a title="base attribute use set" id="key-base-attribute-use-set" name="key-base-attribute-use-set">Definition</a>: The <b>base attribute use   
set</b> of a schema component is the set consisting of all members of the   
{attribute uses} property of members of the base type set of that schema   
component.]   
</p><p>[<a title="same (attribute uses)" id="key-same-attr-uses" name="key-same-attr-uses">Definition</a>: Two attribute uses are <b>the   
same</b> if the {name} and {target namespace} of their {attribute   
declaration} properties are equal. ]   
</p><p>(Note that this is not equality which requires checking the {type definition}   
as well. However, the rules for component consistency will ensure that   
checking the {name} and {target namespace} suffices for our purposes here.)   
</p><p>[<a title="particle set" id="key-particle-set" name="key-particle-set">Definition</a>: The <b>particle set</b> of a schema   
component is the set consisting   
of the {content type} of that schema component with the members of the   
{particles} property of the {term} of any member of the set.]   
</p><p>[<a title="base particle set" id="key-base-particle-set" name="key-base-particle-set">Definition</a>: The <b>base particle set</b> of a   
schema component is the union of all particle sets of all the members of the   
extended base type set of that schema component.]   
</p><p>[<a title="same (particles)" id="key-same-particle" name="key-same-particle">Definition</a>: Two particles are <b>the same</b> if   
the implementation reports them as the same.] Informally,   
implementations will report particles that are "inherited" from base types as   
"the same" as the corresponding particle in the base type. Future revisions of   
the XML Schema recommendation will specify more precisely the conditions under   
which particles should be regarded as "the same".   
</p><p>Traversal where the current schema component   
    is the schema description   
component to any target schema component   
    is always permitted in the construction of a   
canonical path. If the current schema component is not the schema description   
schema component, then traversal from the current schema component   
to the target schema component is forbidden in the construction of a canonical   
path if any of the following conditions is met:</p><ol class="enumar"><li><p>the target schema component is an identity constraint definition</p></li><li><p>the target schema component is a simple or complex type   
definition whose {name} property is not absent</p></li><li><p>the target schema component is an element or attribute declaration   
whose {scope} property is <code>global</code></p></li><li><p>the target schema component has a {scope} property whose value is a   
schema component and that schema component is not a member of the   
ancestor set of the target schema component</p></li><li><p>the component relationship is {scope},   
{substitution group affiliation},    
{primitive type definition}, or {referenced key}</p></li><li><p>the component relationship is {base type definition}   
and target schema component's {name} property is not absent</p></li><li><p>the target schema component is a facet and there exists some facet in   
its base facet set of the target schema component that is the same as the   
facet</p></li><li><p>the current schema component is a complex type, the target schema   
component is the {attribute declaration} of an attribute use component and there   
exists some attribute use in the base attribute use set of the current   
schema component that is the same as the attribute use whose {attribute   
declaration} is the target schema component</p></li><li><p>the target schema component is the {term} of a particle and there   
exists some particle in the base particle set of the current schema component   
that  is the same as the target schema component</p></li></ol><p>Informally, the first two conditions ensure that the canonical path to   
an identity constraint or a named type is the one that flows directly from the   
schema description component, the third condition ensures that the canonical   
path to element and attribute declarations is likewise the global one (if there   
is one), the fourth   
condition accounts for element and attribute declarations stemming from named   
model groups and attribute groups, the fifth and sixth ensure that the   
canonical path doesn't follow "backwards" paths (while accounting for   
redefined types), and the final three   
conditions ensure the canonical path to "inherited" components goes   
through their component of origin.</p><p>Because the 1.0 component model provides no reliable   
ordering of annotations, selection of a specific annotation using a numerical   
predicate is forbidden in canonical paths against a 1.0 schema.  For 1.1   
schemas, an individual annotation component is selected using a numerical   
predicate.</p><p>In general, it is not possible to obtain the canonical path for a   
schema component without access to the schema component graph. In particular,   
canonicalizing some non-canonical path, or determining whether a schema   
component path is canonical cannot be performed without such access.   
</p><p>For example, consider the path   
<code>/type::x:foo/schemaElement::x:bar</code>.   
</p><p>For this schema fragment, this represents a canonical path to the local   
element <code>bar</code>:</p><div class="exampleInner"><pre>   
&lt;complexType name="foo"&gt;   
  &lt;sequence&gt;   
     &lt;element name="bar" type="x:barType"/&gt;   
  &lt;/sequence&gt;   
&lt;/complexType&gt;   
</pre></div><p>But for the following schema fragment,   
the same path   
represents a non-canonical path. The    
canonical path would instead be <code>/group::x:barGroup/schemaElement::x:bar</code>.   
</p><div class="exampleInner"><pre>   
&lt;group name="barGroup"&gt;   
  &lt;sequence&gt;   
     &lt;element name="bar" type="x:barType"/&gt;   
  &lt;/sequence&gt;   
&lt;/group&gt;   
&lt;complexType name="foo"&gt;   
  &lt;sequence&gt;   
    &lt;group ref="x:barGroup"/&gt;   
  &lt;/sequence&gt;   
&lt;/complexType&gt;   
</pre></div><div class="div3">
<h4><a id="section-canonical-syntax" name="section-canonical-syntax" />4.6.1 Canonical Syntax</h4><p>The concrete syntax allows certain abbreviations, such as   
        eliding the positional predicate where it is   
        unnecessary to distinguish components,    
        wildcarded schema component name tests   
        (<code>*</code>), and abbreviated steps   
        (e.g. <code>@name</code>)    
        .   
        Canonical path syntax forbids all these abbreviations. In addition, the   
        canonical path syntax fixes the namespace prefix, if any, to   
        <code>p</code>. Since at most one namespace can be involved in a   
        canonical schema component path, one prefix suffices.    
        Finally, use of the current component, component, and   
        elided-component axes are disallowed in the canonical path   
        syntax, and the use of the particle and attributeUse axes are   
        disallowed except in the last step of the path.    
        </p></div></div><div class="div2">
<h3><a id="section-equality-path" name="section-equality-path" />4.7 Equality of Schema Component Paths</h3><p>[<a title="schema component paths are equal" id="key-equal-path" name="key-equal-path">Definition</a>: Two <b>schema component paths are   
equal</b> if they have the same number of   
steps, and each step in one path is equal to the corresponding   
step in the other. Steps are equal if they have the same   
axis, name test (namespace and local name, or wildcard), and predicate.   
.]   
</p><p>Note: This definition of equality neither relies on the notion of 'the same   
component' nor defines component equivalence. A schema component may have   
multiple schema component paths. Although these schema component paths address   
'the same component', they are not equal. It is true, however, that two   
canonical paths to the same component will be equal.</p></div></div><div class="div1">
<h2><a id="section-conformance" name="section-conformance" />5 Conformance</h2><div class="div2">
<h3><a id="scp-conformance" name="scp-conformance" />5.1 Schema Component Path Conformance</h3><p>Schema component paths may be used by other specifications.   
For such usage, this specification does not define any criteria   
for conformance and relies on other specifications to specify   
criteria for conformance of implementations.   
</p><p>Such specifications must define:   
</p><ul><li><p>How the target schema is identified.</p></li><li><p>How namespace binding applies to schema component paths, in particular   
how or whether the default namespace applies.</p></li><li><p>Whether only canonical schema component paths are   
permitted.</p></li><li><p>Whether only complete schema component paths are permitted.</p></li><li><p>If incomplete schema component paths are permitted, how the initial   
source component is determined.</p></li><li><p>Whether any extension axes are defined, together with their syntax   
and semantics.</p></li><li><p>Whether any extension accessors are defined, together with their   
syntax and semantics.</p></li></ul></div><div class="div2">
<h3><a id="scds-conformance" name="scds-conformance" />5.2 Schema Component Designator Conformance</h3><p>   
This specification normatively depends on the XPointer Framework    
<a href="#xptrframework">[XPTR]</a>.   
</p><p>Conforming XPointer processors claiming to support the   
<code>xscd()</code> scheme must    
identify schema components as   
defined in this specification and   
conform to the XPointer <code>xmlns()</code> scheme   
specification.    
</p></div><div class="div2">
<h3><a id="N1136D" name="N1136D" />5.3 Extensibility</h3><p>Schema component paths and designators navigate the XML Schema component   
model and are wholly dependent on that model to define the set of allowable   
axes and referenced components.  Therefore, as the schema component model   
changes, this specification may add additional axes, mapping rules, and   
accessors as required to support those changes.    
The EBNF defines syntax for extension accessors after the last step in a path   
and for extension axes.     
</p></div></div><div class="div1">
<h2><a id="section-example" name="section-example" />6 Examples (Non-Normative)</h2><div class="div2">
<h3><a id="section-primer-example" name="section-primer-example" />6.1 Extended Primer Example</h3><p>This section walks through an example XML Schema Document from the XML   
Schema Part 0: Primer<a href="#xsd0">[XSD0]</a> and   
  enumerates the abbreviated and canonical schema component designators for schema components.</p><p>All schema constructs in this section are considered to be in the following   
  schema document and its URI is <code>schema-URI</code>:</p><div class="exampleInner"><pre>   
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;   
&lt;!-- elided... see below ... --&gt;   
&lt;/xsd:schema&gt;   
</pre></div><p>Since this schema has no target namespace, no namespace   
  binding is required and there is no <code>xmlns()</code> pointer part for any   
  of the schema component designators for this schema.</p><p>The canonical schema component designator for this schema description   
component is <code>schema-URI#xscd(/)</code>.</p><div class="exampleInner"><pre>   
&lt;xsd:annotation&gt;   
 &lt;xsd:documentation xml:lang="en"&gt;   
  Purchase order schema for Example.com.   
  Copyright 2000 Example.com. All rights reserved.   
 &lt;/xsd:documentation&gt;   
&lt;/xsd:annotation&gt;   
</pre></div><p>The canonical schema component designator for this annotation schema component   
  is <code>schema-URI#xscd(/annotation::*)</code>.</p><p>The following is a global element declaration:</p><div class="exampleInner"><pre>   
&lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;   
</pre></div><p>The abbreviated schema component designator for this element declaration component   
  is <code>schema-URI#xscd(/purchaseOrder)</code> and the canonical is   
  <code>schema-URI#xscd(/schemaElement::purchaseOrder)</code>.</p><p>The following is another global element declaration, </p><div class="exampleInner"><pre>   
 &lt;xsd:element name="comment" type="xsd:string"/&gt;   
</pre></div><p>The abbreviated schema component designator for this element declaration   
  component is <code>schema-URI#xscd(/comment)</code> and the canonical is   
  <code>schema-URI#xscd(/schemaElement::comment)</code>.</p><p>This following is a global complex type definition component:</p><div class="exampleInner"><pre>   
&lt;xsd:complexType name="PurchaseOrderType"&gt;   
 &lt;xsd:sequence&gt;   
  &lt;xsd:element name="shipTo" type="USAddress"/&gt;   
  &lt;xsd:element name="billTo" type="USAddress"/&gt;   
  &lt;xsd:element ref="comment" minOccurs="0"/&gt;   
  &lt;xsd:element name="items"  type="Items"/&gt;   
 &lt;/xsd:sequence&gt;   
 &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;   
&lt;/xsd:complexType&gt;   
</pre></div><p>The abbreviated schema component designator for this complex type definition   
  and its element and attribute declaration components are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/~purchaseOrderType)   
schema-URI#xscd(/~purchaseOrderType/shipTo)   
schema-URI#xscd(/~purchaseOrderType/billTo)   
schema-URI#xscd(/comment)   
schema-URI#xscd(/~purchaseOrderType/items)   
schema-URI#xscd(/~purchaseOrderType/@orderDate)   
</pre></div><p>The canonical schema component designator for this complex type definition and   
  its element and attribute declaration components are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/type::purchaseOrderType)   
schema-URI#xscd(/type::purchaseOrderType/model::sequence/schemaElement::shipTo)   
schema-URI#xscd(/type::purchaseOrderType/model::sequence/schemaElement::billTo)   
schema-URI#xscd(/schemaElement::comment)   
schema-URI#xscd(/type::purchaseOrderType/model::sequence/schemaElement::items)   
schema-URI#xscd(/type::purchaseOrderType/schemaAttribute::orderDate)   
</pre></div><p>The following is another global complex type definition component:</p><div class="exampleInner"><pre>   
&lt;xsd:complexType name="USAddress"&gt;   
 &lt;xsd:sequence&gt;   
  &lt;xsd:element name="name"   type="xsd:string"/&gt;   
  &lt;xsd:element name="street" type="xsd:string"/&gt;   
  &lt;xsd:element name="city"   type="xsd:string"/&gt;   
  &lt;xsd:element name="state"  type="xsd:string"/&gt;   
  &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;   
 &lt;/xsd:sequence&gt;   
 &lt;xsd:attribute name="country" type="xsd:NMTOKEN"   
     fixed="US"/&gt;   
&lt;/xsd:complexType&gt;   
</pre></div><p>The abbreviated schema component designator for this complex type definition   
  and its element and attribute declaration components are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/~USAddress)   
schema-URI#xscd(/~USAddress/name)   
schema-URI#xscd(/~USAddress/street)   
schema-URI#xscd(/~USAddress/city)   
schema-URI#xscd(/~USAddress/state)   
schema-URI#xscd(/~USAddress/zip)   
schema-URI#xscd(/~USAddress/@country)   
</pre></div><p>The canonical schema component designator for this complex type definition and its   
  element and attribute declaration components are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/type::USAddress)   
schema-URI#xscd(/type::USAddress/model::sequence/schemaElement::name)   
schema-URI#xscd(/type::USAddress/model::sequence/schemaElement::street)   
schema-URI#xscd(/type::USAddress/model::sequence/schemaElement::city)   
schema-URI#xscd(/type::USAddress/model::sequence/schemaElement::state)   
schema-URI#xscd(/type::USAddress/model::sequence/schemaElement::zip)   
schema-URI#xscd(/type::USAddress/schemaAttribute::country)   
</pre></div><p>The following is a global complex type definition with anonymous complex type and   
  simple type definition components:</p><div class="exampleInner"><pre>   
&lt;xsd:complexType name="Items"&gt;   
 &lt;xsd:sequence&gt;   
  &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;   
   &lt;xsd:complexType&gt;   
    &lt;xsd:sequence&gt;   
     &lt;xsd:element name="productName" type="xsd:string"/&gt;   
     &lt;xsd:element name="quantity"&gt;   
      &lt;xsd:simpleType&gt;   
       &lt;xsd:restriction base="xsd:positiveInteger"&gt;   
        &lt;xsd:maxExclusive value="100"/&gt;   
       &lt;/xsd:restriction&gt;   
      &lt;/xsd:simpleType&gt;   
     &lt;/xsd:element&gt;   
     &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;   
     &lt;xsd:element ref="comment"   minOccurs="0"/&gt;   
     &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;   
    &lt;/xsd:sequence&gt;   
    &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;   
   &lt;/xsd:complexType&gt;   
  &lt;/xsd:element&gt;   
 &lt;/xsd:sequence&gt;   
&lt;/xsd:complexType&gt;   
</pre></div><p>The abbreviated schema component designator for this complex type definition   
  and its element and attribute declaration, simple type definition, and facet   
  components are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/~Items)   
schema-URI#xscd(/~Items/item)   
schema-URI#xscd(/~Items/item/~0))   
schema-URI#xscd(/~Items/item/productName)   
schema-URI#xscd(/~Items/item/quantity)   
schema-URI#xscd(/~Items/item/quantity/~0)   
schema-URI#xscd(/~Items/item/quantity/~0/facet::maxExclusive)   
schema-URI#xscd(/~Items/item/USPrice)   
schema-URI#xscd(/comment)   
schema-URI#xscd(/~Items/item/shipDate)   
schema-URI#xscd(/~Items/item/@partNum)   
</pre></div><p>The canonical schema component designator for this complex type definition and its   
element and attribute declaration, simple type definition, and facet   
components are (paths broken across lines for   
readability):</p><div class="exampleInner"><pre>   
schema-URI#xscd(/type::Items)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::productName)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::quantity)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::quantity/type::0)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::quantity/type::0/   
     facet::maxExclusive)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::USPrice)   
schema-URI#xscd(/schemaElement::comment)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     model::sequence/schemaElement::shipDate)   
schema-URI#xscd(/type::Items/model::sequence/schemaElement::item/type::0/   
     schemaAttribute::partNum)   
</pre></div><p>The following is a global simple type definition component:</p><div class="exampleInner"><pre>   
&lt;!-- Stock Keeping Unit, a code for identifying products --&gt;   
&lt;xsd:simpleType name="SKU"&gt;   
 &lt;xsd:restriction base="xsd:string"&gt;   
  &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;   
 &lt;/xsd:restriction&gt;   
&lt;/xsd:simpleType&gt;   
</pre></div><p>The canonical schema component designator for this simple type definition   
  and its facet component are:</p><div class="exampleInner"><pre>   
schema-URI#xscd(/type::SKU)   
schema-URI#xscd(/type::SKU/facet::pattern)   
</pre></div></div><div class="div2">
<h3><a id="section-example-more" name="section-example-more" />6.2 Additional Examples</h3><p>The schema for the examples in the previous section had no   
target namespace. If we change the schema so that the target namespace is   
<code>"http://example.com/schema/po"</code>, then the schema   
component designators need to take namespace bindings into account.   
</p><p>For example, the abbreviated schema component designator for the   
complex type definition <code>USAddress</code> and its element and attribute   
declaration components are:</p><div class="exampleInner"><pre>   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/p:name)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/p:street)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/p:city)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/p:state)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/p:zip)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/~p:USAddress/@country)   
</pre></div><p>Note that since the <code>attributeFormDefault</code> for the   
schema is <code>unqualified</code> (the default value), no namespace prefix is   
used with the <code>country</code> attribute.</p><p>The canonical schema component designator for this complex type   
definition and its element and attribute declaration components are (paths   
broken across lines for readability):</p><div class="exampleInner"><pre>   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    model::sequence/schemaElement::p:name)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    model::sequence/schemaElement::p:street)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    model::sequence/schemaElement::p:city)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    model::sequence/schemaElement::p:state)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    model::sequence/schemaElement::p:zip)   
schema-URI#xmlns(p=http://example.com/schema/po)xscd(/type::p:USAddress/   
    schemaAttribute::country)   
</pre></div><p>Schema component paths may also be used in other contexts that   
provide namespace binding contexts.  For example, an XML representation may   
apply normal namespace binding rules to apply to embedded schema component   
paths:   
</p><div class="exampleInner"><pre>   
&lt;xsx:ui xmlns:err="http://example.com/extension/ui"    
        xmlns:p="http://example.com/schema/po"&gt;   
  &lt;xsx:component&gt;   
     &lt;xsx:path&gt;/~p:USAddress/p:state&lt;/xsx:path&gt;   
     &lt;xsx:prompt&gt;State&lt;/xsx:prompt&gt;   
     &lt;xsx:display&gt;selector&lt;/xsx:display&gt;   
     &lt;xsx:choices&gt;http://example.com/state-menu.xml&lt;/xsx:choices&gt;   
     &lt;xsx:tab&gt;Address&lt;/xsx:tab&gt;   
  &lt;/xsx:component&gt;   
&lt;/xsx:ui&gt;   
</pre></div><p>Another possible means of binding namespaces is to use the namespace URI as   
the schema designator with the convention that it is the default namespace.   
This could be useful combined with the use of just the schema component paths   
in the fragment identifier to obtain terse identifiers for global schema types   
in single-namespace schemas:   
</p><div class="exampleInner"><pre>   
http://www.w3.org/2001/XMLSchema#/~gMonth   
</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not define such a fragment identifier scheme   
for namespace documents.  Neither does it rule out such a usage.   
</p></div></div><div class="div2">
<h3><a id="section-examples-abbreviations" name="section-examples-abbreviations" />6.3 Examples with component and elided-component Axes (Non-Normative)</h3><p>The following examples assume that the namespace prefixes   
<code>r</code> and <code>ipo</code> are appropriately bound.</p><p>Here is a path that designates an attribute declaration whose local name is   
<code>period</code> in the namespace denoted by   
<code>r</code> in an anonymous complex type:   
</p><div class="exampleInner"><pre>/r:purchaseReport/type::0/@period</pre></div><p>Using the   
elided-component axis to select the attribute    
declaration directly from the element declaration, this path reduces to:   
</p><div class="exampleInner"><pre>/r:purchaseReport/@period</pre></div><p>Here is a path that designates an    
element   
declaration whose local name is    
<code>name</code> in the namespace denoted by   
<code>ipo</code>   
in a globally defined type:   
</p><div class="exampleInner"><pre>/type::ipo:USAddress/model::sequence/model::sequence[1]/name</pre></div><p>   
Using the elided-component axis to select the element   
declaration directly from the complex type definition,   
this path reduces to:</p><div class="exampleInner"><pre>/type::ipo:USAddress/name</pre></div><p>This path designates an element declaration whose local name is   
<code>regions</code>    
in the namespace denoted by   
<code>r</code>   
in an anonymous complex type:   
</p><div class="exampleInner"><pre>/r:purchaseReport/type::0/model::sequence/r:regions</pre></div><p>Using the elided-component axis to select   
the element declaration r:regions directly from the element declaration   
r:purchaseReport, this path reduces to:</p><div class="exampleInner"><pre>/r:purchaseReport/r:regions</pre></div><p>This path   
designates global or local element declarations whose local   
name is <code>quantity</code> in the namespace denoted by <code>r</code>:</p><div class="exampleInner"><pre>//r:quantity</pre></div><p>This path designates global or local element declarations whose   
local name is <code>quantity</code> in the namespace denoted   
by <code>r</code>, where these declarations    
are in the subgraph represented by the global complex type component whose   
local name is <code>Items</code> in the namespace denoted by   
<code>r</code>:   
</p><div class="exampleInner"><pre>/~r:Items//r:quantity</pre></div><p>This path designates global or local attribute    
declarations whose local name is <code>partNum</code> in the   
namespace denoted by <code>r</code>   
where these declarations are in the subgraph represented by the global complex   
type component whose    
local name is <code>Items</code>   
in the namespace denoted by <code>r</code>:</p><div class="exampleInner"><pre>/~r:Items//@partNum</pre></div><p>This extended example works against the following schema   
  fragment for a schema with no target namespace:   
</p><div class="exampleInner"><pre>   
&lt;xs:element name="example" type="aType"/&gt;   
   
&lt;xs:complexType name="aType"&gt;   
   &lt;xs:sequence&gt;   
      &lt;xs:element name="foo"/&gt;   
      &lt;xs:group ref="aGroup"/&gt;   
   &lt;/xs:sequence&gt;   
&lt;/xs:complexType&gt;   
   
&lt;xs:group name="aGroup"&gt;   
   &lt;xs:sequence&gt;   
      &lt;xs:element name="bar"&gt;   
         &lt;xs:complexType&gt;   
           &lt;xs:sequence&gt;   
              &lt;xs:element ref="foo"/&gt;   
              &lt;xs:element ref="a"/&gt;   
           &lt;/xs:sequence&gt;   
         &lt;/xs:complexType&gt;   
      &lt;/xs:element&gt;   
   &lt;/xs:sequence&gt;   
&lt;/xs:group&gt;   
   
&lt;xs:element name="foo"/&gt;   
</pre></div><p>   
Which of the following paths can be shortened to <code>//foo</code> using the   
component and elided-component axes?   
</p><table border="0" cellspacing="5" summary="//foo"><thead><tr><th>Path</th><th>Shortened to <code>//foo</code>?</th></tr></thead><tbody><tr><td><code>/group::aGroup/model::sequence/bar/~0/model::sequence/foo</code></td><td>No</td></tr><tr><td><code>/~aType/model::sequence/foo</code></td><td>Yes</td></tr><tr><td><code>/~aType/model::sequence/model::sequence/bar/~0/foo</code></td><td>No</td></tr><tr><td><code>/root/~aType/model::sequence/foo</code></td><td>Yes</td></tr><tr><td><code>/root/~aType/model::sequence/model::sequence/bar/~0/foo</code></td><td>No</td></tr></tbody></table><p>The "no" answers are all because <code>bar</code> is not selected   
by either the component axis or the elided-component axis and must therefore   
appear in the path.</p></div></div></div><div class="back"><div class="div1">
<h2><a id="properties" name="properties" />A Schema Component Properties (Non-Normative)</h2><p>Schema component paths rely on the schema component graph implicit in   
the assembled collection of schema components and their properties. The   
following table details which properties are used for defining schema component   
paths, and whether they are used to define links in the graph   
(traversed) or just referenced for some other purpose. Traversals marked with a   
star (*) are the default axis of traversal.    
</p><table border="2" rules="rows" cellspacing="5" cellpadding="5" summary="Use of Schema Component Properties"><thead><tr><th>Component or Property Record</th><th>Property</th><th>Use</th></tr></thead><tbody><tr><th rowspan="8">Attribute Declaration</th></tr><tr><td>{type definition}</td><td>traversed *</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{scope}</td><td>traversed</td></tr><tr><td>{value constraint}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="3">Scope Property Record</th></tr><tr><td>{variety}</td><td>referenced</td></tr><tr><td>{parent}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="16">Element Declaration</th></tr><tr><td>{type definition}</td><td>traversed *</td></tr><tr><td>{identity-constraint definitions}</td><td>traversed</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{type table}</td><td>traversed</td></tr><tr><td>{scope}</td><td>traversed</td></tr><tr><td>{value constraint}</td><td>none</td></tr><tr><td>{nillable}</td><td>none</td></tr><tr><td>{substitution group affiliation}</td><td>traversed</td></tr><tr><td>{substitution group affiliations}</td><td>traversed</td></tr><tr><td>{substitution group exclusions}</td><td>none</td></tr><tr><td>{disallowed substitutions}</td><td>none</td></tr><tr><td>{abstract}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="3">Type Table Property Record</th></tr><tr><td>{alternatives}</td><td>traversed</td></tr><tr><td>{default type definition}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="14">Complex Type Definition</th></tr><tr><td>{base type definition}</td><td>traversed</td></tr><tr><td>{attribute uses}</td><td>traversed</td></tr><tr><td>{attribute wildcard}</td><td>traversed</td></tr><tr><td>{content type}</td><td>traversed *</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{context}</td><td>traversed</td></tr><tr><td>{derivation method}</td><td>none</td></tr><tr><td>{final}</td><td>none</td></tr><tr><td>{abstract}</td><td>none</td></tr><tr><td>{prohibited substitutions}</td><td>none</td></tr><tr><td>{assertions}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="5">Content Type Property Record</th></tr><tr><td>{variety}</td><td>referenced</td></tr><tr><td>{particle}</td><td>traversed *</td></tr><tr><td>{simple type definition}</td><td>traversed</td></tr><tr><td>{open content}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="3">Open Content Property Record</th></tr><tr><td>{mode}</td><td>none</td></tr><tr><td>{wildcard}</td><td>traversed *</td></tr></tbody><tbody><tr><th rowspan="5">Attribute Use</th></tr><tr><td>{attribute declaration}</td><td>traversed *</td></tr><tr><td>{value constraint}</td><td>none</td></tr><tr><td>{required}</td><td>none</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr></tbody><tbody><tr><th rowspan="7">Attribute Group Definition</th></tr><tr><td>{attribute uses}</td><td>traversed *</td></tr><tr><td>{attribute wildcard}</td><td>traversed</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr></tbody><tbody><tr><th rowspan="6">Model Group Definition</th></tr><tr><td>{model group}</td><td>traversed *</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr></tbody><tbody><tr><th rowspan="5">Model Group</th></tr><tr><td>{particles}</td><td>traversed *</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{compositor}</td><td>referenced</td></tr></tbody><tbody><tr><th rowspan="5">Particle</th></tr><tr><td>{term}</td><td>traversed *</td></tr><tr><td>{min occurs}</td><td>none</td></tr><tr><td>{max occurs}</td><td>none</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr></tbody><tbody><tr><th rowspan="5">Wildcard</th></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{namespace constraint}</td><td>none</td></tr><tr><td>{process contents}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="9">Identity-constraint Definition</th></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{identity-constraint category}</td><td>none</td></tr><tr><td>{selector}</td><td>none</td></tr><tr><td>{fields}</td><td>none</td></tr><tr><td>{referenced key}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="4">Type Alternative</th></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{test}</td><td>none</td></tr><tr><td>{type definition}</td><td>traversed *</td></tr></tbody><tbody><tr><th rowspan="3">Assertion</th></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{test}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="7">Notation Declaration</th></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{public identifier}</td><td>none</td></tr><tr><td>{system identifier}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="4">Annotation</th></tr><tr><td>{application information}</td><td>none</td></tr><tr><td>{user information}</td><td>none</td></tr><tr><td>{attributes}</td><td>none</td></tr></tbody><tbody><tr><th rowspan="9">Schema</th></tr><tr><td>{type definitions}</td><td>traversed</td></tr><tr><td>{attribute declarations}</td><td>traversed</td></tr><tr><td>{element declarations}</td><td>traversed *</td></tr><tr><td>{attribute group definitions}</td><td>traversed</td></tr><tr><td>{model group definitions}</td><td>traversed</td></tr><tr><td>{notation declarations}</td><td>traversed</td></tr><tr><td>{identity constraint definitions}</td><td>traversed</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr></tbody><tbody><tr><th rowspan="14">Simple Type Definition</th></tr><tr><td>{base type definition}</td><td>traversed</td></tr><tr><td>{facets}</td><td>traversed *</td></tr><tr><td>{fundamental facets}</td><td>traversed</td></tr><tr><td>{item type definition}</td><td>traversed</td></tr><tr><td>{member type definitions}</td><td>traversed</td></tr><tr><td>{context}</td><td>traversed</td></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{name}</td><td>referenced</td></tr><tr><td>{target namespace}</td><td>referenced</td></tr><tr><td>{variety}</td><td>referenced</td></tr><tr><td>{final}</td><td>none</td></tr><tr><td>{primitive type definition}</td><td>traversed</td></tr></tbody><tbody><tr><th rowspan="5">Facets</th></tr><tr><td>{annotation}</td><td>traversed (special)</td></tr><tr><td>{annotations}</td><td>traversed (special)</td></tr><tr><td>{value}</td><td>traversed * (assertions only)</td></tr><tr><td>{fixed}</td><td>none</td></tr></tbody></table></div><div class="div1">
<h2><a id="axis-summary" name="axis-summary" />B Summary of Component Axes (Non-Normative)</h2><p>The following table details all the axes, the source and target component   
kinds, a brief syntax summary, and indicates whether the axis is a default one.   
</p><table border="2" rules="rows" cellspacing="5" cellpadding="5" summary="Summary of Component Axes"><thead><tr><th>Axis</th><th>Source Component</th><th>Target Component</th><th>Syntax</th><th>Default?</th></tr></thead><tbody><tr><th rowspan="2">(root)</th></tr><tr><td>N/A</td><td>Schema</td><td>/</td><td>no</td></tr></tbody><tbody><tr><th rowspan="11">annotations</th></tr><tr><td>Attribute Declaration</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Attribute Group Definition</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Element Declaration</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Facet</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Model Group Definition</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Notation Declaration</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Schema</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Simple Type Definition</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr><tr><td>Wildcard</td><td>Annotation</td><td><code>annotation::*</code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="3">attribute declarations</th></tr><tr><td>Attribute Use</td><td>Attribute Declaration</td><td><code>schemaAttribute::<var>qname</var></code></td><td>yes</td></tr><tr><td>Schema</td><td>Attribute Declaration</td><td><code>schemaAttribute::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">attribute group definitions</th></tr><tr><td>Schema</td><td>Attribute Group Definition</td><td><code>attributeGroup::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="3">attribute uses</th></tr><tr><td>Complex Type Definition</td><td>Attribute Use</td><td>N/A</td><td>no</td></tr><tr><td>Attribute Group Definition</td><td>Attribute Use</td><td>N/A</td><td>yes</td></tr></tbody><tbody><tr><th rowspan="3">attribute wildcard</th></tr><tr><td>Complex Type Definition</td><td>Attribute Wildcard</td><td><code>anyAttribute::*</code></td><td>no</td></tr><tr><td>Attribute Group Definition</td><td>Attribute Wildcard</td><td><code>anyAttribute::*</code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="4">base type definition</th></tr><tr><td rowspan="2">Complex Type Definition</td><td>Simple Type Definition</td><td><code>baseType::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>baseType::<var>qname</var></code></td><td>no</td></tr><tr><td>Simple Type Definition</td><td>Simple Type Definition</td><td><code>baseType::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">content type</th></tr><tr><td>Complex Type Definition</td><td>Complex Type Definition</td><td><code>type::<var>qname</var></code></td><td>yes</td></tr></tbody><tbody><tr><th rowspan="2">element declarations</th></tr><tr><td>Schema</td><td>Element Declaration</td><td><code>schemaElement::<var>qname</var></code></td><td>yes</td></tr></tbody><tbody><tr><th rowspan="2">facets</th></tr><tr><td>Simple Type Definition</td><td>Facet</td><td><code>facet::<var>name</var></code></td><td>yes</td></tr></tbody><tbody><tr><th rowspan="2">fundamental facets</th></tr><tr><td>Simple Type Definition</td><td>Fundamental Facet</td><td><code>facet::<var>name</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="3">identity constraint definitions</th></tr><tr><td>Element Declaration</td><td>Identity-constraint Definition</td><td><code>identityConstraint::<var>qname</var></code></td><td>no</td></tr><tr><td>Schema</td><td>Identity-constraint Definition</td><td><code>identityConstraint::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">item type definition</th></tr><tr><td>Simple Type Definition</td><td>Simple Type Definition</td><td><code>itemType::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">member type definitions</th></tr><tr><td>Simple Type Definition</td><td>Simple Type Definition</td><td><code>memberType::<var>qname</var></code>[n]</td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">model group</th></tr><tr><td>Model Group Definition</td><td>Model Group</td><td><code>model::<var>compositor</var>[<var>n</var>]</code></td><td>yes</td></tr></tbody><tbody><tr><th rowspan="2">model group definitions</th></tr><tr><td>Schema</td><td>Model Group Definition</td><td><code>group::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">notation declarations</th></tr><tr><td>Schema</td><td>Notation Declaration</td><td><code>notation::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">particles</th></tr><tr><td>Model Group</td><td>Particle</td><td>N/A</td><td>yes</td></tr></tbody><tbody><tr><th rowspan="2">primitive type definition</th></tr><tr><td>Simple Type Definition</td><td>Simple Type Definition</td><td><code>primitivetype::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">referenced key</th></tr><tr><td>Identity-constraint Definition</td><td>Identity-constraint Definition</td><td><code>key::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="7">scope</th></tr><tr><td rowspan="3">Attribute Declaration</td><td>Simple Type Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr><tr><td>Attribute Group Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr><tr><td rowspan="3">Element Declaration</td><td>Simple Type Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr><tr><td>Model Group Definition</td><td><code>scope::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="7">context</th></tr><tr><td rowspan="2">Complex Type Definition</td><td>Element Declaration</td><td><code>context::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>context::<var>qname</var></code></td><td>no</td></tr><tr><td rowspan="4">Simple Type Definition</td><td>Element Declaration</td><td><code>context::<var>qname</var></code></td><td>no</td></tr><tr><td>Attribute Declaration</td><td><code>context::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>context::<var>qname</var></code></td><td>no</td></tr><tr><td>Simple Type Definition</td><td><code>context::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">substitution group affiliation</th></tr><tr><td>Element Declaration</td><td>Element Declaration</td><td><code>substitutionGroup::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="4">term</th></tr><tr><td rowspan="3">Particle</td><td>Element Declaration</td><td><code>schemaElement::<var>qname</var>[<var>n</var>]</code></td><td>yes</td></tr><tr><td>Model Group</td><td><code>model::compositor[<var>n</var>]</code></td><td>yes</td></tr><tr><td>Wildcard</td><td><code>any::*[<var>n</var>]</code></td><td>yes</td></tr></tbody><tbody><tr><th rowspan="7">type definitions</th></tr><tr><td rowspan="2">Attribute Declaration</td><td>Simple Type Definition</td><td><code>type::<var>qname</var></code></td><td>yes</td></tr><tr><td>Complex Type Definition</td><td><code>type::<var>qname</var></code></td><td>yes</td></tr><tr><td rowspan="2">Element Declaration</td><td>Simple Type Definition</td><td><code>type::<var>qname</var></code></td><td>yes</td></tr><tr><td>Complex Type Definition</td><td><code>type::<var>qname</var></code></td><td>yes</td></tr><tr><td rowspan="2">Schema</td><td>Simple Type Definition</td><td><code>type::<var>qname</var></code></td><td>no</td></tr><tr><td>Complex Type Definition</td><td><code>type::<var>qname</var></code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="3">assertions</th></tr><tr><td>Complex Type Definition</td><td>Assertion</td><td><code>assertion::*[<var>n</var>]</code></td><td>no</td></tr><tr><td>Facet</td><td>Assertion</td><td><code>assertion::*[<var>n</var>]</code></td><td>no</td></tr></tbody><tbody><tr><th rowspan="2">alternatives</th></tr><tr><td>Element Declaration</td><td>Type Alternative</td><td><code>alternative::*[<var>n</var>]</code></td><td>no</td></tr></tbody></table></div><div class="div1">
<h2><a id="normative-glossary" name="normative-glossary" />C Glossary (Non-Normative)</h2><p>The listing below is for the benefit of readers of a printed version of this document:   
  it collects together all the definitions which appear in the document above.</p><dl><dt><a href="#key-scd">absolute schema component designator</a></dt><dd>An   
<b>absolute schema component designator</b> identifies   
a particular schema component; it   
consists of two parts: a designator   
for the assembled schema (a <a title="schema designator" href="#key-sd">schema designator</a>), and a designator for a   
particular schema component or schema components relative (a <a title="relative schema component designator" href="#key-relative-scd">relative   
schema component designator</a>) to that assembled schema.</dd><dt><a href="#axis-alternatives">alternative-axis</a></dt><dd>The    
<b><span><code>alternative</code></span></b> axis   
contains    
type alternative components linked to the current component   
through {alternatives}, {default type definition}, or {type table} arcs,   
which are those components    
returned by the component-linked() accessor whose component-kind() is   
equal to <code><span>xscd:</span>type-alternative</code>.    
</dd><dt><a href="#key-ancestor-set">ancestor set</a></dt><dd>The   
    <b>ancestor set</b> of the target schema component is the set of schema   
    components on the valid canonical path to the current schema component   
    together with the current schema component.</dd><dt><a href="#axis-annotation">annotation axis</a></dt><dd>The   
<b><span><code>annotation</code></span></b> axis contains annotation    
components linked to the current component through {annotation} or   
{annotations} arcs, which are the components returned   
by the annotations() accessor.   
</dd><dt><a href="#axis-anyAttribute">anyAttribute axis</a></dt><dd>The   
<b><span><code>anyAttribute</code></span></b> axis contains    
wildcard components linked to the current component   
through {attribute wildcard} arcs.</dd><dt><a href="#axis-any">any axis</a></dt><dd>The <b><span><code>any</code></span></b>   
axis contains    
wildcard components linked to the current component   
through {wildcard}, {term}, {particle}, {particles}, {content type}, or   
{open content} arcs, which is the components returned by the   
term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>wildcard</code>. </dd><dt><a href="#key-arc">arc</a></dt><dd>A traversal from one component to another   
takes place across some particular component property. This property is    
the <b>arc</b> of traversal.   
</dd><dt><a href="#axis-assertion">assertion axis</a></dt><dd>The   
<b><span><code>assertion</code></span></b> axis contains    
assertion components linked to the current component   
through {assertions}, {value}, or {facets} arcs, which are those components   
returned by the assertions() accessor.</dd><dt><a href="#axis-attributeGroup">attributeGroup axis</a></dt><dd>The   
<b><span><code>attributeGroup</code></span></b> axis contains     
attribute group definition components linked to the current component through   
{attribute group definitions} arcs, which are those components   
returned by the component-linked() accessor whose component-kind() is equal to   
<code><span>xscd:</span>attribute-group-definition</code>.</dd><dt><a href="#axis-attributeUse">attributeUse axis</a></dt><dd>The   
<b><span><code>attributeUse</code></span></b> axis contains attribute use components   
linked to the current component through {attribute uses}.   
</dd><dt><a href="#key-scp-axis">axis</a></dt><dd>A schema component path <b>axis</b>   
contains specific components linked to the   
current context component through certain kinds of arcs.   
Unless otherwise indicated, an axis applied to   
a component that has no arc of the required kind designates no components.   
</dd><dt><a href="#key-base-attribute-use-set">base attribute use set</a></dt><dd>The <b>base attribute use   
set</b> of a schema component is the set consisting of all members of the   
{attribute uses} property of members of the base type set of that schema   
component.</dd><dt><a href="#key-base-facet-set">base facet set</a></dt><dd>The <b>base facet set</b> of a schema   
component is the set consisting of all members of the {facets} property of   
members of the base type set of that schema component.</dd><dt><a href="#key-base-particle-set">base particle set</a></dt><dd>The <b>base particle set</b> of a   
schema component is the union of all particle sets of all the members of the   
extended base type set of that schema component.</dd><dt><a href="#axis-baseType">baseType axis</a></dt><dd>The    
<b><span><code>baseType</code></span></b> axis contains   
simple type definition and complex type definition components linked to the   
current component through {base type definition} arcs.   
</dd><dt><a href="#key-base-type-set">base type set</a></dt><dd>   
The <b>base type set</b> of a schema component is the set   
consisting of the {base type definition} of that schema component and   
the {base type definition} of every member of the set.   
</dd><dt><a href="#key-canonicalized-xscd">canonicalized xscd XPointer pointer part</a></dt><dd>   
A <b><span>canonicalized <code>xscd</code> XPointer pointer part</span></b> is   
  an <code>xscd</code> XPointer pointer part whose   
  pointer data is a canonical schema    
component path.    
</dd><dt><a href="#key-canonical-scd">canonical schema component designator</a></dt><dd>   
A <b>canonical schema component designator</b>   
is an absolute schema component designator that is a URI   
that has been mapped from a LEIRI to an IRI in accordance 
with the rules given in <a href="#leiri">[LEIRI]</a>, mapped from an IRI to a URI in 
accordance with  
the rules given in RFC 3987<a href="#rfc3987">[RFC 3987]</a>, and 
normalized according to the rules of 
syntax-based normalization given there;
and where the relative schema component designator consists of an 
<code>xmlns</code> XPointer pointer part (if required) followed   
by a <a title="canonicalized xscd XPointer pointer part" href="#key-canonicalized-xscd"><span>canonicalized <code>xscd</code> XPointer pointer part</span></a>.   
</dd><dt><a href="#key-canonical-schema-component-path">canonical schema component path</a></dt><dd>The <b>canonical schema   
component path</b> of a component is a distinguished valid component path   
that uniquely identifies that particular component, that has as few steps as   
possible, and that can be deterministically constructed starting from the schema description component, and that contains no   
extension axes or accessors.   
</dd><dt><a href="#axis-component">component axis</a></dt><dd>The   
<b><span><code>component</code></span></b> axis contains the transitive closure of   
schema    
components that are either linked to the schema description component or that   
are linked to current component through default arcs.  That is, it contains    
the transitive   
closure of the component-children() accessor, as well as   
component-linked()    
accessor if the schema description is the current component.   
</dd><dt><a href="#key-component-relationship">component relationship</a></dt><dd>The   
    <b>component relationship</b> is the name of the schema component   
    property on the current schema component which references the target schema   
    component.   
</dd><dt><a href="#axis-context">context axis</a></dt><dd>The   
<b><span><code>context</code></span></b> axis contains    
complex type definition, attribute declaration, or   
element declaration components linked to the current component   
through {context} arcs.   
</dd><dt><a href="#axis-currentComponent">currentComponent axis</a></dt><dd>The   
<b><span><code>currentComponent</code></span></b> axis contains the current component.   
</dd><dt><a href="#key-current-component">current schema component</a></dt><dd>The   
    <b>current schema component</b> is a schema component for which   
    there is a valid canonical path through the schema component graph.</dd><dt><a href="#key-default-arc">default arc</a></dt><dd>A <b>default   
arc</b> is a privileged    
arc of traversal.   
</dd><dt><a href="#axis-elided-component">elided-component axis</a></dt><dd>The    
<b><span><code>elided-component</code></span></b> axis contains complex type   
definitions    
linked to the current component through the {type definition} arc and the   
transitive closure of all model group components linked to the current   
component. That is, it contains the transitive closure of components returned   
from the term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>model-group</code>, as well as components linked to the current component   
through the {type definition} arc.   
</dd><dt><a href="#key-extended-base-type-set">extended base type set</a></dt><dd>The <b>extended base type   
set</b> of a schema component is   
the set consisting of the {base type definition} of that schema component if   
its {derivation} method is "extension" and the {base type definition} of   
every member of the set whose {derivation} method is "extension".   
</dd><dt><a href="#axis-facet">facet axis</a></dt><dd>The   
<b><span><code>facet</code></span></b> axis contains   
facet components linked to the current component   
through {facets} or {fundamental facets} arcs, which is the components returned   
by component-linked() whose component-kind() is equal   
to <code><span>xscd:</span>facet</code>.    
</dd><dt><a href="#axis-group">group axis</a></dt><dd>The   
<b><span><code>group</code></span></b> axis contains     
model group definition components linked to the current component through   
{model group definitions} arcs, which are those components returned   
by the component-linked() accessor whose component-kind() is equal to   
<code><span>xscd:</span>model-group-definition</code>.    
</dd><dt><a href="#axis-identityConstraint">identityConstraint axis</a></dt><dd>The   
<b><span><code>identityConstraint</code></span></b> axis contains    
identity constraint definition components linked to the current component   
through {identity constraint definitions} arcs, which are those   
components returned by the component-linked() accessor whose component-kind()   
is equal to <code><span>xscd:</span>identity-constraint-definition</code>.   
</dd><dt><a href="#axis-itemType">itemType axis</a></dt><dd>The   
<b><span><code>itemType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {item type definition} arcs.   
</dd><dt><a href="#axis-key">key axis</a></dt><dd>The <b><span><code>key</code></span></b>   
axis contains   
identity constraint definition components linked to the   
current component through {referenced key}    
arcs.</dd><dt><a href="#axis-memberType">memberType axis</a></dt><dd>The    
<b><span><code>memberType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {member type definitions}    
arcs. </dd><dt><a href="#axis-model">model axis</a></dt><dd>The   
<b><span><code>model</code></span></b> axis contains    
model group components linked to the current component   
through {model group}, {term}, {particle}, {particles}, or {content type}   
arcs, which are the components returned by the term() accessor   
whose component-kind() is equal to <code><span>xscd:</span>model-group</code>.   
</dd><dt><a href="#axis-notation">notation axis</a></dt><dd>The   
<b><span><code>notation</code></span></b> axis contains    
notation declaration components linked to the current component   
through {notation declarations}   
arcs, which are the components returned by the component-linked() accessor   
whose component-kind() is equal to <code><span>xscd:</span>notation-declaration</code>.</dd><dt><a href="#axis-particle">particle axis</a></dt><dd>The   
<b><span><code>particle</code></span></b> axis contains particle components   
linked to the current component through {particles}.   
</dd><dt><a href="#key-particle-set">particle set</a></dt><dd>The <b>particle set</b> of a schema   
component is the set consisting   
of the {content type} of that schema component with the members of the   
{particles} property of the {term} of any member of the set.</dd><dt><a href="#axis-primitiveType">primitiveType axis</a></dt><dd>The    
<b><span><code>primitiveType</code></span></b> axis contains   
simple type definition components linked to the   
current component through {primitive type definition}    
arcs.</dd><dt><a href="#key-relative-scd">relative schema component designator</a></dt><dd>A   
    <b>relative schema component designator</b>    
    identifies a particular schema component relative to   
    some current assembled schema; it   
    is expressed as an <a href="http://www.w3.org/TR/xptr-framework/#scheme">XPointer scheme</a>   
    <code> xscd()</code> that uses a <a title="schema component path" href="#key-scp">schema component path</a>   
    as the <a href="http://www.w3.org/TR/xptr-framework/#NT-SchemeData">scheme data</a>.</dd><dt><a href="#key-same-attr-uses">same (attribute uses)</a></dt><dd>Two attribute uses are <b>the   
same</b> if the {name} and {target namespace} of their {attribute   
declaration} properties are equal. </dd><dt><a href="#key-same-facet">same (facets)</a></dt><dd>Two facets are <b>the same</b> if they   
are the same kind of component (e.g. both are length facets) and their {value}   
properties have identical values.</dd><dt><a href="#key-same-particle">same (particles)</a></dt><dd>Two particles are <b>the same</b> if   
the implementation reports them as the same.</dd><dt><a href="#axis-schemaAttribute">schemaAttribute axis</a></dt><dd>The    
<b><span><code>schemaAttribute</code></span></b> axis contains attribute   
declaration components linked to the current component through   
{attribute declaration} or {attribute declarations} arcs,   
which are those components returned by the component-linked() accessor whose   
component-kind() is equal to <code><span>xscd:</span>attribute-declaration</code>.   
</dd><dt><a href="#key-equal-scd">schema component designators are equal</a></dt><dd>Two   
<b>schema component designators are equal</b> if they are absolute   
and their URIs are equal or if they are relative to the   
same schema, and their <a title="schema component paths are equal" href="#key-equal-path">schema component paths are   
equal</a>.</dd><dt><a href="#key-scp-nametest">schema component name test</a></dt><dd>A    
<b>schema component name   
test</b> is a condition on name of the components selected by the schema   
component path step.</dd><dt><a href="#key-scp">schema component path</a></dt><dd>A   
<b>schema component path</b> selects a sequence of   
schema components in the context of an assembled schema; it is a series   
of <a title="step" href="#key-scp-step">steps</a> separated by    
'<code>/</code>' or '<code>//</code>'.  Complete schema component paths always   
start with either '<code>/</code>' or '<code>//</code>'.    
</dd><dt><a href="#key-equal-path">schema component paths are equal</a></dt><dd>Two <b>schema component paths are   
equal</b> if they have the same number of   
steps, and each step in one path is equal to the corresponding   
step in the other. Steps are equal if they have the same   
axis, name test (namespace and local name, or wildcard), and predicate.   
.</dd><dt><a href="#key-scp-pospred">schema component positional predicate</a></dt><dd>    
A <b>schema component positional predicate</b> is a condition on the    
relative position of the component in the sequence of matching components from   
the schema component path step.</dd><dt><a href="#key-sd">schema designator</a></dt><dd>A <b>schema   
designator</b> is a single URI for a resource representing an   
assembled schema.</dd><dt><a href="#axis-schemaElement">schemaElement axis</a></dt><dd>The   
<b><span><code>schemaElement</code></span></b> axis contains element    
declaration components linked to the current component through   
{element declarations}, {term}, {particle},   
{particles}, or {content type}, which are the components returned by the   
term() accessor whose component-kind() is equal to   
<code><span>xscd:</span>element-declaration</code>, together with {element declarations}.   
</dd><dt><a href="#axis-scope">scope axis</a></dt><dd>The   
<b><span><code>scope</code></span></b> axis contains    
complex type definition, attribute group definition, or   
model group definition components linked to the current component   
through {scope} and {parent} arcs, which are the components returned from    
the component-scope() accessor.   
</dd><dt><a href="#key-scp-step">step</a></dt><dd>A <b>step</b>    
consists of a <a title="axis" href="#key-scp-axis">schema component   
axis</a> and a <a title="schema component name test" href="#key-scp-nametest">schema component name   
test</a> and    
an optional <a title="schema component positional predicate" href="#key-scp-pospred">positional predicate</a>.   
It selects a sequence of schema components that are linked to a   
source component through an arc that matches the axis, pass the name test,   
and are selected by the positional predicate, if any.   
</dd><dt><a href="#axis-substitutionGroup">substitutionGroup axis</a></dt><dd>The    
<b><span><code>substitutionGroup</code></span></b> axis contains   
element declaration components linked to the current component   
through {substitution group affiliation} and {substitution group affiliations}    
arcs.   
</dd><dt><a href="#key-target-component">target schema component</a></dt><dd>The   
    <b>target schema component</b> is a schema component linked to the   
    current schema component via one of the schema component properties   
    defined previously.</dd><dt><a href="#axis-type">type axis</a></dt><dd>The <b><span><code>type</code></span></b>   
axis contains simple type definition    
and complex type definition components linked to the current component through   
{type definition}, {type definitions}, {content type},   
or {simple type definition} arcs, which are the components    
returned by the component-children() accessor whose    
component-kind() is equal to either   
<code><span>xscd:</span>complex-type-definition</code> or    
<code><span>xscd:</span>simple-type-definition</code>.</dd></dl></div><div class="div1">
<h2><a id="references" name="references" />D References</h2><div class="div2">
<h3><a id="N11ED1" name="N11ED1" />D.1 Normative References</h3><dl><dt class="label"><a id="rfc3986" name="rfc3986" />RFC 3986</dt><dd>   
<em><a href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource   
Identifier (URI): Generic Syntax</a></em>, T. Berners-Lee,  R. Fielding,   
and L. Masinter.  The Internet Society, January 2005.  This version is    
available at    
<a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.   
</dd><dt class="label"><a id="xsd2" name="xsd2" />XSD2</dt><dd>   
<em><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</a></em>,  Paul V. Biron and   
Ashok Malhotra, Editors.    
World Wide Web Consortium, 28 October 2004. This version is available at    
<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</a>.   
The latest version is available at   
<a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.   
</dd><dt class="label"><a id="xptrxmlns" name="xptrxmlns" />XPTR XMLNS</dt><dd>   
<em><a href="http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325/">XPointer xmlns() Scheme</a></em>, Steven J. DeRose, Ron Daniel Jr., Eve   
Maler, Jonathan Marsh, Editors. World Wide Web Consortium, 25 March 2003.   
This version is available at   
<a href="http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325/">http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325/</a>.   
The latest version is available at   
<a href="http://www.w3.org/TR/xptr-xmlns/">http://www.w3.org/TR/xptr-xmlns/</a>.   
</dd><dt class="label"><a id="rfc3987" name="rfc3987" />RFC 3987</dt><dd>   
<em><a href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource   
Identifiers (IRIs)</a></em>, M. Duerst and M. Suignard.  The Internet 
Society, January 2005.  This version is available at    
<a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.   
</dd><dt class="label"><a id="xsd11_1" name="xsd11_1" />XSD11_1</dt><dd>    
<em><a href="http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/">XML   
Schema Definition Language (XSD) 1.1  Part 1: Structures</a></em>, Shundi   
Gao, C. M. Sperberg-McQueen, Henry S. Thompson, Editors.    
World Wide Web Consortium, 20 June 2008. This   
version is available at    
<a href="http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/">http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/</a>.   
The latest version is available at   
<a href="http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a>.   
</dd><dt class="label"><a id="xptrframework" name="xptrframework" />XPTR</dt><dd>   
<em><a href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/">XPointer   
Framework</a></em> Paul Grosso, Eve Maler,    
Jonathan Marsh, Norman Walsh, Editors. World Wide Web   
Consortium, 25 March 2003.   
The current version is available at   
<a href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/">http://www.w3.org/TR/2003/REC-xptr-framework-20030325/</a>   
The latest version is available at   
<a href="http://www.w3.org/TR/xptr-framework/">http://www.w3.org/TR/xptr-framework/</a>.   
</dd><dt class="label"><a id="xsd11_2" name="xsd11_2" />XSD11_2</dt><dd>   
<em><a href="http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/">XML   
Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></em>,     
David Peterson, Shundi Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and Henry   
S. Thompson, Editors.    
World Wide Web Consortium, 20 June 2008. This version is available at    
<a href="http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/">http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/</a>.    
The latest version is available at   
<a href="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.   
</dd><dt class="label"><a id="xsd1" name="xsd1" />XSD1</dt><dd>    
<em><a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">XML Schema Part 1: Structures (Second   
Edition)</a></em>, Henry S. Thompson, David Beech, Murray Maloney and   
Noah Mendelsohn, Editors. World Wide Web Consortium, 28 October 2004. This   
version is available at    
<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</a>. 
The latest version is available at   
<a href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>.   
</dd><dt class="label"><a id="leiri" name="leiri" />LEIRI</dt><dd>   
<em><a href="http://www.w3.org/TR/2008/NOTE-leiri-20081103/">Legacy 
extended IRIs for XML resource identification</a></em>, Henry S. Thompson, 
Richard Tobin, and Norman Walsh.  World Wide Web Consortium, 3 November 2008. 
This version is available at    
<a href="http://www.w3.org/TR/2008/NOTE-leiri-20081103/">http://www.w3.org/TR/2008/NOTE-leiri-20081103/</a>.   
</dd></dl></div><div class="div2">
<h3><a id="N11FE7" name="N11FE7" />D.2 Non-normative Informational References</h3><dl><dt class="label"><a id="xsd0" name="xsd0" />XSD0</dt><dd>    
<em><a href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/">XML Schema Part 0: Primer (Second   
Edition)</a></em>, David C. Fallside, Editor. World Wide Web Consortium, 28 October 2004. This   
version is available at    
<a href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/</a>.   
The latest version is available at   
<a href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>.   
</dd><dt class="label"><a id="dom3" name="dom3" />DOM3</dt><dd>   
<em><a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">   
Document Object   
Model (DOM) Level 3 Core Specification, Version 1.0</a></em>,   
Arnaud Le Hors, et al, Editors. World Wide Web   
Consortium, 7 April 2004. This version is available at   
<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/   
</a>.   
The latest version is available at   
<a href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/   
</a>.   
</dd></dl></div></div></div></body></html>