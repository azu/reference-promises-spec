<!-- http://www.w3.org/TR/xslt-30/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--{xsl-query} XSLT Processor: Saxonica SAXON HE 9.4.0.3-->
<!--{xmlspec} XSLT Processor: SaxonicaSAXONHE 9.4.0.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="EN" xmlns="http://www.w3.org/1999/xhtml" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.12), see www.w3.org" />
<title>XSL Transformations (XSLT) Version 3.0</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xslt3.0/diff.xsl (B) */  
dd.indent { margin-left: 2em; }
p.element-syntax { border: solid thin; background-color: #ffccff }
p.element-syntax-chg { border: solid thick yellow; background-color: #ffccff }
div.proto { border: solid thin; background-color: #ffccff }
div.proto + div.proto { margin-top : 2em; }
div.example { border: solid thin; background-color: #40e0d0; padding: 1em }
div.example-chg { border: solid thick yellow; background-color: #40e0d0; padding: 1em }
span.verb { font: small-caps 100% sans-serif } 
span.error { font-size: small } 
span.definition { font: small-caps 100% sans-serif } 
span.grayed { color: gray }

/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XSL Transformations (XSLT)
Version 3.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Last Call
Working Draft 12 December 2013</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/">http://www.w3.org/TR/2013/WD-xslt-30-20131212/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xslt-30/">http://www.w3.org/TR/xslt-30/</a><br />
</dd>
<dt>Previous versions:</dt>
<dd><a href=
"http://www.w3.org/TR/2012/WD-xslt-30-20120710/">http://www.w3.org/TR/2012/WD-xslt-30-20120710/</a><br />

<a href=
"http://www.w3.org/TR/2010/WD-xslt-21-20100511/">http://www.w3.org/TR/2010/WD-xslt-21-20100511/</a><br />
</dd>
<dt>Editor:</dt>
<dd>Michael Kay, Saxonica <a href=
"http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd>
</dl>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30">
<strong>translations</strong></a>.</p>
<p>The following associated resources are available:</p>
<ul>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/Overview.html">Normative
specification in HTML format</a></li>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/Overview-diff.html">HTML
with revision markings (non-normative)</a></li>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/schema-for-xslt30.xsd">
Schema for XSLT 3.0 stylesheets (non-normative)</a></li>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/schema-for-json.xsd">
Schema for the XML representation of JSON used by fn:json-to-xml
(non-normative)</a></li>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/xml-to-json.xsl">Stylesheet
for XML-to-JSON conversion (non-normative)</a></li>
<li><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/xml-to-json-indented.xsl">
Stylesheet for XML-to-JSON conversion with indentation
(non-normative)</a></li>
</ul>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2013&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href=
"http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This specification defines the syntax and semantics of XSLT
<span>3.0</span>, a language for transforming XML documents into
other XML documents.</p>
<p>XSLT 3.0 is a revised version of the XSLT 2.0 Recommendation
<a href="#xslt20">[XSLT 2.0]</a> published on 23 January 2007.</p>
<p>The primary purpose of the changes in this version of the
language is to enable transformations to be performed in streaming
mode, where neither the source document nor the result document is
ever held in memory in its entirety. Another important aim is to
improve the modularity of large stylesheets, allowing stylesheets
to be developed from independently-developed components with a high
level of software engineering robustness.</p>
<p>XSLT 3.0 is designed to be used in conjunction with XPath 3.0,
which is defined in <a href="#xpath-30">[XPath 3.0]</a>. XSLT
shares the same data model as XPath 3.0, which is defined in
<a href="#xpath-datamodel-30">[Data Model]</a>, and it uses the
library of functions and operators defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. XPath 3.0 and
the underlying function library introduce a number of enhancements,
for example the availability of higher-order functions. Some of the
functions that were previously defined in <span>the XSLT 2.0</span>
specification, such as the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> functions,
are now defined in the standard function library to make them
available to other host languages.</p>
<p>XSLT 3.0 also includes optional facilities to serialize the
results of a transformation, by means of an interface to the
serialization component described in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>.</p>
<p><em>This document contains hyperlinks to specific sections or
definitions within other documents in this family of
specifications. These links are indicated visually by a superscript
identifying the target specification: for example XP30 for XPath
3.0, DM30 for the XDM data model version 3.0, FO30 for Functions
and Operators version 3.0.</em></p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index at
http://www.w3.org/TR/.</a></em></p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html">W3C process
document</a>. It has been developed by the <a href=
"http://www.w3.org/Style/XSL/">W3C XSLT Working Group</a>, which is
part of the <a href="http://www.w3.org/XML/Activity">XML
Activity</a>. Comments on this document will be formally accepted
until 10 February 2014. The Working Group expects to advance this
specification to <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
Status.</p>
<p>This specification has been developed in conjunction with
<a href="#xpath-30">[XPath 3.0]</a> and other documents that
underpin both XSLT and XQuery. XSLT 3.0 is dependent on XPath 3.0,
which at the time of publication is a Proposed Recommendation.</p>
<p><em>In addition, this document specifies extensions to the XDM
data model and to XPath language syntax to underpin the
introduction of maps, which have been found necessary to support
some XSLT streaming use cases and make many other processing tasks
easier. This has involved extensive consultation with the XQuery
Working Group (which has joint responsibility for XDM and XPath),
and plans for incorporation of these extensions in a future version
of those specifications are well advanced. This has resulted in
some changes since the previous draft of July 2012: most notably,
the <code>:=</code> separator in map expressions has changed to
<code>:</code>, and collations as a property of a map have been
replaced by an alternative design using explicit collation
keys.</em></p>
<p>Changes since previous versions are listed in <a href=
"#changes-since-2.0"><i>J Changes since XSLT 2.0</i></a> and
<a href="#changes-since-july-2012"><i>K Changes since the Working
Draft of 10 July 2012</i></a>. The only incompatibilities with XSLT
2.0 relate to the way in which certain error conditions are
handled: the details are given in <a href="#incompatibilities"><i>L
Incompatibilities with XSLT 2.0</i></a>. The most significant
changes since the previous working draft are the introduction of
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> and <a title=
"static variable" class="termref" href="#dt-static-variable">static
variables</a>; the introduction of a family of URIs for collations
conforming to the Unicode Collation Algorithm; extensive reworking
of the syntax for <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>; changes to the way in which <a title=
"accumulator function" class="termref" href=
"#dt-accumulator-function">accumulator functions</a> are invoked;
and a substantial rewrite of the rules for assessing the
streamability of stylesheet constructs such as template rules.</p>
<p>Please report errors in this document using W3C's <a href=
"https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string "[XSLT30]" in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>A public test suite for XSLT 3.0 is under development.
Implementors and others are encouraged to run these tests, to
submit comments and contributions, and to report their results. The
test suite is available at <a href=
"https://dvcs.w3.org/hg/xslt30-test/">https://dvcs.w3.org/hg/xslt30-test/</a>.</p>
<p>Publication as a Last Call Working Draft does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the group; that page also includes instructions
for disclosing a patent. An individual who has actual knowledge of
a patent which the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#introduction">Introduction</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#what-is-xslt">What is
XSLT?</a><br />
&#160;&#160;&#160;&#160;1.2 <a href="#whats-new-in-xslt3">What's
New in XSLT 3.0?</a><br />
2 <a href="#concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;2.1 <a href=
"#terminology">Terminology</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#notation">Notation</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#initiating">Initiating a
Transformation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#info-for-static-analysis">Information needed for Static
Analysis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#priming-stylesheet">Priming a Stylesheet</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#invoking-initial-mode">Invoking an Initial Mode</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#invoking-initial-template">Invoking an Initial Template</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.5 <a href=
"#invoking-initial-function">Invoking an Initial Function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.6 <a href=
"#post-processing">Post-processing the Raw Result</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#executing-a-transformation">Executing a Transformation</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#context">The Evaluation
Context</a><br />
&#160;&#160;&#160;&#160;2.6 <a href=
"#parsing-and-serialization">Parsing and Serialization</a><br />
&#160;&#160;&#160;&#160;2.7 <a href=
"#packages-and-modules">Packages and Modules</a><br />
&#160;&#160;&#160;&#160;2.8 <a href=
"#extensibility">Extensibility</a><br />
&#160;&#160;&#160;&#160;2.9 <a href=
"#stylesheets-and-schemas">Stylesheets and XML Schemas</a><br />
&#160;&#160;&#160;&#160;2.10 <a href=
"#streaming-concepts">Streaming</a><br />
&#160;&#160;&#160;&#160;2.11 <a href="#errors">Error
Handling</a><br />
3 <a href="#stylesheet-structure">Stylesheet Structure</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#xslt-namespace">XSLT
Namespace</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#reserved-namespaces">Reserved
Namespaces</a><br />
&#160;&#160;&#160;&#160;3.3 <a href=
"#extension-attributes">Extension Attributes</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#xslt-media-type">XSLT Media
Type</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#standard-attributes">Standard
Attributes</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#packages">Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.1 <a href=
"#package-dependencies">Dependencies between Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2 <a href=
"#named-components">Named Components in Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.1
<a href="#visibility">Visibility of Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.2
<a href="#declared-visibility">Visibility of Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.3
<a href="#exposing-components">Exposing Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.4
<a href="#accepting-components">Accepting Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.5
<a href="#package-overriding-components">Overriding Named
Components from a Used Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2.6
<a href="#component-references">Binding References to
Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3 <a href=
"#modes-and-packages">Overriding Template Rules from a Used
Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.4 <a href=
"#package-local-declarations">Declarations Local to a
Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.5 <a href=
"#xquery-packages">Using an XQuery Library Package</a><br />
&#160;&#160;&#160;&#160;3.7 <a href=
"#stylesheet-modules">Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.8 <a href=
"#stylesheet-element">Stylesheet Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.1 <a href=
"#default-collation-attribute">The default-collation
Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.2 <a href=
"#default-mode">The [xsl:]default-mode Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.3 <a href=
"#user-defined-top-level">User-defined Data Elements</a><br />
&#160;&#160;&#160;&#160;3.9 <a href=
"#simplified-stylesheet">Simplified Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.10 <a href="#backwards">Backwards
Compatible Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
"#backwards-1.0">XSLT 1.0 Compatibility Mode</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
"#backwards-2.0">XSLT 2.0 Compatibility Mode</a><br />
&#160;&#160;&#160;&#160;3.11 <a href="#forwards">Forwards
Compatible Processing</a><br />
&#160;&#160;&#160;&#160;3.12 <a href="#combining-modules">Combining
Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.1 <a href=
"#locating-modules">Locating Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.2 <a href=
"#include">Stylesheet Inclusion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.3 <a href=
"#import">Stylesheet Import</a><br />
&#160;&#160;&#160;&#160;3.13 <a href="#embedded">Embedded
Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.14 <a href=
"#conditional-inclusion">Conditional Element Inclusion</a><br />
&#160;&#160;&#160;&#160;3.15 <a href="#built-in-types">Built-in
Types</a><br />
&#160;&#160;&#160;&#160;3.16 <a href="#import-schema">Importing
Schema Components</a><br />
4 <a href="#data-model">Data Model</a><br />
&#160;&#160;&#160;&#160;4.1 <a href="#xml-versions">XML
Versions</a><br />
&#160;&#160;&#160;&#160;4.2 <a href=
"#stylesheet-stripping">Stripping Whitespace from the
Stylesheet</a><br />
&#160;&#160;&#160;&#160;4.3 <a href=
"#stripping-annotations">Stripping Type Annotations from a Source
Tree</a><br />
&#160;&#160;&#160;&#160;4.4 <a href="#strip">Stripping Whitespace
from a Source Tree</a><br />
&#160;&#160;&#160;&#160;4.5 <a href="#id-in-data-model">Attribute
Types and DTD Validation</a><br />
&#160;&#160;&#160;&#160;4.6 <a href="#model-for-streaming">Data
Model for Streaming</a><br />
&#160;&#160;&#160;&#160;4.7 <a href="#limits">Limits</a><br />
&#160;&#160;&#160;&#160;4.8 <a href="#d-o-e-in-data-model">Disable
Output Escaping</a><br />
5 <a href="#constructs">Features of the XSLT Language</a><br />
&#160;&#160;&#160;&#160;5.1 <a href="#qname">Qualified
Names</a><br />
&#160;&#160;&#160;&#160;5.2 <a href="#unprefixed-qnames">Unprefixed
Lexical QNames in Expressions and Patterns</a><br />
&#160;&#160;&#160;&#160;5.3 <a href=
"#expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;5.4 <a href=
"#static-and-dynamic-context">The Static and Dynamic
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.1 <a href=
"#static-context">Initializing the Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.2 <a href=
"#additional-static-context">Additional Static Context Components
used by XSLT</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3 <a href=
"#xpath-dynamic-context">Initializing the Dynamic Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.1
<a href="#focus">Maintaining Position: the Focus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.2
<a href="#evaluation-context">Other Components of the XPath Dynamic
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.4 <a href=
"#additional-dynamic-context">Additional Dynamic Context Components
used by XSLT</a><br />
&#160;&#160;&#160;&#160;5.5 <a href=
"#defining-decimal-format">Defining a Decimal Format</a><br />
&#160;&#160;&#160;&#160;5.6 <a href="#patterns">Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.1 <a href=
"#pattern-examples">Examples of Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.2 <a href=
"#pattern-syntax">Syntax of Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.3 <a href=
"#pattern-semantics">The Meaning of a Pattern</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.4 <a href=
"#pattern-errors">Errors in Patterns</a><br />
&#160;&#160;&#160;&#160;5.7 <a href="#value-templates">Value
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.1 <a href=
"#attribute-value-templates">Attribute Value Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.2 <a href=
"#text-value-templates">Text Value Templates</a><br />
&#160;&#160;&#160;&#160;5.8 <a href=
"#sequence-constructors">Sequence Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.1 <a href=
"#constructing-complex-content">Constructing Complex
Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.2 <a href=
"#constructing-simple-content">Constructing Simple
Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.3 <a href=
"#namespace-fixup">Namespace Fixup</a><br />
&#160;&#160;&#160;&#160;5.9 <a href="#uri-references">URI
References</a><br />
6 <a href="#rules">Template Rules</a><br />
&#160;&#160;&#160;&#160;6.1 <a href="#defining-templates">Defining
Templates</a><br />
&#160;&#160;&#160;&#160;6.2 <a href=
"#defining-template-rules">Defining Template Rules</a><br />
&#160;&#160;&#160;&#160;6.3 <a href="#applying-templates">Applying
Template Rules</a><br />
&#160;&#160;&#160;&#160;6.4 <a href="#conflict">Conflict Resolution
for Template Rules</a><br />
&#160;&#160;&#160;&#160;6.5 <a href="#default-priority">Default
Priority for Template Rules</a><br />
&#160;&#160;&#160;&#160;6.6 <a href="#modes">Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.1 <a href=
"#declaring-modes">Declaring Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.2 <a href=
"#using-modes">Using Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.3 <a href=
"#streamable-templates">Streamable Templates</a><br />
&#160;&#160;&#160;&#160;6.7 <a href=
"#declaring-context-item">Declaring the Context Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.1 <a href=
"#initial-context-for-mode">Declaring the Initial Context Item for
a Mode</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.2 <a href=
"#initial-context-for-template">Declaring the context item for a
template</a><br />
&#160;&#160;&#160;&#160;6.8 <a href="#built-in-rule">Built-in
Template Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.1 <a href=
"#built-in-templates-text-only-copy">Built-in Templates: Text-only
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.2 <a href=
"#built-in-templates-deep-copy">Built-in Templates: Deep
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.3 <a href=
"#built-in-templates-shallow-copy">Built-in Templates: Shallow
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.4 <a href=
"#built-in-templates-deep-skip">Built-in Templates: Deep
Skip</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.5 <a href=
"#built-in-templates-shallow-skip">Built-in Templates: Shallow
Skip</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.8.6 <a href=
"#built-in-templates-fail">Built-in Templates: Fail</a><br />
&#160;&#160;&#160;&#160;6.9 <a href="#apply-imports">Overriding
Template Rules</a><br />
&#160;&#160;&#160;&#160;6.10 <a href=
"#parameters-to-template-rules">Passing Parameters to Template
Rules</a><br />
7 <a href="#repetition">Repetition</a><br />
&#160;&#160;&#160;&#160;7.1 <a href="#for-each">The xsl:for-each
instruction</a><br />
&#160;&#160;&#160;&#160;7.2 <a href="#iterate">The xsl:iterate
Instruction</a><br />
8 <a href="#conditionals">Conditional Processing</a><br />
&#160;&#160;&#160;&#160;8.1 <a href="#xsl-if">Conditional
Processing with xsl:if</a><br />
&#160;&#160;&#160;&#160;8.2 <a href="#xsl-choose">Conditional
Processing with xsl:choose</a><br />
&#160;&#160;&#160;&#160;8.3 <a href=
"#try-catch">Try/Catch</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.3.1 <a href=
"#try-catch-examples">Try/Catch Examples</a><br />
9 <a href="#variables-and-parameters">Variables and
Parameters</a><br />
&#160;&#160;&#160;&#160;9.1 <a href=
"#variables">Variables</a><br />
&#160;&#160;&#160;&#160;9.2 <a href=
"#parameters">Parameters</a><br />
&#160;&#160;&#160;&#160;9.3 <a href="#variable-values">Values of
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.4 <a href="#temporary-trees">Creating
Implicit Document Nodes</a><br />
&#160;&#160;&#160;&#160;9.5 <a href="#global-variables">Global
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.6 <a href="#static-params">Static
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.7 <a href="#static-expression">Static
Expressions</a><br />
&#160;&#160;&#160;&#160;9.8 <a href="#local-variables">Local
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.9 <a href="#scope-of-variables">Scope of
Variables</a><br />
&#160;&#160;&#160;&#160;9.10 <a href="#with-param">Setting
Parameter Values</a><br />
&#160;&#160;&#160;&#160;9.11 <a href="#circularity">Circular
Definitions</a><br />
10 <a href="#callable-components">Callable Components</a><br />
&#160;&#160;&#160;&#160;10.1 <a href="#named-templates">Named
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.1 <a href=
"#call-template-params">Passing Parameters to Named
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.2 <a href=
"#tunnel-params">Tunnel Parameters</a><br />
&#160;&#160;&#160;&#160;10.2 <a href="#attribute-sets">Named
Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.1 <a href=
"#using-attribute-sets">Using Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.2 <a href=
"#visibility-of-attribute-sets">Visibility of Attribute
Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.3 <a href=
"#streamability-of-attribute-sets">Streamability of Attribute
Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.4 <a href=
"#evaluating-attribute-sets">Evaluating Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.5 <a href=
"#attribute-sets-examples">Attribute Sets: Examples</a><br />
&#160;&#160;&#160;&#160;10.3 <a href=
"#stylesheet-functions">Stylesheet Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.1 <a href=
"#xsl-function-name">Function Name and Arity</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.2 <a href=
"#function-arguments">Arguments</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.3 <a href=
"#function-result">Function Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.4 <a href=
"#function-visibility-and-overriding">Visibility and Overriding of
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.5 <a href=
"#function-lookup">Dynamic Access to Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.6 <a href=
"#function-determinism">Determinism of Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.7 <a href=
"#memoization">Memoization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.8 <a href=
"#function-examples">Examples of Stylesheet Functions</a><br />
&#160;&#160;&#160;&#160;10.4 <a href="#dynamic-xpath">Dynamic XPath
Evaluation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.1 <a href=
"#evaluate-static-context">Static context for the target
expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.2 <a href=
"#evaluate-dynamic-context">Dynamic context for the target
expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.3 <a href=
"#evaluate-effect">The effect of the xsl:evaluate
instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.4 <a href=
"#evaluation-as-optional-feature">xsl:evaluate as an optional
feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.5 <a href=
"#evaluate-examples">Examples of xsl:evaluate</a><br />
11 <a href="#creating-new-nodes">Creating Nodes and
Sequences</a><br />
&#160;&#160;&#160;&#160;11.1 <a href=
"#literal-result-element">Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.1 <a href=
"#setting-annotation-for-lre">Setting the Type Annotation for
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.2 <a href=
"#attributes-for-lres">Attribute Nodes for Literal Result
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.3 <a href=
"#lre-namespaces">Namespace Nodes for Literal Result
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.4 <a href=
"#conditional-literal-result-elements">Conditional Creation of
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.5 <a href=
"#namespace-aliasing">Namespace Aliasing</a><br />
&#160;&#160;&#160;&#160;11.2 <a href="#xsl-element">Creating
Element Nodes Using xsl:element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.1 <a href=
"#xsl-element-content">The Content of the Constructed Element
Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.2 <a href=
"#xsl-element-name">The Name of the Constructed Element
Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.3 <a href=
"#xsl-element-properties">Other Properties of the Constructed
Element Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.4 <a href=
"#annotation-for-constructed-element">The Type Annotation of the
Constructed Element Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.5 <a href=
"#xsl-element-on-empty">Conditional Construction of Element
Nodes</a><br />
&#160;&#160;&#160;&#160;11.3 <a href=
"#creating-attributes">Creating Attribute Nodes Using
xsl:attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.3.1 <a href=
"#annotation-for-constructed-attribute">Setting the Type Annotation
for a Constructed Attribute Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.3.2 <a href=
"#xsl-attribute-on-empty">Conditional Creation of Attribute
Nodes</a><br />
&#160;&#160;&#160;&#160;11.4 <a href=
"#creating-text-nodes">Creating Text Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.1 <a href=
"#literal-text-nodes">Literal Text Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.2 <a href=
"#xsl-text">Creating Text Nodes Using xsl:text</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.3 <a href=
"#value-of">Generating Text with xsl:value-of</a><br />
&#160;&#160;&#160;&#160;11.5 <a href=
"#creating-document-nodes">Creating Document Nodes</a><br />
&#160;&#160;&#160;&#160;11.6 <a href=
"#creating-processing-instructions">Creating Processing
Instructions</a><br />
&#160;&#160;&#160;&#160;11.7 <a href=
"#creating-namespace-nodes">Creating Namespace Nodes</a><br />
&#160;&#160;&#160;&#160;11.8 <a href="#creating-comments">Creating
Comments</a><br />
&#160;&#160;&#160;&#160;11.9 <a href="#copying">Copying
Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.1 <a href=
"#shallow-copy">Shallow Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.1.1
<a href="#conditional-copy">Conditional Copying of Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.2 <a href=
"#copy-of">Deep Copy</a><br />
&#160;&#160;&#160;&#160;11.10 <a href=
"#constructing-sequences">Constructing Sequences</a><br />
12 <a href="#number">Numbering</a><br />
&#160;&#160;&#160;&#160;12.1 <a href=
"#formatting-supplied-number">Formatting a Supplied
Number</a><br />
&#160;&#160;&#160;&#160;12.2 <a href=
"#numbering-based-on-position">Numbering based on Position in a
Document</a><br />
&#160;&#160;&#160;&#160;12.3 <a href="#convert">Number to String
Conversion Attributes</a><br />
13 <a href="#sorting">Sorting</a><br />
&#160;&#160;&#160;&#160;13.1 <a href="#xsl-sort">The xsl:sort
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.1 <a href=
"#sorting-process">The Sorting Process</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.2 <a href=
"#comparing-sort-keys">Comparing Sort Key Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.3 <a href=
"#collating-sequences">Sorting Using Collations</a><br />
&#160;&#160;&#160;&#160;13.2 <a href=
"#creating-sorted-sequence">Creating a Sorted Sequence</a><br />
&#160;&#160;&#160;&#160;13.3 <a href="#sorted-iteration">Processing
a Sequence in Sorted Order</a><br />
&#160;&#160;&#160;&#160;13.4 <a href="#uca-collations">The Unicode
Collation Algorithm</a><br />
14 <a href="#grouping">Grouping</a><br />
&#160;&#160;&#160;&#160;14.1 <a href="#xsl-for-each-group">The
xsl:for-each-group Element</a><br />
&#160;&#160;&#160;&#160;14.2 <a href=
"#information-about-group">Accessing Information about the Current
Group Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.1 <a href=
"#func-current-group">fn:current-group</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.2 <a href=
"#func-current-grouping-key">fn:current-grouping-key</a><br />
&#160;&#160;&#160;&#160;14.3 <a href="#order-of-groups">Ordering
among Groups</a><br />
&#160;&#160;&#160;&#160;14.4 <a href="#grouping-examples">Examples
of Grouping</a><br />
&#160;&#160;&#160;&#160;14.5 <a href=
"#non-transitivity">Non-Transitivity</a><br />
15 <a href="#merging">Merging</a><br />
&#160;&#160;&#160;&#160;15.1 <a href=
"#merge-terminology">Terminology for Merging</a><br />
&#160;&#160;&#160;&#160;15.2 <a href="#merge-instruction">The
xsl:merge Instruction</a><br />
&#160;&#160;&#160;&#160;15.3 <a href=
"#merge-input-sequences">Selecting the Sequences to be
Merged</a><br />
&#160;&#160;&#160;&#160;15.4 <a href=
"#streamable-merging">Streamable Merging</a><br />
&#160;&#160;&#160;&#160;15.5 <a href="#merge-keys">Defining the
Merge Keys</a><br />
&#160;&#160;&#160;&#160;15.6 <a href="#merge-action">The
xsl:merge-action Element</a><br />
&#160;&#160;&#160;&#160;15.7 <a href="#merge-examples">Examples of
xsl:merge</a><br />
16 <a href="#splitting">Splitting</a><br />
&#160;&#160;&#160;&#160;16.1 <a href="#fork-instruction">The
xsl:fork Instruction</a><br />
&#160;&#160;&#160;&#160;16.2 <a href="#splitting-examples">Examples
of Splitting with Streamed Data</a><br />
17 <a href="#regular-expressions">Regular Expressions</a><br />
&#160;&#160;&#160;&#160;17.1 <a href="#analyze-string">The
xsl:analyze-string Instruction</a><br />
&#160;&#160;&#160;&#160;17.2 <a href=
"#func-regex-group">fn:regex-group</a><br />
&#160;&#160;&#160;&#160;17.3 <a href="#regex-examples">Examples of
Regular Expression Matching</a><br />
18 <a href="#streaming">Streaming</a><br />
&#160;&#160;&#160;&#160;18.1 <a href="#stream-instruction">The
xsl:stream Instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.1 <a href=
"#stream-validation">Validation of Streamed Documents</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.2 <a href=
"#stream-examples">Examples of xsl:stream</a><br />
&#160;&#160;&#160;&#160;18.2 <a href=
"#accumulators">Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.1 <a href=
"#accumulator-declaration">Declaring an Accumulator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.2 <a href=
"#accumulator-informal-rules">Informal Model for
Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.3 <a href=
"#accumulator-formal-rules">Formal Model for Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.4 <a href=
"#func-accumulator-before">fn:accumulator-before</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.5 <a href=
"#func-accumulator-after">fn:accumulator-after</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.6 <a href=
"#accumulators-visibility-and-overriding">Visibility and Overriding
of Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.7 <a href=
"#streamability-of-accumulators">Streamability of
Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.8 <a href=
"#accumulator-examples">Examples of Accumulators</a><br />
&#160;&#160;&#160;&#160;18.3 <a href=
"#func-copy-of">fn:copy-of</a><br />
&#160;&#160;&#160;&#160;18.4 <a href=
"#func-snapshot">fn:snapshot</a><br />
19 <a href="#streamability">Streamability</a><br />
&#160;&#160;&#160;&#160;19.1 <a href="#pattern-scanning">An
Optimization: Pattern-Based Scanning</a><br />
&#160;&#160;&#160;&#160;19.2 <a href=
"#determining-static-type">Determining the Static Type of a
Construct</a><br />
&#160;&#160;&#160;&#160;19.3 <a href=
"#determining-context-item-type">Determining the Context Item
Type</a><br />
&#160;&#160;&#160;&#160;19.4 <a href="#operand-roles">Operand
Roles</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.4.1 <a href=
"#operand-usage-examples">Examples showing the Effect of Operand
Usage</a><br />
&#160;&#160;&#160;&#160;19.5 <a href="#posture">Determining the
Posture of a Construct</a><br />
&#160;&#160;&#160;&#160;19.6 <a href=
"#determining-context-posture">Determining the Context
Posture</a><br />
&#160;&#160;&#160;&#160;19.7 <a href="#sweep">The Sweep of a
Construct</a><br />
&#160;&#160;&#160;&#160;19.8 <a href=
"#classifying-constructs">Classifying Constructs</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.1 <a href=
"#general-streamability-rules">General Rules for
Streamability</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.2 <a href=
"#general-streamability-examples">Examples of the General
Streamability Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.3 <a href=
"#classifying-sequence-constructors">Classifying Sequence
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4 <a href=
"#classifying-instructions">Classifying Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.1
<a href="#streamability-literal-result-elements">Streamability of
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.2
<a href="#streamability-extension-instructions">Streamability of
extension instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.3
<a href="#streamability-xsl-analyze-string">Streamability of
xsl:analyze-string</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.4
<a href="#streamability-xsl-apply-imports">Streamability of
xsl:apply-imports</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.5
<a href="#streamability-xsl-apply-templates">Streamability of
xsl:apply-templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.6
<a href="#streamability-xsl-assert">Streamability of
xsl:assert</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.7
<a href="#streamability-xsl-attribute">Streamability of
xsl:attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.8
<a href="#streamability-xsl-break">Streamability of
xsl:break</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.9
<a href="#streamability-xsl-call-template">Streamability of
xsl:call-template</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.10
<a href="#streamability-xsl-choose">Streamability of
xsl:choose</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.11
<a href="#streamability-xsl-comment">Streamability of
xsl:comment</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.12
<a href="#streamability-xsl-copy">Streamability of
xsl:copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.13
<a href="#streamability-xsl-copy-of">Streamability of
xsl:copy-of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.14
<a href="#streamability-xsl-document">Streamability of
xsl:document</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.15
<a href="#streamability-xsl-element">Streamability of
xsl:element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.16
<a href="#streamability-xsl-evaluate">Streamability of
xsl:evaluate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.17
<a href="#streamability-xsl-for-each">Streamability of
xsl:for-each</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.18
<a href="#streamability-xsl-for-each-group">Streamability of
xsl:for-each-group</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.19
<a href="#streamability-xsl-fork">Streamability of
xsl:fork</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.20
<a href="#streamability-xsl-if">Streamability of xsl:if</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.21
<a href="#streamability-xsl-iterate">Streamability of
xsl:iterate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.22
<a href="#streamability-xsl-map">Streamability of xsl:map</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.23
<a href="#streamability-xsl-map-entry">Streamability of
xsl:map-entry</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.24
<a href="#streamability-xsl-merge">Streamability of
xsl:merge</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.25
<a href="#streamability-xsl-message">Streamability of
xsl:message</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.26
<a href="#streamability-xsl-namespace">Streamability of
xsl:namespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.27
<a href="#streamability-xsl-next-iteration">Streamability of
xsl:next-iteration</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.28
<a href="#streamability-xsl-next-match">Streamability of
xsl:next-match</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.29
<a href="#streamability-xsl-number">Streamability of
xsl:number</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.30
<a href="#streamability-xsl-perform-sort">Streamability of
xsl:perform-sort</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.31
<a href="#streamability-xsl-processing-instruction">Streamability
of xsl:processing-instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.32
<a href="#streamability-xsl-result-document">Streamability of
xsl:result-document</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.33
<a href="#streamability-xsl-sequence">Streamability of
xsl:sequence</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.34
<a href="#streamability-xsl-stream">Streamability of
xsl:stream</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.35
<a href="#streamability-xsl-text">Streamability of
xsl:text</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.36
<a href="#streamability-xsl-try">Streamability of xsl:try</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.37
<a href="#streamability-xsl-value-of">Streamability of
xsl:value-of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.38
<a href="#streamability-xsl-variable">Streamability of
xsl:variable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.5 <a href=
"#classifying-attribute-sets">Classifying Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.6 <a href=
"#classifying-vts">Classifying Value Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7 <a href=
"#classifying-expressions">Classifying Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.1
<a href="#streamability-of-for-expressions">Streamability of for
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.2
<a href="#streamability-of-quantified-expressions">Streamability of
Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.3
<a href="#streamability-of-if-expressions">Streamability of if
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.4
<a href="#streamability-of-union-expressions">Streamability of
union, intersect, and except expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.5
<a href=
"#streamability-of-simple-mapping-expressions">Streamability of
Simple Mapping Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.6
<a href="#streamability-of-path-expressions">Streamability of Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.7
<a href="#streamability-of-axis-steps">Streamability of Axis
Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.8
<a href="#streamability-of-filter-expressions">Streamability of
Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.9
<a href="#streamability-of-dynamic-function-calls">Streamability of
Dynamic Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.10
<a href="#streamability-of-variable-references">Streamability of
Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.11
<a href="#streamability-of-context-item-expression">Streamability
of the Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.12
<a href="#streamability-of-function-calls">Streamability of
Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.13
<a href="#streamability-of-named-function-ref">Streamability of
Named Function References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.14
<a href="#streamability-of-inline-functions">Streamability of
Inline Function Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.15
<a href="#streamability-of-map-expressions">Streamability of map
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8 <a href=
"#classifying-built-in-functions">Classifying Calls to Built-In
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.1
<a href="#streamability-fn-accumulator-after">Streamability of the
accumulator-after function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.2
<a href="#streamability-fn-accumulator-before">Streamability of the
accumulator-before function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.3
<a href="#streamability-fn-current">Streamability of the current
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.4
<a href="#streamability-fn-current-group">Streamability of the
current-group function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.5
<a href="#streamability-fn-current-grouping-key">Streamability of
the current-grouping-key function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.6
<a href="#streamability-fn-function-lookup">Streamability of the
function-lookup function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.7
<a href="#streamability-fn-last">Streamability of the last
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.8
<a href="#streamability-fn-outermost">Streamability of the
outermost function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.9
<a href="#streamability-fn-position">Streamability of the position
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.10
<a href="#streamability-fn-root">Streamability of the root
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.11
<a href="#streamability-fn-unparsed-entity-public-id">Streamability
of the unparsed-entity-public-id function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.12
<a href="#streamability-fn-unparsed-entity-uri">Streamability of
the unparsed-entity-uri function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.9 <a href=
"#classifying-patterns">Classifying Patterns</a><br />
&#160;&#160;&#160;&#160;19.9 <a href=
"#streamability-analysis-examples">Examples of Streamability
Analysis</a><br />
&#160;&#160;&#160;&#160;19.10 <a href=
"#streamability-guarantees">Streamability Guarantees</a><br />
20 <a href="#add-func">Additional Functions</a><br />
&#160;&#160;&#160;&#160;20.1 <a href=
"#func-document">fn:document</a><br />
&#160;&#160;&#160;&#160;20.2 <a href="#key">Keys</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.2.1 <a href=
"#xsl-key">The xsl:key Declaration</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.2.2 <a href=
"#func-key">fn:key</a><br />
&#160;&#160;&#160;&#160;20.3 <a href="#misc-func">Miscellaneous
Additional Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.1 <a href=
"#func-current">fn:current</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.2 <a href=
"#func-unparsed-entity-uri">fn:unparsed-entity-uri</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.3 <a href=
"#func-unparsed-entity-public-id">fn:unparsed-entity-public-id</a><br />

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.4 <a href=
"#func-system-property">fn:system-property</a><br />
21 <a href="#additional-types">XPath Extensions</a><br />
&#160;&#160;&#160;&#160;21.1 <a href="#map">Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.1 <a href=
"#map-type">The Type of a Map</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2 <a href=
"#map-functions">Functions that Operate on Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.1
<a href="#func-map-new">map:new</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.2
<a href="#func-map-keys">map:keys</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.3
<a href="#func-map-contains">map:contains</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.4
<a href="#func-map-get">map:get</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.5
<a href="#func-map-entry">map:entry</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.6
<a href="#func-map-remove">map:remove</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.7
<a href="#func-map-for-each-entry">map:for-each-entry</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.8
<a href="#func-collation-key">fn:collation-key</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.10
<a href="#func-deep-equal">fn:deep-equal</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.3 <a href=
"#map-instructions">Map Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.4 <a href=
"#map-expressions">Map Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.5 <a href=
"#maps-streaming">Maps and Streaming</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.6 <a href=
"#map-examples">Examples using Maps</a><br />
&#160;&#160;&#160;&#160;21.2 <a href="#json">Processing JSON
Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.1 <a href=
"#json-to-xml-mapping">XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.2 <a href=
"#func-json-to-xml">fn:json-to-xml</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.3 <a href=
"#xml-to-json">Converting XML to JSON</a><br />
22 <a href="#diagnostics">Diagnostics</a><br />
&#160;&#160;&#160;&#160;22.1 <a href="#message">Messages</a><br />
&#160;&#160;&#160;&#160;22.2 <a href=
"#assertions">Assertions</a><br />
23 <a href="#extension">Extensibility and Fallback</a><br />
&#160;&#160;&#160;&#160;23.1 <a href=
"#extension-functions">Extension Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.1 <a href=
"#func-function-available">fn:function-available</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.2 <a href=
"#calling-extension-functions">Calling Extension
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.3 <a href=
"#external-objects">External Objects</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.4 <a href=
"#func-type-available">fn:type-available</a><br />
&#160;&#160;&#160;&#160;23.2 <a href=
"#extension-instruction">Extension Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.1 <a href=
"#designating-extension-namespace">Designating an Extension
Namespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.2 <a href=
"#func-element-available">fn:element-available</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.3 <a href=
"#fallback">Fallback</a><br />
24 <a href="#result-trees">Final Result Trees</a><br />
&#160;&#160;&#160;&#160;24.1 <a href=
"#creating-result-trees">Creating Final Result Trees</a><br />
&#160;&#160;&#160;&#160;24.2 <a href=
"#validation">Validation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.2.1 <a href=
"#validating-constructed-nodes">Validating Constructed Elements and
Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.2.1.1
<a href="#validating-using-validation-attribute">Validation using
the [xsl:]validation Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.2.1.2
<a href="#validation-xsl-type">Validation using the [xsl:]type
Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.2.1.3
<a href="#validation-process">The Validation Process</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.2.2 <a href=
"#validating-document-nodes">Validating Document Nodes</a><br />
25 <a href="#serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;25.1 <a href="#character-maps">Character
Maps</a><br />
&#160;&#160;&#160;&#160;25.2 <a href=
"#disable-output-escaping">Disabling Output Escaping</a><br />
26 <a href="#conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;26.1 <a href="#basic-conformance">Basic
XSLT Processor</a><br />
&#160;&#160;&#160;&#160;26.2 <a href=
"#schema-aware-conformance">Schema-Awareness Conformance
Feature</a><br />
&#160;&#160;&#160;&#160;26.3 <a href=
"#serialization-feature">Serialization Feature</a><br />
&#160;&#160;&#160;&#160;26.4 <a href=
"#backwards-compatibility-feature">Compatibility Features</a><br />
&#160;&#160;&#160;&#160;26.5 <a href="#streaming-feature">Streaming
Feature</a><br />
&#160;&#160;&#160;&#160;26.6 <a href=
"#dynamic-evaluation-feature">Dynamic Evaluation Feature</a><br />
&#160;&#160;&#160;&#160;26.7 <a href=
"#xquery-invocation-feature">XQuery Invocation
Feature</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#references">References</a><br />
&#160;&#160;&#160;&#160;A.1 <a href=
"#normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#other-references">Other
References</a><br />
B <a href="#json-in-xml">XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#schema-for-json">Schema for
the XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;B.2 <a href=
"#xml-to-json-stylesheet">Stylesheet for converting XML to JSON
(without indentation)</a><br />
&#160;&#160;&#160;&#160;B.3 <a href=
"#xml-to-json-stylesheet-indented">Stylesheet for converting XML to
JSON (with indentation)</a><br />
C <a href="#glossary">Glossary</a> (Non-Normative)<br />
D <a href="#element-syntax-summary">Element Syntax Summary</a>
(Non-Normative)<br />
E <a href="#error-summary">Summary of Error Conditions</a>
(Non-Normative)<br />
F <a href="#implementation-defined-features">Checklist of
Implementation-Defined Features</a> (Non-Normative)<br />
G <a href="#XSLT-defined-functions">List of XSLT-defined
functions</a> (Non-Normative)<br />
H <a href="#schema-for-xslt">Schema for XSLT Stylesheets</a>
(Non-Normative)<br />
I <a href="#acknowledgements">Acknowledgements</a>
(Non-Normative)<br />
J <a href="#changes-since-2.0">Changes since XSLT 2.0</a>
(Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href=
"#xslt-changes-since-2.0">Changes in this Specification</a><br />
&#160;&#160;&#160;&#160;J.2 <a href=
"#xpath-changes-since-2.0">Changes in Other Related
Specifications</a><br />
K <a href="#changes-since-july-2012">Changes since the Working
Draft of 10 July 2012</a> (Non-Normative)<br />
L <a href="#incompatibilities">Incompatibilities with XSLT 2.0</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="introduction" id="introduction"></a>1 <a href=
"#introduction" style="text-decoration: none">Introduction</a></h2>
<div class="div2">
<h3><a name="what-is-xslt" id="what-is-xslt"></a>1.1 <a href=
"#what-is-xslt" style="text-decoration: none">What is
XSLT?</a></h3>
<p>This specification defines the syntax and semantics of the XSLT
<span>3.0</span> language.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet" id="dt-stylesheet" title="stylesheet"></a>A
transformation in the XSLT language is expressed in the form of a
<b>stylesheet</b>, whose syntax is well-formed XML <a href=
"#REC-xml">[XML 1.0]</a> conforming to the Namespaces in XML
Recommendation <a href="#xml-names">[Namespaces in
XML]</a>.<span class="definition">]</span></p>
<p>A stylesheet generally includes elements that are defined by
XSLT as well as elements that are not defined by XSLT. XSLT-defined
elements are distinguished by use of the namespace
<code>http://www.w3.org/1999/XSL/Transform</code> (see <a href=
"#xslt-namespace"><i>3.1 XSLT Namespace</i></a>), which is referred
to in this specification as the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a>. Thus this
specification is a definition of the syntax and semantics of the
XSLT namespace.</p>
<p>The term <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> reflects the fact that one of the
important roles of XSLT is to add styling information to an XML
source document, by transforming it into a document consisting of
XSL formatting objects (see <a href="#xsl11">[XSL-FO]</a>), or into
another presentation-oriented format such as HTML, XHTML, or SVG.
However, XSLT is used for a wide range of transformation tasks, not
exclusively for formatting and presentation applications.</p>
<p>A transformation expressed in XSLT describes rules for
transforming zero or more source trees into one or more result
trees. The structure of these trees is described in <a href=
"#xpath-datamodel-30">[Data Model]</a>. The transformation is
achieved by a set of <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>. A template rule associates
a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, which matches nodes in the source
document, with a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>. In many
cases, evaluating the sequence constructor will cause new nodes to
be constructed, which can be used to produce part of a result tree.
The structure of the result trees can be completely different from
the structure of the source trees. In constructing a result tree,
nodes from the source trees can be filtered and reordered, and
arbitrary structure can be added. This mechanism allows a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
to be applicable to a wide class of documents that have similar
source tree structures.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The use of the term <b>tree</b> in this document does not imply
the use of a data structure in memory that holds the entire
contents of the document at one time. It implies rather a logical
view of the XML input and output in which elements have a
hierarchic relationship to each other. When a source document is
being processed in a streaming manner, access to the nodes in this
tree is constrained, but it is still viewed and described as a
tree.</p>
</div>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> has a modular structure. It may
consist of one or more <a title="package" class="termref" href=
"#dt-package">packages</a> developed independently of each other;
each package defines the services (functions, templates, etc) that
it exposes to its clients. Internally, a package may consist of a
number of <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-principal-stylesheet-module" id=
"dt-principal-stylesheet-module" title=
"principal stylesheet module"></a>For a given transformation, one
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> functions as the
<b>principal stylesheet module</b>. The complete <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
is assembled by finding the <a title="stylesheet module" class=
"termref" href="#dt-stylesheet-module">stylesheet modules</a>
referenced directly or indirectly from the principal stylesheet
module using <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a> elements: see
<a href="#include"><i>3.12.2 Stylesheet Inclusion</i></a> and
<a href="#import"><i>3.12.3 Stylesheet Import</i></a>.<span class=
"definition">]</span></p>
</div>
<div class="div2">
<h3><a name="whats-new-in-xslt3" id="whats-new-in-xslt3"></a>1.2
<a href="#whats-new-in-xslt3" style="text-decoration: none">What's
New in XSLT 3.0?</a></h3>
<p>A major focus for enhancements in XSLT 3.0 is the requirement to
enable streaming of source documents. This is needed when source
documents become too large to hold in main memory, and also for
applications where it is important to start delivering results
before the entire source document is available.</p>
<p>While implementations of XSLT that use streaming have always
been theoretically possible, the nature of the language has made it
very difficult to achieve this in practice. The approach adopted in
this specification is twofold: it identifies a set of restrictions
which, if followed by stylesheet authors, will enable
implementations to adopt a streaming mode of operation without
placing excessive demands on the optimization capabilities of the
processor; and it provides new constructs to indicate that
streaming is required, or to express transformations in a way that
makes it easier for the processor to adopt a streaming execution
plan.</p>
<p>Capabilities provided in this category include:</p>
<ul>
<li>
<p>A new <a href="#element-stream"><code>xsl:stream</code></a>
instruction, which reads and processes a source document in
streaming mode;</p>
</li>
<li>
<p>The ability to declare that a <a title="mode" class="termref"
href="#dt-mode">mode</a> is a streaming mode, in which case all the
template rules using that mode must be streamable;</p>
</li>
<li>
<p>A new <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction, which iterates over the items in a sequence, allowing
parameters for the processing of one item to be set during the
processing of the previous item;</p>
</li>
<li>
<p>A new <a href="#element-merge"><code>xsl:merge</code></a>
instruction, allowing multiple input streams to be merged into a
single output stream;</p>
</li>
<li>
<p>A new <a href="#element-fork"><code>xsl:fork</code></a>
instruction, allowing multiple computations to be performed in
parallel during a single pass through an input document.</p>
</li>
<li>
<p><a title="accumulator function" class="termref" href=
"#dt-accumulator-function">Accumulators</a>, which allow a value to
be computed progressively during streamed processing of a document,
and accessed as a function of a node in the document, without
compromise to the functional nature of the XSLT language.</p>
</li>
</ul>
<p>A second focus for enhancements in XSLT 3.0 is the introduction
of a new mechanism for stylesheet modularity, called the package.
Unlike the stylesheet modules of XSLT 1.0 and 2.0 (which remain
available), a package defines an interface that regulates which
functions, variables, templates and other components are visible
outside the package, and which can be overridden. There are two
main goals for this facility: it is designed to deliver software
engineering benefits by improving the reusability and
maintainability of code, and it is intended to streamline
stylesheet deployment by allowing packages to be compiled
independently of each other, and compiled instances of packages to
be shared between multiple applications.</p>
<p>Other significant features in XSLT 3.0 include:</p>
<ul>
<li>
<p>An <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction allowing evaluation of XPath expressions that are
dynamically constructed as strings, or that are read from a source
document;</p>
</li>
<li>
<p>Enhancements to the syntax of <a title="pattern" class="termref"
href="#dt-pattern">patterns</a>, in particular enabling the
matching of atomic values as well as nodes;</p>
</li>
<li>
<p>An <a href="#element-try"><code>xsl:try</code></a> instruction
to allow recovery from dynamic errors;</p>
</li>
<li>
<p>The element <a href=
"#element-context-item"><code>xsl:context-item</code></a>, used to
declare the stylesheet's expectations of the initial context item
(notably, its type), given the initial mode.</p>
</li>
<li>
<p>A new instruction <a href=
"#element-assert"><code>xsl:assert</code></a> to assist developers
in producing correct and robust code.</p>
</li>
</ul>
<p>XSLT 3.0 also delivers enhancements made to the XPath language
and to the standard function library, including the following:</p>
<ul>
<li>
<p>Variables can now be bound in XPath using the <code>let</code>
expression.</p>
</li>
<li>
<p>Functions are now first class values, and can be passed as
arguments to other (higher-order) functions, making XSLT a
fully-fledged functional programming language.</p>
</li>
<li>
<p>A number of new functions are available, for example
trigonometric functions, and the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-parse-xml"><code>parse-xml</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-serialize"><code>serialize</code></a><sup><small>FO30</small></sup>
to convert between lexical and tree representations of XML.</p>
</li>
</ul>
<p>This Working Draft includes support for maps (a data structure
consisting of key/value pairs, sometimes referred to in other
programming languages as dictionaries, hashes, or associative
arrays). This feature extends the data model, provides new syntax
in XPath, and adds a number of new functions and operators. The XSL
Working Group intends that these changes should eventually become
part of XPath: however, this has not yet been agreed with all
interested parties.</p>
<p>A full list of changes is at <a href="#changes-since-2.0"><i>J
Changes since XSLT 2.0</i></a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="concepts" id="concepts"></a>2 <a href="#concepts"
style="text-decoration: none">Concepts</a></h2>
<div class="div2">
<h3><a name="terminology" id="terminology"></a>2.1 <a href=
"#terminology" style="text-decoration: none">Terminology</a></h3>
<p>For a full glossary of terms, see <a href="#glossary"><i>C
Glossary</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-processor" id="dt-processor" title="processor"></a>The software
responsible for transforming source trees into result trees using
an XSLT stylesheet is referred to as the <b>processor</b>. This is
sometimes expanded to <em>XSLT processor</em> to avoid any
confusion with other processors, for example an XML
processor.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation" id="dt-implementation" title=
"implementation"></a>A specific product that performs the functions
of an <a title="processor" class="termref" href=
"#dt-processor">XSLT processor</a> is referred to as an
<b>implementation</b>. <span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-result-tree" id="dt-result-tree" title="result tree"></a>The
term <b>result tree</b> is used to refer to any tree constructed by
<a title="instruction" class="termref" href=
"#dt-instruction">instructions</a> in the stylesheet. A result tree
is either a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-final-result-tree" id="dt-final-result-tree" title=
"final result tree"></a>A <b>final result tree</b> is a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> that forms part of the final output of a transformation.
Once created, the contents of a final result tree are not
accessible within the stylesheet itself.<span class=
"definition">]</span> The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction always creates a final result tree, and a final result
tree may also be created implicitly by the <a title=
"initial template" class="termref" href=
"#dt-initial-template">initial template</a>. The conditions under
which this happens are described in <a href=
"#executing-a-transformation"><i>2.4 Executing a
Transformation</i></a>. A final result tree <span class=
"verb">may</span> be serialized as described in <a href=
"#serialization"><i>25 Serialization</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-source-tree" id="dt-source-tree" title="source tree"></a>The
term <b>source tree</b> means any tree provided as input to the
transformation. This includes the document containing the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> if any,
documents containing nodes supplied as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, documents
obtained from the results of functions such as <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>documents read using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction,</span>
and documents returned by extension functions or extension
instructions. In the context of a particular XSLT instruction, the
term <b>source tree</b> means any tree provided as input to that
instruction; this may be a source tree of the transformation as a
whole, or it may be a <a title="temporary tree" class="termref"
href="#dt-temporary-tree">temporary tree</a> produced during the
course of the transformation.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-temporary-tree" id="dt-temporary-tree" title=
"temporary tree"></a>The term <b>temporary tree</b> means any tree
that is neither a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> nor a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.<span class=
"definition">]</span> Temporary trees are used to hold intermediate
results during the execution of the transformation.</p>
<p>The use of the term "tree" in phrases such as <b>source
tree</b>, <b>result tree</b>, and <b>temporary tree</b> is not
confined to documents that the processor materializes in memory in
their entirety. The processor <span class="verb">may</span>, and in
some cases <span class="verb">must</span>, use streaming techniques
to limit the amount of memory used to hold source and result
documents. When streaming is used, the nodes of the tree may never
all be in memory at the same time, but at an abstract level the
information is still modeled as a tree of nodes, and the document
is therefore still described as a tree.</p>
<p>In this specification the phrases <span class=
"verb">must</span>, <span class="verb">must not</span>,
<span class="verb">should</span>, <span class="verb">should
not</span>, <span class="verb">may</span>, <span class=
"verb">required</span>, and <span class="verb">recommended</span>,
<span>when used in normative text and rendered in capitals,</span>
are to be interpreted as described in <a href=
"#rfc2119">[rfc2119]</a>.</p>
<p>Where the phrase <span class="verb">must</span>, <span class=
"verb">must not</span>, or <span class="verb">required</span>
relates to the behavior of the XSLT processor, then an
implementation is not conformant unless it behaves as specified,
subject to the more detailed rules in <a href="#conformance"><i>26
Conformance</i></a>.</p>
<p>Where the phrase <span class="verb">must</span>, <span class=
"verb">must not</span>, or <span class="verb">required</span>
relates to a stylesheet then the processor <span class=
"verb">must</span> enforce this constraint on stylesheets by
reporting an error if the constraint is not satisfied.</p>
<p>Where the phrase <span class="verb">should</span>, <span class=
"verb">should not</span>, or <span class="verb">recommended</span>
relates to a stylesheet then a processor <span class=
"verb">may</span> produce warning messages if the constraint is not
satisfied, but <span class="verb">must not</span> treat this as an
error.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation-defined" id="dt-implementation-defined" title=
"implementation-defined"></a>In this specification, the term
<b>implementation-defined</b> refers to a feature where the
implementation is allowed some flexibility, and where the choices
made by the implementation <span class="verb">must</span> be
described in documentation that accompanies any conformance
claim.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation-dependent" id="dt-implementation-dependent"
title="implementation-dependent"></a>The term
<b>implementation-dependent</b> refers to a feature where the
behavior <span class="verb">may</span> vary from one implementation
to another, and where the vendor is not expected to provide a full
specification of the behavior.<span class="definition">]</span>
(This might apply, for example, to limits on the size of source
documents that can be transformed.)</p>
<p>In all cases where this specification leaves the behavior
implementation-defined or implementation-dependent, the
implementation has the option of providing mechanisms that allow
the user to influence the behavior.</p>
<p>A paragraph labeled as a <b>Note</b> or described as an
<b>example</b> is non-normative.</p>
<p>Many terms used in this document are defined in the XPath
specification <a href="#xpath-30">[XPath 3.0]</a> or the XDM
specification <a href="#xpath-datamodel-30">[Data Model]</a>.
Particular attention is drawn to the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-atomization" id="dt-atomization" title="atomize"></a>The term
<b>atomization</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-atomization">Section 2.4.2
Atomization</a> <sup><small>XP30</small></sup>. It is a process
that takes as input a sequence of <span>items</span>, and returns a
sequence of atomic values, in which the nodes are replaced by their
typed values as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.<span class="definition">]</span> For some
<span>items</span> (for example, elements with element-only
content, <span>and function items</span>), atomization generates a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-typed-value" id="dt-typed-value" title="typed value"></a>The
term <b>typed value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section
5.15 typed-value Accessor</a> <sup><small>DM30</small></sup>. Every
node, <span>other than an element whose type annotation identifies
it as having</span> element-only content, has a <a title=
"string value" class="termref" href="#dt-string-value">typed
value</a>. For example, the <a title="typed value" class="termref"
href="#dt-typed-value">typed value</a> of an attribute of type
<code>xs:IDREFS</code> is a sequence of zero or more
<code>xs:IDREF</code> values.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-string-value" id="dt-string-value" title="string value"></a>The
term <b>string value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section
5.13 string-value Accessor</a> <sup><small>DM30</small></sup>.
Every node has a <a title="string value" class="termref" href=
"#dt-string-value">string value</a>. For example, the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an element is the concatenation of the <a title=
"string value" class="termref" href="#dt-string-value">string
values</a> of all its descendant text nodes.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode"></a>The term <b>XPath 1.0
compatibility mode</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#static_context">Section 2.1.1
Static Context</a> <sup><small>XP30</small></sup>. This is a
setting in the static context of an XPath expression; it has two
values, <code>true</code> and <code>false</code>. When the value is
set to true, the semantics of function calls and certain other
operations are adjusted to give a greater degree of backwards
compatibility between <span>XPath 3.0</span> and XPath
1.0.<span class="definition">]</span></p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-core-function" id="dt-core-function" title=
"core function"></a>The term <b>core function</b> means a function
that is specified in <a href="#xpath-functions-30">[Functions and
Operators]</a> and that is in the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a>.<span class="definition">]</span></p>
</div>
<div class="div2">
<h3><a name="notation" id="notation"></a>2.2 <a href="#notation"
style="text-decoration: none">Notation</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-element" id="dt-xslt-element" title="XSLT element"></a>An
<b>XSLT element</b> is an element in the <a title="XSLT namespace"
class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose
syntax and semantics are defined in this specification.<span class=
"definition">]</span> For a non-normative list of XSLT elements,
see <a href="#element-syntax-summary"><i>D Element Syntax
Summary</i></a>.</p>
<p>In this document the specification of each <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a> is preceded by a summary of its syntax in the form of a
model for elements of that element type. A full list of all these
specifications can be found in <a href=
"#element-syntax-summary"><i>D Element Syntax Summary</i></a>. The
meaning of syntax summary notation is as follows:</p>
<ul>
<li>
<p>An attribute that is <span class="verb">required</span> is shown
with its name in bold. An attribute that may be omitted is shown
with a question mark following its name.</p>
</li>
<li>
<p>An attribute that is <a title="deprecated" class="termref" href=
"#dt-deprecated">deprecated</a> is shown in a grayed font within
square brackets.</p>
</li>
<li>
<p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute. If this is
surrounded by curly brackets (<code>{...}</code>), then the
attribute value is treated as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, and
the string occurring within curly brackets specifies the allowed
values of the result of evaluating the attribute value template.
Alternative allowed values are separated by <code>|</code>. A
quoted string indicates a value equal to that specific string. An
unquoted, italicized name specifies a particular type of value.</p>
<p>The types used are as follows:</p>
<table summary=
"Types used in element syntax summaries, and their meaning" border=
"1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Type name</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">string</td>
<td align="left" valign="top">Any string</td>
</tr>
<tr>
<td align="left" valign="top">expression</td>
<td align="left" valign="top">An XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a></td>
</tr>
<tr>
<td align="left" valign="top">pattern</td>
<td align="left" valign="top">A <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> as described in <a href=
"#patterns"><i>5.6 Patterns</i></a>.</td>
</tr>
<tr>
<td align="left" valign="top">sequence-type</td>
<td align="left" valign="top">A <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>
as defined in the XPath specification</td>
</tr>
<tr>
<td align="left" valign="top">uri; uris</td>
<td align="left" valign="top">A URI, for example a namespace URI or
a collation URI; a whitespace-separated list of URIs</td>
</tr>
<tr>
<td align="left" valign="top">qname</td>
<td align="left" valign="top">A <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> as defined in
<a href="#qname"><i>5.1 Qualified Names</i></a></td>
</tr>
<tr>
<td align="left" valign="top">eqname; eqnames</td>
<td align="left" valign="top">An <a title="EQName" class="termref"
href="#dt-eqname">EQName</a> as defined in <a href="#qname"><i>5.1
Qualified Names</i></a>; a whitespace-separated list of
EQNames</td>
</tr>
<tr>
<td align="left" valign="top">token; tokens</td>
<td align="left" valign="top">A string containing no significant
whitespace; a whitespace-separated list of such strings</td>
</tr>
<tr>
<td align="left" valign="top">nmtoken; nmtokens</td>
<td align="left" valign="top">A string conforming to the XML schema
rules for the type <code>xs:NMTOKEN</code>; a whitespace-separated
list of such strings.</td>
</tr>
<tr>
<td align="left" valign="top">char</td>
<td align="left" valign="top">A string comprising a single Unicode
character</td>
</tr>
<tr>
<td align="left" valign="top">integer</td>
<td align="left" valign="top">An integer, that is a string in the
lexical space of the schema type <code>xs:integer</code></td>
</tr>
<tr>
<td align="left" valign="top">decimal</td>
<td align="left" valign="top">A decimal value, that is a string in
the lexical space of the schema type <code>xs:decimal</code></td>
</tr>
<tr>
<td align="left" valign="top">ncname</td>
<td align="left" valign="top">An unprefixed name: a string in the
value space of the schema type <code>xs:NCName</code></td>
</tr>
<tr>
<td align="left" valign="top">prefix</td>
<td align="left" valign="top">An <code>xs:NCName</code>
representing a namespace prefix, which must be in scope for the
element on which it appears</td>
</tr>
<tr>
<td align="left" valign="top">id</td>
<td align="left" valign="top">An <code>xs:NCName</code> used as a
unique identifier for an element in the containing XML
document</td>
</tr>
</tbody>
</table>
<p>Except where the set of allowed values of an attribute is
specified using the italicized name <em>string</em> or
<em>char</em>, leading and trailing whitespace in the attribute
value is ignored. In the case of an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, this
applies to the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> obtained when the
attribute value template is expanded.</p>
</li>
<li>
<p>Unless the element is <span class="verb">required</span> to be
empty, the model element contains a comment specifying the allowed
content. The allowed content is specified in a similar way to an
element type declaration in XML; <em>sequence constructor</em>
means that any mixture of text nodes, <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>, <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, and
<a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a> from the <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> category is allowed;
<em>other-declarations</em> means that any mixture of XSLT elements
from the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> category, other than <a href=
"#element-import"><code>xsl:import</code></a>, is allowed, together
with <a title="user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a>.</p>
</li>
<li>
<p>The element is prefaced by comments indicating if it belongs to
the <code>instruction</code> category or <code>declaration</code>
category or both. The category of an element only affects whether
it is allowed in the content of elements that allow a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> or
<em>other-declarations</em>.</p>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e1013" id=
"d7e1013"></a>Example: Syntax Notation</div>
<p>This example illustrates the notation used to describe <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
elements</a>.</p>
<p class="element-syntax"><a name="element-example-element" id=
"element-example-element"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:example-element<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;debug? = { "yes" | "no" }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a>)*, <a href=
"#element-sequence">xsl:sequence</a>) --&gt;<br />
&lt;/xsl:example-element&gt;</code></p>
<p>This example defines a (non-existent) element
<code>xsl:example-element</code>. The element is classified as an
instruction. It takes a mandatory <code>select</code> attribute,
whose value is an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, and an optional <code>debug</code>
attribute, whose value <span class="verb">must</span> be either
<code>yes</code> or <code>no</code>; the curly brackets indicate
that the value can be defined as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>,
allowing a value such as <code>debug="{$debug}"</code>, where the
<a title="variable" class="termref" href=
"#dt-variable">variable</a> <code>debug</code> is evaluated to
yield <code>"yes"</code> or <code>"no"</code> at run-time.</p>
<p>The content of an <code>xsl:example-element</code> instruction
is defined to be a sequence of zero or more <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> elements, followed by
an <a href="#element-sequence"><code>xsl:sequence</code></a>
element.</p>
</div>
<p><a name="err-XTSE0010" id="err-XTSE0010"><span class=
"error">[ERR XTSE0010]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
XSLT-defined element is used in a context where it is not
permitted, if a <span class="verb">required</span> attribute is
omitted, or if the content of the element does not correspond to
the content that is allowed for the element.</p>
<p>Attributes are validated as follows. These rules apply to the
value of the attribute after removing leading and trailing
whitespace.</p>
<ul>
<li>
<p><a name="err-XTSE0020" id="err-XTSE0020"><span class=
"error">[ERR XTSE0020]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
attribute (other than an attribute written using curly brackets in
a position where an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a> is permitted) contains a value that is not one of the
permitted values for that attribute.</p>
</li>
<li>
<p><a name="err-XTDE0030" id="err-XTDE0030"><span class=
"error">[ERR XTDE0030]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of an attribute written
using curly brackets, in a position where an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted, is a value that is not one of the permitted values for
that attribute. If the processor is able to detect the error
statically (for example, when any XPath expressions within the
curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.</p>
</li>
</ul>
<p>Special rules apply if the construct appears in part of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that is processed with <a title=
"forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible
behavior</a>: see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-deprecated" id="dt-deprecated" title="deprecated"></a>Some
constructs defined in this specification are described as being
<b>deprecated</b>. The use of this term implies that stylesheet
authors <span class="verb">should not</span> use the construct, and
that the construct may be removed in a later version of this
specification.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This working draft includes a non-normative XML Schema for XSLT
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> (see <a href=
"#schema-for-xslt"><i>H Schema for XSLT Stylesheets</i></a>). The
syntax summaries described in this section are normative.</p>
</div>
<p>XSLT defines a set of standard functions which are additional to
those defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. <span>A list of these functions appears in <a href=
"#XSLT-defined-functions"><i>G List of XSLT-defined
functions</i></a>.</span> The signatures of these functions are
described using the same notation as used in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. The names of
<span>many of</span> these functions are in the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a>.</p>
</div>
<div class="div2">
<h3><a name="initiating" id="initiating"></a>2.3 <a href=
"#initiating" style="text-decoration: none">Initiating a
Transformation</a></h3>
<p>This document does not specify any application programming
interfaces or other interfaces for initiating a transformation.
This section, however, describes the information that is supplied
when a transformation is initiated. Except where otherwise
indicated, the information is <span class=
"verb">required</span>.</p>
<p>The execution of a stylesheet necessarily involves two
activities: static analysis and dynamic evaluation. Static analysis
consists of those tasks that can be performed by inspection of the
stylesheet alone, including <span>the binding of <a title=
"static variable" class="termref" href="#dt-static-variable">static
variables</a>,</span> the evaluation of <code>[xsl:]use-when</code>
expressions (see <a href="#conditional-inclusion"><i>3.14
Conditional Element Inclusion</i></a>), and detection of <a title=
"static error" class="termref" href="#dt-static-error">static
errors</a>. Dynamic evaluation consists of tasks which in general
cannot be carried out until a source document is available.</p>
<p>Dynamic evaluation is further divided into two activities:
<b>priming</b> the stylesheet, and <b>invoking</b> a selected
component.</p>
<ul>
<li>
<p>Priming the stylesheet provides the dynamic context for
evaluation, and supplies all the information needed to establish
the values of global variables.</p>
</li>
<li>
<p>Invoking a component (such as a template or function) causes
evaluation of that template or function to produce a result, which
is an arbitrary XDM value.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-raw-result" id="dt-raw-result" title="raw result"></a>The
result of invoking the selected component, after any required
conversion to the declared result type of the component, is
referred to as the <b>raw result</b>.<span class=
"definition">]</span></p>
<p>This raw result may optionally be post-processed to construct a
result tree, to serialize the result, or both, as described in
<a href="#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a>.</p>
</li>
</ul>
<p>Implementations <span class="verb">may</span> allow static
analysis and dynamic evaluation to be initiated independently, so
that the cost of static analysis can be amortized over multiple
transformations using the same stylesheet. <span>Implementations
<span class="verb">may</span> also allow priming of a stylesheet
and invocation of components to be initiated independently, in
which case a single act of priming the stylesheet may be followed
by a series of independent component invocations. Although this
specification does not require such a separation, this section
distinguishes information that is needed before static analysis can
proceed, information that is needed to prime the stylesheet, and
information that is needed when invoking components.</span></p>
<p>The language is designed to allow the static analysis of each
<a title="package" class="termref" href="#dt-package">package</a>
to be performed independently of other packages, with only basic
knowledge of the properties of components made available by used
packages. Beyond this, the specification leaves it to
implementations to decide how to organize this process. When
packages are not used explicitly, the entire stylesheet is treated
as a single package.</p>
<div class="div3">
<h4><a name="info-for-static-analysis" id=
"info-for-static-analysis"></a>2.3.1 <a href=
"#info-for-static-analysis" style=
"text-decoration: none">Information needed for Static
Analysis</a></h4>
<p>The following information is needed prior to static analysis
<span>of a package</span>:</p>
<ul>
<li>
<p>The location of the <a title="package manifest" class="termref"
href="#dt-package-manifest">package manifest</a>, or in the absence
of a package manifest, the <a title="stylesheet module" class=
"termref" href="#dt-stylesheet-module">stylesheet module</a> that
is to act as the <a title="principal stylesheet module" class=
"termref" href="#dt-principal-stylesheet-module">principal
stylesheet module</a> for the transformation. The complete
<a title="package" class="termref" href="#dt-package">package</a>
is assembled by recursively expanding the <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations in the
principal stylesheet module, as described in <a href=
"#include"><i>3.12.2 Stylesheet Inclusion</i></a> and <a href=
"#import"><i>3.12.3 Stylesheet Import</i></a>.</p>
</li>
<li>
<p>Information about the packages referenced from this package
using <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declarations. The information needed will include the names and
signatures of public components exported by the referenced
package.</p>
</li>
<li>
<p>A set (possibly empty) of values for <a title="static parameter"
class="termref" href="#dt-static-parameter">static parameters</a>
(see <a href="#global-variables"><i>9.5 Global Variables and
Parameters</i></a>). These values are available for use within
<a title="static expression" class="termref" href=
"#dt-static-expression">static expressions</a> (notably
<code>[xsl:]use-when</code> expressions) as well as non-static
expressions in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>. As a minimum, values <span class=
"verb">must</span> be supplied for any static parameters declared
with the attribute <code>required="yes"</code>.</p>
</li>
</ul>
<p>Conceptually, the output of the static analysis of a package is
an object which might be referred to (without constraining the
implementation) as a compiled package. Prior to dynamic evaluation,
all the compiled packages needed for execution must be checked for
consistency, and component references must be resolved. This
process may be referred to, again without constraining the
implementation, as linking.</p>
</div>
<div class="div3">
<h4><a name="priming-stylesheet" id="priming-stylesheet"></a>2.3.2
<a href="#priming-stylesheet" style="text-decoration: none">Priming
a Stylesheet</a></h4>
<p>The information needed when priming a stylesheet is as
follows:</p>
<ul>
<li>
<p>A set (possibly empty) of values for <span>non-static</span>
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>). These values are available for use within
<a title="expression" class="termref" href=
"#dt-expression">expressions</a> in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum,
values <span class="verb">must</span> be supplied for any
parameters declared with the attribute
<code>required="yes"</code>.</p>
<p>A supplied value is converted if necessary to the declared type
of the stylesheet parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is possible for static stylesheet parameters to be declared
in any package, and stylesheet parameters in different packages
might have the same name.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-context-item" id="dt-initial-context-item" title=
"initial context item"></a>An item that acts as the <b>initial
context item</b> for the transformation. This item is accessible
within the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> as the initial value of the XPath
<a title="expression" class="termref" href=
"#dt-expression">expressions</a> <code>.</code> (dot) and
<code>self::node()</code>, as described in <a href=
"#focus"><i>5.4.3.1 Maintaining Position: the Focus</i></a>
<span class="definition">]</span>.</p>
<p>The <a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> is potentially
used when initializing global variables and parameters. If the
initialization of any <a title="global variable" class="termref"
href="#dt-global-variable">global variables</a> or <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">parameter</a> depends on the context
item, a dynamic error can occur if the context item is absent. It
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
this error occurs during priming of the stylesheet or subsequently
when the variable is referenced; and it is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether the
error occurs at all if the variable or parameter is never
referenced. The error can be suppressed by use of <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a> within the
initialization of the variable or parameter.</p>
<p>If no initial context item is supplied, then the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> will initially be <a title="absent" class="termref" href=
"#dt-absent">absent</a>, and the evaluation of any expression that
references these values will result in a dynamic error. (Note that
the initial context size and context position will always be 1
(one) when an <span><a title="initial context item" class="termref"
href="#dt-initial-context-item">initial context item</a></span> is
supplied, and will be <a title="absent" class="termref" href=
"#dt-absent">absent</a> if no initial context item is
supplied).</p>
</li>
<li>
<p>A base output URI. <span class=
"definition">[Definition:&#160;</span><a name="dt-base-output-uri"
id="dt-base-output-uri" title="base output URI"></a> The <b>base
output URI</b> is a URI to be used as the base URI when resolving a
relative URI <span>reference</span> allocated to a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>. If the
transformation generates more than one final result tree, then
typically each one will be allocated a URI relative to this base
URI. <span class="definition">]</span> The way in which a base
output URI is established is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>A mechanism for obtaining a document node and a media type,
given an absolute URI. The total set of available documents
(modeled as a mapping from URIs to document nodes) forms part of
the context for evaluating XPath expressions, specifically the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function. The XSLT <a href=
"#func-document"><code>document</code></a> function additionally
requires the media type of the resource representation, for use in
interpreting any fragment identifier present within a URI
Reference.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The set of documents that are available to the stylesheet is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, as is
the processing that is carried out to construct a tree representing
the resource retrieved using a given URI. Some possible ways of
constructing a document (specifically, rules for constructing a
document from an Infoset or from a PSVI) are described in <a href=
"#xpath-datamodel-30">[Data Model]</a>.</p>
</div>
</li>
</ul>
<p>Once a stylesheet is primed, the values of global variables
remain stable through all component invocations. In addition,
priming a stylesheet creates an <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> during which the dynamic
context and all function calls remain stable; for example two calls
on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> function
within an execution scope are defined to return the same
result.</p>
<p>Parameters passed to the transformation by the client
application <span>when a stylesheet is primed</span> are matched
against <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>), not against the <a title="template parameter"
class="termref" href="#dt-template-parameter">template
parameters</a> declared within the <a title="initial template"
class="termref" href="#dt-initial-template">initial
template</a>.</p>
<p><a name="err-XTDE0050" id="err-XTDE0050"><span class=
"error">[ERR XTDE0050]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if a
stylesheet declares a visible <a title="stylesheet parameter"
class="termref" href="#dt-stylesheet-parameter">stylesheet
parameter</a> with <code>required="yes"</code> and no value for
this parameter is supplied when the stylesheet is primed. A
stylesheet parameter is visible if it is not masked by another
global variable or parameter with the same name and higher
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>. <span>If the
parameter is a <a title="static parameter" class="termref" href=
"#dt-static-parameter">static parameter</a> then the value
<span class="verb">must</span> be supplied prior to the static
analysis phase.</span></p>
</div>
<div class="div3">
<h4><a name="invoking-initial-mode" id=
"invoking-initial-mode"></a>2.3.3 <a href="#invoking-initial-mode"
style="text-decoration: none">Invoking an Initial Mode</a></h4>
<p>When the stylesheet is evaluated by invoking a <a title="mode"
class="termref" href="#dt-mode">mode</a>, processing proceeds by
finding the <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> that match the items in a
supplied input sequence, and evaluating these template rules with a
<a title="focus" class="termref" href="#dt-focus">focus</a> based
on this input sequence.</p>
<p>The following information is needed when dynamic evaluation is
to start with a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>:</p>
<ul>
<li>
<p>Optionally, a sequence of items to be processed. If no input
sequence is supplied explicitly, this defaults to a singleton
sequence containing the <a title="initial context item" class=
"termref" href="#dt-initial-context-item">initial context
item</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In earlier versions of this specification, the initial input
sequence (to which templates are applied) was always the same as
the initial context item (used for computing the values of global
variables), and since this is the most common scenario, it is
likely to affect the design of APIs.</p>
</div>
</li>
<li>
<p>Optionally, an initial <a title="mode" class="termref" href=
"#dt-mode">mode</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-mode" id="dt-initial-mode" title="initial mode"></a>The
initial mode, if specified, <span class="verb">must</span> either
be the default mode, or a mode that is explicitly named
<span>either in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span> in
the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> declaration
within the stylesheet. If an initial mode is supplied, then in
searching for the <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that best matches the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span>, the
processor considers only those rules that apply to the initial
mode. If no initial mode is supplied, then the mode used is that
named in the <span><code>default-mode</code> attribute of the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element of the <a title="principal stylesheet module" class=
"termref" href="#dt-principal-stylesheet-module">principal
stylesheet module</a>; or failing that, the mode named in the
<code>default-mode</code> attribute of its containing <a href=
"#element-package"><code>xsl:package</code></a> element;</span> or
in the absence of such an attribute, the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed
mode</a>.<span class="definition">]</span></p>
</li>
<li>
<p>Parameters, which will be passed to the template rules used to
process items in the input sequence. The parameters consist of two
sets of (QName, value) pairs, one set for <a title=
"tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel
parameters, in which the QName identifies the name of a parameter
and the value provides the value of the parameter. Either or both
sets of parameters may be empty. The effect is the same as when a
template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as
appropriate. If a parameter is supplied that is not declared or
used, the value is simply ignored. These parameters are
<em>not</em> used to set <a title="stylesheet parameter" class=
"termref" href="#dt-stylesheet-parameter">stylesheet
parameters</a>.</p>
<p>A supplied value is converted if necessary to the declared type
of the template parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
processing the supplied input sequence as if by a call on <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
the specified mode: specifically, each item in the input sequence
is processed by selecting and evaluating the best matching template
rule, and converting the result (if necessary) to the type declared
in the <code>as</code> attribute of that template using the
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>; and
the results of processing each item are then concatenated into a
single sequence, respecting the order of items in the input
sequence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the initial mode is a <a title="streamable mode" class=
"termref" href="#dt-streamable-mode">streamable mode,</a> then
streaming will only be possible if nodes in the input sequence are
supplied in a form that allows such processing: for example, as a
reference to a stream of parsing events.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The design of the API for invoking a transformation should
provide some means for users to designate the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a> as the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> in cases where it is not the
default mode.</p>
</div>
<p><a name="err-XTDE0044" id="err-XTDE0044"><span class=
"error">[ERR XTDE0044]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> and if no input
sequence is supplied (either explicitly, or defaulted to the
<a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a>).</p>
<p><a name="err-XTDE0045" id="err-XTDE0045"><span class=
"error">[ERR XTDE0045]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> (other than the
unnamed mode) that does not match <span>either the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> in the <code>name</code> attribute of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span>
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in the <code>mode</code>
attribute of any template defined in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can process further source
documents in addition to those supplied when the transformation is
invoked. These additional documents can be loaded using the
functions <a href="#func-document"><code>document</code></a> (see
<a href="#func-document"><i>20.1 fn:document</i></a>) or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
(see <a href="#xpath-functions-30">[Functions and Operators]</a>),
<span>or using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction</span>;
alternatively, they can be supplied as <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>), or returned as the result of an <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> (see <a href=
"#extension-functions"><i>23.1 Extension Functions</i></a>).</p>
</div>
</div>
<div class="div3">
<h4><a name="invoking-initial-template" id=
"invoking-initial-template"></a>2.3.4 <a href=
"#invoking-initial-template" style="text-decoration: none">Invoking
an Initial Template</a></h4>
<p>The following additional information is needed when dynamic
evaluation is to start with a <a title="named template" class=
"termref" href="#dt-named-template">named template</a>:</p>
<ul>
<li>
<p>Optionally, the name of a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> which is to
be executed as the entry point to the transformation. <span>If no
template name is supplied, the default template name is
<code>xsl:initial-template</code>.</span> The selected template
<span class="verb">must</span> exist within the <a title=
"stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
</li>
<li>
<p>Optionally, a context item for evaluation of this named
template, defaulting to the <a title="initial context item" class=
"termref" href="#dt-initial-context-item">initial context item</a>
if it exists.</p>
</li>
<li>
<p>Parameters, which will be passed to the selected template rule.
The parameters consist of two sets of (QName, value) pairs, one set
for <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel
parameters, in which the QName identifies the name of a parameter
and the value provides the value of the parameter. Either or both
sets of parameters may be empty. The effect is the same as when a
template is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a> with an
<a href="#element-with-param"><code>xsl:with-param</code></a> child
specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as
appropriate. If a parameter is supplied that is not declared or
used, the value is simply ignored. These parameters are
<em>not</em> used to set <a title="stylesheet parameter" class=
"termref" href="#dt-stylesheet-parameter">stylesheet
parameters</a>.</p>
<p>A supplied value is converted if necessary to the declared type
of the template parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
evaluating the initial template, after conversion of the result to
the type declared in the <code>as</code> attribute of that template
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>,
if such conversion is necessary.</p>
<p><a name="err-XTDE0040" id="err-XTDE0040"><span class=
"error">[ERR XTDE0040]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a template name that does
not match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of a named template defined
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, <span>whose visibility is
<code>public</code> or <code>final</code></span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-template" id="dt-initial-template" title=
"initial template"></a>The transformation is performed by
evaluating an <b>initial template</b>. If a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a> is supplied when the transformation is initiated, then
this is the initial template; otherwise, the initial template is
the <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> selected according to the
rules of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction for processing the <span><a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> in the
initial <a title="mode" class="termref" href=
"#dt-mode">mode</a>.<span class="definition">]</span></p>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> <span class="error">[see
<a href="#err-XTDE0060">ERR XTDE0060</a>]</span> if the <a title=
"initial template" class="termref" href=
"#dt-initial-template">initial template</a> defines a <a title=
"template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> that specifies
<code>required="yes"</code> <span>and no value is supplied for that
parameter</span>.</p>
</div>
<div class="div3">
<h4><a name="invoking-initial-function" id=
"invoking-initial-function"></a>2.3.5 <a href=
"#invoking-initial-function" style="text-decoration: none">Invoking
an Initial Function</a></h4>
<p>The following additional information is needed when dynamic
evaluation is to start with a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet
function</a></p>
<ul>
<li>
<p>The name and arity of a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet function</a>
which is to be executed as the entry point to the
transformation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the design of a concrete API, the arity may be inferred from
the length of the parameter list.</p>
</div>
</li>
<li>
<p>A list of values to act as parameters to the initial function.
The number of values in the list must be the same as the arity of
the function.</p>
<p>A supplied value is converted if necessary to the declared type
of the stylesheet parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
evaluating the initial function, after conversion of the result to
the type declared in the <code>as</code> attribute of that function
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>,
if such conversion is necessary.</p>
<p><a name="err-XTDE0041" id="err-XTDE0041"><span class=
"error">[ERR XTDE0041]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a function name and arity
that does not match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> and arity of a named
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, whose visibility is
<code>public</code> or <code>final</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-function" id="dt-initial-function" title=
"initial function"></a>The transformation is performed by
evaluating an <b>initial function</b>. <span class=
"definition">]</span></p>
<p><a name="err-XTDE0060" id="err-XTDE0060"><span class=
"error">[ERR XTDE0060]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a> defines a <a title=
"template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> that specifies
<code>required="yes"</code>.</p>
</div>
<div class="div3">
<h4><a name="post-processing" id="post-processing"></a>2.3.6
<a href="#post-processing" style=
"text-decoration: none">Post-processing the Raw Result</a></h4>
<p>At user option, the <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of a component invocation may
either be returned to the calling application unchanged, or it may
be post-processed. Two stages of post-processing are defined, both
of which are optional:</p>
<ol class="enumar">
<li>
<p><b>Result tree construction</b></p>
<p>If the raw result is non-empty, then it is used to construct an
implicit <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, following the rules
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>: the effect is as if the raw
result <var>R</var> were processed by the following function:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="construct-result-tree" as="document-node()"&gt;
  &lt;xsl:param name="R" as="item()*"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;xsl:sequence select="$R"/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:function&gt;
</pre></div>
<p>An implicit result tree is also created when the raw result is
empty, provided that no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated during the course of the
transformation. In this situation the implicit result tree will
consist of a document node with no children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that there is always at least one result tree. It
also means that if the content of the initial template is a single
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, as in the example above, then only one result tree is
produced, not two. It is useful to make the result document
explicit as this is a convenient way of invoking document-level
validation. (Validation of the implicit result document can also be
achieved by adding an <a href=
"#element-document"><code>xsl:document</code></a> instruction to
the initial template.)</p>
<p>If the result of the initial template is non-empty, and an
explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated with the empty attribute
<code>href=""</code>, then an error will occur <span class=
"error">[see <a href="#err-XTDE1490">ERR XTDE1490</a>]</span>,
since it is not possible to create two final result trees with the
same URI.</p>
</div>
</li>
<li>
<p><b>Serialization</b></p>
<p>See <a href="#parsing-and-serialization"><i>2.6 Parsing and
Serialization</i></a>.</p>
<p>Either the raw result, or a result tree produced as described
above, may optionally be serialized as decribed in <a href=
"#serialization">[serialization]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The first phase of serialization, called <b>sequence
normalization</b>, has no effect if the supplied value is a single
document node, which will be the case if serialization is preceded
by result tree construction. In the case of any other supplied
value, the effect of sequence normalization is very similar to the
effect of result tree construction, except where an
<code>item-separator</code> serialization parameter is present. Use
of <code>item-separator</code> allows, for example, a sequence of
strings returned by invoking a stylesheet function to be output
with newline separators.</p>
</div>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not constrain the design of application
programming interfaces or the choice of defaults. In previous
versions of this specification, result tree construction was a
mandatory process, while serialization was optional. When invoking
stylesheet functions directly, however, result tree construction
and serialization may be inappropriate as defaults. These
considerations may affect the design of APIs.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="executing-a-transformation" id=
"executing-a-transformation"></a>2.4 <a href=
"#executing-a-transformation" style=
"text-decoration: none">Executing a Transformation</a></h3>
<p>The classic method of executing an XSLT transformation is to
apply template rules to an input document, delivering the result as
a result tree which is then optionally serialized. This processing
model is described in this section. Other ways of invoking a
transformation or processing the result are outlined in the
previous section.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template-rule" id="dt-template-rule" title=
"template rule"></a>A stylesheet contains a set of <b>template
rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A
template rule has three parts: a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> that is matched against nodes, a
(possibly empty) set of <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameters</a>,
and a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is
evaluated to produce a sequence of items.<span class=
"definition">]</span> In many cases these items are newly
constructed nodes, which are then written to a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>.</p>
<p>A transformation as a whole is executed by evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of the
<a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a> as described in
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>.</p>
<p>The result sequence produced by evaluating the initial template
is handled as follows:</p>
<ol class="enumar">
<li>
<p>If the initial template has an <code>as</code> attribute, then
the result sequence of the initial template is checked against the
required type in the same way as for any other template.</p>
</li>
<li>
<p>If the result sequence is non-empty, then it is
<span>typically</span> used to construct an implicit <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, following the rules
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>: the effect is as if the
initial template <var>T</var> were called by an implicit template
of the form:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</pre></div>
</li>
</ol>
<p>The process of generating a result tree from the raw result of
the initial template <span class="verb">may</span> be replaced with
the very similar sequence normalization process described in
<a href="#serialization"><i>25 Serialization</i></a>. In the latter
case the serialization parameter <code>item-separator</code> may be
used to separate items in the raw result with a string other than
space (for example, newlines).</p>
<p>An implicit result tree is also created when the result sequence
is empty, provided that no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated during the course of the
transformation. In this situation the implicit result tree will
consist of a document node with no children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that there is always at least one result tree. It
also means that if the content of the initial template is a single
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, as in the example above, then only one result tree is
produced, not two. It is useful to make the result document
explicit as this is the only way of invoking document-level
validation.</p>
<p>If the result of the initial template is non-empty, and an
explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated with the empty attribute
<code>href=""</code>, then an error will occur <span class=
"error">[see <a href="#err-XTDE1490">ERR XTDE1490</a>]</span>,
since it is not possible to create two final result trees with the
same URI.</p>
</div>
<p>A <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is a sequence
of sibling nodes in the stylesheet, each of which is either an
<a title="XSLT instruction" class="termref" href=
"#dt-xslt-instruction">XSLT instruction</a>, a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, a text
node, or an <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-instruction" id="dt-instruction" title="instruction"></a>An
<b>instruction</b> is either an <a title="XSLT instruction" class=
"termref" href="#dt-xslt-instruction">XSLT instruction</a> or an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-instruction" id="dt-xslt-instruction" title=
"XSLT instruction"></a>An <b>XSLT instruction</b> is an <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a> whose syntax summary in this specification contains the
annotation <code>&lt;!-- category: instruction
--&gt;</code>.<span class="definition">]</span></p>
<p><a title="extension instruction" class="termref" href=
"#dt-extension-instruction">Extension instructions</a> are
described in <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a>.</p>
<p>The main categories of <a title="XSLT instruction" class=
"termref" href="#dt-xslt-instruction">XSLT instruction</a> are as
follows:</p>
<ul>
<li>
<p>instructions that create new nodes: <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
<a href="#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-value-of"><code>xsl:value-of</code></a>, <a href=
"#element-text"><code>xsl:text</code></a>, <a href=
"#element-namespace"><code>xsl:namespace</code></a>;</p>
</li>
<li>
<p>an instruction that returns an arbitrary sequence by evaluating
an XPath expression: <a href=
"#element-sequence"><code>xsl:sequence</code></a>;</p>
</li>
<li>
<p>instructions that cause conditional or repeated evaluation of
nested instructions: <a href="#element-if"><code>xsl:if</code></a>,
<a href="#element-choose"><code>xsl:choose</code></a>,
<span><a href="#element-try"><code>xsl:try</code></a>,</span>
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href="#element-fork"><code>xsl:fork</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a> and its subordinate
instructions <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> and
<a href="#element-break"><code>xsl:break</code></a></span>;</p>
</li>
<li>
<p>instructions that invoke templates: <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a>;</p>
</li>
<li>
<p>Instructions that declare variables: <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>;</p>
</li>
<li>
<p>other specialized instructions: <a href=
"#element-number"><code>xsl:number</code></a>, <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-assert"><code>xsl:assert</code></a>,</span>
<a href="#element-message"><code>xsl:message</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-stream"><code>xsl:stream</code></a>,
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-merge"><code>xsl:merge</code></a></span>.</p>
</li>
</ul>
<p>Often, a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> will include an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, which selects a sequence of nodes to be processed.
Each of the selected nodes is processed by searching the stylesheet
for a matching <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> and evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of that
template rule. The resulting sequences of items are concatenated,
in order, to give the result of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, as described in <a href="#applying-templates"><i>6.3
Applying Template Rules</i></a>; this sequence is often added to a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Since the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> of the
selected <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> may themselves contain
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions, this results in a cycle of selecting nodes,
identifying <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>, constructing sequences, and
constructing <a title="result tree" class="termref" href=
"#dt-result-tree">result trees</a>, that recurses through a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>.</p>
</div>
<div class="div2">
<h3><a name="context" id="context"></a>2.5 <a href="#context"
style="text-decoration: none">The Evaluation Context</a></h3>
<p>The results of some expressions and instructions in a stylesheet
may depend on information provided contextually. This context
information is divided into two categories: the static context,
which is known during static analysis of the stylesheet, and the
dynamic context, which is not known until the stylesheet is
evaluated. Although information in the static context is known at
analysis time, it is sometimes used during stylesheet
evaluation.</p>
<p>Some context information can be set by means of declarations
within the stylesheet itself. For example, the namespace bindings
used for any XPath expression are determined by the namespace
declarations present in containing elements in the stylesheet.
Other information may be supplied externally or implicitly: an
example is the current date and time.</p>
<p>The context information used in processing an XSLT stylesheet
includes as a subset all the context information required when
evaluating XPath expressions. The <span>XPath 3.0</span>
specification defines a static and dynamic context that the host
language (in this case, XSLT) may initialize, which affects the
results of XPath expressions used in that context. XSLT augments
the context with additional information: this additional
information is used firstly by XSLT constructs outside the scope of
XPath (for example, the <a href=
"#element-sort"><code>xsl:sort</code></a> element), and secondly,
by functions that are defined in the XSLT specification (such as
<a href="#func-key"><code>key</code></a> and <a href=
"#func-current-group"><code>current-group</code></a>) that are
available for use in XPath expressions appearing within a
stylesheet.</p>
<p>The static context for an expression or other construct in a
stylesheet is determined by the place in which it appears
lexically. The details vary for different components of the static
context, but in general, elements within a stylesheet module affect
the static context for their descendant elements within the same
stylesheet module.</p>
<p>The dynamic context is maintained as a stack. When an
instruction or expression is evaluated, it may add dynamic context
information to the stack; when evaluation is complete, the dynamic
context reverts to its previous state. An expression that accesses
information from the dynamic context always uses the value at the
top of the stack.</p>
<p>The most commonly used component of the dynamic context is the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a>. This is an implicit variable
whose value is the item currently being processed (it may be a
node, an atomic value, <span>or a function item</span>). The value
of the context item can be referenced within an XPath expression
using the expression <code>.</code> (dot).</p>
<p>Full details of the static and dynamic context are provided in
<a href="#static-and-dynamic-context"><i>5.4 The Static and Dynamic
Context</i></a>.</p>
</div>
<div class="div2">
<h3><a name="parsing-and-serialization" id=
"parsing-and-serialization"></a>2.6 <a href=
"#parsing-and-serialization" style="text-decoration: none">Parsing
and Serialization</a></h3>
<p>An XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> describes a process that constructs
a set of <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> from a set of
<a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a>.</p>
<p>The <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> does not describe how a <a title=
"source tree" class="termref" href="#dt-source-tree">source
tree</a> is constructed. Some possible ways of constructing source
trees are described in <a href="#xpath-datamodel-30">[Data
Model]</a>. Frequently an <a title="implementation" class="termref"
href="#dt-implementation">implementation</a> will operate in
conjunction with an XML parser (or more strictly, in the
terminology of <a href="#REC-xml">[XML 1.0]</a>, an <em>XML
processor</em>), to build a source tree from an input XML document.
An implementation <span class="verb">may</span> also provide an
application programming interface allowing the tree to be
constructed directly, or allowing it to be supplied in the form of
a DOM Document object (see <a href="#DOM-Level-2-Core">[DOM Level
2]</a>). This is outside the scope of this specification. Users
should be aware, however, that since the input to the
transformation is a tree conforming to the XDM data model as
described in <a href="#xpath-datamodel-30">[Data Model]</a>,
constructs that might exist in the original XML document, or in the
DOM, but which are not within the scope of the data model, cannot
be processed by the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> and cannot be guaranteed to remain
unchanged in the transformation output. Such constructs include
CDATA section boundaries, the use of entity references, and the
DOCTYPE declaration and internal DTD subset.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization" id="dt-serialization" title=
"serialization"></a>A frequent requirement is to output a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as an XML document
(or in other formats such as HTML). This process is referred to as
<b>serialization</b>.<span class="definition">]</span></p>
<p>Like parsing, serialization is not part of the transformation
process, and it is not <span class="verb">required</span> that an
XSLT processor <span class="verb">must</span> be able to perform
serialization. However, for pragmatic reasons, this specification
describes declarations (the <a href=
"#element-output"><code>xsl:output</code></a> element and the
<a href="#element-character-map"><code>xsl:character-map</code></a>
declarations, see <a href="#serialization"><i>25
Serialization</i></a>), and attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, that allow a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> to specify the desired
properties of a serialized output file. When serialization is not
being performed, either because the implementation does not support
the serialization option, or because the user is executing the
transformation in a way that does not invoke serialization, then
the content of the <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations has no effect. Under these circumstances the processor
<span class="verb">may</span> report any errors in an <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declaration, or in the serialization attributes of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
but is not <span class="verb">required</span> to do so.</p>
</div>
<div class="div2">
<h3><a name="packages-and-modules" id=
"packages-and-modules"></a>2.7 <a href="#packages-and-modules"
style="text-decoration: none">Packages and Modules</a></h3>
<p>In previous versions of the XSLT language, it has been possible
to structure a stylesheet as a collection of modules, using the
<a href="#element-include"><code>xsl:include</code></a> and
<a href="#element-import"><code>xsl:import</code></a> declarations
to express the dependency of on module on others.</p>
<p>In XSLT 3.0 an additional layer of modularization of stylesheet
code is enabled through the introduction of <a title="package"
class="termref" href="#dt-package">packages</a>. A package is a
collection of stylesheet modules with a controlled interface to the
packages that use it: for example, it defines which functions and
templates defined in the package are visible to callers, which are
purely internal, and which are not only public but capable of being
overridden by other functions and templates supplied by the using
package.</p>
<p>Packages are introduced with several motivations, which broadly
divide into two categories:</p>
<ol class="enumar">
<li>
<p>Software engineering benefits: greater re-use of code, greater
robustness through ease of testing, controlled evolution of code in
response to new requirements, ability to deliver code that users
cannot see or modify.</p>
</li>
<li>
<p>Efficiency benefits: the ability to avoid compiling libraries
repeatedly when they are used in multiple stylesheets, and to avoid
holding multiple copies of the same library in memory
simultaneously.</p>
</li>
</ol>
<p>Packages are designed to allow separate compilation: that is, a
package can be compiled independently of the packages that use it.
This specification does not define a process model for compilation,
or expand on what it means to compile different packages
independently. Nor does it mandate that implementations offer any
feature along these lines. It merely defines language features that
are designed to make separate compilation of packages possible.</p>
<p>To achieve this, packages (unlike modules):</p>
<ul>
<li>
<p>Must not contain unresolved references to functions, templates,
or variables declared in other packages;</p>
</li>
<li>
<p>Have strict rules governing the ability to override declarations
in a library package with declarations in a package that uses the
library;</p>
</li>
<li>
<p>Constrain the visibility of component names and of context
declarations such as the declarations of keys and decimal
formats;</p>
</li>
<li>
<p>Can declare a mode (a collection of template rules) as final,
which disallows the addition of new overriding template rules in a
using package;</p>
</li>
<li>
<p>Require explicit disambiguation where naming conflicts arise,
for example when a package uses two other packages that both export
like-named components;</p>
</li>
<li>
<p>Allow multiple specializations of library components to coexist
in the same application.</p>
</li>
</ul>
<p>A package is defined by means of an XML document whose outermost
element is an <a href=
"#element-package"><code>xsl:package</code></a> element. This is
referred to as the <b>package manifest</b>. The <a href=
"#element-package"><code>xsl:package</code></a> element has child
elements describing properties of the package, as well as an
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
<a href="#element-transform"><code>xsl:transform</code></a> child
element that defines the content of the package, either directly or
by reference through one or more <a href=
"#element-import"><code>xsl:import</code></a> or <a href=
"#element-include"><code>xsl:include</code></a> declarations.</p>
<p>When no packages are explicitly defined, the entire stylesheet
is treated as a single package; the effect is as if the <a title=
"principal stylesheet module" class="termref" href=
"#dt-principal-stylesheet-module">principal stylesheet module</a>
were wrapped in an <a href=
"#element-package"><code>xsl:package</code></a> element with no
other information in the package manifest.</p>
</div>
<div class="div2">
<h3><a name="extensibility" id="extensibility"></a>2.8 <a href=
"#extensibility" style=
"text-decoration: none">Extensibility</a></h3>
<p>XSLT defines a number of features that allow the language to be
extended by implementers, or, if implementers choose to provide the
capability, by users. These features have been designed, so far as
possible, so that they can be used without sacrificing
interoperability. Extensions other than those explicitly defined in
this specification are not permitted.</p>
<p>These features are all based on XML namespaces; namespaces are
used to ensure that the extensions provided by one implementer do
not clash with those of a different implementer.</p>
<p>The most common way of extending the language is by providing
additional functions, which can be invoked from XPath expressions.
These are known as <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and are
described in <a href="#extension-functions"><i>23.1 Extension
Functions</i></a>.</p>
<p>It is also permissible to extend the language by providing new
<a title="instruction" class="termref" href=
"#dt-instruction">instructions</a>. These are referred to as
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, and are
described in <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a>. A stylesheet that uses extension instructions
in a particular namespace must declare that it is doing so by using
the <code>[xsl:]extension-element-prefixes</code> attribute.</p>
<p>Extension instructions and extension functions defined according
to these rules <span class="verb">may</span> be provided by the
implementer of the XSLT processor, and the implementer <span class=
"verb">may</span> also provide facilities to allow users to create
further extension instructions and extension functions.</p>
<p>This specification defines how extension instructions and
extension functions are invoked, but the facilities for creating
new extension instructions and extension functions are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. For
further details, see <a href="#extension"><i>23 Extensibility and
Fallback</i></a>.</p>
<p>The XSLT language can also be extended by the use of <a title=
"extension attribute" class="termref" href=
"#dt-extension-attribute">extension attributes</a> (see <a href=
"#extension-attributes"><i>3.3 Extension Attributes</i></a>), and
by means of <a title="user-defined data element" class="termref"
href="#dt-data-element">user-defined data elements</a> (see
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>).</p>
</div>
<div class="div2">
<h3><a name="stylesheets-and-schemas" id=
"stylesheets-and-schemas"></a>2.9 <a href=
"#stylesheets-and-schemas" style=
"text-decoration: none">Stylesheets and XML Schemas</a></h3>
<p>An XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can make use of information from a
schema. An XSLT transformation can take place in the absence of a
schema (and, indeed, in the absence of a DTD), but where the source
document has undergone schema validity assessment, the XSLT
processor has access to the type information associated with
individual nodes, not merely to the untyped text.</p>
<p>Information from a schema can be used both statically (when the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> is compiled), and dynamically
(during evaluation of the stylesheet to transform a source
document).</p>
<p>There are places within a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, and within XPath <a title=
"expression" class="termref" href="#dt-expression">expressions</a>
and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, where it is
possible to refer to named type definitions in a schema, or to
element and attribute declarations. For example, it is possible to
declare the types expected for the parameters of a function. This
is done using the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>
syntax defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-component" id="dt-schema-component" title=
"schema component"></a>Type definitions and element and attribute
declarations are referred to collectively as <b>schema
components</b>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-in-scope-schema-component" id="dt-in-scope-schema-component"
title="in-scope schema component"></a>The <a title=
"schema component" class="termref" href=
"#dt-schema-component">schema components</a> that may be referenced
by name in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> are referred to as the <b>in-scope
schema components</b>. This set is the same throughout all the
modules of a stylesheet.<span class="definition">]</span></p>
<p>The conformance rules for XSLT <span>3.0</span>, defined in
<a href="#conformance"><i>26 Conformance</i></a>, distinguish
between a <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a> and a <a title=
"schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>.
As the names suggest, a basic XSLT processor does not support the
features of XSLT that require access to schema information, either
statically or dynamically. A <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> that works with a basic XSLT
processor will produce the same results with a schema-aware XSLT
processor provided that the source documents are untyped (that is,
they are not validated against a schema). However, if source
documents are validated against a schema then the results may be
different from the case where they are not validated. Some
constructs that work on untyped data may fail with typed data (for
example, an attribute of type <code>xs:date</code> cannot be used
as an argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-substring"><code>substring</code></a><sup><small>FO30</small></sup>
function) and other constructs may produce different results
depending on the datatype (for example, given the element
<code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the
expression <code>@price gt @discount</code> will return true if the
attributes have type <code>xs:decimal</code>, but will return false
if they are untyped).</p>
<p>There is a standard set of type definitions that are always
available as <a title="in-scope schema component" class="termref"
href="#dt-in-scope-schema-component">in-scope schema components</a>
in every stylesheet. These are defined in <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>.</p>
<p>The remainder of this section describes facilities that are
available only with a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a>.</p>
<p>Additional <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> (type definitions,
element declarations, and attribute declarations) may be added to
the <a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> by
means of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration in a stylesheet.</p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration may reference an external schema document by means of a
URI, or it may contain an inline <code>xs:schema</code>
element.</p>
<p>It is only necessary to import a schema explicitly if one or
more of its <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> are referenced
explicitly by name in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>; it is not necessary to import
a schema merely because the stylesheet is used to process a source
document that has been assessed against that schema. It is possible
to make use of the information resulting from schema assessment
(for example, the fact that a particular attribute holds a date)
even if no schema has been imported by the stylesheet.</p>
<p>Importing a schema does not of itself say anything about the
type of the source document that the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is expected to
process. The imported type definitions can be used for temporary
nodes or for nodes on a <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a> just as much as for nodes in
source documents. It is possible to make assertions about the type
of an input document by means of tests within the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
For example:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e2860" id=
"d7e2860"></a>Example: Asserting the Required Type of the Source
Document</div>
<div class="exampleInner">
<pre>
&lt;xsl:mode initial="yes" typed="lax"&gt;
  &lt;xsl:context-item use="required"
                    as="document-node(schema-element(my:invoice))"/&gt;
&lt;/xsl:mode&gt;
</pre></div>
<p>This example will cause the transformation to fail with an error
message when the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> is the unnamed mode, unless the
document element of the source document is valid against the
top-level element declaration <code>my:invoice</code>, and has been
annotated as such.</p>
<p>The setting <code>typed="lax"</code> further ensures that in any
match pattern for a template rule in this mode, an element name
that corresponds to the name of an element declaration in the
schema is taken as referring to elements validated against that
declaration: for example, <code>match="employee"</code> will only
match a validated <code>employee</code> element. Selecting this
option enables the XSLT processor to do more compile-time
type-checking against the schema, for example it allows the
processor to produce warning or error messages when path
expressions contain misspelt element names, or confuse an element
with an attribute.</p>
</div>
<p>It is also true that importing a schema does not of itself say
anything about the structure of the result tree. It is possible to
request validation of a result tree against the schema by using the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, for example:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e2888" id=
"d7e2888"></a>Example: Requesting Validation of the Result
Document</div>
<div class="exampleInner">
<pre>
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               
</pre></div>
<p>This example will cause the transformation to fail with an error
message unless the document element of the result document is valid
against the top-level element declaration
<code>xhtml:html</code>.</p>
</div>
<p>It is possible that a source document may contain nodes whose
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> is not one of the types
imported by the stylesheet. This creates a potential problem
because in the case of an expression such as <code>data(.) instance
of xs:integer</code> the system needs to know whether the type
named in the type annotation of the context node is derived by
restriction from the type <code>xs:integer</code>. This information
is not explicitly available in an XDM tree, as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>. The implementation may
choose one of several strategies for dealing with this
situation:</p>
<ol class="enumar">
<li>
<p>The processor may signal a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if a source
document is found to contain a <a title="type annotation" class=
"termref" href="#dt-annotation">type annotation</a> that is not
known to the processor.</p>
</li>
<li>
<p>The processor may maintain additional metadata, beyond that
described in <a href="#xpath-datamodel-30">[Data Model]</a>, that
allows the source document to be processed as if all the necessary
schema information had been imported using <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>. Such
metadata might be held in the data structure representing the
source document itself, or it might be held in a system catalog or
repository.</p>
</li>
<li>
<p>The processor may be configured to use a fixed set of schemas,
which are automatically used to validate all source documents
before they can be supplied as input to a transformation. In this
case it is impossible for a source document to have a <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> that the processor is not aware of.</p>
</li>
<li>
<p>The processor may be configured to treat the source document as
if no schema processing had been performed, that is, effectively to
strip all type annotations from elements and attributes on input,
marking them instead as having type <code>xs:untyped</code> and
<code>xs:untypedAtomic</code> respectively.</p>
</li>
</ol>
<p>Where a stylesheet author chooses to make assertions about the
types of nodes or of <a title="variable" class="termref" href=
"#dt-variable">variables</a> and <a title="parameter" class=
"termref" href="#dt-parameter">parameters</a>, it is possible for
an XSLT processor to perform static analysis of the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
(that is, analysis in the absence of any source document). Such
analysis <span class="verb">may</span> reveal errors that would
otherwise not be discovered until the transformation is actually
executed. An XSLT processor is not <span class=
"verb">required</span> to perform such static type-checking. Under
some circumstances (see <a href="#errors"><i>2.11 Error
Handling</i></a>) type errors that are detected early <span class=
"verb">may</span> be reported as static errors. In addition an
implementation <span class="verb">may</span> report any condition
found during static analysis as a warning, provided that this does
not prevent the stylesheet being evaluated as described by this
specification.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can also control the <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotations</a> of nodes that it constructs in a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, or in <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>. This can be done in a
number of ways.</p>
<ul>
<li>
<p>It is possible to request explicit validation of a complete
document, that is, a tree rooted at a document node. This applies
both to temporary trees constructed using the <a href=
"#element-document"><code>xsl:document</code></a> (or <a href=
"#element-copy"><code>xsl:copy</code></a>) instruction and also to
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> constructed using
<a href=
"#element-result-document"><code>xsl:result-document</code></a>.
Validation is either strict or lax, as described in <a href=
"#xmlschema-1">[XML Schema Part 1]</a>. If validation of a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> fails (strictly speaking, if the
outcome of the validity assessment is <code>invalid</code>), then
the transformation fails, but in all other cases, the element and
attribute nodes of the tree will be annotated with the names of the
types to which these nodes conform. These <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotations</a> will be discarded if the result tree is serialized
as an XML document, but they remain available when the result tree
is passed to an application (perhaps another <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>) for further
processing.</p>
</li>
<li>
<p>It is also possible to validate individual element and attribute
nodes as they are constructed. This is done using the
<code>type</code> and <code>validation</code> attributes of the
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, and <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instructions, or
the <code>xsl:type</code> and <code>xsl:validation</code>
attributes of a literal result element.</p>
</li>
<li>
<p>When elements, attributes, or document nodes are copied, either
explicitly using the <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instructions, or
implicitly when nodes in a sequence are attached to a new parent
node, the options <code>validation="strip"</code> and
<code>validation="preserve"</code> are available, to control
whether existing <a title="type annotation" class="termref" href=
"#dt-annotation">type annotations</a> are to be retained or
not.</p>
</li>
</ul>
<p>When nodes in a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> are validated, type
information is available for use by operations carried out on the
temporary tree, in the same way as for a source document that has
undergone schema assessment.</p>
<p>For details of how validation of element and attribute nodes
works, see <a href="#validation"><i>24.2 Validation</i></a>.</p>
</div>
<div class="div2">
<h3><a name="streaming-concepts" id="streaming-concepts"></a>2.10
<a href="#streaming-concepts" style=
"text-decoration: none">Streaming</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streaming" id="dt-streaming" title="streaming"></a>The term
<b>streaming</b> refers to a manner of processing in which
documents (such as source and result documents) are not represented
by a complete tree of nodes occupying memory proportional to
document size, but instead are processed "on the fly" as a sequence
of events, similar in concept to the stream of events notified by
an XML parser to represent markup in lexical XML.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamed-document" id="dt-streamed-document" title=
"streamed document"></a>A <b>streamed document</b> is a <a title=
"source tree" class="termref" href="#dt-source-tree">source
tree</a> that is processed using streaming, that is, without
constructing a complete tree of nodes in memory.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamed-document-node" id="dt-streamed-document-node" title=
"streamed node"></a>A <b>streamed node</b> is a node in a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.<span class=
"definition">]</span></p>
<p>Many processors implementing earlier versions of this
specification have adopted an architecture that allows streaming of
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> directly to a serializer, without
first materializing the complete result tree in memory. Streaming
of the <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>, however, has proved to be more
difficult without subsetting the language. This has created a
situation where documents exceeding the capacity of virtual memory
could not be transformed. XSLT 3.0 therefore introduces facilities
allowing stylesheets to be written in a way that makes streaming of
source documents possible, without excessive reliance on
processor-specific optimization techniques.</p>
<p>Streaming achieves two important objectives: it allows large
documents to be transformed without requiring correspondingly large
amounts of memory; and it allows the processor to start producing
output before it has finished receiving its input, thus reducing
latency.</p>
<p>This specification does not attempt to legislate precisely which
implementation techniques fall under the definition of streaming,
and which do not. A number of techniques are available that reduce
memory requirements, while still requiring a degree of buffering,
or allocation of memory to partial results. A stylesheet that
requests streaming of a source document is indicating that the
processor should avoid assuming that the entire source document
will fit in memory; in return, the stylesheet must be written in a
way that makes streaming possible. This specification does not
attempt to describe the algorithms that the processor should
actually use, or to impose quantitative constraints on the
resources that these algorithms should consume.</p>
<p>Nothing in this specification, nor in its predecessors <a href=
"#xslt">[XSLT 1.0]</a> and <a href="#xslt20">[XSLT 2.0]</a>,
prevents a processor using streaming whenever it sees an
opportunity to do so. However, experience has shown that in order
to achieve streaming, it is often necessary to write stylesheet
code in such a way as to make this possible. Therefore, XSLT 3.0
provides explicit constructs allowing the stylesheet author to
request streaming, and defines explicit static constraints on the
structure of the code which are designed to make streaming
possible.</p>
<p>A processor that claims conformance with the streaming option
offers a guarantee that when streaming is requested for a source
document, and when the stylesheet conforms to the rules that make
the processing <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a>, then an
algorithm will be adopted in which memory consumption is either
completely independent of document size, or increases only very
slowly as document size increases, allowing documents to be
processed that are orders-of-magnitude larger than the physical
memory available. A processor that does not claim conformance with
the streaming option must still process a stylesheet and deliver
the correct results, but is not required to use streaming
algorithms, and may therefore fail with out-of-memory errors when
presented with large source documents.</p>
<p>Apart from the fact that there are constructs to request
streaming, and rules that must be followed to guarantee that
streaming is possible, the language has been designed so there are
as few differences as possible between streaming and non-streaming
evaluation. The semantics of the language continue to be expressed
in terms of the XDM data model, which is substantively unchanged;
but readers must take care to observe that when terms like "node"
and "axis" are used, the concepts are completely abstract and may
have no direct representation in the run-time execution
environment.</p>
<p>Streamed processing of a document can be initiated in one of two
ways:</p>
<ul>
<li>
<p>The <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> can be declared as a <a title=
"streamable mode" class="termref" href=
"#dt-streamable-mode">streamable mode</a>. In this case the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> will
generally be a document node, and it will be supplied by the
calling application in a form that allows streaming (that is, in
some form other than a tree in memory; for example, as a reference
to a push or pull XML parser primed to deliver a stream of events).
<span>The type of the <a title="initial context item" class=
"termref" href="#dt-initial-context-item">initial context item</a>
can be constrained using the <a href=
"#element-context-item"><code>xsl:context-item</code></a>
element.</span></p>
</li>
<li>
<p>Streamed processing of any document can be initiated using the
<a href="#element-stream"><code>xsl:stream</code></a> instruction.
This has an attribute <code>href</code> whose value is the URI of a
document to be processed using streaming, and the actual processing
to be applied is defined by the instructions written as children of
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</li>
</ul>
<p>The rules for streamability, which are defined in detail in
<a href="#streamability"><i>19 Streamability</i></a>, impose two
main constraints:</p>
<ul>
<li>
<p>The only nodes reachable from the node that is currently being
processed are its attributes and namespaces, its ancestors and
their attributes and namespaces, and its descendants and their
attributes and namespaces. The siblings of the node, and the
siblings of its ancestors, are not reachable in the tree, and any
attempt to use their values is a <a title="static error" class=
"termref" href="#dt-static-error">static error</a>. However,
constructs (for example, simple forms of <a href=
"#element-number"><code>xsl:number</code></a>, and simple
positional <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>) that require knowledge of the number of
preceding elements by name are permitted.</p>
</li>
<li>
<p>When processing a given node in the tree, each descendant node
can only be visited once. Essentially this allows two styles of
processing: either visit each of the children once, and then
process that child with the same restrictions applied; or process
all the descendants in a single pass, in which case it is not
possible while processing a descendant to make any further downward
selection.</p>
</li>
</ul>
<p>The second restriction, that only one visit to the children is
allowed, means that XSLT code that was not designed with streaming
in mind will often need to be rewritten to make it streamable. In
many cases it is possible to do this using a technique sometimes
called <em>windowing</em> or <em>burst-mode streaming</em> (note
this is not quite the same meaning as <em>windowing</em> in XQuery
3.0). Many XML documents consist of a large number of elements,
each of manageable size, representing transactions or business
objects where each such element can be processed independently: in
such cases, an effective design pattern is to write a streaming
transformation that takes a snapshot of each element in turn,
processing the snapshot using the full power of the XSLT language.
Each snapshot is a tree built in memory and is therefore fully
navigable. For details see the <a href=
"#func-snapshot"><code>snapshot</code></a> and <a href=
"#func-copy-of"><code>copy-of</code></a> functions.</p>
<p>The new facility of <em>accumulators</em> allows applications
complete control over how much information is retained (and by
implication, how much memory is required) in the course of a pass
over a <a title="streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>. An accumulator
computes a value for every node in a streamed document: or more
accurately, two values, one for the first visit to a node (before
visiting its descendants), and a second value for the second visit
to the node (after visiting the descendants). The computation is
structured in such a way that the value for a given node can depend
only on the value for the previous node in document order together
with the data available when positioned at the current node (for
example, the attribute values). Based on the well-established fold
operation of functional programming languages, accumulators provide
the convenience and economy of mutable variables while remaining
within the constraints of a purely declarative processing
model.</p>
<p>Streaming applications often fall into one of the following
categories:</p>
<ul>
<li>
<p>Aggregation applications, where a single aggregation operation
(perhaps <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>
distinct-values</code></a><sup><small>FO30</small></sup>) is
applied to a set of elements selected from the streamed source
document by means of a path expression.</p>
</li>
<li>
<p>Record-at-a-time applications, where the source document
consists of a long sequence of elements with similar structure
("records"), and each "record" is processed using the same logic,
independently of any other "records". This kind of processing is
facilitated using the <a href=
"#func-snapshot"><code>snapshot</code></a> and <a href=
"#func-copy-of"><code>copy-of</code></a> function mentioned
earlier.</p>
</li>
<li>
<p>Grouping applications, where the output follows the structure of
the input, except that an extra layer of hierarchy is added. For
example, the input might be a flat series of banking transactions
in date/time order, and the output might contain the same
transactions grouped by date.</p>
</li>
<li>
<p>Accumulator applications, which are the same as record-at-a-time
applications, except that the processing of one "record" might
depend on data encountered earlier in the document. A classical
example is processing a sequence of banking transactions in which
the input transaction contains a debit or credit amount, and the
output adds a running total (the account balance). The <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction has
been introduced to facilitate this style of processing.</p>
</li>
<li>
<p>Isomorphic transformations, in which there is an ordered (often
largely one-to-one) relationship between the nodes of the source
tree and the nodes of the result tree: for example, transformations
that involve only the renaming or selective deletion of nodes, or
scalar manipulations of the values held in the leaf nodes. Such
transformations are most conveniently expressed using recursive
application of template rules. This is possible with a streamed
input document only if all the template rules adhere to the
constraints required for streamability. To enforce these rules,
while still allowing unrestricted processing of other documents
within the same transformation, all streaming evaluation must be
carried out using a specific <a title="mode" class="termref" href=
"#dt-mode">mode</a>, which is declared to be a streaming mode by
means of an <a href="#element-mode"><code>xsl:mode</code></a>
declaration in the stylesheet.</p>
</li>
</ul>
<p>There are important classes of application in which streaming is
possible only if multiple streams can be processed in parallel.
This specification therefore provides facilities:</p>
<ol class="enumar">
<li>
<p>allowing multiple sorted input sequences to be merged into one
sorted output sequence (the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction)</p>
</li>
<li>
<p>allowing multiple output sequences to be generated during a
single pass of an input sequence (the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction).</p>
</li>
</ol>
<p>These facilities have been designed in such a way that they can
readily be implemented using streaming, that is, without
materializing the input or output sequences in memory.</p>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.11 <a href="#errors" style=
"text-decoration: none">Error Handling</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-error" id="dt-static-error" title="static error"></a>An
error that can be detected by examining a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> before
execution starts (that is, before the source document and values of
stylesheet parameters are available) is referred to as a <b>static
error</b>.<span class="definition">]</span></p>
<p>Errors classified in this specification as static errors
<span class="verb">must</span> be signaled by all implementations:
that is, the <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
indicate that the error is present. A static error <span class=
"verb">must</span> be signaled even if it occurs in a part of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that is never evaluated. Static
errors are never recoverable. After signaling a static error, a
processor <span class="verb">may</span> continue for the purpose of
signaling additional errors, but it <span class="verb">must</span>
eventually terminate abnormally without producing any <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p>There is an exception to this rule when the stylesheet specifies
<a title="forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible behavior</a>
(see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>).</p>
<p>Generally, errors in the structure of the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>, or in the
syntax of XPath <a title="expression" class="termref" href=
"#dt-expression">expressions</a> contained in the stylesheet, are
classified as <a title="static error" class="termref" href=
"#dt-static-error">static errors</a>. Where this specification
states that an element in the stylesheet <span class=
"verb">must</span> or <span class="verb">must not</span> appear in
a certain position, or that it <span class="verb">must</span> or
<span class="verb">must not</span> have a particular attribute, or
that an attribute <span class="verb">must</span> or <span class=
"verb">must not</span> have a value satisfying specified
conditions, then any contravention of this rule is a static error
unless otherwise specified.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error"></a>An error that is not detected until a source
document is being transformed is referred to as a <b>dynamic
error</b>.<span class="definition">]</span></p>
<p>When a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs, and is not caught
using <a href="#element-catch"><code>xsl:catch</code></a>, the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span> signal
the error, and the transformation fails.</p>
<p>Because different implementations may optimize execution of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> in different ways, the detection of
dynamic errors is to some degree <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. In
cases where an implementation is able to produce the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> without evaluating a
particular construct, the implementation is never <span class=
"verb">required</span> to evaluate that construct solely in order
to determine whether doing so causes a dynamic error. For example,
if a <a title="variable" class="termref" href=
"#dt-variable">variable</a> is declared but never referenced, an
implementation <span class="verb">may</span> choose whether or not
to evaluate the variable declaration, which means that if
evaluating the variable declaration causes a dynamic error, some
implementations will signal this error and others will not.</p>
<p>There are some cases where this specification requires that a
construct <span class="verb">must not</span> be evaluated: for
example, the content of an <a href=
"#element-if"><code>xsl:if</code></a> instruction <span class=
"verb">must not</span> be evaluated if the test condition is false.
This means that an implementation <span class="verb">must
not</span> signal any dynamic errors that would arise if the
construct were evaluated.</p>
<p>An implementation <span class="verb">may</span> signal a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> before any source document is
available, but only if it can determine that the error would be
signaled for every possible source document and every possible set
of parameter values. For example, some <a title="" class="termref"
href="#circularity">circularity</a> errors fall into this category:
see <a href="#circularity"><i>9.11 Circular
Definitions</i></a>.</p>
<p>There are also some <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic errors</a> where the specification
gives a processor license to signal the error during the analysis
phase even if the construct might never be executed; an example is
the use of an invalid QName as a literal argument to a function
such as <a href="#func-key"><code>key</code></a>, or the use of an
invalid regular expression in the <code>regex</code> attribute of
the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction.</p>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> may also be signaled during
the static analysis phase if the error occurs during evaluation of
a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a>.</p>
<p>The XPath specification states (see <a href=
"http://www.w3.org/TR/xpath-30/#id-kinds-of-errors">Section 2.3.1
Kinds of Errors</a> <sup><small>XP30</small></sup>) that if any
expression (at any level) can be evaluated during the analysis
phase (because all its explicit operands are known and it has no
dependencies on the dynamic context), then any error in performing
this evaluation <span class="verb">may</span> be reported as a
static error. For XPath expressions used in an XSLT stylesheet,
however, any such errors <span class="verb">must not</span> be
reported as static errors in the stylesheet unless they would occur
in every possible evaluation of that stylesheet; instead, they must
be signaled as dynamic errors, and signaled only if the XPath
expression is actually evaluated.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3524" id=
"d7e3524"></a>Example: Errors in Constant Subexpressions</div>
<p>An XPath processor may report statically that the expression
<code>1 div 0</code> fails with a "divide by zero" error. But
suppose this XPath expression occurs in an XSLT construct such
as:</p>
<div class="exampleInner">
<pre>
&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</pre></div>
<p>Then the XSLT processor must not report an error, because the
relevant XPath construct appears in a context where it will never
be executed by an XSLT 2.0 <span>or 3.0</span> processor. (An XSLT
1.0 processor will execute this code successfully, returning
positive infinity, because it uses double arithmetic rather than
decimal arithmetic.)</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-type-error" id="dt-type-error" title="type error"></a>Certain
errors are classified as <b>type errors</b>. A type error occurs
when the value supplied as input to an operation is of the wrong
type for that operation, for example when an integer is supplied to
an operation that expects a node.<span class="definition">]</span>
If a type error occurs in an instruction that is actually
evaluated, then it <span class="verb">must</span> be signaled in
the same way as a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>. Alternatively, an
implementation <span class="verb">may</span> signal a type error
during the analysis phase in the same way as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>, even if it occurs in part of the stylesheet that is
never evaluated, provided it can establish that execution of a
particular construct would never succeed.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
type errors are signaled statically.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3570" id=
"d7e3570"></a>Example: A Type Error</div>
<p>The following construct contains a type error, because
<code>42</code> is not allowed as the value of the
<code>select</code> expression of the <a href=
"#element-number"><code>xsl:number</code></a> instruction (it must
be a node). An implementation <span class="verb">may</span>
optionally signal this as a static error, even though the offending
instruction will never be evaluated, and the type error would
therefore never be signaled as a dynamic error.</p>
<div class="exampleInner">
<pre>
&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;
</pre></div>
<p>On the other hand, in the following example it is not possible
to determine statically whether the operand of <span><a href=
"#element-number"><code>xsl:number</code></a></span> will have a
suitable dynamic type. An implementation <span class=
"verb">may</span> produce a warning in such cases, but it
<span class="verb">must not</span> treat it as an error.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>If more than one error arises, an implementation is not
<span class="verb">required</span> to signal any errors other than
the first one that it detects. It is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> which
of the several errors is signaled. This applies both to static
errors and to dynamic errors. An implementation is allowed to
signal more than one error, but if any errors have been signaled,
it <span class="verb">must not</span> finish as if the
transformation were successful.</p>
<p>When a transformation signals one or more dynamic errors, the
final state of any persistent resources updated by the
transformation is <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.
Implementations are not <span class="verb">required</span> to
restore such resources to their initial state. In particular, where
a transformation produces multiple result documents, it is possible
that one or more serialized result documents <span class=
"verb">may</span> be written successfully before the transformation
terminates, but the application cannot rely on this behavior.</p>
<p>Everything said above about error handling applies equally to
errors in evaluating XSLT instructions, and errors in evaluating
XPath <a title="expression" class="termref" href=
"#dt-expression">expressions</a>. Static errors and dynamic errors
may occur in both cases.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization-error" id="dt-serialization-error" title=
"serialization error"></a>If a transformation has successfully
produced a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, it is still possible
that errors may occur in serializing the result tree. For example,
it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a
<b>serialization error</b>.<span class="definition">]</span> If the
processor performs serialization, then it <span class=
"verb">must</span> do so as specified in <a href=
"#serialization"><i>25 Serialization</i></a>, and in particular it
<span class="verb">must</span> signal any serialization errors that
occur.</p>
<p>Errors are identified by a QName. For errors defined in this
specification, the namespace of the QName is always
<code>http://www.w3.org/2005/xqt-errors</code> (and is therefore
not given explicitly), while the local part is an 8-character code
in the form <var>PPSSNNNN</var>. Here <var>PP</var> is always
<code>XT</code> (meaning XSLT), and <var>SS</var> is one of
<code>SE</code> (static error), <code>DE</code> (dynamic error),
<code>RE</code> (recoverable dynamic error), or <code>TE</code>
(type error). Note that the allocation of an error to one of these
categories is purely for convenience and carries no normative
implications about the way the error is handled. Many errors, for
example, can be reported either dynamically or statically. These
error codes are used to label error conditions in this
specification, and are summarized in <a href="#error-summary"><i>E
Summary of Error Conditions</i></a>.</p>
<p>Errors defined in related specifications (<a href=
"#xpath-30">[XPath 3.0]</a>, <a href=
"#xpath-functions-30">[Functions and Operators]</a> <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>) use QNames with a similar structure, in the
same namespace. When errors occur in processing XPath expressions,
an XSLT processor <span class="verb">should</span> use the original
error code reported by the XPath processor, unless a more specific
XSLT error code is available.</p>
<p><span>Implementations <span class="verb">must</span> use the
codes defined in these specifications when signaling errors, to
ensure that <a href="#element-catch"><code>xsl:catch</code></a>
behaves in an interoperable way across implementations. Stylesheet
authors should note, however, that there are many examples of
errors where more than one rule in this specification is violated,
and where the processor therefore has discretion in deciding which
error code to associate with the condition: there is therefore no
guarantee that different processors will always use the same error
code for the same erroneous input.</span></p>
<p>Additional errors defined by an implementation (or by an
application) <span class="verb">may</span> use QNames in an
implementation-defined (or user-defined) namespace without risk of
collision.</p>
</div>
</div>
<div class="div1">
<h2><a name="stylesheet-structure" id="stylesheet-structure"></a>3
<a href="#stylesheet-structure" style=
"text-decoration: none">Stylesheet Structure</a></h2>
<p>This section describes the overall structure of a stylesheet as
a collection of XML documents.</p>
<div class="div2">
<h3><a name="xslt-namespace" id="xslt-namespace"></a>3.1 <a href=
"#xslt-namespace" style="text-decoration: none">XSLT
Namespace</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-namespace" id="dt-xslt-namespace" title=
"XSLT namespace"></a>The <b>XSLT namespace</b> has the URI
<code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
identify elements, attributes, and other names that have a special
meaning defined in this specification.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>1999</code> in the URI indicates the year in which the
URI was allocated by the W3C. It does not indicate the version of
XSLT being used, which is specified by attributes (see <a href=
"#stylesheet-element"><i>3.8 Stylesheet Element</i></a> and
<a href="#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>).</p>
</div>
<p>XSLT <a title="processor" class="termref" href=
"#dt-processor">processors</a> <span class="verb">must</span> use
the XML namespaces mechanism <a href="#xml-names">[Namespaces in
XML]</a> to recognize elements and attributes from this namespace.
Elements from the XSLT namespace are recognized only in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> and not in the source document. The
complete list of XSLT-defined elements is specified in <a href=
"#element-syntax-summary"><i>D Element Syntax Summary</i></a>.
<a title="implementation" class="termref" href=
"#dt-implementation">Implementations</a> <span class="verb">must
not</span> extend the XSLT namespace with additional elements or
attributes. Instead, any extension <span class="verb">must</span>
be in a separate namespace. Any namespace that is used for
additional instruction elements <span class="verb">must</span> be
identified by means of the <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instruction</a> mechanism specified in <a href=
"#extension-instruction"><i>23.2 Extension
Instructions</i></a>.</p>
<p>This specification uses a prefix of <code>xsl:</code> for
referring to elements in the XSLT namespace. However, XSLT
stylesheets are free to use any prefix, provided that there is a
namespace declaration that binds the prefix to the URI of the XSLT
namespace.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Throughout this specification, an element or attribute that is
in no namespace, or an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> whose namespace part
is an empty sequence, is referred to as having a <b>null namespace
URI</b>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The conventions used for the names of <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT elements</a>,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they
already appear in the syntax of a related language such as XML or
HTML. Names of types defined in XML Schema are regarded as single
words and are capitalized exactly as in XML Schema. This sometimes
leads to composite function names such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup>.</p>
</div>
</div>
<div class="div2">
<h3><a name="reserved-namespaces" id="reserved-namespaces"></a>3.2
<a href="#reserved-namespaces" style=
"text-decoration: none">Reserved Namespaces</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-reserved-namespace" id="dt-reserved-namespace" title=
"reserved namespace"></a>The XSLT namespace, together with certain
other namespaces recognized by an XSLT processor, are classified as
<b>reserved namespaces</b> and <span class="verb">must</span> be
used only as specified in this and related
specifications.<span class="definition">]</span> The reserved
namespaces are those listed below.</p>
<ul>
<li>
<p>The <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>, described in <a href=
"#xslt-namespace"><i>3.1 XSLT Namespace</i></a>, is reserved.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-function-namespace" id=
"dt-standard-function-namespace" title=
"standard function namespace"></a>The <b>standard function
namespace</b> <code>http://www.w3.org/2005/xpath-functions</code>
is used for functions in the function library defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a> and for
standard functions defined in this specification.<span class=
"definition">]</span></p>
</li>
<li>
<p>The namespace
<code>http://www.w3.org/2005/xpath-functions/math</code> is used
for mathematical functions in the function library defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>.</p>
</li>
<li>
<p>The namespace
<code>http://www.w3.org/2005/xpath-functions/map</code> is used for
functions defined in this specification relating to the
manipulation of <a title="map" class="termref" href=
"#dt-map">maps</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"xml-namespace" id="xml-namespace" title="XML namespace"></a>The
<b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces
in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>,
is used for attributes such as <code>xml:lang</code>,
<code>xml:space</code>, and <code>xml:id</code>.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-namespace" id="dt-schema-namespace" title=
"schema namespace"></a>The <b>schema namespace</b>
<code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
<a href="#xmlschema-1">[XML Schema Part 1]</a><span class=
"definition">]</span>. In a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> this namespace may be used to
refer to built-in schema datatypes and to the constructor functions
associated with those datatypes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-instance-namespace" id="dt-schema-instance-namespace"
title="schema instance namespace"></a>The <b>schema instance
namespace</b>
<code>http://www.w3.org/2001/XMLSchema-instance</code> is used as
defined in <a href="#xmlschema-1">[XML Schema Part
1]</a><span class="definition">]</span>. Attributes in this
namespace, if they appear in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, are treated by the
XSLT processor in the same way as any other attributes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-error-namespace" id="dt-standard-error-namespace"
title="standard error namespace"></a>The <b>standard error
namespace</b> <code>http://www.w3.org/2005/xqt-errors</code> is
used for error codes defined in this specification and related
specifications. It is also used for the names of certain predefined
variables accessible within the scope of an <a href=
"#element-catch"><code>xsl:catch</code></a> element.<span class=
"definition">]</span></p>
</li>
<li>
<p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is
reserved for use as described in <a href="#xml-names">[Namespaces
in XML]</a>. No element or attribute node can have a name in this
namespace, and although the prefix <code>xmlns</code> is implicitly
bound to this namespace, no namespace node will ever define this
binding.</p>
</li>
</ul>
<p>Reserved namespaces may be used without restriction to refer to
the names of elements and attributes in source documents and result
documents. As far as the XSLT processor is concerned, reserved
namespaces other than the XSLT namespace may be used without
restriction in the names of <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
elements</a> and <a title="user-defined data element" class=
"termref" href="#dt-data-element">user-defined data elements</a>,
and in the names of attributes of literal result elements or of
<a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>: but other processors
<span class="verb">may</span> impose restrictions or attach special
meaning to them. Reserved namespaces <span class="verb">must
not</span> be used, however, in the names of stylesheet-defined
objects such as <a title="variable" class="termref" href=
"#dt-variable">variables</a> and <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>With the exception of the XML namespace, any of the above
namespaces that are used in a stylesheet must be explicitly
declared with a namespace declaration. Although conventional
prefixes are used for these namespaces in this specification, any
prefix may be used in a user stylesheet.</p>
</div>
<p><a name="err-XTSE0080" id="err-XTSE0080"><span class=
"error">[ERR XTSE0080]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> to use a
<a title="reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a> in the name of a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a named
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, or a <a title=
"character map" class="termref" href="#dt-character-map">character
map</a>.</p>
</div>
<div class="div2">
<h3><a name="extension-attributes" id=
"extension-attributes"></a>3.3 <a href="#extension-attributes"
style="text-decoration: none">Extension Attributes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-attribute" id="dt-extension-attribute" title=
"extension attribute"></a>An element from the XSLT namespace may
have any attribute not from the XSLT namespace, provided that the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> (see <a href=
"#xpath-30">[XPath 3.0]</a>) of the attribute has a non-null
namespace URI. These attributes are referred to as <b>extension
attributes</b>.<span class="definition">]</span> The presence of an
extension attribute <span class="verb">must not</span> cause the
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> produced by the
transformation to be different from the result trees that a
conformant XSLT <span>3.0</span> processor might produce. They
<span class="verb">must not</span> cause the processor to fail to
signal an error that a conformant processor is required to signal.
This means that an extension attribute <span class="verb">must
not</span> change the effect of any <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> except to the
extent that the effect is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>Furthermore, if serialization is performed using one of the
serialization methods <code>xml</code>, <code>xhtml</code>,
<code>html</code>, or <code>text</code> described in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>, the presence of an extension attribute must not
cause the serializer to behave in a way that is inconsistent with
the mandatory provisions of that specification.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="extension attribute" class="termref" href=
"#dt-extension-attribute">Extension attributes</a> may be used to
modify the behavior of <a title="extension function" class=
"termref" href="#dt-extension-function">extension functions</a> and
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>. They may be
used to select processing options in cases where the specification
leaves the behavior <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. They
may also be used for optimization hints, for diagnostics, or for
documentation.</p>
<p><a title="extension attribute" class="termref" href=
"#dt-extension-attribute">Extension attributes</a> may also be used
to influence the behavior of the serialization methods
<code>xml</code>, <code>xhtml</code>, <code>html</code>, or
<code>text</code>, to the extent that the behavior of the
serialization method is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. For
example, an extension attribute might be used to define the amount
of indentation to be used when <code>indent="yes"</code> is
specified. If a serialization method other than one of these four
is requested (using a prefixed QName in the method parameter) then
extension attributes may influence its behavior in arbitrary ways.
Extension attributes must not be used to cause the four standard
serialization methods to behave in a non-conformant way, for
example by failing to report serialization errors that a serializer
is required to report. An implementation that wishes to provide
such options must create a new serialization method for the
purpose.</p>
<p>An implementation that does not recognize the name of an
extension attribute, or that does not recognize its value, must
perform the transformation as if the extension attribute were not
present. As always, it is permissible to produce warning
messages.</p>
<p>The namespace used for an extension attribute will be copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> in the normal way if it is in
scope for a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>. This can
be prevented using the <code>[xsl:]exclude-result-prefixes</code>
attribute.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e4119" id=
"d7e4119"></a>Example: An Extension Attribute for
<code>xsl:message</code></div>
<p>The following code might be used to indicate to a particular
implementation that the <a href=
"#element-message"><code>xsl:message</code></a> instruction is to
ask the user for confirmation before continuing with the
transformation:</p>
<div class="exampleInner">
<pre>
&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</pre></div>
<p>Implementations that do not recognize the namespace
<code>http://vendor.example.com/xslt/extensions</code> will simply
ignore the extra attribute, and evaluate the <a href=
"#element-message"><code>xsl:message</code></a> instruction in the
normal way.</p>
</div>
<p><a name="err-XTSE0090" id="err-XTSE0090"><span class=
"error">[ERR XTSE0090]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for an
element from the XSLT namespace to have an attribute whose
namespace is either null (that is, an attribute with an unprefixed
name) or the XSLT namespace, other than attributes defined for the
element in this document.</p>
</div>
<div class="div2">
<h3><a name="xslt-media-type" id="xslt-media-type"></a>3.4 <a href=
"#xslt-media-type" style="text-decoration: none">XSLT Media
Type</a></h3>
<p>The media type <code>application/xslt+xml</code> <span>has
been</span> registered for XSLT stylesheet modules.</p>
<p>The definition of the media type is at <a href=
"#XSLT-Mime-Type">[XSLT Media Type]</a>.</p>
<p>This media type <span class="verb">should</span> be used for an
XML document containing a <a title="standard stylesheet module"
class="termref" href="#dt-standard-stylesheet-module">standard
stylesheet module</a> at its top level, and it <span class=
"verb">may</span> also be used for a <a title=
"simplified stylesheet module" class="termref" href=
"#dt-simplified-stylesheet-module">simplified stylesheet
module</a>. It <span class="verb">should not</span> be used for an
XML document containing an <a title="embedded stylesheet module"
class="termref" href="#dt-embedded-stylesheet-module">embedded
stylesheet module</a>.</p>
</div>
<div class="div2">
<h3><a name="standard-attributes" id="standard-attributes"></a>3.5
<a href="#standard-attributes" style=
"text-decoration: none">Standard Attributes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-attributes" id="dt-standard-attributes" title=
"standard attributes"></a>There are a number of <b>standard
attributes</b> that may appear on any <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT element</a>:
specifically <code>default-collation</code>,
<code>default-mode</code>, <code>default-validation</code>,
<code>exclude-result-prefixes</code>,
<span><code>expand-text</code>,</span>
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and
<code>xpath-default-namespace</code>.<span class=
"definition">]</span></p>
<p>These attributes may also appear on a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, but in
this case, to distinguish them from user-defined attributes, the
names of the attributes are in the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a>. They are
thus typically written as <code>xsl:default-collation</code>,
<code>xsl:default-mode</code>, <code>xsl:default-validation</code>,
<code>xsl:exclude-result-prefixes</code>,
<span><code>xsl:expand-text</code>,</span>
<code>xsl:extension-element-prefixes</code>,
<code>xsl:use-when</code>, <code>xsl:version</code>, or
<code>xsl:xpath-default-namespace</code>.</p>
<p>It is <span class="verb">recommended</span> that all these
attributes should also be permitted on <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, but this is
at the discretion of the implementer of each extension instruction.
They <span class="verb">may</span> also be permitted on <a title=
"user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a>, though they will
only have any useful effect in the case of data elements that are
designed to behave like XSLT declarations or instructions.</p>
<p>In the following descriptions, these attributes are referred to
generically as <code>[xsl:]version</code>, and so on.</p>
<p>These attributes all affect the element they appear on, together
with any elements and attributes that have that element as an
ancestor. The two forms with and without the XSLT namespace have
the same effect; the XSLT namespace is used for the attribute if
and only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>In the case of <code>[xsl:]default-collation</code>,
<span><code>[xsl:]expand-text</code>,</span>
<code>[xsl:]version</code>, and
<code>[xsl:]xpath-default-namespace</code>, the value can be
overridden by a different value for the same attribute appearing on
a descendant element. The effective value of the attribute for a
particular stylesheet element is determined by the innermost
ancestor-or-self element on which the attribute appears.</p>
<p>In an <a title="embedded stylesheet module" class="termref"
href="#dt-embedded-stylesheet-module">embedded stylesheet
module</a>, <a title="standard attributes" class="termref" href=
"#dt-standard-attributes">standard attributes</a> appearing on
ancestors of the outermost element of the stylesheet module have no
effect.</p>
<p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
<code>[xsl:]extension-element-prefixes</code> the values are
cumulative. For these attributes, the value is given as a
whitespace-separated list of namespace prefixes, and the effective
value for an element is the combined set of namespace URIs
designated by the prefixes that appear in this attribute for that
element and any of its ancestor elements. Again, the two forms with
and without the XSLT namespace are equivalent.</p>
<p>The effect of the <code>[xsl:]use-when</code> attribute is
described in <a href="#conditional-inclusion"><i>3.14 Conditional
Element Inclusion</i></a>.</p>
<p>Because these attributes may appear on any <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a>, they are not listed in the syntax summary of each
individual element. Instead they are listed and described in the
entry for the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href=
"#element-transform"><code>xsl:transform</code></a>, <span>and
<a href="#element-package"><code>xsl:package</code></a></span>
elements only. This reflects the fact that these attributes are
often used on the <span>outermost element of the stylesheet</span>,
in which case they apply to the entire <a title="stylesheet module"
class="termref" href="#dt-stylesheet-module">stylesheet module</a>
<span>or <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span>.</p>
<p>Note that the effect of these attributes does <em>not</em>
extend to <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> referenced by
<a href="#element-include"><code>xsl:include</code></a> or <a href=
"#element-import"><code>xsl:import</code></a> declarations,
<span>nor to packages referenced using <a href=
"#element-use-package"><code>xsl:use-package</code></a></span>.</p>
<p>For the detailed effect of each attribute, see the following
sections:</p>
<dl>
<dt class="label"><code>[xsl:]default-collation</code></dt>
<dd>
<p>see <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a></p>
</dd>
<dt class="label"><code>[xsl:]default-mode</code></dt>
<dd>
<p>see <a href="#default-mode"><i>3.8.2 The [xsl:]default-mode
Attribute</i></a></p>
</dd>
<dt class="label"><code>[xsl:]default-validaion</code></dt>
<dd>
<p>see <a href="#validation"><i>24.2 Validation</i></a></p>
</dd>
<dt class="label"><code>[xsl:]exclude-result-prefixes</code></dt>
<dd>
<p>see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for
Literal Result Elements</i></a></p>
</dd>
<dt class="label"><code>[xsl:]expand-text</code></dt>
<dd>
<p>see <a href="#text-value-templates"><i>5.7.2 Text Value
Templates</i></a></p>
</dd>
<dt class="label">
<code>[xsl:]extension-element-prefixes</code></dt>
<dd>
<p>see <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a></p>
</dd>
<dt class="label"><code>[xsl:]use-when</code></dt>
<dd>
<p>see <a href="#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a></p>
</dd>
<dt class="label"><code>[xsl:]version</code></dt>
<dd>
<p>see <a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a> and <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a></p>
</dd>
<dt class="label"><code>[xsl:]xpath-default-namespace</code></dt>
<dd>
<p>see <a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical
QNames in Expressions and Patterns</i></a></p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="packages" id="packages"></a>3.6 <a href="#packages"
style="text-decoration: none">Packages</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-package" id="dt-package" title="package"></a>A <b>package</b>
is represented by an <a href=
"#element-package"><code>xsl:package</code></a> element, which will
generally be the outermost element of an XML document.<span class=
"definition">]</span> (This specification does not preclude the
<a href="#element-package"><code>xsl:package</code></a> being
embedded in another XML document, but it will never have any other
XSLT element as an ancestor).</p>
<p class="element-syntax"><a name="element-package" id=
"element-package"></a><code>&lt;xsl:package<br />
&#160;&#160;name? = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*, (<a href=
"#element-stylesheet">xsl:stylesheet</a> | <a href=
"#element-transform">xsl:transform</a>), <a href=
"#element-expose">xsl:expose</a>*) --&gt;<br />
&lt;/xsl:package&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-package-manifest" id="dt-package-manifest" title=
"package manifest"></a>The content of the <a href=
"#element-package"><code>xsl:package</code></a> element is referred
to as the <b>package manifest</b><span class=
"definition">]</span>.</p>
<p>The <span><code>version</code></span> attribute indicates the
version of the XSLT language specification to which the package
manifest conforms. The value <span class="verb">should</span> be
<code>3.0</code>.</p>
<p>A package typically has a name, given in its <code>name</code>
attribute, which <span class="verb">must</span> be an absolute URI.
Unnamed packages are allowed, but they can only be used as the "top
level" of an application; they cannot be the target of a <a href=
"#element-use-package"><code>xsl:use-package</code></a> declaration
in another package.</p>
<p><span>A package may have</span> a version identifier, given in
its <code>package-version</code> attribute. This is used to
distinguish different packages that have the same package name,
perhaps successive versions of a package, or perhaps variants of a
package for use in different environments. The version identifier
can be any string.</p>
<p>The attributes <code>default-collation</code>,
<code>default-mode</code>, <code>default-validation</code>,
<code>exclude-result-prefixes</code>, <code>expand-text</code>,
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and <code>xpath-default-namespace</code> are
standard attributes that can appear on any XSLT element, and
potentially affect all descendant elements. Their meaning is
described in <a href="#standard-attributes"><i>3.5 Standard
Attributes</i></a>.</p>
<p>The package manifest is in three parts:</p>
<ol class="enumar">
<li>
<p>It starts with zero-or-more <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements
which identify the packages used by this package, including
subsidiary elements that constrain the way in which the components
contained in those packages are used.</p>
</li>
<li>
<p>This is followed by an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element (the
two names are synonyms) which is an embedded <a title=
"standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard stylesheet module</a>.
This can contain references to other stylesheet modules using
<a href="#element-include"><code>xsl:include</code></a> and/or
<a href="#element-import"><code>xsl:import</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declarations</a>, and it can contain other
declarations such as <a href=
"#element-function"><code>xsl:function</code></a> and <a href=
"#element-template"><code>xsl:template</code></a>.</p>
<p>The modules making up a package are this module, plus all
modules that are transitively reachable from it using <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations. It is
permissible for the same module to appear in more than one package,
or indeed more than once in the same package; this situation is no
different from having two modules with identical content but
different URIs.</p>
</li>
<li>
<p>Finally, the manifest contains zero or more <a href=
"#element-expose"><code>xsl:expose</code></a> declarations that
define the interface offered by this package to the outside
world.</p>
</li>
</ol>
<p>A package that does not itself expose any components (in effect,
a stylesheet that makes use of library packages but is not itself
intended to act as a library package) may be written using a
simplified syntax: the <a href=
"#element-package"><code>xsl:package</code></a> element is omitted,
and the <a href=
"#element-use-package"><code>xsl:use-package</code></a> children
are moved to the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element, which
is now the outermost element of the stylesheet module. More
formally, an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element having
one or more <a href=
"#element-use-package"><code>xsl:use-package</code></a> children is
equivalent to the package represented by the output of the
following transformation, preserving the base URI of the
source:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    &lt;xsl:mode on-no-match="shallow-copy"/&gt;
    &lt;xsl:template match="(xsl:stylesheet|xsl:transform)[xsl:use-package]"&gt;
      &lt;t:package version="{@version}"&gt;
        &lt;xsl:copy-of select="xsl:use-package"/&gt;
        &lt;xsl:copy&gt;
          &lt;xsl:copy-of select="@*"/&gt;
          &lt;xsl:copy-of select="* except xsl:use-package"/&gt;
        &lt;/xsl:copy&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;   
       
</pre></div>
<p>The effect of the <code>input-type-annotations</code> attribute
is defined in <a href="#stripping-annotations"><i>4.3 Stripping
Type Annotations from a Source Tree</i></a>.</p>
<div class="div3">
<h4><a name="package-dependencies" id=
"package-dependencies"></a>3.6.1 <a href="#package-dependencies"
style="text-decoration: none">Dependencies between
Packages</a></h4>
<p>When components in one package reference components in another,
the dependency of the first package on the second must be
represented by an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element in
the <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> of the first
package.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-use" id="dt-use" title="use"></a>If a package <var>Q</var>
contains an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
that references package <var>P</var>, then package <var>Q</var> is
said to <b>use</b> package <var>P</var>. In this relationship
package <var>Q</var> is referred to as the <b>using</b> package,
package <var>P</var> as the <b>used</b> package.<span class=
"definition">]</span></p>
<p>The phrase <b>directly uses</b> is synonymous with <b>uses</b>
as defined above, while <b>directly or indirectly uses</b> refers
to the transitive closure of this relationship.</p>
<p class="element-syntax"><a name="element-use-package" id=
"element-use-package"></a><code>&lt;xsl:use-package<br />
&#160;&#160;<b>name</b> = <var>uri</var><br />
&#160;&#160;package-version? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-accept">xsl:accept</a> | <a href=
"#element-override">xsl:override</a>)* --&gt;<br />
&lt;/xsl:use-package&gt;</code></p>
<p>A <a title="package" class="termref" href=
"#dt-package">package</a> may be <a title="use" class="termref"
href="#dt-use">used</a> by more than one other package, but the
relationship must not be cyclic. It is possible, but by no means
inevitable, that using the same package in more than one place
within a stylesheet will cause static errors due to the presence of
conflicting components according to the above rules. Where a
package is successfully used by more than one other package, its
components may be overridden in different ways by different using
packages.</p>
<p>The <code>name</code> and <code>package-version</code>
attributes together identify the used package. The used package
must have a name that is an exact match for the name in the
<code>name</code> attribute (using codepoint comparison), and it
may have a package-version that matches the pattern given in the
<code>package-version</code> attribute, according to the rules
below. Omitting this attribute is equivalent to specifying the
value as <code>package-version="#"</code>, which matches any
version.</p>
<p>The value of the <code>package-version</code> attribute consists
of a prefix and a suffix separated by a hash sign (#); if there is
no hash sign, the entire string is used as the prefix, and the
suffix is empty; if there is more than one hash sign, the first one
is taken as the separator and others as part of the suffix; if the
hash sign is the last character in the string then a suffix of ".*"
is assumed. The pattern matches a package version if the package
version can be divided into two substrings such that the first
substring matches the prefix literally (using codepoint
comparison), and the second substring matches the suffix considered
as a regular expression (matched according to the rules of the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>
function with the <code>$flags</code> argument set to a zero length
string). Thus the version pattern <code>3.1</code> matches version
<code>3.1</code> only; the pattern <code>3.1#</code> matches
<code>3.1</code>, <code>3.1.2</code>, and <code>3.17</code>; the
pattern <code>3.1#(\.\d+)?</code> matches <code>3.1</code> and
<code>3.1.5</code>; and the pattern <code>3.1#(\.\d+)*</code>
matches <code>3.1</code>, <code>3.1.5</code>, and
<code>3.1.5.2</code>.</p>
<p>This specification does not define how the implementation
locates a package given its name and version. Nor does it define
whether this process locates source code or some other
representation of the package contents. Such mechanisms are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Use of the
package name as a dereferencable URI is <span class="verb">not
recommended</span>, because the intent of the packaging feature is
to allow a package to be distributed as reusable code and therefore
to exist in many different locations.</p>
<p>The <a href="#element-accept"><code>xsl:accept</code></a> and
<a href="#element-override"><code>xsl:override</code></a> elements
are used to modify the visibility or behavior of components
acquired from the used package; they are described in <a href=
"#accepting-components"><i>3.6.2.4 Accepting Components</i></a>
below.</p>
<p>An <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
whose parent element is <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> is allowed only
if the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> does not form
part of an explicit package.</p>
</div>
<div class="div3">
<h4><a name="named-components" id="named-components"></a>3.6.2
<a href="#named-components" style="text-decoration: none">Named
Components in Packages</a></h4>
<p>This section discusses the use of named components in packages:
specifically <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">functions</a>, <a title="named template"
class="termref" href="#dt-named-template">named templates</a>,
<a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute sets</a>, <span><a title="mode"
class="termref" href="#dt-mode">modes</a>, <a title="accumulator"
class="termref" href="#dt-accumulator">accumulators</a>,</span>
<span><a title="key" class="termref" href=
"#dt-key">keys</a></span>, <a title="mode" class="termref" href=
"#dt-mode">modes</a>, and <a title="global variable" class=
"termref" href="#dt-global-variable">global variables</a> and
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">parameters</a>. Some of the provisions
in this section also apply to named modes, but there are
differences noted in <a href="#modes-and-packages"><i>3.6.3
Overriding Template Rules from a Used Package</i></a>. The section
is largely concerned with details of the rules that affect
references from one component to another by name, whether the
components are in the same package or in different packages. The
rules are designed to meet a number of requirements:</p>
<ul>
<li>
<p>A component defined in one package can be overridden by a
component in another package, provided the signatures are
type-compatible.</p>
</li>
<li>
<p>The author of a package can declare whether the components in
the package are public or private (that is, whether or not they can
be used from outside the package) and whether they are final,
overridable, or abstract (that is whether they can or must be
overridden by the using package).</p>
</li>
<li>
<p>Within an application, two packages can make use of a common
library and override its components in different ways.</p>
</li>
<li>
<p>Visibility of components can be defined either as part of the
declaration of the component, or in the package manifest.</p>
</li>
<li>
<p>An application that wishes to make use of a library package can
be selective about which components from the library it acquires,
perhaps to avoid name clashes between components acquired from
different libraries.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-component" id="dt-component" title="component"></a>The term
<b>component</b> is used to refer to any of the following: a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, a <a title="mode" class="termref" href=
"#dt-mode">mode</a>, <span>an <a title="accumulator function"
class="termref" href=
"#dt-accumulator-function">accumulator</a></span> an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, a <span><a title="key" class="termref" href=
"#dt-key">key</a></span>, <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a>, or a
<a title="mode" class="termref" href=
"#dt-mode">mode</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-symbolic-identifier" id="dt-symbolic-identifier" title=
"symbolic identifier"></a>The <b>symbolic identifier</b> of a
<a title="component" class="termref" href=
"#dt-component">component</a> is a composite name used to identify
the component uniquely within a package. The symbolic identifier
comprises the kind of component (stylesheet function, named
template, <span>accumulator</span>, attribute set, global variable,
or mode), the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the component (namespace
URI plus local name), and in the case of stylesheet functions, the
<a title="arity" class="termref" href=
"#dt-arity">arity</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-homonymous" id="dt-homonymous" title="homonymous"></a>Two
<a title="component" class="termref" href=
"#dt-component">components</a> are said to be <b>homonymous</b> if
they have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>.<span class=
"definition">]</span></p>
<p>Every <a title="component" class="termref" href=
"#dt-component">component</a> has a <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a> in some <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> and therefore within
some <a title="package" class="termref" href=
"#dt-package">package</a>. <span>In the case of <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
sets</a>, there may be several declarations.</span> The declaration
is an element in an XDM tree representing the stylesheet module.
Declarations therefore have identity, based on XDM node
identity.</p>
<p>Not all <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> result in <a title="component"
class="termref" href="#dt-component">components</a>:</p>
<ul>
<li>
<p>Some declarations, such as <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a> and
<a href="#element-strip-space"><code>xsl:strip-space</code></a>,
declare aspects of the processing context which are not considered
to be components as defined here.</p>
</li>
<li>
<p><a title="template rule" class="termref" href=
"#dt-template-rule">Template rules</a> (<a href=
"#element-template"><code>xsl:template</code></a> with a
<code>match</code> attribute) are also not considered to be
components for the purposes of this section, which is concerned
only with components that are bound by name. However, when an
<a href="#element-template"><code>xsl:template</code></a> has both
a <code>match</code> attribute and a <code>name</code> attribute,
then it establishes both a template rule and a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, and in its role as a named template it comes within
the scope of this discussion.</p>
</li>
<li>
<p>A named declaration, for example a named template, a function,
<span>an accumulator,</span> or a global variable, may be
overridden within the same package by another like-named
declaration having higher <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>. When
a declaration is overridden in this way it can never be referenced
or invoked either from within its containing package or from
outside that package; it is effectively dead code, and it therefore
does not result in the creation of any component, which means that
it plays no part in the component binding process.</p>
</li>
<li>
<p>In the case of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> and
<a href="#element-key"><code>xsl:key</code></a> declarations,
several declarations combine to form a single component.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaring-package" id="dt-declaring-package" title=
"declaring package"></a>The <b>declaring package</b> of a <a title=
"component" class="termref" href="#dt-component">component</a> is
the package that contains the declaration <span>(or, in the case of
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
and <a href="#element-key"><code>xsl:key</code></a>, multiple
declarations)</span> of the component.<span class=
"definition">]</span></p>
<p>When a <a title="component" class="termref" href=
"#dt-component">component</a> declared in one <a title="package"
class="termref" href="#dt-package">package</a> is made available in
another, the using package will contain a separate component that
can be regarded as a modified copy of the original. The new
component shares the same <a title="symbolic identifier" class=
"termref" href="#dt-symbolic-identifier">symbolic identifier</a> as
the original, and it has the same <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a>, but it has other
properties such as its <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> that may differ from the
original.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-containing-package" id="dt-containing-package" title=
"containing package"></a>A component declaration results in
multiple components, one in the package in which the declaration
appears, and potentially one in each package that uses the
declaring package, directly or indirectly, subject to the
visibility of the component. Each of these multiple compenents has
the same <a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a>, but each has a
different <b>containing package</b>. For the original component,
the declaring package and the containing package are the same; for
a copy of a component made as a result of a <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declaration, the declaring package will be the original package,
and the containing package will be the package in which the
<a href="#element-use-package"><code>xsl:use-package</code></a>
declaration appears.<span class="definition">]</span></p>
<p>The properties of a <a title="component" class="termref" href=
"#dt-component">component</a> are as follows:</p>
<ul>
<li>
<p>The original <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of the component.</p>
</li>
<li>
<p>The <a title="package" class="termref" href=
"#dt-package">package</a> to which the component belongs (called
its <b>containing</b> package, not to be confused with the
<a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a>).</p>
</li>
<li>
<p>The <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> of the
component.</p>
</li>
<li>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component, which determines
the way in which the component is seen by other components within
the same package and within using packages. This is one of
<code>public</code>, <code>private</code>, <code>abstract</code>,
<code>final</code>, or <code>hidden</code>. The visibility of
components is discussed further in <a href="#visibility"><i>3.6.2.1
Visibility of Components</i></a>.</p>
</li>
<li>
<p>A set of bindings for the <a title="symbolic reference" class=
"termref" href="#dt-symbolic-reference">symbolic references</a> in
the component. The way in which these bindings are established is
discussed further in <a href="#component-references"><i>3.6.2.6
Binding References to Components</i></a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When a function <var>F</var> defined in a package <var>P</var>
is acquired by two using packages <var>Q</var> and <var>R</var>, we
may think of <var>P</var>, <var>Q</var>, and <var>R</var> as all
providing access to the "same" function. The detailed semantics,
however, demand an understanding that there is one function
declaration, but three components. The three components
representing the function <var>F</var> within packages
<var>P</var>, <var>Q</var>, and <var>R</var> have some properties
in common (the same symbolic identifier, the same declaration), but
other properties (the visibility and the bindings of symbolic
references) that may vary from one of these components to
another.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-symbolic-reference" id="dt-symbolic-reference" title=
"symbolic reference"></a>The <a title="declaration" class="termref"
href="#dt-declaration">declaration</a> of a component includes
constructs that can be interpreted as references to other <a title=
"component" class="termref" href="#dt-component">components</a> by
means of their <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. These
constructs are generically referred to as <b>symbolic
references</b>. Examples of constructs that give rise to symbolic
references are the <code>name</code> attribute of <a href=
"#element-call-template"><code>xsl:call-template</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, and <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>; the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>;
XPath variable references referring to global variables; and XPath
function calls referring to <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
<span>or <a title="accumulator function" class="termref" href=
"#dt-accumulator-function">accumulator
functions</a></span>.<span class="definition">]</span></p>
<p>Symbolic references exist as properties of the <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> of a <a title="component" class=
"termref" href="#dt-component">component</a>. The <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> being referred to
can be determined straightforwardly from the syntactic form and
context of the reference: for example, the instruction
<code>&lt;xsl:value-of select="f:price($o)"
xmlns:f="http://f.com/"/&gt;</code> contains a symbolic reference
to a function with expanded name <code>{http://f.com/}price</code>
and with arity=1. However, because there may be several
(homonymous) function components with this symbolic identifier,
translating this symbolic reference into a reference to a specific
component (a process called "binding") is less straightforward, and
is described in the text that follows.</p>
<p>The process of assembling a stylesheet from its constituent
packages is primarily a process of binding these symbolic
references to actual components. Within any <a title="component"
class="termref" href="#dt-component">component</a> whose <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> is <var>D</var>, there is a set
of bindings; each binding is an association between an <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> in <var>D</var> and
a <a title="component" class="termref" href=
"#dt-component">component</a> whose <a title="symbolic identifier"
class="termref" href="#dt-symbolic-identifier">symbolic
identifier</a> matches the outward reference. Outward references
for which a component <var>C</var> contains a binding are said to
be <b>bound</b> in <var>C</var>; those for which <var>C</var>
contains no binding are said to be <b>unbound</b>.</p>
<p>For example, suppose that in some package <var>P</var>, function
<var>A</var> calls <var>B</var>, which in turn calls <var>C</var>,
and that <var>B</var> is <code>private</code>. Now suppose that in
some package <var>Q</var> which uses <var>P</var>, <var>C</var> is
overridden. The effect of the binding process is that <var>Q</var>
will contain three components corresponding to <var>A</var>,
<var>B</var>, and <var>C</var>, which we might call
<var>A(Q)</var>, <var>B(Q)</var>, and <var>C(Q)</var>. The
<a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> of <var>A(Q)</var> and
<var>B(Q)</var> are in package <var>P</var>, but the declaration of
<var>C(Q)</var> is in <var>Q</var>. The internal visibility of
<var>B(Q)</var> will be <code>hidden</code> (meaning that it cannot
be referenced from within <var>Q</var>), and <var>B(Q)</var> will
contain a binding for the component <var>C(Q)</var> that
corresponds to the outward reference from <var>B</var> to
<var>C</var>. The effect is that when <var>A</var> calls
<var>B</var> and <var>B</var> calls <var>C</var>, it is the
overriding version of <var>C</var> that is executed. In another
package <var>R</var> that uses <var>P</var> without overriding
<var>C</var>, there will be three different components
<var>A(R)</var>, <var>B(R)</var>, and <var>C(R)</var>. This time
the declaration of all three components is in the original package
<var>P</var>. Component <var>B(R)</var> will contain a binding to
<var>C(R)</var>, so in this package, the original version of
<var>C</var> is executed. The fact that one package <var>Q</var>
overrides <var>C</var> thus has no effect on <var>R</var>, which
does not override it.</p>
<p>Template rules are not components in their own right; unlike
named templates, they are never referenced by name. Component
references within a template rule (for example, references to
functions, global variables, or named templates) are treated as
occurring within the component that represents the containing mode.
If a template rule lists several modes, it is treated as if there
were multiple template rules one in each mode.</p>
<p><a title="key" class="termref" href="#dt-key">Keys</a> behave
rather differently from other components. Their visibility is
always private, which means they can only be used within their
declaring package. In addition, the component binding (the
reference to a key definition from a call on the <a href=
"#func-key"><code>key</code></a> function) is in the general case
made dynamically rather than statically. However, outward
references from key definitions to other components (such as global
variables and functions) behave in the same way as component
references contained in any other private component, in that they
may be rebound to an overriding declaration of the target
component.</p>
<div class="div4">
<h5><a name="visibility" id="visibility"></a>3.6.2.1 <a href=
"#visibility" style="text-decoration: none">Visibility of
Components</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-visibility" id="dt-visibility" title="visibility"></a>The
<b>visibility</b> of a <a title="component" class="termref" href=
"#dt-component">component</a> is one of: <code>private</code>,
<code>public</code>, <code>abstract</code>, <code>final</code>, or
<code>hidden</code>.<span class="definition">]</span></p>
<p>The meanings of these visibility values is as follows:</p>
<table border="1" cellpadding="5" summary=
"Values of the visibility attribute, and their meaning" width=
"100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Visibility</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">public</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; it can be
overridden by a different component in any using package.</td>
</tr>
<tr>
<td align="left" valign="top">private</td>
<td align="left" valign="top">The component can be referenced from
other components in this package; it cannot be referenced or
overridden within a using package.</td>
</tr>
<tr>
<td align="left" valign="top">abstract</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; in a
using package it can either remain abstract or be overridden by a
different component.</td>
</tr>
<tr>
<td align="left" valign="top">final</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; it cannot
be overridden by a different component in any using package.</td>
</tr>
<tr>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">The component cannot be referenced
from other components in this package; it cannot be referenced or
overridden within a using package.</td>
</tr>
</tbody>
</table>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> (sometimes called the <b>actual
visibility</b>) of a component depends on two factors: its
<a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> and its
<a title="exposed visibility" class="termref" href=
"#dt-exposed-visibility">exposed visibility</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-potential-visibility" id="dt-potential-visibility" title=
"potential visibility"></a>The <b>potential visibility</b> of a
component is established when the component is declared or accepted
into a package.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-exposed-visibility" id="dt-exposed-visibility" title=
"exposed visibility"></a>The <b>exposed visibility</b> of a
component is established by an <a href=
"#element-expose"><code>xsl:expose</code></a> element in the
package manifest.<span class="definition">]</span></p>
<p>For a component within its <a title="declaring package" class=
"termref" href="#dt-declaring-package">declaring package</a> the
<a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> is the value of
the <code>visibility</code> attribute on the component's <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>, or <code>private</code> if the
attribute is absent.</p>
<p>For a component accepted from another package, the <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> depends on the
visibility declared in the relevant <a href=
"#element-accept"><code>xsl:accept</code></a> or <a href=
"#element-override"><code>xsl:override</code></a> element that
makes the component available within the using package; this in
turn has a default that depends on the (actual) visibility of the
corresponding component in the used package.</p>
<p>These rules are described more fully in the sections that
follow.</p>
</div>
<div class="div4">
<h5><a name="declared-visibility" id=
"declared-visibility"></a>3.6.2.2 <a href="#declared-visibility"
style="text-decoration: none">Visibility of Declarations</a></h5>
<p>The <a href="#element-function"><code>xsl:function</code></a>,
<a href="#element-template"><code>xsl:template</code></a>, <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>,
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, and <a href=
"#element-mode"><code>xsl:mode</code></a> <a title="declaration"
class="termref" href="#dt-declaration">declarations</a> each have
an optional <code>visibility</code> attribute that determines the
<a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> of the
component corresponding to this declaration in its <a title=
"declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a>. The value is one of
<code>private</code>, <code>public</code>, <code>abstract</code>,
<code>final</code> (never <code>hidden</code>), with the default
being <code>private</code>. <span>In the case of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>, all
the declarations for an attribute set must have the same value for
the <code>visibility</code> attribute. In the case of <a href=
"#element-key"><code>xsl:key</code></a>, the visibility cannot be
explicitly specified: it is always <code>private</code>.</span></p>
<p>Whatever the value of this attribute, and whatever the <a title=
"exposed visibility" class="termref" href=
"#dt-exposed-visibility">exposed visiblity</a> of the component,
other declarations within the same package may contain <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic references</a> to this
declaration: informally, the name of the component is always "in
scope" within the package containing its declaration. The way in
which these symbolic references are bound to an actual component,
however, depends on the component's visibility, as defined in
<a href="#component-references"><i>3.6.2.6 Binding References to
Components</i></a>. For example, a symbolic reference will never be
bound to a component whose visibility is <code>abstract</code>.</p>
</div>
<div class="div4">
<h5><a name="exposing-components" id=
"exposing-components"></a>3.6.2.3 <a href="#exposing-components"
style="text-decoration: none">Exposing Components</a></h5>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of a component within a package may
be modified by means of an <a href=
"#element-expose"><code>xsl:expose</code></a> element in the
package manifest.</p>
<p class="element-syntax"><a name="element-expose" id=
"element-expose"></a><code>&lt;xsl:expose<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract"&#160;/&gt;</code></p>
<p>The <a href="#element-expose"><code>xsl:expose</code></a>
element allows selected components within a package to have an
<a title="exposed visibility" class="termref" href=
"#dt-exposed-visibility">exposed visibility</a> different from
their <a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> .</p>
<p>The components in question are identified using their <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. The
<code>component</code> attribute defines the kind of component that
is selected (<code>variable</code> embraces <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a>). The
<code>names</code> attribute selects a subset of those components
by name (and in the case of functions, arity); its value is a
whitespace-separated sequence of tokens each of which is either a
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
or a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NamedFunctionRef">NamedFunctionRef</a><sup><small>XP30</small></sup>.
(Examples are <code>*</code>, <code>p:*</code>,
<code>*:local</code>, <code>p:local</code>, and
<code>p:local#2</code>.)</p>
<p>The value may be a <code>NamedFunctionRef</code> only in the
case of stylesheet functions, and distinguishes functions with the
same name and different arity.</p>
<p>The <code>visibility</code> attribute defines the exposed
visibility of the selected components.</p>
<p>If a <a title="component" class="termref" href=
"#dt-component">component</a> is matched by more than one <a href=
"#element-expose"><code>xsl:expose</code></a> element in the
package manifest, then its exposed visibility is determined by the
best matching <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
or <code>LiteralFunctionItem</code>. The rules are similar to those
for <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>:</p>
<ul>
<li>
<p>A token in the form of a LiteralFunctionItem (for example,
<code>f:price#1</code>) has higher priority than any NameTest.</p>
</li>
<li>
<p>Next, any match that has a lower <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
than the <a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> of another match is
ignored.</p>
</li>
<li>
<p>If several matches have the same <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
(which can happen if the same value is repeated, or if one of the
NameTests takes the form <code>*:local</code> and the other takes
the form <code>prefix:*</code>), then the <a href=
"#element-expose"><code>xsl:expose</code></a> element that appears
last in document order within the package manifest is used.</p>
</li>
</ul>
<p>If no <a href="#element-expose"><code>xsl:expose</code></a>
element matches a component, then the <a title="visibility" class=
"termref" href="#dt-visibility">visibility</a> of the component is
its <a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a>.</p>
<p>Otherwise, the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component depends on its
potential visibility and its exposed visibility as defined by the
following table. In this table, the value N/P means "not
permitted".</p>
<table border="1" cellpadding="5" summary=
"relationship of exposed visibility to potential visibility" width=
"100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Exposed
visibility</th>
<th colspan="4" align="left" valign="top">Potential visibility</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<th colspan="1" align="left" valign="top">private</th>
<th colspan="1" align="left" valign="top">final</th>
<th colspan="1" align="left" valign="top">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<td align="left" valign="top">public</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">private</th>
<td align="left" valign="top">private</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">final</th>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">abstract</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">abstract</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE3010" id="err-XTSE3010"><span class=
"error">[ERR XTSE3010]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
exposed visibility of a component is inconsistent with its
potential visibility, as defined in the above table, unless the
token that matches the component is a wildcard, in which case it is
treated as not matching that component.</p>
<p><a name="err-XTSE3020" id="err-XTSE3020"><span class=
"error">[ERR XTSE3020]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-expose"><code>xsl:expose</code></a> element
matches no components in the containing package, unless the tokens
in the <code>names</code> attribute are all wildcards.</p>
</div>
<div class="div4">
<h5><a name="accepting-components" id=
"accepting-components"></a>3.6.2.4 <a href="#accepting-components"
style="text-decoration: none">Accepting Components</a></h5>
<p>When a package <var>Q</var> uses a package <var>P</var>, by
virtue of an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element in
the <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> of <var>Q</var>, then
<var>Q</var> will contain a <a title="component" class="termref"
href="#dt-component">component</a> corresponding to every component
in <var>P</var>. The <a title="potential visibility" class=
"termref" href="#dt-potential-visibility">potential visibility</a>
of the component within <var>Q</var> depends on the <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
of the component in <var>P</var>, optionally modified by two
elements that may appear as children of the <a href=
"#element-use-package"><code>xsl:use-package</code></a> element,
namely <a href="#element-accept"><code>xsl:accept</code></a> and
<a href="#element-override"><code>xsl:override</code></a>.</p>
<p>For every component <var>C(P)</var> in package <var>P</var> that
is not matched by any <a href=
"#element-override"><code>xsl:override</code></a> or <a href=
"#element-accept"><code>xsl:accept</code></a> element in the
package manifest of <var>Q</var>, there will be a corresponding
component <var>C(Q)</var> in package <var>Q</var> that has the same
<a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> and <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> as <var>C(P)</var>. The <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> of
<var>C(Q)</var> will be the same as the (actual) <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
of <var>C(P)</var>, except that where the <a title="visibility"
class="termref" href="#dt-visibility">visibility</a> of
<var>C(P)</var> is <code>private</code>, the <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> of
<var>C(Q)</var> will be <code>hidden</code>. The (actual)
visibility of <var>C(Q)</var> depends both on its <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> and its
<a title="exposed visibility" class="termref" href=
"#dt-exposed-visibility">exposed visibility</a>, as described in
<a href="#exposing-components"><i>3.6.2.3 Exposing
Components</i></a>.</p>
<p>A component <var>C(P)</var> in package <var>P</var> whose
<a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> is <code>hidden</code> will never
be matched by an <a href=
"#element-override"><code>xsl:override</code></a> or <a href=
"#element-accept"><code>xsl:accept</code></a> element in the
package manifest of <var>Q</var>, and therefore <var>Q</var> will
contain a <code>hidden</code> component <var>C(Q)</var>
corresponding to <var>C(P)</var>.</p>
<p class="element-syntax"><a name="element-accept" id=
"element-accept"></a><code>&lt;xsl:accept<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract" | "hidden" | "absent"&#160;/&gt;</code></p>
<p>The <a href="#element-accept"><code>xsl:accept</code></a>
element has the same syntax as <a href=
"#element-expose"><code>xsl:expose</code></a>, and very similar
semantics. Whereas <a href=
"#element-expose"><code>xsl:expose</code></a> allows a package to
restrict the visibility of its own components to other (using)
packages, <a href="#element-accept"><code>xsl:accept</code></a>
allows a package to restrict the visibility of components exposed
by a package that it uses. This may be necessary if, for example,
it uses two different packages whose component names conflict. It
may also simply be good practice if the package author knows that
only a small subset of the functionality of a used package is
required.</p>
<p>The rules for determining whether an <a href=
"#element-accept"><code>xsl:accept</code></a> element matches a
particular component, and for which element to use if there are
several matches, are the same as the rules for the <a href=
"#element-expose"><code>xsl:expose</code></a> element.</p>
<p><a name="err-XTSE3030" id="err-XTSE3030"><span class=
"error">[ERR XTSE3030]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-accept"><code>xsl:accept</code></a> element
matches no components in the used package, unless the tokens in its
<code>names</code> attribute are all wildcards.</p>
<p>In the absence of a matching <a href=
"#element-override"><code>xsl:override</code></a> element (see
<a href="#package-overriding-components"><i>3.6.2.5 Overriding
Named Components from a Used Package</i></a>), the <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> of a component
that matches an <a href=
"#element-accept"><code>xsl:accept</code></a> element depends both
on the <code>visibility</code> attribute of the best-matching
<a href="#element-accept"><code>xsl:accept</code></a> element and
on the (actual) <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the corresponding component in
the used package, according to the following table. In this table
the entry "N/P" means "not permitted".</p>
<table border="1" cellpadding="5" summary=
"relationship of the visibility given in xsl:accept to visibility in the used package"
width="100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Visibility in
<a href="#element-accept"><code>xsl:accept</code></a> element</th>
<th colspan="4" align="left" valign="top">Visibility in used
package</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<th colspan="1" align="left" valign="top">private</th>
<th colspan="1" align="left" valign="top">final</th>
<th colspan="1" align="left" valign="top">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<td align="left" valign="top">public</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">private</th>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">final</th>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">abstract</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">abstract</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">hidden</th>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">absent</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">absent</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE3040" id="err-XTSE3040"><span class=
"error">[ERR XTSE3040]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
visibility assigned to a component by an <a href=
"#element-accept"><code>xsl:accept</code></a> element is
incompatible with the visibility of the corresponding component in
the used package, as defined by the above table, unless the token
that matches the component name is a wildcard, in which case the
<a href="#element-accept"><code>xsl:accept</code></a> element is
treated as not matching that component.</p>
<p><a name="err-XTSE3050" id="err-XTSE3050"><span class=
"error">[ERR XTSE3050]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-use-package"><code>xsl:use-package</code></a>
elements in a <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> cause two or more
<a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> components to be accepted with a
visibility other than <code>hidden</code>.</p>
<p>Conflicts between the components accepted from used packages and
those declared within the package itself are handled as
follows:</p>
<ol class="enumar">
<li>
<p>If the conflict is between two components both declared within
the package itself, then it is resolved by the rules relating to
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> defined for each kind
of component.</p>
</li>
<li>
<p>If the conflict is between two components both accepted from
used packages, or between a component declared within the package
and an accepted component, then a static error occurs.</p>
</li>
</ol>
<p>The value <code>visibility="absent"</code> may be used only in
the case of a component that is present in the used package with
exposed visibility <code>abstract</code>. It is used to indicate
that the using package does not intend to provide an implementation
of the abstract component, and that any invocation of the abstract
component is therefore to result in an error. Specifically:</p>
<ol class="enumar">
<li>
<p>Any component reference to the component within the using
package is a static error, as if the component were hidden: in
effect, the name of the component is not in scope in the using
package.</p>
</li>
<li>
<p>Any invocation of the absent component (typically from within
its declaring package) causes a dynamic error, as if the component
were overridden by a component that unconditionally raises a
dynamic error.</p>
<p><a name="err-XTDE3052" id="err-XTDE3052"><span class=
"error">[ERR XTDE3052]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
invocation of an absent component (that is, an abstract component
accepted into a using package with
<code>visibility="absent"</code>) is evaluated.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To override a component accepted from a used package, the
overriding declaration must appear as a child of the <a href=
"#element-override"><code>xsl:override</code></a> element.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no rule that prevents a function (say) being declared
in the using package with the same name as a <code>private</code>
function in the used package. This does not create a conflict,
since all references in the used package are bound to one function
and all those in the using package are bound to another.</p>
</div>
</div>
<div class="div4">
<h5><a name="package-overriding-components" id=
"package-overriding-components"></a>3.6.2.5 <a href=
"#package-overriding-components" style=
"text-decoration: none">Overriding Named Components from a Used
Package</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-override" id="dt-override" title="override"></a>A component in
a using package may <b>override</b> a component in a used package,
provided that the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component in the used
package is either <code>abstract</code> or <code>public</code>. The
overriding declaration is written as a child of the <a href=
"#element-override"><code>xsl:override</code></a> element, which in
turn appears as a child of <a href=
"#element-use-package"><code>xsl:use-package</code></a>.<span class="definition">]</span></p>
<p class="element-syntax"><a name="element-override" id=
"element-override"></a><code>&lt;xsl:override&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-template">xsl:template</a> | <a href=
"#element-function">xsl:function</a> | <a href=
"#element-accumulator">xsl:accumulator</a> | <a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a> | <a href=
"#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br />
&lt;/xsl:override&gt;</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This mechanism is distinct from the mechanism for overriding
declarations within the same package by relying on <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>. It imposes stricter
rules: the overriding component is required to be type-compatible
with the component that it overrides.</p>
</div>
<p>If the used package <var>P</var> contains a <a title="component"
class="termref" href="#dt-component">component</a> <var>C(P)</var>
and the <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
contains an <a href=
"#element-override"><code>xsl:override</code></a> element which
contains a declaration <var>D</var> whose <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> matches the
symbolic identifier of <var>C(P)</var>, then the using package
<var>Q</var> will contain a component whose declaration is D, whose
symbolic identifier is that of D, and whose <a title=
"potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> is equal to the
value of the <code>visibility</code> attribute of <var>D</var>, or
<code>private</code> if this is absent.</p>
<p>If the overridden component <var>C(P)</var> has visibility
<code>public</code> then the using package <var>Q</var> will also
contain a component <var>C′(Q)</var> whose declaration is the same
as the declaration of <var>C(P)</var> and whose <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
is <code>hidden</code>. This component is used as the target of a
binding for the symbolic reference <code>xsl:original</code>
described below.</p>
<p>Other than its appearance as a child of <a href=
"#element-override"><code>xsl:override</code></a>, the overriding
declaration is a normal <a href=
"#element-function"><code>xsl:function</code></a>, <a href=
"#element-template"><code>xsl:template</code></a>, <span><a href=
"#element-accumulator"><code>xsl:accumulator</code></a></span>,
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>, or
<a href="#element-mode"><code>xsl:mode</code></a> element. In the
case of <a href="#element-variable"><code>xsl:variable</code></a>
and <a href="#element-param"><code>xsl:param</code></a>, the
variable that is declared is a <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a>.</p>
<p>The <a title="potential visibility" class="termref" href=
"#dt-potential-visibility">potential visibility</a> of the
overriding component in the using package is defined by the
<code>visibility</code> attribute appearing on the overriding
declaration.</p>
<p><a name="err-XTSE3055" id="err-XTSE3055"><span class=
"error">[ERR XTSE3055]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
component declaration appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> is <a title=
"homonymous" class="termref" href="#dt-homonymous">homonymous</a>
with any other declaration in the using package, regardless of
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, including any other
overriding declaration in the package manifest of the using
package.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When an attribute set is overridden, the overriding attribute
set must be defined using a single <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element. Attribute sets defined in different packages are never
merged by virtue of having the same name, though they may be merged
explicitly by using the <code>use-attribute-sets</code>
attribute.</p>
</div>
<p><a name="err-XTSE3058" id="err-XTSE3058"><span class=
"error">[ERR XTSE3058]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
component declaration appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> does not match
(is not <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> with) some component in the used
package.</p>
<p><a name="err-XTSE3060" id="err-XTSE3060"><span class=
"error">[ERR XTSE3060]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
component referenced by an <a href=
"#element-override"><code>xsl:override</code></a> declaration has
<a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> other than <code>public</code> or
<code>abstract</code></p>
<p>A package is executable if and only if it contains no <a title=
"component" class="termref" href="#dt-component">component</a>
whose <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> is <code>abstract</code>. A package
that is not executable is not a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, and therefore
cannot be nominated as the stylesheet to be used when initiating a
transformation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In other words, if a component is declared as abstract, then
some package that uses the declaring package of that component
directly or indirectly must override that component with one that
is not abstract. It is not necessary for the override to happen in
the immediately using package.</p>
</div>
<p><a name="err-XTSE3070" id="err-XTSE3070"><span class=
"error">[ERR XTSE3070]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
signature of an overriding component is not <a title="compatible"
class="termref" href="#dt-compatible">compatible</a> with the
signature of the component that it is overriding.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-compatible" id="dt-compatible" title="compatible"></a>The
signatures of two <a title="component" class="termref" href=
"#dt-component">components</a> are <b>compatible</b> if they
present the same interface to the user of the component. The
additional rules depend on the kind of component.<span class=
"definition">]</span></p>
<p>Compatibility is only relevant when comparing two components
that have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>. The
compatibility rules for each kind of component are as follows:</p>
<ul>
<li>
<p>Two attribute sets with the same name are compatible if and only
if they satisfy the following rule:</p>
<ol class="enumar">
<li>
<p>If the overridden attribute set specifies
<code>streamable="yes"</code> then the overriding attribute set
also specifies <code>streamable="yes"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two functions with the same name and arity are compatible if and
only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>The types of the arguments are pairwise <a title=
"identical (types)" class="termref" href=
"#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>The return types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden function specifies
<code>identity-sensitive="no"</code> then the overriding function
also specifies <code>identity-sensitive="no"</code>.</p>
</li>
<li>
<p>If the overridden function specifies
<code>override-extension-functions="no"</code> (or the equivalent
using the deprecated <code>override</code> attribute) then the
overriding function also specifies
<code>override-extension-functions="no"</code> (or the
equivalent).</p>
</li>
</ol>
</li>
<li>
<p>Two accumulators with the same name are compatible if and only
if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>The types (defined in the <code>as</code> attribute) are
<a title="identical (types)" class="termref" href=
"#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden accumulator specifies
<code>streamable="yes"</code> then the overriding accumulator also
specifies <code>streamable="yes"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two named templates with the same name are compatible if and
only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>Their return types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>For every parameter on the overridden template, there is a
parameter on the overriding template that has the same name, an
<a title="identical (types)" class="termref" href=
"#dt-identical-types">identical</a> required type, and the same
effective values for the <code>tunnel</code> and
<code>required</code> attributes.</p>
</li>
<li>
<p>Any parameter on the overriding template for which there is no
corresponding parameter on the overridden template specifies
<code>required="no"</code>.</p>
</li>
<li>
<p>The two templates have equivalent <a href=
"#element-context-item"><code>xsl:context-item</code></a> children,
where equivalence means that the <code>use</code> attributes are
the same and the required types are <a title="identical (types)"
class="termref" href="#dt-identical-types">identical</a>; an absent
<a href="#element-context-item"><code>xsl:context-item</code></a>
is equivalent to one that specifies <code>use="optional"</code> and
<code>as="item()"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two variables (including parameters) with the same name are
compatible if and only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>Their declared types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden variable is a parameter that specifies
<code>required="yes"</code> then the overriding variable is either
a non-parameter variable, or a parameter that specifies
<code>required="yes"</code></p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A variable may override a parameter or vice-versa, and the
initial value may differ.</p>
<p>Because static variables and parameters are constrained to have
visibility <code>private</code> or <code>final</code>, they cannot
be overridden in another package. The compatibility rules therefore
do not arise. The reason that such variables cannot be overridden
is that they are typically used during stylesheet compilation (for
example, in <code>[xsl:]use-when</code> expressions) and it is a
design goal that packages should be capable of independent
compilation.</p>
</div>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-identical-types" id="dt-identical-types" title=
"identical (types)"></a>Types S and T are considered
<b>identical</b> for the purpose of these rules if and only if
<code>subtype(S, T)</code> and <code>subtype(T, S)</code> both
hold, where the subtype relation is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-seqtype-subtype">Section 2.5.6.1
The judgement subtype(A, B)</a>
<sup><small>XP30</small></sup>.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<ol class="enumar">
<li>
<p>One consequence of this rule is that two plain union types are
considered identical if they have the same set of member types,
even if the union types have different names or the ordering of the
member types is different.</p>
</li>
<li>
<p>While this rule may appear formal, it is not as straightforward
as might be supposed, because the subtype relation in XPath has a
dependency on the "Type derivation OK (Simple)" relation in XML
Schema, which itself appeals to a judgement as to whether the two
type definitions being compared "are the same type definition".
Both XSD 1.0 and XSD 1.1 add the note "The wording of [this rule]
appeals to a notion of component identity which is only
incompletely defined by this version of this specification."
However, they go on to say that component identity is well defined
if the components are named simple type definitions, which will
always apply in this case. For named atomic types, the final result
of these rules is that two atomic types are identical if and only
if they have the same name.</p>
</li>
</ol>
</div>
<p>Modes are not overridable, so the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration cannot appear
as a child of <a href=
"#element-override"><code>xsl:override</code></a>.</p>
<p>Within the declaration of an overriding component (that is, a
component whose declaration is a child of <a href=
"#element-override"><code>xsl:override</code></a>), where the
overridden component has <code>public</code> visibility, it is
possible to use the name <code>xsl:original</code> as a <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> to the overridden
component:</p>
<ul>
<li>
<p>Within an overriding named template, <code>&lt;xsl:call-template
name="xsl:original"/&gt;</code> may be used to call the overridden
named template.</p>
</li>
<li>
<p>Within an overriding stylesheet function,
<code>xsl:original()</code> may be used to call the overridden
stylesheet function.</p>
</li>
<li>
<p>Within an overriding global variable or parameter,
<code>$xsl:original</code> may be used to reference the overridden
global variable or parameter.</p>
</li>
<li>
<p>Within an overriding attribute set,
<code>[xsl:]use-attribute-set="xsl:original"</code> may be used to
reference the overridden attribute set.</p>
</li>
<li>
<p>Within an overriding accumulator, however, it is not possible to
refer to the overridden accumulator.</p>
</li>
</ul>
<p>Within the overriding component <var>C(Q)</var>, this symbolic
reference is bound to the hidden component <var>C′(Q)</var>
described earlier, whose declaration is that of the component
<var>C(P)</var> in the used package. The static context for the
overriding declaration is augmented to include a component of the
relevant kind (function, named template, attribute set, or
variable) with the name <code>xsl:original</code>.</p>
</div>
<div class="div4">
<h5><a name="component-references" id=
"component-references"></a>3.6.2.6 <a href="#component-references"
style="text-decoration: none">Binding References to
Components</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-reference-resolution" id="dt-reference-resolution" title=
"reference resolution"></a>The process of identifying the <a title=
"component" class="termref" href="#dt-component">component</a> to
which a <a title="symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> applies (possibly
chosen from several <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> alternatives) is called
<b>reference binding</b>.<span class="definition">]</span> A
reference is called <b>bound</b> if the component to which it
applies has been identified and fixed, and is <b>unbound</b>
otherwise (that is, if it exists only in the form of a <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a>).</p>
<p>Reference resolution for the components in a package occurs
conceptually after a package has been fully defined and before the
processing of any other package that uses it.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If packages are separately compiled, then reference resolution
is likely to form part of the compilation process.</p>
</div>
<p>When reference resolution is performed for a <a title=
"component" class="termref" href="#dt-component">component</a>
<var>C</var>, each symbolic reference <var>R</var> that is present
in the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of <var>C</var> is processed as
follows:</p>
<ol class="enumar">
<li>
<p>If <var>C</var> already contains a binding for <var>R</var> then
this binding is retained.</p>
</li>
<li>
<p>If <var>C</var> contains no binding for <var>R</var> then the
processor attempts to locate a component in the containing package
of <var>C</var> whose visibility is not <code>hidden</code> and
whose symbolic name matches <var>R</var>. If there is no such
component, then a static error is reported as described elsewhere
in this specification. There can never be more than one. Call the
located component <var>D</var>. If <var>D</var> has <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
<code>private</code> or <code>final</code>, then <var>C</var>
acquires a binding that associates the symbolic reference
<var>R</var> with the component <var>D</var>. Otherwise, the
reference remains unbound.</p>
</li>
</ol>
<p>When a package <var>P</var> is used by another package
<var>Q</var>, then <var>Q</var> will accept components
corresponding to the components in <var>P</var>, as described in
previous sections. Until reference resolution is performed for
<var>Q</var>, these components will have the same bindings as their
corresponding components from <var>P</var>: a symbolic reference
that was bound for a component in <var>P</var> will retain the same
binding, and a symbolic reference that was unbound in <var>P</var>
will remain unbound in the corresponding component in <var>Q</var>.
Subsequently, when reference resolution is performed for package
<var>Q</var>, these symbolic references may become bound, perhaps
to components whose declaration is in <var>Q</var> or in some other
package.</p>
<p>When reference resolution is performed on a package that is
intended to be used as a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> (that is, for the top-level
package), symbolic references to components whose visibility is
<code>public</code> are bound in the same way as references to
components whose visibility is <code>private</code> or
<code>final</code>. At this stage there must be no symbolic
references referring to components whose visibility is
<code>abstract</code> (that is, an implementation must be provided
for every abstract component).</p>
<p><a name="err-XTSE3080" id="err-XTSE3080"><span class=
"error">[ERR XTSE3080]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
top-level package intended for execution (as distinct from a
library package) contains symbolic references referring to
components whose visibility is <code>abstract</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Unresolved references are allowed at the module level but not at
the package level. A stylesheet module can contain references to
components that are satisfied only when the module is imported into
another module that declares the missing component.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The process of resolving references (or linking) is critical to
an implementation that uses separate compilation. One of the aims
of these rules is to ensure that when compiling a package, it is
always possible to determine the signature of called functions,
templates, and other components. A further aim is to establish
unambiguously in what circumstances components can be overridden,
so that compilers know when it is possible to perform optimizations
such as inlining of function and variable references.</p>
<p>Suppose a public template <var>T</var> calls a private function
<var>F</var>. When the package containing these two components is
referenced by a using package, the template remains public, while
the function becomes hidden. Because the function becomes hidden,
it can no longer conflict with any other function of the same name,
or be overridden by any other function; at this stage the compiler
knows exactly which function <var>T</var> will be calling, and can
perform optimizations based on this knowledge.</p>
</div>
<p>The mechanism for resolving component references described in
this section is consistent with the mechanism used for binding
function and variable references described in the XPath
specification. XPath requires these variable and function names to
be present in the static context for an XPath expression. XSLT
ensures that all the non-hidden functions, global variables, and
global parameters in a package are present in the static context
for every XPath expression that appears in that package, along with
required information such as the type of a variable and the
signature of a function.</p>
</div>
</div>
<div class="div3">
<h4><a name="modes-and-packages" id="modes-and-packages"></a>3.6.3
<a href="#modes-and-packages" style=
"text-decoration: none">Overriding Template Rules from a Used
Package</a></h4>
<p>The rules in the previous section apply to named components
including functions, named templates, global variables, and named
attribute sets. The rules for <a title="mode" class="termref" href=
"#dt-mode">modes</a>, and the <a title="template rule" class=
"termref" href="#dt-template-rule">template rules</a> appearing
within a mode, are slightly different.</p>
<p>The unnamed mode is local to a package: in effect, each package
has its own private unnamed mode, and the unnamed mode of one
package does not interact with the unnamed mode of any other
package.</p>
<p>A named mode may be declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration as being
either <code>public</code>, <code>private</code>, or
<code>final</code>. The values of the <code>visibility</code>
attribute are interpreted as follows:</p>
<table border="1" cellspacing="2" summary=
"visibility values for named modes, and their meaning" cellpadding=
"5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Value</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">public</td>
<td align="left" valign="top">A <b>using</b> package may use
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> to
invoke templates in this mode; it may also declare additional
template rules in this mode, which are selected in preference to
template rules in the used package. These may appear only as
children of the <a href=
"#element-override"><code>xsl:override</code></a> element within
the <a href="#element-use-package"><code>xsl:use-package</code></a>
element.</td>
</tr>
<tr>
<td valign="top" align="left">private</td>
<td align="left" valign="top">A <b>using</b> package may neither
reference the mode nor provide additional templates in this mode;
the name of the mode is not even visible in the using package, so
no such attempt is possible. The using package can use the same
name for its own modes without risk of conflict.</td>
</tr>
<tr>
<td valign="top" align="left">final</td>
<td align="left" valign="top">A <b>using</b> package may use
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> to
invoke templates in this mode, but it must not provide additional
template rules in this mode.</td>
</tr>
</tbody>
</table>
<p>As with other named components, an <a href=
"#element-use-package"><code>xsl:use-package</code></a> declaration
may contain an <a href=
"#element-expose"><code>xsl:expose</code></a> element to control
the visibility of a mode acquired from the <b>used</b> package. The
allowed values of its <code>visibility</code> attribute are
<code>public</code>, <code>private</code>, <code>final</code>, and
<code>hidden</code>.</p>
<p>The <a href="#element-mode"><code>xsl:mode</code></a>
declaration itself must not be overridden. A using package must not
contain an <a href="#element-mode"><code>xsl:mode</code></a>
declaration whose name matches that of a <code>public</code> or
<code>final</code> <a href=
"#element-mode"><code>xsl:mode</code></a> component accepted from a
used package.</p>
<p>The <a href="#element-expose"><code>xsl:expose</code></a> and
<a href="#element-accept"><code>xsl:accept</code></a> elements may
be used to reduce the visibility of a mode in a using package; the
same rules apply in general, though some of the rules are not
applicable because, for example, modes cannot be
<code>abstract</code>.</p>
<p>It is not possible for a package to combine the template rules
from two other packages into a single mode. When <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used without specifying a mode, the chosen template rules will
always come from the same package; when it is used with a named
mode, then they will come from the package where the mode is
defined, or any package that uses that package and adds template
rules to the mode. If two template rules defined in different
packages match the same node, then the rule in the using package
wins over any rule in the used package; this decision is made
before taking other factors such as import precedence and priority
into account.</p>
<p>A static error occurs if two modes with the same name are
visible within a package, either because they are both declared
within the package, or because one is declared within the package
and the other is acquired from a used package, or because both are
accepted from different used packages.</p>
<p>The rules for matching template rules by precedence and priority
operate as normal, with the addition that template rules declared
within an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
have higher precedence than any template rule declared in the used
package.</p>
<p>When a template rule specifies <code>mode="#all"</code> this is
interpreted as meaning all modes declared implicitly or explicitly
within the <a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a> of the <a href=
"#element-template"><code>xsl:template</code></a> element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If existing XSLT code has been written to use template rules in
the unnamed mode, a convenient way to incorporate this code into a
library package is to add a stub module that defines a new named
<code>public</code> or <code>final</code> mode, in which there is a
single template rule whose content is the single instruction
<code>&lt;xsl:apply-templates/&gt;</code>. This in effect redirects
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions using the named mode to the rules defined in the
unnamed mode.</p>
</div>
</div>
<div class="div3">
<h4><a name="package-local-declarations" id=
"package-local-declarations"></a>3.6.4 <a href=
"#package-local-declarations" style=
"text-decoration: none">Declarations Local to a Package</a></h4>
<p>Declarations of <a title="key" class="termref" href=
"#dt-key">keys</a>, <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal formats</a>, namespace aliases (see
<a href="#namespace-aliasing"><i>11.1.5 Namespace
Aliasing</i></a>), <a title="output definition" class="termref"
href="#dt-output-definition">output definitions</a>, and <a title=
"character map" class="termref" href="#dt-character-map">character
maps</a> within a package have local scope within that package —
they are all effectively private. The elements that declare these
constructs do not have a <code>visibility</code> attribute. The
unnamed decimal format and the unnamed output format are also local
to a package.</p>
<p>If <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations appear within a library package, they only affect
calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> functions
appearing within that package. Such a declaration within the main
package additionally affects stripping of whitespace in the
principal source document.</p>
<p>An <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration within a package applies only to calls on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> appearing
within that package.</p>
<p>An <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declarations within a package applies only to literal result
elements within the same package.</p>
<p>An <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration within a package adds the names of the imported schema
components to the static context for that package only; these names
are effectively private, in the sense that they do not become
available for use in any other packages. However, the names of
schema components must be consistent across the stylesheet as a
whole: it is not possible for two different packages within a
stylesheet to use a type-name such as "part-number" to refer to
different schema-defined simple or complex types.</p>
<p>Type names used in the interface of public components in a
package (for example, in the arguments of a function) must be
respected by callers of those components, in the sense that the
caller must supply values of the correct type. Often this will mean
that the using component, if it contains calls on such interfaces,
must itself import the necessary schema components. However, the
requirement for an explicit schema import applies only where the
package contains explicit use of the names of schema components
required to call such interfaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, suppose a library package contains a function which
requires an argument of type <code>mfg:part-number</code>. The
caller of this function must supply an argument of the correct
type, but does not need to import the schema unless it explicitly
uses the schema type name <code>mfg:part-number</code>. If it
obtains an instance of this type from outside the package, for
example as the result of another function call, then it can supply
this instance to the acquired function even though it has not
imported a schema that defines this type.</p>
</div>
<p>At execution time, the schema available for validating instance
documents contains (at least) the union of the schema components
imported into all constituent packages of the stylesheet.</p>
</div>
<div class="div3">
<h4><a name="xquery-packages" id="xquery-packages"></a>3.6.5
<a href="#xquery-packages" style="text-decoration: none">Using an
XQuery Library Package</a></h4>
<p><em>The capability described in this section is an optional
feature that processors are not <span class="verb">required</span>
to provide.</em></p>
<p>A processor <span class="verb">may</span> recognize the URI
supplied in the <code>name</code> attribute of an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element as
the module URI of an XQuery library module.</p>
<p>In this case all public functions and global variables declared
in the XQuery library module become available for use in the using
package as if they were declared as public functions or global
variables in an XSLT 3.0 package. XQuery external variables are
treated as if they were XSLT stylesheet parameters.</p>
<p>There are some minor differences in semantics between XSLT and
XQuery, for example XSLT uses the function conversion rules when
initializing a global variable (in XSLT, a node will be atomized if
the required type is atomic) whereas XQuery requires the computed
value to match the declared type precisely. The way in which such
differences are handled is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>; a
conformant implementation may use either the XQuery semantics or
the XSLT semantics.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether an
XQuery expression that is evaluated in the course of a
transformation is evaluated within the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> as the calling XSLT code.
(It if is, then, for example, calls to
<code>current-dateTime</code> will deliver the same result whether
called from the XSLT code or the XQuery code.)</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
node identity is preserved when calling XQuery code from XSLT
code.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Where the XSLT implementation invokes an XQuery processor
developed by a third party, it may be necessary to convert nodes to
a different internal representation as part of the calling
mechanism, and it may be difficult to do this conversion in a way
that retains node identity. It is required, however, that nodes
passed to the XQuery processor, or returned in the result, retain
all their relationships to other nodes in the same tree.
Furthermore, this specification provides no license to drop type
annotations.</p>
</div>
<p>As when using multiple XSLT packages, it is required that any
schema imported by the XQuery library module must be consistent
with the schema imported by the using package, and that any type
annotation on a node passed from one package to another must refer
unambiguously to the same type.</p>
<p>The effect of using an XQuery library module in which there are
functions that are updating or nondeterministic is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>Processors <span class="verb">may</span> impose additional
restrictions on the use of XQuery library modules; for example they
may treat variables and functions declared in the library module as
<code>final</code>, or they may require that the module uses a
particular version of XQuery.</p>
</div>
</div>
<div class="div2">
<h3><a name="stylesheet-modules" id="stylesheet-modules"></a>3.7
<a href="#stylesheet-modules" style=
"text-decoration: none">Stylesheet Modules</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-module" id="dt-stylesheet-module" title=
"stylesheet module"></a>A <span><a title="package" class="termref"
href="#dt-package">package</a></span> consists of one or more
<b>stylesheet modules</b>, each one forming all or part of an XML
document.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A stylesheet module is represented by an XDM element node (see
<a href="#xpath-datamodel-30">[Data Model]</a>). In the case of a
standard stylesheet module, this will be an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element. In the
case of a simplified stylesheet module, it can be any element (not
in the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>) that has an
<code>xsl:version</code> attribute.</p>
<p>Although stylesheet modules will commonly be maintained in the
form of documents conforming to XML 1.0 or XML 1.1, this
specification does not mandate such a representation. As with
<a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a>, the way in which stylesheet
modules are constructed, from textual XML or otherwise, is outside
the scope of this specification.</p>
</div>
<p>A stylesheet module is either a standard stylesheet module or a
simplified stylesheet module:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-stylesheet-module" id="dt-standard-stylesheet-module"
title="standard stylesheet module"></a>A <b>standard stylesheet
module</b> is a tree, or part of a tree, consisting of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element (see
<a href="#stylesheet-element"><i>3.8 Stylesheet Element</i></a>)
together with its descendant nodes and associated attributes and
namespaces.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-simplified-stylesheet-module" id=
"dt-simplified-stylesheet-module" title=
"simplified stylesheet module"></a>A <b>simplified stylesheet
module</b> is a tree, or part of a tree, consisting of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> together
with its descendant nodes and associated attributes and namespaces.
This element is not itself in the XSLT namespace, but it
<span class="verb">must</span> have an <code>xsl:version</code>
attribute, which implies that it <span class="verb">must</span>
have a namespace node that declares a binding for the XSLT
namespace. For further details see <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>. <span class="definition">]</span></p>
</li>
</ul>
<p>Both forms of stylesheet module (standard and simplified) can
exist either as an entire XML document, or embedded as part of
another XML document, typically but not necessarily a source
document that is to be processed using the stylesheet.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standalone-stylesheet-module" id=
"dt-standalone-stylesheet-module" title=
"standalone stylesheet module"></a>A <b>standalone stylesheet
module</b> is a stylesheet module that comprises the whole of an
XML document.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-embedded-stylesheet-module" id="dt-embedded-stylesheet-module"
title="embedded stylesheet module"></a>An <b>embedded stylesheet
module</b> is a stylesheet module that is embedded within another
XML document, typically the source document that is being
transformed.<span class="definition">]</span> (see <a href=
"#embedded"><i>3.13 Embedded Stylesheet Modules</i></a>).</p>
<p>There are thus four kinds of stylesheet module:</p>
<blockquote>
<p>standalone standard stylesheet modules<br />
standalone simplified stylesheet modules<br />
embedded standard stylesheet modules<br />
embedded simplified stylesheet modules</p>
</blockquote>
</div>
<div class="div2">
<h3><a name="stylesheet-element" id="stylesheet-element"></a>3.8
<a href="#stylesheet-element" style=
"text-decoration: none">Stylesheet Element</a></h3>
<p class="element-syntax"><a name="element-stylesheet" id=
"element-stylesheet"></a><code>&lt;xsl:stylesheet<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;version? = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*,
<var>other-declarations</var>) --&gt;<br />
&lt;/xsl:stylesheet&gt;</code></p>
<p class="element-syntax"><a name="element-transform" id=
"element-transform"></a><code>&lt;xsl:transform<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;version? = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*,
<var>other-declarations</var>) --&gt;<br />
&lt;/xsl:transform&gt;</code></p>
<p>A stylesheet module is represented by an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element in an
XML document. <a href=
"#element-transform"><code>xsl:transform</code></a> is allowed as a
synonym for <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>; everything
this specification says about the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
applies equally to <a href=
"#element-transform"><code>xsl:transform</code></a>.</p>
<p>The <code>version</code> attribute indicates the version of XSLT
that the stylesheet module requires. The attribute is <span class=
"verb">required</span>, unless the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element is a
child of an <a href="#element-package"><code>xsl:package</code></a>
element, in which case it is optional: the default is then taken
from the parent <a href=
"#element-package"><code>xsl:package</code></a> element.</p>
<p><a name="err-XTSE0110" id="err-XTSE0110"><span class=
"error">[ERR XTSE0110]</span></a> The value of the
<code>version</code> attribute if present <span class=
"verb">must</span> be a number: specifically, it <span class=
"verb">must</span> be a valid instance of the type
<code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>.</p>
<p>The <code>version</code> attribute is intended to indicate the
version of the XSLT specification against which the stylesheet is
written. In a stylesheet written to use XSLT 3.0, the value
<span class="verb">should</span> normally be set to
<code>3.0</code>. If the value is numerically less than
<code>3.0</code>, the stylesheet is processed using the rules for
<a title="backwards compatible behavior" class="termref" href=
"#dt-backwards-compatible-behavior">backwards compatible
behavior</a> (see <a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>). If the value is numerically greater than
<code>3.0</code>, the stylesheet is processed using the rules for
<a title="forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible behavior</a>
(see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>).</p>
<p>The effect of the <code>input-type-annotations</code> attribute
is described in <a href="#stripping-annotations"><i>4.3 Stripping
Type Annotations from a Source Tree</i></a>.</p>
<p>The <code>[xsl:]default-validation</code> attribute defines the
default value of the <code>validation</code> attribute of all
relevant instructions appearing within its scope. For details of
the effect of this attribute, see <a href="#validation"><i>24.2
Validation</i></a>.</p>
<p><a name="err-XTSE0120" id="err-XTSE0120"><span class=
"error">[ERR XTSE0120]</span></a> An <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
<span class="verb">must not</span> have any text node children.
(This rule applies after stripping of <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> as described
in <a href="#stylesheet-stripping"><i>4.2 Stripping Whitespace from
the Stylesheet</i></a>.)</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-top-level" id="dt-top-level" title="top-level"></a>An element
occurring as a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a><span>,
<a href="#element-transform"><code>xsl:transform</code></a>, or
<a href="#element-override"><code>xsl:override</code></a></span>
element is called a <b>top-level</b> element.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaration" id="dt-declaration" title=
"declaration"></a>Top-level elements fall into two categories:
declarations, and user-defined data elements. Top-level elements
whose names are in the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a> are
<b>declarations</b>. Top-level elements in any other namespace are
<a title="user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a> (see <a href=
"#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)<span class="definition">]</span>.</p>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> elements permitted in the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element are:</p>
<blockquote>
<p><a href=
"#element-use-package"><code>xsl:use-package</code></a><br />
<a href="#element-import"><code>xsl:import</code></a><br />
<a href="#element-include"><code>xsl:include</code></a><br />
<a href=
"#element-accumulator"><code>xsl:accumulator</code></a><br />
<a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a><br />
<a href=
"#element-character-map"><code>xsl:character-map</code></a><br />
<a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a><br />
<a href="#element-function"><code>xsl:function</code></a><br />
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a><br />
<a href="#element-key"><code>xsl:key</code></a><br />
<span><a href=
"#element-mode"><code>xsl:mode</code></a></span><br />
<a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a><br />

<a href="#element-output"><code>xsl:output</code></a><br />
<a href="#element-param"><code>xsl:param</code></a><br />
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a><br />
<a href=
"#element-strip-space"><code>xsl:strip-space</code></a><br />
<a href="#element-template"><code>xsl:template</code></a><br />
<a href="#element-variable"><code>xsl:variable</code></a></p>
</blockquote>
<p>Note that the <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> elements can act either
as <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> or as <a title="instruction"
class="termref" href="#dt-instruction">instructions</a>. A global
variable or parameter is defined using a declaration; a local
variable or parameter using an instruction.</p>
<p><span>If there are <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements,
these <span class="verb">must</span> come before any other
elements. If there are <a href=
"#element-import"><code>xsl:import</code></a> elements, these
<span class="verb">must</span> come after any <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements
but before any other elements.</span> Apart from this, the child
elements of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
appear in any order. <span>In most cases, the ordering of these
elements does not affect the results of the transformation;
however, as described in <a href="#conflict"><i>6.4 Conflict
Resolution for Template Rules</i></a>, when two template rules with
the same <a title="priority" class="termref" href=
"#dt-priority">priority</a> match the same nodes, there are
situations where the order of the template rules will affect which
is chosen.</span></p>
<p>For the meaning of the <a href=
"#element-use-package"><code>xsl:use-package</code></a> element,
see <a href="#packages"><i>3.6 Packages</i></a>.</p>
<div class="div3">
<h4><a name="default-collation-attribute" id=
"default-collation-attribute"></a>3.8.1 <a href=
"#default-collation-attribute" style=
"text-decoration: none">The</a> <code>default-collation</code>
<a href="#default-collation-attribute" style=
"text-decoration: none">Attribute</a></h4>
<p>The <code>default-collation</code> attribute is a <a title=
"standard attributes" class="termref" href=
"#dt-standard-attributes">standard attribute</a> that may appear on
any element in the XSLT namespace, or (as
<code>xsl:default-collation</code>) on a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
<p>The attribute, <span>when it appears on an element <var>E</var>,
is used to specify the default collation used by all XPath
expressions appearing in attributes or <a title=
"text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> that have
<var>E</var> as an ancestor</span>, unless overridden by another
<code>default-collation</code> attribute on an inner element. It
also determines the collation used by certain XSLT constructs (such
as <a href="#element-key"><code>xsl:key</code></a> and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>)
within its scope.</p>
<p>The value of the attribute is a whitespace-separated list of
collation URIs. If any of these URIs is a relative URI
<span>reference</span>, then it is resolved relative to the base
URI of the attribute's parent element. If the implementation
recognizes one or more of the resulting absolute collation URIs,
then it uses the first one that it recognizes as the default
collation.</p>
<p><a name="err-XTSE0125" id="err-XTSE0125"><span class=
"error">[ERR XTSE0125]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of an <code>[xsl:]default-collation</code> attribute, after
resolving against the base URI, contains no URI that the
implementation recognizes as a collation URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason the attribute allows a list of collation URIs is that
collation URIs will often be meaningful only to one particular XSLT
implementation. Stylesheets designed to run with several different
implementations can therefore specify several different collation
URIs, one for use with each. To avoid the above error condition, it
is possible to include as the last collation URI in the list either
the Unicode Codepoint Collation <span>or a collation in the UCA
family (see <a href="#uca-collations"><i>13.4 The Unicode Collation
Algorithm</i></a>) with the parameter
<code>fallback=yes</code></span>.</p>
</div>
<p>The <code>[xsl:]default-collation</code> attribute does not
affect the collation used by <code>xsl:sort</code>.</p>
<p>In the absence of an <code>[xsl:]default-collation</code>
attribute, the default collation <span class="verb">may</span> be
set by the calling application in an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. The
recommended default, unless the user chooses otherwise, is to use
the Unicode codepoint collation.</p>
</div>
<div class="div3">
<h4><a name="default-mode" id="default-mode"></a>3.8.2 <a href=
"#default-mode" style="text-decoration: none">The</a>
<code>[xsl:]default-mode</code> <a href="#default-mode" style=
"text-decoration: none">Attribute</a></h4>
<p>The <code>default-mode</code> attribute defines the default
value for the <a title="mode" class="termref" href=
"#dt-mode">mode</a> attribute of all <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
elements <span>within its scope</span>. <span>When the
<code>mode</code> attribute of these elements is omitted, or when
it contains the value <code>#default</code>, then the mode is taken
from the <code>[xsl:]default-mode</code> attribute of the innermost
ancestor element that has such an attribute. If there is no such
element, then the default is the <a title="unnamed mode" class=
"termref" href="#dt-unnamed-mode">unnamed mode</a>. This is
equivalent to specifying <code>#unnamed</code>.</span></p>
<p>The value <span class="verb">must</span> either be <span>an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, or the token <code>#unnamed</code>
which refers to the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>. It is not necessary for the
referenced mode to be explicitly declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This attribute is provided to support an approach to stylesheet
modularity in which all the template rules for one <a title="mode"
class="termref" href="#dt-mode">mode</a> are collected together
into a single <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>. Using this attribute
reduces the risk of forgetting to specify the mode in one or more
places where it is needed, and it also makes it easier to reuse an
existing stylesheet module that does not use modes in an
application where modes are needed to avoid conflicts with existing
template rules.</p>
</div>
</div>
<div class="div3">
<h4><a name="user-defined-top-level" id=
"user-defined-top-level"></a>3.8.3 <a href=
"#user-defined-top-level" style=
"text-decoration: none">User-defined Data Elements</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-data-element" id="dt-data-element" title=
"user-defined data element"></a>In addition to <a title=
"declaration" class="termref" href=
"#dt-declaration">declarations</a>, the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
contain among its children any element not from the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, provided that the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
element has a non-null namespace URI. Such elements are referred to
as <b>user-defined data elements</b>.<span class=
"definition">]</span></p>
<p><a name="err-XTSE0130" id="err-XTSE0130"><span class=
"error">[ERR XTSE0130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element has a child element whose name has a null namespace
URI.</p>
<p>An implementation <span class="verb">may</span> attach an
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> meaning to
user-defined data elements that appear in particular namespaces.
The set of namespaces that are recognized for such data elements is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
presence of a user-defined data element <span class="verb">must
not</span> change the behavior of <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT elements</a> and functions
defined in this document; for example, it is not permitted for a
user-defined data element to specify that <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
should use different rules to resolve conflicts. The constraints on
what user-defined data elements can and cannot do are exactly the
same as the constraints on <a title="extension attribute" class=
"termref" href="#dt-extension-attribute">extension attributes</a>,
described in <a href="#extension-attributes"><i>3.3 Extension
Attributes</i></a>. Thus, an implementation is always free to
ignore user-defined data elements, and <span class=
"verb">must</span> ignore such data elements without giving an
error if it does not recognize the namespace URI.</p>
<p>User-defined data elements can provide, for example,</p>
<ul>
<li>
<p>information used by <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a> (see <a href=
"#extension"><i>23 Extensibility and Fallback</i></a>),</p>
</li>
<li>
<p>information about what to do with any <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>,</p>
</li>
<li>
<p>information about how to construct <a title="source tree" class=
"termref" href="#dt-source-tree">source trees</a>,</p>
</li>
<li>
<p>optimization hints for the <a title="processor" class="termref"
href="#dt-processor">processor</a>,</p>
</li>
<li>
<p>metadata about the stylesheet,</p>
</li>
<li>
<p>structured documentation for the stylesheet.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="simplified-stylesheet" id=
"simplified-stylesheet"></a>3.9 <a href="#simplified-stylesheet"
style="text-decoration: none">Simplified Stylesheet
Modules</a></h3>
<p>A simplified syntax is allowed for a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that defines only a
single template rule for the document node. The stylesheet module
may consist of just a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a> (see <a href="#literal-result-element"><i>11.1 Literal
Result Elements</i></a>) together with its contents. The literal
result element must have an <code>xsl:version</code> attribute (and
it must therefore also declare the XSLT namespace). Such a
stylesheet module is equivalent to a standard stylesheet module
whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element contains a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> containing the literal result
element, minus its <code>xsl:version</code> attribute; the template
rule has a match <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> of <code>/</code>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e8143" id=
"d7e8143"></a>Example: A Simplified Stylesheet</div>
<p>For example:</p>
<div class="exampleInner">
<pre>
&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre></div>
<p>has the same meaning as</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
<p>Note that it is not possible, using a simplified stylesheet, to
request that the serialized output contains a <code>DOCTYPE</code>
declaration. This can only be done by using a standard stylesheet
module, and using the <a href=
"#element-output"><code>xsl:output</code></a> element.</p>
</div>
<p>More formally, a simplified stylesheet module is equivalent to
the standard stylesheet module that would be generated by applying
the following transformation to the simplified stylesheet module,
invoking the transformation by calling the <a title=
"named template" class="termref" href="#dt-named-template">named
template</a> <code>expand</code>, with the containing literal
result element as the <a title="context node" class="termref" href=
"#dt-context-node">context node</a>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</pre></div>
<p><a name="err-XTSE0150" id="err-XTSE0150"><span class=
"error">[ERR XTSE0150]</span></a> A <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> that is
used as the outermost element of a simplified stylesheet module
<span class="verb">must</span> have an <code>xsl:version</code>
attribute. This indicates the version of XSLT that the stylesheet
requires. For this version of XSLT, the value will normally be
<code><span>3.0</span></code> ; the value <span class=
"verb">must</span> be a valid instance of the type
<code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>.</p>
<p>The allowed content of a literal result element when used as a
simplified stylesheet is the same as when it occurs within a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. Thus, a
literal result element used as the document element of a simplified
stylesheet cannot contain <a title="declaration" class="termref"
href="#dt-declaration">declarations</a>. Simplified stylesheets
therefore cannot use <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>, <a title="global variable"
class="termref" href="#dt-global-variable">global variables</a>,
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, <a title="key"
class="termref" href="#dt-key">keys</a>, <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute-sets</a>, or
<a title="output definition" class="termref" href=
"#dt-output-definition">output definitions</a>. In turn this means
that the only useful way to initiate the transformation is to
supply a document node as the <span><a title="initial context item"
class="termref" href="#dt-initial-context-item">initial context
item</a></span>, to be matched by the implicit
<code>match="/"</code> template rule using the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a>.</p>
</div>
<div class="div2">
<h3><a name="backwards" id="backwards"></a>3.10 <a href=
"#backwards" style="text-decoration: none">Backwards Compatible
Processing</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-effective-version" id="dt-effective-version" title=
"effective version"></a>The <b>effective version</b> of an element
in a <span><a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title=
"package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span> is the decimal
value of the <code>[xsl:]version</code> attribute (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>) on that
element or on the innermost ancestor element that has such an
attribute, excluding the <code>version</code> attribute on an
<a href="#element-output"><code>xsl:output</code></a>
element.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-backwards-compatible-behavior" id=
"dt-backwards-compatible-behavior" title=
"backwards compatible behavior"></a>An element is processed with
<b>backwards compatible behavior</b> if its <a title=
"effective version" class="termref" href=
"#dt-effective-version">effective version</a> is less than
<code>3.0</code>.<span class="definition">]</span></p>
<p>Specifically:</p>
<ul>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 1.0, then
the element is processed with XSLT 1.0 behavior as described in
<a href="#backwards-1.0"><i>3.10.1 XSLT 1.0 Compatibility
Mode</i></a>.</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 2.0, then
the element is processed with XSLT 2.0 behavior as described in
<a href="#backwards-2.0"><i>3.10.2 XSLT 2.0 Compatibility
Mode</i></a>.</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is any other value
less than 3.0, the <span class="verb">recommended</span> action is
to report a static error; however, processors <span class=
"verb">may</span> recognize such values and process the element in
an <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XSLT 1.0 allowed the <code>version</code> attribute to take any
decimal value, and invoked forwards compatible processing for any
value other than 1.0. XSLT 2.0 allowed the attribute to take any
decimal value, and invoked backwards compatible (i.e.
1.0-compatible) processing for any value less than 2.0. Some
stylesheets may therefore be encountered that use values other than
1.0 or 2.0. In particular, the value 1.1 is sometimes encountered,
as it was used at one stage in a draft language proposal.</p>
</div>
</li>
</ul>
<p>These rules do not apply to the <a href=
"#element-output"><code>xsl:output</code></a> element, whose
<code>version</code> attribute has an entirely different purpose:
it is used to define the version of the output method to be used
for serialization.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether a
particular XSLT 3.0 implementation supports backwards compatible
behavior for any XSLT version earlier than XSLT 3.0.</p>
<p><a name="err-XTDE0160" id="err-XTDE0160"><span class=
"error">[ERR XTDE0160]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
element has an <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of <var>V</var> (with
<var>V</var> &lt; 3.0) when the implementation does not support
backwards compatible behavior for XSLT version <var>V</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>By making use of backwards compatible behavior, it is possible
to write the stylesheet in a way that ensures that its results when
processed with an XSLT 3.0 processor are identical to the effects
of processing the same stylesheet using <span>a processor for an
earlier version of XSLT</span>. To assist with transition, some
parts of a stylesheet may be processed with backwards compatible
behavior enabled, and other parts with this behavior disabled.</p>
<p>All data values manipulated by an <span>XSLT 3.0</span>
processor are defined by the XDM data model, whether or not the
relevant expressions use backwards compatible behavior. Because the
same data model is used in both cases, expressions are fully
composable. The result of evaluating instructions or expressions
with backwards compatible behavior is fully defined in the
<span>XSLT 3.0</span> and <span>XPath 3.0</span> specifications, it
is not defined by reference to <span>earlier versions of the XSLT
and XPath specifications</span>.</p>
<p>To write a stylesheet that makes use of <span>features that are
new in version <var>N</var>, while also working with a processor
that only supports XSLT version <var>M</var> (<var>M</var> &lt;
<var>N</var>)</span>, it is necessary to understand both the rules
for backwards compatible behavior in <span>XSLT version
<var>N</var></span>, and the rules for forwards compatible behavior
in <span>XSLT version <var>M</var></span>. If the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
specifies <code>version="2.0"</code> <span>or
<code>version="3.0"</code></span>, then an XSLT 1.0 processor will
ignore XSLT 2.0 <span>and XSLT 3.0</span> <a title="declaration"
class="termref" href="#dt-declaration">declarations</a> that were
not defined in XSLT 1.0, for example <a href=
"#element-function"><code>xsl:function</code></a> and <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>. If any
new <span>XSLT 3.0</span> instructions are used (for example
<a href="#element-evaluate"><code>xsl:evaluate</code></a> or
<a href="#element-stream"><code>xsl:stream</code></a>), or if new
<span>XPath 3.0</span> features are used (for example, new
functions, or <span>let</span> expressions), then the stylesheet
must provide fallback behavior that relies only on facilities
<span>available in the earliest XSLT version supported</span>. The
fallback behavior can be invoked by using the <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction, or
by testing the results of the <a href=
"#func-function-available"><code>function-available</code></a> or
<a href=
"#func-element-available"><code>element-available</code></a>
functions, or by testing the value of the <code>xsl:version</code>
property returned by the <a href=
"#func-system-property"><code>system-property</code></a>
function.</p>
</div>
<div class="div3">
<h4><a name="backwards-1.0" id="backwards-1.0"></a>3.10.1 <a href=
"#backwards-1.0" style="text-decoration: none">XSLT 1.0
Compatibility Mode</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-10-behavior" id="dt-xslt-10-behavior" title=
"XSLT 1.0 behavior"></a>An element in the stylesheet is processed
with <b>XSLT 1.0 behavior</b> if its <a title="effective version"
class="termref" href="#dt-effective-version">effective version</a>
is equal to 1.0.<span class="definition">]</span></p>
<p>In this mode, if any attribute contains an XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>,
then the expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
<code>true</code>. For details of this mode, see <a href=
"http://www.w3.org/TR/xpath-30/#static_context">Section 2.1.1
Static Context</a> <sup><small>XP30</small></sup>.
<span>Expressions contained in <a title="text value template"
class="termref" href="#dt-text-value-template">text value
templates</a> are always evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
<code>false</code>, since this construct was not available in XSLT
1.0.</span></p>
<p>Furthermore, in such an expression any function call for which
no implementation is available (unless it uses the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>)
is bound to a fallback error function whose effect when evaluated
is to raise a dynamic error <span class="error">[see <a href=
"#err-XTDE1425">ERR XTDE1425</a>]</span> . The effect is that with
backwards compatible behavior enabled, calls on <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> that are not
available in a particular implementation do not cause an error
unless the function call is actually evaluated. For further
details, see <a href="#extension-functions"><i>23.1 Extension
Functions</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This might appear to contradict the specification of XPath
<span>3.0</span>, which states that a static error [XPST0017] is
raised when an expression contains a call to a function that is not
present (with matching name and arity) in the static context. This
apparent contradiction is resolved by specifying that the XSLT
processor constructs a static context for the expression in which
every possible function name and arity (other than names in the
<a title="standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>)
is present; when no other implementation of the function is
available, the function call is bound to a fallback error function
whose run-time effect is to raise a dynamic error.</p>
</div>
<p>Certain XSLT constructs also produce different results when XSLT
1.0 compatibility mode is enabled. This is described separately for
each such construct.</p>
</div>
<div class="div3">
<h4><a name="backwards-2.0" id="backwards-2.0"></a>3.10.2 <a href=
"#backwards-2.0" style="text-decoration: none">XSLT 2.0
Compatibility Mode</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-20-behavior" id="dt-xslt-20-behavior" title=
"XSLT 2.0 behavior"></a>An element is processed with <b>XSLT 2.0
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is equal to
2.0.<span class="definition">]</span></p>
<p>In this specification, no differences are defined for XSLT 2.0
behavior. An XSLT 3.0 processor will therefore produce the same
results whether the <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> of an element is
set to 2.0 or 3.0.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An XSLT 2.0 processor, by contrast, will in some cases produce
different results in the two cases. For example, if the stylesheet
contains an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction with an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, an XSLT
3.0 processor will process the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction
regardless whether the effective version is 2.0 or 3.0, while an
XSLT 2.0 processor will report a static error if the effective
version is 2.0, and will take the fallback action if the effective
version is 3.0.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="forwards" id="forwards"></a>3.11 <a href="#forwards"
style="text-decoration: none">Forwards Compatible
Processing</a></h3>
<p>The intent of forwards compatible behavior is to make it
possible to write a stylesheet that takes advantage of features
introduced in some version of XSLT subsequent to <span>XSLT
3.0</span>, while retaining the ability to execute the stylesheet
with an <span>XSLT 3.0</span> processor using appropriate fallback
behavior.</p>
<p>It is always possible to write conditional code to run under
different XSLT versions by using the <code>use-when</code> feature
described in <a href="#conditional-inclusion"><i>3.14 Conditional
Element Inclusion</i></a>. The rules for forwards compatible
behavior supplement this mechanism in two ways:</p>
<ul>
<li>
<p>certain constructs in the stylesheet that mean nothing to an
<span>XSLT 3.0</span> processor are ignored, rather than being
treated as errors.</p>
</li>
<li>
<p>explicit fallback behavior can be defined for instructions
defined in a future XSLT release, using the <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction.</p>
</li>
</ul>
<p>The detailed rules follow.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-forwards-compatible-behavior" id=
"dt-forwards-compatible-behavior" title=
"forwards compatible behavior"></a>An element is processed with
<b>forwards compatible behavior</b> if its <a title=
"effective version" class="termref" href=
"#dt-effective-version">effective version</a> is greater than
<code>3.0</code>.<span class="definition">]</span></p>
<p>These rules do not apply to the <code>version</code> attribute
of the <a href="#element-output"><code>xsl:output</code></a>
element, which has an entirely different purpose: it is used to
define the version of the output method to be used for
serialization.</p>
<p>When an element is processed with forwards compatible
behavior:</p>
<ul>
<li>
<p>if the element is in the XSLT namespace and appears as a child
of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, and
XSLT <span>3.0</span> does not allow the element to appear as a
child of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, then
the element and its content <span class="verb">must</span> be
ignored.</p>
</li>
<li>
<p>if the element has an attribute that XSLT <span>3.0</span> does
not allow the element to have, then the attribute <span class=
"verb">must</span> be ignored.</p>
</li>
<li>
<p>if the element is in the XSLT namespace and appears as part of a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and XSLT
<span>3.0</span> does not allow such elements to appear as part of
a sequence constructor, then:</p>
<ol class="enumar">
<li>
<p>If the element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then no
error is reported either statically or dynamically, and the result
of evaluating the instruction is the concatenation of the sequences
formed by evaluating the sequence constructors within its <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, in
document order. Siblings of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements are
ignored, even if they are valid XSLT <span>3.0</span>
instructions.</p>
</li>
<li>
<p>If the element has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then a
static error is reported in the same way as if forwards compatible
behavior were not enabled.</p>
</li>
</ol>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e8733" id=
"d7e8733"></a>Example: Forwards Compatible Behavior</div>
<p>For example, an XSLT <span>3.0</span> <a title="processor"
class="termref" href="#dt-processor">processor</a> will process the
following stylesheet without error, although the stylesheet
includes elements from the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a> that are not
defined in this specification:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a stylesheet depends crucially on a <a title="declaration"
class="termref" href="#dt-declaration">declaration</a> introduced
by a version of XSLT after <span>3.0</span>, then the stylesheet
can use an <a href="#element-message"><code>xsl:message</code></a>
element with <code>terminate="yes"</code> (see <a href=
"#message"><i>22.1 Messages</i></a>) to ensure that implementations
that conform to an earlier version of XSLT will not silently ignore
the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e8771" id=
"d7e8771"></a>Example: Testing the XSLT Version</div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
introduction of the <a href=
"#element-package"><code>xsl:package</code></a> element. An XSLT
1.0 or 2.0 processor encountering this element will report a static
error, regardless of the <code>version</code> setting.</p>
<p>This problem can be circumvented by using the simplified package
syntax (whereby <a href=
"#element-use-package"><code>xsl:use-package</code></a> appears as
a child of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, or by
writing the stylesheet code in a separate module from the package
manifest, and using the separate module as the version of the
stylesheet that is presented to a 2.0 processor.</p>
</div>
</div>
<div class="div2">
<h3><a name="combining-modules" id="combining-modules"></a>3.12
<a href="#combining-modules" style=
"text-decoration: none">Combining Stylesheet Modules</a></h3>
<p>XSLT provides two mechanisms to construct a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
from multiple <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a>:</p>
<ul>
<li>
<p>an inclusion mechanism that allows stylesheet modules to be
combined without changing the semantics of the modules being
combined, and</p>
</li>
<li>
<p>an import mechanism that allows stylesheet modules to override
each other.</p>
</li>
</ul>
<div class="div3">
<h4><a name="locating-modules" id="locating-modules"></a>3.12.1
<a href="#locating-modules" style="text-decoration: none">Locating
Stylesheet Modules</a></h4>
<p>The include and import mechanisms use two declarations, <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a>, which are defined in
the sections that follow.</p>
<p>These declarations use an <code>href</code> attribute, whose
value is a <a title="URI Reference" class="termref" href=
"#dt-uri-reference">URI reference</a>, to identify the <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> to be included or
imported. If the value of this attribute is a relative URI
<span>reference</span>, it is resolved as described in <a href=
"#uri-references"><i>5.9 URI References</i></a>.</p>
<p>After resolving against the base URI, the way in which the URI
reference is used to locate a representation of a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>, and the way in which
the stylesheet module is constructed from that representation, are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. In
particular, it is implementation-defined which URI schemes are
supported, whether fragment identifiers are supported, and what
media types are supported. Conventionally, the URI is a reference
to a resource containing the stylesheet module as a source XML
document, or it may include a fragment identifier that selects an
embedded stylesheet module within a source XML document; but the
implementation is free to use other mechanisms to locate the
stylesheet module identified by the URI reference.</p>
<p>The referenced <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a> may be any of
the four kinds of stylesheet module: that is, it may be <a title=
"standalone stylesheet module" class="termref" href=
"#dt-standalone-stylesheet-module">standalone</a> or <a title=
"embedded stylesheet module" class="termref" href=
"#dt-embedded-stylesheet-module">embedded</a>, and it may be
<a title="standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard</a> or <a title=
"simplified stylesheet module" class="termref" href=
"#dt-simplified-stylesheet-module">simplified</a>. If it is a
<a title="simplified stylesheet module" class="termref" href=
"#dt-simplified-stylesheet-module">simplified stylesheet module</a>
then it is transformed into the equivalent <a title=
"standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard stylesheet module</a> by
applying the transformation described in <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>.</p>
<p>Implementations <span class="verb">may</span> choose to accept
URI references containing a fragment identifier defined by
reference to the XPointer specification (see <a href=
"#xptr-framework">[XPointer Framework]</a>). Note that if the
implementation does not support the use of fragment identifiers in
the URI reference, then it will not be possible to include an
<a title="embedded stylesheet module" class="termref" href=
"#dt-embedded-stylesheet-module">embedded stylesheet
module</a>.</p>
<p><a name="err-XTSE0165" id="err-XTSE0165"><span class=
"error">[ERR XTSE0165]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
processor is not able to retrieve the resource identified by the
URI reference, or if the resource that is retrieved does not
contain a stylesheet module.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is appropriate to use this error code when the resource
cannot be retrieved, or when the retrieved resource is not well
formed XML. If the resource contains XML than can be parsed but
that violates the rules for stylesheet modules, then a more
specific error code may be more appropriate.</p>
</div>
</div>
<div class="div3">
<h4><a name="include" id="include"></a>3.12.2 <a href="#include"
style="text-decoration: none">Stylesheet Inclusion</a></h4>
<p class="element-syntax"><a name="element-include" id=
"element-include"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:include<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p>A stylesheet module may include another stylesheet module using
an <a href="#element-include"><code>xsl:include</code></a>
declaration.</p>
<p>The <a href="#element-include"><code>xsl:include</code></a>
declaration has a <span class="verb">required</span>
<code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included. This attribute is
used as described in <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>.</p>
<p><a name="err-XTSE0170" id="err-XTSE0170"><span class=
"error">[ERR XTSE0170]</span></a> An <a href=
"#element-include"><code>xsl:include</code></a> element
<span class="verb">must</span> be a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-level" id="dt-stylesheet-level" title=
"stylesheet level"></a>A <b>stylesheet level</b> is a collection of
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> connected using
<a href="#element-include"><code>xsl:include</code></a>
declarations: specifically, two stylesheet modules <var>A</var> and
<var>B</var> are part of the same stylesheet level if one of them
includes the other by means of an <a href=
"#element-include"><code>xsl:include</code></a> declaration, or if
there is a third stylesheet module <var>C</var> that is in the same
stylesheet level as both <var>A</var> and <var>B</var>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaration-order" id="dt-declaration-order" title=
"declaration order"></a>The <a title="declaration" class="termref"
href="#dt-declaration">declarations</a> within a <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> have a total ordering
known as <b>declaration order</b>. The order of declarations within
a stylesheet level is the same as the document order that would
result if each stylesheet module were inserted textually in place
of the <a href="#element-include"><code>xsl:include</code></a>
element that references it.<span class="definition">]</span> In
other respects, however, the effect of <a href=
"#element-include"><code>xsl:include</code></a> is not equivalent
to the effect that would be obtained by textual inclusion.</p>
<p><a name="err-XTSE0180" id="err-XTSE0180"><span class=
"error">[ERR XTSE0180]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
stylesheet module directly or indirectly includes itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not intrinsically an error for a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> to include the
same module more than once. However, doing so can cause errors
because of duplicate definitions. Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet
<var>C</var> includes stylesheet <var>A</var>, and stylesheet
<var>D</var> includes both stylesheet <var>B</var> and stylesheet
<var>C</var>, then <var>A</var> will be included indirectly by
<var>D</var> twice. If all of <var>B</var>, <var>C</var> and
<var>D</var> are used as independent stylesheets, then the error
can be avoided by separating everything in <var>B</var> other than
the inclusion of <var>A</var> into a separate stylesheet
<var>B'</var> and changing <var>B</var> to contain just inclusions
of <var>B'</var> and <var>A</var>, similarly for <var>C</var>, and
then changing <var>D</var> to include <var>A</var>, <var>B'</var>,
<var>C'</var>.</p>
</div>
</div>
<div class="div3">
<h4><a name="import" id="import"></a>3.12.3 <a href="#import"
style="text-decoration: none">Stylesheet Import</a></h4>
<p class="element-syntax"><a name="element-import" id=
"element-import"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:import<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p>A stylesheet module may import another <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> using an <a href=
"#element-import"><code>xsl:import</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>. Importing a stylesheet module is
the same as including it (see <a href="#include"><i>3.12.2
Stylesheet Inclusion</i></a>) except that <a title="template rule"
class="termref" href="#dt-template-rule">template rules</a> and
other <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> in the importing module take
precedence over template rules and declarations in the imported
module; this is described in more detail below.</p>
<p>The <a href="#element-import"><code>xsl:import</code></a>
declaration has a <span class="verb">required</span>
<code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included. This attribute is
used as described in <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>.</p>
<p><a name="err-XTSE0190" id="err-XTSE0190"><span class=
"error">[ERR XTSE0190]</span></a> An <a href=
"#element-import"><code>xsl:import</code></a> element <span class=
"verb">must</span> be a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e9187" id=
"d7e9187"></a>Example: Using <a href=
"#element-import"><code>xsl:import</code></a></div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-import-tree" id="dt-import-tree" title="import tree"></a>The
<a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> making up a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
are treated as forming an <b>import tree</b>. In the import tree,
each stylesheet level has one child for each <a href=
"#element-import"><code>xsl:import</code></a> declaration that it
contains.<span class="definition">]</span> The ordering of the
children is the <a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> of the <a href=
"#element-import"><code>xsl:import</code></a> declarations within
their stylesheet level.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-import-precedence" id="dt-import-precedence" title=
"import precedence"></a>A <a title="declaration" class="termref"
href="#dt-declaration">declaration</a> <var>D</var> in the
stylesheet is defined to have lower <b>import precedence</b> than
another declaration <var>E</var> if the stylesheet level containing
<var>D</var> would be visited before the stylesheet level
containing <var>E</var> in a post-order traversal of the import
tree (that is, a traversal of the import tree in which a stylesheet
level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.<span class=
"definition">]</span></p>
<p>For example, suppose</p>
<ul>
<li>
<p>stylesheet module <var>A</var> imports stylesheet modules
<var>B</var> and <var>C</var> in that order;</p>
</li>
<li>
<p>stylesheet module <var>B</var> imports stylesheet module
<var>D</var>;</p>
</li>
<li>
<p>stylesheet module <var>C</var> imports stylesheet module
<var>E</var>.</p>
</li>
</ul>
<p>Then the import tree has the following structure:</p>
<object type="image/svg+xml" codetype="image/svg+xml" data=
"img/fig1.svg" width="274" height="130"><span style=
"background-color:#FFFF20;padding-top:1pt;padding-bottom:1pt;">This
browser can't display the SVG file img/fig1.svg. Please upgrade
your browser or install the Adobe SVG Viewer.</span></object>
<p><em>Here you should see a diagram. If it does not appear
correctly in your browser, you need to install an SVG
Plugin.</em></p>
<p>The order of import precedence (lowest first) is <var>D</var>,
<var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p>
<p>In general, a <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> with higher import precedence
takes precedence over a declaration with lower import precedence.
This is defined in detail for each kind of declaration.</p>
<p><a name="err-XTSE0210" id="err-XTSE0210"><span class=
"error">[ERR XTSE0210]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
stylesheet module directly or indirectly imports itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The case where a stylesheet module with a particular URI is
imported several times is not treated specially. The effect is
exactly the same as if several stylesheet modules with different
URIs but identical content were imported. This might or might not
cause an error, depending on the content of the stylesheet
module.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="embedded" id="embedded"></a>3.13 <a href="#embedded"
style="text-decoration: none">Embedded Stylesheet Modules</a></h3>
<p>An <a title="embedded stylesheet module" class="termref" href=
"#dt-embedded-stylesheet-module">embedded stylesheet module</a> is
a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> whose containing
element is not the outermost element of the containing XML
document. Both <a title="standard stylesheet module" class=
"termref" href="#dt-standard-stylesheet-module">standard stylesheet
modules</a> and <a title="simplified stylesheet module" class=
"termref" href="#dt-simplified-stylesheet-module">simplified
stylesheet modules</a> may be embedded in this way.</p>
<p>Two situations where embedded stylesheets may be useful are:</p>
<ul>
<li>
<p>The stylesheet may be embedded in the source document to be
transformed.</p>
</li>
<li>
<p>The stylesheet may be embedded in an XML document that describes
a sequence of processing of which the XSLT transformation forms
just one part.</p>
</li>
</ul>
<p>The <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
<span class="verb">may</span> have an <code>id</code> attribute to
facilitate reference to the stylesheet module within the containing
document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In order for such an attribute value to be used as a fragment
identifier in a URI, the XDM attribute node must generally have the
<code>is-id</code> property: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-is-id">Section 5.5
is-id Accessor</a> <sup><small>DM30</small></sup>. This property
will typically be set if the attribute is defined in a DTD as being
of type <code>ID</code>, or if is defined in a schema as being of
type <code>xs:ID</code>. It is also necessary that the media type
of the containing document should support the use of ID values as
fragment identifiers. <span>Such support is widespread in existing
products, and is endorsed in respect of the media type
<code>application/xml</code> by <a href="#xptr-framework">[XPointer
Framework]</a></span>.</p>
<p>An alternative, if the implementation supports it, is to use an
<code>xml:id</code> attribute. XSLT allows this attribute (like
other namespaced attributes) to appear on any <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e9396" id=
"d7e9396"></a>Example: The <code>xml-stylesheet</code> Processing
Instruction</div>
<p>The following example shows how the <code>xml-stylesheet</code>
processing instruction (see <a href="#xml-stylesheet">[XML
Stylesheet]</a>) can be used to allow a source document to contain
its own stylesheet. The URI reference uses a fragment identifier to
locate the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element:</p>
<div class="exampleInner">
<pre>
&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A stylesheet module that is embedded in the document to which it
is to be applied typically needs to contain a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> that specifies that <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> elements are
to be ignored.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above example uses the pseudo-attribute
<code>type="application/xslt+xml"</code> in the
<code>xml-stylesheet</code> processing instruction to denote an
XSLT stylesheet. This is the officially registered media type for
XSLT: see <a href="#xslt-media-type"><i>3.4 XSLT Media
Type</i></a>. However, browsers developed before this media type
was registered are more likely to accept the unofficial designation
<code>type="text/xsl"</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Support for the <code>xml-stylesheet</code> processing
instruction is not required for conformance with this
Recommendation. Implementations are not constrained in the
mechanisms they use to identify a stylesheet when a transformation
is initiated: see <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="conditional-inclusion" id=
"conditional-inclusion"></a>3.14 <a href="#conditional-inclusion"
style="text-decoration: none">Conditional Element
Inclusion</a></h3>
<p>Any element in the XSLT namespace may have a
<code>use-when</code> attribute whose value is an XPath expression
that can be evaluated statically. If the attribute is present and
the <a href="http://www.w3.org/TR/xpath-30/#dt-ebv">effective
boolean value</a><sup><small>XP30</small></sup> of the expression
is false, then the element, together with all the nodes having that
element as an ancestor, is effectively excluded from the <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>. When a node is
effectively excluded from a stylesheet module the stylesheet module
has the same effect as if the node were not there. Among other
things this means that no static or dynamic errors will be reported
in respect of the element and its contents, other than errors in
the <code>use-when</code> attribute itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This does not apply to XML parsing or validation errors, which
will be reported in the usual way. It also does not apply to
attributes that are necessarily processed before
<code>[xsl:]use-when</code>, examples being <code>xml:space</code>
and <code>[xsl:]xpath-default-namespace</code>.</p>
</div>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or any
other element within a <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a> that is not in
the XSLT namespace, may similarly carry an
<code>xsl:use-when</code> attribute.</p>
<p>If the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element itself
is effectively excluded, the effect is to exclude all the children
of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element, but
not the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element or its
attributes.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This allows all the declarations that depend on the same
condition to be included in one stylesheet module, and for their
inclusion or exclusion to be controlled by a single
<code>use-when</code> attribute at the level of the module.</p>
</div>
<p>Conditional element exclusion happens after stripping of
whitespace text nodes from the stylesheet, as described in <a href=
"#stylesheet-stripping"><i>4.2 Stripping Whitespace from the
Stylesheet</i></a>.</p>
<p>The XPath expression used as the value of the
<code>xsl:use-when</code> attribute follows the rules for <a title=
"static expression" class="termref" href=
"#dt-static-expression">static expressions</a>.</p>
<p>The use of <code>[xsl:]use-when</code> is illustrated in the
following examples.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e9532" id=
"d7e9532"></a>Example: Using Conditional Exclusion to Achieve
Portability</div>
<p>This example demonstrates the use of the <code>use-when</code>
attribute to achieve portability of a stylesheet across
schema-aware and non-schema-aware processors.</p>
<div class="exampleInner">
<pre>
&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The effect of these declarations is that a non-schema-aware
processor ignores the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration and the first template rule, and therefore generates no
errors in respect of the schema-related constructs in these
declarations.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e9547" id=
"d7e9547"></a>Example: Including Variant Stylesheet Modules</div>
<p>This example includes different stylesheet modules depending on
which XSLT processor is in use.</p>
<div class="exampleInner">
<pre>
&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="built-in-types" id="built-in-types"></a>3.15 <a href=
"#built-in-types" style="text-decoration: none">Built-in
Types</a></h3>
<p>Every XSLT <span>3.0</span> processor includes the following
named type definitions in the <a title="in-scope schema component"
class="termref" href="#dt-in-scope-schema-component">in-scope
schema components</a>:</p>
<ul>
<li>
<p><span>All built-in types defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>, including <code>xs:anyType</code> and
<code>xs:anySimpleType</code>.</span></p>
</li>
<li>
<p>The following types defined in <a href="#xpath-30">[XPath
3.0]</a>: <code>xs:yearMonthDuration</code>,
<code>xs:dayTimeDuration</code>, <code>xs:anyAtomicType</code>,
<code>xs:untyped</code>, and <code>xs:untypedAtomic</code>.</p>
</li>
</ul>
<p>XSLT 3.0 processors <span class="verb">may</span> optionally
include types defined in XSD 1.1 (see <a href="#xmlschema11-1">[XML
Schema]</a>). XSD 1.1 adopts the types
<code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
and <code>xs:anyAtomicType</code> previously defined in XPath 2.0,
and adds one new type: <code>xs:dateTimeStamp</code>. XSD 1.1 also
allows implementors to define additional primitive types, and XSLT
3.0 permits such types to be supported by an XSLT processor.</p>
<p>A <a title="schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>
additionally supports:</p>
<ul>
<li>
<p>User-defined types, and element and attribute declarations, that
are imported using an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration as described in <a href="#import-schema"><i>3.16
Importing Schema Components</i></a>. These may include both simple
and complex types.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names that are imported from the XML Schema namespace do not
include all the names of top-level types defined in either the
Schema for Schema Documents or the Schema for Schema Documents
(Datatypes). The Schema for Schema Documents, as well as defining
built-in types such as <code>xs:integer</code> and
<code>xs:double</code>, also defines types that are intended for
use only within that schema, such as
<code>xs:derivationControl</code>. A <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> that is designed to
process XML Schema documents as its input or output may import the
Schema for Schema Documents.</p>
</div>
<p>An implementation may define mechanisms that allow additional
<a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> to be added to the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet. For example, the mechanisms used to define
<a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a> (see <a href=
"#extension-functions"><i>23.1 Extension Functions</i></a>) may
also be used to import the types used in the interface to such
functions.</p>
<p>These <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> are the only ones that
may be referenced in XPath expressions within the stylesheet, or in
the <code>[xsl:]type</code> and <code>as</code> attributes of those
elements that permit these attributes.</p>
</div>
<div class="div2">
<h3><a name="import-schema" id="import-schema"></a>3.16 <a href=
"#import-schema" style="text-decoration: none">Importing Schema
Components</a></h3>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facilities described in this section are not available with
a <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a>. They require a
<a title="schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>,
as described in <a href="#conformance"><i>26
Conformance</i></a>.</p>
</div>
<p class="element-syntax"><a name="element-import-schema" id=
"element-import-schema"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:import-schema<br />
&#160;&#160;namespace? = <var>uri</var><br />
&#160;&#160;schema-location? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
&lt;/xsl:import-schema&gt;</code></p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration is used to identify <a title="schema component" class=
"termref" href="#dt-schema-component">schema components</a> (that
is, top-level type definitions and top-level element and attribute
declarations) that need to be available statically, that is, before
any source document is available. Names of such components used
statically within the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> must refer to an <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema component</a>,
which means they must either be built-in types as defined in
<a href="#built-in-types"><i>3.15 Built-in Types</i></a>, or they
must be imported using an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration identifies a namespace containing the names of the
components to be imported (or indicates that components whose names
are in no namespace are to be imported). The effect is that the
names of top-level element and attribute declarations and type
definitions from this namespace (or non-namespace) become available
for use within XPath expressions in the <span><a title="package"
class="termref" href="#dt-package">package</a></span>, and within
other stylesheet constructs such as the <code>type</code> and
<code>as</code> attributes of various <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT elements</a>.</p>
<p>The same schema components are available in all stylesheet
modules <span>within the <a title="declaring package" class=
"termref" href="#dt-declaring-package">declaring
package</a></span>; importing components in one stylesheet module
makes them available throughout the <a title="package" class=
"termref" href="#dt-package">package</a>.</p>
<p>The schema components imported into different <a title="package"
class="termref" href="#dt-package">packages</a> within a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
must be consistent. Specifically, it is not permitted to use the
same name in the same XSD symbol space to refer to different schema
components within different packages; and the union of the schema
components imported into the packages of a stylesheet must
constitute a valid schema (as well as the set of schema components
imported into each package forming a valid schema in its own
right).</p>
<p>The <code>namespace</code> and <code>schema-location</code>
attributes are both optional.</p>
<p>If the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
contains an <code>xs:schema</code> element, then the
<code>schema-location</code> attribute <span class=
"verb">must</span> be absent, and one of the following <span class=
"verb">must</span> be true:</p>
<ul>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element are both absent (indicating a
no-namespace schema), or</p>
</li>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element are both present and both have the
same value, or</p>
</li>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
is absent and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element is present, in which case the target
namespace is as given on the <code>xs:schema</code> element.</p>
</li>
</ul>
<p><a name="err-XTSE0215" id="err-XTSE0215"><span class=
"error">[ERR XTSE0215]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
element that contains an <code>xs:schema</code> element has a
<code>schema-location</code> attribute, or if it has a
<code>namespace</code> attribute that conflicts with the target
namespace of the contained schema.</p>
<p>If two <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations specify the same namespace, or if both specify no
namespace, then only the one with highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used. If this
leaves more than one, then all the declarations at the highest
import precedence are used (which may cause conflicts, as described
below).</p>
<p>After discarding any <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations under the above rule, the effect of the remaining
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
declarations is defined in terms of a hypothetical document called
the synthetic schema document, which is constructed as follows. The
synthetic schema document defines an arbitrary target namespace
that is different from any namespace actually used by the
application, and it contains <code>xs:import</code> elements
corresponding one-for-one with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, with the following
correspondence:</p>
<ul>
<li>
<p>The <code>namespace</code> attribute of the
<code>xs:import</code> element is copied from the
<code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration if it is explicitly present, or is implied by the
<code>targetNamespace</code> attribute of a contained
<code>xs:schema</code> element, and is absent if it is absent.</p>
</li>
<li>
<p>The <code>schemaLocation</code> attribute of the
<code>xs:import</code> element is copied from the
<code>schema-location</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration if present, and is absent if it is absent. If there is
a contained <code>xs:schema</code> element, the effective value of
the <code>schemaLocation</code> attribute is a URI referencing a
document containing a copy of the <code>xs:schema</code>
element.</p>
</li>
<li>
<p>The base URI of the <code>xs:import</code> element is the same
as the base URI of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
</li>
</ul>
<p>The schema components included in the <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>
(that is, the components whose names are available for use within
the stylesheet) are the top-level element and attribute
declarations and type definitions that are available for reference
within the synthetic schema document. See <a href=
"#xmlschema-1">[XML Schema Part 1]</a> (section 4.2.3,
<em>References to schema components across namespaces</em>).</p>
<p><a name="err-XTSE0220" id="err-XTSE0220"><span class=
"error">[ERR XTSE0220]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
synthetic schema document does not satisfy the constraints
described in <a href="#xmlschema-1">[XML Schema Part 1]</a>
(section 5.1, <em>Errors in Schema Construction and
Structure</em>). This includes, without loss of generality,
conflicts such as multiple definitions of the same name.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The synthetic schema document does not need to be constructed by
a real implementation. It is purely a mechanism for defining the
semantics of <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> in
terms of rules that already exist within the XML Schema
specification. In particular, it implicitly defines the rules that
determine whether the set of <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations are mutually consistent.</p>
<p>These rules do not cause names to be imported transitively. The
fact that a name is available for reference within a schema
document A does not of itself make the name available for reference
in a stylesheet that imports the target namespace of schema
document A. (See <a href="#xmlschema-1">[XML Schema Part 1]</a>
section 3.15.3, Constraints on XML Representations of Schemas.) The
stylesheet must import all the namespaces containing names that it
actually references.</p>
<p>The <code>namespace</code> attribute indicates that a schema for
the given namespace is required by the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This information
may be enough on its own to enable an implementation to locate the
required schema components. The <code>namespace</code> attribute
may be omitted to indicate that a schema for names in no namespace
is being imported. The zero-length string is not a valid namespace
URI, and is therefore not a valid value for the
<code>namespace</code> attribute.</p>
<p>The <code>schema-location</code> attribute is a <a title=
"URI Reference" class="termref" href="#dt-uri-reference">URI
Reference</a> that gives a hint indicating where a schema document
or other resource containing the required definitions may be found.
It is likely that a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a> will be able to process a schema document found at
this location.</p>
<p>The XML Schema specification gives implementations flexibility
in how to handle multiple imports for the same namespace. Multiple
imports do not cause errors if the definitions do not conflict.</p>
<p>A consequence of these rules is that it is not intrinsically an
error if no schema document can be located for a namespace
identified in an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration. This will cause an error only if it results in the
stylesheet containing references to names that have not been
imported.</p>
<p>An inline schema document (using an <code>xs:schema</code>
element as a child of the <code>xsl:import-schema</code> element)
has the same status as an external schema document, in the sense
that it acts as a hint for a source of schema components in the
relevant namespace. To ensure that the inline schema document is
always used, it is advisable to use a target namespace that is
unique to this schema document.</p>
</div>
<p>The use of a namespace in an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration does not by itself associate any namespace prefix with
the namespace. If names from the namespace are used within the
stylesheet module then a namespace declaration must be included in
the stylesheet module, in the usual way.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e10116" id=
"d7e10116"></a>Example: An Inline Schema Document</div>
<p>The following example shows an inline schema document. This
declares a simple type <code>local:yes-no</code>, which the
stylesheet then uses in the declaration of a variable.</p>
<p>The example assumes the namespace declaration
<code>xmlns:local="http://example.com/ns/yes-no"</code></p>
<div class="exampleInner">
<pre>
&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="data-model" id="data-model"></a>4 <a href=
"#data-model" style="text-decoration: none">Data Model</a></h2>
<p>The data model used by XSLT is the <span>XPath 3.0 and XQuery
3.0</span> data model (XDM), as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>. XSLT operates on source,
result and stylesheet documents using the same data model.</p>
<p>This section elaborates on some particular features of XDM as it
is used by XSLT:</p>
<p>The rules in <a href="#stylesheet-stripping"><i>4.2 Stripping
Whitespace from the Stylesheet</i></a> and <a href="#strip"><i>4.4
Stripping Whitespace from a Source Tree</i></a> make use of the
concept of a whitespace text node.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-whitespace-text-node" id="dt-whitespace-text-node" title=
"whitespace text node"></a>A <b>whitespace text node</b> is a text
node whose content consists entirely of whitespace characters (that
is, #x09, #x0A, #x0D, or #x20).<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Features of a source XML document that are not represented in
the XDM tree will have no effect on the operation of an XSLT
stylesheet. Examples of such features are entity references, CDATA
sections, character references, whitespace within element tags, and
the choice of single or double quotes around attribute values.</p>
</div>
<div class="div2">
<h3><a name="xml-versions" id="xml-versions"></a>4.1 <a href=
"#xml-versions" style="text-decoration: none">XML Versions</a></h3>
<p>The XDM data model defined in <a href=
"#xpath-datamodel-30">[Data Model]</a> is capable of representing
either an XML 1.0 document (conforming to <a href="#REC-xml">[XML
1.0]</a> and <a href="#xml-names">[Namespaces in XML]</a>) or an
XML 1.1 document (conforming to <a href="#xml11">[XML 1.1]</a> and
<a href="#xml-names11">[Namespaces in XML 1.1]</a>), and it makes
no distinction between the two. In principle, therefore, XSLT
<span>3.0</span> can be used with either of these XML versions.</p>
<p>Construction of the XDM tree is outside the scope of this
specification, so XSLT <span>3.0</span> places no formal
requirements on an XSLT processor to accept input from either XML
1.0 documents or XML 1.1 documents or both. This specification does
define a serialization capability (see <a href=
"#serialization"><i>25 Serialization</i></a>), though from a
conformance point of view it is an optional feature. Although
facilities are described for serializing the XDM tree as either XML
1.0 or XML 1.1 (and controlling the choice), there is again no
formal requirement on an XSLT processor to support either or both
of these XML versions as serialization targets.</p>
<p>Because the XDM tree is the same whether the original document
was XML 1.0 or XML 1.1, the semantics of XSLT processing do not
depend on the version of XML used by the original document. There
is no reason in principle why all the input and output documents
used in a single transformation must conform to the same version of
XML.</p>
<p>Some of the syntactic constructs in XSLT <span>3.0</span> and
<span>XPath 3.0</span>, for example the productions <a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">Char</a><sup><small>XML</small></sup>
and <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
are defined by reference to the XML and XML Namespaces
specifications. There are slight variations between the XML 1.0 and
XML 1.1 versions of these productions <span>(and, indeed, between
different editions of XML 1.0)</span>. Implementations <span class=
"verb">may</span> support <span>any</span> version; it is
<span class="verb">recommended</span> that an XSLT <span>3.0</span>
processor that implements the 1.1 versions <span class=
"verb">should</span> also provide a mode that supports the 1.0
versions. It is thus <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> whether the
XSLT processor supports XML 1.0 with XML Namespaces 1.0, or XML 1.1
with XML Namespaces 1.1, or supports both versions at user
option.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The specification referenced as <a href="#xml-names">[Namespaces
in XML]</a> was actually published without a version number.</p>
</div>
<p><span>The current version of <a href="#xmlschema-2">[XML Schema
Part 2]</a> (that is, XSD 1.0) does not reference the XML 1.1
specifications.</span> This means that datatypes such as
<code>xs:NCName</code> and <code>xs:ID</code> are constrained by
the XML 1.0 rules, and do not allow the full range of values
permitted by XML 1.1. This situation will not be resolved until a
new version of <a href="#xmlschema-2">[XML Schema Part 2]</a>
becomes available; in the meantime, it is <span class=
"verb">recommended</span> that implementers wishing to support XML
1.1 should consult <a href="#SCHEMA-AND-XML-1.1">[XML Schema 1.0
and XML 1.1]</a> for guidance. An XSLT <span>3.0</span> processor
that supports XML 1.1 <span class="verb">should</span> implement
the rules in later versions of <a href="#xmlschema-2">[XML Schema
Part 2]</a> as they become available.</p>
</div>
<div class="div2">
<h3><a name="stylesheet-stripping" id=
"stylesheet-stripping"></a>4.2 <a href="#stylesheet-stripping"
style="text-decoration: none">Stripping Whitespace from the
Stylesheet</a></h3>
<p>The tree representing the stylesheet is preprocessed as
follows:</p>
<ol class="enumar">
<li>
<p>All comments and processing instructions are removed.</p>
</li>
<li>
<p>Any text nodes that are now adjacent to each other are
merged.</p>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> that satisfies
both the following conditions is removed from the tree:</p>
<ul>
<li>
<p>The parent of the text node is not an <a href=
"#element-text"><code>xsl:text</code></a> element</p>
</li>
<li>
<p>The text node does not have an ancestor element that has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, unless there is a closer ancestor element
having an <code>xml:space</code> attribute with a value of
<code>default</code>.</p>
</li>
</ul>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose parent is
one of the following elements is removed from the tree, regardless
of any <code>xml:space</code> attributes:</p>
<blockquote>
<p><span><a href=
"#element-accumulator"><code>xsl:accumulator</code></a></span><br />

<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a><br />
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a><br />
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a><br />

<a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a><br />
<a href=
"#element-call-template"><code>xsl:call-template</code></a><br />
<a href=
"#element-character-map"><code>xsl:character-map</code></a><br />
<a href="#element-choose"><code>xsl:choose</code></a><br />
<span><a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span><br />
<span><a href=
"#element-fork"><code>xsl:fork</code></a></span><br />
<span><a href=
"#element-merge"><code>xsl:merge</code></a></span><br />
<span><a href=
"#element-merge-source"><code>xsl:merge-source</code></a></span><br />

<span><a href=
"#element-mode"><code>xsl:mode</code></a></span><br />
<span><a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a></span><br />

<a href="#element-next-match"><code>xsl:next-match</code></a><br />
<span><a href=
"#element-override"><code>xsl:override</code></a></span><br />
<span><a href=
"#element-package"><code>xsl:package</code></a></span><br />
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a><br />
<a href="#element-transform"><code>xsl:transform</code></a><br />
<span><a href=
"#element-use-package"><code>xsl:use-package</code></a></span></p>
</blockquote>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose immediate
following-sibling node is an <a href=
"#element-param"><code>xsl:param</code></a> or <a href=
"#element-sort"><code>xsl:sort</code></a> element is removed from
the tree, regardless of any <code>xml:space</code> attributes.</p>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose immediate
preceding-sibling node is an <a href=
"#element-catch"><code>xsl:catch</code></a> or <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
is removed from the tree, regardless of any <code>xml:space</code>
attributes.</p>
</li>
</ol>
<p><a name="err-XTSE0260" id="err-XTSE0260"><span class=
"error">[ERR XTSE0260]</span></a> Within an <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT element</a> that is
<span class="verb">required</span> to be empty, any content other
than comments or processing instructions, including any <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> preserved using
the <code>xml:space="preserve"</code> attribute, is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Using <code>xml:space="preserve"</code> in parts of the
stylesheet that contain <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructors</a>
will cause <span>whitespace text nodes in that part of the
stylesheet to be copied to the result of the sequence
constructor</span>. When the result of the sequence constructor is
used to form the content of an element, this can cause errors if
such text nodes are followed by attribute nodes generated using
<a href="#element-attribute"><code>xsl:attribute</code></a>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an <code>xml:space</code> attribute is specified on a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, it will be
copied to the result tree in the same way as any other
attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="stripping-annotations" id=
"stripping-annotations"></a>4.3 <a href="#stripping-annotations"
style="text-decoration: none">Stripping Type Annotations from a
Source Tree</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-annotation" id="dt-annotation" title="type annotation"></a>The
term <b>type annotation</b> is used in this specification to refer
to the value returned by the <code>dm:type-name</code> accessor of
a node: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section
5.14 type-name Accessor</a>
<sup><small>DM30</small></sup>.<span class=
"definition">]</span></p>
<p>There is sometimes a requirement to write stylesheets that
produce the same results whether or not the source documents have
been validated against a schema. To achieve this, an option is
provided to remove any <a title="type annotation" class="termref"
href="#dt-annotation">type annotations</a> on element and attribute
nodes in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>, replacing them with an
annotation of <code>xs:untyped</code> in the case of element nodes,
and <code>xs:untypedAtomic</code> in the case of attribute
nodes.</p>
<p>Such stripping of <a title="type annotation" class="termref"
href="#dt-annotation">type annotations</a> can be requested by
specifying <code>input-type-annotations="strip"</code> on the
<span><a href=
"#element-package"><code>xsl:package</code></a></span> element.
This attribute has three permitted values: <code>strip</code>,
<code>preserve</code>, and <code>unspecified</code>. The default
value is <code>unspecified</code>.</p>
<p>The <code>input-type-annotations</code> attribute may also be
specified on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element; if
it is specified at this level then it must be consistent for all
stylesheet modules within the same package.</p>
<p><a name="err-XTSE0265" id="err-XTSE0265"><span class=
"error">[ERR XTSE0265]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
is a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> in a <a title=
"package" class="termref" href="#dt-package">package</a> that
specifies <code>input-type-annotations="strip"</code> and another
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that specifies
<code>input-type-annotations="preserve"</code>, <span>or if a
stylesheet module specifies the value <code>strip</code> or
<code>preserve</code> and the same value is not specified on the
<a href="#element-package"><code>xsl:package</code></a> element of
the containing package.</span></p>
<p>The <a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a> to which this applies are the
same as those affected by <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>:
see <a href="#strip"><i>4.4 Stripping Whitespace from a Source
Tree</i></a>. <span>As with whitespace stripping, the rules for
stripping of type annotations may vary from one package to another,
and have the effect of modifying the mapping from URIs to document
nodes defined in the XPath dynamic context; this means that two
calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function (for example) supplying the same URI may produce different
document nodes if the calls appear in different
packages.</span></p>
<p>When type annotations are stripped, the following changes are
made to the source tree:</p>
<ul>
<li>
<p>The type annotation of every element node is changed to
<code>xs:untyped</code></p>
</li>
<li>
<p>The type annotation of every attribute node is changed to
<code>xs:untypedAtomic</code></p>
</li>
<li>
<p>The typed value of every element and attribute node is set to be
the same as its string value, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>The <code>is-nilled</code> property of every element node is set
to <code>false</code>.</p>
</li>
</ul>
<p>The values of the <code>is-id</code> and <code>is-idrefs</code>
properties are not changed.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Stripping type annotations does not necessarily return the
document to the state it would be in had validation not taken
place. In particular, any defaulted elements and attributes that
were added to the tree by the validation process will still be
present , and elements and attributes validated as IDs will still
be accessible using the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
function.</p>
</div>
</div>
<div class="div2">
<h3><a name="strip" id="strip"></a>4.4 <a href="#strip" style=
"text-decoration: none">Stripping Whitespace from a Source
Tree</a></h3>
<p>A <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> supplied as input to the
transformation process may contain <a title="whitespace text node"
class="termref" href="#dt-whitespace-text-node">whitespace text
nodes</a> that are of no interest, and that do not need to be
retained by the transformation. Conceptually, an XSLT <a title=
"processor" class="termref" href="#dt-processor">processor</a>
makes a copy of the source tree from which unwanted <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> have been
removed. This process is referred to as whitespace stripping.</p>
<p>For the purposes of this section, the term <b>source tree</b>
means the document containing the <a title="initial context item"
class="termref" href="#dt-initial-context-item">initial context
item</a> <span>if it is a node</span>, any document returned by the
functions <a href="#func-document"><code>document</code></a>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>and any document read using <a href=
"#element-stream"><code>xsl:stream</code></a></span>. It does not
include documents passed as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> <span>or
parameters of the initial template or function</span>, nor values
returned from <a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a>.</p>
<p>Each source tree is associated with a package: the relevant
package for the initial context item is the top-level package; the
relevant package for a call on <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>;
is the package in which that call appears; and the relevant package
for evaluation of <a href=
"#element-stream"><code>xsl:stream</code></a> is the package in
which that instruction appears.</p>
<p>The stripping process takes as input a set of element names
whose child <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> are to be
preserved. The way in which this set of element names is
established using the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations is described later in this section.</p>
<p>Formally, the stripping process modifies the mapping from URIs
to document nodes defined in the XPath dynamic context. This
mapping can therefore vary from one package to another. The mapping
that applies to a particular call on <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
or a particular evaluation of <a href=
"#element-stream"><code>xsl:stream</code></a>, is affected by the
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations within the package in which that construct appears.
This means that two calls on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function (for example) may return different nodes if the calls
appear in different packages.</p>
<p>A <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> is preserved if
either of the following apply:</p>
<ul>
<li>
<p>The element name of the parent of the text node is in the set of
whitespace-preserving element names.</p>
</li>
<li>
<p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of <code>default</code>.</p>
</li>
</ul>
<p>Otherwise, the <a title="whitespace text node" class="termref"
href="#dt-whitespace-text-node">whitespace text node</a> is
stripped.</p>
<p>The <code>xml:space</code> attributes are not removed from the
tree.</p>
<p class="element-syntax"><a name="element-strip-space" id=
"element-strip-space"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:strip-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p class="element-syntax"><a name="element-preserve-space" id=
"element-preserve-space"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:preserve-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p>The set of whitespace-preserving element names is specified by
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
<a title="declaration" class="termref" href=
"#dt-declaration">declarations</a>. Whether an element name is
included in the set of whitespace-preserving names is determined by
the best match among all the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations: it is included if and only if there is no match or
the best match is an <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
element. The <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
elements each have an <code>elements</code> attribute whose value
is a whitespace-separated list of <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>;
an element name matches an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
element if it matches one of the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>.
An element matches a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
if and only if the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
would be true for the element as an XPath node test.</p>
<p>The effect of <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
is local to the <a title="package" class="termref" href=
"#dt-package">package</a> in which they appear. Declarations within
a library package only affect the handling of documents loaded
using a call on the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions <span>or an evaluation of an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction</span>
appearing lexically within the same package. Declarations within
the top-level package also affect the processing of the main input
document.</p>
<p><a name="err-XTSE0270" id="err-XTSE0270"><span class=
"error">[ERR XTSE0270]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if
<span>within any <a title="package" class="termref" href=
"#dt-package">package</a></span> the same <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration if both have the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>.
Two NameTests are considered the same if they match the same set of
names (which can be determined by comparing them after expanding
namespace prefixes to URIs).</p>
<p><span>Otherwise,</span> when more than one <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
element <span>within the relevant <a title="package" class=
"termref" href="#dt-package">package</a></span> matches, the best
matching element is determined by the best matching <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>.
<span>The rules are similar to those for</span> <a title=
"template rule" class="termref" href="#dt-template-rule">template
rules</a>:</p>
<ul>
<li>
<p>First, any match with lower <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a> than
another match is ignored.</p>
</li>
<li>
<p>Next, any match that has a lower <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
than the <a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> of another match is
ignored.</p>
</li>
<li>
<p>If several matches have the same <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
(which can only happen if one of the NameTests takes the form
<code>*:local</code> and the other takes the form
<code>prefix:*</code>), then the declaration that appears last in
<a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> is used.</p>
</li>
</ul>
<p>If an element in a source document has a <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> that is a simple type or a complex type with simple
content, then any whitespace text nodes among its children are
preserved, regardless of any <a href=
"#element-strip-space"><code>xsl:strip-space</code></a>
declarations. The reason for this is that stripping a whitespace
text node from an element with simple content could make the
element invalid: for example, it could cause the
<code>minLength</code> facet to be violated.</p>
<p>Stripping of <a title="type annotation" class="termref" href=
"#dt-annotation">type annotations</a> happens before stripping of
whitespace text nodes, so this situation will not occur if
<code>input-type-annotations="strip"</code> is specified.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In <a href="#xpath-datamodel-30">[Data Model]</a>, processes are
described for constructing an XDM tree from an Infoset or from a
PSVI. Those processes deal with whitespace according to their own
rules, and the provisions in this section apply to the resulting
tree. In practice this means that elements that are defined in a
DTD or a Schema to contain element-only content will have <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> stripped,
regardless of the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations in the stylesheet.</p>
<p>However, source trees are not necessarily constructed using
those processes; indeed, they are not necessarily constructed by
parsing XML documents. Nothing in the XSLT specification constrains
how the source tree is constructed, or what happens to <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> during its
construction. The provisions in this section relate only to
whitespace text nodes that are present in the tree supplied as
input to the XSLT processor. The XSLT processor cannot preserve
whitespace text nodes unless they were actually present in the
supplied tree.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-in-data-model" id="id-in-data-model"></a>4.5
<a href="#id-in-data-model" style="text-decoration: none">Attribute
Types and DTD Validation</a></h3>
<p>The mapping from the Infoset to the XDM data model, described in
<a href="#xpath-datamodel-30">[Data Model]</a>, does not retain
attribute types. This means, for example, that an attribute
described in the DTD as having attribute type <code>NMTOKENS</code>
will be annotated in the XDM tree as <code>xs:untypedAtomic</code>
rather than <code>xs:NMTOKENS</code>, and its typed value will
consist of a single <code>xs:untypedAtomic</code> value rather than
a sequence of <code>xs:NMTOKEN</code> values.</p>
<p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will
be marked in the XDM tree as having the <code>is-id</code> or
<code>is-idrefs</code> properties. It is these properties, rather
than any <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a>, that are examined by the
functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-idref"><code>idref</code></a><sup><small>FO30</small></sup>
described in <a href="#xpath-functions-30">[Functions and
Operators]</a>.</p>
</div>
<div class="div2">
<h3><a name="model-for-streaming" id="model-for-streaming"></a>4.6
<a href="#model-for-streaming" style="text-decoration: none">Data
Model for Streaming</a></h3>
<p>The data model for nodes in a document that is being streamed is
no different from the standard XDM data model, in that it contains
the same objects (nodes) with the same properties and
relationships. The facilities for streaming do not change the data
model; instead they impose rules that limit the ability of
stylesheets to navigate the data model.</p>
<p>A useful way to visualize streaming is to suppose that at any
point in time, there is a current position in the streamed input
document which may be the start or end of the document, the start
or end tag of an element, or a text, comment, or processing
instruction node. From this position, the stylesheet has access to
the following information:</p>
<ul>
<li>
<p>Properties intrinsic to the node, such as its name, its base
URI, its type annotation, and its <code>is-id</code> and
<code>is-idref</code> properties.</p>
</li>
<li>
<p>The ancestors of the node (but navigation downwards from the
ancestors is not permitted).</p>
</li>
<li>
<p>The attributes of the node, and the attributes of its ancestors.
For each such attribute, all the properties of the node including
its string value and typed value are available, but there are
limitations that restrict navigation from the attribute node to
other nodes in the document.</p>
</li>
<li>
<p>The in-scope namespace bindings of the node.</p>
</li>
<li>
<p>In the case of attributes, text nodes, comments, and processing
instructions, the string value and typed value of the node.</p>
</li>
<li>
<p>Summary data about the preceding siblings of the node, and of
each of its ancestor nodes: specifically, for each distinct
combination of node kind, node name, and type annotation, a count
of the number of preceding siblings that have that combination of
properties. This information allows patterns such as
<code>match="para[1]"</code> to be used, and it permits some
limited use of the <a href=
"#element-number"><code>xsl:number</code></a> instruction.</p>
</li>
</ul>
<p>The children and other descendants of a node are not accessible
except as a by-product of changing the current position in the
document. The same applies to properties of an element or document
node that require examination of the node's descendants, that is,
the string value and typed value. This is enforced by means of a
rule that only one expression requiring downward navigation from a
node is permitted.</p>
<p>There is an assumption that information about unparsed entities
is available at all times during the processing of a document. This
has two implications: firstly, the processor may need to read ahead
at the start of the document to determine this information so that
it is available while processing the document root node; and
secondly, the information then needs to be retained for the
duration of the processing.</p>
<p>Expressions such as <code>(/) instance of
document-node(element(invoice))</code> also require look-ahead as
far as the start-tag of the first element.</p>
<p>A streaming processor is required to read only as much of the
source document as is needed to generate correct stylesheet output.
It is not required to read the full source document merely in order
to satisfy the requirement imposed by the XML Recommendation that
an XML Processor must report violations of well-formedness in the
input.</p>
<p>More detailed rules are defined in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</div>
<div class="div2">
<h3><a name="limits" id="limits"></a>4.7 <a href="#limits" style=
"text-decoration: none">Limits</a></h3>
<p>The XDM data model (see <a href="#xpath-datamodel-30">[Data
Model]</a>) leaves it to the host language to define limits. This
section describes the limits that apply to XSLT.</p>
<p>Limits on some primitive datatypes are defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>. Other limits, listed below,
are <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Note that
this does not necessarily mean that each limit must be a simple
constant: it may vary depending on environmental factors such as
available resources.</p>
<p>The following limits are <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumar">
<li>
<p>For the <code>xs:decimal</code> type, the maximum number of
decimal digits (the <code>totalDigits</code> facet). This must be
at least 18 digits. (Note, however, that support for the full value
range of <code>xs:unsignedLong</code> requires 20 digits.)</p>
</li>
<li>
<p>For the types <code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <code>xs:gYear</code>, and
<code>xs:gYearMonth</code>: the range of values of the year
component, which must be at least +0001 to +9999; and the maximum
number of fractional second digits, which must be at least 3.</p>
</li>
<li>
<p>For the <code>xs:duration</code> type: the maximum absolute
values of the years, months, days, hours, minutes, and seconds
components.</p>
</li>
<li>
<p>For the <code>xs:yearMonthDuration</code> type: the maximum
absolute value, expressed as an integer number of months.</p>
</li>
<li>
<p>For the <code>xs:dayTimeDuration</code> type: the maximum
absolute value, expressed as a decimal number of seconds.</p>
</li>
<li>
<p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
<code>xs:base64Binary</code>, <code>xs:QName</code>,
<code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived
from them: the maximum length of the value.</p>
</li>
<li>
<p>For sequences, the maximum number of items in a sequence.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="d-o-e-in-data-model" id="d-o-e-in-data-model"></a>4.8
<a href="#d-o-e-in-data-model" style=
"text-decoration: none">Disable Output Escaping</a></h3>
<p>For backwards compatibility reasons, XSLT <span>3.0</span>
continues to support the <code>disable-output-escaping</code>
feature introduced in XSLT 1.0. This is an optional feature and
implementations are not <span class="verb">required</span> to
support it. A new facility, that of named <a title="character map"
class="termref" href="#dt-character-map">character maps</a> (see
<a href="#character-maps"><i>25.1 Character Maps</i></a>)
<span>was</span> introduced in XSLT 2.0. It provides similar
capabilities to <code>disable-output-escaping</code>, but without
distorting the data model.</p>
<p>If an <a title="implementation" class="termref" href=
"#dt-implementation">implementation</a> supports the
<code>disable-output-escaping</code> attribute of <a href=
"#element-text"><code>xsl:text</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>, (see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>), then the data model for trees constructed by the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> is augmented with a boolean value
representing the value of this property. This boolean value,
however, can be set only within a <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
that is being passed to the serializer.</p>
<p>Conceptually, each character in a text node on such a result
tree has a boolean property indicating whether the serializer is to
disable the normal rules for escaping of special characters (for
example, outputting of <code>&amp;</code> as
<code>&amp;amp;</code>) in respect of this character.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the nodes in a <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> will
often be streamed directly from the XSLT processor to the
serializer. In such an implementation,
<code>disable-output-escaping</code> can be viewed not so much a
property stored with nodes in the tree, but rather as additional
information passed across the interface between the XSLT processor
and the serializer.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="constructs" id="constructs"></a>5 <a href=
"#constructs" style="text-decoration: none">Features of the XSLT
Language</a></h2>
<div class="div2">
<h3><a name="qname" id="qname"></a>5.1 <a href="#qname" style=
"text-decoration: none">Qualified Names</a></h3>
<p>The name of a stylesheet-defined object, specifically a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a named
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, or a <a title=
"character map" class="termref" href="#dt-character-map">character
map</a> is a qualified name: that is, it consists of a local name
and an optional namespace URI.</p>
<p>In most cases where such names are written in a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>,
the syntax for expressing the name is given by the production
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
in the XPath specification. In practice, this means that three
forms are permitted:</p>
<ul>
<li>
<p>A simple <code>NCName</code> appearing on its own (without any
prefix). This represents the local name of the object. The
interpretation of unprefixed names is described below.</p>
</li>
<li>
<p>A <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> written in the form
<code>NCName ":" NCName</code> where the first part is a namespace
prefix and the second part is the local name. The namespace part of
the object's name is then derived from the prefix by examining the
in-scope namespace bindings of the element node in the stylesheet
where the name appears.</p>
</li>
<li>
<p>A <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-URIQualifiedName">URIQualifiedName</a><sup><small>XP30</small></sup>
in the form <code>"Q{" URI? "}" NCName</code> where the two parts
of the name, that is the namespace part and the local part, both
appear explicitly. If the URI part is omitted (for example
<code>Q{}local</code>), the resulting expanded QName is a QName
whose namespace part is absent.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are a few places where the third form, a URIQualifiedName,
is not permitted. These include the <code>name</code> attribute of
<a href="#element-element"><code>xsl:element</code></a> and
<a href="#element-attribute"><code>xsl:attribute</code></a> (which
have a separate <code>namespace</code> attribute for the purpose),
and constructs defined by other specifications. For example, names
appearing within an embedded <code>xs:schema</code> element must
follow the XSD rules.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName"></a>An <b>expanded QName</b> is a value in the
value space of the <code>xs:QName</code> datatype as defined in the
XDM data model (see <a href="#xpath-datamodel-30">[Data
Model]</a>): that is, a triple containing namespace prefix
(optional), namespace URI (optional), and local name. Two expanded
QNames are equal if the namespace URIs are the same (or both
absent) and the local names are the same. The prefix plays no part
in the comparison, but is used only if the expanded QName needs to
be converted back to a string.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-eqname" id="dt-eqname" title="EQName"></a>An <b>EQName</b> is a
string representing a <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> where the string,
after removing leading and trailing whitespace, is in the form
defined by the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
production in the XPath specification.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-lexical-qname" id="dt-lexical-qname" title=
"lexical QName"></a>A <b>lexical QName</b> is a string representing
a <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> where the string, after
removing leading and trailing whitespace, is within the lexical
space of the <code>xs:QName</code> datatype as defined in XML
Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that
is, a local name optionally preceded by a namespace prefix and a
colon.<span class="definition">]</span></p>
<p>Note that every <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is an <a title="EQName"
class="termref" href="#dt-eqname">EQName</a>, but the converse is
not true.</p>
<p>The following rules are used when interpreting a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a>:</p>
<ol class="enumar">
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-defining-element" id="dt-defining-element" title=
"defining element"></a>A string in the form of a lexical QName may
occur as the value of an attribute node in a stylesheet module, or
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in an attribute <span>or
text node within a stylesheet module</span>, or as the result of
evaluating an XPath expression contained in such a node. The
element containing this attribute <span>or text</span> node is
referred to as the <b>defining element</b> of the lexical
QName.<span class="definition">]</span></p>
</li>
<li>
<p>If the lexical QName has a prefix, then the prefix is expanded
into a URI reference using the namespace declarations in effect on
its <a title="defining element" class="termref" href=
"#dt-defining-element">defining element</a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> consisting of the local part of the name and the possibly
null URI reference is used as the name of the object. The default
namespace of the defining element (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) is <em>not</em>
used for unprefixed names.</p>
<p><a name="err-XTSE0280" id="err-XTSE0280"><span class=
"error">[ERR XTSE0280]</span></a> In the case of a prefixed
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> used as the value <span>(or
as part of the value)</span> of an attribute in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>,
or appearing within an XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> in the stylesheet, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a title=
"defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches the prefix of the <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0290" id="err-XTDE0290"><span class=
"error">[ERR XTDE0290]</span></a> Where the result of evaluating an
XPath expression (or an attribute value template) is required to be
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>, or if it is permitted to be
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> and the actual value takes
the form of a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>, then unless otherwise
specified it is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value has a prefix and
the <a title="defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches that prefix. This error <span class=
"verb">may</span> be signaled as a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the value of
the expression can be determined statically.</p>
</li>
<li>
<p>If the lexical QName has no prefix, then:</p>
<ol class="enumla">
<li>
<p>In the case of an unprefixed QName used as a
<code>NameTest</code> within an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> (see <a href=
"#expressions"><i>5.3 Expressions</i></a>) , and in certain other
contexts, the namespace to be used in expanding the QName may be
specified by means of the
<code>[xsl:]xpath-default-namespace</code> attribute, as specified
in <a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical QNames in
Expressions and Patterns</i></a>.</p>
</li>
<li>
<p>If the name is in one of the following categories, then the
default namespace of the <a title="defining element" class=
"termref" href="#dt-defining-element">defining element</a> is
used:</p>
<ol class="enumlr">
<li>
<p>Where a QName is used to define the name of an element being
constructed. This applies both to cases where the name is known
statically (that is, the name of a literal result element) and to
cases where it is computed dynamically (the value of the
<code>name</code> attribute of the <a href=
"#element-element"><code>xsl:element</code></a> instruction).</p>
</li>
<li>
<p>The default namespace is used when expanding the first argument
of the function <a href=
"#func-element-available"><code>element-available</code></a>.</p>
</li>
<li>
<p>The default namespace applies to any unqualified element names
appearing in the <code>cdata-section-elements</code> attribute of
<a href="#element-output"><code>xsl:output</code></a> or <a href=
"#element-result-document"><code>xsl:result-document</code></a></p>
</li>
</ol>
</li>
<li>
<p>In all other cases, a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a> with no prefix
represents an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in no namespace (that is,
an <code>xs:QName</code> value in which both the prefix and the
namespace URI are absent).</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="unprefixed-qnames" id="unprefixed-qnames"></a>5.2
<a href="#unprefixed-qnames" style=
"text-decoration: none">Unprefixed Lexical QNames in Expressions
and Patterns</a></h3>
<p>The attribute <code>[xsl:]xpath-default-namespace</code> (see
<a href="#standard-attributes"><i>3.5 Standard Attributes</i></a>)
may be used on an element in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> to define the
namespace that will be used for an unprefixed element name or type
name within an XPath expression, and in certain other contexts
listed below.</p>
<p>The value of the attribute is the namespace URI to be used.</p>
<p>For any element in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, this attribute has an
effective value, which is the value of the
<code>[xsl:]xpath-default-namespace</code> on that element or on
the innermost containing element that specifies such an attribute,
or the zero-length string if no containing element specifies such
an attribute.</p>
<p>For any element in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, the effective value of this
attribute determines the value of the <em>default namespace for
element and type names</em> in the static context of any XPath
expression contained in an attribute <span>or text node</span> of
that element (including XPath expressions in <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>
<span>and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a></span>). The
effect of this is specified in <a href="#xpath-30">[XPath 3.0]</a>;
in summary, it determines the namespace used for any unprefixed
type name in the <code>SequenceType</code> production, and for any
element name appearing in a path expression or in the
<code>SequenceType</code> production.</p>
<p>The effective value of this attribute similarly applies to any
of the following constructs appearing within its scope:</p>
<ul>
<li>
<p>any unprefixed element name or type name used in a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a></p>
</li>
<li>
<p>any unprefixed element name used in the <code>elements</code>
attribute of the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
instructions</p>
</li>
<li>
<p>any unprefixed element name or type name used in the
<code>as</code> attribute of an <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT element</a></p>
</li>
<li>
<p>any unprefixed type name used in the <code>type</code> attribute
of an <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a></p>
</li>
<li>
<p>any unprefixed type name used in the <code>xsl:type</code>
attribute of a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>.</p>
</li>
</ul>
<p>The <code>[xsl:]xpath-default-namespace</code> attribute
<span class="verb">must</span> be in the <a title="XSLT namespace"
class="termref" href="#dt-xslt-namespace">XSLT namespace</a> if and
only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>If the effective value of the attribute is a zero-length string,
which will be the case if it is explicitly set to a zero-length
string or if it is not specified at all, then an unprefixed element
name or type name refers to a name that is in no namespace. The
default namespace of the parent element (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) is <em>not</em>
used.</p>
<p>The attribute does not affect other names, for example function
names, variable names, or template names, or strings that are
interpreted as <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QNames</a> during stylesheet
evaluation, such as the <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute of <a href=
"#element-element"><code>xsl:element</code></a> or the string
supplied as the first argument to the <a href=
"#func-key"><code>key</code></a> function.</p>
</div>
<div class="div2">
<h3><a name="expressions" id="expressions"></a>5.3 <a href=
"#expressions" style="text-decoration: none">Expressions</a></h3>
<p>XSLT uses the expression language defined by <span>XPath
3.0</span> <a href="#xpath-30">[XPath 3.0]</a>. Expressions are
used in XSLT for a variety of purposes including:</p>
<ul>
<li>
<p>selecting nodes for processing;</p>
</li>
<li>
<p>specifying conditions for different ways of processing a
node;</p>
</li>
<li>
<p>generating text to be inserted in a <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-expression" id="dt-expression" title="expression"></a>Within
this specification, the term <b>XPath expression</b>, or simply
<b>expression</b>, means a string that matches the production
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>
defined in <a href="#xpath-30">[XPath 3.0]</a>.<span class=
"definition">]</span></p>
<p>An XPath expression may occur as the value of certain attributes
on XSLT-defined elements, and also within curly brackets in
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>
<span>and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a></span>.</p>
<p>Except where <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled (see <a href="#forwards"><i>3.11
Forwards Compatible Processing</i></a>), it is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if the value of such an attribute, or the text between
curly brackets in an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a> <span>or <a title="text value template" class=
"termref" href="#dt-text-value-template">text value
template</a></span>, does not match the XPath production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>,
or if it fails to satisfy other static constraints defined in the
XPath specification, for example that all variable references
<span class="verb">must</span> refer to <a title="variable" class=
"termref" href="#dt-variable">variables</a> that are in scope.
Error codes are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p>The transformation fails with a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> is evaluated and raises a dynamic
error. Error codes are defined in <a href="#xpath-30">[XPath
3.0]</a>.</p>
<p>The transformation fails with a <a title="type error" class=
"termref" href="#dt-type-error">type error</a> if an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> raises a type error, or if the
result of evaluating the XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> is evaluated and
raises a type error, or if the XPath processor signals a type error
during static analysis of an <a title="expression" class="termref"
href="#dt-expression">expression</a>. Error codes are defined in
<a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-required-type" id="dt-required-type" title=
"required type"></a>The context within a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> appears may specify the <b>required
type</b> of the expression. The required type indicates the type of
the value that the expression is expected to return.<span class=
"definition">]</span> If no required type is specified, the
expression may return any value: in effect, the required type is
then <code>item()*</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-function-conversion-rules" id="dt-function-conversion-rules"
title="function conversion rules"></a>Except where otherwise
indicated, the actual value of an <a title="expression" class=
"termref" href="#dt-expression">expression</a> is converted to the
<a title="required type" class="termref" href=
"#dt-required-type">required type</a> using the <b>function
conversion rules</b>. These are the rules defined in <a href=
"#xpath-30">[XPath 3.0]</a> for converting the supplied argument of
a function call to the required type of that argument, as defined
in the function signature. The relevant rules are those that apply
when <a title="XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to
<code>false</code>.<span class="definition">]</span></p>
<p>This specification also invokes the <span>XPath 3.0</span>
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a> to
convert the result of evaluating an XSLT <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> to a required
type (for example, the sequence constructor enclosed in an <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-template"><code>xsl:template</code></a>, or <a href=
"#element-function"><code>xsl:function</code></a> element).</p>
<p>Any <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> or <a title="type error"
class="termref" href="#dt-type-error">type error</a> that occurs
when applying the <a title="function conversion rules" class=
"termref" href="#dt-function-conversion-rules">function conversion
rules</a> to convert a value to a required type results in the
transformation failing, in the same way as if the error had
occurred while evaluating an expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note the distinction between the two kinds of error that may
occur. Attempting to convert an integer to a date is a type error,
because such a conversion is never possible. Type errors can be
reported statically if they can be detected statically, whether or
not the construct in question is ever evaluated. Attempting to
convert the string <code>2003-02-29</code> to a date is a dynamic
error rather than a type error, because the problem is with this
particular value, not with its type. Dynamic errors are reported
only if the instructions or expressions that cause them are
actually evaluated.</p>
</div>
</div>
<div class="div2">
<h3><a name="static-and-dynamic-context" id=
"static-and-dynamic-context"></a>5.4 <a href=
"#static-and-dynamic-context" style="text-decoration: none">The
Static and Dynamic Context</a></h3>
<p>XPath defines the concept of an <a href=
"http://www.w3.org/TR/xpath-30/#dt-expression-context">expression
context</a><sup><small>XP30</small></sup> which contains all the
information that can affect the result of evaluating an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The expression context has two parts, the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup>, and the <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-context">dynamic
context</a><sup><small>XP30</small></sup>. The components that make
up the expression context are defined in the XPath specification
(see <a href="http://www.w3.org/TR/xpath-30/#context">Section 2.1
Expression Context</a> <sup><small>XP30</small></sup>). This
section describes the way in which these components are initialized
when an XPath expression is contained within an XSLT
stylesheet.</p>
<p>As well as providing values for the static and dynamic context
components defined in the XPath specification, XSLT defines
additional context components of its own. These context components
are used by XSLT instructions (for example, <a href=
"#element-next-match"><code>xsl:next-match</code></a> and <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>), and
also by the functions in the extended function library described in
this specification.</p>
<p>The following four sections describe:</p>
<blockquote>
<p><a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a><br />
<a href="#additional-static-context"><i>5.4.2 Additional Static
Context Components used by XSLT</i></a><br />
<a href="#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a><br />
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a></p>
</blockquote>
<div class="div3">
<h4><a name="static-context" id="static-context"></a>5.4.1 <a href=
"#static-context" style="text-decoration: none">Initializing the
Static Context</a></h4>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> of an XPath expression
appearing in an XSLT stylesheet is initialized as follows. In these
rules, the term <b>containing element</b> means the element within
the stylesheet that is the parent of the attribute <span>or text
node</span> whose value contains the XPath expression in question,
and the term <b>enclosing element</b> means the containing element
or any of its ancestors.</p>
<ul>
<li>
<p><a title="XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to
true if and only if the containing element is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href=
"#backwards"><i>3.10 Backwards Compatible Processing</i></a>).</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-namespaces">statically
known namespaces</a><sup><small>XP30</small></sup> are the
namespace declarations that are in scope for the containing
element.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-elemtype-ns">default
element/type namespace</a><sup><small>XP30</small></sup> is the
namespace defined by the <code>[xsl:]xpath-default-namespace</code>
attribute on the innermost enclosing element that has such an
attribute, as described in <a href="#unprefixed-qnames"><i>5.2
Unprefixed Lexical QNames in Expressions and Patterns</i></a>. The
value of this attribute is a namespace URI. If there is no
<code>[xsl:]xpath-default-namespace</code> attribute on an
enclosing element, the default namespace for element names and type
names is the null namespace.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-fn-ns">default function
namespace</a><sup><small>XP30</small></sup> is the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>,
defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. This means that it is not necessary to declare this
namespace in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, nor is it necessary to use the
prefix <code>fn</code> (or any other prefix) in calls to the
<a title="core function" class="termref" href=
"#dt-core-function">core functions</a>.</p>
</li>
<li>
<p>The <a href="http://www.w3.org/TR/xpath-30/#dt-issd">in-scope
schema definitions</a><sup><small>XP30</small></sup> for the XPath
expression are the same as the <a title="in-scope schema component"
class="termref" href="#dt-in-scope-schema-component">in-scope
schema components</a> for the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, and are as specified in
<a href="#built-in-types"><i>3.15 Built-in Types</i></a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-in-scope-variables">in-scope
variables</a><sup><small>XP30</small></sup> are defined by the
<a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable binding elements</a> that
are in scope for the containing element (see <a href=
"#variables-and-parameters"><i>9 Variables and
Parameters</i></a>).</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-context-item-static-type">context
item static type</a><sup><small>XP30</small></sup> may be
determined by an XSLT processor that performs static type
inferencing, using rules that are outside the scope of this
specification; if no static type inferencing is done, then the
context item static type for every XPath expression is
<code>item()</code>. <span>Note that some limited static type
inferencing is required in the case of a processor that performs
streamability analysis: see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>.</span></p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-func-signatures">Statically
known function signatures</a><sup><small>XP30</small></sup> are the
<a title="core function" class="termref" href=
"#dt-core-function">core functions</a> defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>, the
constructor functions for all the <span>simple</span> types in the
<a href="http://www.w3.org/TR/xpath-30/#dt-issd">in-scope schema
definitions</a><sup><small>XP30</small></sup>, the additional
functions defined in this specification, the <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> defined in the
stylesheet, plus any <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a> bound using
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> mechanisms
(see <a href="#extension"><i>23 Extensibility and
Fallback</i></a>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It follows from the above that a conformant XSLT processor must
implement the entire library of <a title="core function" class=
"termref" href="#dt-core-function">core functions</a> defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>.</p>
</div>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-collations">statically
known collations</a><sup><small>XP30</small></sup> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. However,
the set of in-scope collations <span class="verb">must</span>
always include the Unicode codepoint collation, defined in <a href=
"http://www.w3.org/TR/xpath-functions-30/#string-compare">Section
5.3 Comparison of strings</a> <sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-collation">default
collation</a><sup><small>XP30</small></sup> is defined by the value
of the <code>[xsl:]default-collation</code> attribute on the
innermost enclosing element that has such an attribute. For
details, see <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-default-collation" id="dt-default-collation" title=
"default collation"></a>In this specification the term <b>default
collation</b> means the collation that is used by XPath operators
such as <code>eq</code> and <code>lt</code> appearing in XPath
expressions within the stylesheet.<span class=
"definition">]</span></p>
<p>This collation is also used by default when comparing strings in
the evaluation of the <a href=
"#element-key"><code>xsl:key</code></a> and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
elements. This <span class="verb">may</span> also (but need not
necessarily) be the same as the default collation used for <a href=
"#element-sort"><code>xsl:sort</code></a> elements within the
stylesheet. Collations used by <a href=
"#element-sort"><code>xsl:sort</code></a> are described in <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>.</p>
</li>
<li>
<p>The <b>base URI</b> is the base URI of the containing element in
the stylesheet. The concept of the base URI of a node is defined in
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup></p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">statically known
documents</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">statically
known collections</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-default-collection">statically
known default collection type</a><sup><small>XP30</small></sup> is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">statically
known decimal formats</a><sup><small>XP30</small></sup> is the set
of decimal formats defined by <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in the stylesheet.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="additional-static-context" id=
"additional-static-context"></a>5.4.2 <a href=
"#additional-static-context" style=
"text-decoration: none">Additional Static Context Components used
by XSLT</a></h4>
<p>Some of the components of the XPath static context are used also
by <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>. For example, the <a href=
"#element-sort"><code>xsl:sort</code></a> element makes use of the
collations defined in the static context, and attributes such as
<code>type</code> and <code>as</code> may reference types defined
in the <a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>.</p>
<p>Many top-level declarations in a stylesheet, and attributes on
the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element, affect the behavior of instructions within the stylesheet.
Each of these constructs is described in its appropriate place in
this specification.</p>
<p>A number of these constructs are of particular significance
because they are used by functions defined in XSLT, which are added
to the library of functions available for use in XPath expressions
within the stylesheet. These are:</p>
<ul>
<li>
<p>The set of named keys, used by the <a href=
"#func-key"><code>key</code></a> function</p>
</li>
<li>
<p>The values of system properties, used by the <a href=
"#func-system-property"><code>system-property</code></a>
function</p>
</li>
<li>
<p>The set of available instructions, used by the <a href=
"#func-element-available"><code>element-available</code></a>
function</p>
</li>
</ul>
<p>A dynamic function call clears the first of these components:
this means that a dynamic call to the <a href=
"#func-key"><code>key</code></a> function will always raise a
dynamic error (the key name is unknown). The values of system
properties and the set of available instructions, by contrast,
reflect the capabilities and configuration of the processor rather
than values specific to the stylesheet code itself; the result of a
dynamic call to <a href=
"#func-system-property"><code>system-property</code></a> or
<a href="#func-element-available"><code>element-available</code></a>
will reflect the information available to the processor at
evaluation time.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If these functions are called within a <a title=
"static expression" class="termref" href=
"#dt-static-expression">static expression</a>, the results will
reflect the capabilities and configuration of the processor used to
perform static analysis, while if they are called elsewhere, the
results should reflect the capabilities and configuration of the
processor used to perform dynamic evaluation, which might give a
different result. These calls should not be pre-evaluated at
compile time unless it is known that this will give the same
result.</p>
</div>
</div>
<div class="div3">
<h4><a name="xpath-dynamic-context" id=
"xpath-dynamic-context"></a>5.4.3 <a href="#xpath-dynamic-context"
style="text-decoration: none">Initializing the Dynamic
Context</a></h4>
<p>For convenience, the dynamic context is described in two parts:
the <a title="focus" class="termref" href="#dt-focus">focus</a>,
which represents the place in the source document that is currently
being processed, and a collection of additional context
variables.</p>
<p>A number of functions specified in <a href=
"#xpath-functions-30">[Functions and Operators]</a> are defined to
be <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
meaning that if they are called twice during the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>, with the same arguments,
then they return the same results (see <a href=
"http://www.w3.org/TR/xpath-functions-30/#terminology">Section 1.6
Terminology</a> <sup><small>FO30</small></sup>). In XSLT, the
execution of a stylesheet defines the execution scope. This means,
for example, that if the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> is called
repeatedly during a transformation, it produces the same result
each time. By implication, the components of the dynamic context on
which these functions depend are also stable for the duration of
the transformation. Specifically, the following components defined
in <a href="http://www.w3.org/TR/xpath-30/#eval_context">Section
2.1.2 Dynamic Context</a> <sup><small>XP30</small></sup> must be
stable: <em>function implementations</em>, <em>current
dateTime</em>, <em>implicit timezone</em>, <em>available
documents</em>, <em>available collections</em>, and <em>default
collection</em>. The values of global variables and stylesheet
parameters are also stable for the duration of a transformation.
The focus is <em>not</em> stable; the additional dynamic context
components defined in <a href=
"#additional-dynamic-context"><i>5.4.4 Additional Dynamic Context
Components used by XSLT</i></a> are also <em>not</em> stable.</p>
<p>As specified in <a href="#xpath-functions-30">[Functions and
Operators]</a>, implementations may provide user options that relax
the requirement for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions (and therefore, by implication, the <a href=
"#func-document"><code>document</code></a> function) to return
stable results. By default, however, the functions must be stable.
The manner in which such user options are provided, if at all, is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>XPath expressions contained in <code>[xsl:]use-when</code>
attributes are not considered to be evaluated "during the
transformation" as defined above. For details see <a href=
"#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-absent" id="dt-absent" title="absent"></a>A component of the
context that has no value is said to be <b>absent</b>.<span class=
"definition">]</span> This is a distinguishable state, and is not
the same as having the empty sequence as its value.</p>
<div class="div4">
<h5><a name="focus" id="focus"></a>5.4.3.1 <a href="#focus" style=
"text-decoration: none">Maintaining Position: the Focus</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus" id="dt-focus" title="focus"></a>When a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated,
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> keeps track of which items are being
processed by means of a set of implicit variables referred to
collectively as the <b>focus</b>.<span class="definition">]</span>
More specifically, the focus consists of the following three
values:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-item" id="dt-context-item" title="context item"></a>The
<b>context item</b> is the item currently being processed. An item
(see <a href="#xpath-datamodel-30">[Data Model]</a>) is either an
atomic value (such as an integer, date, or string), a node,
<span>or a function item</span>. The context item is initially set
to the <span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> supplied
when the transformation is invoked (see <a href=
"#initiating"><i>2.3 Initiating a Transformation</i></a>). It
changes whenever instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; each item in such a sequence
becomes the context item while that item is being
processed.<span class="definition">]</span> The context item is
returned by the XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> <code>.</code> (dot).</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-position" id="dt-context-position" title=
"context position"></a>The <b>context position</b> is the position
of the context item within the sequence of items currently being
processed. It changes whenever the context item changes. When an
instruction such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> or
<a href="#element-for-each"><code>xsl:for-each</code></a> is used
to process a sequence of items, the first item in the sequence is
processed with a context position of 1, the second item with a
context position of 2, and so on.<span class="definition">]</span>
The context position is returned by the XPath <a title="expression"
class="termref" href="#dt-expression">expression</a>
<code>position()</code>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-size" id="dt-context-size" title="context size"></a>The
<b>context size</b> is the number of items in the sequence of items
currently being processed. It changes whenever instructions such as
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; during the processing of each one
of those items, the context size is set to the count of the number
of items in the sequence (or equivalently, the position of the last
item in the sequence).<span class="definition">]</span> The context
size is returned by the XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> <code>last()</code>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-node" id="dt-context-node" title="context node"></a>If
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is a node (as distinct from an
atomic value such as an integer), then it is also referred to as
the <b>context node</b>. The context node is not an independent
variable, it changes whenever the context item changes. When the
context item is an atomic value <span>or a function item</span>,
there is no context node.<span class="definition">]</span> The
context node is returned by the XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a>
<code>self::node()</code>, and it is used as the starting node for
all relative path expressions.</p>
<p>Where the containing element of an XPath expression is an
<a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> or a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, the
initial context item, context position, and context size for the
XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> are the same as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> for the evaluation of the containing instruction or
literal result element.</p>
<p>For an XPath expression contained in a <a title="value template"
class="termref" href="#dt-value-template">value template</a>, the
initial context item, context position, and context size for the
XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> are the same as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> for the evaluation of the containing <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>In other cases (for example, where the containing element is
<a href="#element-sort"><code>xsl:sort</code></a>, <a href=
"#element-with-param"><code>xsl:with-param</code></a>, or <a href=
"#element-key"><code>xsl:key</code></a>), the rules are given in
the specification of the containing element.</p>
<p>The <a href="#func-current"><code>current</code></a> function
can be used within any XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> to select the item that was
supplied as the context item to the XPath expression by the XSLT
processor. Unlike <code>.</code> (dot) this is unaffected by
changes to the context item that occur within the XPath expression.
The <a href="#func-current"><code>current</code></a> function is
described in <a href="#func-current"><i>20.3.1
fn:current</i></a>.</p>
<p>On completion of an instruction that changes the <a title=
"focus" class="termref" href="#dt-focus">focus</a> (such as
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
or <a href="#element-for-each"><code>xsl:for-each</code></a>), the
focus reverts to its previous value.</p>
<p>When a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> is called, the
focus within the body of the function is initially <a title=
"absent" class="termref" href="#dt-absent">absent</a>. The focus is
also <a title="absent" class="termref" href="#dt-absent">absent</a>
on initial entry to the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> if no <span><a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> is
supplied.</p>
<p>When the focus is <a title="absent" class="termref" href=
"#dt-absent">absent</a>, evaluation of any <a title="expression"
class="termref" href="#dt-expression">expression</a> that
references the context item, context position, or context size
results in a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPDY0002" title=
"XPDY0002"><span class="error">[ERR XPDY0002]</span></a>
<sup><small>XP30</small></sup></p>
<p>The description above gives an outline of the way the <a title=
"focus" class="termref" href="#dt-focus">focus</a> works. Detailed
rules for the effect of each instruction are given separately with
the description of that instruction. In the absence of specific
rules, an instruction uses the same focus as its parent
instruction.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-singleton-focus" id="dt-singleton-focus" title=
"singleton focus"></a>A <b>singleton focus</b> based on an item
<var>J</var> has the <span><a title="context item" class="termref"
href="#dt-context-item">context item</a> (and therefore the
<a title="context node" class="termref" href=
"#dt-context-node">context node</a>, if <var>J</var> is a
node)</span> set to <var>J</var>, and the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> both set to 1 (one).<span class="definition">]</span></p>
</div>
<div class="div4">
<h5><a name="evaluation-context" id=
"evaluation-context"></a>5.4.3.2 <a href="#evaluation-context"
style="text-decoration: none">Other Components of the XPath Dynamic
Context</a></h5>
<p>The previous section explained how the <a title="focus" class=
"termref" href="#dt-focus">focus</a> for an XPath expression
appearing in an XSLT stylesheet is initialized. This section
explains how the other components of the <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-context">dynamic
context</a><sup><small>XP30</small></sup> of an XPath expression
are initialized.</p>
<ul>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-variable-values">dynamic
variables</a><sup><small>XP30</small></sup> are the current values
of the in-scope <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding
elements</a>.</p>
</li>
<li>
<p>The <em>current date and time</em> represents an <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during processing of the transformation; it does not change
during the course of the transformation.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-timezone">implicit
timezone</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup>, and the <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">available
collections</a><sup><small>XP30</small></sup> are determined as
part of the process for initiating a transformation (see <a href=
"#initiating"><i>2.3 Initiating a Transformation</i></a>).</p>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup> are defined as part of
the <span>XPath 3.0</span> dynamic context to support the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, but this component is also referenced by the similar XSLT
<a href="#func-document"><code>document</code></a> function: see
<a href="#func-document"><i>20.1 fn:document</i></a>. This variable
defines a mapping between URIs passed to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> function and
the document nodes that are returned.</p>
<p>The mapping from URIs to document nodes is affected by <a href=
"#element-strip-space"><code>xsl:strip-space</code></a>
declarations and by the <code>input-type-annotations</code>
attribute, and may therefore vary from one package to another.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Defining this as part of the evaluation context is a formal way
of specifying that the way in which URIs get turned into document
nodes is outside the control of the language specification, and
depends entirely on the run-time environment in which the
transformation takes place.</p>
</div>
<p>The XSLT-defined <a href=
"#func-document"><code>document</code></a> function allows the use
of URI references containing fragment identifiers. The
interpretation of a fragment identifier depends on the media type
of the resource representation. Therefore, the information supplied
in <a href="http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup> for XSLT processing
must provide not only a mapping from URIs to document nodes as
required by XPath, but also a mapping from URIs to media types.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-default-collection">default
collection</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. This
allows options such as setting the default collection to be an
empty sequence, or to be <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="additional-dynamic-context" id=
"additional-dynamic-context"></a>5.4.4 <a href=
"#additional-dynamic-context" style=
"text-decoration: none">Additional Dynamic Context Components used
by XSLT</a></h4>
<p>In addition to the values that make up the <a title="focus"
class="termref" href="#dt-focus">focus</a>, an XSLT processor
maintains a number of other dynamic context components that reflect
aspects of the evaluation context. These components are fully
described in the sections of the specification that maintain and
use them. They are:</p>
<ul>
<li>
<p>The <a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>, which is the
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> most recently invoked by an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction: see <a href="#apply-imports"><i>6.9 Overriding
Template Rules</i></a>;</p>
</li>
<li>
<p>The <a title="current mode" class="termref" href=
"#dt-current-mode">current mode</a>, which is the <a title="mode"
class="termref" href="#dt-mode">mode</a> set by the most recent
call of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
(for a full definition see <a href="#modes"><i>6.6
Modes</i></a>);</p>
</li>
<li>
<p>The <a title="current group" class="termref" href=
"#dt-current-group">current group</a> and <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a>, which provide
information about the collection of items currently being processed
by an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
<span>or <a href="#element-merge"><code>xsl:merge</code></a></span>
instruction: see <a href="#func-current-group"><i>14.2.1
fn:current-group</i></a>, <a href=
"#func-current-grouping-key"><i>14.2.2
fn:current-grouping-key</i></a>, and <a href="#merging"><i>15
Merging</i></a>;</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In XSLT 3.0 the initial value of these two properties is
"absent", which means that any reference to their values causes a
dynamic error. Previously, the initial value was an empty sequence.
The value is also set to "absent" by an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction that binds variables to the <a title=
"current group value" class="termref" href=
"#dt-current-group-value">current group value</a> and/or <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a>
using the <code>bind-group</code> or <code>bind-grouping-key</code>
attributes.</p>
</div>
</li>
<li>
<p>The <a title="current captured substrings" class="termref" href=
"#dt-current-captured-substrings">current captured substrings</a>:
this is a sequence of strings, which is maintained when a string is
matched against a regular expression using the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction, and which is accessible using the <a href=
"#func-regex-group"><code>regex-group</code></a> function: see
<a href="#func-regex-group"><i>17.2 fn:regex-group</i></a>.</p>
</li>
<li>
<p>The <a title="output state" class="termref" href=
"#dt-output-state">output state</a>: this is a flag whose two
possible values are <a title="final output state" class="termref"
href="#dt-final-output-state">final output state</a> and <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>. This flag
indicates whether instructions are currently writing to a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or to an internal
data structure. The initial setting is <a title=
"final output state" class="termref" href=
"#dt-final-output-state">final output state</a>, and it is switched
to <a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> by
instructions such as <a href=
"#element-variable"><code>xsl:variable</code></a>. For more
details, see <a href="#creating-result-trees"><i>24.1 Creating
Final Result Trees</i></a>.</p>
</li>
</ul>
<p>The following non-normative table summarizes the initial state
of each of the components in the evaluation context, and the
instructions which cause the state of the component to change.</p>
<table border="1" cellpadding="5" summary=
"Components of the dynamic evaluation context" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Component</th>
<th align="left" colspan="1" valign="top">Initial Setting</th>
<th align="left" colspan="1" valign="top">Set by</th>
<th align="left" colspan="1" valign="top">Cleared by</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left"><a title="focus" class="termref"
href="#dt-focus">focus</a></td>
<td valign="top" align="left">singleton focus based on the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> if
supplied</td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span>evaluation of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="current template rule"
class="termref" href="#dt-current-template-rule">current template
rule</a></td>
<td valign="top" align="left">If a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> is supplied
as the entry point to the transformation, then <span><a title=
"absent" class="termref" href="#dt-absent">absent</a></span>;
otherwise the <a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a></td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a></td>
<td valign="top" align="left"><a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>,</span> and
<span>calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, and dynamic
function calls</span>. Also cleared while evaluating global
variables or default values of stylesheet parameters,
<span><a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span>, and the sequence constructors
contained in <a href="#element-key"><code>xsl:key</code></a> and
<a href="#element-sort"><code>xsl:sort</code></a>.</td>
</tr>
<tr>
<td valign="top" align="left"><a title="current mode" class=
"termref" href="#dt-current-mode">current mode</a></td>
<td valign="top" align="left">the initial <a title="mode" class=
"termref" href="#dt-mode">mode</a></td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></span>. Also
cleared while evaluating global variables and stylesheet
parameters, <span><a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span>, and the sequence constructor
contained in <a href="#element-key"><code>xsl:key</code></a> or
<a href="#element-sort"><code>xsl:sort</code></a>. Clearing the
current mode causes the current mode to be set to the default
(unnamed) mode.</td>
</tr>
<tr>
<td valign="top" align="left"><a title="current group" class=
"termref" href="#dt-current-group">current group</a></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href=
"#element-merge"><code>xsl:merge</code></a></span></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, dynamic
function calls</span>, <span>evaluation of global variables,
stylesheet parameters, and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>, calls on <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
a <code>bind-group</code> attribute.</span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="current grouping key"
class="termref" href="#dt-current-grouping-key">current grouping
key</a></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href=
"#element-merge"><code>xsl:merge</code></a></span></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, dynamic
function calls</span>, <span>evaluation of global variables,
stylesheet parameters, and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>, calls on <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
a <code>bind-grouping-key</code> attribute or with a
<code>group-starting-with</code> or <code>group-ending-with</code>
attribute.</span></td>
</tr>
<tr>
<td valign="top" align="left"><a title=
"current captured substrings" class="termref" href=
"#dt-current-captured-substrings">current captured
substrings</a></td>
<td valign="top" align="left">empty sequence</td>
<td valign="top" align="left"><a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a></td>
<td valign="top" align="left"><a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>;
<span>Calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, dynamic
function calls</span>, <span>evaluation of global variables,
stylesheet parameters, and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="output state" class=
"termref" href="#dt-output-state">output state</a></td>
<td valign="top" align="left"><a title="final output state" class=
"termref" href="#dt-final-output-state">final output state</a></td>
<td valign="top" align="left">Set to <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> by
instructions such as <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, etc., and by
calls on <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></td>
<td valign="top" align="left">None</td>
</tr>
</tbody>
</table>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-contextual-function-call" id=
"dt-non-contextual-function-call" title=
"non-contextual function call"></a>The term <b>non-contextual
function call</b> is used to refer to function calls that do not
pass the dynamic context to the called function. This includes all
calls on <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> and all <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-function-invocation">dynamic
function invocations</a><sup><small>XP30</small></sup>, (that is
calls to function items as permitted by XPath 3.0). It does not
include calls to all <a title="core function" class="termref" href=
"#dt-core-function">core functions</a> in particular those that
explicitly depend on the context, such as the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-regex-group"><code>regex-group</code></a> functions. It is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether,
and under what circumstances, calls to <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> are
non-contextual.<span class="definition">]</span></p>
<p>Named function references (such as <code>position#0</code>) and
calls on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> (for
example, <code>function-lookup("position", 0)</code>) are defined
to retain the XPath static and dynamic context at the point of
invocation as part of the closure of the resulting function item,
and to use this preserved context when a dynamic function call is
subsequently made using the function item. This rule does not
extend to the XSLT extensions to the dynamic context defined in
this section. If a dynamic function call is made that depends on
the XSLT part of the dynamic context (for example,
<code>regex-group#1(2)</code>), then the relevant components of the
context are cleared as described in the table above.</p>
</div>
</div>
<div class="div2">
<h3><a name="defining-decimal-format" id=
"defining-decimal-format"></a>5.5 <a href=
"#defining-decimal-format" style="text-decoration: none">Defining a
Decimal Format</a></h3>
<p>The definition of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function is
now in <a href="#xpath-functions-30">[Functions and Operators]</a>.
What remains here is the definition of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration, which provides the context for this function when used
in an XSLT stylesheet.</p>
<p class="element-syntax"><a name="element-decimal-format" id=
"element-decimal-format"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:decimal-format<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;decimal-separator? = <var>char</var><br />
&#160;&#160;grouping-separator? = <var>char</var><br />
&#160;&#160;infinity? = <var>string</var><br />
&#160;&#160;minus-sign? = <var>char</var><br />
&#160;&#160;NaN? = <var>string</var><br />
&#160;&#160;percent? = <var>char</var><br />
&#160;&#160;per-mille? = <var>char</var><br />
&#160;&#160;zero-digit? = <var>char</var><br />
&#160;&#160;digit? = <var>char</var><br />
&#160;&#160;pattern-separator? =
<var>char</var>&#160;/&gt;</code></p>
<p>The <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
element <span>sets the <b>statically known decimal formats</b>
component of the static context for XPath expressions, which</span>
controls the interpretation of a <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a> used by the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-picture-string" id="dt-picture-string" title=
"picture string"></a>The <b>picture string</b> is the string
supplied as the second argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
previously defined in this specification, is now a core function
defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>.</p>
</div>
<p>A <span><a title="package" class="termref" href=
"#dt-package">package</a></span> may contain multiple <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations and may include or import <a title="stylesheet module"
class="termref" href="#dt-stylesheet-module">stylesheet modules</a>
that also contain <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations. The name of an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration is the value of its <code>name</code> attribute, if
any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-decimal-format" id="dt-decimal-format" title=
"decimal format"></a>All the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in a <span>package</span> that share the same name are
grouped into a named <b>decimal format</b>; those that have no name
are grouped into a single unnamed decimal format.<span class=
"definition">]</span></p>
<p>The attributes of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration define the value of the corresponding attribute in the
relevant decimal format in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">Statically
known decimal formats</a><sup><small>XP30</small></sup> component
of the static context for all XPath expressions in the package. The
attribute names used in the XSLT 3.0 syntax are the same as the
attribute names used in the definition of the static context,
except that the <code>digit</code> attribute of <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
corresponds to the <code>digit-sign</code> attribute in the static
context.</p>
<p>The scope of an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a> name
is the package in which it is declared; the name is available for
use only in calls to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> that appear
within the same package.</p>
<p>If a <a title="package" class="termref" href=
"#dt-package">package</a> does not contain a declaration of the
unnamed decimal format, a declaration equivalent to an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
element with no attributes is implied.</p>
<p>The attributes of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration establish values for a number of variables used as
input to the algorithm followed by the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function. An
outline of the purpose of each attribute is given below; however,
the definitive explanations are given <span>as part of the
specification of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup></span>.</p>
<p>For any named <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a>, the effective value of
each attribute is taken from an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration that has that name, and that specifies an explicit
value for the required attribute. If there is no such declaration,
the default value of the attribute is used. If there is more than
one such declaration, the one with highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p>For any unnamed <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a>, the effective value of
each attribute is taken from an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration that is unnamed, and that specifies an explicit value
for the required attribute. If there is no such declaration, the
default value of the attribute is used. If there is more than one
such declaration, the one with highest <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used.</p>
<p><a name="err-XTSE1290" id="err-XTSE1290"><span class=
"error">[ERR XTSE1290]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a named
or unnamed <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a> contains two conflicting
values for the same attribute in different <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations having the same <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>,
unless there is another definition of the same attribute with
higher import precedence.</p>
<p>The following attributes control the interpretation of
characters in the <a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> supplied to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
and also specify characters that may appear in the result of
formatting the number. In each case the value <span class=
"verb">must</span> be a single character <span class="error">[see
<a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.</p>
<ul>
<li>
<p><code>decimal-separator</code> specifies the character used for
the <var>decimal-separator-sign</var>; the default value is the
period character (<code>.</code>)</p>
</li>
<li>
<p><code>grouping-separator</code> specifies the character used for
the <var>grouping-sign</var>, which is typically used as a
thousands separator; the default value is the comma character
(<code>,</code>)</p>
</li>
<li>
<p><code>percent</code> specifies the character used for the
<var>percent-sign</var>; the default value is the percent character
(<code>%</code>)</p>
</li>
<li>
<p><code>per-mille</code> specifies the character used for the
<var>per-mille-sign</var>; the default value is the Unicode
per-mille character (#x2030)</p>
</li>
<li>
<p><code>zero-digit</code> specifies the character used for the
<var>digit-zero-sign</var>; the default value is the digit zero
(<code>0</code>). This character <span class="verb">must</span> be
a digit (category Nd in the Unicode property database), and it
<span class="verb">must</span> have the numeric value zero. This
attribute implicitly defines the Unicode character that is used to
represent each of the values 0 to 9 in the final result string:
Unicode is organized so that each set of decimal digits forms a
contiguous block of characters in numerical sequence.</p>
</li>
</ul>
<p><a name="err-XTSE1295" id="err-XTSE1295"><span class=
"error">[ERR XTSE1295]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
character specified in the <code>zero-digit</code> attribute is not
a digit or is a digit that does not have the numeric value
zero.</p>
<p>The following attributes control the interpretation of
characters in the <a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> supplied to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function. In
each case the value <span class="verb">must</span> be a single
character <span class="error">[see <a href="#err-XTSE0020">ERR
XTSE0020</a>]</span>.</p>
<ul>
<li>
<p><code>digit</code> specifies the character used for the
<var>digit-sign</var> in the <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a>; the default
value is the number sign character (<code>#</code>)</p>
</li>
<li>
<p><code>pattern-separator</code> specifies the character used for
the <var>pattern-separator-sign</var>, which separates positive and
negative sub-pictures in a <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a>; the default
value is the semi-colon character (<code>;</code>)</p>
</li>
</ul>
<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>
<ul>
<li>
<p><code>infinity</code> specifies the string used for the
<var>infinity-symbol</var>; the default value is the string
<code>Infinity</code></p>
</li>
<li>
<p><code>NaN</code> specifies the string used for the
<var>NaN-symbol</var>, which is used to represent the value NaN
(not-a-number); the default value is the string
<code>NaN</code></p>
</li>
<li>
<p><code>minus-sign</code> specifies the character used for the
<var>minus-symbol</var>; the default value is the hyphen-minus
character (<code>-</code>, #x2D). The value <span class=
"verb">must</span> be a single character.</p>
</li>
</ul>
<p><a name="err-XTSE1300" id="err-XTSE1300"><span class=
"error">[ERR XTSE1300]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if, for
any named or unnamed decimal format, the variables representing
characters used in a <a title="picture string" class="termref"
href="#dt-picture-string">picture string</a> do not each have
distinct values. These variables are
<var>decimal-separator-sign</var>, <var>grouping-sign</var>,
<var>percent-sign</var>, <var>per-mille-sign</var>,
<var>digit-zero-sign</var>, <var>digit-sign</var>, and
<var>pattern-separator-sign</var>.</p>
<p>Every (named or unnamed) decimal format defined in a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">package</a> is
added to the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">statically
known decimal formats</a><sup><small>XP30</small></sup> in the
<a href="http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> of every expression in
the <a title="package" class="termref" href=
"#dt-package">package</a>, excluding expressions appearing in
<code>[xsl:]use-when</code> attributes.</p>
</div>
<div class="div2">
<h3><a name="patterns" id="patterns"></a>5.6 <a href="#patterns"
style="text-decoration: none">Patterns</a></h3>
<p>In XSLT 3.0, patterns can match any kind of item: atomic values
and function items as well as nodes.</p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> identifies the
<span>items</span> to which it applies by means of a pattern. As
well as being used in template rules, patterns are used for
numbering (see <a href="#number"><i>12 Numbering</i></a>), for
grouping (see <a href="#grouping"><i>14 Grouping</i></a>), and for
declaring <a title="" class="termref" href="#key">keys</a> (see
<a href="#key"><i>20.2 Keys</i></a>).</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-pattern" id="dt-pattern" title="pattern"></a>A <b>pattern</b>
specifies a set of conditions on an <span>item</span>. An
<span>item</span> that satisfies the conditions matches the
pattern; an <span>item</span> that does not satisfy the conditions
does not match the pattern.<span class="definition">]</span></p>
<p>There are two basic kinds of pattern: <span>predicate</span>
patterns, and path patterns. Patterns may also be formed by
combining other patterns using union, intersection, and difference
operators.</p>
<p>A predicate pattern uses the syntax <code>.[ Expr ]</code>
written with zero or or more predicates in square brackets; it
matches an item if each of the predicates matches the context item.
The detailed semantics are given in <a href=
"#pattern-semantics"><i>5.6.3 The Meaning of a Pattern</i></a>.
This construct can be used to match items of any kind (nodes,
atomic values, and function items). For example, the pattern
<code>.[starts-with(., '$')]</code> matches any string that starts
with the character "$", or a node whose atomized value starts with
"$". This example shows a predicate pattern with a single
predicate, but the grammar allows any number of predicates (zero or
more).</p>
<p>The syntax for <span>path</span> patterns is a subset of the
syntax for <a title="expression" class="termref" href=
"#dt-expression">expressions</a>. <span>Path patterns are used only
for matching nodes; an item other than a node will never match a
path pattern.</span> As explained in detail below, a node matches a
<span>path</span> pattern if the node can be selected by deriving
an equivalent expression, and evaluating this expression with
respect to some possible context.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The specification uses the phrases <em>an item matches a
pattern</em> and <em>a pattern matches an item</em>
interchangeably. They are equivalent: an item matches a pattern if
and only if the pattern matches the item.</p>
</div>
<div class="div3">
<h4><a name="pattern-examples" id="pattern-examples"></a>5.6.1
<a href="#pattern-examples" style="text-decoration: none">Examples
of Patterns</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e13829" id=
"d7e13829"></a>Example: Patterns</div>
<p>Here are some examples of patterns:</p>
<ul>
<li>
<p><code>.</code> matches any item.</p>
</li>
<li>
<p><code>*</code> matches any element.</p>
</li>
<li>
<p><code>para</code> matches any <code>para</code> element.</p>
</li>
<li>
<p><code>chapter|appendix</code> matches any <code>chapter</code>
element and any <code>appendix</code> element.</p>
</li>
<li>
<p><code>olist/entry</code> matches any <code>entry</code> element
with an <code>olist</code> parent.</p>
</li>
<li>
<p><code>appendix//para</code> matches any <code>para</code>
element with an <code>appendix</code> ancestor element.</p>
</li>
<li>
<p><code>schema-element(us:address)</code> matches any element that
is annotated as an instance of the type defined by the schema
element declaration <code>us:address</code>, and whose name is
either <code>us:address</code> or the name of another element in
its substitution group.</p>
</li>
<li>
<p><code>attribute(*, xs:date)</code> matches any attribute
annotated as being of type <code>xs:date</code>.</p>
</li>
<li>
<p><code>/</code> matches a document node.</p>
</li>
<li>
<p><code>document-node()</code> matches a document node.</p>
</li>
<li>
<p><code>document-node(schema-element(my:invoice))</code> matches
the document node of a document whose document element is named
<code>my:invoice</code> and matches the type defined by the global
element declaration <code>my:invoice</code>.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>node()</code> matches any node other than an attribute
node, namespace node, or document node.</p>
</li>
<li>
<p><code>id("W33")</code> matches the element with unique ID
<code>W33</code>.</p>
</li>
<li>
<p><code>para[1]</code> matches any <code>para</code> element that
is the first <code>para</code> child element of its parent. It also
matches a parentless <code>para</code> element.</p>
</li>
<li>
<p><code>//para</code> matches any <code>para</code> element that
has a parent node.</p>
</li>
<li>
<p><code>bullet[position() mod 2 = 0]</code> matches any
<code>bullet</code> element that is an even-numbered
<code>bullet</code> child of its parent.</p>
</li>
<li>
<p><code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element
that has a <code>class</code> attribute with value
<code>appendix</code>.</p>
</li>
<li>
<p><code>@class</code> matches any <code>class</code> attribute
(<em>not</em> any element that has a <code>class</code>
attribute).</p>
</li>
<li>
<p><code>@*</code> matches any attribute node.</p>
</li>
<li>
<p><code>$xyz</code> matches any node that is present in the value
of the variable <code>$xyz</code>.</p>
</li>
<li>
<p><code>$xyz//*</code> matches any element that is a descendant of
a node that is present in the value of the variable
<code>$xyz</code>.</p>
</li>
<li>
<p><code>doc('product.xml')//*</code> matches any element within
the document whose document URI is 'product.xml'.</p>
</li>
<li>
<p><code>.[. instance of node()]</code> matches any node. (Note the
distinction from the pattern <code>node()</code>.)</p>
</li>
<li>
<p><code>.[. instance of xs:date]</code> matches any atomic value
of type <code>xs:date</code> (or a type derived by restriction from
<code>xs:date</code>).</p>
</li>
<li>
<p><code>.[. gt current-date()]</code> matches any date in the
future. It can match an atomic value of type <code>xs:date</code>
or <code>xs:untypedAtomic</code>, or a node whose atomized value is
an <code>xs:date</code> or <code>xs:untypedAtomic</code> value.</p>
</li>
<li>
<p><code>.[starts-with(., 'e')]</code> matches any node or atomic
value that after conversion to a string using the function
conversion rules starts with the letter 'e'.</p>
</li>
<li>
<p><code>.[. instance of function(*)]</code> matches any function
item.</p>
</li>
<li>
<p><code>.[$f(.)]</code> matches any item provided that the call on
the function bound to the variable <code>$f</code> returns a result
whose effective boolean value is true.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="pattern-syntax" id="pattern-syntax"></a>5.6.2 <a href=
"#pattern-syntax" style="text-decoration: none">Syntax of
Patterns</a></h4>
<p><a name="err-XTSE0340" id="err-XTSE0340"><span class=
"error">[ERR XTSE0340]</span></a> Where an attribute is defined to
contain a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, it is a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the pattern
does not match the production <a href=
"#doc-xslt30-patterns-Pattern30">Pattern30</a>.</p>
<p>The grammar for patterns uses the notation defined in <a href=
"http://www.w3.org/TR/xpath-30/#EBNFNotation">Section A.1.1
Notation</a> <sup><small>XP30</small></sup>.</p>
<p>The lexical rules for patterns are the same as the lexical rules
for XPath expressions, as defined in <a href=
"http://www.w3.org/TR/xpath-30/#lexical-structure">Section A.2
Lexical structure</a> <sup><small>XP30</small></sup>. Comments are
permitted between tokens, using the syntax <code>(: ... :)</code>.
All other provisions of the XPath grammar apply where relevant, for
example the rules for whitespace handling and extra-grammatical
constraints.</p>
<h5><a name="d7e14183" id="d7e14183"></a>Patterns</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-Pattern30" id=
"doc-xslt30-patterns-Pattern30"></a>[1]&#160;&#160;&#160;</td>
<td><code>Pattern30</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a> |
<a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PredicatePattern" id=
"doc-xslt30-patterns-PredicatePattern"></a>[2]&#160;&#160;&#160;</td>
<td><code>PredicatePattern</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"." <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-UnionExprP" id=
"doc-xslt30-patterns-UnionExprP"></a>[3]&#160;&#160;&#160;</td>
<td><code>UnionExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>
(("union" | "|") <a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-IntersectExceptExprP" id=
"doc-xslt30-patterns-IntersectExceptExprP"></a>[4]&#160;&#160;&#160;</td>
<td><code>IntersectExceptExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xslt30-patterns-PathExprP">PathExprP</a>
(("intersect" | "except") <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PathExprP" id=
"doc-xslt30-patterns-PathExprP"></a>[5]&#160;&#160;&#160;</td>
<td><code>PathExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-RootedPath">RootedPath</a><br />
| ("/" <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>?)<br />

| ("//" <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>)<br />

| <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-RootedPath" id=
"doc-xslt30-patterns-RootedPath"></a>[6]&#160;&#160;&#160;</td>
<td><code>RootedPath</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-VarRef">VarRef</a><sup><small>XP30</small></sup>
| <a href="#doc-xslt30-patterns-FunctionCallP">FunctionCallP</a>)
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup>
(("/" | "//") <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-FunctionCallP" id=
"doc-xslt30-patterns-FunctionCallP"></a>[7]&#160;&#160;&#160;</td>
<td><code>FunctionCallP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-OuterFunctionName">OuterFunctionName</a>
<a href=
"#doc-xslt30-patterns-ArgumentListP">ArgumentListP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-OuterFunctionName" id=
"doc-xslt30-patterns-OuterFunctionName"></a>[8]&#160;&#160;&#160;</td>
<td><code>OuterFunctionName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"doc" | "id" | "element-with-id" | "key" | <a href=
"#doc-xslt30-patterns-PrefixedQName">PrefixedQName</a> | <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-URIQualifiedName">URIQualifiedName</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ArgumentListP" id=
"doc-xslt30-patterns-ArgumentListP"></a>[10]&#160;&#160;&#160;</td>
<td><code>ArgumentListP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href=
"#doc-xslt30-patterns-ArgumentP">ArgumentP</a> ("," <a href=
"#doc-xslt30-patterns-ArgumentP">ArgumentP</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ArgumentP" id=
"doc-xslt30-patterns-ArgumentP"></a>[11]&#160;&#160;&#160;</td>
<td><code>ArgumentP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-VarRef">VarRef</a><sup><small>XP30</small></sup>
| <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Literal">Literal</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-RelativePathExprP" id=
"doc-xslt30-patterns-RelativePathExprP"></a>[12]&#160;&#160;&#160;</td>
<td><code>RelativePathExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xslt30-patterns-StepExprP">StepExprP</a>
(("/" | "//") <a href=
"#doc-xslt30-patterns-StepExprP">StepExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-StepExprP" id=
"doc-xslt30-patterns-StepExprP"></a>[13]&#160;&#160;&#160;</td>
<td><code>StepExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-PostfixExprP">PostfixExprP</a> | <a href=
"#doc-xslt30-patterns-AxisStepP">AxisStepP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PostfixExprP" id=
"doc-xslt30-patterns-PostfixExprP"></a>[14]&#160;&#160;&#160;</td>
<td><code>PostfixExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ParenthesizedExprP" id=
"doc-xslt30-patterns-ParenthesizedExprP"></a>[15]&#160;&#160;&#160;</td>
<td><code>ParenthesizedExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-AxisStepP" id=
"doc-xslt30-patterns-AxisStepP"></a>[16]&#160;&#160;&#160;</td>
<td><code>AxisStepP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-ForwardStepP">ForwardStepP</a> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ForwardStepP" id=
"doc-xslt30-patterns-ForwardStepP"></a>[17]&#160;&#160;&#160;</td>
<td><code>ForwardStepP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NodeTest">NodeTest</a><sup><small>XP30</small></sup>)
| <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-AbbrevForwardStep">AbbrevForwardStep</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ForwardAxisP" id=
"doc-xslt30-patterns-ForwardAxisP"></a>[18]&#160;&#160;&#160;</td>
<td><code>ForwardAxisP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PrefixedQName" id=
"doc-xslt30-patterns-PrefixedQName"></a>[122]&#160;&#160;&#160;</td>
<td><code>PrefixedQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NCName">NCName</a><sup><small>XP30</small></sup>
":" <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NCName">NCName</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
</table>
<p>The names of these constructs are chosen to align with the XPath
3.0 grammar. Constructs whose names are suffixed with
<code>P</code> are restricted forms of the corresponding XPath 3.0
construct without the suffix. Constructs labelled with the suffix
"XP30" are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p>In a <a href=
"#doc-xslt30-patterns-FunctionCallP">FunctionCallP</a>, the
<code>EQName</code> used for the function name must have local part
<code>doc</code>, <code>id</code>, <code>element-with-id</code>, or
<code>key</code>, and must use the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>
either explicitly or implicitly.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As with XPath expressions, the pattern <code>/ union /*</code>
can be parsed in two different ways, and the chosen interpretation
is to treat <code>union</code> as an element name rather than as an
operator. The other interpretation can be achieved by writing
<code>(/) union (/*)</code></p>
</div>
</div>
<div class="div3">
<h4><a name="pattern-semantics" id="pattern-semantics"></a>5.6.3
<a href="#pattern-semantics" style="text-decoration: none">The
Meaning of a Pattern</a></h4>
<p>The meaning of a pattern is defined formally as follows, where
"if" is to be read as "if and only if".</p>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a>
<var>PP</var>, then it matches an item <var>J</var> if the XPath
expression taking the same form as <var>PP</var> returns a
non-empty sequence when evaluated with a <a title="singleton focus"
class="termref" href="#dt-singleton-focus">singleton focus</a>
based on <var>J</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The pattern <code>.</code>, which is a
<code>PredicatePattern</code> with an empty
<code>PredicateList</code>, matches every item.</p>
<p>A predicate with the numeric value 1 (one) always matches, and a
predicate with any other numeric value never matches. Numeric
predicates in a <code>PredicatePattern</code> are therefore not
useful, but are defined this way in the interests of consistency
with XPath.</p>
</div>
<p>Otherwise (the pattern is a <code>PathPattern</code>), the
pattern is converted to an <a title="expression" class="termref"
href="#dt-expression">expression</a>, called the <b>equivalent
expression</b>. The equivalent expression to a <a href=
"#doc-xslt30-patterns-Pattern30">Pattern</a> is the XPath
expression that takes the same lexical form as the
<code>Pattern</code> as written, with the following adjustment:</p>
<ul>
<li>
<p><span>If any <code>PathExprP</code> in the <code>Pattern</code>
is a <code>RelativePathExprP</code>, then the first
<code>StepExprP</code> <var>PS</var> of this
<code>RelativePathExprP</code></span> is adjusted to allow it to
match a parentless element, attribute, or namespace node. The
adjustment depends on the axis used in this step, whether it
appears explicitly or implicitly (according to the rules of
<a href="http://www.w3.org/TR/xpath-30/#abbrev">Section 3.3.5
Abbreviated Syntax</a> <sup><small>XP30</small></sup>), and is made
as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>NodeTest</code> in <var>PS</var> is
<code>document-node()</code> (optionally with arguments), and if no
explicit axis is specified, then the axis in step <var>PS</var> is
taken as <code>self</code> rather than <code>child</code>.</p>
</li>
<li>
<p>If <var>PS</var> uses the child axis (explicitly or implicitly),
and if the <code>NodeTest</code> in <var>PS</var> is not
<code>document-node()</code> (optionally with arguments), then the
axis in step <var>PS</var> is replaced by
<code>child-or-top</code>, which is defined as follows. If the
context node is a parentless element, comment,
processing-instruction, or text node then the
<code>child-or-top</code> axis selects the context node; otherwise
it selects the children of the context node. It is a forwards axis
whose principal node kind is element.</p>
</li>
<li>
<p>If <var>PS</var> uses the attribute axis (explicitly or
implicitly), then the axis in step <var>PS</var> is replaced by
<code>attribute-or-top</code>, which is defined as follows. If the
context node is an attribute node with no parent, then the
<code>attribute-or-top</code> axis selects the context node;
otherwise it selects the attributes of the context node. It is a
forwards axis whose principal node kind is attribute.</p>
</li>
<li>
<p>If <var>PS</var> uses the namespace axis <span>(explicitly or
implicitly)</span>, then the axis in step <var>PS</var> is replaced
by <code>namespace-or-top</code>, which is defined as follows. If
the context node is a namespace node with no parent, then the
<code>namespace-or-top</code> axis selects the context node;
otherwise it selects the namespace nodes of the context node. It is
a forwards axis whose principal node kind is namespace.</p>
</li>
</ol>
<p>The axes <code>child-or-top</code>,
<code>attribute-or-top</code>, and <code>namespace-or-top</code>
are introduced only for definitional purposes. They cannot be used
explicitly in a user-written pattern or expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this adjustment is to ensure that a pattern such
as <code>person</code> matches any element named
<code>person</code>, even if it has no parent; and similarly, that
the pattern <code>@width</code> matches any attribute named
<code>width</code>, even a parentless attribute. The rule also
ensures that a pattern using a <code>NodeTest</code> of the form
<code>document-node(...)</code> matches a document node. The
pattern <code>node()</code> will match any element, text node,
comment, or processing instruction, whether or not it has a parent.
For backwards compatibility reasons, the pattern
<code>node()</code>, when used without an explicit axis, does not
match document nodes, attribute nodes, or namespace nodes. The
rules are also phrased to ensure that positional patterns of the
form <code>para[1]</code> continue to count nodes relative to their
parent, if they have one. <span>To match any node at all, XSLT 3.0
allows the pattern <code>.[. instance of node()]</code> to be
used.</span></p>
</div>
</li>
</ul>
<p>The meaning of the pattern is then defined in terms of the
semantics of the equivalent expression, denoted below as
<code>EE</code>.</p>
<p>Specifically, an item <var>N</var> matches a pattern
<var>P</var> if the following applies, where <code>EE</code> is the
<b>equivalent expression</b> to <var>P</var>:</p>
<ol class="enumar">
<li>
<p><var>N</var> is a node, and the result of evaluating the
expression <code>root(.)//(EE)</code> with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>N</var> is
a sequence that includes the node <var>N</var></p>
</li>
</ol>
<p>If a pattern appears <span>in an attribute of an element that is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span> (see <a href=
"#backwards"><i>3.10 Backwards Compatible Processing</i></a>), then
the semantics of the pattern are defined on the basis that the
equivalent XPath expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
true.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e14752" id=
"d7e14752"></a>Example: The Semantics of Path Patterns</div>
<p>The path pattern <code>p</code> matches any <code>p</code>
element, because a <code>p</code> element will always be present in
the result of evaluating the <a title="expression" class="termref"
href="#dt-expression">expression</a>
<code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code>
matches a document node, and only a document node, because the
result of the <a title="expression" class="termref" href=
"#dt-expression">expression</a> <code>root(.)//(/)</code> returns
the root node of the tree containing the context node if and only
if it is a document node.</p>
<p>The path pattern <code>node()</code> matches all nodes selected
by the expression <code>root(.)//(child-or-top::node())</code>,
that is, all element, text, comment, and processing instruction
nodes, whether or not they have a parent. It does not match
attribute or namespace nodes because the expression does not select
nodes using the attribute or namespace axes. It does not match
document nodes because for backwards compatibility reasons the
<code>child-or-top</code> axis does not match a document node.</p>
<p>The path pattern <code>$V</code> matches all nodes selected by
the expression <code>root(.)//($V)</code>, that is, all nodes in
the value of $V (which will typically be a global variable, though
when the pattern is used in contexts such as the <a href=
"#element-number"><code>xsl:number</code></a> or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instructions, it can also be a local variable).</p>
<p>The path pattern <code>doc('product.xml')//product</code>
matches all nodes selected by the expression
<code>root(.)//(doc('product.xml')//product)</code>, that is, all
<code>product</code> elements in the document whose URI is
<code>product.xml</code>.</p>
</div>
<p>Although the semantics of path patterns are specified formally
in terms of expression evaluation, it is possible to understand
pattern matching using a different model. A path pattern such as
<code>book/chapter/section</code> can be examined from right to
left. A node will only match this pattern if it is a
<code>section</code> element; and then, only if its parent is a
<code>chapter</code>; and then, only if the parent of that
<code>chapter</code> is a <code>book</code>. When the pattern uses
the <code>//</code> operator, one can still read it from right to
left, but this time testing the ancestors of a node rather than its
parent. For example <code>appendix//section</code> matches every
<code>section</code> element that has an ancestor
<code>appendix</code> element.</p>
<p>The formal definition, however, is useful for understanding the
meaning of a pattern such as <code>para[1]</code>. This matches any
node selected by the expression
<code>root(.)//(child-or-top::para[1])</code>: that is, any
<code>para</code> element that is the first <code>para</code> child
of its parent, or a <code>para</code> element that has no
parent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation, of course, may use any algorithm it wishes
for evaluating patterns, so long as the result corresponds with the
formal definition above. An implementation that followed the formal
definition by evaluating the equivalent expression and then testing
the membership of a specific node in the result would probably be
very inefficient.</p>
</div>
</div>
<div class="div3">
<h4><a name="pattern-errors" id="pattern-errors"></a>5.6.4 <a href=
"#pattern-errors" style="text-decoration: none">Errors in
Patterns</a></h4>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> or <a title="type error"
class="termref" href="#dt-type-error">type error</a> that occurs
during the evaluation of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> against a particular <span>item</span>
has the effect that the item being tested is treated as not
matching the pattern. The error does not cause the transformation
to fail, and cannot be caught by a try/catch expression surrounding
the instruction that causes the pattern to be evaluated.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for this provision is that it is difficult for the
stylesheet author to predict which predicates in a pattern will
actually be evaluated. In the case of match patterns in template
rules, it is not even possible to predict which patterns will be
evaluated against a particular node.</p>
<p>There is a risk that ignoring errors in this way may make
programming mistakes harder to debug. Implementations may mitigate
this by providing warnings or other diagnostics when evaluation of
a pattern triggers an error condition.</p>
<p>Static errors in patterns, including dynamic and type errors
that are signaled statically as permitted by the specification, are
reported in the normal way and cause the transformation to
fail.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="value-templates" id="value-templates"></a>5.7 <a href=
"#value-templates" style="text-decoration: none">Value
Templates</a></h3>
<p>The string value of an attribute or text node in the stylesheet
may in particular circumstances contain embedded expressions
enclosed between curly brackets. Attributes and text nodes that use
(or are permitted to use) this mechanism are referred to
respectively as <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value templates</a>
and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates.</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-value-template" id="dt-value-template" title=
"value template"></a>Collectively, attribute value templates and
text value templates are referred to as <b>value
templates</b>.<span class="definition">]</span></p>
<p>A value template is a string consisting of an alternating
sequence of fixed parts and variable parts. A variable part
consists of an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> enclosed in curly brackets
(<code>{}</code>). A fixed part may contain any characters, except
that a left curly bracket <span class="verb">must</span> be written
as <code>{{</code> and a right curly bracket <span class=
"verb">must</span> be written as <code>}}</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An expression within a variable part may contain an unescaped
curly bracket within a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-StringLiteral">StringLiteral</a><sup><small>XP30</small></sup>
or within a comment.</p>
<p>Currently no XPath expression starts with an opening curly
bracket, so the use of <code>{{</code> creates no ambiguity. If an
enclosed expression ends with a closing curly bracket, no
whitespace is required between this and the closing delimiter.</p>
</div>
<p><a name="err-XTSE0350" id="err-XTSE0350"><span class=
"error">[ERR XTSE0350]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
unescaped left curly bracket appears in a fixed part of a value
template without a matching right curly bracket.</p>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the string contained between
matching curly brackets in a value template does not match the
XPath production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>,
or if it contains other XPath static errors. The error is signaled
using the appropriate XPath error code.</p>
<p><a name="err-XTSE0370" id="err-XTSE0370"><span class=
"error">[ERR XTSE0370]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
unescaped right curly bracket occurs in a fixed part of a value
template.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-effective-value" id="dt-effective-value" title=
"effective value"></a>The result of evaluating a value template is
referred to as its <b>effective value</b>.<span class=
"definition">]</span> The effective value is the string obtained by
concatenating the expansions of the fixed and variable parts:</p>
<ul>
<li>
<p>The expansion of a fixed part is obtained by replacing any
double curly brackets (<code>{{</code> or <code>}}</code>) by the
corresponding single curly bracket.</p>
</li>
<li>
<p>The expansion of a variable part is obtained by evaluating the
enclosed XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> and converting the resulting value
to a string. This conversion is done using the rules given in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This process can generate dynamic errors, for example if the
sequence contains an element with a complex content type (which
cannot be atomized).</p>
</div>
<p>In the case of an attribute value template, the effective value
becomes the string value of the new attribute node. In the case of
a text value template, the effective value becomes the string value
of the new text node.</p>
<div class="div3">
<h4><a name="attribute-value-templates" id=
"attribute-value-templates"></a>5.7.1 <a href=
"#attribute-value-templates" style=
"text-decoration: none">Attribute Value Templates</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-attribute-value-template" id="dt-attribute-value-template"
title="attribute value template"></a>In an attribute that is
designated as an <b>attribute value template</b>, such as an
attribute of a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>, an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> can be used by surrounding the
expression with curly brackets (<code>{}</code>), following the
general rules for <a title="value template" class="termref" href=
"#dt-value-template">value templates</a><span class=
"definition">]</span>.</p>
<p>Curly brackets are not treated specially in an attribute value
in an XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> unless the attribute is
specifically designated as one that permits an attribute value
template; in an element syntax summary, the value of such
attributes is surrounded by curly brackets.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Not all attributes are designated as attribute value templates.
Attributes whose value is an <a title="expression" class="termref"
href="#dt-expression">expression</a> or <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a>, attributes of <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> elements and attributes that
refer to named XSLT objects are generally not designated as
attribute value templates (an exception is the <code>format</code>
attribute of <a href=
"#element-result-document"><code>xsl:result-document</code></a>).
Namespace declarations are not XDM attribute nodes and are
therefore never treated as attribute value templates.</p>
</div>
<p><span>If the element containing the attribute is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then the rules for
converting the value of the expression to a string (given in
<a href="#value-templates"><i>5.7 Value Templates</i></a>) are
modified as follows. After <a title="atomize" class="termref" href=
"#dt-atomization">atomizing</a> the result of the expression, all
items other than the first item in the resulting sequence are
discarded, and the effective value is obtained by converting the
first item in the sequence to a string. If the atomized sequence is
empty, the result is a zero-length string.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above rule applies to attribute value templates but not to
text value templates, since the latter were not available in XSLT
1.0.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e15070" id=
"d7e15070"></a>Example: Attribute Value Templates</div>
<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of
the <code>src</code> and <code>width</code> attributes are computed
using XPath expressions enclosed in attribute value templates:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>With this source</p>
<div class="exampleInner">
<pre>
&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;
</pre></div>
<p>the result would be</p>
<div class="exampleInner">
<pre>
&lt;img src="/images/headquarters.jpg" width="300"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e15097" id=
"d7e15097"></a>Example: Producing a Space-Separated List</div>
<p>The following example shows how the values in a sequence are
output as a space-separated list. The following literal result
element:</p>
<div class="exampleInner">
<pre>
&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;
</pre></div>
<p>produces the output node:</p>
<div class="exampleInner">
<pre>
&lt;temperature readings="10.32 5.5 8.31"/&gt;
</pre></div>
</div>
<p>Curly brackets are <em>not</em> recognized recursively inside
expressions.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e15113" id=
"d7e15113"></a>Example: Curly Brackets can not be Nested</div>
<p>For example:</p>
<div class="exampleInner">
<pre>
&lt;a href="#{id({@ref})/title}"&gt;
</pre></div>
<p>is <em>not</em> allowed. Instead, use simply:</p>
<div class="exampleInner">
<pre>
&lt;a href="#{id(@ref)/title}"&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="text-value-templates" id=
"text-value-templates"></a>5.7.2 <a href="#text-value-templates"
style="text-decoration: none">Text Value Templates</a></h4>
<p>The <a title="standard attributes" class="termref" href=
"#dt-standard-attributes">standard attribute</a>
<code>[xsl:]expand-text</code> may appear on any element in the
stylesheet, and determines whether descendant text nodes of that
element are treated as text value templates. A text node in the
stylesheet is treated as a text value template if (a) it is part of
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, (b) there is
an ancestor element with an <code>[xsl:]expand-text</code>
attribute, and (c) on the innermost ancestor element that has such
an attribute, the value of the attribute is <code>yes</code>. The
value of the attribute <span class="verb">must</span> be
<code>yes</code> or <code>no</code>.</p>
<p>This section describes how text nodes appearing in sequence
constructors are processed when the effective value is
<code>yes</code>. Such text nodes are referred to as text value
templates.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-text-value-template" id="dt-text-value-template" title=
"text value template"></a>In a text node that is designated as a
<b>text value template</b>, <a title="expression" class="termref"
href="#dt-expression">expressions</a> can be used by surrounding
each expression with curly brackets (<code>{}</code>).<span class=
"definition">]</span></p>
<p>The rules for text value templates are given in <a href=
"#value-templates"><i>5.7 Value Templates</i></a>. A text node in a
sequence constructor whose value is a text value template results
in the construction of a text node in the result of the sequence
constructor. The string value of that text node is obtained by
computing the effective value of the value template.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The content of an <a href=
"#element-text"><code>xsl:text</code></a> element is not a sequence
constructor, and therefore cannot contain a text value
template.</p>
<p>The result of evaluating a text value template is a (possibly
zero-length) text node. This text node becomes part of the result
of the containing sequence constructor, and is thereafter handled
exactly as if the value had appeared explicitly as a text node in
the stylesheet.</p>
<p>The way in which the effective value is computed does not depend
on any <code>separator</code> attribute on a containing <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction.
The <code>separator</code> attribute only affects how the text node
is combined with adjacent items in the result of the containing
sequence constructor.</p>
<p>Fixed parts consisting entirely of whitespace are significant
and are handled in the same way as any other fixed part. This is
different from the default treatment of "boundary space" in
XQuery.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e15203" id=
"d7e15203"></a>Example: Using a text value template to construct
message output</div>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={$id}, step={$step}&lt;/xsl:message&gt;
</pre></div>
<p>This will typically output the message text <code>Processing
id=A123, step=5</code>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e15213" id=
"d7e15213"></a>Example: Using a text value template to define the
result of a function</div>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  {$x + $y}
&lt;/xsl:function&gt;
</pre></div>
<p>Note that although this is a very readable way of expressing the
computation performed by the function, the semantics are somewhat
complex, and this could mean that execution is inefficient. The
function computes the value of <code>$x + $y</code> as an integer,
and then constructs a text node containing the string
representation of this integer (preceded and followed by
whitespace). Because the declared result type of the function is
<code>xs:integer</code>, this text node is then atomized, giving an
<code>xs:untypedAtomic</code> value, and the
<code>xs:untypedAtomic</code> value is then cast to an
<code>xs:integer</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The main motivations for adding text value templates to the XSLT
language are firstly, to make it easier to construct parameterized
text in contexts such as <a href=
"#element-value-of"><code>xsl:value-of</code></a> and <a href=
"#element-message"><code>xsl:message</code></a>, and secondly, to
allow use of complex multi-line XPath expressions where maintaining
correct indentation is important for readability. The fact that XML
processors are required to normalize whitespace in attribute values
means that writing such expressions within a <code>select</code>
attribute is not ideal.</p>
<p>The facility is only present if enabled using the
<code>[xsl:]expand-text</code> attribute. This is partly for
backwards compatibility, and partly to avoid creating difficulties
when constructing content that is rich in curly brackets, for
example Javascript code or CSS style sheets.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sequence-constructors" id=
"sequence-constructors"></a>5.8 <a href="#sequence-constructors"
style="text-decoration: none">Sequence Constructors</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sequence-constructor" id="dt-sequence-constructor" title=
"sequence constructor"></a>A <b>sequence constructor</b> is a
sequence of zero or more sibling nodes in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> that can be
evaluated to return a sequence of nodes, atomic values, <span>and
function items</span>. The way that the resulting sequence is used
depends on the containing instruction.<span class=
"definition">]</span></p>
<p>Many <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>, and also <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>, are
defined to take a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> as their
content.</p>
<p>Four kinds of nodes may be encountered in a sequence
constructor:</p>
<ol class="enumar">
<li>
<p>A <em>Text node</em> appearing in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not
been removed in the process of whitespace stripping: see <a href=
"#stylesheet-stripping"><i>4.2 Stripping Whitespace from the
Stylesheet</i></a>) is <span>processed as follows:</span></p>
<ol class="enumla">
<li>
<p>if the effective value of the standard attribute
<code>[xsl:]expand-text</code> is <code>no</code>, or in the
absence of this attribute, the text node in the stylesheet is
copied to create a new parentless text node in the result of the
sequence constructor.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For an <a href="#element-text"><code>xsl:text</code></a>
element, the effective value of <code>[xsl:]expand-text</code> is
always "no".</p>
</div>
</li>
<li>
<p>Otherwise (the effective value of <code>[xsl:]expand-text</code>
is <code>yes</code>), the text node in the stylesheet is processed
as described in <a href="#text-value-templates"><i>5.7.2 Text Value
Templates</i></a>.</p>
</li>
</ol>
</li>
<li>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> is
evaluated to create a new parentless element node, having the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the literal result
element: see <a href="#literal-result-element"><i>11.1 Literal
Result Elements</i></a>.</p>
</li>
<li>
<p>An XSLT <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> produces a sequence of zero, one,
or more items as its result. For most XSLT instructions, these
items are nodes, but some instructions (<span>such as</span>
<a href="#element-sequence"><code>xsl:sequence</code></a> and
<a href="#element-copy-of"><code>xsl:copy-of</code></a>) can also
produce atomic values <span>or function items</span>. Several
instructions, such as <a href=
"#element-element"><code>xsl:element</code></a>, return a newly
constructed parentless node (which may have its own attributes,
namespaces, children, and other descendants). Other instructions,
such as <a href="#element-if"><code>xsl:if</code></a>, pass on the
items produced by their own nested sequence constructors. The
<a href="#element-sequence"><code>xsl:sequence</code></a>
instruction may return atomic values, <span>function items</span>,
or existing nodes.</p>
</li>
<li>
<p>An <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>)
also produces a sequence of items as its result.</p>
</li>
</ol>
<p>The result of evaluating a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> is the sequence of items formed by concatenating
the results of evaluating each of the nodes in the sequence
constructor, retaining order.</p>
<p>There are several ways the result of a sequence constructor may
be used.</p>
<ul>
<li>
<p>The sequence may be bound to a variable or returned from a
stylesheet function, in which case it becomes available as a value
to be manipulated in arbitrary ways by XPath expressions. The
sequence is bound to a variable when the sequence constructor
appears within one of the elements <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a>, when this
instruction has an <code>as</code> attribute. The sequence is
returned from a stylesheet function when the sequence constructor
appears within the <a href=
"#element-function"><code>xsl:function</code></a> element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This will typically expose to the stylesheet elements,
attributes, and other nodes that have not yet been attached to a
parent node in a <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. The semantics of XPath
expressions when applied to parentless nodes are well-defined;
however, such expressions should be used with care. For example,
the expression <code>/</code> causes a type error if the root of
the tree containing the context node is not a document node.</p>
<p>Parentless attribute nodes require particular care because they
have no namespace nodes associated with them. A parentless
attribute node is not permitted to contain namespace-sensitive
content (for example, a QName or an XPath expression) because there
is no information enabling the prefix to be resolved to a namespace
URI. Parentless attributes can be useful in an application (for
example, they provide an alternative to the use of attribute sets:
see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>)
but they need to be handled with care.</p>
</div>
</li>
<li>
<p>The sequence may be returned as the result of the containing
element. This happens when the <span>element</span> containing the
sequence constructor is <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<span><a href="#element-break"><code>xsl:break</code></a></span>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<span><a href="#element-catch"><code>xsl:catch</code></a></span>,
<a href="#element-choose"><code>xsl:choose</code></a>, <a href=
"#element-fallback"><code>xsl:fallback</code></a>, <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href="#element-fork"><code>xsl:fork</code></a></span>,
<a href="#element-if"><code>xsl:if</code></a>, <span><a href=
"#element-iterate"><code>xsl:iterate</code></a></span>, <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a>,
<a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>,
<span><a href=
"#element-on-completion"><code>xsl:on-completion</code></a></span>,
<a href="#element-otherwise"><code>xsl:otherwise</code></a>,
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-sequence"><code>xsl:sequence</code></a>,
<span><a href="#element-try"><code>xsl:try</code></a></span>, or
<a href="#element-when"><code>xsl:when</code></a>.</p>
</li>
<li>
<p>The sequence may be used to construct the content of a new
element or document node. This happens when the sequence
constructor appears as the content of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or of one
of the instructions <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-assert"><code>xsl:assert</code></a></span>,
or <a href="#element-message"><code>xsl:message</code></a>. It also
happens when the sequence constructor is contained in one of the
elements <a href="#element-variable"><code>xsl:variable</code></a>,
<a href="#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a>, when this
instruction has no <code>as</code> attribute. For details, see
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>.</p>
</li>
<li>
<p>The sequence may be used to construct the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an attribute node, text node, namespace node, comment
node, or processing instruction node. This happens when the
sequence constructor is contained in one of the elements <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-value-of"><code>xsl:value-of</code></a>, <a href=
"#element-namespace"><code>xsl:namespace</code></a>, <a href=
"#element-comment"><code>xsl:comment</code></a>, or <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>.
For details, see <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
</li>
</ul>
<div class="div3">
<h4><a name="constructing-complex-content" id=
"constructing-complex-content"></a>5.8.1 <a href=
"#constructing-complex-content" style=
"text-decoration: none">Constructing Complex Content</a></h4>
<p>This section describes how the sequence obtained by evaluating a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> may be used to
construct the children of a newly constructed document node, or the
children, attributes and namespaces of a newly constructed element
node. The sequence of items may be obtained by evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in an
instruction such as <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>, or
a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
<p>When constructing the content of an element, the
<code>inherit-namespaces</code> attribute of the <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a> instruction, or the
<code>xsl:inherit-namespaces</code> property of the literal result
element, determines whether namespace nodes are to be inherited.
The effect of this attribute is described in the rules that
follow.</p>
<p>The sequence is processed as follows (applying the rules in the
order they are listed):</p>
<ol class="enumar">
<li>
<p>The containing instruction may generate attribute nodes and/or
namespace nodes, as specified in the rules for the individual
instruction. For example, these nodes may be produced by expanding
an <code>[xsl:]use-attribute-sets</code> attribute, or by expanding
the attributes of a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a>. Any such nodes are prepended to the sequence produced
by evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>.</p>
</li>
<li>
<p>Any atomic value in the sequence is cast to a string.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code>
to <code>xs:string</code> always succeeds, because these values
retain a prefix for this purpose. However, there is no guarantee
that the prefix used will always be meaningful in the context where
the resulting string is used.</p>
</div>
</li>
<li>
<p>Any consecutive sequence of strings within the result sequence
is converted to a single text node, whose <a title="string value"
class="termref" href="#dt-string-value">string value</a> contains
the content of each of the strings in turn, with a single space
(#x20) used as a separator between successive strings.</p>
</li>
<li>
<p>Any document node within the result sequence is replaced by a
sequence containing each of its children, in document order.</p>
</li>
<li>
<p>Zero-length text nodes within the result sequence are
removed.</p>
</li>
<li>
<p>Adjacent text nodes within the result sequence are merged into a
single text node.</p>
</li>
<li>
<p>Invalid <span>items in the result sequence</span> are detected
as follows.</p>
<p><a name="err-XTDE0410" id="err-XTDE0410"><span class=
"error">[ERR XTDE0410]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence used to construct the content of an element node
contains a namespace node or attribute node that is preceded in the
sequence by a node that is neither a namespace node nor an
attribute node.</p>
<p><a name="err-XTDE0420" id="err-XTDE0420"><span class=
"error">[ERR XTDE0420]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence used to construct the content of a document node
contains a namespace node or attribute node.</p>
<p><a name="err-XTDE0430" id="err-XTDE0430"><span class=
"error">[ERR XTDE0430]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains two or more namespace nodes having the
same name but different <a title="string value" class="termref"
href="#dt-string-value">string values</a> (that is, namespace nodes
that map the same prefix to different namespace URIs).</p>
<p><a name="err-XTDE0440" id="err-XTDE0440"><span class=
"error">[ERR XTDE0440]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains a namespace node with no name and the
element node being constructed has a null namespace URI (that is,
it is an error to define a default namespace when the element is in
no namespace).</p>
<p><a name="err-XTDE0450" id="err-XTDE0450"><span class=
"error">[ERR XTDE0450]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains a function item.</p>
</li>
<li>
<p>If the result sequence contains two or more namespace nodes with
the same name (or no name) and the same <a title="string value"
class="termref" href="#dt-string-value">string value</a> (that is,
two namespace nodes mapping the same prefix to the same namespace
URI), then all but one of the duplicate nodes are discarded.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since the order of namespace nodes is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, it is
not significant which of the duplicates is retained.</p>
</div>
</li>
<li>
<p>If an attribute <var>A</var> in the result sequence has the same
name as another attribute <var>B</var> that appears later in the
result sequence, then attribute <var>A</var> is discarded from the
result sequence. Before discarding attribute <var>A</var>, the
processor <span class="verb">may</span> signal any <a title=
"type error" class="termref" href="#dt-type-error">type errors</a>
that would be signaled if attribute <var>B</var> were not
present.</p>
</li>
<li>
<p>Each node in the resulting sequence is attached as a namespace,
attribute, or child of the newly constructed element or document
node. Conceptually this involves making a deep copy of the node; in
practice, however, copying the node will only be necessary if the
existing node can be referenced independently of the parent to
which it is being attached. When copying an element or processing
instruction node, its base URI property is changed to be the same
as that of its new parent, unless it has an <code>xml:base</code>
attribute (see <a href="#xmlbase">[XML Base]</a>) that overrides
this. If the copied element has an <code>xml:base</code> attribute,
its base URI is the value of that attribute, resolved (if it is
relative) against the base URI of the new parent node.</p>
</li>
<li>
<p>If the newly constructed node is an element node, then namespace
fixup is applied to this node, as described in <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p>
</li>
<li>
<p>If the newly constructed node is an element node, and if
namespaces are inherited, then each namespace node of the newly
constructed element (including any produced as a result of the
namespace fixup process) is copied to each descendant element of
the newly constructed element, unless that element or an
intermediate element already has a namespace node with the same
name (or absence of a name) or that descendant element or an
intermediate element is in no namespace and the namespace node has
no name.</p>
</li>
</ol>
<div class="example">
<div class="exampleHeader"><a name="d7e15785" id=
"d7e15785"></a>Example: A Sequence Constructor for Complex
Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;
</pre></div>
<p>This fragment consists of a literal result element
<code>td</code>, containing a sequence constructor that consists of
two instructions: <a href=
"#element-attribute"><code>xsl:attribute</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>. The sequence
constructor is evaluated to produce a sequence of two nodes: a
parentless attribute node, and a parentless text node. The
<code>td</code> instruction causes a <code>td</code> element to be
created; the new attribute therefore becomes an attribute of the
new <code>td</code> element, while the text node created by the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction becomes a child of the <code>td</code> element (unless
it is zero-length, in which case it is discarded).</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e15819" id=
"d7e15819"></a>Example: Space Separators in Element Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;
</pre></div>
<p>This produces the output (when indented):</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;
</pre></div>
<p>The difference between the two cases is that for the
<code>e</code> element, the sequence constructor generates a
sequence of five atomic values, which are therefore separated by
spaces. For the <code>f</code> element, the content is a sequence
of five text nodes, which are concatenated without space
separation.</p>
<p>It is important to be aware of the distinction between <a href=
"#element-sequence"><code>xsl:sequence</code></a>, which returns
the value of its <code>select</code> expression unchanged, and
<a href="#element-value-of"><code>xsl:value-of</code></a>, which
constructs a text node.</p>
</div>
</div>
<div class="div3">
<h4><a name="constructing-simple-content" id=
"constructing-simple-content"></a>5.8.2 <a href=
"#constructing-simple-content" style=
"text-decoration: none">Constructing Simple Content</a></h4>
<p>The instructions <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
<a href="#element-namespace"><code>xsl:namespace</code></a>, and
<a href="#element-value-of"><code>xsl:value-of</code></a> all
create nodes that cannot have children. Specifically, the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
creates an attribute node, <a href=
"#element-comment"><code>xsl:comment</code></a> creates a comment
node, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
creates a processing instruction node, <a href=
"#element-namespace"><code>xsl:namespace</code></a> creates a
namespace node, and <a href=
"#element-value-of"><code>xsl:value-of</code></a> creates a text
node. The string value of the new node is constructed using either
the <code>select</code> attribute of the instruction, or the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the instruction. The <code>select</code> attribute
allows the content to be specified by means of an XPath expression,
while the sequence constructor allows it to be specified by means
of a sequence of XSLT instructions. The <code>select</code>
attribute or sequence constructor is evaluated to produce a result
sequence, and the <a title="string value" class="termref" href=
"#dt-string-value">string value</a> of the new node is derived from
this result sequence according to the rules below.</p>
<p>These rules are also used to compute the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of an <span><a title=
"value template" class="termref" href="#dt-value-template">value
template</a></span>. In this case the sequence being processed is
the result of evaluating an XPath expression enclosed between curly
brackets, and the separator is a single space character.</p>
<ol class="enumar">
<li>
<p>Zero-length text nodes in the sequence are discarded.</p>
</li>
<li>
<p>Adjacent text nodes in the sequence are merged into a single
text node.</p>
</li>
<li>
<p>The sequence is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> <span>(which may cause a dynamic
error)</span>.</p>
</li>
<li>
<p>Every value in the atomized sequence is cast to a string.</p>
</li>
<li>
<p>The strings within the resulting sequence are concatenated, with
a (possibly zero-length) separator inserted between successive
strings. The default separator is a single space. In the case of
<a href="#element-attribute"><code>xsl:attribute</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a>, a
different separator can be specified using the
<code>separator</code> attribute of the instruction; it is
permissible for this to be a zero-length string, in which case the
strings are concatenated with no separator. In the case of <a href=
"#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
and <a href="#element-namespace"><code>xsl:namespace</code></a>,
and when expanding a <span><a title="value template" class=
"termref" href="#dt-value-template">value template</a></span>, the
default separator cannot be changed.</p>
</li>
<li>
<p>In the case of <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
any leading spaces in the resulting string are removed.</p>
</li>
<li>
<p>The resulting string forms the <a title="string value" class=
"termref" href="#dt-string-value">string value</a> of the new
attribute, namespace, comment, processing-instruction, or text
node.</p>
</li>
</ol>
<div class="example">
<div class="exampleHeader"><a name="d7e15967" id=
"d7e15967"></a>Example: Space Separators in Attribute Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;
</pre></div>
<p>This produces the output:</p>
<div class="exampleInner">
<pre>
&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;
</pre></div>
<p>The difference between the three cases is as follows. For the
<code>e</code> attribute, the sequence constructor generates a
sequence of five atomic values, which are therefore separated by
spaces. For the <code>f</code> attribute, the content is supplied
as a sequence of five text nodes, which are concatenated without
space separation. For the <code>g</code> attribute, the <a title=
"text value template" class="termref" href=
"#dt-text-value-template">text value template</a> constructs a text
node using the rules for constructing simple content, which insert
space separators between atomic values; the text node is then
atomized to form the value of the attribute.</p>
<p>Specifying <code>separator=""</code> on the first <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
would cause the attribute value to be <code>e="12345"</code>. A
<code>separator</code> attribute on the second <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
would have no effect, since the separator only affects the way
adjacent atomic values are handled: separators are never inserted
between adjacent text nodes. <span>A <code>separator</code> on the
third <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction would also have no effect, because text value templates
are evaluated without regard to the containing
instruction.</span></p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an attribute value template contains a sequence of fixed and
variable parts, no additional whitespace is inserted between the
expansions of the fixed and variable parts. For example, the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
<code>a="chapters{4 to 6}"</code> is <code>a="chapters4 5
6"</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="namespace-fixup" id="namespace-fixup"></a>5.8.3
<a href="#namespace-fixup" style="text-decoration: none">Namespace
Fixup</a></h4>
<p>In a tree supplied to or constructed by an XSLT processor, the
constraints relating to namespace nodes that are specified in
<a href="#xpath-datamodel-30">[Data Model]</a> <span class=
"verb">must</span> be satisfied. For example</p>
<ul>
<li>
<p>If an element node has an <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> with a
non-null namespace URI, then that element node <span class=
"verb">must</span> have at least one namespace node whose <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> is the same as that namespace URI.</p>
</li>
<li>
<p>If an element node has an attribute node whose <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> has a non-null namespace URI, then the element
<span class="verb">must</span> have at least one namespace node
whose <a title="string value" class="termref" href=
"#dt-string-value">string value</a> is the same as that namespace
URI and whose name is non-empty.</p>
</li>
<li>
<p>Every element <span class="verb">must</span> have a namespace
node whose <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> has local-part
<code>xml</code> and whose <a title="string value" class="termref"
href="#dt-string-value">string value</a> is
<code>http://www.w3.org/XML/1998/namespace</code>. The namespace
prefix <code>xml</code> <span class="verb">must</span> not be
associated with any other namespace URI, and the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code> <span class=
"verb">must</span> not be associated with any other prefix.</p>
</li>
<li>
<p>A namespace node <span class="verb">must not</span> have the
name <code>xmlns</code> or the string value
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-namespace-fixup" id="dt-namespace-fixup" title=
"namespace fixup"></a>The rules for the individual XSLT
instructions that construct a <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> (see <a href=
"#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>)
prescribe some of the situations in which namespace nodes are
written to the tree. These rules, however, are not sufficient to
ensure that the prescribed constraints are always satisfied. The
XSLT processor <span class="verb">must</span> therefore add
additional namespace nodes to satisfy these constraints. This
process is referred to as <b>namespace fixup</b>.<span class=
"definition">]</span></p>
<p>The actual namespace nodes that are added to the tree by the
namespace fixup process are <a title="implementation-dependent"
class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>,
provided firstly, that at the end of the process the above
constraints <span class="verb">must</span> all be satisfied, and
secondly, that a namespace node <span class="verb">must not</span>
be added to the tree unless the namespace node is necessary either
to satisfy these constraints, or to enable the tree to be
serialized using the original namespace prefixes from the source
document or <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
<p>Namespace fixup <span class="verb">must not</span> result in an
element having multiple namespace nodes with the same name.</p>
<p>Namespace fixup <span class="verb">may</span>, if necessary to
resolve conflicts, change the namespace prefix contained in the
QName value that holds the name of an element or attribute node.
This includes the option to add or remove a prefix. However,
namespace fixup <span class="verb">must not</span> change the
prefix component contained in a value of type <code>xs:QName</code>
or <code>xs:NOTATION</code> that forms the typed value of an
element or attribute node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Namespace fixup is not used to create namespace declarations for
<code>xs:QName</code> or <code>xs:NOTATION</code> values appearing
in the content of an element or attribute.</p>
<p>Where values acquire such types as the result of validation,
namespace fixup does not come into play, because namespace fixup
happens before validation: in this situation, it is the user's
responsibility to ensure that the element being validated has the
required namespace nodes to enable validation to succeed.</p>
<p>Where existing elements are copied along with their existing
type annotations (<code>validation="preserve"</code>) the rules
require that existing namespace nodes are also copied, so that any
namespace-sensitive values remain valid.</p>
<p>Where existing attributes are copied along with their existing
type annotations, the rules of the XDM data model require that a
parentless attribute node cannot contain a namespace-sensitive
typed value; this means that it is an error to copy an attribute
using <code>validation="preserve"</code> if it contains
namespace-sensitive content.</p>
</div>
<p>Namespace fixup is applied to every element that is constructed
using a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or one of
the instructions <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>. An implementation
is not <span class="verb">required</span> to perform namespace
fixup for elements in any source document, that is, for a document
in the initial input sequence, documents loaded using the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
function, documents supplied as the value of a <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a>, or documents
returned by an <a title="extension function" class="termref" href=
"#dt-extension-function">extension function</a> or <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A source document (an input document, a document returned by the
<a href="#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions, a document returned by an extension function or
extension instruction, or a document supplied as a stylesheet
parameter) is required to satisfy the constraints described in
<a href="#xpath-datamodel-30">[Data Model]</a>, including the
constraints imposed by the namespace fixup process. The effect of
supplying a pseudo-document that does not meet these constraints is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<p>In an Infoset (see <a href="#xml-infoset">[XML Information
Set]</a>) created from a document conforming to <a href=
"#xml-names">[Namespaces in XML]</a>, it will always be true that
if a parent element has an in-scope namespace with a non-empty
namespace prefix, then its child elements will also have an
in-scope namespace with the same namespace prefix, though possibly
with a different namespace URI. This constraint is removed in
<a href="#xml-names11">[Namespaces in XML 1.1]</a>. XSLT
<span>3.0</span> supports the creation of result trees that do not
satisfy this constraint: the namespace fixup process does not add a
namespace node to an element merely because its parent node in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> has such a namespace node.
However, the process of constructing the children of a new element,
which is described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, does cause the namespaces of a parent element to
be inherited by its children unless this is prevented using
<code>[xsl:]inherit-namespaces="no"</code> on the instruction that
creates the parent element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This has implications on serialization, defined in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. It means that it is possible to create
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> that cannot be
faithfully serialized as XML 1.0 documents. When such a result tree
is serialized as XML 1.0, namespace declarations written for the
parent element will be inherited by its child elements as if the
corresponding namespace nodes were present on the child element,
except in the case of the default namespace, which can be
undeclared using the construct <code>xmlns=""</code>. When the same
result tree is serialized as XML 1.1, however, it is possible to
undeclare any namespace on the child element (for example,
<code>xmlns:foo=""</code>) to prevent this inheritance taking
place.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="uri-references" id="uri-references"></a>5.9 <a href=
"#uri-references" style="text-decoration: none">URI
References</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-uri-reference" id="dt-uri-reference" title=
"URI Reference"></a>Within this specification, the term <b>URI
Reference</b>, unless otherwise stated, refers to a string in the
lexical space of the <code>xs:anyURI</code> datatype as defined in
<a href="#xmlschema-2">[XML Schema Part 2]</a>.<span class=
"definition">]</span> Note that this is a wider definition than
that in <a href="#RFC3986">[RFC3986]</a>: in particular, it is
designed to accommodate Internationalized Resource Identifiers
(IRIs) as described in <a href="#RFC3987">[RFC3987]</a>, and thus
allows the use of non-ASCII characters without escaping.</p>
<p>URI References are used in XSLT with three main roles:</p>
<ul>
<li>
<p>As namespace URIs</p>
</li>
<li>
<p>As collation URIs</p>
</li>
<li>
<p>As identifiers for resources such as stylesheet modules; these
resources are typically accessible using a protocol such as HTTP.
Examples of such identifiers are the URIs used in the
<code>href</code> attributes of <a href=
"#element-import"><code>xsl:import</code></a>, <a href=
"#element-include"><code>xsl:include</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
</ul>
<p>The rules for namespace URIs are given in <a href=
"#xml-names">[Namespaces in XML]</a> and <a href=
"#xml-names11">[Namespaces in XML 1.1]</a>. Those specifications
deprecate the use of relative URI <span>references</span> as
namespace URIs.</p>
<p>The rules for collation URIs are given in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<p>URI references used to identify external resources must conform
to the same rules as the locator attribute (<code>href</code>)
defined in section 5.4 of <a href="#xlink">[XLink]</a>. If the URI
reference is relative, then it is resolved (unless otherwise
specified) against the base URI of the containing element node,
according to the rules of <a href="#RFC3986">[RFC3986]</a>, after
first escaping all characters that need to be escaped to make it a
valid RFC3986 URI reference. (But a relative URI
<span>reference</span> in the <code>href</code> attribute of
<a href=
"#element-result-document"><code>xsl:result-document</code></a> is
resolved against the <a title="base output URI" class="termref"
href="#dt-base-output-uri">Base Output URI</a>.)</p>
<p>Other URI references appearing in an XSLT stylesheet document,
for example the system identifiers of external entities or the
value of the <code>xml:base</code> attribute, must follow the rules
in their respective specifications.</p>
<p>The base URI of an element node in the stylesheet is determined
as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup>. Some
implementations may allow the output of the static analysis phase
of stylesheet processing (a "compiled stylesheet") to be evaluated
in a different location from that where static analysis took place.
Furthermore, stylesheet authors may in such cases which to avoid
exposing the location of resources that are private to the
development environment. If the base URI of an element in the
stylesheet is defined by an absolute URI appearing in an
<code>xml:base</code> attribute within the stylesheet, this value
<span class="verb">must</span> be used as the static base URI. In
other cases where processing depends on the static base URI of a
stylesheet module, implementations <span class="verb">may</span>
use different values for the static base URI during static analysis
and during dynamic evaluation (for example, an implementation
<span class="verb">may</span> use different base URIs for resolving
<a href="#element-import"><code>xsl:import</code></a> module
references and for resolving a relative reference used as an
argument to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function). In such cases an implementation <span class=
"verb">must</span> document how the static base URI is computed for
each situation in which it is required.</p>
</div>
</div>
<div class="div1">
<h2><a name="rules" id="rules"></a>6 <a href="#rules" style=
"text-decoration: none">Template Rules</a></h2>
<p>Template rules define the processing that can be applied to
<span>items</span> that match a particular <a title="pattern"
class="termref" href="#dt-pattern">pattern</a>.</p>
<div class="div2">
<h3><a name="defining-templates" id="defining-templates"></a>6.1
<a href="#defining-templates" style=
"text-decoration: none">Defining Templates</a></h3>
<p class="element-syntax"><a name="element-template" id=
"element-template"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:template<br />
&#160;&#160;match? = <var>pattern</var><br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;priority? = <var>decimal</var><br />
&#160;&#160;mode? = <var>tokens</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?, <a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:template&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template" id="dt-template" title="template"></a>An <a href=
"#element-template"><code>xsl:template</code></a> declaration
defines a <b>template</b>, which contains a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span>; this
sequence constructor is evaluated to determine the result of the
template</span>. A template can serve either as a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>, invoked by matching <span>items</span> against a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>,
or as a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, invoked explicitly by
name. It is also possible for the same template to serve in both
capacities.<span class="definition">]</span></p>
<p><a name="err-XTSE0500" id="err-XTSE0500"><span class=
"error">[ERR XTSE0500]</span></a> An <a href=
"#element-template"><code>xsl:template</code></a> element
<span class="verb">must</span> have either a <code>match</code>
attribute or a <code>name</code> attribute, or both. An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>match</code> attribute <span class="verb">must</span> have
no <code>mode</code> attribute and no <code>priority</code>
attribute. <span>An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>name</code> attribute <span class="verb">must</span> have
no <code>visibility</code> attribute.</span></p>
<p>If an <a href="#element-template"><code>xsl:template</code></a>
element has a <code>match</code> attribute, then it is a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>. If it has a <code>name</code> attribute, then it is a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>.</p>
<p>A <a title="template" class="termref" href=
"#dt-template">template</a> may be invoked in a number of ways,
depending on whether it is a <a title="template rule" class=
"termref" href="#dt-template-rule">template rule</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, or both. The result of invoking the template is the
result of evaluating the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
contained in the <a href=
"#element-template"><code>xsl:template</code></a> element (see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>).</p>
<p>For details of the optional <a href=
"#element-context-item"><code>xsl:context-item</code></a> child
element, see <a href="#initial-context-for-template"><i>6.7.2
Declaring the context item for a template</i></a>.</p>
<p>If an <code>as</code> attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element is
present, the <code>as</code> attribute defines the required type of
the result. The result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is then
converted to the required type using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. If
no <code>as</code> attribute is specified, the default value is
<code>item()*</code>, which permits any value. No conversion then
takes place.</p>
<p><a name="err-XTTE0505" id="err-XTTE0505"><span class=
"error">[ERR XTTE0505]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> cannot be
converted to the required type.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then (a) the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> defining the
template body <span class="verb">must</span> be empty: that is, the
only permitted children are <a href=
"#element-context-item"><code>xsl:context-item</code></a> and
<a href="#element-param"><code>xsl:param</code></a>, and (b) there
<span class="verb">must</span> be no <code>match</code>
attribute.</p>
<p>If the parent of the <a href=
"#element-template"><code>xsl:template</code></a> element is an
<a href="#element-override"><code>xsl:override</code></a> element,
then there must be a <code>name</code> attribute and no
<code>match</code> attribute, and the <a title="package" class=
"termref" href="#dt-package">package</a> that is the target of the
containing <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
must contain among its <a title="component" class="termref" href=
"#dt-component">components</a> a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> whose
<a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> is the same as
this named template, and which has a <a title="compatible" class=
"termref" href="#dt-compatible">compatible</a> signature.</p>
</div>
<div class="div2">
<h3><a name="defining-template-rules" id=
"defining-template-rules"></a>6.2 <a href=
"#defining-template-rules" style="text-decoration: none">Defining
Template Rules</a></h3>
<p>This section describes <a title="template rule" class="termref"
href="#dt-template-rule">template rules</a>. <a title=
"named template" class="termref" href="#dt-named-template">Named
templates</a> are described in <a href="#named-templates"><i>10.1
Named Templates</i></a>.</p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is specified using the
<a href="#element-template"><code>xsl:template</code></a> element
with a <code>match</code> attribute. The <code>match</code>
attribute is a <a href="#doc-xslt30-patterns-Pattern30">Pattern</a>
that identifies the <span>items</span> to which the rule applies.
The result of applying the template rule is the result of
evaluating the sequence constructor contained in the <a href=
"#element-template"><code>xsl:template</code></a> element, with the
matching <span>item</span> used as the <span><a title=
"context item" class="termref" href="#dt-context-item">context
item</a></span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16676" id=
"d7e16676"></a>Example: A Simple Template Rule</div>
<p>For example, an XML document might contain:</p>
<div class="exampleInner">
<pre>
This is an &lt;emph&gt;important&lt;/emph&gt; point.
</pre></div>
<p>The following <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> matches <code>emph</code>
elements and produces a <code>fo:wrapper</code> element with a
<code>font-weight</code> property of <code>bold</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is evaluated when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects <span>an item</span> that matches the pattern
specified in the <code>match</code> attribute. The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is described in the next section. If several template
rules match a selected <span>item</span>, only one of them is
evaluated, as described in <a href="#conflict"><i>6.4 Conflict
Resolution for Template Rules</i></a>.</p>
</div>
<div class="div2">
<h3><a name="applying-templates" id="applying-templates"></a>6.3
<a href="#applying-templates" style=
"text-decoration: none">Applying Template Rules</a></h3>
<p class="element-syntax"><a name="element-apply-templates" id=
"element-apply-templates"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:apply-templates<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;mode? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>
| <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br />
&lt;/xsl:apply-templates&gt;</code></p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction takes as input a sequence of <span>items</span>
(typically nodes in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>), and produces as output a
sequence of items; these will often be nodes to be added to a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
<p>If the instruction has one or more <a href=
"#element-sort"><code>xsl:sort</code></a> children, then the input
sequence is sorted as described in <a href="#sorting"><i>13
Sorting</i></a>. The result of this sort is referred to below as
the <b>sorted sequence</b>; if there are no <a href=
"#element-sort"><code>xsl:sort</code></a> elements, then the sorted
sequence is the same as the input sequence.</p>
<p>Each <span>item</span> in the input sequence is processed by
finding a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> whose <a title="pattern"
class="termref" href="#dt-pattern">pattern</a> matches that
<span>item</span>. If there is more than one such template rule,
the best among them is chosen, using rules described in <a href=
"#conflict"><i>6.4 Conflict Resolution for Template Rules</i></a>.
If there is no template rule whose pattern matches the
<span>item</span>, a built-in template rule is used (see <a href=
"#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). The
chosen template rule is evaluated. The rule that matches the
<var>N</var>th <span>item</span> in the sorted sequence is
evaluated with that <span>item</span> as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, with <var>N</var> as the <a title="context position"
class="termref" href="#dt-context-position">context position</a>,
and with the length of the sorted sequence as the <a title=
"context size" class="termref" href="#dt-context-size">context
size</a>. Each template rule that is evaluated produces a sequence
of items as its result. The resulting sequences (one for each
<span>item</span> in the sorted sequence) are then concatenated, to
form a single sequence. They are concatenated retaining the order
of the <span>items</span> in the sorted sequence. The final
concatenated sequence forms the result of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16819" id=
"d7e16819"></a>Example: Applying Template Rules</div>
<p>Suppose the source document is as follows:</p>
<div class="exampleInner">
<pre>
&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;
</pre></div>
<p>This can be processed using the two template rules shown
below.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>There is no template rule for the document node; the built-in
template rule for this node will cause the <code>message</code>
element to be processed. The template rule for the
<code>message</code> element causes a <code>p</code> element to be
written to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>; the contents of this
<code>p</code> element are constructed as the result of the
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction. This instruction selects the three child nodes of the
<code>message</code> element (a text node containing the value
"<code>Proceed</code> ", an <code>emph</code> element node, and a
text node containing the value " <code>to the exit!</code>"). The
two text nodes are processed using the built-in template rule for
text nodes, which returns a copy of the text node. The
<code>emph</code> element is processed using the explicit template
rule that specifies <code>match="emph"</code>.</p>
<p>When the <code>emph</code> element is processed, this template
rule constructs a <code>b</code> element. The contents of the
<code>b</code> element are constructed by means of another <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, which in this case selects a single node (the text
node containing the value "<code>at once</code>"). This is again
processed using the built-in template rule for text nodes, which
returns a copy of the text node.</p>
<p>The final result of the <code>match="message"</code> template
rule thus consists of a <code>p</code> element node with three
children: a text node containing the value "<code>Proceed</code> ",
a <code>b</code> element that is the parent of a text node
containing the value "<code>at once</code>", and a text node
containing the value " <code>to the exit!</code>". This <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> might be serialized as:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;
</pre></div>
</div>
<p>The default value of the <code>select</code> attribute is
<code>child::node()</code>, which causes all the children of the
context node to be processed.</p>
<p><a name="err-XTTE0510" id="err-XTTE0510"><span class=
"error">[ERR XTTE0510]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction with no <code>select</code> attribute is evaluated when
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
<p>A <code>select</code> attribute can be used to process
<span>items</span> selected by an expression instead of processing
all children. The value of the <code>select</code> attribute is an
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16983" id=
"d7e16983"></a>Example: Applying Templates to Selected Nodes</div>
<p>The following example processes all of the
<code>given-name</code> children of the <code>author</code>
elements that are children of <code>author-group</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16999" id=
"d7e16999"></a>Example: Applying Templates to Nodes that are not
Descendants</div>
<p>It is also possible to process elements that are not descendants
of the context node. This example assumes that a
<code>department</code> element has <code>group</code> children and
<code>employee</code> descendants. It finds an employee's
department and then processes the <code>group</code> children of
the <code>department</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e17021" id=
"d7e17021"></a>Example: Matching Nodes by Schema-Defined
Types</div>
<p>It is possible to write template rules that are matched
according to the schema-defined type of an element or attribute.
The following example applies different formatting to the children
of an element depending on their type:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
is described in <a href="#apply-imports"><i>6.9 Overriding Template
Rules</i></a>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e17035" id=
"d7e17035"></a>Example: Re-ordering Elements in the Result
Tree</div>
<p>Multiple <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
elements can be used within a single template to do simple
reordering. The following example creates two HTML tables. The
first table is filled with domestic sales while the second table is
filled with foreign sales.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e17045" id=
"d7e17045"></a>Example: Processing Recursive Structures</div>
<p>It is possible for there to be two matching descendants where
one is a descendant of the other. This case is not treated
specially: both descendants will be processed as usual.</p>
<p>For example, given a source document</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;
</pre></div>
<p>the rule</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>will process both the outer <code>div</code> and inner
<code>div</code> elements.</p>
<p>This means that if the template rule for the <code>div</code>
element processes its own children, then these grandchildren will
be processed more than once, which is probably not what is
required. The solution is to process one level at a time in a
recursive descent, by using <code>select="div"</code> in place of
<code>select=".//div"</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e17077" id=
"d7e17077"></a>Example: Applying Templates to Atomic Values</div>
<p>This example reads a non-XML text file and processes it
line-by-line, applying different template rules based on the
content of each line:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="."&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is most commonly used to process nodes that are
descendants of the context node. Such use of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
cannot result in non-terminating processing loops. However, when
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used to process elements that are not descendants of the context
node, the possibility arises of non-terminating loops. For
example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Implementations may be able to detect such loops in some cases,
but the possibility exists that a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> may enter a
non-terminating loop that an implementation is unable to detect.
This may present a denial of service security risk.</p>
</div>
</div>
<div class="div2">
<h3><a name="conflict" id="conflict"></a>6.4 <a href="#conflict"
style="text-decoration: none">Conflict Resolution for Template
Rules</a></h3>
<p>It is possible for <span>a selected item</span> to match more
than one <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> with a given <a title="mode"
class="termref" href="#dt-mode">mode</a> <var>M</var>. When this
happens, only one template rule is evaluated for the
<span>item</span>. The template rule to be used is determined as
follows:</p>
<ol class="enumar">
<li>
<p>First, only the matching template rule or rules with the highest
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> are considered. Other
matching template rules with lower precedence are eliminated from
consideration.</p>
</li>
<li>
<p>Next, of the remaining matching rules, only those with the
highest priority are considered. Other matching template rules with
lower priority are eliminated from consideration.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-priority" id="dt-priority" title="priority"></a>The
<b>priority</b> of a template rule is specified by the
<code>priority</code> attribute on the <a href=
"#element-template"><code>xsl:template</code></a> declaration. If
no priority is specified explicitly for a template rule, its
<a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> is used, as defined in
<a href="#default-priority"><i>6.5 Default Priority for Template
Rules</i></a>.<span class="definition">]</span></p>
<p><a name="err-XTSE0530" id="err-XTSE0530"><span class=
"error">[ERR XTSE0530]</span></a> The value of the
<code>priority</code> attribute <span class="verb">must</span>
conform to the rules for the <code>xs:decimal</code> type defined
in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative values
are permitted.</p>
</li>
<li>
<p>If this leaves more than one matching template rule, then:</p>
<ol class="enumla">
<li>
<p>If the <a title="mode" class="termref" href="#dt-mode">mode</a>
<var>M</var> has an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, and the
attribute value <code>on-multiple-match="fail"</code> is specified
in the mode declaration, a dynamic error is signaled. The error is
treated as occurring in the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, and can be recovered by wrapping that instruction in
an <a href="#element-try"><code>xsl:try</code></a> instruction.</p>
<p><a name="err-XTDE0540" id="err-XTDE0540"><span class=
"error">[ERR XTDE0540]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
conflict resolution algorithm for template rules leaves more than
one matching template rule <span>when the declaration of the
relevant <a title="mode" class="termref" href="#dt-mode">mode</a>
has an <code>on-multiple-match</code> attribute with the value
<code>fail</code></span>.</p>
</li>
<li>
<p>Otherwise, of the matching template rules that remain, the one
that occurs last in <a title="declaration order" class="termref"
href="#dt-declaration-order">declaration order</a> is used.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This was a recoverable error in XSLT 2.0, meaning that it was
implementation-defined whether the error was signaled, or whether
the ambiguity was resolved by taking the last matching rule in
declaration order. In XSLT 3.0 this situation is not an error
unless the attribute value <code>on-multiple-match="fail"</code> is
specified in the mode declaration. It is also possible to request
warnings when this condition arises, by means of the attribute
<span><code>warning-on-multiple-match="yes"</code></span>.</p>
</div>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="default-priority" id="default-priority"></a>6.5
<a href="#default-priority" style="text-decoration: none">Default
Priority for Template Rules</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-default-priority" id="dt-default-priority" title=
"default priority"></a>If no <code>priority</code> attribute is
specified on an <a href=
"#element-template"><code>xsl:template</code></a> element, a
<b>default priority</b> is computed, based on the syntax of the
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
supplied in the <code>match</code> attribute.<span class=
"definition">]</span> The rules are as follows.</p>
<ol class="enumar">
<li>
<p>If the top-level pattern is a <a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>
then the outer parentheses are effectively stripped; these rules
are applied recursively to the <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> contained in the
<a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>.</p>
</li>
<li>
<p>If the top-level pattern is a <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> consisting of
multiple alternatives separated by <code>|</code> or
<code>union</code>, then the template rule is treated equivalently
to a set of template rules, one for each alternative. <span>These
template rules are adjacent to each other in declaration order, and
the declaration order within this set of template rules (which
affects the result of <a href=
"#element-next-match"><code>xsl:next-match</code></a> if the
alternatives have the same default priority) is the order of
alternatives in the <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a>.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The splitting of a template rule into multiple rules occurs only
if there is no explicit <code>priority</code> attribute.</p>
</div>
</li>
<li>
<p>If the top-level pattern is a <a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>
containing two or more <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> operands separated
by <code>intersect</code> or <code>except</code> operators, then
the priority of the pattern is that of the first <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a>.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a> then
its priority is 1 (one), unless the <code>PredicateList</code> is
empty, in which case the priority is −1 (minus one).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form
<code>/</code>, then the priority is −0.5 (minus 0.5).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a> or has the
form <code>processing-instruction(</code> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-StringLiteral">StringLiteral</a><sup><small>XP30</small></sup>
<code>)</code> or <code>processing-instruction(</code> <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
<code>)</code> optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is 0 (zero).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-AttributeTest">AttributeTest</a><sup><small>XP30</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is as shown in the table below. In this table, the symbols
<var>E</var>, <var>A</var>, and <var>T</var> represent an arbitrary
element name, attribute name, and type name respectively, while the
symbol <code>*</code> represents itself. The presence or absence of
the symbol <code>?</code> following a type name does not affect the
priority.</p>
<table border="1" cellpadding="5" summary=
"default priority of patterns" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Format</th>
<th align="left" colspan="1" valign="top">Priority</th>
<th align="left" colspan="1" valign="top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><code>element()</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>element(*)</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>attribute()</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>@*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>attribute(*)</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>@*</code>)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(<var>E</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(equivalent to E)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(*,<var>T</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(matches by type only)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(<var>A</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(equivalent to <code>@A</code>)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(*,<var>T</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(matches by type only)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(<var>E</var>,<var>T</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>schema-element(<var>E</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by substitution group and
type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(<var>A</var>,<var>T</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>schema-attribute(<var>A</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of a
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-DocumentTest">DocumentTest</a><sup><small>XP30</small></sup>,
then if it includes no <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>
the priority is −0.5. If it does include an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>,
then the priority is the same as the priority of that <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>,
computed according to the table above.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup><code>:*</code>
or <code>*:</code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is −0.25.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
any other <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NodeTest">NodeTest</a><sup><small>XP30</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is −0.5.</p>
</li>
<li>
<p>In all other cases, the priority is +0.5.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In many cases this means that highly selective patterns have
higher priority than less selective patterns. The most common kind
of pattern (a pattern that tests for a node of a particular kind,
with a particular <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> or a particular type) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node of a particular kind and an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> with a particular namespace URI) has priority −0.25.
Patterns less specific than this (patterns that just test for nodes
of a given kind) have priority −0.5. Patterns that specify both the
name and the required type have a priority of +0.25, putting them
above patterns that only specify the name <em>or</em> the type.
Patterns more specific than this, for example patterns that include
predicates or that specify the ancestry of the required node, have
priority 0.5.</p>
<p>However, it is not invariably true that a more selective pattern
has higher priority than a less selective pattern. For example, the
priority of the pattern <code>node()[self::*]</code> is higher than
that of the pattern <code>salary</code>. Similarly, the patterns
<code>attribute(*, xs:decimal)</code> and <code>attribute(*,
xs:short)</code> have the same priority, despite the fact that the
latter pattern matches a subset of the nodes matched by the former.
Therefore, to achieve clarity in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> it is good practice
to allocate explicit priorities.</p>
</div>
</div>
<div class="div2">
<h3><a name="modes" id="modes"></a>6.6 <a href="#modes" style=
"text-decoration: none">Modes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-mode" id="dt-mode" title="mode"></a> <b>Modes</b> allow a node
in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> to be processed multiple times,
each time producing a different result. They also allow different
sets of <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> to be active when processing
different trees, for example when processing documents loaded using
the <a href="#func-document"><code>document</code></a> function
(see <a href="#func-document"><i>20.1 fn:document</i></a>) or when
processing <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>.<span class=
"definition">]</span></p>
<p>Modes are identified by an <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>; in addition
to any named modes, there is always one unnamed mode available.
Whether a mode is named or unnamed, its properties <span class=
"verb">may</span> be defined in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration. If a mode
name is used (for example in an <a href=
"#element-template"><code>xsl:template</code></a> declaration or an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) and no declaration of that mode appears in the
stylesheet, the mode is implicitly declared with default
properties.</p>
<div class="div3">
<h4><a name="declaring-modes" id="declaring-modes"></a>6.6.1
<a href="#declaring-modes" style="text-decoration: none">Declaring
Modes</a></h4>
<p class="element-syntax"><a name="element-mode" id=
"element-mode"></a><code>&lt;!-- Category: declaration --&gt;<br />
&lt;xsl:mode<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;streamable? = "yes" | "no"<br />
&#160;&#160;on-no-match? = "deep-copy" | "shallow-copy" |
"deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br />
&#160;&#160;on-multiple-match? = "use-last" | "fail"<br />
&#160;&#160;warning-on-no-match? = "yes" | "no"<br />
&#160;&#160;warning-on-multiple-match? = "yes" | "no"<br />
&#160;&#160;typed? = "yes" | "no" | "strict" | "lax" |
"unspecified"<br />
&#160;&#160;visibility? = "public" | "private" |
"final"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?) --&gt;<br />
&lt;/xsl:mode&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-unnamed-mode" id="dt-unnamed-mode" title=
"unnamed mode"></a>There is always an <b>unnamed mode</b>
available. The unnamed mode is the default mode used when no
<code>mode</code> attribute is specified on an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction or <a href=
"#element-template"><code>xsl:template</code></a> declaration,
unless a different default mode has been specified using the
<span><code>[xsl:]default-mode</code> attribute of a containing
element</span>.<span class="definition">]</span></p>
<p>Every <a title="mode" class="termref" href="#dt-mode">mode</a>
other than the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a> is identified by an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> may contain multiple <a href=
"#element-mode"><code>xsl:mode</code></a> declarations and may
include or import <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet modules</a> that also
contain <a href="#element-mode"><code>xsl:mode</code></a>
declarations. The name of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration is the value
of its <code>name</code> attribute, if any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-mode-definition" id="dt-mode-definition" title=
"mode definition"></a>All the <a href=
"#element-mode"><code>xsl:mode</code></a> declarations in a
stylesheet that share the same name are grouped into a named
<b>mode definition</b>; those that have no name are grouped into a
single unnamed mode definition.<span class=
"definition">]</span></p>
<p>If a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> does not contain a declaration of
the unnamed mode, a declaration is implied equivalent to an
<a href="#element-mode"><code>xsl:mode</code></a> element with the
single attribute <code>initial="yes"</code>. Similarly, if there is
a mode that is named in an <a href=
"#element-template"><code>xsl:template</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
element, or in the <span><code>[xsl:]default-mode</code> attribute
of a containing element</span>, and the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> does not
contain a declaration of that mode, then a declaration is implied
comprising an <a href="#element-mode"><code>xsl:mode</code></a>
element with a <code>name</code> attribute plus the attribute
<code>initial="yes"</code>.</p>
<p>The contained <a href=
"#element-context-item"><code>xsl:context-item</code></a> element,
if present, is used to declare requirements for the <a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> when this mode
is used as the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a>. Therefore, there must be no
<a href="#element-context-item"><code>xsl:context-item</code></a>
child if <code>initial="no"</code> is specified.</p>
<p><a name="err-XTSE0542" id="err-XTSE0542"><span class=
"error">[ERR XTSE0542]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-mode"><code>xsl:mode</code></a> declaration
specifying <code>initial="no"</code> contains an <a href=
"#element-context-item"><code>xsl:context-item</code></a>
element.</p>
<p>The attributes of the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration establish
values for a number of properties of a mode. The allowed values and
meanings of the attributes are given in the following table.</p>
<table cellpadding="5" width="100%" summary=
"attributes of the xsl:mode element" border="1">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Attribute</th>
<th colspan="1" align="left" valign="top">Values</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">name</td>
<td valign="top" align="left">A <a title="EQName" class="termref"
href="#dt-eqname">EQName</a></td>
<td valign="top" align="left">Specifies the name of the mode. If
omitted, this <a href="#element-mode"><code>xsl:mode</code></a>
declaration provides properties of the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed mode</a></td>
</tr>
<tr>
<td valign="top" align="left">streamable</td>
<td valign="top" align="left"><code>yes</code> or <code>no</code>
(default <code>no</code>)</td>
<td valign="top" align="left">Determines whether template rules in
this mode are to be capable of being processed using <a title=
"streaming" class="termref" href="#dt-streaming">streaming</a>. If
the value <code>yes</code> is specified, then the body of any
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that uses this mode
<span class="verb">must</span> conform to the rules for streamable
templates given in <a href="#streamable-templates"><i>6.6.3
Streamable Templates</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">on-no-match</td>
<td valign="top" align="left"><span>One of <code>deep-copy</code>,
<code>shallow-copy</code>, <code>deep-skip</code>,
<code>shallow-skip</code>, <code>text-only-copy</code> or
<code>fail</code> (default <code>text-only-copy</code>)</span></td>
<td valign="top" align="left">Determines selection of the built-in
<a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> that are used to process a
node when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that does not match any user-written
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>. For details,
see <a href="#built-in-rule"><i>6.8 Built-in Template
Rules</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">on-multiple-match</td>
<td valign="top" align="left">One of <code>fail</code> or
<code>use-last</code> (default <code>use-last</code>)</td>
<td valign="top" align="left">Defines the action to be taken when
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used in this mode and more than one user-written <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> is available to process the node, having the same
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and <a title=
"priority" class="termref" href="#dt-priority">priority</a>. The
value <code>fail</code> indicates that it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if more than one template rule matches the node. The
value <code>use-last</code> indicates that the situation is not to
be treated as an error (the last template in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> is the one that is
used).</td>
</tr>
<tr>
<td valign="top" align="left">warning-on-no-match</td>
<td valign="top" align="left">One of <code>yes</code> or
<code>no</code>. The default is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a></td>
<td valign="top" align="left">Requests the <a title="processor"
class="termref" href="#dt-processor">processor</a> to output (or
not to output) a warning message in the case where an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that matches no template rule. The form
and destination of such warnings is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
processor <span class="verb">may</span> ignore this attribute, for
example if the environment provides no suitable means of
communicating with the user.</td>
</tr>
<tr>
<td valign="top" align="left">warning-on-multiple-match</td>
<td valign="top" align="left">One of <code>yes</code> or
<code>no</code>. The default is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a></td>
<td valign="top" align="left">Requests the <a title="processor"
class="termref" href="#dt-processor">processor</a> to output a
warning message in the case where an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that matches multiple template rules
having the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and <a title=
"priority" class="termref" href="#dt-priority">priority</a>. The
form and destination of such warnings is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
processor <span class="verb">may</span> ignore this attribute, for
example if the environment provides no suitable means of
communicating with the user.</td>
</tr>
<tr>
<td valign="top" align="left">typed</td>
<td valign="top" align="left">One of <code>yes</code>,
<code>no</code>, <code>strict</code>, <code>lax</code>, or
<code>unspecified</code>. The default is
<code>unspecified</code>.</td>
<td valign="top" align="left"><span>Informs the <a title=
"processor" class="termref" href="#dt-processor">processor</a>
whether the nodes to be processed by template rules in this mode
are to be typed or untyped. If the value <code>yes</code> is
specified, then all nodes processed in this mode <span class=
"verb">must</span> be typed (a dynamic error occurs if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
this mode selects an element or attribute whose type annotation is
<code>xs:untyped</code> or <code>xs:untypedAtomic</code>). If the
value <code>no</code> is specified, then all nodes processed in
this mode <span class="verb">must</span> be untyped (a dynamic
error occurs if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
this mode selects an element or attribute whose type annotation is
anything other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>). <span>The value <code>strict</code>
is equivalent to <code>yes</code>, with the additional provision
that within the match pattern of every template rule in this mode,
any <code>NameTest</code> used as an <code>AbbrevForwardStep</code>
(with no preceding "@") in the <code>ForwardStepP</code> of the
first <code>StepExprP</code> of a <code>RelativePathExprP</code> is
interpreted as <code>match="schema-element(product)"</code>, while
<code>match="product/code"</code> is interpreted as
<code>match="schema-element(product)/code"</code>.</span> The value
<code>lax</code> is equivalent to <code>strict</code>, except that
the interpretation of a <code>NameTest</code> as a
<code>SchemaElementTest</code> occurs only if it matches the name
of a global element declaration in the in-scope schema
declarations. The value <code>unspecified</code> is equivalent to
omitting the attribute, and places no constraints on whether the
nodes to be processed in this mode are typed or
untyped.</span></td>
</tr>
<tr>
<td valign="top" align="left">visibility</td>
<td valign="top" align="left">One of <code>public</code>,
<code>private</code>, or <code>final</code>. The default is
<code>private</code>.</td>
<td valign="top" align="left">See <a href=
"#declared-visibility"><i>3.6.2.2 Visibility of
Declarations</i></a>. <span>A mode is not eligible to be used as
the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> if its visibility is
<code>private</code>.</span></td>
</tr>
</tbody>
</table>
<p><a name="err-XTTE3100" id="err-XTTE3100"><span class=
"error">[ERR XTTE3100]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when the <code>typed</code> attribute
of that mode specifies the value <code>yes</code>,
<code>strict</code>, or <code>lax</code>.</p>
<p><a name="err-XTTE3110" id="err-XTTE3110"><span class=
"error">[ERR XTTE3110]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is anything other than <code>xs:untyped</code>
or <code>xs:untypedAtomic</code> when the <code>typed</code>
attribute of that mode specifies the value <code>no</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamable-mode" id="dt-streamable-mode" title=
"streamable mode"></a>A <b>streamable mode</b> is a <a title="mode"
class="termref" href="#dt-mode">mode</a> that is declared in an
<a href="#element-mode"><code>xsl:mode</code></a> declaration with
the attribute <code>streamable="yes"</code>.<span class=
"definition">]</span></p>
<p>For any named <a title="mode" class="termref" href=
"#dt-mode">mode</a>, the effective value of each attribute is taken
from an <a href="#element-mode"><code>xsl:mode</code></a>
declaration that has a matching name in its <code>name</code>
attribute, and that specifies an explicit value for the required
attribute. If there is more than one such declaration, the one with
highest <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p>For the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>, the effective value of each
attribute is taken from an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration that has no
<code>name</code> attribute, and that specifies an explicit value
for the required attribute. If there is no such declaration, the
default value of the attribute is used. If there is more than one
such declaration, the one with highest <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used.</p>
<p>The above rules apply both to the attributes (other than
<code>name</code>) of the <a href=
"#element-mode"><code>xsl:mode</code></a> element itself, and to
the attributes of the contained <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
if present.</p>
<p><a name="err-XTSE0545" id="err-XTSE0545"><span class=
"error">[ERR XTSE0545]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a named
or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>
contains two conflicting values for the same attribute in different
<a href="#element-mode"><code>xsl:mode</code></a> declarations
having the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another definition of the same attribute with higher import
precedence. The attributes in question are the attributes other
than <code>name</code> on the <a href=
"#element-mode"><code>xsl:mode</code></a> element, and the
<code>as</code> attribute on the contained <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
if present.</p>
<p>If the <a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> supplied to a
stylesheet is a <a title="streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a> node, then it is not
permitted for the values of global variables to be dependent on the
context item in a way that requires reading of the input stream.
This constraint is enforced by the following static rule:</p>
<p><a name="err-XTSE0548" id="err-XTSE0548"><span class=
"error">[ERR XTSE0548]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
is both (a) a <a title="mode definition" class="termref" href=
"#dt-mode-definition">mode definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
that has the effective attribute values
<code>streamable="yes"</code> and <code>initial="yes"</code>, and
(b) a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
whose initializing expression is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> with respect to its
context item, as defined in <a href="#streamability"><i>19
Streamability</i></a>.</p>
</div>
<div class="div3">
<h4><a name="using-modes" id="using-modes"></a>6.6.2 <a href=
"#using-modes" style="text-decoration: none">Using Modes</a></h4>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is applicable to one or more
modes. The modes to which it is applicable are defined by the
<code>mode</code> attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element. If the
attribute is omitted, then the template rule is applicable to the
<span>default mode specified in the
<span><code>[xsl:]default-mode</code> attribute of the innermost
containing element that has such an attribute</span>, which in turn
defaults to the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</span> If the
<code>mode</code> attribute is present, then its value <span class=
"verb">must</span> be a non-empty whitespace-separated list of
tokens, each of which defines a mode to which the template rule is
applicable. Each token <span class="verb">must</span> be one of the
following:</p>
<ul>
<li>
<p>an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, which is expanded as described in
<a href="#qname"><i>5.1 Qualified Names</i></a> to define the name
of the mode</p>
</li>
<li>
<p>the token <code>#default</code>, to indicate that the template
rule is applicable to the <span>default mode that would apply if
the <code>mode</code> attribute were absent</span></p>
</li>
<li>
<p>the token <code>#unnamed</code>, to indicate that the template
rule is applicable to the <a title="unnamed mode" class="termref"
href="#dt-unnamed-mode">unnamed mode</a></p>
</li>
<li>
<p>the token <code>#all</code>, to indicate that the template rule
is applicable to all modes (specifically, to the
<span>unnamed</span> mode and to every mode that is named
<span>explicitly or implicitly</span> in an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction anywhere in the stylesheet).</p>
</li>
</ul>
<p><a name="err-XTSE0550" id="err-XTSE0550"><span class=
"error">[ERR XTSE0550]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
list of modes is empty, if the same token is included more than
once in the list, if the list contains an invalid token, or if the
token <code>#all</code> appears together with any other value.</p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
element also has an optional <code>mode</code> attribute. The value
of this attribute <span class="verb">must</span> be one of the
following:</p>
<ul>
<li>
<p>an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, which is expanded as described in
<a href="#qname"><i>5.1 Qualified Names</i></a> to define the name
of a mode</p>
</li>
<li>
<p>the token <code>#default</code>, to indicate that the default
mode <span>for the <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a></span> is to be
used</p>
</li>
<li>
<p>the token <code>#unnamed</code>, to indicate that the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a> is to be used</p>
</li>
<li>
<p>the token <code>#current</code>, to indicate that the <a title=
"current mode" class="termref" href="#dt-current-mode">current
mode</a> is to be used</p>
</li>
</ul>
<p>If the attribute is omitted, the default mode <span>for the
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a></span> is used.</p>
<p>When searching for a template rule to process each
<span>item</span> selected by the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, only those template rules that are applicable to the
selected mode are considered.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-mode" id="dt-current-mode" title="current mode"></a>At
any point in the processing of a stylesheet, there is a <b>current
mode</b>. When the transformation is initiated, the current mode is
the <span><a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a></span>, as described in
<a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.
Whenever an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is evaluated, the current mode becomes the mode
selected by this instruction.<span class="definition">]</span> When
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made</span>, the current mode is set to the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a>. While evaluating global variables and parameters, and the
sequence constructor contained in <a href=
"#element-key"><code>xsl:key</code></a> or <a href=
"#element-sort"><code>xsl:sort</code></a>, the current mode is set
to the unnamed mode. No other instruction changes the current mode.
The current mode while evaluating an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a> is the
same as the current mode of the caller. On completion of the
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, or on return from a stylesheet function call, the
current mode reverts to its previous value. The current mode is
used when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction uses the syntax <code>mode="#current"</code>; it is
also used by the <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> and
<a href="#element-next-match"><code>xsl:next-match</code></a>
instructions (see <a href="#apply-imports"><i>6.9 Overriding
Template Rules</i></a>).</p>
</div>
<div class="div3">
<h4><a name="streamable-templates" id=
"streamable-templates"></a>6.6.3 <a href="#streamable-templates"
style="text-decoration: none">Streamable Templates</a></h4>
<p>A template is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if and
only if all the following conditions are satisfied:</p>
<ul>
<li>
<p>The <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> defined in the <code>match</code>
attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element
<span>is</span> a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern as defined in <a href=
"#classifying-patterns"><i>19.8.9 Classifying Patterns</i></a>.</p>
</li>
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the body of the <a href=
"#element-template"><code>xsl:template</code></a> element <span>is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a></span>, as defined in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</li>
<li>
<p>Every <a title="expression" class="termref" href=
"#dt-expression">expression</a> and contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> in a contained
<a href="#element-param"><code>xsl:param</code></a> element (the
construct that provides the default value of the parameter)
<span>is</span> <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ul>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration declares an
intent that every template rule that includes that mode (explicitly
or implicitly, including by specifying <code>#all</code>), should
be guaranteed streamable according to these criteria. The
consequences of declaring the mode to be streamable when there is
such a template rule that is not guaranteed streamable depend on
the conformance level of the processor, and are explained in
<a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p>Processing of a document using streamable templates may be
initiated using code such as the following, where <code>S</code> is
a mode declared with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="bigdoc.xml"&gt;
  &lt;xsl:apply-templates mode="S"/&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Alternatively, streamed processing may be initiated by invoking
the transformation with an <a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a> declared as streamable,
while supplying the <a title="initial context item" class="termref"
href="#dt-initial-context-item">initial context item</a> (in an
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way) as a
streamed document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Invoking a streamable template using the construct
<code>&lt;xsl:apply-templates
select="doc('bigdoc.xml')"/&gt;</code> does not ensure streamed
processing. As always, processors may use streamed processing if
they are able to do so, but when the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> functions are
used, processors are obliged to ensure that the results are
deterministic, which may be difficult to reconcile with streaming
(if the same document is read twice, the results must be
identical). The use of <a href=
"#element-stream"><code>xsl:stream</code></a> does not offer the
same guarantees of determinism.</p>
</div>
<p>For an example of processing a collection of documents by use of
the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>
uri-collection</code></a><sup><small>FO30</small></sup> in
conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a>, see <a href=
"#stream-examples"><i>18.1.2 Examples of xsl:stream</i></a> .</p>
</div>
</div>
<div class="div2">
<h3><a name="declaring-context-item" id=
"declaring-context-item"></a>6.7 <a href="#declaring-context-item"
style="text-decoration: none">Declaring the Context Item</a></h3>
<p>The <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is used for two purposes:</p>
<ul>
<li>
<p>As a child of <a href="#element-mode"><code>xsl:mode</code></a>,
it declares the required type of the <a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> that is
supplied by the calling application when this mode is used as the
<a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a>.</p>
</li>
<li>
<p>As a child of <a href=
"#element-template"><code>xsl:template</code></a>, it declares the
required type of the context item when the containing template is
called using an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction.</p>
</li>
</ul>
<p class="element-syntax"><a name="element-context-item" id=
"element-context-item"></a><code>&lt;xsl:context-item<br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" |
"prohibited"&#160;/&gt;</code></p>
<p>If the <code>as</code> attribute is present then its value must
be an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>.
If the attribute is omitted this is equivalent to specifying
<code>as="item()"</code>.</p>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is signaled if the supplied context
item does not match its required type. The error code is the same
as for <a href="#element-param"><code>xsl:param</code></a>:
<span class="error">[see <a href="#err-XTTE0590">ERR
XTTE0590</a>]</span>.</p>
<div class="div3">
<h4><a name="initial-context-for-mode" id=
"initial-context-for-mode"></a>6.7.1 <a href=
"#initial-context-for-mode" style="text-decoration: none">Declaring
the Initial Context Item for a Mode</a></h4>
<p>This section applies when <a href=
"#element-context-item"><code>xsl:context-item</code></a> is used
to declare the initial context item for a mode.</p>
<p>When the <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
appears as a child of <a href=
"#element-mode"><code>xsl:mode</code></a>, the only permitted value
for the <code>use</code> attribute is <code>required</code>,
indicating that an initial context item <span class=
"verb">must</span> be supplied by the calling application when this
mode is selected as the <a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a>. The context item that is
supplied will be converted to the declared type using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. This
may result in a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the conversion is not
possible.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the <code>ItemType</code> is one that can only be satisfied
by a schema-validated input document, for example
<code>as="schema-element(invoice)"</code>, the <a title="processor"
class="termref" href="#dt-processor">processor</a> may interpret
this as a request to apply schema validation to the input.
Similarly, if the <code>KindTest</code> indicates that an element
node is required, the processor may interpret this as a request to
supply the document element rather than the document node of a
supplied input document.</p>
</div>
<p>If there is no <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
for an <a href="#element-mode"><code>xsl:mode</code></a> that
specifies <code>initial="yes"</code>, this is equivalent to
specifying <code>&lt;xsl:context-item as="item()"/&gt;</code></p>
<div class="example">
<div class="exampleHeader"><a name="d7e19040" id=
"d7e19040"></a>Example: Declaring the Required Context Item</div>
<p>The following example declares two modes, both of which have
<code>initial="yes"</code> meaning that they can be used as entry
points to the stylesheet. In the first mode, named
<code>invoice</code>, the required context item is a
schema-validated <code>invoice</code> element. In the second mode,
named <code>po</code>, the required context item is a
schema-validated <code>purchase-order</code> element. A third mode,
<code>format-address</code> is declared with
<code>initial="no"</code> so it cannot be used as an initial entry
point; this mode might be used when processing content that is
common to invoices and purchase orders.</p>
<div class="exampleInner">
<pre>
&lt;xsl:mode name="invoice" initial="yes" on-no-match="deep-copy"&gt;
  &lt;xsl:context-item as="schema-element(invoice)"/&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="po" initial="yes" on-no-match="deep-copy"&gt;
  &lt;xsl:context-item as="schema-element(purchase-order)"/&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="format-address" initial="no"/&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="initial-context-for-template" id=
"initial-context-for-template"></a>6.7.2 <a href=
"#initial-context-for-template" style=
"text-decoration: none">Declaring the context item for a
template</a></h4>
<p>The <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
can appear as a child of <a href=
"#element-template"><code>xsl:template</code></a> to define the
type of the context item passed to a named template. If the named
template is also the <a title="initial template" class="termref"
href="#dt-initial-template">initial template</a>, then this
constrains the <a title="initial context item" class="termref"
href="#dt-initial-context-item">initial context item</a> for the
transformation as a whole.</p>
<p>If an <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is present as the first child element of <a href=
"#element-template"><code>xsl:template</code></a>, it defines
whether the template requires a context item to be supplied, and if
so, what the type of the context item must be. If this template is
the <a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a>, then this has the
effect of placing constraints on the <a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> for the
transformation as a whole.</p>
<p>The <code>use</code> attribute of <a href=
"#element-context-item"><code>xsl:context-item</code></a> takes the
value <code>required</code>, <code>optional</code>, or
<code>prohibited</code>. If the value <code>required</code> is
specified, then there must be a context item. (This will
automatically be the case if the template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, but
not if it is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>). If
the value <code>optional</code> is specified, or if the attribute
is omitted, or if the <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is omitted, then there may or may not be a context item when the
template is invoked. If the containing <a href=
"#element-template"><code>xsl:template</code></a> element has no
<code>name</code> attribute then the only permitted value is
<code>required</code>. If the value <code>prohibited</code> is
specified, then there will be no context item available to the body
template (if the calling template has a context item, it will not
be made available to the called template).</p>
<p>The <code>as</code> attribute of the <a href=
"#element-context-item"><code>xsl:context-item</code></a> defines
the required type of the context item supplied to the template if
one is supplied. The default value is <code>as="item()"</code>. If
a context item is supplied (which will automatically be the case if
the template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>) then
if will be converted to the required type by applying the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>; a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> <span class="error">[see <a href="#err-XTTE0590">ERR
XTTE0590</a>]</span> occurs if conversion to the required type is
not possible. The processor <span class="verb">may</span> signal a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> statically if the required context item type is
incompatible with the <code>match</code> pattern, that is, if no
item that satisfies the match pattern can also satisfy the required
context item type.</p>
<p>The <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
plays no part in deciding whether and when the template rule is
invoked in response to an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p><a name="err-XTTE3090" id="err-XTTE3090"><span class=
"error">[ERR XTTE3090]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a href="#element-context-item"><code>xsl:context-item</code></a>
child of <a href="#element-template"><code>xsl:template</code></a>
specifies that a context item is required and none is supplied by
the caller, that is, if the context item is absent at the point
where <a href=
"#element-call-template"><code>xsl:call-template</code></a> is
evaluated.</p>
</div>
</div>
<div class="div2">
<h3><a name="built-in-rule" id="built-in-rule"></a>6.8 <a href=
"#built-in-rule" style="text-decoration: none">Built-in Template
Rules</a></h3>
<p>When an <span>item</span> is selected by <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
there is no user-specified <a title="template rule" class="termref"
href="#dt-template-rule">template rule</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
that can be used to process that <span>item</span>, then a built-in
template rule is evaluated instead.</p>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> have lower <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than all other
template rules. Thus, the stylesheet author can override a built-in
template rule by including an explicit template rule.</p>
<p>There are six sets of built-in template rules available. The set
that is chosen is a property of the <a title="mode" class="termref"
href="#dt-mode">mode</a> selected by the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction. This property is set using the
<code>on-no-match</code> attribute of the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, which takes
one of the six values <code>deep-copy</code>,
<code>shallow-copy</code>, <code>deep-skip</code>,
<code>shallow-skip</code>, <code>text-only-copy</code>, or
<code>fail</code>, the default being <code>text-only-copy</code>.
The effect of these six sets of built-in template rules is
explained in the following subsections.</p>
<div class="div3">
<h4><a name="built-in-templates-text-only-copy" id=
"built-in-templates-text-only-copy"></a>6.8.1 <a href=
"#built-in-templates-text-only-copy" style=
"text-decoration: none">Built-in Templates: Text-only Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="text-only-copy"</code></span> is that the
textual content of the source document is retained while losing the
markup, except where explicit template rules dictate otherwise.
When an element is encountered for which there is no explicit
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>, the processing continues
with the children of that element. Text nodes are copied to the
output.</p>
<p>The built-in rule for document nodes and element nodes is
equivalent to calling <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. If the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for text and attribute nodes
<span>and atomic values</span> returns a text node containing the
<a title="string value" class="termref" href=
"#dt-string-value">string value</a> of the context node. It is
effectively:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="text()|@*|xs:anyAtomicType" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This text node may have a string value that is zero-length.</p>
</div>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for processing instructions,
comments, namespace nodes, and function items does nothing (it
returns the empty sequence).</p>
<div class="exampleInner">
<pre>
&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()|function(*)" 
   mode="M"/&gt;
</pre></div>
<div class="example">
<div class="exampleHeader"><a name="d7e19345" id=
"d7e19345"></a>Example: Using a Built-In Template Rule</div>
<p>Suppose the stylesheet contains the following instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;
</pre></div>
<p>If there is no explicit template rule that matches the
<code>title</code> element, then the following implicit rule is
used:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="built-in-templates-deep-copy" id=
"built-in-templates-deep-copy"></a>6.8.2 <a href=
"#built-in-templates-deep-copy" style=
"text-decoration: none">Built-in Templates: Deep Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="deep-copy"</code></span> is that an unmatched
element in the source tree is copied unchanged to the output,
together with its entire subtree. Other unmatched items are also
copied unchanged. The subtree is copied unconditionally, without
attempting to match nodes in the subtree against template
rules.</p>
<p>When this default action is selected for a mode <var>M</var>,
all items <span>(nodes, atomic values, and functions)</span> are
processed using a template rule that is equivalent to the
following:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="built-in-templates-shallow-copy" id=
"built-in-templates-shallow-copy"></a>6.8.3 <a href=
"#built-in-templates-shallow-copy" style=
"text-decoration: none">Built-in Templates: Shallow Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="shallow-copy"</code></span> is that the source
tree is copied unchanged to the output, except for nodes where
different processing is specified using an explicit <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<p>When this default action is selected for a mode <var>M</var>,
all items <span>(nodes, atomic values, and functions)</span> are
processed using a template rule that is equivalent to the
following, except that all parameters supplied in <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements are
passed on implicitly to the called templates:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>This rule is often referred to as the <em>identity
template</em>, though it should be noted that it does not preserve
node identity.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule differs from the traditional identity template rule by
using two <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions, one to process the attributes and one to process the
children. The only observable difference from the traditional
<code>select="node() | @*</code> is that with two separate
instructions, the value of <code>position()</code> in the called
templates forms one sequence starting at 1 for the attributes, and
a new sequence starting at 1 for the children.</p>
<p>A further reason for choosing this form is for streamability:
this formulation is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>, whereas the
traditional form using <code>select="node() | @*"</code> is not
(see <a href="#streamability-xsl-apply-templates"><i>19.8.4.5
Streamability of xsl:apply-templates</i></a>).</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e19437" id=
"d7e19437"></a>Example: Modified Identity Transformation</div>
<p>The following stylesheet transforms an input document by
deleting all elements named <code>note</code>, together with their
attributes and descendants:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                                  
&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="built-in-templates-deep-skip" id=
"built-in-templates-deep-skip"></a>6.8.4 <a href=
"#built-in-templates-deep-skip" style=
"text-decoration: none">Built-in Templates: Deep Skip</a></h4>
<p>The effect of processing a tree using a <a title="mode" class=
"termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="deep-skip"</code> is that where no explicit
template rule is specified for an element, that element and all its
descendants are ignored, and are not copied to the result tree.</p>
<p>The effect of choosing <code>on-no-match="deep-skip"</code> is
as follows:</p>
<ul>
<li>
<p>The built-in rule for document nodes is equivalent to calling
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. If the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
</li>
<li>
<p>The built-in rule for all items other than document nodes
<span>(that is, for all other kinds of node, as well as atomic
values and functions)</span> is to do nothing, that is, to return
an empty sequence (without applying templates to any children or
ancestors).</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="built-in-templates-shallow-skip" id=
"built-in-templates-shallow-skip"></a>6.8.5 <a href=
"#built-in-templates-shallow-skip" style=
"text-decoration: none">Built-in Templates: Shallow Skip</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="shallow-skip"</code></span> is to drop both the
textual content and the markup from the result document, except
where there is an explicit user-written <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> that
dictates otherwise.</p>
<p>The built-in rule for document nodes and element nodes is the
same as for <code>on-no-match="text-only-copy"</code>: that is, it
is equivalent to calling <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. If the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p>The built-in template rule for all other kinds of node, and for
atomic values and functions, is empty: that is, when the item is
matched, the built-in template rule returns an empty sequence.</p>
</div>
<div class="div3">
<h4><a name="built-in-templates-fail" id=
"built-in-templates-fail"></a>6.8.6 <a href=
"#built-in-templates-fail" style="text-decoration: none">Built-in
Templates: Fail</a></h4>
<p>The effect of choosing <code>on-no-match="fail"</code> for a
<a title="mode" class="termref" href="#dt-mode">mode</a> is that
every <span>item</span> selected in an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction must be matched by an explicit user-written <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<p>The built-in template rule is effectively:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>with an <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>
message body.</p>
<p><a name="err-XTDE0555" id="err-XTDE0555"><span class=
"error">[ERR XTDE0555]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
used to process a node using a mode whose declaration specifies
<code>on-no-match="fail"</code> when there is no <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> whose match pattern matches that
node.</p>
</div>
</div>
<div class="div2">
<h3><a name="apply-imports" id="apply-imports"></a>6.9 <a href=
"#apply-imports" style="text-decoration: none">Overriding Template
Rules</a></h3>
<p class="element-syntax"><a name="element-apply-imports" id=
"element-apply-imports"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:apply-imports&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:apply-imports&gt;</code></p>
<p class="element-syntax"><a name="element-next-match" id=
"element-next-match"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:next-match&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:next-match&gt;</code></p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that is being used to
override another template rule (see <a href="#conflict"><i>6.4
Conflict Resolution for Template Rules</i></a>) can use the
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction to invoke the overridden template rule. The <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction only considers template rules in imported stylesheet
modules; the <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
considers all other template rules of lower <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and/or priority,
<span>and also declarations of the same precedence and priority
that appear earlier in <a title="declaration order" class="termref"
href="#dt-declaration-order">declaration order</a></span>. Both
instructions will invoke the built-in template rule for the
<span>context item</span> (see <a href="#built-in-rule"><i>6.8
Built-in Template Rules</i></a>) if no other template rule is
found.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-template-rule" id="dt-current-template-rule" title=
"current template rule"></a>At any point in the processing of a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, there may be a <b>current template
rule</b>. Whenever a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is chosen as a result of
evaluating <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, the
template rule becomes the current template rule for the evaluation
of the rule's sequence constructor. When an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, or <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span>
instruction is evaluated, or when evaluating a sequence constructor
contained in an <a href="#element-sort"><code>xsl:sort</code></a>
or <a href="#element-key"><code>xsl:key</code></a> element, or when
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made,</span> the current template rule becomes
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span> for the evaluation of that
instruction or function.<span class="definition">]</span></p>
<p>The current template rule is not affected by invoking named
templates (see <a href="#named-templates"><i>10.1 Named
Templates</i></a>) or named attribute sets (see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a>). While
evaluating a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> or the default value of a
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and Parameters</i></a>)
the current template rule is <span><a title="absent" class=
"termref" href="#dt-absent">absent</a></span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules ensure that when <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a> is
called, the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the same as when the current
template rule was invoked.</p>
</div>
<p>Both <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> and
<a href="#element-next-match"><code>xsl:next-match</code></a>
search for a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that matches the
<span><a title="context item" class="termref" href=
"#dt-context-item">context item</a></span>, and that is applicable
to the <a title="current mode" class="termref" href=
"#dt-current-mode">current mode</a> (see <a href="#modes"><i>6.6
Modes</i></a>). In choosing a template rule, they use the usual
criteria such as the priority and <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
of the template rules, but they consider as candidates only a
subset of the template rules in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This subset differs
between the two instructions:</p>
<ul>
<li>
<p>The <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction considers as candidates only those template rules
contained in <a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> that are descendants
in the <a title="import tree" class="termref" href=
"#dt-import-tree">import tree</a> of the <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> that contains the
<a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is <em>not</em> the same as saying that the search
considers all template rules whose import precedence is lower than
that of the current template rule.</p>
</div>
</li>
<li>
<p>The <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
considers as candidates all those template rules that come after
the <a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a> in the
ordering of template rules implied by the conflict resolution rules
given in <a href="#conflict"><i>6.4 Conflict Resolution for
Template Rules</i></a>. That is, it considers all template rules
with lower <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than the <a title=
"current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>, plus the
template rules that are at the same import precedence that have
lower priority than the current template rule, <span>plus
the</span> template rules with the same import precedence and
priority that occur before the current template rule in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As explained in <a href="#conflict"><i>6.4 Conflict Resolution
for Template Rules</i></a>, a template rule <span>with no
<code>priority</code> attribute</span>, whose match pattern
contains multiple alternatives separated by <code>|</code>, is
treated equivalently to a set of template rules, one for each
alternative. This means that where the same <span>item</span>
matches more than one alternative, it is possible for an <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
to cause the current template rule to be invoked recursively. This
situation does not occur when the <span>template rule has an
explicit</span> priority.</p>
</div>
</li>
</ul>
<p>If no matching template rule is found that satisfies these
criteria, the built-in template rule for the <span>context
item</span> is used (see <a href="#built-in-rule"><i>6.8 Built-in
Template Rules</i></a>).</p>
<p>An <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction may use <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
elements to pass parameters to the chosen <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> (see
<a href="#with-param"><i>9.10 Setting Parameter Values</i></a>). It
also passes on any <a title="tunnel parameter" class="termref"
href="#dt-tunnel-parameter">tunnel parameters</a> as described in
<a href="#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a>.</p>
<p><a name="err-XTDE0560" id="err-XTDE0560"><span class=
"error">[ERR XTDE0560]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
evaluated when the <a title="current template rule" class="termref"
href="#dt-current-template-rule">current template rule</a> is
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e19879" id=
"d7e19879"></a>Example: Using <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a></div>
<p>For example, suppose the stylesheet <code>doc.xsl</code>
contains a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for <code>example</code>
elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Another stylesheet could import <code>doc.xsl</code> and modify
the treatment of <code>example</code> elements as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The combined effect would be to transform an
<code>example</code> into an element of the form:</p>
<div class="exampleInner">
<pre>
&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;
</pre></div>
</div>
<p>An <a href="#element-fallback"><code>xsl:fallback</code></a>
instruction appearing as a child of an <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
is ignored by an XSLT 2.0 <span>or 3.0</span> processor, but can be
used to define fallback behavior when the stylesheet is processed
by an XSLT 1.0 processor with forwards compatible behavior.</p>
</div>
<div class="div2">
<h3><a name="parameters-to-template-rules" id=
"parameters-to-template-rules"></a>6.10 <a href=
"#parameters-to-template-rules" style=
"text-decoration: none">Passing Parameters to Template
Rules</a></h3>
<p>A template rule may have parameters. The parameters are declared
in the body of the template using <a href=
"#element-param"><code>xsl:param</code></a> elements, as described
in <a href="#parameters"><i>9.2 Parameters</i></a>.</p>
<p>Values for these parameters may be supplied in the calling
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction by means of <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
appearing as children of the calling instruction. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> represented by the <code>name</code> attribute of the
<a href="#element-with-param"><code>xsl:with-param</code></a>
element must match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> represented by the
<code>name</code> attribute of the corresponding <a href=
"#element-param"><code>xsl:param</code></a> element.</p>
<p><a name="err-XTDE0700" id="err-XTDE0700"><span class=
"error">[ERR XTDE0700]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if a
template that is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
declares a <a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied by the calling instruction. The same error is reported in
the case of a <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> whether invoked using
one of these three instructions or by <a href=
"#element-call-template"><code>xsl:call-template</code></a>, as
explained in <a href="#tunnel-params"><i>10.1.2 Tunnel
Parameters</i></a>.</p>
<p>It is not an error for these instructions to supply a parameter
that does not match any parameter declared in the template rule
that is invoked; unneeded parameter values are simply ignored.</p>
<p>A parameter may be declared as a <a title="tunnel parameter"
class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> by
specifying <code>tunnel="yes"</code> in the <a href=
"#element-param"><code>xsl:param</code></a> declaration; in this
case the caller must supply the value as a tunnel parameter by
specifying <code>tunnel="yes"</code> in the corresponding <a href=
"#element-with-param"><code>xsl:with-param</code></a> element.
Tunnel parameters differ from ordinary template parameters in that
they are passed transparently through multiple template
invocations. They are fully described in <a href=
"#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="repetition" id="repetition"></a>7 <a href=
"#repetition" style="text-decoration: none">Repetition</a></h2>
<p>XSLT offers two constructs for processing each item of a
sequence: <a href="#element-for-each"><code>xsl:for-each</code></a>
and <a href="#element-iterate"><code>xsl:iterate</code></a>.</p>
<p>The main difference between the two constructs is that with
<a href="#element-for-each"><code>xsl:for-each</code></a>, the
processing applied to each item in the sequence is independent of
the processing applied to any other item; this means that the items
may be processed in any order or in parallel, though the order of
the output sequence is well defined and corresponds to the order of
the input (sorted if so requested). By contrast, with <a href=
"#element-iterate"><code>xsl:iterate</code></a>, the processing is
explicitly sequential: while one item is being processed, values
may be computed which are then available for use while the next
item is being processed. This makes <a href=
"#element-iterate"><code>xsl:iterate</code></a> suitable for tasks
such as creating a running total over a sequence of financial
transactions.</p>
<p>A further difference is that <a href=
"#element-for-each"><code>xsl:for-each</code></a> permits sorting
of the input sequence, while <a href=
"#element-iterate"><code>xsl:iterate</code></a> does not.</p>
<div class="div2">
<h3><a name="for-each" id="for-each"></a>7.1 <a href="#for-each"
style="text-decoration: none">The</a> <code>xsl:for-each</code>
<a href="#for-each" style=
"text-decoration: none">instruction</a></h3>
<p class="element-syntax"><a name="element-for-each" id=
"element-for-each"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:for-each<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each&gt;</code></p>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction processes each item in a sequence of items, evaluating
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> within the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction once for each item in that sequence.</p>
<p>The <code>select</code> attribute is <span class=
"verb">required</span>; it contains an <a title="expression" class=
"termref" href="#dt-expression">expression</a> which is evaluated
to produce a sequence, called the input sequence. If there is an
<a href="#element-sort"><code>xsl:sort</code></a> element present
(see <a href="#sorting"><i>13 Sorting</i></a>) the input sequence
is sorted to produce a sorted sequence. Otherwise, the sorted
sequence is the same as the input sequence.</p>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction contains a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>.
The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated
once for each item in the sorted sequence, with the <a title=
"focus" class="termref" href="#dt-focus">focus</a> set as
follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the item being
processed.</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of this
item in the sorted sequence.</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the size of the sorted
sequence (which is the same as the size of the input sequence).</p>
</li>
</ul>
<p>For each item in the input sequence, evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> produces a
sequence of items (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>). These output sequences are
concatenated; if item <var>Q</var> follows item <var>P</var> in the
sorted sequence, then the result of evaluating the sequence
constructor with <var>Q</var> as the context item is concatenated
after the result of evaluating the sequence constructor with
<var>P</var> as the context item. The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is
the concatenated sequence of items.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20168" id=
"d7e20168"></a>Example: Using <a href=
"#element-for-each"><code>xsl:for-each</code></a></div>
<p>For example, given an XML document with this structure</p>
<div class="exampleInner">
<pre>
&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;
</pre></div>
<p>the following would create an HTML document containing a table
with a row for each <code>customer</code> element</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="iterate" id="iterate"></a>7.2 <a href="#iterate"
style="text-decoration: none">The</a> <code>xsl:iterate</code>
<a href="#iterate" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-iterate" id=
"element-iterate"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:iterate<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>,
<a href="#element-on-completion">xsl:on-completion</a>?)
--&gt;<br />
&lt;/xsl:iterate&gt;</code></p>
<p class="element-syntax"><a name="element-next-iteration" id=
"element-next-iteration"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:next-iteration&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a>*) --&gt;<br />
&lt;/xsl:next-iteration&gt;</code></p>
<p class="element-syntax"><a name="element-break" id=
"element-break"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:break<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:break&gt;</code></p>
<p class="element-syntax"><a name="element-on-completion" id=
"element-on-completion"></a><code>&lt;xsl:on-completion<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:on-completion&gt;</code></p>
<p>The <code>select</code> attribute is <span class=
"verb">required</span>; it contains an <a title="expression" class=
"termref" href="#dt-expression">expression</a> which is evaluated
to produce a sequence, called the input sequence.</p>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction is evaluated once for each item in the input sequence,
in order, or until the loop exits by evaluating an <a href=
"#element-break"><code>xsl:break</code></a> instruction, whichever
is earlier. Within the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
that forms the body of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> is set to each item from the
value of the <code>select</code> expression in turn; the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> reflects the position
of this item in the input sequence, and the <a title="context size"
class="termref" href="#dt-context-size">context size</a> is the
number of items in the input sequence (which may be greater than
the number of iterations, if the loop exits prematurely using
<a href="#element-break"><code>xsl:break</code></a>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If <a href="#element-iterate"><code>xsl:iterate</code></a> is
used in conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a> to achieve streaming,
calls on the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
will be disallowed.</p>
</div>
<p>The <a href="#element-break"><code>xsl:break</code></a> and
<a href="#element-on-completion"><code>xsl:on-completion</code></a>
elements may have either a <code>select</code> attribute or a
non-empty contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> but not
both. The effect of the element in both cases is obtained by
evaluating the <code>select</code> expression if present or the
contained sequence constructor otherwise; if neither is present,
the value is an empty sequence.</p>
<p>The effect of <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> is to
cause the iteration to continue by processing the next item in the
input sequence, potentially with different values for the iteration
parameters. The effect of <a href=
"#element-break"><code>xsl:break</code></a> is to cause the
iteration to finish, whether or not all the items in the input
sequence have been processed. In both cases the affected iteration
is the one controlled by the innermost ancestor <a href=
"#element-iterate"><code>xsl:iterate</code></a> element.</p>
<p>The instructions <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> and
<a href="#element-break"><code>xsl:break</code></a> are allowed
only as descendants of an <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, and
only in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-tail-position" id="dt-tail-position" title=
"tail position"></a>An <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> <var>J</var> is in a <b>tail
position</b> within a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
<var>SC</var> if it satisfies one of the following
conditions:<span class="definition">]</span></p>
<ul>
<li>
<p><var>J</var> is the last instruction in <var>SC</var>, ignoring
any <a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-if"><code>xsl:if</code></a> instruction that is itself in
a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch of an
<a href="#element-choose"><code>xsl:choose</code></a> instruction
that is itself in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-try"><code>xsl:try</code></a> instruction that is itself
in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var> (that
is, it is immediately followed by an <a href=
"#element-catch"><code>xsl:catch</code></a> element, ignoring any
<a href="#element-fallback"><code>xsl:fallback</code></a>
elements).</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-catch"><code>xsl:catch</code></a> element within an
<a href="#element-try"><code>xsl:try</code></a> instruction that is
itself in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
</ul>
<p><a name="err-XTSE3120" id="err-XTSE3120"><span class=
"error">[ERR XTSE3120]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-break"><code>xsl:break</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element appears other than in a <a title="tail position" class=
"termref" href="#dt-tail-position">tail position</a> within the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
<p><a name="err-XTSE3125" id="err-XTSE3125"><span class=
"error">[ERR XTSE3125]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> is
present and the instruction has children.</p>
<p><a name="err-XTSE3130" id="err-XTSE3130"><span class=
"error">[ERR XTSE3130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>name</code> attribute of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child of an
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element does not match the <code>name</code> attribute of an
<a href="#element-param"><code>xsl:param</code></a> child of the
<span>innermost</span> containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction.</p>
<p>Parameter names in <a href=
"#element-with-param"><code>xsl:with-param</code></a> must be
unique: <span class="error">[see <a href="#err-XTSE0670">ERR
XTSE0670</a>]</span>.</p>
<p>The result of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction is the
concatenation of the sequences that result from the repeated
evaluation of the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
followed by the sequence that results from evaluating the <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
if any.</p>
<p>Any <a href="#element-param"><code>xsl:param</code></a> element
that appears as a child of <a href=
"#element-iterate"><code>xsl:iterate</code></a> declares a
parameter whose value may vary from one iteration to the next. The
initial value of the parameter is the value obtained according to
the rules given in <a href="#variable-values"><i>9.3 Values of
Variables and Parameters</i></a>. The dynamic context for
evaluating the initial value of an <a href=
"#element-param"><code>xsl:param</code></a> element is the same as
the dynamic context for evaluating the <code>select</code>
expression of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction (the
context item is thus <em>not</em> the first item in the input
sequence).</p>
<p>On the first iteration a parameter always takes its initial
value (which may depend on variables or other aspects of the
dynamic context). Subsequently:</p>
<ul>
<li>
<p>If an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction is evaluated, then parameter values for processing the
next item in the input sequence can be set in the <a href=
"#element-with-param"><code>xsl:with-param</code></a> children of
that instruction; in the absence of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
names a particular parameter, that parameter will retain its value
from the previous iteration.</p>
</li>
<li>
<p>If an <a href="#element-break"><code>xsl:break</code></a>
instruction is evaluated, no further items in the input sequence
are processed.</p>
</li>
<li>
<p>If neither an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> nor
an <a href="#element-break"><code>xsl:break</code></a> instruction
is evaluated, then the next item in the input sequence is processed
using parameter values that are unchanged from the previous
iteration.</p>
</li>
</ul>
<p>The <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction contributes nothing to the result sequence
(technically, it returns an empty sequence). The instruction
supplies parameter values for the next iteration, which are
evaluated according to the rules given in <a href=
"#with-param"><i>9.10 Setting Parameter Values</i></a>; if there
are no further items in the input sequence then it supplies
parameter values for use while evaluating the body of the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
if any.</p>
<p>The <a href="#element-break"><code>xsl:break</code></a>
instruction indicates that the iteration should terminate without
processing any remaining items from the input sequence. The
<span><code>select</code> expression or</span> contained sequence
constructor is evaluated using the same context item, position, and
size as the <a href="#element-break"><code>xsl:break</code></a>
instruction itself, and the result is appended to the result of the
<a href="#element-iterate"><code>xsl:iterate</code></a> instruction
as a whole.</p>
<p>If neither an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> nor
an <a href="#element-break"><code>xsl:break</code></a> instruction
is evaluated, the next item in the input sequence is processed with
parameter values unchanged from the previous iteration; if there
are no further items in the input sequence, the iteration
terminates.</p>
<p>The optional <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
(which is not technically an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> and is not technically part
of the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>) is evaluated
when the input sequence is exhausted. It is not evaluated if the
evaluation is terminated using <a href=
"#element-break"><code>xsl:break</code></a>. During evaluation of
this sequence constructor the context item, position, and size are
<a title="absent" class="termref" href="#dt-absent">absent</a>
(that is, any reference to these values is an error). However, the
values of the parameters to <a href=
"#element-iterate"><code>xsl:iterate</code></a> are available, and
take the values supplied by the <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction evaluated while processing the last item in the
sequence.</p>
<p>If the input sequence is empty, then the result of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction is the
result of evaluating the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
forming the body of the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, using the initial values of the <a href=
"#element-param"><code>xsl:param</code></a> elements. If there is
no <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, the result is an empty sequence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Conceptually, <a href=
"#element-iterate"><code>xsl:iterate</code></a> behaves like a
tail-recursive function. The <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction then represents the recursive call, supplying the tail
of the input sequence as an implicit parameter. There are two main
reasons for providing the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction. One is
that many XSLT users find writing recursive functions to be a
difficult skill, and this construct promises to be easier to learn.
The other is that recursive function calls are difficult for an
optimizer to analyze. Because <a href=
"#element-iterate"><code>xsl:iterate</code></a> is more constrained
than a general-purpose head-tail recursive function, it should be
more amenable to optimization. In particular, when the instruction
is used in conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a>, it is designed to
make it easy for the implementation to use streaming techniques,
processing the nodes in an input document sequentially as they are
read, without building the entire document tree in memory.</p>
</div>
<p>The examples below use <a href=
"#element-iterate"><code>xsl:iterate</code></a> in conjunction with
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction. This is not the only way of using <a href=
"#element-iterate"><code>xsl:iterate</code></a>, but it illustrates
the way in which the two features can be combined to achieve
streaming of a large input document.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20694" id=
"d7e20694"></a>Example: Using <a href=
"#element-iterate"><code>xsl:iterate</code></a> to Compute
Cumulative Totals</div>
<p>Suppose that the input XML document has this structure</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>and that the requirement is to transform this to:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;
</pre></div>
<p>This can be achieved using the following code, which is designed
to process the transaction file using streaming:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{$newBalance}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>The following example modifies this by only outputting the
information for the first day's transactions:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="'transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>The following code outputs the balance only at the end of each
day, together with the final balance:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>If the sequence of transactions is empty, this code outputs a
single element: <code>&lt;balance date=""
value="0.00"/&gt;</code>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20726" id=
"d7e20726"></a>Example: Collecting Multiple Values in a Single
Pass</div>
<p>Problem: Given a sequence of <code>employee</code> elements,
find the employees having the highest and lowest salary, while
processing each employee only once.</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="employees/employee"&gt;
    &lt;xsl:param name="highest" as="element(employee)*"/&gt;
    &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
    &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                  select="empty($highest[@salary ge current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                  select="exists($highest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                  select="empty($lowest[@salary le current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                  select="exists($lowest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                  select="if ($is-new-highest) then .
                          else if ($is-equal-highest) then ($highest, .)
                          else $highest"/&gt;
    &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                  select="if ($is-new-lowest) then .
                          else if ($is-equal-lowest) then ($lowest, .)
                          else $lowest"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
      &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;highest-paid-employees&gt;
        &lt;xsl:value-of select="$highest/name"/&gt;
      &lt;/highest-paid-employees&gt;
      &lt;lowest-paid-employees&gt;
        &lt;xsl:value-of select="$lowest/name"/&gt;
      &lt;/lowest-paid-employees&gt;  
    &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:stream&gt;
</pre></div>
<p>If the input sequence is empty, this code outputs an empty
<code>highest-paid-employees</code> element and an empty
<code>lowest-paid-employees</code> element.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20746" id=
"d7e20746"></a>Example: Processing the Last Item in a Sequence
Specially</div>
<p>When streaming, some limited look-ahead is needed to determine
whether the item being processed is the last in a sequence. The
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
function cannot be used in <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> code. The
<a href="#element-iterate"><code>xsl:iterate</code></a> instruction
provides a solution to this problem.</p>
<p>Problem: render the last paragraph in a section in some special
way, for example by using bold face. (The actual rendition is
achieved by processing the paragraph with mode
<code>last-para</code>.)</p>
<p>The solution uses <a href=
"#element-iterate"><code>xsl:iterate</code></a> <span>together with
the <a href="#func-copy-of"><code>copy-of</code></a>
function</span> to maintain a one-element lookahead by explicit
coding:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="copy-of(.)"/&gt;
     &lt;/xsl:next-iteration&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="conditionals" id="conditionals"></a>8 <a href=
"#conditionals" style="text-decoration: none">Conditional
Processing</a></h2>
<p>There are two instructions in XSLT that support conditional
processing: <a href="#element-if"><code>xsl:if</code></a> and
<a href="#element-choose"><code>xsl:choose</code></a>. The <a href=
"#element-if"><code>xsl:if</code></a> instruction provides simple
if-then conditionality; the <a href=
"#element-choose"><code>xsl:choose</code></a> instruction supports
selection of one choice when there are several possibilities.</p>
<p>XSLT 3.0 also supports <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a> which define
conditional processing to handle <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic errors</a>.</p>
<div class="div2">
<h3><a name="xsl-if" id="xsl-if"></a>8.1 <a href="#xsl-if" style=
"text-decoration: none">Conditional Processing with</a> <a href=
"#element-if"><code>xsl:if</code></a> <a href="#xsl-if" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-if" id=
"element-if"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:if<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:if&gt;</code></p>
<p>The <a href="#element-if"><code>xsl:if</code></a> element has a
mandatory <code>test</code> attribute, which specifies an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The content is a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The result of the <a href="#element-if"><code>xsl:if</code></a>
instruction depends on the <a href=
"http://www.w3.org/TR/xpath-30/#dt-ebv">effective boolean
value</a><sup><small>XP30</small></sup> of the expression in the
<code>test</code> attribute. The rules for determining the
effective boolean value of an expression are given in <a href=
"#xpath-30">[XPath 3.0]</a>: they are the same as the rules used
for XPath conditional expressions.</p>
<p>If the effective boolean value of the <a title="expression"
class="termref" href="#dt-expression">expression</a> is true, then
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated
(see <a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>), and the resulting sequence is returned as
the result of the <a href="#element-if"><code>xsl:if</code></a>
instruction; otherwise, the sequence constructor is not evaluated,
and the empty sequence is returned.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20860" id=
"d7e20860"></a>Example: Using <a href=
"#element-if"><code>xsl:if</code></a></div>
<p>In the following example, the names in a group of names are
formatted as a comma separated list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The following colors every other table row yellow:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="xsl-choose" id="xsl-choose"></a>8.2 <a href=
"#xsl-choose" style="text-decoration: none">Conditional Processing
with</a> <a href="#element-choose"><code>xsl:choose</code></a>
<a href="#xsl-choose" style="text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-choose" id=
"element-choose"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-when">xsl:when</a>+, <a href=
"#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
&lt;/xsl:choose&gt;</code></p>
<p class="element-syntax"><a name="element-when" id=
"element-when"></a><code>&lt;xsl:when<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:when&gt;</code></p>
<p class="element-syntax"><a name="element-otherwise" id=
"element-otherwise"></a><code>&lt;xsl:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:otherwise&gt;</code></p>
<p>The <a href="#element-choose"><code>xsl:choose</code></a>
element selects one among a number of possible alternatives. It
consists of a sequence of one or more <a href=
"#element-when"><code>xsl:when</code></a> elements followed by an
optional <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element. Each
<a href="#element-when"><code>xsl:when</code></a> element has a
single attribute, <code>test</code>, which specifies an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The content of the <a href=
"#element-when"><code>xsl:when</code></a> and <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> elements is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>When an <a href="#element-choose"><code>xsl:choose</code></a>
element is processed, each of the <a href=
"#element-when"><code>xsl:when</code></a> elements is tested in
turn (that is, in the order that the elements appear in the
stylesheet), until one of the <a href=
"#element-when"><code>xsl:when</code></a> elements is satisfied. If
none of the <a href="#element-when"><code>xsl:when</code></a>
elements is satisfied, then the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element is
considered, as described below.</p>
<p>An <a href="#element-when"><code>xsl:when</code></a> element is
satisfied if the <a href=
"http://www.w3.org/TR/xpath-30/#dt-ebv">effective boolean
value</a><sup><small>XP30</small></sup> of the <a title=
"expression" class="termref" href="#dt-expression">expression</a>
in its <code>test</code> attribute is <code>true</code>. The rules
for determining the effective boolean value of an expression are
given in <a href="#xpath-30">[XPath 3.0]</a>: they are the same as
the rules used for XPath conditional expressions.</p>
<p>The content of the first, and only the first, <a href=
"#element-when"><code>xsl:when</code></a> element that is satisfied
is evaluated, and the resulting sequence is returned as the result
of the <a href="#element-choose"><code>xsl:choose</code></a>
instruction. If no <a href=
"#element-when"><code>xsl:when</code></a> element is satisfied, the
content of the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element is
evaluated, and the resulting sequence is returned as the result of
the <a href="#element-choose"><code>xsl:choose</code></a>
instruction. If no <a href=
"#element-when"><code>xsl:when</code></a> element is satisfied, and
no <a href="#element-otherwise"><code>xsl:otherwise</code></a>
element is present, the result of the <a href=
"#element-choose"><code>xsl:choose</code></a> instruction is an
empty sequence.</p>
<p>Only the sequence constructor of the selected <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> instruction is
evaluated. The <code>test</code> expressions for <a href=
"#element-when"><code>xsl:when</code></a> instructions after the
selected one are not evaluated.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e21004" id=
"d7e21004"></a>Example: Using <a href=
"#element-choose"><code>xsl:choose</code></a></div>
<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth
to which the ordered lists are nested.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="try-catch" id="try-catch"></a>8.3 <a href="#try-catch"
style="text-decoration: none">Try/Catch</a></h3>
<p>The <a href="#element-try"><code>xsl:try</code></a> instruction
can be used to trap dynamic errors occurring within the expression
it wraps; the recovery action if such errors occur is defined using
a child <a href="#element-catch"><code>xsl:catch</code></a>
element.</p>
<p class="element-syntax"><a name="element-try" id=
"element-try"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:try<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>,
<a href="#element-catch">xsl:catch</a>, (<a href=
"#element-catch">xsl:catch</a> | <a href=
"#element-fallback">xsl:fallback</a>)*) --&gt;<br />
&lt;/xsl:try&gt;</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because a sequence constructor may contain an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element, the
effect of this content model is that an <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction may
appear as a child of <a href=
"#element-try"><code>xsl:try</code></a> in any position.</p>
</div>
<p class="element-syntax"><a name="element-catch" id=
"element-catch"></a><code>&lt;xsl:catch<br />
&#160;&#160;errors? = <var>tokens</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:catch&gt;</code></p>
<p>An <a href="#element-try"><code>xsl:try</code></a> instruction
evaluates either the expression contained in its
<code>select</code> attribute, or its contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and returns
the result of that evaluation if it succeeds without error. If a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the evaluation,
the processor evaluates the first <a href=
"#element-catch"><code>xsl:catch</code></a> child element
applicable to the error, and returns that result instead.</p>
<p>If the <a href="#element-try"><code>xsl:try</code></a> element
has a <code>select</code> attribute, then it <span class=
"verb">must</span> have no children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a>. That is, the
<code>select</code> attribute and the contained sequence
constructor are mutually exclusive. If neither is present, the
result of the <a href="#element-try"><code>xsl:try</code></a> is an
empty sequence (no dynamic error can occur in this case).</p>
<p><a name="err-XTSE3140" id="err-XTSE3140"><span class=
"error">[ERR XTSE3140]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-try"><code>xsl:try</code></a> element is present and the
element has children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children of the <a href="#element-try"><code>xsl:try</code></a>
element are ignored by an XSLT 3.0 processor, but can be used to
define the recovery action taken by an XSLT 1.0 or XSLT 2.0
processor operating with <a title="forwards compatible behavior"
class="termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a>.</p>
<p>The <a href="#element-catch"><code>xsl:catch</code></a> element
has an optional <code>errors</code> attribute, which lists the
error conditions that the <a href=
"#element-catch"><code>xsl:catch</code></a> element is designed to
intercept. The default value is <code>errors="*"</code>, which
catches all errors. The value is a whitespace-separated list of
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>;
an <a href="#element-catch"><code>xsl:catch</code></a> element
catches an error condition if this list includes a
<code>NameTest</code> that matches the error code associated with
that error condition.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Error codes are QNames. Those defined in this specification and
in related specifications are all in the <a title=
"standard error namespace" class="termref" href=
"#dt-standard-error-namespace">standard error namespace</a>, and
may therefore be caught using an <a href=
"#element-catch"><code>xsl:catch</code></a> element such as
<code>&lt;xsl:catch errors="err:FODC0001 err:FODC0005"&gt;</code>
where the namespace prefix <code>err</code> is bound to this
namespace. Errors defined by implementors, and errors raised by an
explicit call of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function or by use of the <a href=
"#element-message"><code>xsl:message</code></a> <span>or <a href=
"#element-assert"><code>xsl:assert</code></a></span> instruction,
may use error codes in other namespaces.</p>
</div>
<p>If more than one <a href=
"#element-catch"><code>xsl:catch</code></a> element matches an
error, the error is processed using the first one that matches, in
document order. If no <a href=
"#element-catch"><code>xsl:catch</code></a> matches the error, then
the error is not caught (that is, evaluation of the <a href=
"#element-try"><code>xsl:try</code></a> element fails with the
dynamic error).</p>
<p>An <a href="#element-catch"><code>xsl:catch</code></a> element
may have either a <code>select</code> attribute, or a contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><a name="err-XTSE3150" id="err-XTSE3150"><span class=
"error">[ERR XTSE3150]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-catch"><code>xsl:catch</code></a> element is present
unless the element has empty content.</p>
<p>The result of evaluating the <a href=
"#element-catch"><code>xsl:catch</code></a> element is the result
of evaluating the XPath expression in its <code>select</code>
attribute or the result of evaluating the contained sequence
constructor; if neither is present, the result is an empty
sequence. This result is delivered as the result of the
<code>xsl:try</code> instruction.</p>
<p>If a dynamic error occurs during the evaluation of <a href=
"#element-catch"><code>xsl:catch</code></a>, it causes the
containing <a href="#element-try"><code>xsl:try</code></a> to fail
with this error. The error is not caught by other sibling <a href=
"#element-catch"><code>xsl:catch</code></a> elements within the
same <a href="#element-try"><code>xsl:try</code></a> instruction,
but it may be caught by an <a href=
"#element-try"><code>xsl:try</code></a> instruction at an outer
level, or by an <a href="#element-try"><code>xsl:try</code></a>
instruction nested within the <a href=
"#element-catch"><code>xsl:catch</code></a>.</p>
<p>Within the <code>select</code> expression, or within the
sequence constructor contained by the <a href=
"#element-catch"><code>xsl:catch</code></a> element, a number of
variables are implicitly declared, giving information about the
error that occurred. These are lexically scoped to the
<code>xsl:catch</code> element. These variables are all in the
<a title="standard error namespace" class="termref" href=
"#dt-standard-error-namespace">standard error namespace</a>, and
they are initialized as described in the following table:</p>
<table border="1" cellpadding="5" summary=
"variables containing information for use within try/catch" width=
"100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Variable</th>
<th align="left" colspan="1" valign="top">Type</th>
<th align="left" colspan="1" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">err:code</td>
<td valign="top" align="left">xs:QName</td>
<td valign="top" align="left">The error code</td>
</tr>
<tr>
<td valign="top" align="left">err:description</td>
<td valign="top" align="left">xs:string<span>?</span></td>
<td valign="top" align="left">A description of the error condition;
<span>an empty sequence if no description is available (for
example, if the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function was called with one argument)</span>.</td>
</tr>
<tr>
<td valign="top" align="left">err:value</td>
<td valign="top" align="left">item()*</td>
<td valign="top" align="left">Value associated with the error. For
an error raised by calling the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function, this is the value of the third argument (if supplied).
For an error raised by evaluating <a href=
"#element-message"><code>xsl:message</code></a> with
<code>terminate="yes"</code>, <span>or a failing <a href=
"#element-assert"><code>xsl:assert</code></a></span>, this is the
document node at the root of the tree containing the XML message
body.</td>
</tr>
<tr>
<td valign="top" align="left">err:module</td>
<td valign="top" align="left">xs:string?</td>
<td valign="top" align="left">The URI (or system ID) of the
stylesheet module containing the instruction where the error
occurred; an empty sequence if the information is not
available.</td>
</tr>
<tr>
<td valign="top" align="left">err:line-number</td>
<td valign="top" align="left">xs:integer?</td>
<td valign="top" align="left">The line number within the stylesheet
module of the instruction where the error occurred; an empty
sequence if the information is not available. The value
<span class="verb">may</span> be approximate.</td>
</tr>
<tr>
<td valign="top" align="left">err:column-number</td>
<td valign="top" align="left">xs:integer?</td>
<td valign="top" align="left">The column number within the
stylesheet module of the instruction where the error occurred; an
empty sequence if the information is not available. The value
<span class="verb">may</span> be approximate.</td>
</tr>
</tbody>
</table>
<p>Variables declared within the sequence constructor of the
<a href="#element-try"><code>xsl:try</code></a> element (and not
within an <a href="#element-catch"><code>xsl:catch</code></a>) are
not visible within the <a href=
"#element-catch"><code>xsl:catch</code></a> element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Within an <a href="#element-catch"><code>xsl:catch</code></a> it
is possible to re-throw the error using the function call
<code>error($err:code, $err:description, $err:value)</code>.</p>
</div>
<p>The following additional rules apply to the catching of
errors:</p>
<ol class="enumar">
<li>
<p>All dynamic errors occurring during the evaluation of the
<a href="#element-try"><code>xsl:try</code></a> sequence
constructor or <code>select</code> expression are caught (provided
they match one of the <a href=
"#element-catch"><code>xsl:catch</code></a> elements).</p>
<ul>
<li>
<p>This includes errors occurring in functions or templates invoked
in the course of this evaluation, unless already caught by a nested
<a href="#element-try"><code>xsl:try</code></a>.</p>
</li>
<li>
<p>It also includes errors caused by calling the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function, or the <a href=
"#element-message"><code>xsl:message</code></a> instruction with
<code>terminate="yes"</code>, or the <span><a href=
"#element-assert"><code>xsl:assert</code></a>
instruction</span>.</p>
</li>
<li>
<p>It does not include errors that occur while evaluating
references to variables whose declaration and initialization is
outside the <a href="#element-try"><code>xsl:try</code></a>.</p>
</li>
</ul>
</li>
<li>
<p>The existence of an <a href=
"#element-try"><code>xsl:try</code></a> instruction does not affect
the obligation of the processor to signal certain errors as static
errors, or its right to choose whether to signal some errors (such
as <a title="type error" class="termref" href="#dt-type-error">type
errors</a>) statically or dynamically. Static errors are never
caught.</p>
</li>
<li>
<p>Some fatal errors arising in the processing environment, such as
running out of memory, may cause termination of the transformation
despite the presence of an <a href=
"#element-try"><code>xsl:try</code></a> instruction. This is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>If the sequence constructor or <code>select</code> expression of
the <a href="#element-try"><code>xsl:try</code></a> causes
execution of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<a href="#element-message"><code>xsl:message</code></a>, <span>or
<a href="#element-assert"><code>xsl:assert</code></a></span>
instructions and fails with a dynamic error that is caught, it is
implementation-dependent whether these instructions have any
externally visible effect. The processor is <span class="verb">not
required</span> to roll back any changes made by these
instructions. The same applies to any side effects caused by
extension functions or extension instructions.</p>
</li>
<li>
<p>A serialization error that occurs during the serialization of a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> produced using
<a href=
"#element-result-document"><code>xsl:result-document</code></a> is
treated as a dynamic error in the evaluation of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, and may be caught by a containing <a href=
"#element-try"><code>xsl:try</code></a> instruction. A
serialization error that occurs while serializing the implicit
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> returned by the
<a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a> is treated as occurring
after the transformation has finished, and cannot be caught.</p>
</li>
<li>
<p>A validation error is treated as occurring in the instruction
that requested validation. For example, if the stylesheet is
producing XHTML output and requests validation of the entire result
document by means of the attribute <code>validation="strict"</code>
on the instruction that creates the outermost <code>html</code>
element, then a validation failure can be caught only at that
level. Although the validation error might be detected, for
example, while writing a <code>p</code> element at a location where
no <code>p</code> element is allowed, it is not treated as an error
in the instruction that writes the <code>p</code> element and
cannot be caught at that level.</p>
</li>
<li>
<p>A type error may be caught if the processor raises it
dynamically; this does not affect the processor's right to raise
the error statically if it chooses.</p>
<p>The following rules are provided to define which expression is
considered to fail when a type error occurs, and therefore where
the error can be caught. The general principle is that where the
semantics of a construct <var>C</var> place requirements on the
type of some subexpression, a type error is an error in the
evaluation of <var>C</var>, not in the evaluation of the
subexpression.</p>
<p>For example, consider the following construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>The expected type of the result of the sequence constructor is
<code>xs:integer</code>; if the value of variable <code>$foo</code>
turns out to be a string, then a type error will occur. It is not
possible to catch this by writing:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>This fails to catch the error because the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction is
deemed to evaluate successfully; the failure only occurs when the
result of this instruction is bound to the variable.</p>
<p>A similar rule applies to functions: if the body of a function
computes a result which does not conform to the required type of
the function result, it is not possible to catch this error within
the function body itself; it can only be caught by the caller of
the function. Similarly, if an expression used to compute an
argument to a function returns a value of the wrong type for the
function signature, this is not considered an error in this
expression, but an error in evaluating the function call as a
whole.</p>
<p>A consequence of these rules is that when a type error occurs
while initializing a global variable (because the initializer
returns a value of the wrong type, given the declared type of the
variable), then this error cannot be caught.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because processors are permitted to report type errors during
static analysis, it is unwise to attempt to recover from type
errors dynamically. The best strategy is generally to prevent their
occurrence. For example, rather than writing <code>$p + 1</code>
where <code>$p</code> is a parameter of unknown type, and then
catching the type error that occurs if <code>$p</code> is not
numeric, it is better first to test whether <code>$p</code> is
numeric, perhaps by means of an expression such as <code>$p
instance of my:numeric</code>, where <code>my:numeric</code> is a
union type with <code>xs:double</code>, <code>xs:float</code>, and
<code>xs:decimal</code> as its member types.</p>
</div>
</li>
<li>
<p>The fact that the application tries to catch errors does not
prevent the processor from organizing the evaluation in such a way
as to prevent errors occurring. For example <code>exists(//a[10 div
. gt 5])</code> may still do an "early exit", rather than examining
every item in the sequence just to see if it triggers a
divide-by-zero error.</p>
</li>
<li>
<p>Except as specified above, the optimizer must not rearrange the
evaluation (at compile time or at run time) so that expressions
written to be subject to the try/catch are evaluated outside its
scope, or expressions written to be external to the try/catch are
evaluated within its scope. This does not prevent expressions being
rearranged, but any expression that is so rearranged must carry its
try/catch context with it.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an error occurs while evaluating an instruction within
<a href="#element-try"><code>xsl:try</code></a>, then no
instruction within the <a href=
"#element-try"><code>xsl:try</code></a> has any effect on the
result returned by the <a href=
"#element-try"><code>xsl:try</code></a> instruction. This means
that if a processor is streaming the output to a serializer, it
needs to adopt a strategy such as buffering the output in memory so
that nothing is written until successful completion of the <a href=
"#element-try"><code>xsl:try</code></a> instruction, or
checkpointing the output so it can be rolled back when an error
occurs.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Use of try/catch may affect the ability of a processor to
perform streamed evaluation of a stylesheet. If the sequence
constructor contained within <a href=
"#element-try"><code>xsl:try</code></a> creates a sequence of ten
elements, and these form part of a final result tree, then if a
failure occurs while writing the tenth element, the work of
creating the previous nine must be "undone". In effect this means
that either the processor must delay sending the new elements to
the serializer until it is assured of success, or the serializer
must provide a mechanism to roll back elements already written.</p>
</div>
<div class="div3">
<h4><a name="try-catch-examples" id="try-catch-examples"></a>8.3.1
<a href="#try-catch-examples" style=
"text-decoration: none">Try/Catch Examples</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e21637" id=
"d7e21637"></a>Example: Catching a Divide-by-Zero Error</div>
<p>The following example divides an employee's salary by the number
of years they have served, catching the divide-by-zero error if the
latter is zero.</p>
<div class="exampleInner">
<pre>
&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FAOR0001" select="()"/&gt;
&lt;/xsl:try&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e21644" id=
"d7e21644"></a>Example: Catching an Error during Result-tree
Validation</div>
<p>The following example generates a result tree and performs
schema validation, outputting a warning message and serializing the
invalid tree if validation fails.</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>The reason that the result tree is constructed in a variable in
this example is so that the unvalidated tree is available to be
used within the <a href="#element-catch"><code>xsl:catch</code></a>
element. An alternative approach would be to repeat the logic for
constructing the tree:</p>
<div class="exampleInner">
<pre>
&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="variables-and-parameters" id=
"variables-and-parameters"></a>9 <a href=
"#variables-and-parameters" style="text-decoration: none">Variables
and Parameters</a></h2>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-variable-binding-element" id="dt-variable-binding-element"
title="variable-binding element"></a>The two elements <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are referred to as
<b>variable-binding elements</b> <span class=
"definition">]</span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-variable" id="dt-variable" title="variable"></a>The <a href=
"#element-variable"><code>xsl:variable</code></a> element declares
a <b>variable</b>, which may be a <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a> or a
<a title="local variable" class="termref" href=
"#dt-local-variable">local variable</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-parameter" id="dt-parameter" title="parameter"></a>The <a href=
"#element-param"><code>xsl:param</code></a> element declares a
<b>parameter</b>, which may be a <a title="stylesheet parameter"
class="termref" href="#dt-stylesheet-parameter">stylesheet
parameter</a>, a <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameter</a>, a <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a><span>, or an
<a href="#element-iterate"><code>xsl:iterate</code></a>
parameter</span>. A parameter is a <a title="variable" class=
"termref" href="#dt-variable">variable</a> with the additional
property that its value can be set by the caller.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-value" id="dt-value" title="value"></a>A variable is a binding
between a name and a value. The <b>value</b> of a variable is any
sequence (of nodes, atomic values, <span>and/or function
items</span>), as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.<span class="definition">]</span></p>
<div class="div2">
<h3><a name="variables" id="variables"></a>9.1 <a href="#variables"
style="text-decoration: none">Variables</a></h3>
<p class="element-syntax"><a name="element-variable" id=
"element-variable"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:variable<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;static? = "yes" | "no"<br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:variable&gt;</code></p>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute, which specifies the name of the variable. The value of
the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element has an optional <code>as</code> attribute, which specifies
the <a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the variable. The value of
the <code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-supplied-value" id="dt-supplied-value" title=
"supplied value"></a>The value of the variable is computed using
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> given in the <code>select</code>
attribute or the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
as described in <a href="#variable-values"><i>9.3 Values of
Variables and Parameters</i></a>. This value is referred to as the
<b>supplied value</b> of the variable.<span class=
"definition">]</span> If the <a href=
"#element-variable"><code>xsl:variable</code></a> element has a
<code>select</code> attribute, then the sequence constructor
<span class="verb">must</span> be empty.</p>
<p>If the <code>as</code> attribute is specified, then the
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the variable is
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p><a name="err-XTTE0570" id="err-XTTE0570"><span class=
"error">[ERR XTTE0570]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a variable cannot be
converted to the required type.</p>
<p>If the <code>as</code> attribute is omitted, the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of the variable is used directly, and no conversion takes
place.</p>
<p>For the effect of the <code>static</code> attribute, see
<a href="#static-params"><i>9.6 Static Variables and
Parameters</i></a>.</p>
<p>The <code>visibility</code> attribute <span class="verb">must
not</span> be specified for a local variable: that is, it is
allowed only when the parent element is
<code>xsl:stylesheet</code>, <code>xsl:transform</code>, or
<code>xsl:override</code>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <code>select</code> attribute
<span class="verb">must</span> be absent and the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span class=
"verb">must</span> be empty. In this situation there is no
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a>, and therefore the
constraint that the supplied value is consistent with the required
type does not apply.</p>
</div>
<div class="div2">
<h3><a name="parameters" id="parameters"></a>9.2 <a href=
"#parameters" style="text-decoration: none">Parameters</a></h3>
<p class="element-syntax"><a name="element-param" id=
"element-param"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;required? = "yes" | "no"<br />
&#160;&#160;tunnel? = "yes" | "no"<br />
&#160;&#160;static? = "yes" | "no"<br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:param&gt;</code></p>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
may be used:</p>
<ul>
<li>
<p>as a child of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, to define a
parameter to the transformation</p>
</li>
<li>
<p>as a child of <a href=
"#element-template"><code>xsl:template</code></a> to define a
parameter to a template, which may be supplied when the template is
invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href=
"#element-next-match"><code>xsl:next-match</code></a>;</p>
</li>
<li>
<p>as a child of <a href=
"#element-function"><code>xsl:function</code></a> to define a
parameter to a stylesheet function, which may be supplied when the
function is called from an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a></p>
</li>
<li>
<p>as a child of <a href=
"#element-iterate"><code>xsl:iterate</code></a> to define a
parameter that can vary from one iteration to the next.</p>
</li>
</ul>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
has a <span class="verb">required</span> <code>name</code>
attribute, which specifies the name of the parameter. The value of
the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p><a name="err-XTSE0580" id="err-XTSE0580"><span class=
"error">[ERR XTSE0580]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
values of the <code>name</code> attribute of two <span>sibling
<a href="#element-param"><code>xsl:param</code></a> elements
represent the same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a></span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For rules concerning stylesheet parameters, see <a href=
"#global-variables"><i>9.5 Global Variables and Parameters</i></a>.
Local variables may <a title="shadows" class="termref" href=
"#dt-shadows">shadow</a> template parameters and function
parameters: see <a href="#scope-of-variables"><i>9.9 Scope of
Variables</i></a>.</p>
</div>
<p>The <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the parameter is the
value supplied by the caller. If no value was supplied by the
caller, and if the parameter is not mandatory, then the supplied
value is computed using the <a title="expression" class="termref"
href="#dt-expression">expression</a> given in the
<code>select</code> attribute or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, as described
in <a href="#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>. If the <a href=
"#element-param"><code>xsl:param</code></a> element has a
<code>select</code> attribute, then the sequence constructor
<span class="verb">must</span> be empty.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not dictate whether and when the default
value of a parameter is evaluated. For example, if the default is
specified as <code>&lt;xsl:param
name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it is not
specified whether a distinct <code>foo</code> element node will be
created on each invocation of the template, or whether the same
<code>foo</code> element node will be used for each invocation.
However, it is permissible for the default value to depend on the
values of other parameters, or on the evaluation context, in which
case the default must effectively be evaluated on each
invocation.</p>
</div>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
has an optional <code>as</code> attribute, which specifies the
<a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the parameter. The value
of the <code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p>If the <code>as</code> attribute is specified, then the
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the parameter is
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p><a name="err-XTTE0590" id="err-XTTE0590"><span class=
"error">[ERR XTTE0590]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
conversion of the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a parameter to its
required type fails.</p>
<p>If the <code>as</code> attribute is omitted, the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of the parameter is used directly, and no conversion
takes place.</p>
<p>The optional <code>required</code> attribute may be used to
indicate that a parameter is mandatory. This attribute may be
specified for <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> and for
<a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameters</a>; it <span class=
"verb">must not</span> be specified for <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameters</a>, which are always
mandatory, <span>or for parameters to <a href=
"#element-iterate"><code>xsl:iterate</code></a>, which are always
initialized to a default value</span>. A parameter is mandatory if
it is a <a title="function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a> or if the
<code>required</code> attribute is present and has the value
<code>yes</code>. Otherwise, the parameter is optional. If the
parameter is mandatory, then the <a href=
"#element-param"><code>xsl:param</code></a> element <span class=
"verb">must</span> be empty and <span class="verb">must not</span>
have a <code>select</code> attribute.</p>
<p><a name="err-XTTE0600" id="err-XTTE0600"><span class=
"error">[ERR XTTE0600]</span></a> If a default value is given
explicitly, that is, if there is either a <code>select</code>
attribute or a non-empty <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
then it is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the default value cannot be
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p>If a stylesheet parameter specifies <code>required="yes"</code>
and does not specify <code>static="yes"</code>, then its visibility
must be <code>public</code>, <code>final</code>, or
<code>abstract</code>. The default visibility of such a parameter
is <code>public</code>.</p>
<p><a name="err-XTSE3370" id="err-XTSE3370"><span class=
"error">[ERR XTSE3370]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the the
<code>visibility</code> attribute of a stylesheet parameter that
specifies <code>required="yes"</code> and does not specify
<code>static="yes"</code> is present with a value other than
<code>public</code>, <code>final</code>, or <code>abstract</code>,
or if an <a href="#element-expose"><code>xsl:expose</code></a> or
<a href="#element-accept"><code>xsl:accept</code></a> declaration
attempts to modify the visibility of such a component to a value
other than <code>public</code>, <code>final</code>, or
<code>abstract</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule has the effect that after combining all the packages
making up a stylesheet, the non-static stylesheet parameters whose
values are required necessarily have distinct names, which
simplifies the design of APIs.</p>
</div>
<p>If an optional parameter has no <code>select</code> attribute
and has an empty <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, and if
there is no <code>as</code> attribute, then the default value of
the parameter is a zero length string.</p>
<p><a name="err-XTDE0610" id="err-XTDE0610"><span class=
"error">[ERR XTDE0610]</span></a> If an optional parameter has no
<code>select</code> attribute and has an empty <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and if there
is an <code>as</code> attribute, then the default value of the
parameter is an empty sequence. If the empty sequence is not a
valid instance of the required type defined in the <code>as</code>
attribute, then the parameter is treated as a required parameter,
which means that it is a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> if the caller supplies
no value for the parameter.</p>
<p>For the effect of the <code>static</code> attribute, see
<a href="#static-params"><i>9.6 Static Variables and
Parameters</i></a>.</p>
<p>The <code>visibility</code> attribute <span class="verb">must
not</span> be specified for a local parameter: that is, it is
allowed only when the parent element is
<code>xsl:stylesheet</code>, <code>xsl:transform</code>, or
<code>xsl:override</code>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <code>select</code> attribute
<span class="verb">must</span> be absent and the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span class=
"verb">must</span> be empty. In this situation there is no
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a>, and therefore the
constraint that the supplied value is consistent with the required
type does not apply.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of these rules is that specifying <code>&lt;xsl:param
name="p" as="xs:date" select="2"/&gt;</code> is an error, but if
the default value of the parameter is never used, then the
processor has discretion whether or not to report the error. By
contrast, <code>&lt;xsl:param name="p" as="xs:date"/&gt;</code> is
treated as if <code>required="yes"</code> had been specified: the
empty sequence is not a valid instance of <code>xs:date</code>, so
in effect there is no default value and the parameter is therefore
treated as being mandatory.</p>
</div>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>; the value <code>yes</code> may be
specified only for <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameters</a>. Tunnel
parameters are described in <a href="#tunnel-params"><i>10.1.2
Tunnel Parameters</i></a></p>
</div>
<div class="div2">
<h3><a name="variable-values" id="variable-values"></a>9.3 <a href=
"#variable-values" style="text-decoration: none">Values of
Variables and Parameters</a></h3>
<p>A <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> may
specify the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a <a title="variable"
class="termref" href="#dt-variable">variable</a> <span>or the
default value of a</span> <a title="parameter" class="termref"
href="#dt-parameter">parameter</a> in four different ways.</p>
<ul>
<li>
<p>If the <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute, then the value of the attribute
<span class="verb">must</span> be an <a title="expression" class=
"termref" href="#dt-expression">expression</a> and the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of the variable is the value that results from evaluating
the expression. In this case, the content of the variable-binding
element <span class="verb">must</span> be empty.</p>
</li>
<li>
<p>If the <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has
empty content and has neither a <code>select</code> attribute nor
an <code>as</code> attribute, then the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a> of the
variable is a zero-length string. Thus</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x"/&gt;
</pre></div>
<p>is equivalent to</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="''"/&gt;
</pre></div>
</li>
<li>
<p>If a <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has no
<code>select</code> attribute and has non-empty content (that is,
the variable-binding element has one or more child nodes), and has
no <code>as</code> attribute, then the content of the
variable-binding element specifies the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a>. The
content of the variable-binding element is a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>; a new document
is constructed with a document node having as its children the
sequence of nodes that results from evaluating the sequence
constructor and then applying the rules given in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. The value of the variable is then a singleton
sequence containing this document node. For further information,
see <a href="#temporary-trees"><i>9.4 Creating Implicit Document
Nodes</i></a>.</p>
</li>
<li>
<p>If a <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has an
<code>as</code> attribute but no <code>select</code> attribute,
then the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> is the sequence that
results from evaluating the (possibly empty) <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the variable-binding element (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p>
</li>
</ul>
<p>These combinations are summarized in the table below.</p>
<table border="1" cellpadding="5" summary=
"effect of different attribute combinations on xsl:variable" width=
"100%">
<col width="12%" span="1" />
<col width="12%" span="1" />
<col width="12%" span="1" />
<col span="1" />
<thead>
<tr>
<th align="left" colspan="1" valign="top">select attribute</th>
<th align="left" colspan="1" valign="top">as attribute</th>
<th align="left" colspan="1" valign="top">content</th>
<th align="left" colspan="1" valign="top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is obtained by evaluating the
<code>select</code> attribute</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is obtained by evaluating the
<code>select</code> attribute, adjusted to the type required by the
<code>as</code> attribute</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Static error</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Static error</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is a zero-length string</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is an empty sequence, provided
the <code>as</code> attribute permits an empty sequence</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Value is a document node whose
content is obtained by evaluating the sequence constructor</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Value is obtained by evaluating the
sequence constructor, adjusted to the type required by the
<code>as</code> attribute</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE0620" id="err-XTSE0620"><span class=
"error">[ERR XTSE0620]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute and has non-empty content.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22598" id=
"d7e22598"></a>Example: Values of Variables</div>
<p>The value of the following variable is the sequence of integers
(1, 2, 3):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;
</pre></div>
<p>The value of the following variable is an integer, assuming that
the attribute <code>@size</code> exists, and is annotated either as
an integer, or as <code>xs:untypedAtomic</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;
</pre></div>
<p>The value of the following variable is a zero-length string:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="z"/&gt;
</pre></div>
<p>The value of the following variable is a document node
containing an empty element as a child:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is a sequence of integers
(2, 4, 6):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is a sequence of parentless
attribute nodes:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is an empty sequence:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;
</pre></div>
</div>
<p>The actual value of the variable depends on the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a>, as described above, and the required type, which is
determined by the value of the <code>as</code> attribute.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22644" id=
"d7e22644"></a>Example: Pitfalls with Numeric Predicates</div>
<p>When a variable is used to select nodes by position, be careful
not to do:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
<p>This will output the values of all the <code>td</code> elements,
space-separated (or <span>with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span>,
the value of the first <code>td</code> element), because the
variable <code>n</code> will be bound to a node, not a number.
Instead, do one of the following:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
<p>or</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;
</pre></div>
<p>or</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="temporary-trees" id="temporary-trees"></a>9.4 <a href=
"#temporary-trees" style="text-decoration: none">Creating Implicit
Document Nodes</a></h3>
<p>A document node is created implicitly when evaluating an
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
has non-empty content and that has no <code>as</code> attribute.
The value of the <a title="variable" class="termref" href=
"#dt-variable">variable</a> is a single node, the document node of
a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>. The content of the
document node is formed from the result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the variable-binding element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>can be regarded as a shorthand for:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;
</pre></div>
</div>
<p>The base URI of the document node is taken from the base URI of
the variable binding element in the stylesheet. (See <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup> in <a href=
"#xpath-datamodel-30">[Data Model]</a>)</p>
<p>No document-level validation takes place (which means, for
example, that there is no checking that ID values are unique).
However, type annotations on nodes within the new tree are copied
unchanged.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The base URI of other nodes in the tree is determined by the
rules for constructing complex content. The effect of these rules
is that the base URI of a node in the temporary tree is determined
as if all the nodes in the temporary tree came from a single entity
whose URI was the base URI of the <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a>. Thus,
the base URI of the document node will be equal to the base URI of
the variable-binding element, while an <code>xml:base</code>
attribute within the temporary tree will change the base URI for
its parent element and that element's descendants, just as it would
within a document constructed by parsing.</p>
</div>
<p>The <code>document-uri</code> and <code>unparsed-entities</code>
properties of the new document node are set to empty.</p>
<p>A <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> is available for processing
in exactly the same way as any source document. For example, its
nodes are accessible using path expressions, and they can be
processed using instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a>. Also,
the <a href="#func-key"><code>key</code></a> and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
functions can be used to find nodes within a temporary tree,
<span>by supplying the document node at the root of the tree as an
argument to the function or by making it the context
node</span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22761" id=
"d7e22761"></a>Example: Two-Phase Transformation</div>
<p>For example, the following stylesheet uses a temporary tree as
the intermediate result of a two-phase transformation, using
different <a title="mode" class="termref" href="#dt-mode">modes</a>
for the two phases (see <a href="#modes"><i>6.6 Modes</i></a>).
Typically, the template rules in module <code>phase1.xsl</code>
will be declared with <code>mode="phase1"</code>, while those in
module <code>phase2.xsl</code> will be declared with
<code>mode="phase2"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The algorithm for matching nodes against template rules is
exactly the same regardless which tree the nodes come from. If
different template rules are to be used when processing different
trees, then unless nodes from different trees can be distinguished
by means of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>, it is a good idea to use <a title=
"mode" class="termref" href="#dt-mode">modes</a> to ensure that
each tree is processed using the appropriate set of template
rules.</p>
</div>
</div>
<div class="div2">
<h3><a name="global-variables" id="global-variables"></a>9.5
<a href="#global-variables" style="text-decoration: none">Global
Variables and Parameters</a></h3>
<p>Both <a href="#element-variable"><code>xsl:variable</code></a>
and <a href="#element-param"><code>xsl:param</code></a> are allowed
as <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> elements: that is, they may
appear as children of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-global-variable" id="dt-global-variable" title=
"global variable"></a>A top-level <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a>
declares a <b>global variable</b> that is visible everywhere
(except <span>within its own declaration, and</span> where it is
<a title="shadows" class="termref" href="#dt-shadows">shadowed</a>
by another binding).<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-parameter" id="dt-stylesheet-parameter" title=
"stylesheet parameter"></a>A top-level <a href=
"#element-param"><code>xsl:param</code></a> element declares a
<b>stylesheet parameter</b>. A stylesheet parameter is a global
variable with the additional property that its value can be
supplied by the caller when a transformation is
initiated.<span class="definition">]</span> As described in
<a href="#parameters"><i>9.2 Parameters</i></a>, a stylesheet
parameter may be declared as being mandatory, or may have a default
value specified for use when no value is supplied by the caller.
The mechanism by which the caller supplies a value for a stylesheet
parameter is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>. An
XSLT <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
provide such a mechanism.</p>
<p>It is an error if no value is supplied for a mandatory
stylesheet parameter <span class="error">[see <a href=
"#err-XTDE0050">ERR XTDE0050</a>]</span>.</p>
<p>If a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains more than one binding for
a global variable of a particular name, then the binding with the
highest <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p><a name="err-XTSE0630" id="err-XTSE0630"><span class=
"error">[ERR XTSE0630]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains more than one
<span>non-hidden</span> binding of a global variable with the same
name and same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains another binding with the same name and higher import
precedence.</p>
<p>For a global variable or the default value of a stylesheet
parameter, the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the variable value is evaluated with a
<a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on the root node of
the tree containing the <span><a title="initial context item"
class="termref" href="#dt-initial-context-item">initial context
item</a></span>. An XPath error will be reported if the evaluation
of a global variable or parameter references the context item,
context position, or context size when no initial context item is
supplied. The values of other components of the dynamic context are
the initial values as defined in <a href=
"#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a> and <a href="#additional-dynamic-context"><i>5.4.4
Additional Dynamic Context Components used by XSLT</i></a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22907" id=
"d7e22907"></a>Example: A Stylesheet Parameter</div>
<p>The following example declares a global parameter
<code>para-font-size</code>, which is referenced in an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The implementation must provide a mechanism allowing the user to
supply a value for the parameter <code>para-font-size</code> when
invoking the stylesheet; the value <code>12pt</code> acts as a
default.</p>
</div>
</div>
<div class="div2">
<h3><a name="static-params" id="static-params"></a>9.6 <a href=
"#static-params" style="text-decoration: none">Static Variables and
Parameters</a></h3>
<p>Static variables and parameters are global variables and can be
used in the same way as other global variables. In addition, they
can be used in <code>[xsl:]use-when</code> expressions.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-variable" id="dt-static-variable" title=
"static variable"></a>A <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> <a title="variable-binding element"
class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> having
the attribute <code>static="yes"</code> declares a <b>static
variable</b>: that is, a <a title="global variable" class="termref"
href="#dt-global-variable">global variable</a> whose value is known
during static analysis of the stylesheet.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-parameter" id="dt-static-parameter" title=
"static parameter"></a>A <a title="static variable" class="termref"
href="#dt-static-variable">static variable</a> declared using an
<a href="#element-param"><code>xsl:param</code></a> element is
referred to as a <b>static parameter</b>.<span class=
"definition">]</span></p>
<p>The <code>static</code> attribute <span class="verb">must
not</span> be present on an <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element unless it is a
<a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element.</p>
<p>When the <code>static</code> attribute is present with the value
<code>yes</code>, the <code>visibility</code> attribute
<span class="verb">must not</span> have a value other than
<code>private</code> or <code>final</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule prevents static variables being overridden in another
package. Since the values of such variables may be used at compile
time (for example, during processing of <code>[xsl:]use-when</code>
expressions), the rule is necessary to ensure that packages can be
independently compiled.</p>
<p>Declaring a static variable or parameter with
<code>visibility="final"</code> allows its value to be used in
ordinary (non-static) expressions in a using package, but use in
static expressions is possible only within the same package.</p>
</div>
<p>When the attribute <code>static="yes"</code> is specified, the
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a> element
<span class="verb">must</span> have empty content. In the case of
<a href="#element-variable"><code>xsl:variable</code></a> the
<code>select</code> attribute must be present to define the value
of the variable.</p>
<p>If the <code>select</code> attribute is present, then it is
evaluated using the rules for <a title="static expression" class=
"termref" href="#dt-static-expression">static expressions</a>.</p>
</div>
<div class="div2">
<h3><a name="static-expression" id="static-expression"></a>9.7
<a href="#static-expression" style="text-decoration: none">Static
Expressions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-expression" id="dt-static-expression" title=
"static expression"></a>A <b>static expression</b> is an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> whose value must be computed during
static analysis of the stylesheet.<span class=
"definition">]</span></p>
<p>Static expressions appear in two contexts:</p>
<ul>
<li>
<p>In <code>[xsl:]use-when</code> attributes (see <a href=
"#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a>)</p>
</li>
<li>
<p>In the <code>select</code> attribute of <a title=
"static variable" class="termref" href="#dt-static-variable">static
variable</a> declarations (<a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> with
<code>static="yes"</code>).</p>
</li>
</ul>
<p>There are no syntactic constraints on the XPath expression that
can be used as a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a>. However, there are
severe constraints on the information provided in its evaluation
context. These constraints are designed to ensure that the
expression can be evaluated at the earliest possible stage of
stylesheet processing, without any dependency on information
contained in the stylesheet itself or in any source document.</p>
<p>Specifically, the components of the static and dynamic context
are defined by the following two tables:</p>
<table border="1" cellpadding="5" width="100%" summary=
"static context for static expressions">
<caption>Static Context Components for Static Expressions</caption>
<col align="left" width="30%" span="1" />
<col align="left" span="1" />
<thead>
<tr>
<th colspan="1" align="left" valign="top">Component</th>
<th colspan="1" align="left" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">XPath 1.0 compatibility mode</td>
<td align="left" valign="top">false</td>
</tr>
<tr>
<td valign="top" align="left">Statically known namespaces</td>
<td align="left" valign="top">determined by the in-scope namespaces
for the containing element in the stylesheet</td>
</tr>
<tr>
<td valign="top" align="left">Default element/type namespace</td>
<td align="left" valign="top">determined by the
<code>xpath-default-namespace</code> attribute if present (see
<a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical QNames in
Expressions and Patterns</i></a>); otherwise the null
namespace</td>
</tr>
<tr>
<td valign="top" align="left">Default function namespace</td>
<td align="left" valign="top">The <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a></td>
</tr>
<tr>
<td valign="top" align="left">In-scope schema types</td>
<td align="left" valign="top">The type definitions that would be
available in the absence of any <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration</td>
</tr>
<tr>
<td valign="top" align="left">In-scope element declarations</td>
<td align="left" valign="top">None</td>
</tr>
<tr>
<td valign="top" align="left">In-scope attribute declarations</td>
<td align="left" valign="top">None</td>
</tr>
<tr>
<td valign="top" align="left">In-scope variables</td>
<td align="left" valign="top">The <a title="static variable" class=
"termref" href="#dt-static-variable">static variables</a> visible
within the containing package whose declarations occur prior to the
element containing the static expression in stylesheet tree order.
Stylesheet tree order is the order that results when all <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations are
replaced by the declarations in the imported or included stylesheet
module. A static variable is not in scope within its own
declaration, <span>and it is in scope only within its declaring
package, not in any using packages.</span> If two static variables
satisfying this rule have the same name and are both in scope, the
one that has highest <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a> is used (it is a
consequence of rules defined elsewhere that there cannot be more
than one declaration with highest import precedence). Note that the
declaration with highest import precedence is not necessarily the
one that appears last in stylesheet tree order; note also that
because forwards references are not allowed, the declaration that
is used will not necessarily be the one with highest import
precedence in the stylesheet as a whole.</td>
</tr>
<tr>
<td valign="top" align="left">Context item static type</td>
<td align="left" valign="top"><a title="absent" class="termref"
href="#dt-absent">Absent</a></td>
</tr>
<tr>
<td valign="top" align="left">Statically known function
signatures</td>
<td align="left" valign="top">The <a title="core function" class=
"termref" href="#dt-core-function">core functions</a> defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>,
together with the functions <a href=
"#func-element-available"><code>element-available</code></a>,
<a href=
"#func-function-available"><code>function-available</code></a>,
<a href="#func-type-available"><code>type-available</code></a>, and
<a href="#func-system-property"><code>system-property</code></a>
defined in this specification, plus the set of extension functions
that are present in the static context of every XPath expression
(other than a use-when expression) within the content of the
element that is the parent of the <code>use-when</code> attribute.
Note that <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> are <em>not</em>
included in the context, which means that the function <a href=
"#func-function-available"><code>function-available</code></a> will
return <code>false</code> in respect of such functions. The effect
of this rule is to ensure that <a href=
"#func-function-available"><code>function-available</code></a>
returns true in respect of functions that can be called within the
scope of the <code>use-when</code> attribute. It also has the
effect that these extension functions will be recognized within the
<code>use-when</code> attribute itself; however, the fact that a
function is available in this sense gives no guarantee that a call
on the function will succeed.</td>
</tr>
<tr>
<td valign="top" align="left">Statically known collations</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default collation</td>
<td align="left" valign="top">The Unicode Codepoint Collation</td>
</tr>
<tr>
<td valign="top" align="left">Static Base URI</td>
<td align="left" valign="top">The base URI of the containing
element in the stylesheet document <span>(see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup>)</span></td>
</tr>
<tr>
<td valign="top" align="left">Statically known documents</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known collections</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known default collection
type</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known decimal formats</td>
<td align="left" valign="top">A single unnamed <a title=
"decimal format" class="termref" href="#dt-decimal-format">decimal
format</a> equivalent to the decimal format that is created by an
<a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration with no attributes.</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<table border="1" cellpadding="5" width="100%" summary=
"dynamic context for static expressions">
<caption>Dynamic Context Components for Static
Expressions</caption>
<col align="left" width="30%" span="1" />
<col align="left" span="1" />
<thead>
<tr>
<th colspan="1" align="left" valign="top">Component</th>
<th colspan="1" align="left" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">Context item, position, and size</td>
<td align="left" valign="top"><a title="absent" class="termref"
href="#dt-absent">Absent</a></td>
</tr>
<tr>
<td valign="top" align="left">Variable values</td>
<td align="left" valign="top">A value for every variable present in
the in-scope variables. For <a title="static parameter" class=
"termref" href="#dt-static-parameter">static parameters</a> where
an external value is supplied: the externally-supplied value of the
parameter. In all other cases: the value of the variable as defined
in <a href="#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">Named functions</td>
<td align="left" valign="top">The function implementation
corresponding to each function signature in the statically known
function signatures</td>
</tr>
<tr>
<td valign="top" align="left">Current dateTime</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Implicit timezone</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default language</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default calendar</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default place</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Available documents</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Available collections</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default collection</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Environment variables</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
</tbody>
</table>
<p>Within a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>, all static
expressions are evaluated in a single <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>. This need not be the same
execution scope as that used for static expressions in other
stylesheet modules, or as that used when evaluating XPath
expressions appearing elsewhere in the stylesheet module. This
means that a function such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-date"><code>current-date</code></a><sup><small>FO30</small></sup>
will return the same result when called in different
<code>[xsl:]use-when</code> expressions within the same stylesheet
module, but will not necessarily return the same result as the same
call in an <code>[xsl:]use-when</code> expression within a
different stylesheet module, or as a call on the same function
executed during the transformation proper.</p>
</div>
<div class="div2">
<h3><a name="local-variables" id="local-variables"></a>9.8 <a href=
"#local-variables" style="text-decoration: none">Local Variables
and Parameters</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-local-variable" id="dt-local-variable" title=
"local variable"></a>As well as being allowed as a <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>, the <a href=
"#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a>. Such a
variable is known as a <b>local variable</b>.<span class=
"definition">]</span></p>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may also be used to create a variable binding with local scope:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template-parameter" id="dt-template-parameter" title=
"template parameter"></a> An <a href=
"#element-param"><code>xsl:param</code></a> element may appear as a
child of an <a href=
"#element-template"><code>xsl:template</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>template parameter</b>. A template parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the template is called, using any of the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href=
"#element-next-match"><code>xsl:next-match</code></a>.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-function-parameter" id="dt-function-parameter" title=
"function parameter"></a> An <a href=
"#element-param"><code>xsl:param</code></a> element may appear as a
child of an <a href=
"#element-function"><code>xsl:function</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>function parameter</b>. A function parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the function is called, using a function call in an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.<span class=
"definition">]</span></p>
</li>
<li>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. This defines a parameter whose value may
be initialized on entry to the iteration, and which may be varied
each time round the iteration by use of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element in
the <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction.</p>
</li>
</ul>
<p>The result of evaluating a local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element (that is, the
contribution it makes to the result of the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> it is part of)
is an empty sequence.</p>
</div>
<div class="div2">
<h3><a name="scope-of-variables" id="scope-of-variables"></a>9.9
<a href="#scope-of-variables" style="text-decoration: none">Scope
of Variables</a></h3>
<p>For any <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable-binding element</a>,
there is a region (more specifically, a set of nodes) of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> within which the binding is
visible. The set of variable bindings in scope for an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> consists of those bindings that are
visible at the point in the stylesheet where the expression
occurs.</p>
<p>A global <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding element</a> is
visible everywhere in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> (including other <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a>) except within the
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a> element itself
and any region where it is <a title="shadows" class="termref" href=
"#dt-shadows">shadowed</a> by another variable binding.</p>
<p>A local <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding element</a> is
visible for all following siblings and their descendants, with
<span>the following</span> exceptions:</p>
<ol class="enumar">
<li>
<p>It is not visible in any region where it is <a title="shadows"
class="termref" href="#dt-shadows">shadowed</a> by another variable
binding.</p>
</li>
<li>
<p>It is not visible within the subtree rooted at an <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction that
is a sibling of the variable binding element.</p>
</li>
<li>
<p>It is not visible within the subtree rooted at an <a href=
"#element-catch"><code>xsl:catch</code></a> instruction that is a
sibling of the variable binding element.</p>
</li>
</ol>
<p>The binding is not visible for the <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element itself.</p>
<p>If a binding is visible for an element then it is visible for
every attribute of that element and for every text node child of
that element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-shadows" id="dt-shadows" title="shadows"></a>A binding
<b>shadows</b> another binding if the binding occurs at a point
where the other binding is visible, and the bindings have the same
name. <span class="definition">]</span> It is not an error if a
binding established by a local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> <a title="shadows"
class="termref" href="#dt-shadows">shadows</a> a global binding. In
this case, the global binding will not be visible in the region of
the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> where it is shadowed by the other
binding.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23573" id=
"d7e23573"></a>Example: Local Variable Shadowing a Global
Variable</div>
<p>The following is allowed:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>It is also not an error if a binding established by a local
<a href="#element-variable"><code>xsl:variable</code></a> element
<a title="shadows" class="termref" href="#dt-shadows">shadows</a> a
binding established by another local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23594" id=
"d7e23594"></a>Example: Misuse of Variable Shadowing</div>
<p>The following is not an error, but the effect is probably not
what was intended. The template outputs <code>&lt;x
value="1"/&gt;</code>, because the declaration of the inner
variable named <code>$x</code> has no effect on the value of the
outer variable named <code>$x</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Once a variable has been given a value, the value cannot
subsequently be changed. XSLT does not provide an equivalent to the
assignment operator available in many procedural programming
languages.</p>
<p>This is because an assignment operator would make it harder to
create an implementation that processes a document other than in a
batch-like way, starting at the beginning and continuing through to
the end.</p>
</div>
<p>As well as global variables and local variables, an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> may also declare range variables
for use locally within an expression. For details, see <a href=
"#xpath-30">[XPath 3.0]</a>.</p>
<p>Where a reference to a variable occurs in an XPath expression,
it is resolved first by reference to range variables that are in
scope, then by reference to local variables and parameters, and
finally by reference to global variables and parameters. A range
variable may shadow a local variable or a global variable. XPath
also allows a range variable to shadow another range variable.</p>
</div>
<div class="div2">
<h3><a name="with-param" id="with-param"></a>9.10 <a href=
"#with-param" style="text-decoration: none">Setting Parameter
Values</a></h3>
<p class="element-syntax"><a name="element-with-param" id=
"element-with-param"></a><code>&lt;xsl:with-param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;tunnel? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:with-param&gt;</code></p>
<p>Parameters are passed to templates using the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element. The
<span class="verb">required</span> <code>name</code> attribute
specifies the name of the <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a> (the
variable the value of whose binding is to be replaced). The value
of the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p><span>The <a href=
"#element-with-param"><code>xsl:with-param</code></a> element is
also used when passing parameters to an iteration of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, or to
a dynamic invocation of an XPath expression using <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>. In
consequence,</span> <a href=
"#element-with-param"><code>xsl:with-param</code></a> may appear
within <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<span><a href="#element-evaluate"><code>xsl:evaluate</code></a>,
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>,</span>
and <a href="#element-next-match"><code>xsl:next-match</code></a>.
(Arguments to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, however, are
supplied as part of an XPath function call: see <a href=
"#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>.)</p>
<p><a name="err-XTSE0670" id="err-XTSE0670"><span class=
"error">[ERR XTSE0670]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two or
more sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements have
<code>name</code> attributes that represent the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<p>The value of the parameter is specified in the same way as for
<a href="#element-variable"><code>xsl:variable</code></a> and
<a href="#element-param"><code>xsl:param</code></a> (see <a href=
"#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>), taking account of the values of the
<code>select</code> and <code>as</code> attributes and the content
of the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element, if
any.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is possible to have an <code>as</code> attribute on the
<a href="#element-with-param"><code>xsl:with-param</code></a>
element that differs from the <code>as</code> attribute on the
corresponding <a href="#element-param"><code>xsl:param</code></a>
element.</p>
<p>In this situation, the supplied value of the parameter will
first be processed according to the rules of the <code>as</code>
attribute on the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element, and
the resulting value will then be further processed according to the
rules of the <code>as</code> attribute on the <a href=
"#element-param"><code>xsl:param</code></a> element.</p>
<p>For example, suppose the supplied value is a node with <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> <code>xs:untypedAtomic</code>, and the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element
specifies <code>as="xs:integer"</code>, while the <a href=
"#element-param"><code>xsl:param</code></a> element specifies
<code>as="xs:double"</code>. Then the node will first be atomized
and the resulting untyped atomic value will be cast to
<code>xs:integer</code>. If this succeeds, the
<code>xs:integer</code> will then be promoted to an
<code>xs:double</code>.</p>
</div>
<p>The <a title="focus" class="termref" href="#dt-focus">focus</a>
used for computing the value specified by the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element is
the same as that used for <span>its parent <a title="instruction"
class="termref" href="#dt-instruction">instruction</a></span>.</p>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>. Tunnel parameters are described in
<a href="#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a>. They
are used only when passing parameters to templates: for an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
is a child of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> the
<code>tunnel</code> attribute <span class="verb">must</span> either
be omitted or take the value <code>no</code>.</p>
<p>In other cases it is a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> if the template that is
invoked declares a <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied by the calling instruction. <span class="error">[see
<a href="#err-XTDE0700">ERR XTDE0700</a>]</span></p>
</div>
<div class="div2">
<h3><a name="circularity" id="circularity"></a>9.11 <a href=
"#circularity" style="text-decoration: none">Circular
Definitions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-circularity" id="dt-circularity" title="circularity"></a>A
<b>circularity</b> is said to exist if a construct such as a
<a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a>, an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, or a <a title="key" class="termref" href=
"#dt-key">key</a>, is defined in terms of itself. For example, if
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the value of a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> <var>X</var> references a global variable
<var>Y</var>, then the value for <var>Y</var> <span class=
"verb">must</span> be computed before the value of <var>X</var>. A
circularity exists if it is impossible to do this for all global
variable definitions.<span class="definition">]</span></p>
<div class="example">
<div class="exampleHeader"><a name="d7e23916" id=
"d7e23916"></a>Example: Circular Variable Definitions</div>
<p>The following two declarations create a circularity:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23923" id=
"d7e23923"></a>Example: Circularity involving Variables and
Functions</div>
<p>The definition of a global variable can be circular even if no
other variable is involved. For example the following two
declarations (see <a href="#stylesheet-functions"><i>10.3
Stylesheet Functions</i></a> for an explanation of the <a href=
"#element-function"><code>xsl:function</code></a> element) also
create a circularity:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23935" id=
"d7e23935"></a>Example: Circularity involving Variables and
Templates</div>
<p>The definition of a variable is also circular if the evaluation
of the variable invokes an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction and the variable is referenced in the pattern used in
the <code>match</code> attribute of any template rule in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>. For example the following
definition is circular:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23951" id=
"d7e23951"></a>Example: Circularity involving Variables and
Keys</div>
<p>Similarly, a variable definition is circular if it causes a call
on the <a href="#func-key"><code>key</code></a> function, and the
definition of that <a title="" class="termref" href="#key">key</a>
refers to that variable in its <code>match</code> or
<code>use</code> attributes. So the following definition is
circular:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:sequence select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</pre></div>
</div>
<p><a name="err-XTDE0640" id="err-XTDE0640"><span class=
"error">[ERR XTDE0640]</span></a> In general, a <a title=
"circularity" class="termref" href=
"#dt-circularity">circularity</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a>. However, as with all other dynamic errors, an
implementation will signal the error only if it actually executes
the instructions and expressions that participate in the
circularity. Because different implementations may optimize the
execution of a stylesheet in different ways, it is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
a particular circularity will actually be signaled.</p>
<p>For example, in the following declarations, the function
declares a local variable <code>$b</code>, but it returns a result
that does not require the variable to be evaluated. It is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the value is actually evaluated, and it is therefore
implementation-dependent whether the circularity is signaled as an
error:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>Circularities usually involve global variables or parameters,
but they can also exist between <a title="" class="termref" href=
"#key">key</a> definitions (see <a href="#key"><i>20.2
Keys</i></a>), between named <a title="attribute set" class=
"termref" href="#dt-attribute-set">attribute sets</a> (see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or between
any combination of these constructs. For example, a circularity
exists if a key definition invokes a function that references an
attribute set that calls the <a href=
"#func-key"><code>key</code></a> function, supplying the name of
the original key definition as an argument.</p>
<p>Circularity is not the same as recursion. Stylesheet functions
(see <a href="#stylesheet-functions"><i>10.3 Stylesheet
Functions</i></a>) and named templates (see <a href=
"#named-templates"><i>10.1 Named Templates</i></a>) may call other
functions and named templates without restriction. With careless
coding, recursion may be non-terminating. Implementations are
<span class="verb">required</span> to signal circularity as a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>, but they are not
<span class="verb">required</span> to detect non-terminating
recursion.</p>
</div>
</div>
<div class="div1">
<h2><a name="callable-components" id="callable-components"></a>10
<a href="#callable-components" style=
"text-decoration: none">Callable Components</a></h2>
<p>This section describes three constructs that can be used to
provide subroutine-like functionality that can be invoked from
anywhere in the stylesheet: named templates (see <a href=
"#named-templates"><i>10.1 Named Templates</i></a>), named
attribute sets (see <a href="#attribute-sets"><i>10.2 Named
Attribute Sets</i></a>), and <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
(see <a href="#stylesheet-functions"><i>10.3 Stylesheet
Functions</i></a>).</p>
<div class="div2">
<h3><a name="named-templates" id="named-templates"></a>10.1
<a href="#named-templates" style="text-decoration: none">Named
Templates</a></h3>
<p class="element-syntax"><a name="element-call-template" id=
"element-call-template"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:call-template<br />
&#160;&#160;<b>name</b> = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:call-template&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-named-template" id="dt-named-template" title=
"named template"></a>Templates can be invoked by name. An <a href=
"#element-template"><code>xsl:template</code></a> element with a
<code>name</code> attribute defines a <b>named
template</b>.<span class="definition">]</span> The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>. If an
<a href="#element-template"><code>xsl:template</code></a> element
has a <code>name</code> attribute, it may, but need not, also have
a <code>match</code> attribute. An <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction invokes a template by name; it has a <span class=
"verb">required</span> <code>name</code> attribute that identifies
the template to be invoked. Unlike <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction does not change the <a title="focus" class="termref"
href="#dt-focus">focus</a>.</p>
<p>The <code>match</code>, <code>mode</code> and
<code>priority</code> attributes on an <a href=
"#element-template"><code>xsl:template</code></a> element have no
effect when the <a title="template" class="termref" href=
"#dt-template">template</a> is invoked by an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction. Similarly, the <code>name</code> <span>and
<code>visibility</code></span> attributes on an <a href=
"#element-template"><code>xsl:template</code></a> element have no
effect when the template is invoked by an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p><a name="err-XTSE0650" id="err-XTSE0650"><span class=
"error">[ERR XTSE0650]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute does not match the
<code>name</code> attribute of any <span><a title="named template"
class="termref" href="#dt-named-template">named template</a>
visible in the containing <a title="package" class="termref" href=
"#dt-package">package</a> (this includes any template defined in
this package, as well as templates accepted from used packages
whose visibility in this package is not <code>hidden</code>). For
more details of the process of binding the called template, see
<a href="#component-references"><i>3.6.2.6 Binding References to
Components</i></a>.</span></p>
<p><a name="err-XTSE0660" id="err-XTSE0660"><span class=
"error">[ERR XTSE0660]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<span><a title="package" class="termref" href=
"#dt-package">package</a></span> contains more than one
<span>non-hidden</span> <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and the same
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains a <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and higher <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
<p><a name="err-XTSE3340" id="err-XTSE3340"><span class=
"error">[ERR XTSE3340]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-template"><code>xsl:template</code></a>
declaration has the name <code>xsl:initial-template</code> and
contains an <a href="#element-param"><code>xsl:param</code></a>
that specifies <code>required="yes"</code>.</p>
<p><span>The target <a title="template" class="termref" href=
"#dt-template">template</a> for an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is established using the binding rules described in
<a href="#component-references"><i>3.6.2.6 Binding References to
Components</i></a>. This will always be a template whose
<code>name</code> attribute matches the <code>name</code> attribute
of the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction. It may be a template defined in the same package that
has higher <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than any other
template with this name, or it may be a template accepted from a
used package, or (if the template is not defined as
<code>private</code> or <code>final</code>) it may be an overriding
template in a package that uses the containing package.</span> The
result of evaluating an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
its target <a title="template" class="termref" href=
"#dt-template">template</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p>
<p>The template name <code>xsl:initial-template</code> is specially
recognized in that it provides a default entry point for stylesheet
execution (see <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>.) A template with this name <span class=
"verb">must not</span> have any <a href=
"#element-param"><code>xsl:param</code></a> children that specify
<code>required="yes"</code>. In all other respects a template with
this name behaves exactly like a template with any other name.</p>
<div class="div3">
<h4><a name="call-template-params" id=
"call-template-params"></a>10.1.1 <a href="#call-template-params"
style="text-decoration: none">Passing Parameters to Named
Templates</a></h4>
<p>Parameters are passed to named templates using the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element as a
child of the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction.</p>
<p><a name="err-XTSE0680" id="err-XTSE0680"><span class=
"error">[ERR XTSE0680]</span></a> In the case of <a href=
"#element-call-template"><code>xsl:call-template</code></a>, it is
a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to pass a non-tunnel parameter
named <var>x</var> to a template that does not have a
<span>non-tunnel</span> <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a>
named <var>x</var>, unless <span>the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is processed with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span>.
This is not an error in the case of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, and
<a href="#element-next-match"><code>xsl:next-match</code></a>; in
these cases the parameter is simply ignored.</p>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>. Tunnel parameters are described in
<a href="#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a></p>
<p><a name="err-XTSE0690" id="err-XTSE0690"><span class=
"error">[ERR XTSE0690]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
template that is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>
declares a <a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> specifying
<code>required="yes"</code> and not specifying
<code>tunnel="yes"</code>, if no value for this parameter is
supplied by the calling <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24383" id=
"d7e24383"></a>Example: Calling a Named Template with a
Parameter</div>
<p>This example defines a named template for a
<code>numbered-block</code> with a parameter to control the format
of the number.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="tunnel-params" id="tunnel-params"></a>10.1.2 <a href=
"#tunnel-params" style="text-decoration: none">Tunnel
Parameters</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-tunnel-parameter" id="dt-tunnel-parameter" title=
"tunnel parameter"></a>A parameter passed to a template may be
defined as a <b>tunnel parameter</b>. Tunnel parameters have the
property that they are automatically passed on by the called
template to any further templates that it calls, and so on
recursively.<span class="definition">]</span> Tunnel parameters
thus allow values to be set that are accessible during an entire
phase of stylesheet processing, without the need for each template
that is used during that phase to be aware of the parameter.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Tunnel parameters are conceptually similar to dynamically scoped
variables in some functional programming languages.</p>
</div>
<p>A <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> is created by using an
<a href="#element-with-param"><code>xsl:with-param</code></a>
element that specifies <code>tunnel="yes"</code>. A template that
requires access to the value of a tunnel parameter must declare it
using an <a href="#element-param"><code>xsl:param</code></a>
element that also specifies <code>tunnel="yes"</code>.</p>
<p>On any template call using an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction, a set of <a title="tunnel parameter" class="termref"
href="#dt-tunnel-parameter">tunnel parameters</a> is passed from
the calling template to the called template. This set consists of
any parameters explicitly created using <code>&lt;xsl:with-param
tunnel="yes"&gt;</code>, overlaid on a base set of tunnel
parameters. If the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction has an <a href=
"#element-template"><code>xsl:template</code></a> declaration as an
ancestor element in the stylesheet, then the base set consists of
the tunnel parameters that were passed to that template; otherwise
(for example, if the instruction is within a global variable
declaration, an <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> declaration, or a <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>), the base set is
empty. If a parameter created using <code>&lt;xsl:with-param
tunnel="yes"&gt;</code> has the same <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> as a
parameter in the base set, then the parameter created using
<a href="#element-with-param"><code>xsl:with-param</code></a>
overrides the parameter in the base set; otherwise, the parameter
created using <a href=
"#element-with-param"><code>xsl:with-param</code></a> is added to
the base set.</p>
<p>When a template accesses the value of a <a title=
"tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> by declaring it with
<code>xsl:param tunnel="yes"</code>, this does not remove the
parameter from the base set of tunnel parameters that is passed on
to any templates called by this template.</p>
<p>Two sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
<span class="verb">must</span> have distinct parameter names, even
if one is a <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> and the other is not.
Equally, two sibling <a href=
"#element-param"><code>xsl:param</code></a> elements representing
<a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameters</a> <span class=
"verb">must</span> have distinct parameter names, even if one is a
<a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> and the other is not.
However, the tunnel parameters that are implicitly passed in a
template call <span class="verb">may</span> have names that
duplicate the names of non-tunnel parameters that are explicitly
passed on the same call.</p>
<p><a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">Tunnel parameters</a> are not passed in
calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>.</p>
<p>All other options of <a href=
"#element-with-param"><code>xsl:with-param</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are available with
<a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> just as with
non-tunnel parameters. For example, parameters may be declared as
mandatory or optional, a default value may be specified, and a
required type may be specified. If any conversion is required from
the supplied value of a tunnel parameter to the required type
specified in <a href="#element-param"><code>xsl:param</code></a>,
then the converted value is used within the receiving template, but
the value that is passed on in any further template calls is the
original supplied value before conversion. Equally, any default
value is local to the template: specifying a default value for a
tunnel parameter does not change the set of tunnel parameters that
is passed on in further template calls.</p>
<p>The set of <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> that is passed to the
<a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a> is empty.</p>
<p><a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">Tunnel parameters</a> are passed unchanged
through a built-in template rule (see <a href=
"#built-in-rule"><i>6.8 Built-in Template Rules</i></a>).</p>
<p>If a tunnel parameter is declared in an <a href=
"#element-param"><code>xsl:param</code></a> element with the
attribute <code>tunnel="yes"</code>, then a dynamic error occurs
<span class="error">[see <a href="#err-XTDE0700">ERR
XTDE0700</a>]</span> if the set of tunnel parameters passed to the
template does not include a parameter with a matching <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24568" id=
"d7e24568"></a>Example: Using Tunnel Parameters</div>
<p>Suppose that the equations in a scientific paper are to be
sequentially numbered, but that the format of the number depends on
the context in which the equations appear. It is possible to
reflect this using a rule of the form:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>At any level of processing above this level, it is possible to
determine how the equations will be numbered, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;
</pre></div>
<p>The parameter value is passed transparently through all the
intermediate layers of template rules until it reaches the rule
with <code>match="equation"</code>. The effect is similar to using
a global variable, except that the parameter can take different
values during different phases of the transformation.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="attribute-sets" id="attribute-sets"></a>10.2 <a href=
"#attribute-sets" style="text-decoration: none">Named Attribute
Sets</a></h3>
<p class="element-syntax"><a name="element-attribute-set" id=
"element-attribute-set"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:attribute-set<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-attribute">xsl:attribute</a>* --&gt;<br />
&lt;/xsl:attribute-set&gt;</code></p>
<p>Attribute sets <span>generate</span> named collections of
attributes that can be used repeatedly on different constructed
elements. The <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration is used to declare attribute sets. The <span class=
"verb">required</span> <code>name</code> attribute specifies the
name of the attribute set. The value of the <code>name</code>
attribute is an <code>EQName</code>, which is expanded as described
in <a href="#qname"><i>5.1 Qualified Names</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-attribute-set" id="dt-attribute-set" title=
"attribute set"></a>An <b>attribute set</b> is defined as a set of
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the same <a title="package" class="termref" href=
"#dt-package">package</a> that share the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.<span class="definition">]</span></p>
<p>The content of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
consists of zero or more <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
that are evaluated to produce the attributes in the set.</p>
<div class="div3">
<h4><a name="using-attribute-sets" id=
"using-attribute-sets"></a>10.2.1 <a href="#using-attribute-sets"
style="text-decoration: none">Using Attribute Sets</a></h4>
<p><a title="attribute set" class="termref" href=
"#dt-attribute-set">Attribute sets</a> are used by specifying a
<code>use-attribute-sets</code> attribute on the <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a> instruction, or by
specifying an <code>xsl:use-attribute-sets</code> attribute on a
literal result element. An attribute set may be defined in terms of
other attribute sets by using the <code>use-attribute-sets</code>
attribute on the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
itself. The value of the <code>[xsl:]use-attribute-sets</code>
attribute is in each case a whitespace-separated list of names of
attribute sets. Each name is specified as an <span><a title=
"EQName" class="termref" href="#dt-eqname">EQName</a></span>, which
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>Specifying a <code>use-attribute-sets</code> attribute is
broadly equivalent to adding <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
for each of the attributes in each of the named attribute sets to
the beginning of the content of the instruction with the
<code>[xsl:]use-attribute-sets</code> attribute, in the same order
in which the names of the attribute sets are specified in the
<code>use-attribute-sets</code> attribute.</p>
<p>More formally, an <code>xsl:use-attribute-sets</code> attribute
is expanded using the following recursive algorithm, or any
algorithm that produces the same results:</p>
<ul>
<li>
<p>The value of the attribute is tokenized as a list of QNames.</p>
</li>
<li>
<p>Each QName in the list is processed, in order, as follows:</p>
<ul>
<li>
<p>The QName must match the <code>name</code> attribute of one or
more <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the stylesheet.</p>
</li>
<li>
<p>Each <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration whose name matches is processed as follows. Where two
such declarations have different <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
the one with lower import precedence is processed first. Where two
declarations have the same import precedence, they are processed in
<a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>.</p>
<ul>
<li>
<p>If the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration has a <code>use-attribute-sets</code> attribute, the
attribute is expanded by applying this algorithm recursively.</p>
</li>
<li>
<p>If the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration contains one or more <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions,
these instructions are evaluated (following the rules for
evaluating a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>: see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) to
produce a sequence of attribute nodes. These attribute nodes are
appended to the result sequence.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="err-XTSE0710" id="err-XTSE0710"><span class=
"error">[ERR XTSE0710]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>use-attribute-sets</code> attribute of an
<a href="#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, or <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element, or the <code>xsl:use-attribute-sets</code> attribute of a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, is not a
whitespace-separated sequence of <span><a title="EQName" class=
"termref" href="#dt-eqname">EQNames</a></span>, or if it contains a
QName that does not match the <code>name</code> attribute of any
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration in the stylesheet.</p>
<p><a name="err-XTSE0720" id="err-XTSE0720"><span class=
"error">[ERR XTSE0720]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
element directly or indirectly references itself via the names
contained in the <code>use-attribute-sets</code> attribute.</p>
</div>
<div class="div3">
<h4><a name="visibility-of-attribute-sets" id=
"visibility-of-attribute-sets"></a>10.2.2 <a href=
"#visibility-of-attribute-sets" style=
"text-decoration: none">Visibility of Attribute Sets</a></h4>
<p>The <code>visibility</code> attribute determines the potential
visibility of the attribute set in packages other than the
containing package. If the <code>visibility</code> attribute is
present on any of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up the definition of an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a> (that is, all declarations within the same package sharing
the same name), then it <span class="verb">must</span> be present,
with the same value, on every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration making up the definition of that <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then there must be no <a href=
"#element-attribute"><code>xsl:attribute</code></a> children
<span>and no <code>use-attribute-sets</code> attribute</span>.</p>
</div>
<div class="div3">
<h4><a name="streamability-of-attribute-sets" id=
"streamability-of-attribute-sets"></a>10.2.3 <a href=
"#streamability-of-attribute-sets" style=
"text-decoration: none">Streamability of Attribute Sets</a></h4>
<p>An <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> may be designated as
streamable by including the attribute <code>streamable="yes"</code>
on each <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration making up the attribute set. If any <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for an attribute set has the attribute
<code>streamable="yes"</code>, then every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for that attribute set <span class="verb">must</span>
have the attribute <code>streamable="yes"</code>.</p>
<p>An <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> is <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if every
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration making up the attribute set, considered as a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, is <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
according to the analysis in <a href=
"#classifying-attribute-sets"><i>19.8.5 Classifying Attribute
Sets</i></a>.</p>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
declares an intent that the attribute set should be guaranteed
streamable according to these criteria. The consequences of
declaring the attribute set to be streamable when it is not in fact
guaranteed streamable depend on the conformance level of the
processor, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is common for attribute sets to create attributes with
constant values, and such attribute sets will always be motionless
and therefore streamable. Although such cases are fairly simple for
a processor to detect, references to attribute sets are not
guaranteed streamable unless the attribute set is declared with the
attribute <code>streamable="yes"</code>, which should therefore be
used if interoperable streaming is required.</p>
</div>
</div>
<div class="div3">
<h4><a name="evaluating-attribute-sets" id=
"evaluating-attribute-sets"></a>10.2.4 <a href=
"#evaluating-attribute-sets" style=
"text-decoration: none">Evaluating Attribute Sets</a></h4>
<p>Attribute sets are evaluated as follows:</p>
<ul>
<li>
<p>The <a href="#element-copy"><code>xsl:copy</code></a> and
<a href="#element-element"><code>xsl:element</code></a>
instructions have an <code>use-attribute-sets</code> attribute. The
sequence of attribute nodes produced by evaluating this attribute
is prepended to the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the instruction.</p>
</li>
<li>
<p><a title="literal result element" class="termref" href=
"#dt-literal-result-element">Literal result elements</a> allow an
<code>xsl:use-attribute-sets</code> attribute, which is evaluated
in the same way as the <code>use-attribute-sets</code> attribute of
<a href="#element-element"><code>xsl:element</code></a> and
<a href="#element-copy"><code>xsl:copy</code></a>. The sequence of
attribute nodes produced by evaluating this attribute is prepended
to the sequence of attribute nodes produced by evaluating the
attributes of the literal result element, which in turn is
prepended to the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained with
the literal result element.</p>
</li>
</ul>
<p>The <a href="#element-attribute"><code>xsl:attribute</code></a>
instructions are evaluated using the same <a title="focus" class=
"termref" href="#dt-focus">focus</a> as is used for evaluating the
element that is the parent of the
<code>[xsl:]use-attribute-sets</code> attribute forming the initial
input to the algorithm. However, the static context for the
evaluation depends on the position of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction in
the stylesheet: thus, only local variables declared within an
<a href="#element-attribute"><code>xsl:attribute</code></a>
instruction, and global variables, are visible.</p>
<p>The set of attribute nodes produced by expanding
<code>xsl:use-attribute-sets</code> may include several attributes
with the same name. When the attributes are added to an element
node, only the last of the duplicates will take effect.</p>
<p>The way in which each instruction uses the results of expanding
the <code>[xsl:]use-attribute-sets</code> attribute is described in
the specification for the relevant instruction: see <a href=
"#literal-result-element"><i>11.1 Literal Result Elements</i></a>,
<a href="#xsl-element"><i>11.2 Creating Element Nodes Using
xsl:element</i></a> , and <a href="#copying"><i>11.9 Copying
Nodes</i></a>.</p>
<p>The result of evaluating an attribute set is a sequence of
attribute nodes. Evaluating the same attribute set more than once
can produce different results, because although an attribute set
does not have parameters, it may contain expressions or
instructions whose value depends on the evaluation context.</p>
<p>Each attribute node produced by expanding an attribute set has a
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> determined by the rules for
the <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction that created the attribute node: see <a href=
"#annotation-for-constructed-attribute"><i>11.3.1 Setting the Type
Annotation for a Constructed Attribute Node</i></a>. These type
annotations may be preserved, stripped, or replaced as determined
by the rules for the instruction that creates the element in which
the attributes are used.</p>
</div>
<div class="div3">
<h4><a name="attribute-sets-examples" id=
"attribute-sets-examples"></a>10.2.5 <a href=
"#attribute-sets-examples" style="text-decoration: none">Attribute
Sets: Examples</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e25009" id=
"d7e25009"></a>Example: A Simple Attribute Set</div>
<p>The following example creates a named <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>
<code>title-style</code> and uses it in a <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25025" id=
"d7e25025"></a>Example: Overriding Attributes in an Attribute
Set</div>
<p>The following example creates a named attribute set
<code>base-style</code> and uses it in a template rule with
multiple specifications of the attributes:</p>
<dl>
<dt class="label">font-family</dt>
<dd>
<p>is specified only in the attribute set</p>
</dd>
<dt class="label">font-size</dt>
<dd>
<p>is specified in the attribute set, is specified on the literal
result element, and in an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction</p>
</dd>
<dt class="label">font-style</dt>
<dd>
<p>is specified in the attribute set, and on the literal result
element</p>
</dd>
<dt class="label">font-weight</dt>
<dd>
<p>is specified in the attribute set, and in an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction</p>
</dd>
</dl>
<p>Stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="stylesheet-functions" id=
"stylesheet-functions"></a>10.3 <a href="#stylesheet-functions"
style="text-decoration: none">Stylesheet Functions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-function" id="dt-stylesheet-function" title=
"stylesheet function"></a>An <a href=
"#element-function"><code>xsl:function</code></a> declaration
declares the name, parameters, and implementation of a
<b>stylesheet function</b> that can be called from any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> within the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.<span class=
"definition">]</span></p>
<p class="element-syntax"><a name="element-function" id=
"element-function"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:function<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;override-extension-function? = "yes" | "no"<br />
&#160;&#160;<span class="grayed">[override]?</span> = "yes" |
"no"<br />
&#160;&#160;identity-sensitive? = "yes" | "no"<br />
&#160;&#160;cache? = "full" | "partial" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:function&gt;</code></p>
<p>The <a href="#element-function"><code>xsl:function</code></a>
declaration defines a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet function</a>
that can be called from any XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> used in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> (including an XPath expression used
within a predicate in a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>). The <code>name</code> attribute
specifies the name of the function. The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>.</p>
<p>An <a href="#element-function"><code>xsl:function</code></a>
declaration can only appear as a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element in a
stylesheet module.</p>
<p>The content of the <a href=
"#element-function"><code>xsl:function</code></a> element consists
of zero or more <a href="#element-param"><code>xsl:param</code></a>
elements that specify the formal arguments of the function,
followed by a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that defines
the value to be returned by the function.</p>
<div class="div3">
<h4><a name="xsl-function-name" id="xsl-function-name"></a>10.3.1
<a href="#xsl-function-name" style="text-decoration: none">Function
Name and Arity</a></h4>
<p>The name of the function is given by the <code>name</code>
attribute; the arguments are defined by child <a href=
"#element-param"><code>xsl:param</code></a> elements; and the
return type is defined by the <code>as</code> attribute. Together
these definitions constitute the <em>function signature</em>.</p>
<p><a name="err-XTSE0740" id="err-XTSE0740"><span class=
"error">[ERR XTSE0740]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> has a name that
is in no namespace.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To prevent the namespace declaration used for the function name
appearing in the result document, use the
<code>exclude-result-prefixes</code> attribute on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element: see
<a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal
Result Elements</i></a>.</p>
<p>The name of the function must not be in a <a title=
"reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a>: <span class=
"error">[see <a href="#err-XTSE0080">ERR XTSE0080</a>]</span></p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-arity" id="dt-arity" title="arity"></a>The <b>arity</b> of a
stylesheet function is the number of <a href=
"#element-param"><code>xsl:param</code></a> elements in the
function definition.<span class="definition">]</span> Optional
arguments are not allowed.</p>
<p>As defined in XPath, the function that is executed as the result
of a function call is identified by looking in the in-scope
functions of the static context for a function whose name and
<a title="arity" class="termref" href="#dt-arity">arity</a> matches
the name and number of arguments in the function call.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Functions are not polymorphic. Although the XPath function call
mechanism allows two functions to have the same name and different
<a title="arity" class="termref" href="#dt-arity">arity</a>, it
does not allow them to be distinguished by the types of their
arguments.</p>
</div>
</div>
<div class="div3">
<h4><a name="function-arguments" id="function-arguments"></a>10.3.2
<a href="#function-arguments" style=
"text-decoration: none">Arguments</a></h4>
<p>The <a href="#element-param"><code>xsl:param</code></a> elements
define the formal arguments to the function. These are interpreted
positionally. When the function is called using a function-call in
an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, the first argument supplied is
assigned to the first <a href=
"#element-param"><code>xsl:param</code></a> element, the second
argument supplied is assigned to the second <a href=
"#element-param"><code>xsl:param</code></a> element, and so on.</p>
<p><a name="err-XTSE0760" id="err-XTSE0760"><span class=
"error">[ERR XTSE0760]</span></a> Because arguments to a stylesheet
function call <span class="verb">must</span> all be specified, the
<a href="#element-param"><code>xsl:param</code></a> elements within
an <a href="#element-function"><code>xsl:function</code></a>
element <span class="verb">must not</span> specify a default value:
this means they <span class="verb">must</span> be empty, and
<span class="verb">must not</span> have a <code>select</code>
attribute.</p>
<p>The <code>as</code> attribute of the <a href=
"#element-param"><code>xsl:param</code></a> element defines the
required type of the parameter. The rules for converting the values
of the actual arguments supplied in the function call to the types
required by each <a href=
"#element-param"><code>xsl:param</code></a> element are defined in
<a href="#xpath-30">[XPath 3.0]</a>. The rules that apply are those
for the case where <a title="XPath 1.0 compatibility mode" class=
"termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility
mode</a> is set to <code>false</code>.</p>
<p><a name="err-XTTE0790" id="err-XTTE0790"><span class=
"error">[ERR XTTE0790]</span></a> If the value of a parameter to a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> cannot be
converted to the required type, a <a title="type error" class=
"termref" href="#dt-type-error">type error</a> is signaled.</p>
<p>If the <code>as</code> attribute is omitted, no conversion takes
place and any value is accepted.</p>
</div>
<div class="div3">
<h4><a name="function-result" id="function-result"></a>10.3.3
<a href="#function-result" style="text-decoration: none">Function
Result</a></h4>
<p>The result of the function is the result of evaluating the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>Within the sequence constructor, the <a title="focus" class=
"termref" href="#dt-focus">focus</a> is initially <a title="absent"
class="termref" href="#dt-absent">absent</a>; this means that any
attempt to reference the context item, context position, or context
size is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>. <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPDY0002" title=
"XPDY0002"><span class="error">[ERR XPDY0002]</span></a>
<sup><small>XP30</small></sup></p>
<p>It is not possible within the body of the <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> to access the
values of local variables that were in scope in the place where the
function call was written. Global variables, however, remain
available.</p>
<p>The optional <code>as</code> attribute indicates the <a title=
"required type" class="termref" href="#dt-required-type">required
type</a> of the result of the function. The value of the
<code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><a name="err-XTTE0780" id="err-XTTE0780"><span class=
"error">[ERR XTTE0780]</span></a> If the <code>as</code> attribute
is specified, then the result evaluated by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) is
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. It
is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if this conversion fails. If the
<code>as</code> attribute is omitted, the calculated result is used
as supplied, and no conversion takes place.</p>
</div>
<div class="div3">
<h4><a name="function-visibility-and-overriding" id=
"function-visibility-and-overriding"></a>10.3.4 <a href=
"#function-visibility-and-overriding" style=
"text-decoration: none">Visibility and Overriding of
Functions</a></h4>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> defining the
function body <span class="verb">must</span> be empty.</p>
<p>A <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> is included in
the <em>in-scope functions</em> of the static context for all XPath
expressions used in the <span>containing <a title="package" class=
"termref" href="#dt-package">package</a></span>, unless</p>
<ul>
<li>
<p>there is another <a title="stylesheet function" class="termref"
href="#dt-stylesheet-function">stylesheet function</a> with the
same name and <a title="arity" class="termref" href=
"#dt-arity">arity</a>, and higher <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
or</p>
</li>
<li>
<p>the <code>override-extension-function</code> or
<code>override</code> attribute has the value <code>no</code> and
there is already a function with the same name and <a title="arity"
class="termref" href="#dt-arity">arity</a> in the in-scope
functions.</p>
</li>
</ul>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the function in other packages
depends on the value of the <code>visibility</code> attribute and
other factors, as described in <a href="#packages"><i>3.6
Packages</i></a></p>
<p>The optional
<span><code>override-extension-function</code></span> attribute
defines what happens if this function has the same name and
<a title="arity" class="termref" href="#dt-arity">arity</a> as a
function provided by the implementer or made available in the
static context using an implementation-defined mechanism. If the
<span><code>override-extension-function</code></span> attribute has
the value <code>yes</code>, then this function is used in
preference; if it has the value <code>no</code>, then the other
function is used in preference. The default value is
<code>yes</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Specifying
<span><code>override-extension-function="yes"</code></span> ensures
interoperable behavior: the same code will execute with all
processors. Specifying
<span><code>override-extension-function="no"</code></span> is
useful when writing a fallback implementation of a function that is
available with some processors but not others: it allows the
vendor's implementation of the function (or a user's implementation
written as an extension function) to be used in preference to the
stylesheet implementation, which is useful when the extension
function is more efficient.</p>
<p>The <code>override-extension-function</code> attribute does
<em>not</em> affect the rules for deciding which of several
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> with the same
name and <a title="arity" class="termref" href=
"#dt-arity">arity</a> takes precedence.</p>
</div>
<p>The <code>override</code> attribute is a <a title="deprecated"
class="termref" href="#dt-deprecated">deprecated</a> synonym of
<code>override-extension-function</code>, retained for
compatibility with XSLT 2.0. If both attributes are present then
they <span class="verb">must</span> have the same value.</p>
<p><a name="err-XTSE0770" id="err-XTSE0770"><span class=
"error">[ERR XTSE0770]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for a
<span><a title="package" class="termref" href=
"#dt-package">package</a></span> to contain two or more
<span>non-hidden</span> functions with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>, the same <a title="arity" class="termref" href=
"#dt-arity">arity</a>, and the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
unless there is another function with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> and arity, and a higher import precedence.</p>
<p>When the <a href=
"#element-function"><code>xsl:function</code></a> declaration
appears as a child of <a href=
"#element-override"><code>xsl:override</code></a>, there
<span class="verb">must</span> be a stylesheet function with the
same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and <a title="arity" class=
"termref" href="#dt-arity">arity</a> in the <a title="package"
class="termref" href="#dt-package">package</a> referenced by the
containing <a href=
"#element-use-package"><code>xsl:use-package</code></a> element;
the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of that function must be
<code>public</code> or <code>abstract</code>, and the overriding
and overridden functions <span class="verb">must</span> have the
same argument types and result type.</p>
</div>
<div class="div3">
<h4><a name="function-lookup" id="function-lookup"></a>10.3.5
<a href="#function-lookup" style="text-decoration: none">Dynamic
Access to Functions</a></h4>
<p>If a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> with a particular
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and <a title="arity" class=
"termref" href="#dt-arity">arity</a> exists in the stylesheet, then
a call to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function
supplying that name and arity will return the function as a value.
This applies only if the static context for the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> includes
the stylesheet function, which implies that the function is visible
in the containing package.</p>
<p>The <a href=
"#func-function-available"><code>function-available</code></a>
function, when called with a particular <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> and
<a title="arity" class="termref" href="#dt-arity">arity</a>,
returns true if and only if a call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> with the
same arguments, in the same static context, would return a function
item.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For legacy reasons there is also a single-argument version of
<a href=
"#func-function-available"><code>function-available</code></a>,
which returns true if there is a function with the given name
regardless of arity.</p>
</div>
<p>The standard rules for <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> require
that if the supplied name and arity identify a context-dependent
function such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-name"><code>name#0</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-lang"><code>lang#1</code></a><sup><small>FO30</small></sup>
(call it <var>F</var>), then the returned function value includes
in its closure a copy of the static and dynamic context of the call
to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>, and the
context item for a subsequent dynamic call of <var>F</var> is taken
from this saved context. In the case where the context item is a
node in a streamed input document, saving the node is not possible.
In this case, therefore, the context is saved with an absent focus,
so the call on <var>F</var> will fail with a dynamic error saying
that there is no context item available.</p>
</div>
<div class="div3">
<h4><a name="function-determinism" id=
"function-determinism"></a>10.3.6 <a href="#function-determinism"
style="text-decoration: none">Determinism of Functions</a></h4>
<p>Stylesheet functions have been designed to be largely
deterministic: unless a stylesheet function calls some <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> which is itself
non-deterministic, the function will return results that depend
only on the supplied arguments. This property (coupled with the
fact that the effect of calling extension functions is entirely
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>)
enables a processor to implement various optimizations, such as
removing invariant function calls from the body of a loop, or
combining common sub-expressions,.</p>
<p>One exception to the intrinsic determinism of stylesheet
functions arises because constructed nodes have distinct identity.
This means that when a function that creates a new node is called,
two calls on the function will return nodes that can be
distinguished: for example, with such a function,
<code>f:make-node() is f:make-node()</code> will return false. This
property of functions is called <em>identity-sensitivity</em>. If a
processor cannot determine by static analysis that the function is
not identity-sensitive, then it cannot perform optimizations that
would observably change this behavior.</p>
<p>To allow processors greater freedom to optimize calls on
stylesheet functions, the attribute
<code>identity-sensitive="no"</code> may be specified (the default
is <code>yes</code>). When the value <code>no</code> is specified,
the stylesheet author is asserting that for any node passed in the
value of an argument to the function, and for any node returned as
a result, the stylesheet as a whole will give acceptable results if
the node is replaced by a different node that is deep-equal to the
original.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note the term "acceptable". The result of the transformation may
be different, but not in a way that the stylesheet author cares
about.</p>
<p>Declaring a function with <code>identity-sensitive="no"</code>
might allow a call to the function to be moved out of a loop, so
the function is only called once before entry to the loop rather
than being called repeatedly within the loop. If the arguments to
the function depend only on global variables then it might enable
the function call to be moved into a global variable. It might also
enable some caching or memoization at the processor's
discretion.</p>
<p>Declaring a function with <code>identity-sensitive="no"</code>
might also allow nodes from a streamed input document to be passed
to the function, since the function is licensed to operate on a
deep copy of the node. However, the streamability analysis in this
specification does not take account of this possibility.</p>
</div>
</div>
<div class="div3">
<h4><a name="memoization" id="memoization"></a>10.3.7 <a href=
"#memoization" style="text-decoration: none">Memoization</a></h4>
<p>The <code>cache</code> attribute is an optimization hint which
the processor can use or ignore at its discretion; however it
should be taken seriously, because it may make a difference to
whether execution of a stylesheet is practically feasible or
not.</p>
<p>The default value is <code>cache="no".</code></p>
<p>The value <code>cache="full"</code> encourages the processor to
retain memory of all previous calls of this function during the
same transformation and to reuse results from this memory whenever
possible. The value <code>cache="partial"</code> encourages the
processor to retain such memory but to discard results if necessary
to keep the amount of memory used within bounds. The default value
<code>cache="no"</code> encourages the processor not to retain
memory of previous calls.</p>
<p>In all cases the results must respect the semantics; for example
if an attribute node is supplied as the value of an argument, then
its identity must be assumed to be significant unless (a)
<code>identity-sensitive="no"</code> is specified, or (b) the
processor is able to determine by static analysis that the identity
of the attribute node makes no difference to the result (for
example, because all references to the argument are atomizing
references).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Memoization using the <code>cache</code> attribute may be more
effective if the attribute <code>identity-sensitive="no"</code> is
also used, as this gives a processor more scope for optimization.
In particular, specifying <code>cache="full"</code> by itself does
not remove the obligation of a processor to return distinct nodes
on each call of a function, whereas combining this with
<code>identity-sensitive="no"</code> does remove this
obligation.</p>
</div>
</div>
<div class="div3">
<h4><a name="function-examples" id="function-examples"></a>10.3.8
<a href="#function-examples" style="text-decoration: none">Examples
of Stylesheet Functions</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e25738" id=
"d7e25738"></a>Example: A Stylesheet Function</div>
<p>The following example creates a recursive <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> named
<code>str:reverse</code> that reverses the words in a supplied
sentence, and then invokes this function from within a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;
</pre></div>
<p>An alternative way of writing the same function is to implement
the conditional logic at the XSLT level, thus:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence 
           select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25758" id=
"d7e25758"></a>Example: Declaring the Return Type of a
Function</div>
<p>The following example illustrates the use of the <code>as</code>
attribute in a function definition. It returns a string containing
the representation of its integer argument, expressed as a roman
numeral. For example, the function call <code>num:roman(7)</code>
will return the string <code>"vii"</code>. This example uses the
<a href="#element-number"><code>xsl:number</code></a> instruction,
described in <a href="#number"><i>12 Numbering</i></a>. The
<a href="#element-number"><code>xsl:number</code></a> instruction
returns a text node, and the <a title="function conversion rules"
class="termref" href="#dt-function-conversion-rules">function
conversion rules</a> are invoked to convert this text node to the
type declared in the <a href=
"#element-function"><code>xsl:function</code></a> element, namely
<code>xs:string</code>. So the text node is <a title="atomize"
class="termref" href="#dt-atomization">atomized</a> to a
string.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25795" id=
"d7e25795"></a>Example: A Higher-Order Function</div>
<p>XPath 3.0 introduces the ability to pass function items as
argument to a function. A function that takes function items as
arguments is known as a higher-order function.</p>
<p>The following example is a higher-order function that operates
on any tree-structured data, for example an organization chart.
Given as input a function that finds the direct subordinates of a
node in this tree structure (for example, the direct reports of a
manager, or the geographical subdivisions of an administrative
area), it determines whether one object is present in the subtree
rooted at another object (for example, whether one person is among
the staff managed directly or indirectly by a manager, or whether
one parcel of land is contained directly or indirectly within
another parcel. The function does not check for cycles in the
data.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>Given source data representing an organization chart in the form
of elements such as:</p>
<div class="exampleInner">
<pre>
&lt;employee id="P57832" manager="P68951"/&gt;
</pre></div>
<p>the following function can be defined to get the direct reports
of a manager:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = $manager/@id]"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>It is then possible to test whether one employee <code>$E</code>
reports directly or indirectly to another employee <code>$M</code>
by means of the function call:</p>
<div class="exampleInner">
<pre>
f:is-subordinate($M, $E, f:direct-reports#1)
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="dynamic-xpath" id="dynamic-xpath"></a>10.4 <a href=
"#dynamic-xpath" style="text-decoration: none">Dynamic XPath
Evaluation</a></h3>
<p class="element-syntax"><a name="element-evaluate" id=
"element-evaluate"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:evaluate<br />
&#160;&#160;<b>xpath</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;base-uri? = { <var>uri</var> }<br />
&#160;&#160;with-params? = <var>expression</var><br />
&#160;&#160;context-item? = <var>expression</var><br />
&#160;&#160;namespace-context? = <var>expression</var><br />
&#160;&#160;schema-aware? = { "yes" | "no" }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:evaluate&gt;</code></p>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction constructs an XPath expression in the form of a string,
evaluates the expression in a specified context, and returns the
result of the evaluation.</p>
<p>The expression given as the value of the <code>xpath</code>
attribute is evaluated and the result is converted to a string
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion
rules</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-target-expression" id="dt-target-expression" title=
"target expression"></a>The string that results from evaluating the
expression in the <code>xpath</code> attribute is referred to as
the <b>target expression</b>.<span class="definition">]</span></p>
<p><a name="err-XTDE3160" id="err-XTDE3160"><span class=
"error">[ERR XTDE3160]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="target expression" class="termref" href=
"#dt-target-expression">target expression</a> is not a valid XPath
3.0 expression (that is, if a static error occurs when analyzing
the string according to the rules of the XPath 3.0
specification).</p>
<p>The <code>as</code> attribute, if present, indicates the
required type of the result. If the attribute is absent, the
required type is <code>item()*</code>, which allows any result. The
result of evaluating the <a title="target expression" class=
"termref" href="#dt-target-expression">target expression</a> is
converted to the required type using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. This
may cause a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if conversion is not possible. The
result after conversion is returned as the result of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p>
<p>The target expression may contain variable references; the
values of such variables may be supplied using an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
instruction if the names of the variables are known statically, or
using a map supplied as the value of the expression in the
<code>with-params</code> attribute if the names are only known
dynamically. If the <code>with-params</code> attribute is present
then it must contain an expression whose value, when evaluated, is
of type <code>map(xs:QName, item()*)</code> (see <a href=
"#map"><i>21.1 Maps</i></a> for details of maps).</p>
<div class="div3">
<h4><a name="evaluate-static-context" id=
"evaluate-static-context"></a>10.4.1 <a href=
"#evaluate-static-context" style="text-decoration: none">Static
context for the target expression</a></h4>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> for the <a title=
"target expression" class="termref" href=
"#dt-target-expression">target expression</a> is as follows:</p>
<ul>
<li>
<p>XPath 1.0 compatibility mode is <code>false</code>.</p>
</li>
<li>
<p>Statically known namespaces and default element/type
namespace:</p>
<ul>
<li>
<p>if the <code>namespace-context</code> attribute is present, then
its value is an <a title="expression" class="termref" href=
"#dt-expression">expression</a> whose required type is a single
node. The expression is evaluated, and the in-scope namespaces of
the resulting node are used as the statically known namespaces for
the target expression. The binding for the default namespace in the
in-scope namespaces is used as the default namespace for elements
and types in the target expression.</p>
<p><a name="err-XTTE3170" id="err-XTTE3170"><span class=
"error">[ERR XTTE3170]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>namespace-context</code> attribute of the
<a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is anything other than a single node.</p>
</li>
<li>
<p>if the <code>namespace-context</code> attribute is absent, then
the in-scope namespaces of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction (with
the exception of any binding for the default namespace) are used as
the statically known namespaces for the target expression, and the
value of the innermost <code>[xsl:]xpath-default-namespace</code>
attribute, if any, is used as the default namespace for elements
and types in the target expression.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XPath 3.0 allows expanded names to be written in a
context-independent way using the syntax
<code>Q{namespace-uri}local-name</code></p>
</div>
</li>
<li>
<p>Default function namespace: the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a>.</p>
</li>
<li>
<p>In-scope schema definitions: if the <code>schema-aware</code>
attribute is present and has the <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a>
<code>yes</code>, then the in-scope schema definitions from the
stylesheet context (that is, the schema definitions imported using
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a>).
Otherwise, the built-in types (see <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>).</p>
</li>
<li>
<p>In-scope variables: the names of the in-scope variables are the
union of the names appearing in the <code>name</code> attribute of
the contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements, and
the names present as keys in the map obtained by evaluating the
<code>with-params</code> attribute, if present. The corresponding
type is <code>item()*</code> in the case of a name found as a key
in the <code>with-params</code> map, or the type named in the
<code>as</code> attribute of <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
(defaulting to <code>item()*</code>) otherwise.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Variables declared in the stylesheet in <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> elements are
<em>not</em> in-scope within the target expression.</p>
<p>If variable names are present in both the static <a href=
"#element-with-param"><code>xsl:with-param</code></a> children and
also in the dynamic <code>with-params</code> map, the value from
the latter takes precedence.</p>
</div>
</li>
<li>
<p>Function signatures: All <a title="core function" class=
"termref" href="#dt-core-function">core functions</a>; constructor
functions for <span>named simple</span> types included in the
in-scope schema definitions; all user-defined functions <span>and
accumulator functions present in the containing package provided
their visibility is not <code>hidden</code> or
<code>private</code>;</span> and an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> set of
<a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a>.</p>
<p>Note that this set deliberately excludes XSLT-defined functions
in the <a title="standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>
including for example, <a href="#func-key"><code>key</code></a>,
<a href="#func-current-group"><code>current-group</code></a>, and
<a href="#func-system-property"><code>system-property</code></a> A
list of these functions is in <a href=
"#XSLT-defined-functions"><i>G List of XSLT-defined
functions</i></a>.</p>
</li>
<li>
<p>Statically known collations: the same as the collations
available at this point in the stylesheet.</p>
</li>
<li>
<p>Default collation: the same as the default collation defined at
this point in the stylesheet (for example, by use of the
<code>[xsl:]default-collation</code> attribute)</p>
</li>
<li>
<p>Base URI: if the <code>base-uri</code> attribute is present,
then its <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a>; otherwise, the base URI
of the <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction.</p>
</li>
<li>
<p>Statically known documents: the empty set</p>
</li>
<li>
<p>Statically known collections: the empty set</p>
</li>
<li>
<p>Statically known default collection type:
<code>node()*</code></p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="evaluate-dynamic-context" id=
"evaluate-dynamic-context"></a>10.4.2 <a href=
"#evaluate-dynamic-context" style="text-decoration: none">Dynamic
context for the target expression</a></h4>
<p>The dynamic context for evaluation of the target expression is
as follows:</p>
<ul>
<li>
<p>The context item, position, and size depend on the result of
evaluating the expression in the <code>context-item</code>
attribute. If this attribute is absent, or if the result is an
empty sequence, then the context item, position, and size for
evaluation of the target expression are all <a title="absent"
class="termref" href="#dt-absent">absent</a>. If the result of
evaluating the <code>context-item</code> expression is a single
item, then the target expression is evaluated with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on this item.</p>
<p><a name="err-XTTE3210" id="err-XTTE3210"><span class=
"error">[ERR XTTE3210]</span></a> If the result of evaluating the
<code>context-item</code> expression is a sequence containing more
than one item, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is signaled.</p>
</li>
<li>
<p>The <b>variable values</b> consists of the values bound to
parameters defined either in the contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements,
which are evaluated as described in <a href=
"#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>, or in the map that results from evaluation of
the expression in the <code>with-params</code> attribute; if the
same QName is bound in both, the value in the
<code>with-params</code> map takes precedence.</p>
</li>
<li>
<p>The XSLT-specific aspects of the dynamic context described in
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a> are all <a title="absent"
class="termref" href="#dt-absent">absent</a>.</p>
</li>
<li>
<p>All other aspects of the dynamic context are the same as the
dynamic context for the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction
itself.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="evaluate-effect" id="evaluate-effect"></a>10.4.3
<a href="#evaluate-effect" style="text-decoration: none">The effect
of the</a> <code>xsl:evaluate</code> <a href="#evaluate-effect"
style="text-decoration: none">instruction</a></h4>
<p>The XPath expression is evaluated in the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> as the calling XSLT
transformation; this means that the results of <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> will be
consistent between the calling stylesheet and the called XPath
expression.</p>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if evaluation of the XPath
expression fails with a dynamic error. The XPath-defined error code
is used unchanged.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations wanting to avoid the cost of repeated
compilation of the same XPath expression should cache the compiled
form internally.</p>
</div>
<p>Stylesheet authors need to be aware of the security risks
associated with the use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>. The instruction
should not be used to execute code from an untrusted source. To
avoid the risk of code injection, user-supplied data should never
be inserted into the expression using string concatenation, but
should always be referenced by use of parameters.</p>
</div>
<div class="div3">
<h4><a name="evaluation-as-optional-feature" id=
"evaluation-as-optional-feature"></a>10.4.4 <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> <a href=
"#evaluation-as-optional-feature" style="text-decoration: none">as
an optional feature</a></h4>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is newly introduced in XSLT 3.0. It is part of the
dynamic evaluation feature, which is an optional feature of the
specification (see <a href="#dynamic-evaluation-feature"><i>26.6
Dynamic Evaluation Feature</i></a>). An XSLT 3.0 processor
<span class="verb">may</span> disable the feature, or allow users
to disable the feature. The processor <span class="verb">may</span>
be able to determine during static analysis whether or not the
feature is available, or it <span class="verb">may</span> only be
able to determine this during dynamic evaluation. In the first case
we refer to the feature being <b>statically disabled</b>, in the
second case to it being <b>dynamically disabled</b>.</p>
<p>If the feature is statically disabled, then:</p>
<ul>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code> returns
false, wherever it appears;</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
returns "no", wherever it appears;</p>
</li>
<li>
<p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, fallback
processing takes place;</p>
</li>
<li>
<p>No static error is raised if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
present in the stylesheet (an error occurs only if it is actually
evaluated).</p>
</li>
</ul>
<p>If the feature is dynamically disabled, then:</p>
<ul>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code>
appearing in a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a> (for example, in an
<code>[xsl:]use-when</code> attribute) returns true;</p>
</li>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code>
appearing anywhere else returns false;</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
appearing in a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a> (for example, in an
<code>[xsl:]use-when</code> attribute) returns "yes";</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
appearing anywhere else returns "no";</p>
</li>
<li>
<p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, fallback
processing takes place;</p>
</li>
<li>
<p>In the absence of an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, a dynamic
error is raised if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated. The dynamic error may be caught using <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a>.</p>
</li>
</ul>
<p><a name="err-XTDE3175" id="err-XTDE3175"><span class=
"error">[ERR XTDE3175]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
<a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is evaluated when use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> has been
statically or dynamically disabled.</p>
<p>In consequence of these rules, the recommended approach for
stylesheet authors to write code that works whether or not <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> is enabled is to
use an <a href="#element-fallback"><code>xsl:fallback</code></a>
child instruction. For example:</p>
<div class="exampleInner">
<pre>
    &lt;xsl:variable name="isValid" as="xs:boolean"&gt;
      &lt;xsl:evaluate xpath="$validityCondition"&gt;
         &lt;xsl:fallback&gt;&lt;xsl:sequence select="true()"/&gt;&lt;/xsl:fallback&gt;
      &lt;/xsl:evaluate&gt;
      &lt;/xsl:variable&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There may be circumstances where it is inappropriate to allow
use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>.
For example:</p>
<ul>
<li>
<p>There may be security risks associated with the ability to
execute code from an untrusted source, which cannot be inspected
during static analysis.</p>
</li>
<li>
<p>There may be environments where the the available computing
resources are sufficient to enable pre-compiled stylesheets to be
executed, but not to enable XPath expressions to be compiled into
executable code.</p>
</li>
</ul>
<p>Processors that implement <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> should provide
mechanisms allowing calls on <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> to be disabled.
Implementations may disable the feature by default, and they may
disable it unconditionally.</p>
</div>
</div>
<div class="div3">
<h4><a name="evaluate-examples" id="evaluate-examples"></a>10.4.5
<a href="#evaluate-examples" style="text-decoration: none">Examples
of</a> <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e26406" id=
"d7e26406"></a>Example: Using a Dynamic Sort Key</div>
<p>A common requirement is to sort a table on the value of an
expression which is selected at run-time, perhaps by supplying the
expression as a string-valued parameter to the stylesheet. Suppose
that such an expression is supplied to the parameter:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;
</pre></div>
<p>Then the data may be sorted as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;
</pre></div>
<p>Note the importance in this use case of caching the compiled
expression, since it is evaluated repeatedly, once for each item in
the list being sorted.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e26419" id=
"d7e26419"></a>Example: Getting a Function if it Exists</div>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function,
if it were not available in the standard library, could be
implemented like this:</p>
<div class="exampleInner">
<pre>
     &lt;xsl:function name="f:function-lookup"&gt;
       &lt;xsl:param name="name" as="xs:QName"/&gt;
       &lt;xsl:param name="arity" as="xs:integer"/&gt;
       &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                      || local-name-from-QName($name) || '#' || $arity"&gt;
         &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
         &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
       &lt;/xsl:evaluate&gt;
     &lt;/xsl:function&gt;  
     
</pre></div>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction uses the supplied QName and arity to construct an
expression of the form <code>Q{namespace-uri}local#arity</code>,
which is then evaluated to return a function item representing the
requested function.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="creating-new-nodes" id="creating-new-nodes"></a>11
<a href="#creating-new-nodes" style=
"text-decoration: none">Creating Nodes and Sequences</a></h2>
<p>This section describes instructions that directly create new
nodes, or sequences of nodes, atomic values, <span>and/or function
items</span>.</p>
<div class="div2">
<h3><a name="literal-result-element" id=
"literal-result-element"></a>11.1 <a href="#literal-result-element"
style="text-decoration: none">Literal Result Elements</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-literal-result-element" id="dt-literal-result-element" title=
"literal result element"></a>In a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>, an element in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> that does not belong
to the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> and that is not an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>) is
classified as a <b>literal result element</b>.<span class=
"definition">]</span> A literal result element is evaluated to
construct a new element node with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> (that is, the same namespace URI, local name, and
namespace prefix). The result of evaluating a literal result
element is a node sequence containing one element, the newly
constructed element node.</p>
<p>The content of the element is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>). The sequence obtained by evaluating
this sequence constructor, after prepending any attribute nodes
produced as described in <a href="#attributes-for-lres"><i>11.1.2
Attribute Nodes for Literal Result Elements</i></a> and namespace
nodes produced as described in <a href="#lre-namespaces"><i>11.1.3
Namespace Nodes for Literal Result Elements</i></a>, is used to
construct the content of the element, following the rules in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a></p>
<p>The base URI of the new element is copied from the base URI of
the literal result element in the stylesheet, unless the content of
the new element includes an <code>xml:base</code> attribute, in
which case the base URI of the new element is the value of that
attribute, resolved (if it is a relative URI
<span>reference</span>) against the base URI of the literal result
element in the stylesheet. (Note, however, that this is only
relevant when creating a parentless element. When the literal
result element is copied to form a child of an element or document
node, the base URI of the new copy is taken from that of its new
parent.)</p>
<div class="div3">
<h4><a name="setting-annotation-for-lre" id=
"setting-annotation-for-lre"></a>11.1.1 <a href=
"#setting-annotation-for-lre" style="text-decoration: none">Setting
the Type Annotation for Literal Result Elements</a></h4>
<p>The attributes <code>xsl:type</code> and
<code>xsl:validation</code> may be used on a literal result element
to invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> that the new element node will
carry. These attributes also affect the type annotation carried by
any elements and attributes that have the new element node as an
ancestor. These two attributes are both optional, and if one is
specified then the other <span class="verb">must</span> be
omitted.</p>
<p>The value of the <code>xsl:validation</code> attribute, if
present, must be one of the values <code>strict</code>,
<code>lax</code>, <code>preserve</code>, or <code>strip</code>. The
value of the <code>xsl:type</code> attribute, if present, must be
an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span> identifying a type definition that
is present in the <a title="in-scope schema component" class=
"termref" href="#dt-in-scope-schema-component">in-scope schema
components</a> for the stylesheet. Neither attribute may be
specified as an <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value template.</a>
The effect of these attributes is described in <a href=
"#validation"><i>24.2 Validation</i></a>.</p>
</div>
<div class="div3">
<h4><a name="attributes-for-lres" id=
"attributes-for-lres"></a>11.1.2 <a href="#attributes-for-lres"
style="text-decoration: none">Attribute Nodes for Literal Result
Elements</a></h4>
<p>Attribute nodes for a literal result element may be created by
including <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
within the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. Additionally,
attribute nodes are created corresponding to the attributes of the
literal result element in the stylesheet, and as a result of
expanding the <code>xsl:use-attribute-sets</code> attribute of the
literal result element, if present.</p>
<p>The sequence that is used to construct the content of the
literal result element (as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>) is the concatenation of the following four
sequences, in order:</p>
<ol class="enumar">
<li>
<p>The sequence of namespace nodes produced as described in
<a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal
Result Elements</i></a>.</p>
</li>
<li>
<p>The sequence of attribute nodes produced by expanding the
<code>xsl:use-attribute-sets</code> attribute (if present)
following the rules given in <a href="#attribute-sets"><i>10.2
Named Attribute Sets</i></a></p>
</li>
<li>
<p>The attributes produced by processing the attributes of the
literal result element itself, other than attributes in the
<a title="" class="termref" href="#xslt-namespace">XSLT
namespace</a>. The way these are processed is described below.</p>
</li>
<li>
<p>The sequence produced by evaluating the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, if the element
is not empty.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The significance of this order is that an attribute produced by
an <code>xsl:attribute</code>, <a href=
"#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction in the
content of the literal result element takes precedence over an
attribute produced by expanding an attribute of the literal result
element itself, which in turn takes precedence over an attribute
produced by expanding the <code>xsl:use-attribute-sets</code>
attribute. This is because of the rules in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, which specify that when two or more attributes in
the sequence have the same name, all but the last of the duplicates
are discarded.</p>
<p>Although the above rules place namespace nodes before
attributes, this is not strictly necessary, because the rules in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a> allow the namespaces and attributes to
appear in any order so long as both come before other kinds of
node. The order of namespace nodes and attribute nodes in the
sequence has no effect on the relative position of the nodes in
document order once they are added to a tree.</p>
</div>
<p>Each attribute of the literal result element, other than an
attribute in the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>, is processed to produce an
attribute for the element in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a>.</p>
<p>The value of such an attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>: it can
therefore contain <a title="expression" class="termref" href=
"#dt-expression">expressions</a> contained in curly brackets
(<code>{}</code>). The new attribute node will have the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> (that is, the same
namespace URI, local name, and namespace prefix) as the attribute
in the stylesheet tree, and its <a title="string value" class=
"termref" href="#dt-string-value">string value</a> will be the same
as the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute in the
stylesheet tree. The <a title="type annotation" class="termref"
href="#dt-annotation">type annotation</a> on the attribute will
initially be <code>xs:untypedAtomic</code>, and the <a title=
"typed value" class="termref" href="#dt-typed-value">typed
value</a> of the attribute node will be the same as its <a title=
"string value" class="termref" href="#dt-string-value">string
value</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The eventual <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> of the attribute in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> depends on the
<code>xsl:validation</code> and <code>xsl:type</code> attributes of
the parent literal result element, and on the instructions used to
create its ancestor elements. If the <code>xsl:validation</code>
attribute is set to <code>preserve</code> or <code>strip</code>,
the type annotation will be <code>xs:untypedAtomic</code>, and the
<a title="typed value" class="termref" href="#dt-typed-value">typed
value</a> of the attribute node will be the same as its <a title=
"string value" class="termref" href="#dt-string-value">string
value</a>. If the <code>xsl:validation</code> attribute is set to
<code>strict</code> or <code>lax</code>, or if the
<code>xsl:type</code> attribute is used, the type annotation on the
attribute will be set as a result of the schema validation process
applied to the parent element. If neither attribute is present, the
type annotation on the attribute will be
<code>xs:untypedAtomic</code>.</p>
</div>
<p>If the name of a constructed attribute is <code>xml:id</code>,
the processor must perform attribute value normalization by
effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup> function
to the value of the attribute, and the resulting attribute node
must be given the <code>is-id</code> property.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the attribute name is <code>xml:space</code>, it is
<em>not</em> an error when the value is something other than
<code>default</code> or <code>preserve</code>. Although the XML
specification states that other values are erroneous, a document
containing such values is well-formed; if erroneous values are to
be rejected, schema validation should be used.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>xml:base</code>, <code>xml:lang</code>,
<code>xml:space</code>, and <code>xml:id</code> attributes have two
effects in XSLT. They behave as standard XSLT attributes, which
means for example that if they appear on a literal result element,
they will be copied to the <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a> in the same way as any other
attribute. In addition, they have their standard meaning as defined
in the core XML specifications. Thus, an <code>xml:base</code>
attribute in the stylesheet affects the base URI of the element on
which it appears, and an <code>xml:space</code> attribute affects
the interpretation of <a title="whitespace text node" class=
"termref" href="#dt-whitespace-text-node">whitespace text nodes</a>
within that element. One consequence of this is that it is
inadvisable to write these attributes as attribute value templates:
although an XSLT processor will understand this notation, the XML
parser will not. See also <a href="#namespace-aliasing"><i>11.1.5
Namespace Aliasing</i></a> which describes how to use <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
with these attributes.</p>
<p>The same is true of the schema-defined attributes
<code>xsi:type</code>, <code>xsi:nil</code>,
<code>xsi:noNamespaceSchemaLocation</code>, and
<code>xsi:schemaLocation</code>. If the stylesheet is processed by
a schema processor, these attributes will be recognized and
interpreted by the schema processor, but in addition the XSLT
processor treats them like any other attribute on a literal result
element: that is, their <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> (after expanding
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>) is
copied to the result tree in the same way as any other attribute.
If the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> is validated, the copied
attributes will again be recognized and interpreted by the schema
processor.</p>
<p>None of these attributes will be generated in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> unless the stylesheet writes them to the result tree
explicitly, in the same way as any other attribute.</p>
</div>
<p><a name="err-XTSE0805" id="err-XTSE0805"><span class=
"error">[ERR XTSE0805]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
attribute on a literal result element is in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, unless it is one of the attributes explicitly
defined in this specification.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If there is a need to create attributes in the XSLT namespace,
this can be achieved using <a href=
"#element-attribute"><code>xsl:attribute</code></a>, or by means of
the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration.</p>
</div>
</div>
<div class="div3">
<h4><a name="lre-namespaces" id="lre-namespaces"></a>11.1.3
<a href="#lre-namespaces" style="text-decoration: none">Namespace
Nodes for Literal Result Elements</a></h4>
<p>The created element node will have a copy of the namespace nodes
that were present on the element node in the stylesheet tree with
the exception of any namespace node whose <a title="string value"
class="termref" href="#dt-string-value">string value</a> is
designated as an <b>excluded namespace</b>. Special considerations
apply to aliased namespaces: see <a href=
"#namespace-aliasing"><i>11.1.5 Namespace Aliasing</i></a></p>
<p>The following namespaces are designated as excluded
namespaces:</p>
<ul>
<li>
<p>The <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> URI
(<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
</li>
<li>
<p>A namespace URI declared as an extension namespace (see <a href=
"#extension-instruction"><i>23.2 Extension
Instructions</i></a>)</p>
</li>
<li>
<p>A namespace URI designated by using an
<code>[xsl:]exclude-result-prefixes</code> attribute either on the
literal result element itself or on an ancestor element. The
attribute <span class="verb">must</span> be in the XSLT namespace
only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>The value of the attribute is either <code>#all</code>, or a
whitespace-separated list of tokens, each of which is either a
namespace prefix or <code>#default</code>. The namespace bound to
each of the prefixes is designated as an excluded namespace.</p>
<p><a name="err-XTSE0808" id="err-XTSE0808"><span class=
"error">[ERR XTSE0808]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
namespace prefix is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and there is
no namespace binding in scope for that prefix.</p>
<p>The default namespace of the parent element of the
<code>[xsl:]exclude-result-prefixes</code> attribute (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) may be designated
as an excluded namespace by including <code>#default</code> in the
list of namespace prefixes.</p>
<p><a name="err-XTSE0809" id="err-XTSE0809"><span class=
"error">[ERR XTSE0809]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value <code>#default</code> is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and the parent
element of the <code>[xsl:]exclude-result-prefixes</code> attribute
has no default namespace.</p>
<p>The value <code>#all</code> indicates that all namespaces that
are in scope for the stylesheet element that is the parent of the
<code>[xsl:]exclude-result-prefixes</code> attribute are designated
as excluded namespaces.</p>
<p>The designation of a namespace as an excluded namespace is
effective within the subtree of the stylesheet module rooted at the
element bearing the <code>[xsl:]exclude-result-prefixes</code>
attribute; a subtree rooted at an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element does
not include any stylesheet modules imported or included by children
of that <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
</li>
</ul>
<p>The excluded namespaces, as described above, <em>only</em>
affect namespace nodes copied from the stylesheet when processing a
literal result element. There is no guarantee that an excluded
namespace will not appear on the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> for some other
reason. Namespace nodes are also written to the result tree as part
of the process of namespace fixup (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>), or as the
result of instructions such as <a href=
"#element-copy"><code>xsl:copy</code></a> and <a href=
"#element-element"><code>xsl:element</code></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When a stylesheet uses a namespace declaration only for the
purposes of addressing a <a title="source tree" class="termref"
href="#dt-source-tree">source tree</a>, specifying the prefix in
the <code>[xsl:]exclude-result-prefixes</code> attribute will avoid
superfluous namespace declarations in the serialized <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>. The attribute is also useful to prevent namespaces used
solely for the naming of stylesheet functions or extension
functions from appearing in the serialized result tree.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e26971" id=
"d7e26971"></a>Example: Excluding Namespaces from the Result
Tree</div>
<p>For example, consider the following stylesheet:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>The result of this stylesheet will be:</p>
<div class="exampleInner">
<pre>
&lt;foo xmlns:d="d.uri"/&gt;
</pre></div>
<p>The namespaces <code>a.uri</code> and <code>b.uri</code> are
excluded by virtue of the <code>exclude-result-prefixes</code>
attribute on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, and
the namespace <code>c.uri</code> is excluded by virtue of the
<code>xsl:exclude-result-prefixes</code> attribute on the
<code>foo</code> element. The setting <code>#all</code> does not
affect the namespace <code>d.uri</code> because <code>d.uri</code>
is not an in-scope namespace for the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element. The
element in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> does not have a namespace node
corresponding to <code>xmlns:a2="a.uri"</code> because the effect
of <code>exclude-result-prefixes</code> is to designate the
namespace URI <code>a.uri</code> as an excluded namespace,
irrespective of how many prefixes are bound to this namespace
URI.</p>
<p>If the stylesheet is changed so that the literal result element
has an attribute <code>b:bar="3"</code>, then the element in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> will typically have a namespace
declaration <code>xmlns:b="b.uri"</code> (the processor may choose
a different namespace prefix if this is necessary to avoid
conflicts). The <code>exclude-result-prefixes</code> attribute
makes <code>b.uri</code> an excluded namespace, so the namespace
node is not automatically copied from the stylesheet, but the
presence of an attribute whose name is in the namespace
<code>b.uri</code> forces the namespace fixup process (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) to introduce a
namespace node for this namespace.</p>
</div>
<p>A literal result element may have an optional
<code>xsl:inherit-namespaces</code> attribute, with the value
<code>yes</code> or <code>no</code>. The default value is
<code>yes</code>. If the value is set to <code>yes</code>, or is
omitted, then the namespace nodes created for the newly constructed
element are copied to the children and descendants of the newly
constructed element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
</div>
<div class="div3">
<h4><a name="conditional-literal-result-elements" id=
"conditional-literal-result-elements"></a>11.1.4 <a href=
"#conditional-literal-result-elements" style=
"text-decoration: none">Conditional Creation of Literal Result
Elements</a></h4>
<p>If a literal result element has an <code>xsl:on-empty</code>
attribute, then the value of the attribute <span class=
"verb">must</span> be an XPath expression. If the attribute is
present and the constructed element has <span>no attributes and no
children</span>, then instead of returning the constructed element,
the instruction returns the result of evaluating the expression in
the <code>xsl:on-empty</code> attribute<span>; if this expression
returns a node, the instruction returns a copy of this
node.</span></p>
<p><a name="err-XTTE3300" id="err-XTTE3300"><span class=
"error">[ERR XTTE3300]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>xsl:on-empty</code> attribute does not
satisfy the required type <code>element()?</code>. That is, the
expression must deliver either a single element node, or an empty
sequence.</p>
<p>If the <code>xsl:on-empty</code> expression is evaluated and
returns an empty sequence, then the <code>xsl:validation</code> and
<code>xsl:type</code> attributes are ignored. However, if the
result of the <code>xsl:on-empty</code> expression is an element,
then it is subjected to validation as determined by these
attributes, along with <code>[xsl:]default-validation</code> where
relevant.</p>
<p>Note that when a literal result element has one or more
attributes (other than attributes in the XSLT namespace), or when
it references a non-empty attribute set, the <code>on-empty</code>
attribute has no effect because these conditions will not be
satisfied.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e27142" id=
"d7e27142"></a>Example: Generating a Wrapper Element for a
non-Empty Sequence</div>
<p>The following example generates an <code>events</code> element
if and only if there are one or more <code>event</code> elements.
The code could be written like this:</p>
<div class="exampleInner">
<pre>
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;
</pre></div>
<p>However, the above code would not be guaranteed streamable. To
make it streamable, it can be rewritten as:</p>
<div class="exampleInner">
<pre>
&lt;events xsl:on-empty="()"&gt;
    &lt;xsl:copy-of select="event"/&gt;
&lt;/events&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for introducing the <code>on-empty</code> attribute
is primarily to make it easier to write applications that conform
to the rules for guaranteed streamability. A common requirement is
to generate a wrapper element for a sequence of elements (for
example an <code>events</code> wrapper for a sequence of
<code>event</code> elements) only if the content sequence is
non-empty. Without the <code>xsl:on-empty</code> attribute this is
difficult to achieve, because testing whether any
<code>event</code> element exists and processing the set of
<code>event</code> elements both count as <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>
instructions.</p>
</div>
</div>
<div class="div3">
<h4><a name="namespace-aliasing" id="namespace-aliasing"></a>11.1.5
<a href="#namespace-aliasing" style=
"text-decoration: none">Namespace Aliasing</a></h4>
<p>When a stylesheet is used to define a transformation whose
output is itself a stylesheet module, or in certain other cases
where the result document uses namespaces that it would be
inconvenient to use in the stylesheet, namespace aliasing can be
used to declare a mapping between a namespace URI used in the
stylesheet and the corresponding namespace URI to be used in the
result document.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-literal-namespace-uri" id="dt-literal-namespace-uri" title=
"literal namespace URI"></a>A namespace URI in the stylesheet tree
that is being used to specify a namespace URI in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> is called a <b>literal namespace URI</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-target-namespace-uri" id="dt-target-namespace-uri" title=
"target namespace URI"></a>The namespace URI that is to be used in
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> as a substitute for a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is called the
<b>target namespace URI</b>.<span class="definition">]</span></p>
<p>Either of the <a title="literal namespace URI" class="termref"
href="#dt-literal-namespace-uri">literal namespace URI</a> or the
<a title="target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a> can be
<em>null</em>: this is treated as a reference to the set of names
that are in no namespace.</p>
<p class="element-syntax"><a name="element-namespace-alias" id=
"element-namespace-alias"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:namespace-alias<br />
&#160;&#160;<b>stylesheet-prefix</b> = <var>prefix</var> |
"#default"<br />
&#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
"#default"&#160;/&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-alias" id="dt-alias" title="alias"></a>A stylesheet can use the
<a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element to declare that a <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is being used as an <b>alias</b> for a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>.<span class=
"definition">]</span></p>
<p>The effect is that when names in the namespace identified by the
<a title="literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> are copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>, the namespace URI in the result
tree will be the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, instead
of the literal namespace URI. This applies to:</p>
<ul>
<li>
<p>the namespace URI in the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of a literal
result element in the stylesheet</p>
</li>
<li>
<p>the namespace URI in the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of an
attribute specified on a literal result element in the
stylesheet</p>
</li>
</ul>
<p>The effect of an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration is local to the <a title="package" class="termref"
href="#dt-package">package</a> in which it appears: that is, it
only affects the result of <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
elements</a> within the same package.</p>
<p>Where namespace aliasing changes the namespace URI part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> containing the name of an
element or attribute node, the namespace prefix in that expanded
QName is replaced by the prefix indicated by the
<code>result-prefix</code> attribute of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration.</p>
<p>The <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element declares that the namespace URI bound to the prefix
specified by the <code>stylesheet-prefix</code> is the <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a>, and the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute is the <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>. Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace
URI that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a>.</p>
<p>The default namespace (as declared by <code>xmlns</code>) may be
specified by using <code>#default</code> instead of a prefix. If no
default namespace is in force, specifying <code>#default</code>
denotes the null namespace URI. This allows elements that are in no
namespace in the stylesheet to acquire a namespace in the result
document, or vice versa.</p>
<p>If a <a title="literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is declared
to be an alias for multiple different <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">target namespace URIs</a>, then the
declaration with the highest <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a> is
used.</p>
<p><a name="err-XTSE0810" id="err-XTSE0810"><span class=
"error">[ERR XTSE0810]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if
<span>within a <a title="package" class="termref" href=
"#dt-package">package</a></span> there is more than one such
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and the same <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a> and different
values for the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, unless
there is also an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and a higher import precedence.</p>
<p><a name="err-XTSE0812" id="err-XTSE0812"><span class=
"error">[ERR XTSE0812]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a value
other than <code>#default</code> is specified for either the
<code>stylesheet-prefix</code> or the <code>result-prefix</code>
attributes of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element when there is no in-scope binding for that namespace
prefix.</p>
<p>When a literal result element is processed, its namespace nodes
are handled as follows:</p>
<ul>
<li>
<p>A namespace node whose string value is a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is not copied
to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
</li>
<li>
<p>A namespace node whose string value is a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a> is copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>, whether or not the URI
identifies an excluded namespace.</p>
</li>
</ul>
<p>In the event that the same URI is used as a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> and a
<a title="target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>, the second of
these rules takes precedence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules achieve the effect that the element generated from
the literal result element will have an in-scope namespace node
that binds the <code>result-prefix</code> to the <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>, provided that
the namespace declaration associating this prefix with this URI is
in scope for both the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
instruction and for the literal result element. Conversely, the
<code>stylesheet-prefix</code> and the <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> will not
normally appear in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e27457" id=
"d7e27457"></a>Example: Using <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a> to
Generate a Stylesheet</div>
<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a> URI, the stylesheet may use an alias.</p>
<p>For example, the stylesheet</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>will generate an XSLT stylesheet from a document of the
form:</p>
<div class="exampleInner">
<pre>
&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;
</pre></div>
<p>The output of the transformation will be a stylesheet such as
the following. Whitespace has been added for clarity. Note that an
implementation may output different namespace prefixes from those
appearing in this example; however, the rules guarantee that there
will be a namespace node that binds the prefix <code>xsl</code> to
the URI <code>http://www.w3.org/1999/XSL/Transform</code>, which
makes it safe to use the QName <code>xsl:version</code> in the
content of the generated stylesheet.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI. For example, it can be useful to
define an alias for the namespace
<code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
stylesheet can use the attributes <code>xsi:type</code>,
<code>xsi:nil</code>, and <code>xsi:schemaLocation</code> on a
literal result element, without running the risk that a schema
processor will interpret these as applying to the stylesheet
itself. Equally, literal result elements belonging to a namespace
dealing with digital signatures might cause XSLT stylesheets to be
mishandled by general-purpose security software; using an alias for
the namespace would avoid the possibility of such mishandling.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e27505" id=
"d7e27505"></a>Example: Aliasing the XML Namespace</div>
<p>It is possible to define an alias for the XML namespace.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>produces the output:</p>
<div class="exampleInner">
<pre>
&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;
</pre></div>
<p>This allows an <code>xml:space</code> attribute to be generated
in the output without affecting the way the stylesheet is parsed.
The same technique can be used for other attributes such as
<code>xml:lang</code>, <code>xml:base</code>, and
<code>xml:id</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Namespace aliasing is only necessary when literal result
elements are used. The problem of reserved namespaces does not
arise when using <a href=
"#element-element"><code>xsl:element</code></a> and <a href=
"#element-attribute"><code>xsl:attribute</code></a> to construct
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Therefore, as an alternative to
using <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>, it
is always possible to achieve the desired effect by replacing
literal result elements with <a href=
"#element-element"><code>xsl:element</code></a> and <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instructions.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="xsl-element" id="xsl-element"></a>11.2 <a href=
"#xsl-element" style="text-decoration: none">Creating Element Nodes
Using</a> <code>xsl:element</code> <a href="#xsl-element" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-element" id=
"element-element"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:element<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;inherit-namespaces? = "yes" | "no"<br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:element&gt;</code></p>
<p>The <a href="#element-element"><code>xsl:element</code></a>
instruction allows an element to be created with a computed name.
The <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created is specified by a <span class="verb">required</span>
<code>name</code> attribute and an optional <code>namespace</code>
attribute.</p>
<p>The result of evaluating the <a href=
"#element-element"><code>xsl:element</code></a> instruction,
<span>in usual circumstances</span>, is the newly constructed
element node.</p>
<div class="div3">
<h4><a name="xsl-element-content" id=
"xsl-element-content"></a>11.2.1 <a href="#xsl-element-content"
style="text-decoration: none">The Content of the Constructed
Element Node</a></h4>
<p>The content of the <a href=
"#element-element"><code>xsl:element</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children, attributes, and namespaces of the created element. The
sequence obtained by evaluating this sequence constructor (see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>) is used to construct the content of the
element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>.</p>
<p>The <a href="#element-element"><code>xsl:element</code></a>
element may have a <code>use-attribute-sets</code> attribute, whose
value is a whitespace-separated list of QNames that identify
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations. If this attribute is present, it is expanded as
described in <a href="#attribute-sets"><i>10.2 Named Attribute
Sets</i></a> to produce a sequence of attribute nodes. This
sequence is prepended to the sequence produced as a result of
evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>.</p>
</div>
<div class="div3">
<h4><a name="xsl-element-name" id="xsl-element-name"></a>11.2.2
<a href="#xsl-element-name" style="text-decoration: none">The Name
of the Constructed Element Node</a></h4>
<p>The <code>name</code> attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, whose
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0820" id="err-XTDE0820"><span class=
"error">[ERR XTDE0820]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0830" id="err-XTDE0830"><span class=
"error">[ERR XTDE0830]</span></a> In the case of an <a href=
"#element-element"><code>xsl:element</code></a> instruction with no
<code>namespace</code> attribute, it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-element"><code>xsl:element</code></a> instruction.</p>
<p>If the <code>namespace</code> attribute is not present then the
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> using the namespace declarations in effect for the
<a href="#element-element"><code>xsl:element</code></a> element,
including any default namespace declaration.</p>
<p>If the <code>namespace</code> attribute is present, then it too
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be in the lexical space of the
<code>xs:anyURI</code> type. If the string is zero-length, then the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element has a null
namespace URI. Otherwise, the string is used as the namespace URI
of the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created. The local part of the <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> specified by
the <code>name</code> attribute is used as the local part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created.</p>
<p><a name="err-XTDE0835" id="err-XTDE0835"><span class=
"error">[ERR XTDE0835]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute is not in the lexical space of the
<code>xs:anyURI</code> datatype or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The XDM data model requires the name of a node to be an instance
of <code>xs:QName</code>, and XML Schema defines the namespace part
of an <code>xs:QName</code> to be an instance of
<code>xs:anyURI</code>. However, the schema specification, and the
specifications that it refers to, give implementations some
flexibility in how strictly they enforce these constraints.</p>
</div>
<p>The prefix of the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> specified in the
<code>name</code> attribute (or the absence of a prefix) is copied
to the prefix part of the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> representing the name
of the new element node. In the event of a conflict a prefix may
subsequently be added, changed, or removed during the namespace
fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>). The term <em>conflict</em> here means any violation
of the constraints defined in <a href="#xpath-datamodel-30">[Data
Model]</a>, for example the use of the same prefix to refer to two
different namespaces in the element and in one of its attributes,
the use of the prefix <code>xml</code> to refer to a namespace
other than the XML namespace, or any use of the prefix
<code>xmlns</code>.</p>
</div>
<div class="div3">
<h4><a name="xsl-element-properties" id=
"xsl-element-properties"></a>11.2.3 <a href=
"#xsl-element-properties" style="text-decoration: none">Other
Properties of the Constructed Element Node</a></h4>
<p>The <a href="#element-element"><code>xsl:element</code></a>
instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The
default value is <code>yes</code>. If the value is set to
<code>yes</code>, or is omitted, then the namespace nodes created
for the newly constructed element (whether these were copied from
those of the source node, or generated as a result of namespace
fixup) are copied to the children and descendants of the newly
constructed element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
<p>The base URI of the new element is copied from the base URI of
the <a href="#element-element"><code>xsl:element</code></a>
instruction in the stylesheet, unless the content of the new
element includes an <code>xml:base</code> attribute, in which case
the base URI of the new element is the value of that attribute,
resolved (if it is a relative URI) against the base URI of the
<a href="#element-element"><code>xsl:element</code></a> instruction
in the stylesheet. (Note, however, that this is only relevant when
creating parentless elements. When the new element is copied to
form a child of an element or document node, the base URI of the
new copy is taken from that of its new parent.)</p>
</div>
<div class="div3">
<h4><a name="annotation-for-constructed-element" id=
"annotation-for-constructed-element"></a>11.2.4 <a href=
"#annotation-for-constructed-element" style=
"text-decoration: none">The Type Annotation of the Constructed
Element Node</a></h4>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-element"><code>xsl:element</code></a> instruction to
invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> that the new element node will
carry. These attributes also affect the type annotation carried by
any elements and attributes that have the new element node as an
ancestor. These two attributes are both optional, and if one is
specified then the other <span class="verb">must</span> be omitted.
The permitted values of these attributes and their semantics are
described in <a href="#validation"><i>24.2 Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final type annotation of the element in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> also depends on the <code>type</code> and
<code>validation</code> attributes of the instructions used to
create the ancestors of the element.</p>
</div>
</div>
<div class="div3">
<h4><a name="xsl-element-on-empty" id=
"xsl-element-on-empty"></a>11.2.5 <a href="#xsl-element-on-empty"
style="text-decoration: none">Conditional Construction of Element
Nodes</a></h4>
<p>If the <code>on-empty</code> attribute is present and the
content of the constructed element as determined by the rules in
<a href="#xsl-element-content"><i>11.2.1 The Content of the
Constructed Element Node</i></a> (that is, the result of evaluating
the sequence constructor and prepending any attributes generated by
the <code>use-attribute-sets</code> attribute) is a sequence
containing nothing other than namespace nodes and zero-length text
nodes, then instead of returning the newly constructed element
node, the instruction returns the result of evaluating the
expression in the <code>on-empty</code> attribute<span>; if this
expression returns a node, the instruction returns a copy of this
node</span>.</p>
<p><a name="err-XTTE3310" id="err-XTTE3310"><span class=
"error">[ERR XTTE3310]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>on-empty</code> attribute does not satisfy
the required type <code>element()?</code>. That is, the expression
must deliver either a single element node, or an empty
sequence.</p>
<p>If the <code>on-empty</code> expression is evaluated and returns
an empty sequence, then the <code>validation</code> and
<code>type</code> attributes are ignored. However, if the result of
the <code>on-empty</code> expression is an element, then it is
subjected to validation as determined by these attributes, along
with <code>[xsl:]default-validation</code> where relevant.</p>
</div>
</div>
<div class="div2">
<h3><a name="creating-attributes" id="creating-attributes"></a>11.3
<a href="#creating-attributes" style=
"text-decoration: none">Creating Attribute Nodes Using</a>
<code>xsl:attribute</code> <a href="#creating-attributes" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-attribute" id=
"element-attribute"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:attribute<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:attribute&gt;</code></p>
<p>The <a href="#element-attribute"><code>xsl:attribute</code></a>
element can be used to add attributes to result elements whether
created by literal result elements in the stylesheet or by
instructions such as <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of the attribute to be created is specified by a
<span class="verb">required</span> <code>name</code> attribute and
an optional <code>namespace</code> attribute. Except in error
cases, the result of evaluating an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction is
the newly constructed attribute node.</p>
<p>The string value of the new attribute node may be defined either
by using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
attribute node will be a zero-length string. The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0840" id="err-XTSE0840"><span class=
"error">[ERR XTSE0840]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element is
present unless the element has empty content.</p>
<p>If the <code>separator</code> attribute is present, then the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of this attribute is used
to separate adjacent items in the result sequence, as described in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified
using the <code>select</code> attribute, or a zero-length string
when the content is specified using a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The <code>name</code> attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, whose
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0850" id="err-XTDE0850"><span class=
"error">[ERR XTDE0850]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0855" id="err-XTDE0855"><span class=
"error">[ERR XTDE0855]</span></a> In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is the string <code>xmlns</code>.</p>
<p><a name="err-XTDE0860" id="err-XTDE0860"><span class=
"error">[ERR XTDE0860]</span></a> In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instruction.</p>
<p>If the <code>namespace</code> attribute is not present, then the
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> using the namespace declarations in effect for the
<a href="#element-attribute"><code>xsl:attribute</code></a>
element, <em>not</em> including any default namespace
declaration.</p>
<p>If the <code>namespace</code> attribute is present, then it too
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be in the lexical space of the
<code>xs:anyURI</code> type. If the string is zero-length, then the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute has a null
namespace URI. Otherwise, the string is used as the namespace URI
of the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute to be
created. The local part of the <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> specified by
the <code>name</code> attribute is used as the local part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute to be
created.</p>
<p><a name="err-XTDE0865" id="err-XTDE0865"><span class=
"error">[ERR XTDE0865]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute is not in the lexical space of the
<code>xs:anyURI</code> datatype or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The same considerations apply as for elements: <span class=
"error">[see <a href="#err-XTDE0835">ERR XTDE0835</a>]</span> in
<a href="#xsl-element"><i>11.2 Creating Element Nodes Using
xsl:element</i></a> .</p>
</div>
<p>The prefix of the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> specified in the
<code>name</code> attribute (or the absence of a prefix) is copied
to the prefix part of the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> representing the name
of the new attribute node. In the event of a conflict this prefix
may subsequently be added, changed, or removed during the namespace
fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>). If the attribute is in a non-null namespace and no
prefix is specified, then the namespace fixup process will invent a
prefix. The term <em>conflict</em> here means any violation of the
constraints defined in <a href="#xpath-datamodel-30">[Data
Model]</a>, for example the use of the same prefix to refer to two
different namespaces in the element and in one of its attributes,
the use of the prefix <code>xml</code> to refer to a namespace
other than the XML namespace, or any use of the prefix
<code>xmlns</code>.</p>
<p>If the name of a constructed attribute is <code>xml:id</code>,
the processor must perform attribute value normalization by
effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup> function
to the value of the attribute, and the resulting attribute node
must be given the <code>is-id</code> property. This applies whether
the attribute is constructed using the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction or
whether it is constructed using an attribute of a literal result
element. This does not imply any constraints on the value of the
attribute, or on its uniqueness, and it does not affect the
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> of the attribute, unless the
containing document is validated.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of setting the <code>is-id</code> property is that
the parent element can be located within the containing document by
use of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
function. In effect, XSLT when constructing a document performs
some of the functions of an <code>xml:id</code> processor, as
defined in <a href="#xml-id">[xml:id]</a>; the other aspects of
<code>xml:id</code> processing are performed during validation.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e28331" id=
"d7e28331"></a>Example: Creating a List-Valued Attribute</div>
<p>The following instruction creates the attribute
<code>colors="red green blue"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28341" id=
"d7e28341"></a>Example: Namespaces are not Attributes</div>
<p>It is not an error to write:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;
</pre></div>
<p>However, this will not result in the namespace declaration
<code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being
output. Instead, it will produce an attribute node with local name
<code>xsl</code>, and with a system-allocated namespace prefix
mapped to the namespace URI <code>file://some.namespace</code>.
This is because the namespace fixup process is not allowed to use
<code>xmlns</code> as the name of a namespace node.</p>
</div>
<p>As described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>, in a sequence that is used to
construct the content of an element, any attribute nodes
<span class="verb">must</span> appear in the sequence before any
element, text, comment, or processing instruction nodes. Where the
sequence contains two or more attribute nodes with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a>, the one that comes last is
the only one that takes effect.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a collection of attributes is generated repeatedly, this can
be done conveniently by using named attribute sets: see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a></p>
</div>
<div class="div3">
<h4><a name="annotation-for-constructed-attribute" id=
"annotation-for-constructed-attribute"></a>11.3.1 <a href=
"#annotation-for-constructed-attribute" style=
"text-decoration: none">Setting the Type Annotation for a
Constructed Attribute Node</a></h4>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction to
invoke validation of the contents of the attribute against a type
definition or attribute declaration in a schema, and to determine
the <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> that the new attribute node
will carry. These two attributes are both optional, and if one is
specified then the other <span class="verb">must</span> be omitted.
The permitted values of these attributes and their semantics are
described in <a href="#validation"><i>24.2 Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> of the attribute in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> also depends on the
<code>type</code> and <code>validation</code> attributes of the
instructions used to create the ancestors of the attribute.</p>
</div>
</div>
<div class="div3">
<h4><a name="xsl-attribute-on-empty" id=
"xsl-attribute-on-empty"></a>11.3.2 <a href=
"#xsl-attribute-on-empty" style="text-decoration: none">Conditional
Creation of Attribute Nodes</a></h4>
<p>If the <code>on-empty</code> attribute is present and the string
value of the constructed attribute is a zero-length string, then
instead of returning the constructed attribute, the instruction
returns the result of evaluating the expression in the
<code>on-empty</code> attribute; <span>if this expression returns a
node, the instruction returns a copy of the node.</span>.</p>
<p><a name="err-XTTE3320" id="err-XTTE3320"><span class=
"error">[ERR XTTE3320]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>on-empty</code> attribute does not satisfy
the required type <code>attribute()?</code>. That is, the
expression must deliver either a single attribute node, or an empty
sequence.</p>
<p>If the <code>on-empty</code> expression is evaluated and returns
an empty sequence, then the <code>validation</code> and
<code>type</code> attributes are ignored. However, if the result of
the <code>on-empty</code> expression is an attribute node, then it
is subjected to validation as determined by these attributes, along
with <code>[xsl:]default-validation</code> where relevant.</p>
</div>
</div>
<div class="div2">
<h3><a name="creating-text-nodes" id="creating-text-nodes"></a>11.4
<a href="#creating-text-nodes" style=
"text-decoration: none">Creating Text Nodes</a></h3>
<p>This section describes three different ways of creating text
nodes: by means of literal text nodes in the stylesheet, or by
using the <a href="#element-text"><code>xsl:text</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a>
instructions. It is also possible to create text nodes using the
<a href="#element-number"><code>xsl:number</code></a> instruction
described in <a href="#number"><i>12 Numbering</i></a>.</p>
<p>If and when the sequence that results from evaluating a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is used to form
the content of a node, as described in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a> and <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, adjacent text nodes in the sequence are merged.
Within the sequence itself, however, they exist as distinct
nodes.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28490" id=
"d7e28490"></a>Example: A Sequence of Text Nodes</div>
<p>The following function returns a sequence of three text
nodes:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>When this function is called as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="f:wrap('---')"/&gt;
</pre></div>
<p>the result is:</p>
<div class="exampleInner">
<pre>
(---)
</pre></div>
<p>No additional spaces are inserted, because the calling <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction
merges adjacent text nodes before atomizing the sequence. However,
the result of the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;
</pre></div>
<p>is:</p>
<div class="exampleInner">
<pre>
( --- )
</pre></div>
<p>because in this case the three text nodes are atomized to form
three strings, and spaces are inserted between adjacent
strings.</p>
</div>
<p>It is possible to construct text nodes whose string value is
zero-length. A zero-length text node, when atomized, produces a
zero-length string. However, zero-length text nodes are ignored
when they appear in a sequence that is used to form the content of
a node, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a> and <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
<div class="div3">
<h4><a name="literal-text-nodes" id="literal-text-nodes"></a>11.4.1
<a href="#literal-text-nodes" style="text-decoration: none">Literal
Text Nodes</a></h4>
<p>A <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> can contain
text nodes. Each text node in a sequence constructor remaining
after <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> have been
stripped as specified in <a href="#stylesheet-stripping"><i>4.2
Stripping Whitespace from the Stylesheet</i></a> will construct a
new text node with the same <a title="string value" class="termref"
href="#dt-string-value">string value</a>. The resulting text node
is added to the result of the containing sequence constructor.</p>
<p>Text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> that contains a <code>&lt;</code> character, which will be
represented by the markup <code>&amp;lt;</code> (or an equivalent
character reference) when the result tree is serialized as an XML
document, unless otherwise specified using <a title="character map"
class="termref" href="#dt-character-map">character maps</a> (see
<a href="#character-maps"><i>25.1 Character Maps</i></a>) or
<code>disable-output-escaping</code> (see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>).</p>
</div>
<div class="div3">
<h4><a name="xsl-text" id="xsl-text"></a>11.4.2 <a href="#xsl-text"
style="text-decoration: none">Creating Text Nodes Using</a>
<code>xsl:text</code> <a href="#xsl-text" style=
"text-decoration: none"></a></h4>
<p class="element-syntax"><a name="element-text" id=
"element-text"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:text<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
&lt;/xsl:text&gt;</code></p>
<p>The <a href="#element-text"><code>xsl:text</code></a> element is
evaluated to construct a new text node. The content of the <a href=
"#element-text"><code>xsl:text</code></a> element is a single text
node whose value forms the <a title="string value" class="termref"
href="#dt-string-value">string value</a> of the new text node. An
<a href="#element-text"><code>xsl:text</code></a> element may be
empty, in which case the result of evaluating the instruction is a
text node whose string value is the zero-length string.</p>
<p>The result of evaluating an <a href=
"#element-text"><code>xsl:text</code></a> instruction is the newly
constructed text node.</p>
<p>A text node that is an immediate child of an <a href=
"#element-text"><code>xsl:text</code></a> instruction will not be
stripped from the stylesheet tree, even if it consists entirely of
whitespace (see <a href="#strip"><i>4.4 Stripping Whitespace from a
Source Tree</i></a>).</p>
<p>For the effect of the <a title="deprecated" class="termref"
href="#dt-deprecated">deprecated</a>
<code>disable-output-escaping</code> attribute, see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not always necessary to use the <a href=
"#element-text"><code>xsl:text</code></a> instruction to write text
nodes to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Literal text can be written to
the result tree by including it anywhere in a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, while computed
text can be output using the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction. The
principal reason for using <a href=
"#element-text"><code>xsl:text</code></a> is that it offers
improved control over whitespace handling.</p>
</div>
</div>
<div class="div3">
<h4><a name="value-of" id="value-of"></a>11.4.3 <a href="#value-of"
style="text-decoration: none">Generating Text with</a> <a href=
"#element-value-of"><code>xsl:value-of</code></a> <a href=
"#value-of" style="text-decoration: none"></a></h4>
<p>Within a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction can
be used to generate computed text nodes. The <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction
computes the text using an <a title="expression" class="termref"
href="#dt-expression">expression</a> that is specified as the value
of the <code>select</code> attribute, or by means of contained
instructions. This might, for example, extract text from a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> or insert the value of a
variable.</p>
<p class="element-syntax"><a name="element-value-of" id=
"element-value-of"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:value-of<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:value-of&gt;</code></p>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is evaluated to construct a new text node; the result
of the instruction is the newly constructed text node.</p>
<p>The string value of the new text node may be defined either by
using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) that
forms the content of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty, then the result of the instruction is a text
node whose string value is zero-length.</span> The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0870" id="err-XTSE0870"><span class=
"error">[ERR XTSE0870]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element is
present when the content of the element is non-empty</p>
<p>If the <code>separator</code> attribute is present, then the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of this attribute is used
to separate adjacent items in the result sequence, as described in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified
using the <code>select</code> attribute, or a zero-length string
when the content is specified using a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><span>Special rules apply when the instruction is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>.</span> If no
<code>separator</code> attribute is present, and if the
<code>select</code> attribute is present, then all items in the
<a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> result sequence other than the first
are ignored.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28759" id=
"d7e28759"></a>Example: Generating a List with Separators</div>
<p>The instruction:</p>
<div class="exampleInner">
<pre>
&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;
</pre></div>
<p>produces the output:</p>
<div class="exampleInner">
<pre>
&lt;x&gt;1|2|3|4&lt;/x&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a>
element can be used to copy a sequence of nodes to the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> without <a title="atomize" class="termref" href=
"#dt-atomization">atomization</a>. See <a href="#copy-of"><i>11.9.2
Deep Copy</i></a>.</p>
</div>
<p>For the effect of the <a title="deprecated" class="termref"
href="#dt-deprecated">deprecated</a>
<code>disable-output-escaping</code> attribute, see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a></p>
</div>
</div>
<div class="div2">
<h3><a name="creating-document-nodes" id=
"creating-document-nodes"></a>11.5 <a href=
"#creating-document-nodes" style="text-decoration: none">Creating
Document Nodes</a></h3>
<p class="element-syntax"><a name="element-document" id=
"element-document"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:document<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:document&gt;</code></p>
<p>The <a href="#element-document"><code>xsl:document</code></a>
instruction is used to create a new document node. The content of
the <a href="#element-document"><code>xsl:document</code></a>
element is a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children of the new document node. A document node is created, and
the sequence obtained by evaluating the sequence constructor is
used to construct the content of the document, as described in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>. The <a title="temporary tree" class=
"termref" href="#dt-temporary-tree">temporary tree</a> rooted at
this document node forms the <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a>.</p>
<p>Except in error situations, the result of evaluating the
<a href="#element-document"><code>xsl:document</code></a>
instruction is a single node, the newly constructed document
node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The new document is not serialized. To construct a document that
is to form a final result rather than an intermediate result, use
the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction described in <a href="#creating-result-trees"><i>24.1
Creating Final Result Trees</i></a>.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-document"><code>xsl:document</code></a> instruction to
validate the contents of the new document, and to determine the
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> that elements and attributes
within the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> will carry. The permitted values
and their semantics are described in <a href=
"#validating-document-nodes"><i>24.2.2 Validating Document
Nodes</i></a>.</p>
<p>The base URI of the new document node is taken from the base URI
of the <a href="#element-document"><code>xsl:document</code></a>
instruction.</p>
<p>The <code>document-uri</code> and <code>unparsed-entities</code>
properties of the new document node are set to empty.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28875" id=
"d7e28875"></a>Example: Checking Uniqueness Constraints in a
Temporary Tree</div>
<p>The following example creates a temporary tree held in a
variable. The use of an enclosed <a href=
"#element-document"><code>xsl:document</code></a> instruction
ensures that uniqueness constraints defined in the schema for the
relevant elements are checked.</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="creating-processing-instructions" id=
"creating-processing-instructions"></a>11.6 <a href=
"#creating-processing-instructions" style=
"text-decoration: none">Creating Processing Instructions</a></h3>
<p class="element-syntax"><a name="element-processing-instruction"
id="element-processing-instruction"></a><code>&lt;!-- Category:
instruction --&gt;<br />
&lt;xsl:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:processing-instruction&gt;</code></p>
<p>The <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is evaluated to create a processing instruction node.</p>
<p>The <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute that specifies the name of the processing instruction
node. The value of the <code>name</code> attribute is interpreted
as an <a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<p>The string value of the new processing-instruction node may be
defined either by using the <code>select</code> attribute, or by
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element. <span>These are mutually exclusive: if the
<code>select</code> attribute is present then the sequence
constructor must be empty, and if the sequence constructor is
non-empty then the <code>select</code> attribute must be absent. If
the <code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
processing-instruction node will be a zero-length string. The way
in which the value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0880" id="err-XTSE0880"><span class=
"error">[ERR XTSE0880]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is present unless the element has empty content.</p>
<p>Except in error situations, the result of evaluating the
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>
instruction is a single node, the newly constructed processing
instruction node.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28965" id=
"d7e28965"></a>Example: Creating a Processing Instruction</div>
<p>This instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;')"/&gt;
</pre></div>
<p>creates the processing instruction</p>
<div class="exampleInner">
<pre>
&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;
</pre></div>
<p>Note that the <code>xml-stylesheet</code> processing instruction
contains <em>pseudo-attributes</em> in the form
<code>name="value"</code>. Although these have the same textual
form as attributes in an element start tag, they are not
represented as XDM attribute nodes, and cannot therefore be
constructed using <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instructions.</p>
</div>
<p><a name="err-XTDE0890" id="err-XTDE0890"><span class=
"error">[ERR XTDE0890]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not both an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
and a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because these rules disallow the name <code>xml</code>, the
<a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
cannot be used to output an XML declaration. The <a href=
"#element-output"><code>xsl:output</code></a> declaration should be
used to control this instead (see <a href="#serialization"><i>25
Serialization</i></a>).</p>
</div>
<p>If the result of evaluating the content of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
contains the string <code>?&gt;</code>, this string is modified by
inserting a space between the <code>?</code> and <code>&gt;</code>
characters.</p>
<p>The base URI of the new processing-instruction is copied from
the base URI of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element in the stylesheet. (Note, however, that this is only
relevant when creating a parentless processing instruction. When
the new processing instruction is copied to form a child of an
element or document node, the base URI of the new copy is taken
from that of its new parent.)</p>
</div>
<div class="div2">
<h3><a name="creating-namespace-nodes" id=
"creating-namespace-nodes"></a>11.7 <a href=
"#creating-namespace-nodes" style="text-decoration: none">Creating
Namespace Nodes</a></h3>
<p class="element-syntax"><a name="element-namespace" id=
"element-namespace"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:namespace<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:namespace&gt;</code></p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
element is evaluated to create a namespace node. Except in error
situations, the result of evaluating the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction is
a single node, the newly constructed namespace node.</p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute that specifies the name of the namespace node (that is,
the namespace prefix). The value of the <code>name</code> attribute
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. If the <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute is a zero-length string, a namespace
node is added for the default namespace.</p>
<p>The string value of the new namespace node (that is, the
namespace URI) may be defined either by using the
<code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent.</span> Since the
string value of a namespace node cannot be a zero-length string,
<span>either a <code>select</code> attribute or a non-empty
sequence constructor <span class="verb">must</span> be
present</span>. The way in which the value is constructed is
specified in <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
<p><a name="err-XTDE0905" id="err-XTDE0905"><span class=
"error">[ERR XTDE0905]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
string value of the new namespace node is not valid in the lexical
space of the datatype <code>xs:anyURI</code>, or if it is the
string <code>http://www.w3.org/2000/xmlns/</code>.</p>
<p><a name="err-XTSE0910" id="err-XTSE0910"><span class=
"error">[ERR XTSE0910]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element is
present when the element has content other than one or more
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, or if the <code>select</code> attribute is absent
when the element has empty content.</p>
<p>Note the restrictions described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a> for the position of a namespace node relative to
other nodes in the node sequence returned by a sequence
constructor.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e29173" id=
"d7e29173"></a>Example: Constructing a QName-Valued Attribute</div>
<p>This literal result element:</p>
<div class="exampleInner">
<pre>
&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;
</pre></div>
<p>would typically cause the output document to contain the
element:</p>
<div class="exampleInner">
<pre>
&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;
</pre></div>
<p>In this case, the element is constructed using a literal result
element, and the namespace
<code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could
therefore have been added to the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> simply by
declaring it as one of the in-scope namespaces in the stylesheet.
In practice, the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction is
more likely to be useful in situations where the element is
constructed using an <a href=
"#element-element"><code>xsl:element</code></a> instruction, which
does not copy all the in-scope namespaces from the stylesheet.</p>
</div>
<p><a name="err-XTDE0920" id="err-XTDE0920"><span class=
"error">[ERR XTDE0920]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is neither a zero-length string nor an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
or if it is <code>xmlns</code>.</p>
<p><a name="err-XTDE0925" id="err-XTDE0925"><span class=
"error">[ERR XTDE0925]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#element-namespace"><code>xsl:namespace</code></a>
instruction generates a namespace node whose name is
<code>xml</code> and whose string value is not
<code>http://www.w3.org/XML/1998/namespace</code>, or a namespace
node whose string value is
<code>http://www.w3.org/XML/1998/namespace</code> and whose name is
not <code>xml</code>.</p>
<p><a name="err-XTDE0930" id="err-XTDE0930"><span class=
"error">[ERR XTDE0930]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
evaluating the <code>select</code> attribute or the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of an <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
results in a zero-length string.</p>
<p>For details of other error conditions that may arise, see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is rarely necessary to use <a href=
"#element-namespace"><code>xsl:namespace</code></a> to create a
namespace node in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>; in most circumstances, the
required namespace nodes will be created automatically, as a
side-effect of writing elements or attributes that use the
namespace. An example where <a href=
"#element-namespace"><code>xsl:namespace</code></a> is needed is a
situation where the required namespace is used only within
attribute values in the result document, not in element or
attribute names; especially where the required namespace prefix or
namespace URI is computed at run-time and is not present in either
the source document or the stylesheet.</p>
<p>Adding a namespace node to the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> will never change
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of any element or attribute
node in the result tree: that is, it will never change the
namespace URI of an element or attribute. It might, however,
constrain the choice of prefixes when namespace fixup is
performed.</p>
<p>Namespace prefixes for element and attribute names are initially
established by the rules of the instruction that creates the
element or attribute node, and in the event of conflicts, they may
be changed by the namespace fixup process described in <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>. The fixup
process ensures that an element has in-scope namespace nodes for
the namespace URIs used in the element name and in its attribute
names, and the serializer will typically use these namespace nodes
to determine the prefix to use in the serialized output. The fixup
process cannot generate namespace nodes that are inconsistent with
those already present in the tree. This means that it is not
possible for the processor to decide the prefix to use for an
element or for any of its attributes until all the namespace nodes
for the element have been added.</p>
<p>If a namespace prefix is mapped to a particular namespace URI
using the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction, or
by using <a href="#element-copy"><code>xsl:copy</code></a> or
<a href="#element-copy-of"><code>xsl:copy-of</code></a> to copy a
namespace node, this prevents the namespace fixup process (and
hence the serializer) from using the same prefix for a different
namespace URI on the same element.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e29314" id=
"d7e29314"></a>Example: Conflicting Namespace Prefixes</div>
<p>Given the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;
</pre></div>
<p>a possible serialization of the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> is:</p>
<div class="exampleInner">
<pre>
&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;
</pre></div>
<p>The processor must invent a namespace prefix for the URI
<code>p.uri</code>; it cannot use the prefix <code>p</code> because
that prefix has been explicitly associated with a different
URI.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
instruction cannot be used to generate a <b>namespace
undeclaration</b> of the form <code>xmlns=""</code> (nor the new
forms of namespace undeclaration permitted in <a href=
"#xml-names11">[Namespaces in XML 1.1]</a>). Namespace
undeclarations are generated automatically by the serializer if
<code>undeclare-prefixes="yes"</code> is specified on <a href=
"#element-output"><code>xsl:output</code></a>, whenever a parent
element has a namespace node for the default namespace prefix, and
a child element has no namespace node for that prefix.</p>
</div>
</div>
<div class="div2">
<h3><a name="creating-comments" id="creating-comments"></a>11.8
<a href="#creating-comments" style="text-decoration: none">Creating
Comments</a></h3>
<p class="element-syntax"><a name="element-comment" id=
"element-comment"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:comment<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:comment&gt;</code></p>
<p>The <a href="#element-comment"><code>xsl:comment</code></a>
element is evaluated to construct a new comment node. Except in
error cases, the result of evaluating the <a href=
"#element-comment"><code>xsl:comment</code></a> instruction is a
single node, the newly constructed comment node.</p>
<p>The string value of the new comment node may be defined either
by using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-comment"><code>xsl:comment</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
comment node will be a zero-length string. The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0940" id="err-XTSE0940"><span class=
"error">[ERR XTSE0940]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-comment"><code>xsl:comment</code></a> element is present
unless the element has empty content.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e29415" id=
"d7e29415"></a>Example: Generating a Comment Node</div>
<p>For example, this</p>
<div class="exampleInner">
<pre>
&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;
</pre></div>
<p>would create the comment</p>
<div class="exampleInner">
<pre>
&lt;!--This file is automatically generated. Do not edit!--&gt;
</pre></div>
</div>
<p>In the generated comment node, the processor <span class=
"verb">must</span> insert a space after any occurrence of
<code>-</code> that is followed by another <code>-</code> or that
ends the comment.</p>
</div>
<div class="div2">
<h3><a name="copying" id="copying"></a>11.9 <a href="#copying"
style="text-decoration: none">Copying Nodes</a></h3>
<div class="div3">
<h4><a name="shallow-copy" id="shallow-copy"></a>11.9.1 <a href=
"#shallow-copy" style="text-decoration: none">Shallow Copy</a></h4>
<p class="element-syntax"><a name="element-copy" id=
"element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:copy<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;copy-namespaces? = "yes" | "no"<br />
&#160;&#160;inherit-namespaces? = "yes" | "no"<br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:copy&gt;</code></p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction provides a way of copying <span>a selected item. The
selected item is the item selected by evaluating the expression in
the <code>select</code> attribute if present, or the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a> otherwise</span>. If the selected item is a node,
evaluating the <a href="#element-copy"><code>xsl:copy</code></a>
instruction constructs a copy of the selected node, and the result
of the <a href="#element-copy"><code>xsl:copy</code></a>
instruction is this newly constructed node. By default, the
namespace nodes of the context node are automatically copied as
well, but the attributes and children of the node are not
automatically copied.</p>
<p>When the <span>selected item</span> is an atomic value <span>or
function item</span>, the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction returns this
value. The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
evaluated, <span>and <span class="verb">must not</span> generate
any <a title="type error" class="termref" href=
"#dt-type-error">type errors</a>.</span></p>
<p>When the <span>selected item</span> is an attribute node, text
node, comment node, processing instruction node, or namespace node,
the <a href="#element-copy"><code>xsl:copy</code></a> instruction
returns a new node that is a copy of the context node. The new node
will have the same node kind, name, and string value as the context
node. In the case of an attribute node, it will also have the same
values for the <code>is-id</code> and <code>is-idrefs</code>
properties. The <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is not
evaluated, <span>and <span class="verb">must not</span> generate
any <a title="type error" class="termref" href=
"#dt-type-error">type errors</a>.</span>.</p>
<p>When the <span>selected item</span> is a document node or
element node, the <a href="#element-copy"><code>xsl:copy</code></a>
instruction returns a new node that has the same node kind and name
as the <span>selected</span> node. The content of the new node is
formed by evaluating the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
contained in the <a href="#element-copy"><code>xsl:copy</code></a>
instruction. <span>If the <code>select</code> attribute is present
then the sequence constructor is evaluated with the selected item
as the <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a>; otherwise it is
evaluated using the context of the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction
unchanged.</span> The sequence obtained by evaluating this sequence
constructor is used (after prepending any attribute nodes or
namespace nodes as described in the following paragraphs) to
construct the content of the document or element node, as described
in <a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>.</p>
<p>If the <code>select</code> expression returns an empty sequence,
the <a href="#element-copy"><code>xsl:copy</code></a> instruction
returns an empty sequence, and the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
evaluated.</p>
<p><a name="err-XTTE3180" id="err-XTTE3180"><span class=
"error">[ERR XTTE3180]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>select</code> expression is a sequence of
more than one item.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>use-attribute-sets</code>
attribute, whose value is a whitespace-separated list of QNames
that identify <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations. This attribute is used only when copying element
nodes. This list is expanded as described in <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a
sequence of attribute nodes. This sequence is prepended to the
sequence produced as a result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>copy-namespaces</code> attribute,
with the value <code>yes</code> or <code>no</code>. The default
value is <code>yes</code>. The attribute is used only when copying
element nodes. If the value is set to <code>yes</code>, or is
omitted, then all the namespace nodes of the source element are
copied as namespace nodes for the result element. These copied
namespace nodes are prepended to the sequence produced as a result
of evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (it is
immaterial whether they come before or after any attribute nodes
produced by expanding the <code>use-attribute-sets</code>
attribute). If the value is set to <code>no</code>, then the
namespace nodes are not copied. However, namespace nodes will still
be added to the result element as <span class=
"verb">required</span> by the namespace fixup process: see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The
default value is <code>yes</code>. The attribute is used only when
copying element nodes. If the value is set to <code>yes</code>, or
is omitted, then the namespace nodes created for the newly
constructed element (whether these were copied from those of the
source node, or generated as a result of namespace fixup) are
copied to the children and descendants of the newly constructed
element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
<p><a name="err-XTTE0950" id="err-XTTE0950"><span class=
"error">[ERR XTTE0950]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> to use the
<a href="#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy
a node that has namespace-sensitive content if the
<code>copy-namespaces</code> attribute has the value
<code>no</code> and its explicit or implicit
<code>validation</code> attribute has the value
<code>preserve</code>. It is also a type error if either of these
instructions (with <code>validation="preserve"</code>) is used to
copy an attribute having namespace-sensitive content, unless the
parent element is also copied. A node has namespace-sensitive
content if its typed value contains an item of type
<code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived
therefrom. The reason this is an error is because the validity of
the content depends on the namespace context being preserved.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When attribute nodes are copied, whether with <a href=
"#element-copy"><code>xsl:copy</code></a> or with <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, the processor does
not automatically copy any associated namespace information. The
namespace used in the attribute name itself will be declared by
virtue of the namespace fixup process (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) when the
attribute is added to an element in the <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>, but if
namespace prefixes are used in the content of the attribute (for
example, if the value of the attribute is an XPath expression) then
it is the responsibility of the stylesheet author to ensure that
suitable namespace nodes are added to the <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>. This can be
achieved by copying the namespace nodes using <a href=
"#element-copy"><code>xsl:copy</code></a>, or by generating them
using <a href=
"#element-namespace"><code>xsl:namespace</code></a>.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction to validate
the contents of an element, attribute or document node against a
type definition, element declaration, or attribute declaration in a
schema, and thus to determine the <a title="type annotation" class=
"termref" href="#dt-annotation">type annotation</a> that the new
copy of an element or attribute node will carry. These attributes
are ignored when copying an item that is not an element, attribute
or document node. When the node being copied is an element or
document node, these attributes also affect the type annotation
carried by any elements and attributes that have the copied element
or document node as an ancestor. These two attributes are both
optional, and if one is specified then the other <span class=
"verb">must</span> be omitted. The permitted values of these
attributes and their semantics are described in <a href=
"#validation"><i>24.2 Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> of the node in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> also depends on the <code>type</code> and
<code>validation</code> attributes of the instructions used to
create the ancestors of the node.</p>
</div>
<p>The base URI of a node is copied, except in the case of an
element node having an <code>xml:base</code> attribute, in which
case the base URI of the new node is taken as the value of the
<code>xml:base</code> attribute, resolved if it is relative against
the base URI of the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction. If the
copied node is subsequently attached as a child to a new element or
document node, the final copy of the node inherits its base URI
from its parent node, unless this is overridden using an
<code>xml:base</code> attribute.</p>
<p>When an <code>xml:id</code> attribute is copied, using either
the <a href="#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction, it is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether the
value of the attribute is subjected to attribute value
normalization (that is, effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup>
function).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In most cases the value will already have been subjected to
attribute value normalization on the source tree, but if this
processing has not been performed on the source tree, it is not an
error for it to be performed on the result tree.</p>
</div>
<div class="div4">
<h5><a name="conditional-copy" id="conditional-copy"></a>11.9.1.1
<a href="#conditional-copy" style=
"text-decoration: none">Conditional Copying of Nodes</a></h5>
<p>The effect of specifying an <code>on-empty</code> attribute is
as follows.</p>
<p>If the result of the instruction in the absence of the
<code>on-empty</code> attribute would be any of the following:</p>
<ul>
<li>
<p>An empty sequence</p>
</li>
<li>
<p>An element or document node having no attributes and no
children</p>
</li>
<li>
<p>A node of any other kind with a zero-length string value</p>
</li>
</ul>
<p>then instead of returning this result, the instruction returns
the result of evaluating the expression in the
<code>on-empty</code> attribute; if the result of this expression
is a node, the instruction returns a copy of this node.</p>
<p><a name="err-XTTE3330" id="err-XTTE3330"><span class=
"error">[ERR XTTE3330]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>on-empty</code> attribute does not satisfy
the required type <code>node()?</code>. That is, the expression
must deliver either a single node, or an empty sequence.</p>
<p>If the <code>on-empty</code> expression is evaluated and returns
an empty sequence, then the <code>validation</code> and
<code>type</code> attributes are ignored. However, if the result of
the <code>on-empty</code> expression is a node, then it is
subjected to validation as determined by these attributes, along
with <code>[xsl:]default-validation</code> where relevant.</p>
</div>
</div>
<div class="div3">
<h4><a name="copy-of" id="copy-of"></a>11.9.2 <a href="#copy-of"
style="text-decoration: none">Deep Copy</a></h4>
<p class="element-syntax"><a name="element-copy-of" id=
"element-copy-of"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:copy-of<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;copy-namespaces? = "yes" | "no"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;/&gt;</code></p>
<p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a>
instruction can be used to construct a copy of a sequence of nodes,
atomic values, <span>and/or function items</span> with each new
node containing copies of all the children, attributes, and (by
default) namespaces of the original node, recursively. The result
of evaluating the instruction is a sequence of items corresponding
one-to-one with the supplied sequence, and retaining its order.</p>
<p>The <span class="verb">required</span> <code>select</code>
attribute contains an <a title="expression" class="termref" href=
"#dt-expression">expression</a>, whose value may be any sequence of
nodes, atomic values, <span>and/or function items</span>. The items
in this sequence are processed as follows:</p>
<ul>
<li>
<p>If the item is an element node, a new element is constructed and
appended to the result sequence. The new element will have the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the original, and it
will have deep copies of the attribute nodes and children of the
element node.</p>
<p>The new element will also have namespace nodes copied from the
original element node, unless they are excluded by specifying
<code>copy-namespaces="no"</code>. If this attribute is omitted, or
takes the value <code>yes</code>, then all the namespace nodes of
the original element are copied to the new element. If it takes the
value <code>no</code>, then none of the namespace nodes are copied:
however, namespace nodes will still be created in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> as <span class="verb">required</span> by the namespace
fixup process: see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>. This attribute affects all elements copied by this
instruction: both elements selected directly by the
<code>select</code> <a title="expression" class="termref" href=
"#dt-expression">expression</a>, and elements that are descendants
of nodes selected by the <code>select</code> expression.</p>
<p>The new element will have the same values of the
<code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code>
properties as the original element.</p>
</li>
<li>
<p>If the item is a document node, the instruction adds a new
document node to the result sequence; the children of this document
node will be one-to-one copies of the children of the original
document node (each copied according to the rules for its own node
kind).</p>
</li>
<li>
<p>If the item is an attribute or namespace node, or a text node, a
comment, or a processing instruction, the same rules apply as with
<a href="#element-copy"><code>xsl:copy</code></a> (see <a href=
"#shallow-copy"><i>11.9.1 Shallow Copy</i></a>).</p>
</li>
<li>
<p>If the item is an atomic value <span>or a function item</span>,
the value is appended to the result sequence, as with <a href=
"#element-sequence"><code>xsl:sequence</code></a>.</p>
</li>
</ul>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to
validate the contents of an element, attribute or document node
against a type definition, element declaration, or attribute
declaration in a schema and thus to determine the <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> that the new copy of an element or attribute node
will carry. These attributes are applied individually to each
element, attribute, and document node that is selected by the
expression in the <code>select</code> attribute. These attributes
are ignored when copying an item that is not an element, attribute
or document node.</p>
<p>The specified <code>type</code> and <code>validation</code>
apply directly only to elements, attributes and document nodes
created as copies of nodes actually selected by the
<code>select</code> expression, they do not apply to nodes that are
implicitly copied because they have selected nodes as an ancestor.
However, these attributes do indirectly affect the <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> carried by such implicitly copied nodes, as a
consequence of the validation process.</p>
<p>These two attributes are both optional, and if one is specified
then the other <span class="verb">must</span> be omitted. The
permitted values of these attributes and their semantics are
described in <a href="#validation"><i>24.2 Validation</i></a>.</p>
<p>Errors may occur when copying namespace-sensitive elements or
attributes using <code>validation="preserve"</code>. <span class=
"error">[see <a href="#err-XTTE0950">ERR XTTE0950</a>]</span>.</p>
<p>The base URI of a node is copied, except in the case of an
element node having an <code>xml:base</code> attribute, in which
case the base URI of the new node is taken as the value of the
<code>xml:base</code> attribute, resolved if it is relative against
the base URI of the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction. If the
copied node is subsequently attached as a child to a new element or
document node, the final copy of the node inherits its base URI
from its parent node, unless this is overridden using an
<code>xml:base</code> attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="constructing-sequences" id=
"constructing-sequences"></a>11.10 <a href=
"#constructing-sequences" style=
"text-decoration: none">Constructing Sequences</a></h3>
<p class="element-syntax"><a name="element-sequence" id=
"element-sequence"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:sequence<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sequence&gt;</code></p>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction may be used within a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> to construct a sequence of nodes, atomic values,
<span>and/or function items</span>. This sequence is returned as
the result of the instruction. Unlike most other instructions,
<a href="#element-sequence"><code>xsl:sequence</code></a> can
return a sequence containing existing nodes, rather than
constructing new nodes. When <a href=
"#element-sequence"><code>xsl:sequence</code></a> is used to select
atomic values <span>or function items</span>, the effect is very
similar to the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction.</p>
<p>The items comprising the result sequence are evaluated either
using the <code>select</code> attribute, or using the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. These are
mutually exclusive; if the instruction has a <code>select</code>
attribute, then it <span class="verb">must</span> have no children
other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions. If
there is no <code>select</code> attribute and no contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the result is
an empty sequence.</p>
<p><a name="err-XTSE3185" id="err-XTSE3185"><span class=
"error">[ERR XTSE3185]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of <a href=
"#element-sequence"><code>xsl:sequence</code></a> is present and
the instruction has children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a>.</p>
<p>Any contained <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions are
ignored by an XSLT 2.0 <span>or 3.0</span> processor, but can be
used to define fallback behavior for an XSLT 1.0 processor running
in forwards compatibility mode.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30140" id=
"d7e30140"></a>Example: Constructing a Sequence of Integers</div>
<p>For example, the following code:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;
</pre></div>
<p>produces the output: <code>37</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30152" id=
"d7e30152"></a>Example: Using <code>xsl:for-each</code> to
Construct a Sequence</div>
<p>The following code constructs a sequence containing the value of
the <code>@price</code> attribute for selected elements (which we
assume to be typed as <code>xs:decimal</code>), or a computed price
for those elements that have no <code>@price</code> attribute. It
then returns the average price:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;
</pre></div>
<p>Note that the existing <code>@price</code> attributes could
equally have been added to the <code>$prices</code> sequence using
<a href="#element-copy-of"><code>xsl:copy-of</code></a> or <a href=
"#element-value-of"><code>xsl:value-of</code></a>. However,
<a href="#element-copy-of"><code>xsl:copy-of</code></a> would
create a copy of the attribute node, which is not needed in this
situation, while <a href=
"#element-value-of"><code>xsl:value-of</code></a> would create a
new text node, which then has to be converted to an
<code>xs:decimal</code>. Using <a href=
"#element-sequence"><code>xsl:sequence</code></a>, which in this
case atomizes the existing attribute node and adds an
<code>xs:decimal</code> atomic value to the result sequence, is a
more direct way of achieving the same result.</p>
<p>This example could alternatively be solved at the XPath
level:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;
</pre></div>
<p>The apparently redundant <code>+</code> operator is there to
atomize the attribute value: the expression on the right hand side
of the <code>/</code> operator must not return a <span>sequence
containing both nodes and non-nodes (atomic values or function
items).</span></p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The main use case for allowing <a href=
"#element-sequence"><code>xsl:sequence</code></a> to contain a
sequence constructor is to allow the instructions within an
<a href="#element-fork"><code>xsl:fork</code></a> element to be
divided into groups.</p>
<p>It can also be used to limit the scope of local variables or of
standard attributes such as
<code>[xsl:]default-collation</code>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="number" id="number"></a>12 <a href="#number" style=
"text-decoration: none">Numbering</a></h2>
<p class="element-syntax"><a name="element-number" id=
"element-number"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:number<br />
&#160;&#160;value? = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;level? = "single" | "multiple" | "any"<br />
&#160;&#160;count? = <var>pattern</var><br />
&#160;&#160;from? = <var>pattern</var><br />
&#160;&#160;format? = { <var>string</var> }<br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;letter-value? = { "alphabetic" | "traditional" }<br />
&#160;&#160;ordinal? = { <var>string</var> }<br />
&#160;&#160;start-at? = { <var>integer</var> }<br />
&#160;&#160;grouping-separator? = { <var>char</var> }<br />
&#160;&#160;grouping-size? = { <var>integer</var>
}&#160;/&gt;</code></p>
<p>The <a href="#element-number"><code>xsl:number</code></a>
instruction is used to create a formatted number. The result of the
instruction is a newly constructed text node containing the
formatted number as its <a title="string value" class="termref"
href="#dt-string-value">string value</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-place-marker" id="dt-place-marker" title="place marker"></a>The
<a href="#element-number"><code>xsl:number</code></a> instruction
performs two tasks: firstly, determining a <b>place marker</b>
(this is a sequence of integers, to allow for hierarchic numbering
schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and
secondly, formatting the place marker for output as a text node in
the result sequence.<span class="definition">]</span> The place
marker to be formatted can either be supplied directly, in the
<code>value</code> attribute, or it can be computed based on the
position of a selected node within the tree that contains it.</p>
<p><a name="err-XTSE0975" id="err-XTSE0975"><span class=
"error">[ERR XTSE0975]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> is present unless the
<code>select</code>, <code>level</code>, <code>count</code>, and
<code>from</code> attributes are all absent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facilities described in this section are specifically
designed to enable the calculation and formatting of section
numbers, paragraph numbers, and the like. For formatting of other
numeric quantities, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function may
be more suitable: see <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number">Section
4.7.2 fn:format-number</a> <sup><small>FO30</small></sup>.</p>
<p>Furthermore, formatting of integers where there is no
requirement to calculate the position of a node in the document can
now be accomplished using the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
which borrows many concepts from the <a href=
"#element-number"><code>xsl:number</code></a> specification.</p>
</div>
<div class="div2">
<h3><a name="formatting-supplied-number" id=
"formatting-supplied-number"></a>12.1 <a href=
"#formatting-supplied-number" style=
"text-decoration: none">Formatting a Supplied Number</a></h3>
<p>The <a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a> to be formatted may be
specified by an expression. The <code>value</code> attribute
contains the <a title="expression" class="termref" href=
"#dt-expression">expression</a>. The value of this expression is
<a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> using the procedure defined in
<a href="#xpath-30">[XPath 3.0]</a>, and each value <var>$V</var>
in the atomized sequence is then converted to the integer value
returned by the XPath expression
<code>xs:integer(round(number($V)))</code>. <span>If the
<code>start-at</code> attribute is present, then its effective
value is converted to an integer and decremented by one, and the
resulting value is added to each integer in the sequence.</span>
The resulting sequence of integers is used as the place marker to
be formatted.</p>
<p>If the instruction is processed with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then:</p>
<ul>
<li>
<p>all items in the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> sequence after the first are
discarded;</p>
</li>
<li>
<p>If the atomized sequence is empty, it is replaced by a sequence
containing the <code>xs:double</code> value <code>NaN</code> as its
only item;</p>
</li>
<li>
<p>If any value in the sequence cannot be converted to an integer
(this includes the case where the sequence contains a
<code>NaN</code> value) then the string <code>NaN</code> is
inserted into the formatted result string in its proper position.
The error described in the following paragraph does not apply in
this case.</p>
</li>
</ul>
<p><a name="err-XTDE0980" id="err-XTDE0980"><span class=
"error">[ERR XTDE0980]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if any
undiscarded item in the atomized sequence supplied as the value of
the <code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> cannot be converted
to an integer, or if the resulting integer is less than 0
(zero).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The value zero does not arise when numbering nodes in a source
document, but it can arise in other numbering sequences. It is
permitted specifically because the rules of the <a href=
"#element-number"><code>xsl:number</code></a> instruction are also
invoked by functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-time"><code>format-time</code></a><sup><small>FO30</small></sup>:
the minutes and seconds component of a time value can legitimately
be zero.</p>
</div>
<p>The resulting sequence is formatted as a string using the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective values</a> of the attributes
specified in <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>; each of these attributes is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>. After
conversion, the <a href=
"#element-number"><code>xsl:number</code></a> element constructs a
new text node containing the resulting string, and returns this
node.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30446" id=
"d7e30446"></a>Example: Numbering a Sorted List</div>
<p>The following example numbers a sorted list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="numbering-based-on-position" id=
"numbering-based-on-position"></a>12.2 <a href=
"#numbering-based-on-position" style=
"text-decoration: none">Numbering based on Position in a
Document</a></h3>
<p>If no <code>value</code> attribute is specified, then the
<a href="#element-number"><code>xsl:number</code></a> instruction
returns a new text node containing a formatted <a title=
"place marker" class="termref" href="#dt-place-marker">place
marker</a> that is based on the position of a selected node within
its containing document. If the <code>select</code> attribute is
present, then the expression contained in the <code>select</code>
attribute is evaluated to determine the selected node. If the
<code>select</code> attribute is omitted, then the selected node is
the <a title="context node" class="termref" href=
"#dt-context-node">context node</a>.</p>
<p><a name="err-XTTE0990" id="err-XTTE0990"><span class=
"error">[ERR XTTE0990]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a href="#element-number"><code>xsl:number</code></a> instruction
is evaluated, with no <code>value</code> or <code>select</code>
attribute, when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
<p><a name="err-XTTE1000" id="err-XTTE1000"><span class=
"error">[ERR XTTE1000]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>select</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
anything other than a single node.</p>
<p><a name="err-XTDE1001" id="err-XTDE1001"><span class=
"error">[ERR XTDE1001]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>start-at</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not in
the lexical space of <code>xs:integer</code>. The error may be
signaled statically if it can be detected statically.</p>
<p>The following attributes control how the selected node is to be
numbered:</p>
<ul>
<li>
<p>The <code>level</code> attribute specifies rules for selecting
the nodes that are taken into account in allocating a number; it
has the values <code>single</code>, <code>multiple</code> or
<code>any</code>. The default is <code>single</code>.</p>
</li>
<li>
<p>The <code>count</code> attribute is a <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a> that specifies which nodes
are to be counted at those levels. If <code>count</code> attribute
is not specified, then it defaults to the pattern that matches any
node with the same node kind as the selected node and, if the
selected node has an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a>, with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the selected node.</p>
</li>
<li>
<p>The <code>from</code> attribute is a <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a> that specifies where
counting starts.</p>
</li>
</ul>
<p>In addition, the attributes specified in <a href=
"#convert"><i>12.3 Number to String Conversion Attributes</i></a>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>
<p>The <a href="#element-number"><code>xsl:number</code></a>
element first constructs a sequence of positive integers using the
<code>level</code>, <code>count</code> and <code>from</code>
attributes. Where <code>level</code> is <code>single</code> or
<code>any</code>, this sequence will either be empty or contain a
single number; where <code>level</code> is <code>multiple</code>,
the sequence may be of any length. The sequence is constructed as
follows:</p>
<p>Let <code>matches-count($node)</code> be a function that returns
true if and only if the given node <code>$node</code> matches the
pattern given in the <code>count</code> attribute, or the implied
pattern (according to the rules given above) if the
<code>count</code> attribute is omitted.</p>
<p>Let <code>matches-from($node)</code> be a function that returns
true if and only if the given node <code>$node</code> matches the
pattern given in the <code>from</code> attribute, or if
<code>$node</code> is the root node of a tree. If the
<code>from</code> attribute is omitted, then the function returns
true if and only if <code>$node</code> is the root node of a
tree.</p>
<p>Let <code>$S</code> be the selected node.</p>
<p>When <code>level="single"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
following expression:</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)][1]</code></p>
<p>(this selects the innermost ancestor-or-self node that matches
the <code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>
<p>(this selects the innermost ancestor-or-self node that matches
the <code>from</code> pattern):</p>
</li>
<li>
<p>Let <code>$AF</code> be the value of:</p>
<p><code>&#160;&#160;&#160;$A[ancestor-or-self::node()[. is
$F]]</code></p>
<p>(this selects $A if it is in the subtree rooted at $F, or the
empty sequence otherwise)</p>
</li>
<li>
<p>If <code>$AF</code> is empty, return the empty sequence,
<code>()</code></p>
</li>
<li>
<p>Otherwise return the value of:</p>
<p><code>&#160;&#160;&#160;1 +
count($AF/preceding-sibling::node()[matches-count(.)])</code></p>
<p>(the number of preceding siblings of the counted node that match
the <code>count</code> pattern, plus one).</p>
</li>
</ul>
<p>When <code>level="multiple"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)]</code></p>
<p>(the set of ancestor-or-self nodes that match the
<code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>
<p>(the innermost ancestor-or-self node that matches the
<code>from</code> pattern)</p>
</li>
<li>
<p>Let <code>$AF</code> be the value of</p>
<p><code>&#160;&#160;&#160;$A[ancestor-or-self::node()[. is
$F]]</code></p>
<p>(the nodes selected in the first step that are in the subtree
rooted at the node selected in the second step)</p>
</li>
<li>
<p>Return the result of the expression</p>
<p><code>&#160;&#160;&#160;for $af in $AF return
1+count($af/preceding-sibling::node()[matches-count(.)])</code></p>
<p>(a sequence of integers containing, for each of these nodes, one
plus the number of preceding siblings that match the
<code>count</code> pattern)</p>
</li>
</ul>
<p>When <code>level="any"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code></p>
<p>(the set of nodes consisting of the selected node together with
all nodes, other than attributes and namespaces, that precede the
selected node in document order, provided that they match the
<code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code></p>
<p>(the last node in document order that matches the
<code>from</code> pattern and that precedes the selected node,
using the same definition)</p>
</li>
<li>
<p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or .
&gt;&gt; $F]</code>.</p>
<p>(the nodes selected in the first step, excluding those that
precede the node selected in the second step)</p>
</li>
<li>
<p>If <code>$AF</code> is empty, return the empty sequence,
<code>()</code></p>
</li>
<li>
<p>Otherwise return the value of the expression
<code>count($AF)</code></p>
</li>
</ul>
<p>The resulting sequence of numbers is referred to as the
<a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a>).</p>
<p>If the <code>start-at</code> attribute is present, then the
effective value of the attribute is converted to an integer and
decremented by one, and the resulting value is added to each number
in the <a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a>.</p>
<p>The sequence of numbers (the is then converted into a string
using the <a title="effective value" class="termref" href=
"#dt-effective-value">effective values</a> of the attributes
specified in <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>; each of these attributes is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>. After
conversion, the resulting string is used to create a text node,
which forms the result of the <a href=
"#element-number"><code>xsl:number</code></a> instruction.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30890" id=
"d7e30890"></a>Example: Numbering the Items in an Ordered
List</div>
<p>The following will number the items in an ordered list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30898" id=
"d7e30898"></a>Example: Multi-Level Numbering</div>
<p>The following two rules will number <code>title</code> elements.
This is intended for a document that contains a sequence of
chapters followed by a sequence of appendices, where both chapters
and appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3. Subsections within a chapter
are numbered 1.1.1, 1.1.2, 1.1.3; subsections within an appendix
are numbered A.1.1, A.1.2, A.1.3.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30908" id=
"d7e30908"></a>Example: Numbering Notes within a Chapter</div>
<p>This example numbers notes sequentially within a chapter,
<span>starting from the number 100:</span> :</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="convert" id="convert"></a>12.3 <a href="#convert"
style="text-decoration: none">Number to String Conversion
Attributes</a></h3>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification is aligned with that of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>
format-integer</code></a><sup><small>FO30</small></sup> function,
but there are differences; for example grouping separators are part
of the primary format token in <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>
format-integer</code></a><sup><small>FO30</small></sup>, but are
indicated by separate attributes in <a href=
"#element-number"><code>xsl:number</code></a>.</p>
</div>
<p>The following attributes are used to control conversion of a
sequence of numbers into a string. The numbers are integers greater
than or equal to 0 (zero). The attributes are all optional.</p>
<p>The main attribute is <code>format</code>. The default value for
the <code>format</code> attribute is <code>1</code>. The
<code>format</code> attribute is split into a sequence of tokens
where each token is a maximal sequence of alphanumeric characters
or a maximal sequence of non-alphanumeric characters.
<em>Alphanumeric</em> means any character that has a Unicode
category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo <span>(see <a href=
"#UNICODE">[UNICODE]</a>)</span>. The alphanumeric tokens
(<em>format tokens</em>) indicate the format to be used for each
number in the sequence; in most cases the format token is the same
as the required representation of the number 1 (one).</p>
<p>Each non-alphanumeric token is either a prefix, a separator, or
a suffix. If there is a non-alphanumeric token but no format token,
then the single non-alphanumeric token is used as both the prefix
and the suffix. The prefix, if it exists, is the non-alphanumeric
token that precedes the first format token: the prefix always
appears exactly once in the constructed string, at the start. The
suffix, if it exists, is the non-alphanumeric token that follows
the last format token: the suffix always appears exactly once in
the constructed string, at the end. All other non-alphanumeric
tokens (those that occur between two format tokens) are
<em>separator tokens</em> and are used to separate numbers in the
sequence.</p>
<p>The <var>n</var>th format token is used to format the
<var>n</var>th number in the sequence. If there are more numbers
than format tokens, then the last format token is used to format
remaining numbers. If there are no format tokens, then a format
token of <code>1</code> is used to format all numbers. Each number
after the first is separated from the preceding number by the
separator token preceding the format token used to format that
number, or, if that is the first format token, then by
<code>.</code> (dot).</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30980" id=
"d7e30980"></a>Example: Formatting a List of Numbers</div>
<p>Given the sequence of numbers <code>5, 13, 7</code> and the
format token <code>A-001(i)</code>, the output will be the string
<code>E-013(vii)</code></p>
</div>
<p>Format tokens are interpreted as follows:</p>
<ul>
<li>
<p>Any token where the last character has a decimal digit value of
1 (as specified in the Unicode character property database,
<span>see <a href="#UNICODE">[UNICODE]</a>)</span>, and the Unicode
value of preceding characters is one less than the Unicode value of
the last character generates a decimal representation of the number
where each number is at least as long as the format token. The
digits used in the decimal representation are the set of digits
containing the digit character used in the format token. Thus, a
format token <code>1</code> generates the sequence <code>0 1 2 ...
10 11 12 ...</code>, and a format token <code>01</code> generates
the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>.
A format token of <code>&amp;#x661;</code> (Arabic-Indic digit one)
generates the sequence <code>١</code> then <code>٢</code> then
<code>٣</code> ...</p>
</li>
<li>
<p>A format token <code>A</code> generates the sequence <code>A B C
... Z AA AB AC...</code>.</p>
</li>
<li>
<p>A format token <code>a</code> generates the sequence <code>a b c
... z aa ab ac...</code>.</p>
</li>
<li>
<p>A format token <code>i</code> generates the sequence <code>i ii
iii iv v vi vii viii ix x ...</code>.</p>
</li>
<li>
<p>A format token <code>I</code> generates the sequence <code>I II
III IV V VI VII VIII IX X ...</code>.</p>
</li>
<li>
<p>A format token <code>w</code> generates numbers written as
lower-case words, for example in English, <code>one two three four
...</code></p>
</li>
<li>
<p>A format token <code>W</code> generates numbers written as
upper-case words, for example in English, <code>ONE TWO THREE FOUR
...</code></p>
</li>
<li>
<p>A format token <code>Ww</code> generates numbers written as
title-case words, for example in English, <code>One Two Three Four
...</code></p>
</li>
<li>
<p>Any other format token indicates a numbering sequence in which
that token represents the number 1 (one) (but see the note below).
It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> which
numbering sequences, additional to those listed above, are
supported. If an implementation does not support a numbering
sequence represented by the given token, it <span class=
"verb">must</span> use a format token of <code>1</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some traditional numbering sequences additional signs are
added to denote that the letters should be interpreted as numbers;
these are not included in the format token. An example, see also
the example below, is classical Greek where a <em>dexia keraia</em>
and sometimes an <em>aristeri keraia</em> is added.</p>
</div>
</li>
</ul>
<p>For all format tokens other than the first kind above (one that
consists of decimal digits), there <span class="verb">may</span> be
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> lower and
upper bounds on the range of numbers that can be formatted using
this format token; indeed, for some numbering sequences there may
be intrinsic limits. For example, the formatting token
<code>&amp;#x2460;</code> (circled digit one) has a range of 1 to
20 imposed by the Unicode character repertoire. For the numbering
sequences described above any upper bound imposed by the
implementation <span class="verb">must not</span> be less than 1000
(one thousand) and any lower bound must not be greater than 1.
Numbers that fall outside this range <span class="verb">must</span>
be formatted using the format token <code>1</code>. The numbering
sequence associated with the format token <code>1</code> has a
lower bound of 0 (zero).</p>
<p>The above expansions of numbering sequences for format tokens
such as <code>a</code> and <code>i</code> are indicative but not
prescriptive. There are various conventions in use for how
alphabetic sequences continue when the alphabet is exhausted, and
differing conventions for how roman numerals are written (for
example, <code>IV</code> versus <code>IIII</code> as the
representation of the number 4). Sometimes alphabetic sequences are
used that omit letters such as <code>i</code> and <code>o</code>.
This specification does not prescribe the detail of any sequence
other than those sequences consisting entirely of decimal
digits.</p>
<p>Many numbering sequences are language-sensitive. This applies
especially to the sequence selected by the tokens <code>w</code>,
<code>W</code> and <code>Ww</code>. It also applies to other
sequences, for example different languages using the Cyrillic
alphabet use different sequences of characters, each starting with
the letter #x410 (Cyrillic capital letter A). In such cases, the
<code>lang</code> attribute specifies which language's conventions
are to be used; it has the same range of values as
<code>xml:lang</code> (see <a href="#REC-xml">[XML 1.0]</a>). If no
<code>lang</code> value is specified, the language that is used is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The set of
languages for which numbering is supported is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. If a
language is requested that is not supported, the processor uses the
language that it would use if the <code>lang</code> attribute were
omitted.</p>
<p>If the optional <code>ordinal</code> attribute is present, and
if its value is not a zero-length string, this indicates a request
to output ordinal numbers rather than cardinal numbers. For
example, in English, the value <code>ordinal="yes"</code> when used
with the format token <code>1</code> outputs the sequence <code>1st
2nd 3rd 4th ...</code>, and when used with the format token
<code>w</code> outputs the sequence <code>first second third fourth
...</code>. In some languages, ordinal numbers vary depending on
the grammatical context, for example they may have different
genders and may decline with the noun that they qualify. In such
cases the value of the <code>ordinal</code> attribute may be used
to indicate the variation of the ordinal number required. The way
in which the variation is indicated will depend on the conventions
of the language. For inflected languages that vary the ending of
the word, the preferred approach is to indicate the required
ending, preceded by a hyphen: for example in German, appropriate
values are <code>-e, -er, -es, -en</code>. It is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> what
combinations of values of the format token, the language, and the
<code>ordinal</code> attribute are supported. If ordinal numbering
is not supported for the combination of the format token, the
language, and the actual value of the <code>ordinal</code>
attribute, the request is ignored and cardinal numbers are
generated instead.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31255" id=
"d7e31255"></a>Example: Ordinal Numbering in Italian</div>
<p>The specification <code>format="1" ordinal="-º"
lang="it"</code>, if supported, should produce the sequence:</p>
<div class="exampleInner">
<pre>
1º 2º 3º 4º ...
</pre></div>
<p>The specification <code>format="Ww" ordinal="-o"
lang="it"</code>, if supported, should produce the sequence:</p>
<div class="exampleInner">
<pre>
Primo Secondo Terzo Quarto Quinto ...
</pre></div>
</div>
<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters. In many languages there are
two commonly used numbering sequences that use letters. One
numbering sequence assigns numeric values to letters in alphabetic
sequence, and the other assigns numeric values to each letter in
some other manner traditional in that language. In English, these
would correspond to the numbering sequences specified by the format
tokens <code>a</code> and <code>i</code>. In some languages, the
first member of each sequence is the same, and so the format token
alone would be ambiguous. A value of <code>alphabetic</code>
specifies the alphabetic sequence; a value of
<code>traditional</code> specifies the other sequence. If the
<code>letter-value</code> attribute is not specified, then it is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> how any
ambiguity is resolved.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations may use <a title="extension attribute" class=
"termref" href="#dt-extension-attribute">extension attributes</a>
on <a href="#element-number"><code>xsl:number</code></a> to provide
additional control over the way in which numbers are formatted.</p>
</div>
<p>The <code>grouping-separator</code> attribute gives the
separator used as a grouping (for example, thousands) separator in
decimal numbering sequences, and the optional
<code>grouping-size</code> specifies the size (normally 3) of the
grouping. For example, <code>grouping-separator=","</code> and
<code>grouping-size="3"</code> would produce numbers of the form
<code>1,000,000</code> while <code>grouping-separator="."</code>
and <code>grouping-size="2"</code> would produce numbers of the
form <code>1.00.00.00</code>. If only one of the
<code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31338" id=
"d7e31338"></a>Example: Format Tokens and the Resulting
Sequences</div>
<p>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system
configuration.</p>
<table border="1" cellpadding="5" summary=
"format tokens for use with xsl:number" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Description</th>
<th align="left" colspan="1" valign="top">Format Token</th>
<th align="left" colspan="1" valign="top">Sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">French cardinal words</td>
<td align="left" valign="top"><code>format="Ww"
lang="fr"</code></td>
<td align="left" valign="top">Un, Deux, Trois, Quatre</td>
</tr>
<tr>
<td align="left" valign="top">German ordinal words</td>
<td align="left" valign="top"><code>format="w" ordinal="-e"
lang="de"</code></td>
<td align="left" valign="top">erste, zweite, dritte, vierte</td>
</tr>
<tr>
<td align="left" valign="top">Katakana numbering</td>
<td align="left" valign="top">
<code>format="&amp;#x30A2;"</code></td>
<td align="left" valign="top">ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ,
ス, セ, ソ, タ, チ, ツ, テ, ト, ナ, ニ, ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム, メ,
モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ, ヰ, ヱ, ヲ, ン</td>
</tr>
<tr>
<td align="left" valign="top">Katakana numbering in iroha
order</td>
<td align="left" valign="top">
<code>format="&amp;#x30A4;"</code></td>
<td align="left" valign="top">イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ,
ワ, カ, ヨ, タ, レ, ソ, ツ, ネ, ナ, ラ, ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ, エ,
テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ, モ, セ, ス</td>
</tr>
<tr>
<td align="left" valign="top">Thai numbering</td>
<td align="left" valign="top">
<code>format="&amp;#x0E51;"</code></td>
<td align="left" valign="top">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑,
๑๒, ๑๓, ๑๔, ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐</td>
</tr>
<tr>
<td align="left" valign="top">Traditional Hebrew numbering</td>
<td align="left" valign="top"><code>format="&amp;#x05D0;"
letter-value="traditional"</code></td>
<td align="left" valign="top">א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב,
יג, יד, טו, טז, יז, יח, יט, כ</td>
</tr>
<tr>
<td align="left" valign="top">Traditional Georgian numbering</td>
<td align="left" valign="top"><code>format="&amp;#x10D0;"
letter-value="traditional"</code></td>
<td align="left" valign="top">ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ,
იგ, იდ, იე, ივ, იზ, იჱ, ით, კ</td>
</tr>
<tr>
<td align="left" valign="top">Classical Greek numbering (see
note)</td>
<td align="left" valign="top"><code>format="&amp;#x03B1;"
letter-value="traditional"</code></td>
<td align="left" valign="top">αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ,
ιʹ, ιαʹ, ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ, κʹ</td>
</tr>
<tr>
<td align="left" valign="top">Old Slavic numbering</td>
<td align="left" valign="top"><code>format="&amp;#x0430;"
letter-value="traditional"</code></td>
<td align="left" valign="top">А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ,
ГӀ, ДӀ, ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К</td>
</tr>
</tbody>
</table>
<p>Note that Classical Greek is an example where the format token
is not the same as the representation of the number 1.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="sorting" id="sorting"></a>13 <a href="#sorting" style=
"text-decoration: none">Sorting</a></h2>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-specification" id="dt-sort-key-specification" title=
"sort key specification"></a>A <b>sort key specification</b> is a
sequence of one or more adjacent <a href=
"#element-sort"><code>xsl:sort</code></a> elements which together
define rules for sorting the items in an input sequence to form a
sorted sequence.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-component" id="dt-sort-key-component" title=
"sort key component"></a>Within a <a title="sort key specification"
class="termref" href="#dt-sort-key-specification">sort key
specification</a>, each <a href=
"#element-sort"><code>xsl:sort</code></a> element defines one
<b>sort key component</b>.<span class="definition">]</span> The
first <a href="#element-sort"><code>xsl:sort</code></a> element
specifies the primary component of the sort key specification, the
second <a href="#element-sort"><code>xsl:sort</code></a> element
specifies the secondary component of the sort key specification,
and so on.</p>
<p>A sort key specification may occur immediately within an
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>, or
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When used within <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, or
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-sort"><code>xsl:sort</code></a> elements must
occur before any other children.</p>
</div>
<div class="div2">
<h3><a name="xsl-sort" id="xsl-sort"></a>13.1 <a href="#xsl-sort"
style="text-decoration: none">The</a> <a href=
"#element-sort"><code>xsl:sort</code></a> <a href="#xsl-sort"
style="text-decoration: none">Element</a></h3>
<p class="element-syntax"><a name="element-sort" id=
"element-sort"></a><code>&lt;xsl:sort<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;stable? = { "yes" | "no" }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sort&gt;</code></p>
<p>The <a href="#element-sort"><code>xsl:sort</code></a> element
defines a <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>. A sort key
component specifies how a <a title="sort key value" class="termref"
href="#dt-sort-key-value">sort key value</a> is to be computed for
each item in the sequence being sorted, and also how two sort key
values are to be compared.</p>
<p>The value of a <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a> is determined
either by its <code>select</code> attribute or by the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. If neither is
present, the default is <code>select="."</code>, which has the
effect of sorting on the actual value of the item if it is an
atomic value, or on the typed-value of the item if it is a node. If
a <code>select</code> attribute is present, its value <span class=
"verb">must</span> be an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a>.</p>
<p><a name="err-XTSE1015" id="err-XTSE1015"><span class=
"error">[ERR XTSE1015]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-sort"><code>xsl:sort</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
<p>Those attributes of the <a href=
"#element-sort"><code>xsl:sort</code></a> elements whose values are
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a> are
evaluated using the same <a title="focus" class="termref" href=
"#dt-focus">focus</a> as is used to evaluate the
<code>select</code> attribute of the containing instruction
(specifically, <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, or
<a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>).</p>
<p>The <code>stable</code> attribute is permitted only on the first
<a href="#element-sort"><code>xsl:sort</code></a> element within a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a></p>
<p><a name="err-XTSE1017" id="err-XTSE1017"><span class=
"error">[ERR XTSE1017]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-sort"><code>xsl:sort</code></a> element other
than the first in a sequence of sibling <a href=
"#element-sort"><code>xsl:sort</code></a> elements has a
<code>stable</code> attribute.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stable" id="dt-stable" title="stable"></a>A <a title=
"sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is said to
be <b>stable</b> if its first <a href=
"#element-sort"><code>xsl:sort</code></a> element has no
<code>stable</code> attribute, or has a <code>stable</code>
attribute whose <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is
<code>yes</code>.<span class="definition">]</span></p>
<div class="div3">
<h4><a name="sorting-process" id="sorting-process"></a>13.1.1
<a href="#sorting-process" style="text-decoration: none">The
Sorting Process</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-sequence" id="dt-initial-sequence" title=
"initial sequence"></a>The sequence to be sorted is referred to as
the <b>initial sequence</b>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sorted-sequence" id="dt-sorted-sequence" title=
"sorted sequence"></a>The sequence after sorting as defined by the
<a href="#element-sort"><code>xsl:sort</code></a> elements is
referred to as the <b>sorted sequence</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-value" id="dt-sort-key-value" title=
"sort key value"></a> For each item in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, a value is computed
for each <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a> within the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>. The value
computed for an item by using the <var>N</var>th sort key component
is referred to as the <var>N</var>th <b>sort key value</b> of that
item.<span class="definition">]</span></p>
<p>The items in the <a title="initial sequence" class="termref"
href="#dt-initial-sequence">initial sequence</a> are ordered into a
<a title="sorted sequence" class="termref" href=
"#dt-sorted-sequence">sorted sequence</a> by comparing their
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a>. The relative position of
two items <var>A</var> and <var>B</var> in the sorted sequence is
determined as follows. The first sort key value of <var>A</var> is
compared with the first sort key value of <var>B</var>, according
to the rules of the first <a title="sort key component" class=
"termref" href="#dt-sort-key-component">sort key component</a>. If,
under these rules, <var>A</var> is less than <var>B</var>, then
<var>A</var> will precede <var>B</var> in the sorted sequence,
unless the <code>order</code> attribute of this <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a> specifies
<code>descending</code>, in which case <var>B</var> will precede
<var>A</var> in the sorted sequence. If, however, the relevant sort
key values compare equal, then the second sort key value of
<var>A</var> is compared with the second sort key value of
<var>B</var>, according to the rules of the second <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>. This continues
until two sort key values are found that compare unequal. If all
the sort key values compare equal, and the <a title=
"sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is
<a title="stable" class="termref" href="#dt-stable">stable</a>,
then <var>A</var> will precede <var>B</var> in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> if and only if <var>A</var> preceded <var>B</var> in
the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>. If all the sort key
values compare equal, and the <a title="sort key specification"
class="termref" href="#dt-sort-key-specification">sort key
specification</a> is not <a title="stable" class="termref" href=
"#dt-stable">stable</a>, then the relative order of <var>A</var>
and <var>B</var> in the <a title="sorted sequence" class="termref"
href="#dt-sorted-sequence">sorted sequence</a> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If two items have equal <a title="sort key value" class=
"termref" href="#dt-sort-key-value">sort key values</a>, and the
sort is <a title="stable" class="termref" href=
"#dt-stable">stable</a>, then their order in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> will be the same as their order in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, regardless of whether
<code>order="descending"</code> was specified on any or all of the
<a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key components</a>.</p>
</div>
<p>The <var>N</var>th sort key value is computed by evaluating
either the <code>select</code> attribute or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of the
<var>N</var>th <a href="#element-sort"><code>xsl:sort</code></a>
element, or the expression <code>.</code> (dot) if neither is
present. This evaluation is done with the <a title="focus" class=
"termref" href="#dt-focus">focus</a> set as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the item in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> whose <a title=
"sort key value" class="termref" href="#dt-sort-key-value">sort key
value</a> is being computed.</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of that
item in the initial sequence.</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the size of the initial
sequence.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As in any other XPath expression, the <a href=
"#func-current"><code>current</code></a> function may be used
within the <code>select</code> expression of <a href=
"#element-sort"><code>xsl:sort</code></a> to refer to the item that
is the context item for the expression as a whole; that is, the
item whose <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key value</a> is being computed.</p>
</div>
<p>The <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are <a title="atomize"
class="termref" href="#dt-atomization">atomized</a>, and are then
compared. The way they are compared depends on their datatype, as
described in the next section.</p>
</div>
<div class="div3">
<h4><a name="comparing-sort-keys" id=
"comparing-sort-keys"></a>13.1.2 <a href="#comparing-sort-keys"
style="text-decoration: none">Comparing Sort Key Values</a></h4>
<p>It is possible to force the system to compare <a title=
"sort key value" class="termref" href="#dt-sort-key-value">sort key
values</a> using the rules for a particular datatype by including a
cast as part of the <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a>. For example,
<code>&lt;xsl:sort select="xs:date(@dob)"/&gt;</code> will force
the attributes to be compared as dates. In the absence of such a
cast, the sort key values are compared using the rules appropriate
to their datatype. Any values of type <code>xs:untypedAtomic</code>
are cast to <code>xs:string</code>.</p>
<p>For backwards compatibility with XSLT 1.0, the
<code>data-type</code> attribute remains available. If this has the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <code>text</code>, the
atomized <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are converted to strings
before being compared. If it has the effective value
<code>number</code>, the atomized sort key values are converted to
doubles before being compared. The conversion is done by using the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string"><code>string</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-number"><code>number</code></a><sup><small>FO30</small></sup>
function as appropriate. <span>If the <code>data-type</code>
attribute has any other <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a>, then this value
<span class="verb">must</span> be a <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a> denoting an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> with a non-absent namespace</span>, and the effect of the
attribute is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<p><a name="err-XTTE1020" id="err-XTTE1020"><span class=
"error">[ERR XTTE1020]</span></a> If any <a title="sort key value"
class="termref" href="#dt-sort-key-value">sort key value</a>, after
<a title="atomize" class="termref" href=
"#dt-atomization">atomization</a> and any type conversion
<span class="verb">required</span> by the <code>data-type</code>
attribute, is a sequence containing more than one item, then the
effect depends on whether the <a href=
"#element-sort"><code>xsl:sort</code></a> element <span>is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0
behavior,</span> the effective sort key value is the first item in
the sequence. In other cases, this is a <a title="type error"
class="termref" href="#dt-type-error">type error</a>.</p>
<p>The set of <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> (after any conversion) is
first divided into two categories: empty values, and ordinary
values. The empty sort key values represent those items where the
sort key value is an empty sequence. These values are considered
for sorting purposes to be equal to each other, but less than any
other value. The remaining values are classified as ordinary
values.</p>
<p><a name="err-XTDE1030" id="err-XTDE1030"><span class=
"error">[ERR XTDE1030]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if, for
any <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>, the set of
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> evaluated for all the
items in the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, after any type
conversion requested, contains a pair of ordinary values for which
the result of the XPath <code>lt</code> operator is an error.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above error condition may occur if the values to be sorted
are of a type that does not support ordering (for example,
<code>xs:QName</code>) or if the sequence is heterogeneous (for
example, if it contains both strings and numbers). The error can
generally be prevented by invoking a cast or constructor function
within the sort key component.</p>
<p>The error condition is subject to the usual caveat that a
processor is not required to evaluate any expression solely in
order to determine whether it raises an error. For example, if
there are several sort key components, then a processor is not
required to evaluate or compare minor sort key values unless the
corresponding major sort key values are equal.</p>
</div>
<p>In general, comparison of two ordinary values is performed
according to the rules of the XPath <code>lt</code> operator. To
ensure a total ordering, the same implementation of the
<code>lt</code> operator <span class="verb">must</span> be used for
all the comparisons: the one that is chosen is the one appropriate
to the most specific type to which all the values can be converted
by subtype substitution and/or type promotion. For example, if the
sequence contains both <code>xs:decimal</code> and
<code>xs:double</code> values, then the values are compared using
<code>xs:double</code> comparison, even when comparing two
<code>xs:decimal</code> values. NaN values, for sorting purposes,
are considered to be equal to each other, and less than any other
numeric value. Special rules also apply to the
<code>xs:string</code> and <code>xs:anyURI</code> types, and types
derived by restriction therefrom, as described in the next
section.</p>
</div>
<div class="div3">
<h4><a name="collating-sequences" id=
"collating-sequences"></a>13.1.3 <a href="#collating-sequences"
style="text-decoration: none">Sorting Using Collations</a></h4>
<p>The rules given in this section apply when comparing values
whose type is <code>xs:string</code> or a type derived by
restriction from <code>xs:string</code>, or whose type is
<code>xs:anyURI</code> or a type derived by restriction from
<code>xs:anyURI</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-collation" id="dt-collation" title="collation"></a>Facilities
in XSLT <span>3.0</span> and XPath <span>3.0</span> that require
strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them is to be
sorted before the other.<span class="definition">]</span> A
collation is identified by a URI, but the manner in which this URI
is associated with an actual rule or algorithm is largely <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>For more information about collations, see <a href=
"http://www.w3.org/TR/xpath-functions-30/#string-compare">Section
5.3 Comparison of strings</a> <sup><small>FO30</small></sup> in
<a href="#xpath-functions-30">[Functions and Operators]</a>. Some
specifications, for example <a href="#UNICODE-TR10">[UNICODE
TR10]</a>, use the term "collation" to describe rules that can be
tailored or parameterized for various purposes. In this
specification, a collation URI refers to a collation in which all
such parameters have already been fixed. Therefore, if a collation
URI is specified, other attributes such as <code>case-order</code>
and <code>lang</code> are ignored.</p>
<p>Every implementation must recognize the collation URI that
<span class="verb">must</span>
<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>,
which provides the ability to compare strings based on the Unicode
codepoint values of the characters in the string.</p>
<p>Furthermore, every imlementation must recognize collation URIs
representing tailorings of the Unicode Collation Algorithm (UCA),
as described in <a href="#uca-collations"><i>13.4 The Unicode
Collation Algorithm</i></a>. Although this form of collation URI
must be recognized, implementations are not required to support
every possible tailoring.</p>
<p>If the <a href="#element-sort"><code>xsl:sort</code></a> element
has a <code>collation</code> attribute, then the strings are
compared according to the rules for the named <a title="collation"
class="termref" href="#dt-collation">collation</a>: that is, they
are compared using the XPath function call <code>compare($a, $b,
$collation)</code>.</p>
<p>If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>collation</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a> is a relative URI, then
it is resolved against the base URI of the <a href=
"#element-sort"><code>xsl:sort</code></a> element.</p>
<p><a name="err-XTDE1035" id="err-XTDE1035"><span class=
"error">[ERR XTDE1035]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<code>collation</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a> (after resolving against
the base URI) is not a URI that is recognized by the implementation
as referring to a collation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is entirely for the implementation to determine whether it
recognizes a particular collation URI. For example, if the
implementation allows collation URIs to contain parameters in the
query part of the URI, it is the implementation that determines
whether a URI containing an unknown or invalid parameter is or is
not a recognized collation URI. The fact that this situation is
described as an error thus does not prevent an implementation
applying a fallback collation if it chooses to do so.</p>
</div>
<p>The <code>lang</code> and <code>case-order</code> attributes are
ignored if a <code>collation</code> attribute is present. But in
the absence of a <code>collation</code> attribute, these attributes
provide input to an <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> algorithm
to locate a suitable collation:</p>
<ul>
<li>
<p>The <code>lang</code> attribute indicates that a collation
suitable for a particular natural language <span class=
"verb">should</span> be used. The <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a> of the
attribute <span class="verb">must</span> be a value that would be
valid for the <code>xml:lang</code> attribute (see <a href=
"#REC-xml">[XML 1.0]</a>).</p>
</li>
<li>
<p>The <code>case-order</code> attribute indicates whether the
desired collation <span class="verb">should</span> sort upper-case
letters before lower-case or vice versa. The <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
<span class="verb">must</span> be either <code>lower-first</code>
(indicating that lower-case letters precede upper-case letters in
the collating sequence) or <code>upper-first</code> (indicating
that upper-case letters precede lower-case).</p>
<p>When <code>lower-first</code> is requested, the returned
collation <span class="verb">should</span> have the property that
when two strings differ only in the case of one or more characters,
then a string in which the first differing character is lower-case
should precede a string in which the corresponding character is
title-case, which should in turn precede a string in which the
corresponding character is upper-case. When upper-first is
requested, the returned collation <span class="verb">should</span>
have the property that when two strings differ only in the case of
one or more characters, then a string in which the first differing
character is upper-case should precede a string in which the
corresponding character is title-case, which should in turn precede
a string in which the corresponding character is lower-case.</p>
<p>So, for example, if <code>lang="en"</code>, then <code>A a B
b</code> are sorted with <code>case-order="upper-first"</code> and
<code>a A b B</code> are sorted with
<code>case-order="lower-first"</code>.</p>
<p>As a further example, if lower-first is requested, then a sorted
sequence might be "MacAndrew, macintosh, macIntosh, Macintosh,
MacIntosh, macintoshes, Macintoshes, McIntosh". If upper-first is
requested, the same sequence would sort as "MacAndrew, MacIntosh,
Macintosh, macIntosh, macintosh, MacIntoshes, macintoshes,
McIntosh".</p>
</li>
</ul>
<p>If none of the <code>collation</code>, <code>lang</code>, or
<code>case-order</code> attributes is present, the collation is
chosen in an <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a> way.
It is not <span class="verb">required</span> that the default
collation for sorting should be the same as the <a title=
"default collation" class="termref" href=
"#dt-default-collation">default collation</a> used when evaluating
XPath expressions, as described in <a href=
"#static-context"><i>5.4.1 Initializing the Static Context</i></a>
and <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is usually appropriate, when sorting, to use a strong
collation, that is, one that takes account of secondary differences
(accents) and tertiary differences (case) between strings that are
otherwise equal. A weak collation, which ignores such differences,
may be more suitable when comparing strings for equality.</p>
<p>Useful background information on international sorting is
provided in <a href="#UNICODE-TR10">[UNICODE TR10]</a>. The
<code>case-order</code> attribute may be interpreted as described
in section 6.6 of <a href="#UNICODE-TR10">[UNICODE TR10]</a>.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="creating-sorted-sequence" id=
"creating-sorted-sequence"></a>13.2 <a href=
"#creating-sorted-sequence" style="text-decoration: none">Creating
a Sorted Sequence</a></h3>
<p class="element-syntax"><a name="element-perform-sort" id=
"element-perform-sort"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:perform-sort<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:perform-sort&gt;</code></p>
<p>The <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction is used to return a <a title="sorted sequence" class=
"termref" href="#dt-sorted-sequence">sorted sequence</a>.</p>
<p>The <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> is obtained either by
evaluating the <code>select</code> attribute or by evaluating the
contained sequence constructor (but not both). If there is no
<code>select</code> attribute and no sequence constructor then the
<a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> (and therefore, the
<a title="sorted sequence" class="termref" href=
"#dt-sorted-sequence">sorted sequence</a>) is an empty
sequence.</p>
<p><a name="err-XTSE1040" id="err-XTSE1040"><span class=
"error">[ERR XTSE1040]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction with a <code>select</code> attribute has any content
other than <a href="#element-sort"><code>xsl:sort</code></a> and
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
<p>The result of the <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction is the result of sorting its <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> using its contained
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32422" id=
"d7e32422"></a>Example: Sorting a Sequence of Atomic Values</div>
<p>The following stylesheet function sorts a sequence of atomic
values using the value itself as the sort key.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32429" id=
"d7e32429"></a>Example: Writing a Function to Perform a Sort</div>
<p>The following example defines a function that sorts books by
price, and uses this function to output the five books that have
the lowest prices:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="sorted-iteration" id="sorted-iteration"></a>13.3
<a href="#sorted-iteration" style=
"text-decoration: none">Processing a Sequence in Sorted
Order</a></h3>
<p>When used within <a href=
"#element-for-each"><code>xsl:for-each</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>, a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> indicates
that the sequence of items selected by that instruction is to be
processed in sorted order, not in the order of the supplied
sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32450" id=
"d7e32450"></a>Example: Processing Elements in Sorted Order</div>
<p>For example, suppose an employee database has the form</p>
<div class="exampleInner">
<pre>
&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</pre></div>
<p>Then a list of employees sorted by name could be generated
using:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>When used within <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> indicates
the order in which the groups are to be processed. For the effect
of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, see
<a href="#grouping"><i>14 Grouping</i></a>.</p>
</div>
<div class="div2">
<h3><a name="uca-collations" id="uca-collations"></a>13.4 <a href=
"#uca-collations" style="text-decoration: none">The Unicode
Collation Algorithm</a></h3>
<p>XSLT 3.0 defines a family of collation URIs representing
tailorings of the Unicode Collation Algorithm (UCA) as defined in
<a href="#UNICODE-TR10">[UNICODE TR10]</a>. The parameters used for
tailoring the UCA are based on the parameters defined in the Locale
Data Markup Language (LDML), defined in <a href=
"#UNICODE-TR35">[UNICODE TR35]</a>.</p>
<p>This family of URIs use the scheme and path
<code>http://www.w3.org/2013/collation/UCA</code> followed by an
optional query part. The query part, if present, consists of a
question mark followed by a sequence of zero or more
semicolon-separated parameters. Each parameter is a keyword-value
pair, the keyword and value being separated by an equals sign.</p>
<p>All implementations must recognize URIs in this family. This
applies to all places where collations are used, including (for
example) the <a href="#element-sort"><code>xsl:sort</code></a>,
<a href="#element-key"><code>xsl:key</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, and
<a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements, the <code>[xsl:]default-collation</code> attribute, and
the <code>collation</code> argument of <a title="core function"
class="termref" href="#dt-core-function">core functions</a>. If the
<code>fallback</code> parameter is present with the value
<code>no</code>, then the implementation <span class=
"verb">must</span> either use a collation that conforms with the
rules in the Unicode specifications for the requested tailoring, or
fail with a static or dynamic error indicating that it does not
provide the collation (the error code should be the same as if the
collation URI were not recognized). If the <code>fallback</code>
parameter is omitted or takes the value <code>yes</code>, and if
the collation URI is well-formed according to the rules in this
section, then the implementation <span class="verb">must</span>
accept the collation URI, and <span class="verb">should</span> use
the available collation that most closely reflects the user's
intentions. For example, if the collation URI requested is
<code>http://www.w3.org/2013/collation/UCA?lang=se;fallback=yes</code>
and the implementation does not include a fully conformant version
of the UCA tailored for Swedish, then it <span class=
"verb">may</span> choose to use a Swedish collation that is known
to differ from the UCA definition, or one whose conformance has not
been established. It might even, as a last resort, fall back to
using codepoint collation.</p>
<p>If two query parameters use the same keyword then the last one
wins. If a query parameter uses a keyword or value which is not
defined in this specification then the meaning is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. If the
implementation recognizes the meaning of the keyword and value then
it <span class="verb">should</span> interpret it accordingly; if it
does not recognize the keyword or value then if the
<code>fallback</code> parameter is present with the value
<code>no</code> it should reject the collation as unsupported,
otherwise it should ignore the unrecognized parameter.</p>
<p>The following query parameters are defined. If any parameter is
absent, the default is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> except
where otherwise stated. The meaning given for each parameter is
non-normative; the normative specification is found in <a href=
"#UNICODE-TR35">[UNICODE TR35]</a>.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Keyword</th>
<th colspan="1" align="left" valign="top">Values</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">fallback</td>
<td align="left" valign="top">yes | no (default yes)</td>
<td align="left" valign="top">Determines whether the processor uses
a fallback collation if a conformant collation is not
available.</td>
</tr>
<tr>
<td align="left" valign="top">lang</td>
<td align="left" valign="top">language code, as defined for the
<code>lang</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a></td>
<td align="left" valign="top">The language whose collation
conventions are to be used.</td>
</tr>
<tr>
<td align="left" valign="top">version</td>
<td align="left" valign="top">string</td>
<td align="left" valign="top">The version number of the UCA to be
used.</td>
</tr>
<tr>
<td align="left" valign="top">strength</td>
<td align="left" valign="top">primary | secondary | tertiary |
quaternary | identical, or 1|2|3|4|5 as synonyms</td>
<td align="left" valign="top">The collation strength as defined in
UCA. Primary strength takes only the base form of the characater
into account (so A=a=Â=â); secondary strength ignores case but
considers accents and diacritics as significant (so A=a and Â=â but
â!=a); tertiary considers case as significant (A!=a!=Â!=â);
quaternary considers spaces and punctuation that would otherwise be
ignored (for example
<code>data-base</code>=<code>database</code>).</td>
</tr>
<tr>
<td align="left" valign="top">alternate</td>
<td align="left" valign="top">non-ignorable | shifted |
blanked</td>
<td align="left" valign="top">Controls the effect of characters
such as spaces and hyphens.</td>
</tr>
<tr>
<td align="left" valign="top">backwards</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">The value <code>backwards=yes</code>
indicates that the last accent in the search term is the most
significant.</td>
</tr>
<tr>
<td align="left" valign="top">normalization</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">Indicates whether search terms are
converted to normalization form D.</td>
</tr>
<tr>
<td align="left" valign="top">caseLevel</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">When used with primary strength,
setting <code>caseLevel=yes</code> has the effect of ignoring
accents while taking account of case.</td>
</tr>
<tr>
<td align="left" valign="top">caseFirst</td>
<td align="left" valign="top">upper | lower</td>
<td align="left" valign="top">Indicates whether upper-case precedes
lower-case or vice versa.</td>
</tr>
<tr>
<td align="left" valign="top">hiraganaQuaternary</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">Controls special treatment of
Hiragana codepoints when strength is quaternary or greater.</td>
</tr>
<tr>
<td align="left" valign="top">numeric</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">When <code>numeric=yes</code> is
specified, a sequence of consecutive digits is interpreted as a
number, for example <code>chap2</code> sorts before
<code>chap12</code>.</td>
</tr>
<tr>
<td align="left" valign="top">reorder</td>
<td align="left" valign="top">a comma-separated sequence of reorder
codes, where a reorder code is one of <code>space</code>,
<code>punct</code>, <code>symbol</code>, <code>currency</code>,
<code>digit</code>, or a four-letter script code defined in
<a href="#ISO15924_register">[ISO 15924 Register]</a>, the register
of scripts maintained by the Unicode Consortium in its capacity as
registration authority for <a href="#ISO15924">[ISO
15924]</a>.</td>
<td align="left" valign="top">Determines the relative ordering of
text in different scripts; for example the value
<code>digit,Grek,Latn</code> indicates that digits precede Greek
letters, which precede Latin letters.</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This list excludes parameters that are inconvenient to express
in a URI, or that are applicable only to substring matching.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="grouping" id="grouping"></a>14 <a href="#grouping"
style="text-decoration: none">Grouping</a></h2>
<p>The facilities described in this section are designed to allow
items in a sequence to be grouped based on common values; for
example it allows grouping of elements having the same value for a
particular attribute, or elements with the same name, or elements
with common values for any other <a title="expression" class=
"termref" href="#dt-expression">expression</a>. Since grouping
identifies items with duplicate values, the same facilities also
allow selection of the distinct values in a sequence of items, that
is, the elimination of duplicates.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Simple elimination of duplicates can also be achieved using the
function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>
distinct-values</code></a><sup><small>FO30</small></sup> in the
<a title="core function" class="termref" href=
"#dt-core-function">core function</a> library: see <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
</div>
<p>In addition these facilities allow grouping based on sequential
position, for example selecting groups of adjacent
<code>para</code> elements. The facilities also provide an easy way
to do fixed-size grouping, for example identifying groups of three
adjacent nodes, which is useful when arranging data in multiple
columns.</p>
<p>For each group of items identified, it is possible to evaluate a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the group.
Grouping is nestable to multiple levels so that groups of distinct
items can be identified, then from among the distinct groups
selected, further sub-grouping of distinct items in the current
group can be done.</p>
<p>It is also possible for one item to participate in more than one
group.</p>
<div class="div2">
<h3><a name="xsl-for-each-group" id="xsl-for-each-group"></a>14.1
<a href="#xsl-for-each-group" style="text-decoration: none">The</a>
<code>xsl:for-each-group</code> <a href="#xsl-for-each-group"
style="text-decoration: none">Element</a></h3>
<p class="element-syntax"><a name="element-for-each-group" id=
"element-for-each-group"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:for-each-group<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;group-by? = <var>expression</var><br />
&#160;&#160;group-adjacent? = <var>expression</var><br />
&#160;&#160;group-starting-with? = <var>pattern</var><br />
&#160;&#160;group-ending-with? = <var>pattern</var><br />
&#160;&#160;bind-group? = <var>eqname</var><br />
&#160;&#160;bind-grouping-key? = <var>eqname</var><br />
&#160;&#160;composite? = "yes" | "no"<br />
&#160;&#160;collation? = { <var>uri</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each-group&gt;</code></p>
<p>This element is an <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> that may be used anywhere within
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-group" id="dt-group" title="group"></a>The <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction allocates the items in an input sequence into
<b>groups</b> of items (that is, it establishes a collection of
sequences) based either on common values of a grouping key, or on a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
that the initial or final <span>item</span> in a group must
match.<span class="definition">]</span> The <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is evaluated once for each of these groups.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-population" id="dt-population" title="population"></a>The
sequence of items to be grouped, which is referred to as the
<b>population</b>, is determined by evaluating the XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
contained in the <code>select</code> attribute.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-population-order" id="dt-population-order" title=
"population order"></a>The population is treated as a sequence; the
order of items in this sequence is referred to as <b>population
order</b> <span class="definition">]</span>.</p>
<p>A group is never empty. If the population is empty, the number
of groups will be zero.</p>
<p>The assignment of items to groups depends on the
<code>group-by</code>, <code>group-adjacent</code>,
<code>group-starting-with</code>, and
<code>group-ending-with</code> attributes.</p>
<p><a name="err-XTSE1080" id="err-XTSE1080"><span class=
"error">[ERR XTSE1080]</span></a> These four attributes are
mutually exclusive: it is a <a title="static error" class="termref"
href="#dt-static-error">static error</a> if none of these four
attributes is present or if more than one of them is present.</p>
<p><a name="err-XTSE1090" id="err-XTSE1090"><span class=
"error">[ERR XTSE1090]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> to specify
the <code>collation</code> attribute <span>or the
<code>composite</code> attribute</span> if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code>
attribute is specified.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-grouping-key" id="dt-grouping-key" title="grouping key"></a>If
either of the <code>group-by</code> or <code>group-adjacent</code>
attributes is present, then for each item in the <a title=
"population" class="termref" href="#dt-population">population</a> a
set of <b>grouping keys</b> is calculated, as follows: the
expression contained in the <code>group-by</code> or
<code>group-adjacent</code> attribute is evaluated; the result is
atomized; and any <code>xs:untypedAtomic</code> values are cast to
<code>xs:string</code>. <span>If <code>composite="yes"</code> is
specified, there is a single grouping key whose value is the
resulting sequence; otherwise, there is a set of grouping keys,
consisting of the distinct atomic values present in the result
sequence.</span> <span class="definition">]</span></p>
<p>When calculating grouping keys for an item in the population,
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in the
<code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated with that item as the <a title="context item" class=
"termref" href="#dt-context-item">context item</a>, with its
position in <a title="population order" class="termref" href=
"#dt-population-order">population order</a> as the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a>, and with the size of
the population as the <a title="context size" class="termref" href=
"#dt-context-size">context size</a>.</p>
<p>If the <code>group-by</code> attribute is present, <span>and if
the <code>composite</code> attribute is omitted or takes the value
<code>no</code>,</span> then an item in the population <span class=
"verb">may</span> have multiple grouping keys: that is, the
<code>group-by</code> expression evaluates to a sequence<span>, and
each item in the sequence is treated as a separate grouping
key.</span> The item is included in as many groups as there are
distinct grouping keys (which may be zero).</p>
<p>f the <code>group-adjacent</code> attribute is used, <span>and
if the <code>composite</code> attribute is omitted or takes the
value <code>no</code>,</span> then each item in the population
<span class="verb">must</span> have exactly one grouping key
value.</p>
<p><a name="err-XTTE1100" id="err-XTTE1100"><span class=
"error">[ERR XTTE1100]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>group-adjacent</code> expression is an
empty sequence or a sequence containing more than one item,
<span>unless <code>composite="yes"</code> is specified.</span></p>
<p><a title="grouping key" class="termref" href=
"#dt-grouping-key">Grouping keys</a> are compared using the rules
for the <span><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function. This means that values of type
<code>xs:untypedAtomic</code> will be cast to
<code>xs:string</code> before the comparison, and that items that
are not comparable using the <code>eq</code> operator are
considered to be not equal, that is, they are allocated to
different groups. It also means that the value <code>NaN</code> is
considered equal to itself.</span> If the values are strings, or
untyped atomic values, then if there is a <code>collation</code>
attribute the values are compared using the collation specified as
the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>collation</code> attribute, resolved if relative against the
base URI of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. If there is no <code>collation</code> attribute then the
<a title="default collation" class="termref" href=
"#dt-default-collation">default collation</a> is used.</p>
<p><a name="err-XTDE1110" id="err-XTDE1110"><span class=
"error">[ERR XTDE1110]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
collation URI specified to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
(after resolving against the base URI) is a collation that is not
recognized by the implementation. (For notes, <span class=
"error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
<p>For more information on collations, see <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>.</p>
<p>The way in which an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element is evaluated depends on which of the four group-defining
attributes is present:</p>
<ul>
<li>
<p>If the <code>group-by</code> attribute is present, the items in
the <a title="population" class="termref" href=
"#dt-population">population</a> are examined, in population order.
For each item <var>J</var>, the expression in the
<code>group-by</code> attribute is evaluated to produce a sequence
of zero or more <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> values. <span>If
<code>composite="yes"</code> is specified, there will be a single
grouping key, which will in general be a sequence of zero or more
atomic values; otherwise, there will be zero or more grouping keys,
each of which will be a single atomic value.</span> For each one of
these <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a>, if there is already a group
created to hold items having that grouping key value, <var>J</var>
is <span>appended</span> to that group; otherwise a new group is
created for items with that grouping key value, and <var>J</var>
becomes its first member.</p>
<p>An item in the population may thus be <span>appended</span> to
zero, one, or many groups. An item will never be
<span>appended</span> more than once to the same group; if two or
more grouping keys for the same item are equal, then the duplicates
are ignored. An <em>item</em> here means the item at a particular
position within the population—if the population contains the same
node at several different positions in the sequence then a group
may indeed contain duplicate nodes.</p>
<p>The number of groups will be the same as the number of distinct
grouping key values present in the <a title="population" class=
"termref" href="#dt-population">population</a>.</p>
<p>If the population contains values of different numeric types
that differ from each other by small amounts, then the
<code>eq</code> operator is not transitive, because of rounding
effects occurring during type promotion. The effect of this is
described in <a href="#non-transitivity"><i>14.5
Non-Transitivity</i></a>.</p>
</li>
<li>
<p>If the <code>group-adjacent</code> attribute is present, the
items in the <a title="population" class="termref" href=
"#dt-population">population</a> are examined, in population order.
If an item has the same value for the <a title="grouping key"
class="termref" href="#dt-grouping-key">grouping key</a> as its
preceding item within the <a title="population" class="termref"
href="#dt-population">population</a> (in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a>), then it is
<span>appended</span> to the same group as its preceding item;
otherwise a new group is created and the item becomes its first
member.</p>
</li>
<li>
<p>If the <code>group-starting-with</code> attribute is present,
then its value <span class="verb">must</span> be a <a href=
"#doc-xslt30-patterns-Pattern30">pattern</a>.</p>
<p>The <span>items</span> in the <a title="population" class=
"termref" href="#dt-population">population</a> are examined in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a>. If an
<span>item</span> matches the pattern, or is the first
<span>item</span> in the population, then a new group is created
and the <span>item</span> becomes its first member. Otherwise, the
<span>item</span> is <span>appended</span> to the same group as its
preceding <span>item</span> within the population.</p>
</li>
<li>
<p>If the <code>group-ending-with</code> attribute is present, then
its value <span class="verb">must</span> be a <a href=
"#doc-xslt30-patterns-Pattern30">pattern</a>.</p>
<p>The <span>items</span> in the <a title="population" class=
"termref" href="#dt-population">population</a> are examined in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a>. If an
<span>item</span> is the first <span>item</span> in the population,
or if the previous <span>item</span> in the population matches the
pattern, then a new group is created and the <span>item</span>
becomes its first member. Otherwise, the <span>item</span> is
<span>appended</span> to the same group as its preceding
<span>item</span> within the population.</p>
</li>
</ul>
<p>In all cases the order of items within each group is
predictable, and reflects the original <a title="population order"
class="termref" href="#dt-population-order">population order</a>,
in that the items are processed in population order and each item
is appended at the end of zero or more groups.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As always, a different algorithm may be used if it achieves the
same effect.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-item" id="dt-initial-item" title="initial item"></a>For
each <a title="group" class="termref" href="#dt-group">group</a>,
the item within the group that is first in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a> is known as the
<b>initial item</b> of the group.<span class=
"definition">]</span></p>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element is evaluated once for each of the <a title="group" class=
"termref" href="#dt-group">groups</a>, in <a title=
"processing order" class="termref" href=
"#dt-processing-order">processing order</a>. The sequences that
result are concatenated, in <a title="processing order" class=
"termref" href="#dt-processing-order">processing order</a>, to form
the result of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. Within the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the <a title="initial item"
class="termref" href="#dt-initial-item">initial item</a> of the
relevant group, the <a title="context position" class="termref"
href="#dt-context-position">context position</a> is the position of
this <span>group in the <a title="processing order" class="termref"
href="#dt-processing-order">processing order</a> of the
groups</span>, and the <a title="context size" class="termref"
href="#dt-context-size">context size</a> is the number of groups
This has the effect that within the <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>, a call on <code>position()</code> takes successive
values <code>1, 2, ... last()</code>.</p>
</div>
<div class="div2">
<h3><a name="information-about-group" id=
"information-about-group"></a>14.2 <a href=
"#information-about-group" style="text-decoration: none">Accessing
Information about the Current Group Value</a></h3>
<p>Two pieces of information are available during the processing of
each group (that is, while evaluating the sequence constructor
contained in the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, and also while evaluating the sort key of a group as
expressed by the <code>select</code> attribute or sequence
constructor of an <a href="#element-sort"><code>xsl:sort</code></a>
child of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element):</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-group-value" id="dt-current-group-value" title=
"current group value"></a>The <b>current group value</b> is the
<a title="group" class="termref" href="#dt-group">group</a> itself,
as a sequence of items<span class="definition">]</span>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-grouping-key-value" id="dt-current-grouping-key-value"
title="current grouping key value"></a>The <b>current grouping key
value</b> is a single atomic value, or in the case of a composite
key, a sequence of atomic values, containing the <a title=
"grouping key" class="termref" href="#dt-grouping-key">grouping
key</a> of the items in the <a title="current group value" class=
"termref" href="#dt-current-group-value">current group
value</a>.<span class="definition">]</span></p>
</li>
</ul>
<p>There are two ways of getting this information. The preferred
way in XSLT 3.0 is to bind variables using the
<code>bind-group</code> and <code>bind-grouping-key</code>
attributes of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
<p>If the <code>bind-group</code> attribute is present, then its
value must be an <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, and this causes a local variable binding
for this name to be visible within the sequence constructor forming
the body of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, and also within any <a href=
"#element-sort"><code>xsl:sort</code></a> element child of the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. The type of the variable is <code>item()*</code> (any
sequence of items), and its value is the content of the <a title=
"current group value" class="termref" href=
"#dt-current-group-value">current group value</a>.</p>
<p>If the <code>bind-grouping-key</code> attribute is present, then
its value must be a <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, and this causes a local variable binding
for this name to be present within the sequence constructor forming
the body of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction and also within any <a href=
"#element-sort"><code>xsl:sort</code></a> element child of the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. The type of the variable is <code>anyAtomicType*</code>
(any sequence of atomic values), and its value is the <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a>,
that is the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> of the <a title="group" class=
"termref" href="#dt-group">group</a> being processed.</p>
<p>If the variable names bound in the <code>bind-group</code> or
<code>bind-grouping-key</code> attributes are used in the
<code>select</code> attribute or the sequence constructor within an
<a href="#element-sort"><code>xsl:sort</code></a> child of the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, then they act as references to the group whose sort
key is being computed, or the grouping key of that group,
respectively.</p>
<p>Except as noted below, the variable bindings established by the
<code>bind-group</code> and <code>bind-grouping-key</code>
attributes, when present, are visible within all descendant
elements of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction on which they are declared, other than elements where
the variable binding is <a title="shadows" class="termref" href=
"#dt-shadows">shadowed</a> by another variable binding. For more
information see <a href="#scope-of-variables"><i>9.9 Scope of
Variables</i></a>.</p>
<p><a name="err-XTSE3220" id="err-XTSE3220"><span class=
"error">[ERR XTSE3220]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
variable bound in the <code>bind-group</code> or
<code>bind-grouping-key</code> attribute of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is referenced within an expression in the
<code>lang</code>, <code>order</code>, <code>collation</code>,
<code>stable</code>, <code>case-order</code>, or
<code>data-type</code> attributes of an <a href=
"#element-sort"><code>xsl:sort</code></a> child of that <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
<p><a name="err-XTSE3230" id="err-XTSE3230"><span class=
"error">[ERR XTSE3230]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>bind-grouping-key</code> attribute is present on an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction unless either the <code>group-by</code> or
<code>group-adjacent</code> attribute is present.</p>
<p>For backwards compatibility, XSLT 3.0 also allows information
about the <a title="current group value" class="termref" href=
"#dt-current-group-value">current group value</a> and the <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a> to
be held in the dynamic context, and obtained therefrom using the
<a href="#func-current-group"><code>current-group</code></a> and
<a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
functions respectively. The difference between using bound
variables and using these functions is that the variables have
static scope (they can only be used lexically within the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element), whereas the functions have dynamic scope (they are
available in called templates — though not in called functions — as
well as within the lexical body of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>). The
fact that the functions have dynamic scope makes certain
optimizations difficult, and in particular it makes it impossible
to satisfy the rules for streamability. When streamed processing is
required, therefore, it is necessary to bind variables to the group
and grouping key rather than using the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
functions.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The terms <a title="current group value" class="termref" href=
"#dt-current-group-value">current group value</a> and <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a>
refer to the group and grouping key being processed, regardless
whether these are bound to variables or held in the dynamic
context. The terms <a title="current group" class="termref" href=
"#dt-current-group">current group</a> and <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> refer to the
values held in the dynamic context, which are set to hold the
<a title="current group value" class="termref" href=
"#dt-current-group-value">current group value</a> and <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a>
only when these values have not been bound to variables.</p>
</div>
<p>An added benefit of using the <code>bind-group</code> and
<code>bind-grouping-key</code> variables is apparent when <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
elements are nested: the grouping variables for the outer
instruction remain in scope when processing the inner
instruction.</p>
<p>If the <code>bind-group</code> attribute is present on the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, then the <a title="current group" class="termref"
href="#dt-current-group">current group</a> (the value accessed by
the <a href="#func-current-group"><code>current-group</code></a>
function) is set to <a title="absent" class="termref" href=
"#dt-absent">absent</a> during the processing of the instruction,
which has the effect that any call on <a href=
"#func-current-group"><code>current-group</code></a> results in a
dynamic error.</p>
<p>If the <code>bind-grouping-key</code> attribute is present on
the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, or if neither the <code>group-by</code> nor
<code>group-adjacent</code> attribute is present, then the
<a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> (the value
accessed by the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function) is set to <a title="absent" class="termref" href=
"#dt-absent">absent</a> during the processing of the instruction,
which has the effect that any call on <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
results in a dynamic error.</p>
<div class="div3">
<h4><a name="func-current-group" id="func-current-group"></a>14.2.1
<a href="#func-current-group" style=
"text-decoration: none">fn:current-group</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the group currently being processed by an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-group" id=
"function-current-group"></a></p>
<div class="proto"><code class=
"function">current-group</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-group" id="dt-current-group" title=
"current group"></a>The evaluation context for XPath <a title=
"expression" class="termref" href="#dt-expression">expressions</a>
includes a component called the <b>current group</b>, which is a
sequence.<span class="definition">]</span></p>
<p>The current group is bound during evaluation of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. If no <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is being evaluated, the current group will be absent:
that is, any reference to it will cause a dynamic error.</p>
<p>The scope of the current group is dynamic: its value is retained
through calls on named templates, template rules, and attribute
sets. <span>It is cleared (becomes <a title="absent" class=
"termref" href="#dt-absent">absent</a>) during <a title=
"non-contextual function call" class="termref" href=
"#dt-non-contextual-function-call">non-contextual function
calls</a>, and during the evaluation of global variables and
stylesheet parameters. It is also cleared during calls on <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> that
use a <code>bind-group</code> attribute.</span></p>
<p>The function <a href=
"#func-current-group"><code>current-group</code></a> returns the
sequence of items making up the current group.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE1060" id="err-XTSE1060"><span class=
"error">[ERR XTSE1060]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#func-current-group"><code>current-group</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE1061" id="err-XTDE1061"><span class=
"error">[ERR XTDE1061]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#func-current-group"><code>current-group</code></a>
function is used when the current group is <a title="absent" class=
"termref" href="#dt-absent">absent</a> <span>, or when it is
invoked in the course of evaluating a pattern</span>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function is classified as <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
which means that it cannot be used with higher-order functions.
Specifically, <code>current-group#0</code> will not be recognized
as a function literal.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-current-grouping-key" id=
"func-current-grouping-key"></a>14.2.2 <a href=
"#func-current-grouping-key" style=
"text-decoration: none">fn:current-grouping-key</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the grouping key of the group currently being processed
using the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-grouping-key" id=
"function-current-grouping-key"></a></p>
<div class="proto"><code class=
"function">current-grouping-key</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-grouping-key" id="dt-current-grouping-key" title=
"current grouping key"></a>The evaluation context for XPath
<a title="expression" class="termref" href=
"#dt-expression">expressions</a> includes a component called the
<b>current grouping key</b>, which is <span>a sequence of atomic
values</span>. The current grouping key is the <a title=
"grouping key" class="termref" href="#dt-grouping-key">grouping
key</a> shared in common by all the items within the <a title=
"current group" class="termref" href="#dt-current-group">current
group</a>.<span class="definition">]</span></p>
<p>The current grouping key is bound during evaluation of the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. If <span>no <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is being evaluated, the current grouping key will be
absent, which means that any reference to it causes a dynamic
error.</span></p>
<p>The scope of the current grouping key is dynamic: its value is
retained through calls on named templates, template rules, and
attribute sets. It is cleared (becomes <a title="absent" class=
"termref" href="#dt-absent">absent</a>) during <a title=
"non-contextual function call" class="termref" href=
"#dt-non-contextual-function-call">non-contextual function
calls</a>, and during the evaluation of global variables and
stylesheet parameters. It is also cleared during calls on <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> that
use a <code>group-starting-with</code> or
<code>group-ending-with</code> or <code>bind-grouping-key</code>
attribute.</p>
<p>While an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction with a <code>group-by</code> or
<code>group-adjacent</code> attribute is being evaluated, the
<a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> will be a
single atomic value <span>if <code>composite="no"</code> is
specified (explicitly or implicitly), or a sequence of atomic
values if <code>composite="yes"</code> is specified.</span></p>
<p>At other times, the current grouping key will be <a title=
"absent" class="termref" href="#dt-absent">absent</a>.</p>
<p>The function <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
returns the <a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a>.</p>
<p><span>The <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a> of all items in a group are
not necessarily identical. For example, one might be an
<code>xs:float</code> while another is a numerically equal
<code>xs:decimal</code></span>. The <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function <span>returns</span> the grouping key of the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> in the group, after atomization and casting of
<code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>
<p>The function takes no arguments.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE1070" id="err-XTSE1070"><span class=
"error">[ERR XTSE1070]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE1071" id="err-XTDE1071"><span class=
"error">[ERR XTDE1071]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used when the current grouping key is <a title="absent"
class="termref" href="#dt-absent">absent</a>, <span>or when it is
invoked in the course of evaluating a pattern.</span>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function is classified as <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
which means that it cannot be used with higher-order functions.
Specifically, <code>current-grouping-key#0</code> will not be
recognized as a function literal.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="order-of-groups" id="order-of-groups"></a>14.3
<a href="#order-of-groups" style="text-decoration: none">Ordering
among Groups</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-first-appearance" id="dt-first-appearance" title=
"order of first appearance"></a>There is a <span>total</span>
ordering among <a title="group" class="termref" href=
"#dt-group">groups</a> referred to as the <b>order of first
appearance</b>. A group <var>G</var> is defined to precede a group
<var>H</var> in order of first appearance if the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> of <var>G</var> precedes the initial item of <var>H</var>
in population order. If two groups <var>G</var> and <var>H</var>
have the same initial item (because the item is in both groups)
then <var>G</var> precedes <var>H</var> if the <a title=
"grouping key" class="termref" href="#dt-grouping-key">grouping
key</a> of <var>G</var> precedes the grouping key of <var>H</var>
in the sequence that results from evaluating the
<code>group-by</code> expression of this initial item.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-processing-order" id="dt-processing-order" title=
"processing order"></a>There is another <span>total</span> ordering
among groups referred to as <b>processing order</b>. If group
<var>R</var> precedes group <var>S</var> in processing order, then
in the result sequence returned by the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction the items generated by processing group <var>R</var>
will precede the items generated by processing group
<var>S</var>.<span class="definition">]</span></p>
<p>If there are no <a href=
"#element-sort"><code>xsl:sort</code></a> elements immediately
within the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element, the <a title="processing order" class="termref" href=
"#dt-processing-order">processing order</a> of the <a title="group"
class="termref" href="#dt-group">groups</a> is the <a title=
"order of first appearance" class="termref" href=
"#dt-first-appearance">order of first appearance</a>.</p>
<p>Otherwise, the <a href="#element-sort"><code>xsl:sort</code></a>
elements immediately within the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element define the processing order of the <a title="group" class=
"termref" href="#dt-group">groups</a> (see <a href="#sorting"><i>13
Sorting</i></a>). They do not affect the order of items within each
group. Multiple <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key components</a> are allowed, and
are evaluated in major-to-minor order. If two groups have the same
values for all their sort key components, they are processed in
<a title="order of first appearance" class="termref" href=
"#dt-first-appearance">order of first appearance</a> if the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is
<a title="stable" class="termref" href="#dt-stable">stable</a>,
otherwise in an <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>
order.</p>
<p>The <code>select</code> <a title="expression" class="termref"
href="#dt-expression">expression</a> of an <a href=
"#element-sort"><code>xsl:sort</code></a> element is evaluated once
for each <a title="group" class="termref" href=
"#dt-group">group</a>. During this evaluation, the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a> is the <a title="initial item" class="termref" href=
"#dt-initial-item">initial item</a> of the group, the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> is the position of this
item within the set of initial items (that is, one item for each
group in the <a title="population" class="termref" href=
"#dt-population">population</a>) in <a title="population order"
class="termref" href="#dt-population-order">population order</a>,
the <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of groups, the
<a title="current group value" class="termref" href=
"#dt-current-group-value">current group value</a> is the group
whose <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key value</a> is being determined, and
the <a title="current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a> is
the grouping key for that group. If the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction uses the <code>group-starting-with</code> or
<code>group-ending-with</code> attributes, then the <a title=
"current grouping key value" class="termref" href=
"#dt-current-grouping-key-value">current grouping key value</a> is
the empty sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34229" id=
"d7e34229"></a>Example: Sorting Groups</div>
<p>For example, this means that if the <a title="grouping key"
class="termref" href="#dt-grouping-key">grouping key</a> is
<code>@category</code>, you can sort the groups in order of their
grouping key by writing <code>&lt;xsl:sort
select="current-grouping-key()"/&gt;</code>; or you can sort the
groups in order of size by writing <code>&lt;xsl:sort
select="count(current-group())"/&gt;</code></p>
</div>
</div>
<div class="div2">
<h3><a name="grouping-examples" id="grouping-examples"></a>14.4
<a href="#grouping-examples" style="text-decoration: none">Examples
of Grouping</a></h3>
<p>These examples all use the <code>bind-group</code> and
<code>bind-grouping-key</code> attributes introduced in XSLT 3.0.
For equivalent examples using the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
functions, see the XSLT 2.0 specification.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34263" id=
"d7e34263"></a>Example: Grouping Nodes based on Common Values</div>
<p>The following example groups a list of nodes based on common
values. The resulting groups are numbered but unsorted, and a total
is calculated for each group.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;
</pre></div>
<p>More specifically, the aim is to produce a four-column table,
containing one row for each distinct country. The four columns are
to contain first, a sequence number giving the number of the row;
second, the name of the country, third, a comma-separated
alphabetical list of the city names within that country, and
fourth, the sum of the <code>pop</code> attribute for the cities in
that country.</p>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;table xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country" 
       bind-group="cities" bind-grouping-key="country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="$country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="$cities/@name" separator=", "/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum($cities/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34285" id=
"d7e34285"></a>Example: A Composite Grouping Key</div>
<p>Sometimes it is necessary to use a composite grouping key: for
example, suppose the source document is similar to the one used in
the previous examples, but allows multiple entries for the same
country and city, such as:</p>
<div class="exampleInner">
<pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;
</pre></div>
<p>Now suppose we want to list the average value of
<code>@pop</code> for each (country, name) combination. One way to
handle this is to concatenate the parts of the key, for example
<code>&lt;xsl:for-each-group select="concat(@country, '/',
@name)"&gt;</code>. A second solution is to nest one <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element directly inside another. XSLT 3.0 introduces a third
option, which is to define the grouping key as composite:</p>
<div class="exampleInner">
<pre>
&lt;xsl:for-each-group select="cities/city" 
                    group-by="@name, @country" 
                    composite="yes"
                    bind-group="group" 
                    bind-grouping-key="key"&gt;
  &lt;p&gt;&lt;xsl:value-of select="$key[1] || ', ' || $key[2] || ': ' || 
                           avg($group/@pop)"/&gt;&lt;/p&gt;
                           &lt;/xsl:for-each-group&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The string concatenation operator <code>||</code> is new in
XPath 3.0.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34311" id=
"d7e34311"></a>Example: Identifying a Group by its Initial
Element</div>
<p>The next example identifies a group not by the presence of a
common value, but rather by adjacency in document order. A group
consists of an <code>h2</code> element, followed by all the
<code>p</code> elements up to the next <code>h2</code> element.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
        &lt;xsl:for-each-group select="*" group-starting-with="h2"
                       bind-group="h2-et-seq"   &gt;
          &lt;section title="{self::h2}"&gt;
            &lt;xsl:for-each select="$h2-et-seq[self::p]"&gt;
              &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/section&gt;
        &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The use of <code>title="{self::h2}"</code> rather than
<code>title="{.}"</code> is to handle the case where the first
element is not an <code>h2</code> element.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34348" id=
"d7e34348"></a>Example: Identifying a Group by its Final
Element</div>
<p>The next example illustrates how a group of related elements can
be identified by the last element in the group, rather than the
first. Here the absence of the attribute
<code>continued="yes"</code> indicates the end of the group.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"
                      bind-group="pageset"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="$pageset"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34368" id=
"d7e34368"></a>Example: Adding an Element to Several Groups</div>
<p>The next example shows how an item can be added to multiple
groups. Book titles will be added to one group for each indexing
term marked up within the title.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"
                        bind-group="group" bind-grouping-key="key"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="$key"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="$group"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34385" id=
"d7e34385"></a>Example: Grouping Alternating Sequences of
Elements</div>
<p>In this example, the membership of a node within a group is
based both on adjacency of the nodes in document order, and on
common values. In this case, the grouping key is a boolean
condition, true or false, so the effect is that a grouping
establishes a maximal sequence of nodes for which the condition is
true, followed by a maximal sequence for which it is false, and so
on.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;
</pre></div>
<p>Solution:</p>
<p>This requires creating a <code>p</code> element around the
maximal sequence of sibling nodes that does not include a
<code>ul</code> or <code>ol</code> element.</p>
<p>This can be done by using <code>group-adjacent</code>, with a
grouping key that is true if the element is a <code>ul</code> or
<code>ol</code> element, and false otherwise:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"
            bind-group="group" bind-grouping-key="is-list"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="$is-list"&gt;
                &lt;xsl:copy-of select="$group"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="$group"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="non-transitivity" id="non-transitivity"></a>14.5
<a href="#non-transitivity" style=
"text-decoration: none">Non-Transitivity</a></h3>
<p>If the population contains values of different numeric types
that differ from each other by small amounts, then the
<code>eq</code> operator is not transitive, because of rounding
effects occurring during type promotion. It is thus possible to
have three values <var>A</var>, <var>B</var>, and <var>C</var>
among the grouping keys of the population such that <code>A eq
B</code>, <code>B eq C</code>, but <code>A ne C</code>.</p>
<p>For example, this arises when computing</p>
<div class="exampleInner">
<pre>
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001'),
             xs:double('1.00000000001')"&gt;
</pre></div>
<p>because the values of type <code>xs:float</code> and
<code>xs:double</code> both compare equal to the value of type
<code>xs:decimal</code> but not equal to each other.</p>
<p>In this situation the results <span class="verb">must</span> be
equivalent to the results obtained by the following algorithm:</p>
<ul>
<li>
<p>For each item <var>J</var> in the <a title="population" class=
"termref" href="#dt-population">population</a> in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a>, for each of the
<a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a> <var>K</var> for that item in
sequence, the processor identifies those existing groups
<var>G</var> such that the grouping key of the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> of <var>G</var> is equal to <var>K</var>.</p>
</li>
<li>
<p>If there is exactly one group <var>G</var>, then <var>J</var> is
added to this group, unless <var>J</var> is already a member of
this group.</p>
</li>
<li>
<p>If there is no group <var>G</var>, then a new group is created
with <var>J</var> as its first item.</p>
</li>
<li>
<p>If there is more than one group <var>G</var> (which can only
happen in exceptional circumstances involving non-transitivity),
then one of these groups is selected in an implementation-dependent
way, and <var>J</var> is added to this group, unless <var>J</var>
is already a member of this group.</p>
</li>
</ul>
<p>The effect of these rules is that (a) every item in a
non-singleton group has a grouping key that is equal to that of at
least one other item in that group, (b) for any two distinct
groups, there is at least one pair of items (one from each group)
whose grouping keys are not equal to each other.</p>
</div>
</div>
<div class="div1">
<h2><a name="merging" id="merging"></a>15 <a href="#merging" style=
"text-decoration: none">Merging</a></h2>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction allows a sorted sequence of items to be constructed by
merging several input sequences, each of which is already sorted.
Each input sequence <span class="verb">must</span> have a merge key
(one or more atomic values that can be computed as a function of
the items in the sequence); the input sequence <span class=
"verb">must</span> be pre-sorted on the value of its merge keys;
and the merge keys for the different input sequences <span class=
"verb">must</span> be compatible in the sense that <span>key values
from an item in one sequence are always comparable with key values
from an item in a different sequence</span>.</p>
<p>For example, if two log files contain details of events sorted
by date and time, then the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction can be used
to combine these into a single sequence that is also sorted by date
and time.</p>
<p>The data written to the output sequence can be computed in an
arbitrary way from the data in the input sequences, provided it
follows the ordering of the input sequences.</p>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction can be used to merge several sequences of items that
all have the same structure (more precisely, sequences whose merge
keys are computed in the same way): for example, log files created
by the same application running on different machines in a server
farm. Alternatively, <a href=
"#element-merge"><code>xsl:merge</code></a> can be used to merge
sequences that have different structure (sequences whose merge keys
are computed in different ways), provided that the computed merge
keys are compatible: an example might be two log files created by
different applications, using different XML vocabularies, that both
contain timestamped events but represent the timestamp in different
ways. The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
represents a <span>set of input sequences that follow common
rules</span>, including the rules for computing the merge key. The
<a href="#element-merge"><code>xsl:merge</code></a> operation may
take any number of <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
representing different <span>rules for</span> input sequences, and
each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
may describe any number (zero or more) of input sequences. The
number of input sequences to the merging operation is thus
<span>fixed only at the time the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is
evaluated, and <span class="verb">may</span> vary from one
evaluation to another</span>.</p>
<p>The following examples illustrate some of the possibilities. The
detailed explanation of the constructs used follows later in this
section.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34603" id=
"d7e34603"></a>Example: Merging All the Files in a Collection</div>
<p>This example takes as input a homogeneous collection of XML log
files each of which contains a sorted sequence of
<code>event</code> elements with a <code>timestamp</code> attribute
validated as an instance of <code>xs:dateTime</code>. It merges the
events from the input files into a single sorted output file.</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge bind-group="group"&gt;
      &lt;xsl:merge-source for-each="collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="$group"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>The example assumes that there are <span>several input files
each of which has</span> a structure similar to the following, in
which the <code>timestamp</code> attribute has a typed value that
is an instance of <code>xs:dateTime</code>:</p>
<div class="exampleInner">
<pre>
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;
</pre></div>
<p>The output file will have the same structure, and will contain
copies of all the <code>event</code> elements from all of the input
files, in sorted order. <span>Note that multiple events with the
same timestamp can occur either within a single file or across
multiple files: the order of appearance of these events in the
output file corresponds to the order of the log files within the
collection (which might or might not be predictable, depending on
the implementation).</span></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e34639" id=
"d7e34639"></a>Example: Merging Two Heterogeneous Files</div>
<p>This example takes as input two log files with different
structure, producing a single merged output in which the entries
have a common structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge bind-group="grp"&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="$grp" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>Here the first input file has a structure similar to that shown
in the previous example, while the second input has a different
structure, of the form:</p>
<div class="exampleInner">
<pre>
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;
</pre></div>
<p>The templates in mode <code>standardize-log-entry</code> convert
the log entries to a common output format, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction is designed to enable streaming of data, so that there
is no need to allocate memory to hold the input sequences. However,
there is no requirement that an implementation should actually use
streaming to perform the processing.</p>
</div>
<div class="div2">
<h3><a name="merge-terminology" id="merge-terminology"></a>15.1
<a href="#merge-terminology" style=
"text-decoration: none">Terminology for Merging</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-source-definition" id="dt-merge-source-definition" title=
"merge source definition"></a>A <b>merge source definition</b> is
the definition of one kind of input to the merge operation. It
selects zero or more <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input
sequences</a>, and it includes a <a title="merge key specification"
class="termref" href="#dt-merge-key-specification">merge key
specification</a> to define how the <span><a title=
"merge key value" class="termref" href="#dt-merge-key-value">merge
key values</a></span> are computed for each such merge input
sequence.<span class="definition">]</span> A merge source
definition corresponds to an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
in the stylesheet.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-input-sequence" id="dt-merge-input-sequence" title=
"merge input sequence"></a>A <b>merge input sequence</b> is an
arbitrary <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup>
of items which is already sorted according to the <a title=
"merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> for the
corresponding <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source
definition</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-specification" id="dt-merge-key-specification" title=
"merge key specification"></a>A <b>merge key specification</b>
consists of one or more adjacent <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements which
together define how the <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequences</a>
selected by a <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a> are
sorted. Each <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element defines
one <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a>.<span class=
"definition">]</span> For example, a merge key specification for a
log file might specify two merge key components, <code>date</code>
and <code>time</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-component" id="dt-merge-key-component" title=
"merge key component"></a>A <b>merge key component</b> specifies
one component of a <a title="merge key specification" class=
"termref" href="#dt-merge-key-specification">merge key
specification</a>; it corresponds to a single <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element in the
stylesheet.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-value" id="dt-merge-key-value" title=
"merge key value"></a> For each item in a <a title=
"merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequence</a>, a value is
computed for each <a title="merge key component" class="termref"
href="#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>. The
value computed for an item by using the <var>N</var>th <a title=
"merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> is referred to as
the <var>N</var>th <b>merge key value</b> of that item.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-composite-merge-key-value" id="dt-composite-merge-key-value"
title="composite merge key value"></a> The ordered collection of
<a title="merge key value" class="termref" href=
"#dt-merge-key-value">merge key values</a> computed for one item in
a <a title="merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequence</a> (one for each
<a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>) is
referred to as a <b>composite merge key value</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-activation" id="dt-merge-activation" title=
"merge activation"></a>A <b>merge activation</b> is a single
evaluation of the sequence constructor contained within the
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
element, which occurs once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key
value</a>.<span class="definition">]</span></p>
</div>
<div class="div2">
<h3><a name="merge-instruction" id="merge-instruction"></a>15.2
<a href="#merge-instruction" style="text-decoration: none">The</a>
<a href="#element-merge"><code>xsl:merge</code></a> <a href=
"#merge-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-merge" id=
"element-merge"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:merge<br />
&#160;&#160;bind-group? = <var>eqname</var><br />
&#160;&#160;bind-key? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-merge-source">xsl:merge-source</a>+, <a href=
"#element-merge-action">xsl:merge-action</a>, <a href=
"#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:merge&gt;</code></p>
<p>The effect of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is to
produce a sorted result sequence from a number of input
sequences.</p>
<p>The input sequences to the merge operation are defined by the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
child elements, as described in the next section.</p>
<p>The sequence constructor contained in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
is evaluated once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a> to
form a partial result sequence. The result of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is the
concatenation of these partial result sequences. For example, the
action might be to copy the items from all the input sequences to
the result sequence without change; or it might be to select the
items from one input sequence in preference to the others. In the
general case, the items in the partial result sequence are produced
by an arbitrary computation that has access to the items (from the
various input sequences) that share the same value for the
composite merge key.</p>
<p>The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> and
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
elements are described in the following sections.</p>
<p>The <code>bind-group</code> attribute establishes the name of a
variable which is available for reference within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element,
and whose value is a sequence of items, from all input sources,
that share a common <a title="composite merge key value" class=
"termref" href="#dt-composite-merge-key-value">composite merge key
value</a>.</p>
<p>The <code>bind-key</code> attribute establishes the name of a
variable which is available for reference within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element,
and whose value is the <a title="composite merge key value" class=
"termref" href="#dt-composite-merge-key-value">composite merge key
value</a> of these items.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children of the <a href="#element-merge"><code>xsl:merge</code></a>
instruction are ignored by an XSLT 3.0 processor, but are used by
an XSLT 1.0 or XSLT 2.0 processor to <span>perform fallback
processing</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An <a href="#element-merge"><code>xsl:merge</code></a>
instruction that has no input sequences returns an empty sequence.
An <a href="#element-merge"><code>xsl:merge</code></a> instruction
with a single input sequence performs processing that is very
similar in concept to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
the <code>group-adjacent</code> attribute, except that it requires
the input to be sorted on the grouping key.</p>
</div>
</div>
<div class="div2">
<h3><a name="merge-input-sequences" id=
"merge-input-sequences"></a>15.3 <a href="#merge-input-sequences"
style="text-decoration: none">Selecting the Sequences to be
Merged</a></h3>
<p class="element-syntax"><a name="element-merge-source" id=
"element-merge-source"></a><code>&lt;xsl:merge-source<br />
&#160;&#160;for-each? = <var>expression</var><br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;bind-source? = <var>eqname</var><br />
&#160;&#160;streamable? = "yes" | "no"<br />
&#160;&#160;sort-before-merge? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-merge-key">xsl:merge-key</a>+ --&gt;<br />
&lt;/xsl:merge-source&gt;</code></p>
<p>Each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
defines one or more <a title="merge input sequence" class="termref"
href="#dt-merge-input-sequence">merge input sequences</a>.</p>
<p>In the absence of the <code>for-each</code> attribute, the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element defines a single merge input sequence. This sequence is the
result of evaluating the expression in the <code>select</code>
attribute. This is evaluated using the dynamic context of the
containing <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
<p>When the <code>for-each</code> attribute is present, the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element defines a collection of merge input sequences. The
selection of items in these input sequences is a two-stage process:
the <code>for-each</code> attribute of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
is an expression that selects a sequence of <em>anchor items</em>,
and for each anchor item, the <code>select</code> attribute is
evaluated to select the items that make up one merge input
sequence. The <code>for-each</code> expression is evaluated with
the dynamic context of the containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, while the
<code>select</code> attribute is evaluated with the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for the
evaluation as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the anchor item</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of the
anchor item within the sequence of anchor items</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of anchor
items.</p>
</li>
</ul>
<p>The <code>bind-source</code> attribute establishes the name of a
variable which is available for reference within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element,
and whose value is a sequence of items, from this source only, that
share the <a title="composite merge key value" class="termref"
href="#dt-composite-merge-key-value">composite merge key value</a>
for this activation of the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a>.</p>
<p>If the <code>sort-before-merge</code> attribute is absent or has
the value <code>no</code>, then each input sequence <span class=
"verb">must</span> already be in the correct order for merging (a
dynamic error occurs if it is not). If the attribute is present
with the value <code>yes</code>, then each input sequence will
first be sorted to ensure that it is in the correct order.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35009" id=
"d7e35009"></a>Example: Merging Several Documents with the Same
Structure</div>
<p>The following <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
selects two anchor items (the root nodes of two documents), and for
each of these it selects an input sequence consisting of selected
<code>event</code> elements within the relevant document.</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source for-each="doc('log-A.xml'), doc('log-B.xml')"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>This example can be extended to merge any number of input
documents with the same structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source for-each="collection('log-collection')"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>In both the above examples the anchor items are document nodes,
and the items in the input sequence are elements within the
document that is rooted at this node. This is a common usage
pattern, but by no means the only way in which the construct can be
used.</p>
</div>
<p>The number of anchor items selected by an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
and therefore the number of input sequences, is variable, but the
input sequences selected by one <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
must all use the same expressions to select the items in the input
sequence and to compute their merge keys. If different expressions
are needed for different input sequences, then multiple <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
can be used.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35039" id=
"d7e35039"></a>Example: Merging Two Documents with Different
Structure</div>
<p>The following code merges two log files having different
internal structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>Although the merge keys are computed in different ways for the
two input sequences, the keys must be compatible across the two
sequences: in this case they are both atomic values of type
<code>xs:dateTime</code>.</p>
</div>
<p>In the common case where there is only one input sequence of a
particular kind, the <code>for-each</code> attribute of <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> may be
omitted; the <code>select</code> expression is then evaluated
relative to the <a title="focus" class="termref" href=
"#dt-focus">focus</a> of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction itself.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35069" id=
"d7e35069"></a>Example: Sorting before Merging</div>
<p>Where one or more of the inputs to the merging process is not
pre-sorted, a sort can be requested using the
<code>sort-before-merge</code> attribute. For example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
</div>
<p><a name="err-XTSE3190" id="err-XTSE3190"><span class=
"error">[ERR XTSE3190]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two
sibling <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
have the same name, whether explicit or implicit.</p>
</div>
<div class="div2">
<h3><a name="streamable-merging" id="streamable-merging"></a>15.4
<a href="#streamable-merging" style=
"text-decoration: none">Streamable Merging</a></h3>
<p>Any (zero or more) of the inputs to a merging operation may be
designated as streamable by including the attribute
<code>streamable="yes"</code> on the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
element.</p>
<p>An <a href="#element-merge"><code>xsl:merge</code></a>
instruction is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if it
satisfies all the following conditions:</p>
<ol class="enumar">
<li>
<p>The <code>for-each</code> attribute must be present on that
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element, and its value must be a function call that calls the
<a href="#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
function;</p>
</li>
<li>
<p>The expression in the <code>select</code> attribute of that
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element must <span>have <a title="striding" class="termref" href=
"#dt-striding">striding</a> <a title="posture" class="termref"
href="#dt-posture">posture</a></span>;</p>
</li>
<li>
<p>The <code>sort-before-merge</code> attribute of that <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
must either be absent or take its default value of
<code>no</code>;</p>
</li>
<li>
<p>The <code>select</code> expression of each merge key in that
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element must be a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> expression;</p>
</li>
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
must have <span><a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> <a title="posture" class="termref"
href="#dt-posture">posture</a> and</span> and either <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
or <span><a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> <a title="sweep" class="termref"
href="#dt-sweep">sweep</a></span>.</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-merge"><code>xsl:merge</code></a> element declares an
intent that the <a href="#element-merge"><code>xsl:merge</code></a>
instruction should be guaranteed streamable according to these
criteria. The consequences of declaring the instruction to be
streamable when it is not in fact guaranteed streamable depend on
the conformance level of the processor, and are explained in
<a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35205" id=
"d7e35205"></a>Example: Streamed Merging</div>
<p>The following example merges two log files, processing each of
them using streaming.</p>
<div class="exampleInner">
<pre>
&lt;events&gt;
   &lt;xsl:merge bind-group="grp" bind-key="key"&gt;
      &lt;xsl:merge-source for-each="doc('log-file-1.xml')" 
                        select="events/event" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source for-each="doc('log-files-2.xml')" 
                        select="snapshot(log/day/record)" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;events time="{$key}"&gt;
            &lt;xsl:copy-of select="$grp"/&gt;
         &lt;/events&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;
</pre></div>
</div>
<p>Note the use of the <a href=
"#func-snapshot"><code>snapshot</code></a> function. This is needed
because the merge key for the second merge source includes data
from a child element of the selected element (making it
non-motionless) and also from an attribute of the parent element
(making it inaccessible if <a href=
"#func-copy-of"><code>copy-of</code></a> were used in place of
<a href="#func-snapshot"><code>snapshot</code></a>).</p>
</div>
<div class="div2">
<h3><a name="merge-keys" id="merge-keys"></a>15.5 <a href=
"#merge-keys" style="text-decoration: none">Defining the Merge
Keys</a></h3>
<p>The keys on which the input sequences are sorted are referred to
as merge keys. If the attribute <code>sort-before-merge</code> has
the value <code>yes</code>, the input sequences will be sorted into
the correct sequence before the merge operation takes place
(alternatively, the processor <span class="verb">may</span> use an
algorithm that has the same effect as sorting followed by merging).
If the attribute is absent or has the value <code>no</code>, then
the input sequences <span class="verb">must</span> already be in
the correct order.</p>
<p>The merge key for each type of input sequence (that is, for each
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element) is defined by a sequence of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element
children of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
Each <a href="#element-merge-key"><code>xsl:merge-key</code></a>
element defines one merge key component. The syntax and semantics
of an <a href="#element-merge-key"><code>xsl:merge-key</code></a>
element are closely based on the rules for the <a href=
"#element-sort"><code>xsl:sort</code></a> element (the only
exception being the absence of the <code>stable</code> attribute);
the difference is that <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements do not
cause a sort to take place, they merely declare the existing sort
order of the input sequence.</p>
<p class="element-syntax"><a name="element-merge-key" id=
"element-merge-key"></a><code>&lt;xsl:merge-key<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-key&gt;</code></p>
<p>The <code>select</code> attribute and the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> are mutually
exclusive:</p>
<p><a name="err-XTSE3200" id="err-XTSE3200"><span class=
"error">[ERR XTSE3200]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-merge-key"><code>xsl:merge-key</code></a> element
with a <code>select</code> attribute has non-empty content.</p>
<p>The effect of the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements is
defined in terms of the rules for an equivalent sequence of
<a href="#element-sort"><code>xsl:sort</code></a> elements: if the
rules for sorting (see <a href="#sorting-process"><i>13.1.1 The
Sorting Process</i></a>) with <code>stable="yes"</code> would place
an item <var>A</var> before an item <var>B</var> in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> produced by the sorting process, then <var>A</var>
must precede <var>B</var> in the input sequence to the merging
process.</p>
<p>The merge keys of the various input sequences to a merge
operation must be compatible with each other, since the merge
operation will decide the ordering of the result sequence by
comparing merge key values across input sequences. This means that
across all the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
of an <a href="#element-merge"><code>xsl:merge</code></a>
instruction:</p>
<ul>
<li>
<p>Each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
<span class="verb">must</span> have the same number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> child elements;
let this number be <var>N</var>.</p>
</li>
<li>
<p>For each integer <var>J</var> in 1..<var>N</var>, consider the
set of <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements that are in position <var>J</var> among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
their parent <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
All the <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements in this set <span class="verb">must</span> have the same
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> for their
<code>lang</code>, <code>order</code>, <code>collation</code>,
<code>case-order</code>, and <code>data-type</code> attributes,
where having the same effective value in this case means that
either both attributes must be absent, or both must be present and
evaluate to the same value; and in addition in the case of
<code>collation</code> the absolute URI must be the same after
resolving against the base URI.</p>
</li>
</ul>
<p>If any of the attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code> are <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a>, then their <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> are
evaluated using the <a title="focus" class="termref" href=
"#dt-focus">focus</a> of the containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction.</p>
<p><a name="err-XTSE2200" id="err-XTSE2200"><span class=
"error">[ERR XTSE2200]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of a
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element is not equal to the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
another <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child of
the same <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
<p><a name="err-XTDE2210" id="err-XTDE2210"><span class=
"error">[ERR XTDE2210]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if there
are two <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements that occupy corresponding positions among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of two
different <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
and that have differing <a title="effective value" class="termref"
href="#dt-effective-value">effective values</a> for any of the
attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code>. Values are considered to differ if the
attribute is present on one element and not on the other, or if it
is present on both elements with <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> that are
not equal to each other. In the case of the <code>collation</code>
attribute, the values are compared as absolute URIs after resolving
against the base URI.The error <span class="verb">may</span> be
reported statically if it is detected statically.</p>
<p><a name="err-XTDE2220" id="err-XTDE2220"><span class=
"error">[ERR XTDE2220]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if any
input sequence to an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction contains
two items that are not correctly sorted according to the merge key
values defined on the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
corresponding <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
when compared using the collation rules defined by the attributes
of the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
unless the attribute <code>sort-before-merge</code> is present with
the value <code>yes</code>.</p>
<p><a name="err-XTTE2230" id="err-XTTE2230"><span class=
"error">[ERR XTTE2230]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if some item
selected by a particular merge key in one input sequence is not
comparable using the XPath <code>le</code> operator with some item
selected by the corresponding sort key in another input
sequence.</p>
</div>
<div class="div2">
<h3><a name="merge-action" id="merge-action"></a>15.6 <a href=
"#merge-action" style="text-decoration: none">The</a> <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> <a href=
"#merge-action" style="text-decoration: none">Element</a></h3>
<p>The <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> child of
an <a href="#element-merge"><code>xsl:merge</code></a> instruction
defines the processing to be applied for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a> found
in the input sequences to the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction.</p>
<p class="element-syntax"><a name="element-merge-action" id=
"element-merge-action"></a><code>&lt;xsl:merge-action&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:merge-action&gt;</code></p>
<p>The merge key values for each item in an input sequence are
calculated based on the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements, in
the same way as <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are calculated using a
sequence of <a href="#element-sort"><code>xsl:sort</code></a>
elements (see <a href="#sorting-process"><i>13.1.1 The Sorting
Process</i></a>). If several items from the same or from different
input sequences have the same values for all their merge keys
(comparing pairwise), then they are considered to form a group. The
sequence constructor contained in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
is evaluated once for each such group of items, and the result of
the <a href="#element-merge"><code>xsl:merge</code></a> instruction
is the concatenation of the results obtained by processing each
group in turn.</p>
<p><span>The groups are processed one by one, based on the values
of the merge keys for the group.</span> If group <var>G</var> has a
set of merge key values <var>M</var>, while group <var>H</var> has
a set of merge key values <var>N</var>, then in the result of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
the result of processing group <var>G</var> will precede the result
of processing <var>H</var> if and only if <var>M</var> precedes
<var>N</var> in the sort order defined by the <code>lang</code>,
<code>order</code>, <code>collation</code>,
<code>case-order</code>, and <code>data-type</code> attributes of
the merge key definitions.</p>
<p>Generally, two sets of sort key values are distinct if any
corresponding items in the two sets of values do not compare equal
under the rules for the XPath <code>eq</code> operator, under the
collating rules for the corresponding merge key definition. In rare
cases, when considering more than two sets of sort key values,
ambiguities may arise because of the non-transitivity of the
<code>eq</code> operator when applied across different numeric
types. In this situation, the partitioning of items into sets
having distinct key values is handled in the same way as for
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> (see
<a href="#non-transitivity"><i>14.5 Non-Transitivity</i></a>), and
is to some extent <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>The static context for the sequence constructor contained within
the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
includes the variables declared using the <code>bind-group</code>
and <code>bind-key</code> attributes of the containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction and the
<code>bind-source</code> attributes of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
of this <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
<p><a name="err-XTSE3270" id="err-XTSE3270"><span class=
"error">[ERR XTSE3270]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the set
of variable names declared using the <code>bind-group</code> and
<code>bind-key</code> attributes of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction and the
<code>bind-source</code> attributes of its <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
contains any duplicates.</p>
<p>The variable defined in the <code>bind-key</code> attribute, if
any, is bound to the value of the <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a>.
There may be several input items having merge keys that are equal
but distinguishable (for example the number 1.0 as a float and as a
double, or the strings "A" and "a" under a case-blind collation);
in this case the value of the variable is the value of the merge
key computed for the first item in the current group, after
atomization and casting of <code>xs:untypedAtomic</code> to
<code>xs:string</code>.</p>
<p>The variable defined in the <code>bind-group</code> attribute,
if any, is bound to the set of items (zero or more from each input
sequence) that have this set of values as their merge key value.
The value of this variable is referred to as the <b>current
group</b>.</p>
<p>Within the current group, the ordering of items from the input
sequences is as follows, in major-to-minor order:</p>
<ul>
<li>
<p>Items are first ordered by the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
that defined the input sequence from which the item was taken;
items from <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
<var>A</var> precede items from <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
<var>B</var> if <var>A</var> precedes <var>B</var> in document
order within the stylesheet.</p>
</li>
<li>
<p>Items from different input sequences selected by the same
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element are then ordered based on the order of the anchor items in
the sequence selected by evaluating the <code>select</code>
attribute of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
element.</p>
</li>
<li>
<p>Finally, duplicate items from the same input sequence retain
their order from the input sequence.</p>
</li>
</ul>
<p>Duplicates are not eliminated: for example, if the same node is
selected in more than one input sequence, it may appear twice in
the current group.</p>
<p>The variable defined in the <code>bind-source</code> attribute
of an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
if any, is bound to the current group, filtered to include only
those items that originate from the merge source in question.</p>
<p>The <a title="focus" class="termref" href="#dt-focus">focus</a>
for evaluation of the sequence constructor contained in the
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
element is as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the first item in the
current group, that is <code>current-group()[1]</code></p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of the
current group within the sequence of groups (so the first
evaluation of <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> has
<code>position()=1</code>, the second has
<code>position()=2</code>, and so on).</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of groups, that
is, the number of distinct sets of merge key values.</p>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e35837" id=
"d7e35837"></a>Example: Selective Processing of Merge Inputs</div>
<p>Consider a situation where there are two merge sources, named
"master" and "update"; the master source identifies a single merge
input file (the master file), while the update source identifies a
set of <var>N</var> update files, perhaps one for each day of the
week. The required logic is that if a merge key is present only in
the master file, then the corresponding item should be copied to
the output; if it is present in a single update file then that item
replaces the corresponding item from the master file; if it is
present in several update files, then an error is raised. This can
be achieved as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge&gt;
  &lt;xsl:merge-source bind-source="master" 
                    for-each="doc('master.xml')"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source bind-source="updates" 
                    for-each="collection('updates')"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty($master)"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty($updates)"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count($updates) = 1"&gt;
        &lt;xsl:copy-of select="$updates"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            
</pre></div>
<p>Some words of explanation:</p>
<ul>
<li>
<p>Error messages are produced if there is an update element whose
key does not correspond to any element in the master source, or if
there is more than one update element corresponding to the same
master element.</p>
</li>
<li>
<p>In the absence of errors, if there is a single update element
then it is copied to the output; if there is none, then the master
element is copied.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="merge-examples" id="merge-examples"></a>15.7 <a href=
"#merge-examples" style="text-decoration: none">Examples of
xsl:merge</a></h3>
<p>Previous sections introduced examples designed to illustrate
some specific features of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction. This
section provides some further examples to illustrate different ways
in which the instruction can be used.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35864" id=
"d7e35864"></a>Example: Applying Transactions to a Master
File</div>
<p>This example applies transactions from a transaction file to a
master file. Records in the master file for which there is no
corresponding transaction are copied unchanged. The transaction
file contains instructions to delete, replace, or insert records
identified by an ID value. The master file is known to be sorted on
the ID value; the transaction file is unsorted.</p>
<p>Master file document structure:</p>
<div class="exampleInner">
<pre>
&lt;data&gt;
  &lt;record ID="A0001"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0002"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0003"&gt;&lt;...&gt;&lt;/record&gt;
&lt;/data&gt;
</pre></div>
<p>Transaction file document structure:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;&lt;...&gt;&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;&lt;...&gt;&lt;/update&gt;
&lt;/transactions&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:merge bind-key="merge-key"&gt;
  &lt;xsl:merge-source bind-source="master"
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source bind-source="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty($updates)"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$updates/@action=('insert', 'replace')"&gt;
        &lt;record ID="{$merge-key}"&gt;
          &lt;xsl:copy-of select="$update/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$updates/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35881" id=
"d7e35881"></a>Example: Merging Two Sequences of Numbers</div>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction can be used to determine the union, intersection, or
difference of two sequences of numbers (or other atomic values).
This code gives the union:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge bind-key="k"&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:value-of select="$k"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               
</pre></div>
<p>While this gives the intersection:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge bind-key="k" bind-group="g"&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count($g) eq 2"&gt;
      &lt;xsl:value-of select="$k"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="splitting" id="splitting"></a>16 <a href="#splitting"
style="text-decoration: none">Splitting</a></h2>
<p>Sometimes it is convenient to be able to compute multiple
results during a single scan of the input data. For example, a
transformation may wish to rename selected elements, and also to
output a count of how many elements have been renamed.
Traditionally in a functional language this means computing two
separate functions of the input sequence, which (in the absence of
sophisticated optimization) will result in the input being scanned
twice. This is inconsistent with streaming, where the input is only
available to be scanned once, and it can also lead to poor
performance in non-streaming applications.</p>
<p>To meet this requirement, XSLT 3.0 introduces the instruction
<a href="#element-fork"><code>xsl:fork</code></a>. The content of
this instruction is a <span>restricted form of</span> <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and in a
formal sense the effect of the instruction is simply to return the
result of evaluating the sequence constructor. However, the
presence of the instruction affects the analysis of streamability
(see <a href="#streamability"><i>19 Streamability</i></a>). In
particular, when <a href="#element-fork"><code>xsl:fork</code></a>
is used in a context where streaming is required, each independent
instruction within the sequence constructor must be streamable, but
the analysis assumes that these instructions can all be evaluated
during a single pass of the streamed input document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The semantics of the instruction require a number of result
sequences to be computed during a single pass of the input. A
processor may interpret this as a request to use multiple threads.
However, implementations using a single thread are feasible, and
this instruction is not intended primarily as a means for
stylesheet authors to express their intentions with regard to
multi-threaded execution.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because multiple results are computed during a single pass of
the input, and then concatenated into a single sequence, this
instruction will generally involve some buffering of results. The
amount of memory used should not exceed that needed to hold the
results of the instruction. However, within this principle,
implementations may adopt a variety of strategies for evaluation;
for example, there may be cases where buffering of the input is
more efficient than buffering of output.</p>
<p>Generally, stylesheet authors indicate that buffering of input
is the preferred strategy by using the <a href=
"#func-copy-of"><code>copy-of</code></a> or <a href=
"#func-snapshot"><code>snapshot</code></a> functions, and indicate
that buffering of output is preferred by using <a href=
"#element-fork"><code>xsl:fork</code></a>. However, conformant
processors are not constrained in their choice of evaluation
strategies.</p>
</div>
<p>The following section describes the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction more
formally.</p>
<div class="div2">
<h3><a name="fork-instruction" id="fork-instruction"></a>16.1
<a href="#fork-instruction" style="text-decoration: none">The</a>
<code>xsl:fork</code> <a href="#fork-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-fork" id=
"element-fork"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:fork&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-sequence">xsl:sequence</a> | <a href=
"#element-fallback">xsl:fallback</a>))+ --&gt;<br />
&lt;/xsl:fork&gt;</code></p>
<p>The result of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction is the
sequence formed by concatenating the results of evaluating each of
its contained <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions, in
order. That is, the result can be determined by treating the
content as a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> and evaluating
it as such.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children will be ignored by an XSLT 3.0 processor.</p>
</div>
<p>By using the <a href="#element-fork"><code>xsl:fork</code></a>
instruction, the stylesheet author is suggesting to the <a title=
"processor" class="termref" href="#dt-processor">processor</a> that
it would be beneficial to evaluate the contained <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions
during a single pass of a streamed input document. The processor is
not <span class="verb">required</span> to take any notice of this
suggestion.</p>
<p>The presence of an <a href=
"#element-fork"><code>xsl:fork</code></a> instruction affects the
analysis of streamability, as described in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</div>
<div class="div2">
<h3><a name="splitting-examples" id="splitting-examples"></a>16.2
<a href="#splitting-examples" style=
"text-decoration: none">Examples of Splitting with Streamed
Data</a></h3>
<p>This section gives examples of how splitting using <a href=
"#element-fork"><code>xsl:fork</code></a> can be used to enable
streaming of input documents in cases where several results need to
be computed during a single pass over the input data.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36009" id=
"d7e36009"></a>Example: Splitting a Transaction File</div>
<p>Consider a transaction file that contains a sequence of debits
and credits:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>where the requirement is to split this into two separate files
containing credits and debits respectively.</p>
<p>This can be achieved in <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> code as
follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value ge 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value lt 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;
               
</pre></div>
<p>In the absence of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction, this would
not be streamable, because the sequence constructor includes two
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instructions. With the addition of
the <a href="#element-fork"><code>xsl:fork</code></a> instruction,
however, each <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is allowed to make a downwards selection.</p>
<p>One possible implementation model for this is as follows: a
single thread reads the source document, and sends parsing events
such as start-element and end-element to two other threads, each of
which is writing one of the two result documents. Each of these
implements the downwards-selecting path expression using a process
that waits until the next <code>transaction</code> start-element
event is received; when this event is received, the process
examines the <code>@value</code> attribute to determine whether or
not this transaction is to be copied; if it is, then all events
until the matching <code>transaction</code> end-element event are
copied to the serializer for the result document; otherwise, these
events are discarded.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36048" id=
"d7e36048"></a>Example: Arithmetic using Multiple Child Elements as
Operands</div>
<p>The rules for streamability do not allow two instructions in a
sequence constructor to both read child or descendant elements of
the context node, which makes it tricky to perform a calculation in
which multiple child elements act as operands. This restriction can
be avoided by using <a href=
"#element-fork"><code>xsl:fork</code></a>, as shown below, where
each of the two branches of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction selects
children of the context node.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;
</pre></div>
<p>A possible implementation strategy here is for events from the
XML parser to be sent to two separate agents (perhaps but not
necessarily running in different threads), one of which computes
<code>xs:decimal(price)</code> and the other
<code>xs:decimal(discount)</code>; on completion the results
computed by the two agents are appended to the sequence that forms
the value of the variable.</p>
<p>With this strategy, the processor would require sufficient
memory to hold the results of evaluating each branch of the fork.
If these results (unlike this example) are large, this could defeat
the purpose of streaming by requiring large amounts of memory;
nevertheless, this code is treated as streamable.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An alternative solution to this requirement is to use map
expressions: see <a href="#map-expressions"><i>21.1.4 Map
Expressions</i></a>.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36076" id=
"d7e36076"></a>Example: Deleting Elements, and Counting
Deletions</div>
<p>In this example the input is a narrative document containing
<code>note</code> elements at any level of nesting. The requirement
is to output a copy of the input document in which (a) the
<code>note</code> elements have been removed, and (b) a
<code>footnote</code> is added at the end indicating how many
<code>note</code> elements have been deleted.</p>
<div class="exampleInner">
<pre>
&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               
</pre></div>
<p>The <a href="#element-fork"><code>xsl:fork</code></a>
instruction contains two independent branches. These can therefore
be evaluated in the same pass over the input data. The first branch
(the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) causes everything except the <code>note</code>
elements to be copied to the result; the second instruction (the
literal result element <code>footnote</code>) outputs a count of
the number of descendant <code>note</code> elements.</p>
<p>Note that although the processing makes a single pass over the
input stream, there is some buffering of results required, because
the results of the instructions within the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction need to be
concatenated. In this case an intelligent implementation might be
able to restrict the buffered data to a single integer.</p>
<p>In a formal sense, however, the result is exactly the same as if
the <a href="#element-fork"><code>xsl:fork</code></a> element were
not there.</p>
<p>An alternative way of solving this example problem would be to
count the number of <code>note</code> elements using an
accumulator: see <a href="#accumulators"><i>18.2
Accumulators</i></a>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="regular-expressions" id="regular-expressions"></a>17
<a href="#regular-expressions" style=
"text-decoration: none">Regular Expressions</a></h2>
<p>The <a title="core function" class="termref" href=
"#dt-core-function">core function</a> library for XPath 3.0 defines
three <span>basic</span> functions that make use of regular
expressions:</p>
<ul>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>
returns a boolean result that indicates whether or not a string
matches a given regular expression.</p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup>
takes a string as input and returns a string obtained by replacing
all substrings that match a given regular expression with a
replacement string.</p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup>
returns a sequence of strings formed by breaking a supplied input
string at any separator that matches a given regular
expression.</p>
</li>
</ul>
<p>These functions are described in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<p>For more complex string processing than is possible using these
functions, XSLT provides an instruction <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
which is defined in this section.</p>
<p>The regular expressions used by this instruction, and the flags
that control the interpretation of these regular expressions,
<span class="verb">must</span> conform to the syntax defined in
<a href="#xpath-functions-30">[Functions and Operators]</a> (see
<a href=
"http://www.w3.org/TR/xpath-functions-30/#regex-syntax">Section
5.6.1 Regular expression syntax</a>
<sup><small>FO30</small></sup>), which is itself based on the
syntax defined in <a href="#xmlschema-2">[XML Schema Part
2]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XPath 3.0 adds a fourth function, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup>, whose
functionality is closely modeled on the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction described in this section, repackaging the facilities
in the form of a function.</p>
</div>
<div class="div2">
<h3><a name="analyze-string" id="analyze-string"></a>17.1 <a href=
"#analyze-string" style="text-decoration: none">The</a>
<code>xsl:analyze-string</code> <a href="#analyze-string" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-analyze-string" id=
"element-analyze-string"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:analyze-string<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;<b>regex</b> = { <var>string</var> }<br />
&#160;&#160;flags? = { <var>string</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-matching-substring">xsl:matching-substring</a>?, <a href=
"#element-non-matching-substring">xsl:non-matching-substring</a>?,
<a href="#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:analyze-string&gt;</code></p>
<p class="element-syntax"><a name="element-matching-substring" id=
"element-matching-substring"></a><code>&lt;xsl:matching-substring&gt;<br />

&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:matching-substring&gt;</code></p>
<p class="element-syntax"><a name="element-non-matching-substring"
id=
"element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring&gt;<br />

&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:non-matching-substring&gt;</code></p>
<p>The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction takes as input a string (the result of evaluating the
expression in the <code>select</code> attribute) and a regular
expression (the effective value of the <code>regex</code>
attribute).</p>
<p>If the result of evaluating the <code>select</code> expression
<span>is an empty sequence, it is treated as a zero-length string.
If the value</span> is not a string, it is converted to a string by
applying the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion
rules</a>.</p>
<p>The <code>flags</code> attribute may be used to control the
interpretation of the regular expression. If the attribute is
omitted, the effect is the same as supplying a zero-length string.
This is interpreted in the same way as the <code>$flags</code>
attribute of the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup>.
Specifically, if it contains the letter <code>m</code>, the match
operates in multiline mode. If it contains the letter
<code>s</code>, it operates in dot-all mode. If it contains the
letter <code>i</code>, it operates in case-insensitive mode. If it
contains the letter <code>x</code>, then whitespace within the
regular expression is ignored. For more detailed specifications of
these modes, see <a href="#xpath-functions-30">[Functions and
Operators]</a> (<a href=
"http://www.w3.org/TR/xpath-functions-30/#flags">Section 5.6.1.1
Flags</a> <sup><small>FO30</small></sup>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because the <code>regex</code> attribute is an attribute value
template, curly brackets within the regular expression must be
doubled. For example, to match a sequence of one to five
characters, write <code>regex=".{{1,5}}"</code>. For regular
expressions containing many curly brackets it may be more
convenient to use a notation such as
<code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or to use a
variable.</p>
</div>
<p>The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction may have two child elements: <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>.
Both elements are optional, and neither may appear more than once.
At least one of them must be present. If both are present, the
<a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
element must come first.</p>
<p>The content of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction must take one of the following forms:</p>
<ol class="enumar">
<li>
<p>A single <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
<li>
<p>A single <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
<li>
<p>A single <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction, followed by a single <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
</ol>
<p><a name="err-XTSE1130" id="err-XTSE1130"><span class=
"error">[ERR XTSE1130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction contains neither an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
nor an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
elements among the children of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction are ignored by an XSLT 2.0 <span>or 3.0</span>
processor, but allow fallback behavior to be defined when the
stylesheet is used with an XSLT 1.0 processor operating with
forwards-compatible behavior.</p>
<p>This instruction is designed to process all the non-overlapping
substrings of the input string that match the regular expression
supplied.</p>
<p><a name="err-XTDE1140" id="err-XTDE1140"><span class=
"error">[ERR XTDE1140]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>regex</code>
attribute does not conform to the <span class=
"verb">required</span> syntax for regular expressions, as specified
in <a href="#xpath-functions-30">[Functions and Operators]</a>. If
the regular expression is known statically (for example, if the
attribute does not contain any <a title="expression" class=
"termref" href="#dt-expression">expressions</a> enclosed in curly
brackets) then the processor <span class="verb">may</span> signal
the error as a <a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p><a name="err-XTDE1145" id="err-XTDE1145"><span class=
"error">[ERR XTDE1145]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>flags</code>
attribute has a value other than the values defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. If the value
of the attribute is known statically (for example, if the attribute
does not contain any <a title="expression" class="termref" href=
"#dt-expression">expressions</a> enclosed in curly brackets) then
the processor <span class="verb">may</span> signal the error as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p>To explain the behavior of the instruction it is useful to
consider an input string of length <var>N</var> characters as
having <var>N+1</var> inter-character positions, including one just
before the first character and one just after the last. Each of
these positions is a possible position for testing whether the
regular expression matches. These positions are numbered from zero
to <code>N</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <b>character</b>, here as elsewhere in this
specification, means a Unicode codepoint. When strings are held in
decomposed form, the multiple codepoints representing a composite
character are considered to be multiple characters. A codepoint
greater than 65535 is considered as one character, not as a
surrogate pair.</p>
</div>
<p>The processor starts by setting the current position to position
zero, and the current non-matching substring to a zero-length
string. It then does the following repeatedly:</p>
<ol class="enumar">
<li>
<p>Test whether the regular expression matches at the current
position.</p>
</li>
<li>
<p>If there is a match:</p>
<ol class="enumla">
<li>
<p>If the current non-matching substring has length greater than
zero, evaluate the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
sequence constructor with the current non-matching substring as the
context item.</p>
</li>
<li>
<p>Reset the current non-matching substring to a zero-length
string.</p>
</li>
<li>
<p>Evaluate the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
sequence constructor with the matching substring as the context
item.</p>
</li>
<li>
<p>Do the appropriate one of of the following:</p>
<ol class="enumlr">
<li>
<p>If the matching substring is non-zero length, set the current
position to coincide with the end of the matching substring, exit,
and repeat.</p>
</li>
<li>
<p>If the matching substring is zero length and the current
position is at the end of the input string, exit.</p>
</li>
<li>
<p>If the matching substring is zero length and the current
position is not at the end of the input string, add the character
that immediately follows the current position to the current
non-matching substring, set the current position to the position
immediately after this character, exit, and repeat.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>If there is no match:</p>
<ol class="enumla">
<li>
<p>If the current position is the last position (that is, just
after the last character):</p>
<ol class="enumlr">
<li>
<p>If the current non-matching substring has length greater than
zero, evaluate the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
sequence constructor with the current non-matching substring as the
context item.</p>
</li>
<li>
<p>Exit.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, add the character at the current position to the
current non-matching substring, increment the current position, and
repeat.</p>
</li>
</ol>
</li>
</ol>
<p><span>When the matcher is looking for a match at a particular
starting position and there are</span> several alternatives within
the regular expression that match at this position in the input
string, then the match that is chosen is the first alternative that
matches. For example, if the input string is <code>The quick brown
fox jumps</code> and the regular expression is
<code>jump|jumps</code>, then the match that is chosen is
<code>jump</code>.</p>
<p>The input string is thus partitioned into a sequence of
substrings, some of which match the regular expression, others
which do not match it. <span>Each non-matching substring will
contain at least one character, but a matching substring may be
zero-length.</span> This sequence of substrings is processed using
the <span>instructions within the contained <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
elements</span>. A matching substring is processed using the
<a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
element, a non-matching substring using the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element. Each of these elements takes a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> as its content.
If the element is absent, the effect is the same as if it were
present with empty content. In processing each substring, the
contents of the substring will be the <a title="context item"
class="termref" href="#dt-context-item">context item</a> (as a
value of type <code>xs:string</code>); the position of the
substring within the sequence of matching and non-matching
substrings will be the <a title="context position" class="termref"
href="#dt-context-position">context position</a>; and the number of
matching and non-matching substrings will be the <a title=
"context size" class="termref" href="#dt-context-size">context
size</a>.</p>
</div>
<div class="div2">
<h3><a name="func-regex-group" id="func-regex-group"></a>17.2
<a href="#func-regex-group" style=
"text-decoration: none">fn:regex-group</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the string captured by a parenthesized subexpression of
the regular expression used during evaluation of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-regex-group" id=
"function-regex-group"></a></p>
<div class="proto"><code class=
"function">regex-group</code>(<code class=
"arg">$group-number</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:integer</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-captured-substrings" id=
"dt-current-captured-substrings" title=
"current captured substrings"></a>While the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction is active, a set of <b>current captured substrings</b>
is available, corresponding to the parenthesized sub-expressions of
the regular expression.<span class="definition">]</span> These
captured substrings are accessible using the function <a href=
"#func-regex-group"><code>regex-group</code></a>. This function
takes an integer argument to identify the group, and returns a
string representing the captured substring.</p>
<p>The <var>N</var>th captured substring (where <var>N</var> &gt;
0) is the string matched by the subexpression contained by the
<var>N</var>th left parenthesis in the regex, <span>excluding any
non-capturing groups, which are written as
<code>(?:xxx)</code></span>. The zeroeth captured substring is the
string that matches the entire regex. This means that the value of
<code>regex-group(0)</code> is initially the same as the value of
<code>.</code> (dot).</p>
<p>The function returns the zero-length string if there is no
captured substring with the relevant number. This can occur for a
number of reasons:</p>
<ol class="enumar">
<li>
<p>The number is negative.</p>
</li>
<li>
<p>The regular expression does not contain a parenthesized
sub-expression with the given number.</p>
</li>
<li>
<p>The parenthesized sub-expression exists, and did not match any
part of the input string.</p>
</li>
<li>
<p>The parenthesized sub-expression exists, and matched a
zero-length substring of the input string.</p>
</li>
</ol>
<p>The set of captured substrings is a context variable with
dynamic scope. It is initially an empty sequence. During the
evaluation of an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction it is set to the sequence of matched substrings for
that regex match. During the evaluation of an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction or a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> or a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> it is set to an empty sequence. On completion of an
instruction that changes the value, the variable reverts to its
previous value.</p>
<p>The value of the <a title="current captured substrings" class=
"termref" href="#dt-current-captured-substrings">current captured
substrings</a> is unaffected through calls of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>,
or by expansion of named <a title="attribute set" class="termref"
href="#dt-attribute-set">attribute sets</a>.</p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="regex-examples" id="regex-examples"></a>17.3 <a href=
"#regex-examples" style="text-decoration: none">Examples of Regular
Expression Matching</a></h3>
<div class="example">
<div class="exampleHeader"><a name="d7e36745" id=
"d7e36745"></a>Example: Replacing Characters by Elements</div>
<p>Problem: replace all newline characters in the
<code>abstract</code> element by empty <code>br</code>
elements:</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36760" id=
"d7e36760"></a>Example: Recognizing non-XML Markup Structure</div>
<p>Problem: replace all occurrences of <code>[...]</code> in the
<code>body</code> by <code>cite</code> elements, retaining the
content between the square brackets as the content of the new
element.</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
<p>Note that this simple approach fails if the <code>body</code>
element contains markup that needs to be retained. In this case it
is necessary to apply the regular expression processing to each
text node individually. If the <code>[...]</code> constructs span
multiple text nodes (for example, because there are elements within
the square brackets) then it probably becomes necessary to make two
or more passes over the data.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36786" id=
"d7e36786"></a>Example: Parsing a Date</div>
<p>Problem: the input string contains a date such as <code>23 March
2002</code>. Convert it to the form <code>2002-03-23</code>.</p>
<p>Solution (with no error handling if the input format is
incorrect):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
<p>Note the use of <code>normalize-space</code> to simplify the
work done by the regular expression, and the use of doubled curly
brackets because the <code>regex</code> attribute is an attribute
value template.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36809" id=
"d7e36809"></a>Example: Matching Zero-Length Strings</div>
<p>This example removes all empty and whitespace-only lines from a
file.</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="unparsed-text('in.txt')"
                    regex="^[\t ]*$" flags="m" expand-text="yes"&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36816" id=
"d7e36816"></a>Example: Parsing comma-separated values</div>
<p>There are many variants of CSV formats. This example is designed
to handle input where:</p>
<ul>
<li>
<p>Each record occupies one line.</p>
</li>
<li>
<p>Fields are separated by commas.</p>
</li>
<li>
<p>Quotation marks around a field are optional, unless the field
contains a comma or quotation mark, in which case they are
mandatory.</p>
</li>
<li>
<p>A quotation mark within the value of a field is represented by a
pair of two adjacent quotation marks.</p>
</li>
</ul>
<p>For example, the input record:</p>
<div class="exampleInner">
<pre>
Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K
</pre></div>
<p>contains six fields, specifically:</p>
<ul>
<li>
<p>Ten Thousand</p>
</li>
<li>
<p>10000</p>
</li>
<li>
<p>&lt;zero-length-string&gt;</p>
</li>
<li>
<p>10,000</p>
</li>
<li>
<p>It's "10 Grand", mister</p>
</li>
<li>
<p>10K</p>
</li>
</ul>
<p>The following code parses such CSV input into an XML structure
containing <code>row</code> and <code>col</code> elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:for-each select="unparsed-text-lines('in.csv')" expand-text="yes"&gt;
  &lt;row&gt;
    &lt;xsl:analyze-string select="." 
                        regex='(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))'&gt;
      &lt;xsl:matching-substring&gt;
        &lt;col&gt;{replace(regex-group(1), '""', '"')||regex-group(2)}&lt;/col&gt;
      &lt;/xsl:matching-substring&gt;
    &lt;/xsl:analyze-string&gt;
  &lt;/row&gt;
&lt;/xsl:for-each&gt;
</pre></div>
<p>Note that because this regular expression matches a zero-length
string, it is not permitted in XSLT 2.0.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="streaming" id="streaming"></a>18 <a href="#streaming"
style="text-decoration: none">Streaming</a></h2>
<p>XSLT 3.0 introduces a number of constructs that are specifically
designed to enable streamed applications to be written, but which
are also useful in their own right; it also includes some features
that are very specialized to streaming. The constructs in this
latter category are described in this section.</p>
<div class="div2">
<h3><a name="stream-instruction" id="stream-instruction"></a>18.1
<a href="#stream-instruction" style="text-decoration: none">The</a>
<code>xsl:stream</code> <a href="#stream-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-stream" id=
"element-stream"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:stream<br />
&#160;&#160;<b>href</b> = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:stream&gt;</code></p>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction reads a source document whose URI is supplied, and
processes the content of the document using streaming by evaluating
the contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>For example, if a document represents a book holding a sequence
of chapters, then the following code can be used to split the book
into multiple XML files, one per chapter, without allocating memory
to hold the entire book in memory at one time:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="book.xml"&gt;
  &lt;xsl:for-each select="book"&gt;             
    &lt;xsl:for-each select="chapter"&gt;
      &lt;xsl:result-document href="chapter{position()}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;  
&lt;/xsl:stream&gt;
</pre></div>
<p>The document to be read is determined by the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>href</code>
attribute (which is defined as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>).
<span>This <span class="verb">must</span> be a valid URI reference.
If it is an absolute URI reference, it is used as is; if it is a
relative URI reference, it is made absolute by resolving it against
the base URI of the <a href=
"#element-stream"><code>xsl:stream</code></a> element</span>. The
process of obtaining a document node given a URI is the same as for
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function. However, unlike the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, the <a href="#element-stream"><code>xsl:stream</code></a>
instruction offers no guarantee that the resulting document will be
stable (that is, that multiple calls specifying the same URI will
return the same document).</p>
<p>Specifically, if the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is
evaluated several times (or if different <a href=
"#element-stream"><code>xsl:stream</code></a> instructions are
evaluated) with the same URI (<span>after making it
absolute</span>) as the value of the <code>href</code> attribute,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the same nodes or different nodes are returned on each occasion; it
is also possible that the actual document content will be
different.</p>
<p>The result of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is the
same as the result of the following (non-streaming) process:</p>
<ol class="enumar">
<li>
<p>The source document is read from the supplied URI and parsed to
form an instance of the XDM data model. This is the <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.</p>
</li>
<li>
<p>The contained sequence constructor is evaluated with the
<span>document</span> node of the <a title="streamed document"
class="termref" href="#dt-streamed-document">streamed document</a>
as the context item, and with the context position and context size
set to one, and the resulting sequence is returned as the result of
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</li>
</ol>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, as
assessed using the streamability analysis in <a href=
"#streamability"><i>19 Streamability</i></a>. The consequences of
being or not being guaranteed streamable depend on the processor
conformance level, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The name of the instruction reflects its intended usage, to
process an input document using streaming. However, a processor
that does not offer the <a title="streaming feature" class=
"termref" href="#dt-streaming-feature">streaming feature</a> must
still implement the instruction (without being required to use
streamed evaluation or to check its streamability); and processors
that do offer the <a title="streaming feature" class="termref"
href="#dt-streaming-feature">streaming feature</a> are also
required to provide a mode of execution in which the construct is
evaluated without streaming if it fails the streamability
criteria.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The rules for streamability ensure that the sequence constructor
(and therefore the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) cannot
return any nodes from the <a title="streamed document" class=
"termref" href="#dt-streamed-document">streamed document</a>. For
example, it cannot contain the instruction <code>&lt;xsl:sequence
select="//chapter"/&gt;</code>. If nodes from this document are to
be returned, they must first be copied, for example by <span>using
the <a href="#element-copy-of"><code>xsl:copy-of</code></a>
instruction or by</span> calling the <a href=
"#func-copy-of"><code>copy-of</code></a> or <a href=
"#func-snapshot"><code>snapshot</code></a> functions.</p>
<p>Because the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction cannot
return nodes from the streamed document, any nodes it does return
will be conventional (unstreamed) nodes that can be processed
without restriction. For example, if <a href=
"#element-stream"><code>xsl:stream</code></a> is invoked within a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>
<code>f:firstChapter</code>, and the sequence constructor consists
of the instruction <code>&lt;xsl:copy-of
select="//chapter"/&gt;</code>, then the calling code can
manipulate the resulting <code>chapter</code> elements as ordinary
trees rooted at parentless element nodes.</p>
</div>
<div class="div3">
<h4><a name="stream-validation" id="stream-validation"></a>18.1.1
<a href="#stream-validation" style=
"text-decoration: none">Validation of Streamed Documents</a></h4>
<p>The <code>validation</code> and <code>type</code> attributes of
<a href="#element-stream"><code>xsl:stream</code></a> may be used
to control schema validation of the <a title="streamed document"
class="termref" href="#dt-streamed-document">streamed document</a>.
They have the same effect as the corresponding attributes of the
<a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction
when applied to a document node, except that the copy that is
produced is itself a streamed document. The process is described in
more detail in <a href="#validating-document-nodes"><i>24.2.2
Validating Document Nodes</i></a>.</p>
<p>These two attributes are both optional, and if one is specified
then the other <span class="verb">must</span> be omitted.</p>
<p>The presence of a <code>validation</code> or <code>type</code>
attribute on an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction causes
any <code>input-type-annotations</code> attribute to have no effect
on any document read using that instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In effect, setting <code>validation</code> to
<code>strict</code> or <code>lax</code>, or supplying the
<code>type</code> attribute, requests document-level validation of
the input as it is read. Setting <code>validation="preserve"</code>
indicates that if the incoming document contains type annotations
(for example, produced by validating the output of a previous step
in a streaming pipeline) then they should be retained, while the
value <code>strip</code> indicates that any such type annotations
should be dropped.</p>
<p>It is a consequence of the way validation is defined in XSD that
the type annotation of an element node can be determined during the
processing of its start tag, although the actual validity of the
element is not known until the end tag is encountered. When
validation is requested, a streamed document should not present
data to the stylesheet except to the extent that such data could
form the leading part of a valid document. If the document proves
to be invalid, the processor should not pass invalid data to the
stylesheet to be processed, but should immediately signal the
appropriate error. For the purposes of <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a>, this error can only be
caught at the level of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction that
initiated validation, not at a finer level. If validation errors
are caught in this way, any output that has been computed up to the
point of the error is not added to the final result tree; the
mechanisms to achieve this may use memory, which may reduce the
efficacy of streaming.</p>
<p>The analyis of guaranteed streamability (see <a href=
"#streamability"><i>19 Streamability</i></a>) takes no account of
information that might be obtained from a schema-aware static
analysis of the stylesheet. Implementations may, however, be able
to use streaming strategies for stylesheets that are not
guaranteed-streamable, by taking advantage of such information. For
example, an implementation might be able to treat the expression
<code>.//title</code> as <a title="striding" class="termref" href=
"#dt-striding">striding</a> rather than <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a> if it can establish from
knowledge of the schema that two <code>title</code> elements will
never overlap.</p>
</div>
</div>
<div class="div3">
<h4><a name="stream-examples" id="stream-examples"></a>18.1.2
<a href="#stream-examples" style="text-decoration: none">Examples
of</a> <code>xsl:stream</code> <a href="#stream-examples" style=
"text-decoration: none"></a></h4>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction can be used to initiate processing of a document using
streaming with a variety of coding styles, illustrated in the
examples below.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37150" id=
"d7e37150"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with Aggregate
Functions</div>
<p>The following example computes the number of transactions in a
transaction file</p>
<p>Input:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>Stylesheet code:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
  &lt;/count&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;count&gt;2&lt;/count&gt;
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>The literal result element <code>count</code> has the same sweep
as the <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction has the same sweep as its <code>select</code>
expression.</p>
</li>
<li>
<p>The call to <code>count</code> has the same sweep as its
argument.</p>
</li>
<li>
<p>The argument to <code>count</code> is a
<code>RelativePathExpr</code> that takes the form of a motionless
pattern and appears in an inspection context (the argument to
<code>count()</code>); the sweep of the
<code>RelativePathExpr</code> and therefore of the entire body of
the <code>xsl:stream</code> instruction is therefore <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>The following example computes the highest-value transaction in
the same input file:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
  &lt;/maxValue&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;maxValue&gt;12.51&lt;/maxValue&gt;
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>The literal result element <code>maxValue</code> has the same
sweep as the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction has the same sweep as its <code>select</code>
expression.</p>
</li>
<li>
<p>The call to <code>max</code> has the same sweep as its
argument.</p>
</li>
<li>
<p>The argument to <code>max</code> is a
<code>RelativePathExpr</code> whose two operands are the
<code>RelativePathExpr</code> <code>transactions/transaction</code>
and the <code>AxisStep</code> <code>@value</code>. The first
operand <code>transactions/transaction</code> has <span><a title=
"striding" class="termref" href="#dt-striding">striding</a>
<a title="posture" class="termref" href=
"#dt-posture">posture</a></span>. The second operand
<code>@value</code>, given that it appears in a node value context,
is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>. The <code>RelativePathExpr</code>
argument to <code>max</code> is therefore consuming.</p>
</li>
<li>
<p>The entire body of the <code>xsl:stream</code> instruction is
therefore <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>To compute both the count and the maximum value in a single pass
over the input, it is possible to use two variables.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37306" id=
"d7e37306"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-for-each"><code>xsl:for-each</code></a> to Process a
Collection of Input Documents</div>
<p>This example displays a list of the chapter titles extracted
from each book in a collection of books.</p>
<p>Each input document is assumed to have a structure such as:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;
</pre></div>
<p>Stylesheet code:</p>
<div class="exampleInner">
<pre>
&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:stream href="{.}"&gt;
      &lt;xsl:for-each select="book"&gt;
        &lt;xsl:for-each select="chapter"&gt;
           &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:stream&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This example uses the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>
uri-collection</code></a><sup><small>FO30</small></sup> to obtain
the document URIs of all the documents in a collection, so that
each one can be processed in turn using <a href=
"#element-stream"><code>xsl:stream</code></a>.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37338" id=
"d7e37338"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-iterate"><code>xsl:iterate</code></a></div>
<p>This example assumes that the input is a book with multiple
chapters, as shown in the previous example, with the page count for
each chapter given as an attribute of the chapter. The
transformation determines the starting page number for each chapter
by accumulating the page counts for previous chapters, and rounding
up to an odd number if necessary.</p>
<div class="exampleInner">
<pre>
&lt;chapter-start-page&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:stream&gt;
&lt;/chapter-start-page&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37355" id=
"d7e37355"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></div>
<p>This example assumes that the input is a book with multiple
chapters, and that each chapter belongs to a part, which is present
as an attribute of the chapter (for example, chapters 1-4 might
constitute Part 1, the next three chapters forming Part 2, and so
on):</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;
</pre></div>
<p>The transformation copies the full text of the chapters,
creating an extra level of hierarchy for the parts.</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:for-each select="book"&gt;
         &lt;xsl:for-each-group select="chapter" group-adjacent="data(@part)"
                             bind-group="g" bind-grouping-key="k"&gt;
            &lt;part number="{$k}"&gt;
               &lt;xsl:copy-of select="$g"/&gt;
            &lt;/part&gt;
         &lt;/xsl:for-each-group&gt;
      &lt;/xsl:for-each&gt;
   &lt;/xsl:stream&gt;
&lt;/book&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter title="The first chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter title="The second chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter title="The fifth chapter of book A" part="2"&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37376" id=
"d7e37376"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></div>
<p>This example copies an XML document while deleting all the
<code>ednote</code> elements at any level of the tree, together
with their descendants. This example is a complete stylesheet,
which is intended to be evaluated by nominating <code>main</code>
as the <a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a>. The use of
<code>on-no-match="deep-copy"</code> in the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration means that
the built-in template rule copies nodes unchanged, except where
overridden by a user-defined template rule.</p>
<div class="exampleInner">
<pre>
&lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streamable="yes" 
                                on-no-match="shallow-copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:stream&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;
</pre></div>
<p>Additional template rules could be added to process other
elements and attributes in the same pass through the data: for
example, to modify the value of a <code>last-updated</code>
attribute (wherever it appears) to the current date and time, the
following rule suffices:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="@last-updated"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="accumulators" id="accumulators"></a>18.2 <a href=
"#accumulators" style="text-decoration: none">Accumulators</a></h3>
<p>Accumulators are introduced in XSLT 3.0 to enable data that is
read during streamed processing of a document to be accumulated,
processed or retained for later use. However, they may equally be
used with non-streamed processing.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-accumulator" id="dt-accumulator" title="accumulator"></a>An
<b>accumulator</b> defines a value that is computed progressively
while processing the nodes of a document in document order. The
value for a given node is available via a pair of functions, one
giving the value for a node before processing its descendants, and
one giving the value for the same node after processing its
descendants.<span class="definition">]</span></p>
<p>The following sections give first, the syntax rules for defining
an accumulator; then an informal description of the semantics; then
a more formal definition; and finally, examples. But to illustrate
the concept intuitively, the following simple example shows how an
accumulator can be used for numbering of nodes:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37424" id=
"d7e37424"></a>Example: Numbering Figures within a Chapter</div>
<p>This example assumes document input in which <code>figure</code>
elements can appear within <code>chapter</code> elements (which we
assume are not nested), and the requirement is to render the
figures with a caption that includes the figure number within its
containing chapter.</p>
<p>When the document is processed using streaming, the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not
available, so a solution using accumulators is needed.</p>
<p>The required accumulator can be defined and used like this:</p>
<div class="exampleInner">
<pre>
   &lt;xsl:accumulator name="figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" new-value="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" new-value="$value + 1"/&gt;
   &lt;/xsl:accumulator&gt;
   
   &lt;xsl:mode streamable="yes"/&gt;
   &lt;xsl:template match="figure"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure &lt;xsl:value-of select="accumulator-before('figNr')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;  
                  
</pre></div>
</div>
<div class="div3">
<h4><a name="accumulator-declaration" id=
"accumulator-declaration"></a>18.2.1 <a href=
"#accumulator-declaration" style="text-decoration: none">Declaring
an Accumulator</a></h4>
<p class="element-syntax"><a name="element-accumulator" id=
"element-accumulator"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:accumulator<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>initial-value</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br />
&lt;/xsl:accumulator&gt;</code></p>
<p class="element-syntax"><a name="element-accumulator-rule" id=
"element-accumulator-rule"></a><code>&lt;xsl:accumulator-rule<br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;phase? = "start" | "end"<br />
&#160;&#160;<b>new-value</b> =
<var>expression</var>&#160;/&gt;</code></p>
<p>An <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> element is
a <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of an accumulator. The
<code>name</code> attribute defines the name of the accumulator.
The value of the <code>name</code> attribute is an <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>An <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declaration
can only appear as a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element in a stylesheet module.</p>
<p>The <span>functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a></span>
return, respectively, the value of the accumulator before visiting
the descendants of a given node, and the value after visiting the
descendants of a node. Each of these functions <span>takes a single
argument, the name of the accumulator</span>, and the function
applies implicitly to the context node. The type of the return
value (for both functions) is determined by the <code>as</code>
attribute of the <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>
element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-accumulator-function" id="dt-accumulator-function" title=
"accumulator function"></a>The functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> are
referred to as the <b>accumulator functions</b>.<span class=
"definition">]</span></p>
<p>When streaming, <span>these functions</span> can only be called
in specific circumstances: specifically, when the context item is
the node at the current position in the streamed document. This
condition cannot always be detected statically. Unlike most of the
rules for streamability, therefore, the use of accumulators gives
rise to the possibility of dynamic errors if stylesheet code does
not follow the rules for streaming.</p>
<p>The initial value of the accumulator is obtained by evaluating
the expression in the <code>initial-value</code> attribute. The
values for individual nodes in a tree are obtained by applying the
rules contained within the <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>
declaration, as described in subsequent sections.</p>
<p>The expression in the <code>initial-value</code> attribute is
evaluated with the same static and dynamic context as the
expression in the <code>select</code> attribute of a global
variable declaration.</p>
<p>The expression in the <code>new-value</code> attribute of
<a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
is evaluated with a static context that follows the normal rules
for expressions in stylesheets, except that:</p>
<ul>
<li>
<p>An additional variable is present in the context. The name of
this variable is <code>value</code> (in no namespace), and its type
is the type that appears in the <code>as</code> attribute of the
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration.</p>
</li>
<li>
<p>The context item for evaluation of the expression will always be
a node that matches the <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> in the <code>match</code> attribute.</p>
</li>
</ul>
<p>The result of both the <code>initial-value</code> and
<code>new-value</code> expressions is converted to the type
declared in the <code>as</code> attribute by applying the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. A
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs if conversion is not possible. The <code>as</code>
attribute defaults to <code>item()*</code>.</p>
<p>The effect of the <code>streamable</code> attribute is defined
in <a href="#streamability-of-accumulators"><i>18.2.7 Streamability
of Accumulators</i></a>.</p>
</div>
<div class="div3">
<h4><a name="accumulator-informal-rules" id=
"accumulator-informal-rules"></a>18.2.2 <a href=
"#accumulator-informal-rules" style=
"text-decoration: none">Informal Model for Accumulators</a></h4>
<p>Informally, an accumulator is evaluated by traversing a document
in tree-walking order. Each node is visited twice, once before
processing its descendants, and once after processing its
descendants. For consistency, this applies even to leaf nodes: each
is visited twice. Attribute and namespace nodes, however, are not
visited.</p>
<p>Before the traversal starts, a variable (called the accumulator
variable) is initialized to the value of the expression given as
the <code>initial-value</code> attribute.</p>
<p>On each node visit, the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
elements are examined to see if there is a matching rule. For a
match to occur, the pattern in the <code>match</code> attribute
must match the node, and the <code>phase</code> attribute must be
<code>start</code> if this is the first visit, and <code>end</code>
if it is the second visit. If there is a matching rule, then a new
value is computed for the accumulator variable using the expression
contained in that rule's <code>new-value</code> attribute. If there
is more than one matching rule, the last in document order is used.
If there is no matching rule, the value of the accumulator variable
does not change.</p>
<p>Each node is labeled with a pre-descent value for the
accumulator, which is the value of the accumulator variable
immediately <em>after</em> processing the first visit to that node,
and with a post-descent value for the accumulator, which is the
value of the accumulator variable immediately <em>before</em>
processing the second visit.</p>
<p>The function <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
delivers the pre-descent value of the accumulator at the context
node; the function <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
delivers the post-descent value of the accumulator at the context
node.</p>
<p>Although this description is expressed in procedural terms, it
can be seen that the two values of the accumulator for any given
node depend only on the node and its preceding and (in the case of
the post-descent value) descendant nodes. Calculation of both
values is therefore deterministic and free of side-effects;
moreover, it is clear that the values can be computed during a
streaming pass of a document, provided that the rules themselves
use only information that is available without repositioning the
input stream.</p>
<p>It is permitted for the <code>new-value</code> expression of an
accumulator rule to invoke an accumulator function. The rules
ensure that a rule with <code>phase="start"</code> can only call
the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
function, and a a rule with <code>phase="end"</code> can only call
the <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function. When such function calls exist in an accumulator rule,
they impose a dependency of one accumulator on another; a dynamic
error occurs if this dependency is cyclic.</p>
</div>
<div class="div3">
<h4><a name="accumulator-formal-rules" id=
"accumulator-formal-rules"></a>18.2.3 <a href=
"#accumulator-formal-rules" style="text-decoration: none">Formal
Model for Accumulators</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-traversal" id="dt-traversal" title="traversal"></a>A
<b>traversal</b> of a tree is a sequence of <a title=
"traversal-event" class="termref" href=
"#dt-traversal-event">traversal events</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-traversal-event" id="dt-traversal-event" title=
"traversal-event"></a>a <b>traversal event</b> (shortened to
<b>event</b> in this section) is a pair comprising a phase (start
or end) and a node.<span class="definition">]</span> It is modelled
as a map with two entries: <code>map{"phase" : p, "node" :
n}</code> where p is the string <code>"start"</code> or
<code>"end"</code> and <code>n</code> is a node.</p>
<p>The traversal of a document contains two traversal events for
each node in the tree, other than attribute and namespace nodes.
One of these events (the "start event") has phase = "start", the
other (the "end event") has phase = "end".</p>
<p>The order of traversal events within a traversal is such that,
given any two nodes <var>M</var> and <var>N</var> with start/end
events denoted by <var>M0</var>, <var>M1</var>, <var>N0</var>, and
<var>N1</var>, :</p>
<ul>
<li>
<p>For any node <var>N</var>, <var>N0</var> precedes
<var>N1</var>;</p>
</li>
<li>
<p>If <var>M</var> is an ancestor of <var>N</var> then
<var>M0</var> precedes <var>N0</var> and <var>N1</var> precedes
<var>M1</var>;</p>
</li>
<li>
<p>If <var>M</var> is on the preceding axis of <var>N</var> then
<var>M1</var> precedes <var>N0</var>.</p>
</li>
</ul>
<p>The accumulator defines a (private) delta function <var>Δ</var>.
The delta function computes the value of the accumulator for one
traversal event in terms of its value for the previous traversal
event. The function is defined as follows:</p>
<ol class="enumar">
<li>
<p>The signature of <var>Δ</var> is <code>function ($value as T,
$event as map(*)) as T</code>, where <var>T</var> is the sequence
type declared in the <code>as</code> attribute of the accumulator
declaration;</p>
</li>
<li>
<p>The implementation of the function is equivalent to the
following algorithm:</p>
<ol class="enumla">
<li>
<p>Let <var>R</var> be the set of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
elements among the children of the accumulator declaration whose
<code>phase</code> attribute equals <code>$event("phase")</code>
and whose <code>match</code> attribute is a <a title="pattern"
class="termref" href="#dt-pattern">pattern</a> that matches
<code>$event("node")</code></p>
</li>
<li>
<p>If <var>R</var> is empty, return <code>$value</code></p>
</li>
<li>
<p>Let <var>Q</var> be the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
in <var>R</var> that is last in document order</p>
</li>
<li>
<p>Return the value of the expression in the
<code>next-value</code> attribute of <code>Q</code>, evaluating the
expression with a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> set to
<code>$event("node")</code> and with a dynamic context that binds
the variable whose name is the accumulator name to the value
<code>$value</code></p>
</li>
</ol>
</li>
</ol>
<p>For every node <var>N</var>, other than attribute and namespace
nodes, the accumulator defines a pre-descent value <var>B(N)</var>
and a post-descent value <var>A(N)</var> whose values are as
follows:</p>
<ol class="enumar">
<li>
<p>Let <var>T</var> be the <a title="traversal" class="termref"
href="#dt-traversal">traversal</a> of the tree rooted at
<code>fn:root(N)</code></p>
</li>
<li>
<p>Let <var>SB</var> be the subsequence of <var>T</var> starting at
the first event in <var>T</var> and ending with the start event for
node <var>N</var> (that is, the event <code>map{ "phase":"start",
"node":N }</code>)</p>
</li>
<li>
<p>Let <var>SA</var> be the subsequence of <var>T</var> starting at
the first event in <var>T</var>, and ending with the event that
immediately precedes the end event for node <var>N</var> (that is,
the event <code>map{ "phase":"end", "node":N }</code>)</p>
</li>
<li>
<p>Let <var>Z</var> be the result of evaluating the expression
contained in the <code>initial-value</code> attribute of the
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration, using the same context as is used for evaluating
global variables</p>
</li>
<li>
<p>Then the pre-descent value <var>B(N)</var> is the value of
<code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value
<var>A(N)</var> is the value of <code>fn:fold-left(SA, Z,
Δ)</code></p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="func-accumulator-before" id=
"func-accumulator-before"></a>18.2.4 <a href=
"#func-accumulator-before" style=
"text-decoration: none">fn:accumulator-before</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the pre-descent value of the selected accumulator at the
context node</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-accumulator-before" id=
"function-accumulator-before"></a></p>
<div class="proto"><code class=
"function">accumulator-before</code>(<code class=
"arg">$name</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>)<code class="as">&#160;as&#160;</code><code class="return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$name</code> argument specifies the name of the
<a title="accumulator" class="termref" href=
"#dt-accumulator">accumulator</a>. The value of the argument
<span class="verb">must</span> be a <span>string containing an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The function returns the pre-descent value <var>B(N)</var>of the
selected accumulator where <var>N</var> is the context node, as
defined in <a href="#accumulator-formal-rules"><i>18.2.3 Formal
Model for Accumulators</i></a></p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE3340" id="err-XTDE3340"><span class=
"error">[ERR XTDE3340]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration visible in the <a title="package" class="termref" href=
"#dt-package">package</a> in which the function call appears. If
the processor is able to detect the error statically (for example,
when the argument is supplied as a string literal), then the
processor <span class="verb">may</span> optionally signal this as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p><a name="err-XTDE3350" id="err-XTDE3350"><span class=
"error">[ERR XTDE3350]</span></a> It is a <a title="" class=
"termref" href="#">dynamic error</a> to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when there is no <a title="context item" class="termref"
href="#dt-context-item">context item</a>.</p>
<p><a name="err-XTTE3360" id="err-XTTE3360"><span class=
"error">[ERR XTTE3360]</span></a> It is a <a title="" class=
"termref" href="#">type error</a> to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node, or when it is an
attribute or namespace node.</p>
<p><a name="err-XTDE3370" id="err-XTDE3370"><span class=
"error">[ERR XTDE3370]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called and (a) the accumulator has the property
<code>streamable="no"</code>, and (b) the context item is a node in
a streamed document.</p>
<p><a name="err-XTDE3380" id="err-XTDE3380"><span class=
"error">[ERR XTDE3380]</span></a> If the accumulator is declared
with the attribute <code>streamable="yes"</code> then it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of either (a) the sequence constructor
contained in a template rule invoked in a <a title="mode" class=
"termref" href="#dt-mode">mode</a> declared with
<code>streamable="yes"</code>, or (b) the sequence constructor
contained in an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, or both.
Call the nearest such construct in the chain of causation the
<b>controlling sequence constructor</b>.</p>
<p><a name="err-XTDE3390" id="err-XTDE3390"><span class=
"error">[ERR XTDE3390]</span></a> If the accumulator is declared
with the attribute <code>streamable="yes"</code> then it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the context item at the point of
evaluating this function is the same node as the context item for
the evaluation of the <b>controlling sequence constructor</b>.</p>
<p><a name="err-XTDE3400" id="err-XTDE3400"><span class=
"error">[ERR XTDE3400]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function for an accumulator <var>A</var> is evaluated <b>in the
course of</b> evaluating the <code>new-value</code> expression of
any accumulator rule for the same accumulator <var>A</var>.</p>
<p><a name="err-XTDE3410" id="err-XTDE3410"><span class=
"error">[ERR XTDE3410]</span></a> If the accumulator is declared
with the attribute <code>streamable="yes"</code> then it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of a <a title=
"pre-descent instruction" class="termref" href=
"#dt-pre-descent-instruction">pre-descent instruction</a> within
the <b>controlling sequence constructor</b>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Given the accumulator:</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="a" initial-value="1"&gt;
   &lt;xsl:accumulator-rule match="section" new-value="$value + 1"/&gt;
&lt;/xsl:accumulator&gt;
</pre></div>
<p>and the template rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:value-of select="accumulator-before('a')"/&gt;
   &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The stylesheet will precede the output from processing each
section with a section number that runs sequentially 1, 2, 3...
irrespective of the nesting of sections.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-accumulator-after" id=
"func-accumulator-after"></a>18.2.5 <a href=
"#func-accumulator-after" style=
"text-decoration: none">fn:accumulator-after</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the post-descent value of the selected accumulator at
the context node.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-accumulator-after" id=
"function-accumulator-after"></a></p>
<div class="proto"><code class=
"function">accumulator-after</code>(<code class=
"arg">$name</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>)<code class="as">&#160;as&#160;</code><code class="return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$name</code> argument specifies the name of the
<a title="accumulator" class="termref" href=
"#dt-accumulator">accumulator</a>. The value of the argument
<span class="verb">must</span> be a <span>string containing an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The function returns the post-descent value <var>A(N)</var> of
the selected accumulator where <var>N</var> is the context node, as
defined in <a href="#accumulator-formal-rules"><i>18.2.3 Formal
Model for Accumulators</i></a></p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>The following errors apply: <span class="error">[see <a href=
"#err-XTDE3340">ERR XTDE3340</a>]</span>, <span class="error">[see
<a href="#err-XTDE3350">ERR XTDE3350</a>]</span>, <span class=
"error">[see <a href="#err-XTTE3360">ERR XTTE3360</a>]</span>,
<span class="error">[see <a href="#err-XTDE3370">ERR
XTDE3370</a>]</span>, <span class="error">[see <a href=
"#err-XTDE3380">ERR XTDE3380</a>]</span>, <span class="error">[see
<a href="#err-XTDE3390">ERR XTDE3390</a>]</span>, <span class=
"error">[see <a href="#err-XTDE3400">ERR XTDE3400</a>]</span>.</p>
<p><a name="err-XTDE3420" id="err-XTDE3420"><span class=
"error">[ERR XTDE3420]</span></a> If the accumulator is declared
with the attribute <code>streamable="yes"</code> then it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of a <a title=
"post-descent instruction" class="termref" href=
"#dt-post-descent-instruction">post-descent instruction</a> within
the <b>controlling sequence constructor</b>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Given the accumulator:</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="w" initial-value="1"&gt;
   &lt;xsl:accumulator-rule match="text()" 
                         new-value="$value + count(tokenize(., '\s+'))"/&gt;
&lt;/xsl:accumulator&gt;
</pre></div>
<p>and the template rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:apply-templates/&gt;
   (words: &lt;xsl:value-of select="accumulator-after('w')"/&gt;)
&lt;/xsl:template&gt;
</pre></div>
<p>The stylesheet will output at the end of each section a count of
the number of words in the document up to that point, irrespective
of the nesting of sections.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="accumulators-visibility-and-overriding" id=
"accumulators-visibility-and-overriding"></a>18.2.6 <a href=
"#accumulators-visibility-and-overriding" style=
"text-decoration: none">Visibility and Overriding of
Accumulators</a></h4>
<p>If a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains more than one <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declaration
with a particular name, then the one with the highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p><a name="err-XTSE3350" id="err-XTSE3350"><span class=
"error">[ERR XTSE3350]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for a
<a title="package" class="termref" href="#dt-package">package</a>
to contain two or more non-hidden accumulators with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another accumulator with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>, and a
higher import precedence.</p>
<p><a name="err-XTSE3360" id="err-XTSE3360"><span class=
"error">[ERR XTSE3360]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for a
<a title="package" class="termref" href="#dt-package">package</a>
to contain a non-hidden accumulator if either the pre-descent or
post-descent functions have the same name as a non-hidden <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> in the same
package.</p>
</div>
<div class="div3">
<h4><a name="streamability-of-accumulators" id=
"streamability-of-accumulators"></a>18.2.7 <a href=
"#streamability-of-accumulators" style=
"text-decoration: none">Streamability of Accumulators</a></h4>
<p>An accumulator is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if it
satisfies both the following conditions:</p>
<ol class="enumar">
<li>
<p>In every contained <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>,
the <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> in the <code>match</code> attribute is a
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern.</p>
</li>
<li>
<p>The <a title="expression" class="termref" href=
"#dt-expression">expression</a> in the <code>new-value</code>
attribute is a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> expression.</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> element
declares an intent that the accumulator should be guaranteed
streamable according to these criteria. The consequences of
declaring the accumulator to be streamable when it is not in fact
guaranteed streamable depend on the conformance level of the
processor, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p>When an accumulator is declared to be streamable, the stylesheet
author must ensure that the accumulator functions are only called
at appropriate points in the processing, otherwise (if streaming is
actually in use) a dynamic error will occur. The rules are given
below.</p>
<p>The pre-descent accumulator function <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> can
only be invoked in the course of evaluating a pre-descent
instruction in a template rule that matches the context item, and
the post-descent accumulator function <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> can
only be invoked in the course of evaluating a post-descent
instruction in such a template rule. The concepts "pre-descent
instruction" and "post-descent instruction" are defined in <a href=
"#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence
Constructors</i></a>.</p>
<p>To formalize this it is necessary to establish what it means for
one <a title="construct" class="termref" href=
"#dt-construct">construct</a> to be evaluated <b>in the course
of</b> evaluating another. The rules are as follows. A <a title=
"construct" class="termref" href="#dt-construct">construct</a>
<var>A</var> is evaluated <b>in the course of</b> evaluating
another <a title="construct" class="termref" href=
"#dt-construct">construct</a> <var>B</var> if any of the following
conditions applies:</p>
<ul>
<li>
<p><var>A</var> is an <a title="operand" class="termref" href=
"#dt-operand">operand</a> of <var>B</var> (this does not include
the body of an inline function declaration)</p>
</li>
<li>
<p><var>A</var> is the body of a function (either an inline
function declaration or a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet function</a>
called by a function call <var>B</var></p>
</li>
<li>
<p><var>A</var> is the body of a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> called by an
<a href="#element-call-template"><code>xsl:call-template</code></a>
instruction <var>B</var></p>
</li>
<li>
<p><var>A</var> is the body of an <a title="attribute set" class=
"termref" href="#dt-attribute-set">attribute set</a> invoked by an
instruction <var>B</var> containing an
<code>[xsl:]use-attribute-set</code> attribute</p>
</li>
<li>
<p><var>A</var> is the body of a <a title="template rule" class=
"termref" href="#dt-template-rule">template rule</a> called by an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction <var>B</var></p>
</li>
<li>
<p><var>A</var> is the <code>new-value</code> expression of an
accumulator rule that matches a node <code>N</code>, and
<var>B</var> is a <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instruction evaluated with
<code>N</code> as its context item</p>
</li>
<li>
<p>There is a construct <var>M</var> such that <var>A</var> is
evaluated <b>in the course of</b> evaluating <var>M</var>, and
<var>M</var> is evaluated <b>in the course of</b> evaluating
<var>B</var>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The initializer of a variable is <em>NOT</em> evaluated <b>in
the course of</b> evaluating a variable reference.</p>
<p>An <a href="#element-variable"><code>xsl:variable</code></a>
instruction and its <code>select</code> attribute or contained
sequence constructor <em>ARE</em> evaluated <b>in the course of</b>
evaluating the sequence constructor that contains the <a href=
"#element-variable"><code>xsl:variable</code></a> instruction.
Where a variable is bound to the result of an accumulator function,
or a value computed from such a result, the position of the
<a href="#element-variable"><code>xsl:variable</code></a>
instruction within its sequence constructor may be significant,
insofar as its position relative to a consuming instruction makes
it a pre-descent or post-descent instruction.</p>
</div>
<p>If a call on <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> is
evaluated for a streamable accumulator then:</p>
<ol class="enumar">
<li>
<p>The evaluation must occur <b>in the course of</b> evaluating a
pre-descent or post-descent instruction in some streamed template
rule T, respectively</p>
</li>
<li>
<p>The context item at the point of invocation of the accumulator
function must be the same as the context node for T.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="accumulator-examples" id=
"accumulator-examples"></a>18.2.8 <a href="#accumulator-examples"
style="text-decoration: none">Examples of Accumulators</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e38689" id=
"d7e38689"></a>Example: Remember the Title of a Document</div>
<p>Consider an XHTML document in which the title of the document is
represented by the content of the first <code>title</code> element
appearing as a child of the <code>head</code> element, which in
turn appears as a child of the <code>html</code> element. Suppose
that we want to process the document in streaming mode, and that we
want to avoid outputting the content of the <code>h1</code> element
if it is the same as the document title.</p>
<p>This can be achieved by remembering the value of the title in an
accumulator variable.</p>
<div class="exampleInner">
<pre>
  &lt;xsl:accumulator name="firstTitle" as="xs:string?" initial-value="()"&gt;
    &lt;xsl:accumulator-rule match="html/head/title[1]" new-value="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;
  
</pre></div>
<p>Subsequently, while processing an <code>h1</code> element
appearing later in the document, the value can be referenced:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:variable name="firstTitle" select="accumulator-before('firstTitle')"/&gt;
    &lt;xsl:variable name="thisTitle" select="string(.)"/&gt;
    &lt;xsl:if test="$thisTitle ne $firstTitle"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:value-of select="$thisTitle"/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This example illustrates that the order of the variable
declarations within a sequence constructor is significant, even
when there is no direct dependency of one variable on another.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e38720" id=
"d7e38720"></a>Example: Keep a Word Count</div>
<p>Suppose that there is a requirement to output, at the end of the
HTML rendition of a document, a paragraph giving the total number
of words in the document.</p>
<p>An accumulator can be used to maintain the word count:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:accumulator name="word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         new-value="$value + count(tokenize(string(.), '\W+'))"/&gt;
  &lt;/xsl:accumulator&gt;
  
</pre></div>
<p>The final value can be output at the end of the document:</p>
<div class="exampleInner">
<pre>
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="accumulator-after('word-count')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e38733" id=
"d7e38733"></a>Example: Output Hierarchic Section Numbers</div>
<p>Consider a document in which <code>section</code> elements are
nested within <code>section</code> elements to arbitrary depth, and
there is a requirement to render the document with hierarchic
section numbers of the form <code>3.5.1.4</code>.</p>
<p>The current section number can be maintained in an accumulator
in the form of a sequence of integers, managed as a stack. The
number of integers represents the current level of nesting, and the
value of each integer represents the number of preceding sibling
sections encountered at that level. For convenience the first item
in the sequence represents the top of thenstack.</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 new-value="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 new-value="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;  
</pre></div>
<p>To illustrate this, consider the values after processing a
series of start and end tags:</p>
<table border="1" summary=
"example data illustrating the effect of parsing events on an accumulator"
cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">events</th>
<th colspan="1" align="left" valign="top">accumulator value</th>
<th colspan="1" align="left" valign="top">required section
number</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1</code></td>
<td align="left" valign="top">1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1, 1</code></td>
<td align="left" valign="top">1.1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 2, 1</code></td>
<td align="left" valign="top">1.2</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>2, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 3, 1</code></td>
<td align="left" valign="top">1.3</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1, 3, 1</code></td>
<td align="left" valign="top">1.3.1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1, 3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 2, 3, 1</code></td>
<td align="left" valign="top">1.3.2</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>2, 3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1</code></td>
</tr>
</tbody>
</table>
<p>The section number for a section can thus be generated as:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="reverse(tail(accumulator('section-nr')))" 
                  separator="."/&gt;
  &lt;/p&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
                  
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e38864" id=
"d7e38864"></a>Example: Compute a Histogram showing the Number of
Books, by Publisher</div>
<div class="exampleInner">
<pre>
 &lt;xsl:accumulator name="histogram" as="map(xs:string, xs:integer)"
    initial-value="map{}"&gt;
    &lt;xsl:accumulator-rule match="book" new-value=""
       if (map:contains($value, @publisher)) 
       then map:put($value, @publisher, 
                            accumulator-before('histogram')(@publisher)+1)
       else map:put($value, @publisher, 
                            1)"/&gt;
 &lt;/xsl:accumulator&gt;
</pre></div>
<p>The <code>new-value</code> expression is evaluated with the
variable <code>$value</code> set to the current value, and with the
context node as the node being visited.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="func-copy-of" id="func-copy-of"></a>18.3 <a href=
"#func-copy-of" style="text-decoration: none">fn:copy-of</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a deep copy of the node supplied as the
<code>$node</code> argument, or of the context node if the argument
is absent.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-copy-of" id="function-copy-of"></a></p>
<div class="proto"><code class=
"function">copy-of</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()</code></div>
<div class="proto"><code class=
"function">copy-of</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The zero-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The zero-argument form of this function has the same effect as
calling <code>copy-of(.)</code>, that is, supplying the context
item as an implicit argument.</p>
<p>The function returns a deep copy of the node
<span>sequence</span> supplied as the argument <code>$nodes</code>.
If the argument is an empty sequence, the function returns an empty
sequence. The effect is the same as that of the function:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="fn:copy-of" as="node()*" 
              identity-sensitive="no"&gt;
  &lt;xsl:param name="nodes" as="node()*/&gt;
  &lt;xsl:copy-of select="$nodes" 
               copy-namespaces="yes" 
               validation="preserve"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>The streamability analysis, however, is different: see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>.</p>
<p>If the function is called more than once with the same argument,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
each call returns the same node, or whether multiple calls return
different nodes. That is, <span>in the case where <var>$X</var> is
a single node,</span> the result of the expression
<code>copy-of($X) is copy-of($X)</code> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.
<span>However, <code>copy-of($X) is $X</code> will always be
false.</span></p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href="#func-copy-of"><code>copy-of</code></a> function is
available for use (and is primarily intended for use) when a source
document is processed using streaming. It can also be used when not
streaming. The effect is to take a copy of the subtree rooted at
the current node, and to make this available as a normal tree, that
can be processed without any of the restrictions that apply while
streaming, for example only being able to process children once.
The copy, of course, does not include siblings or ancestors of the
context node, so any attempt to navigate to siblings or ancestors
will result in an empty sequence being returned.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Using <code>copy-of()</code> while streaming:</p>
<p>This example copies from the source document all employees who
work in marketing and are based in Dubai. Because there are two
accesses using the child axis, it is not possible to do this
without buffering each employee in memory, which can be achieved
using the <a href="#func-copy-of"><code>copy-of</code></a>
function.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/&gt;
&lt;/xsl:stream&gt;
</pre></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="func-snapshot" id="func-snapshot"></a>18.4 <a href=
"#func-snapshot" style="text-decoration: none">fn:snapshot</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a copy of a node together with its ancestors and
descendants and their attributes and namespaces.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-snapshot" id="function-snapshot"></a></p>
<div class="proto"><code class=
"function">snapshot</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()</code></div>
<div class="proto"><code class=
"function">snapshot</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The zero-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The zero-argument form of this function has the same effect as
calling <code>snapshot(.)</code>, that is, supplying the context
item as an implicit argument.</p>
<p>The function returns a <span>seequence of nodes in which each
node is a <a title="snapshot" class="termref" href=
"#dt-snapshot">snapshot</a> of the corresponding node in the input
sequence</span> supplied as the argument <code>$node</code>. If the
argument is an empty sequence, the function returns an empty
sequence.</p>
<p>If the function is called more than once with the same argument,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
each call returns the same node, or whether multiple calls return
different nodes. That is, the result of the expression
<code>snapshot($X) is snapshot($X)</code> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-snapshot" id="dt-snapshot" title="snapshot"></a>A
<b>snapshot</b> of a node <var>N</var> is a deep copy of
<var>N</var>, as produced by the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
<code>copy-namespaces</code> set to <code>yes</code> and
<code>validation</code> set to <code>preserve</code>, with the
additional property that for every ancestor of <var>N</var>, the
copy also has a corresponding ancestor whose name, node-kind, and
base URI are the same as the corresponding ancestor of
<var>N</var>, and that has copies of the attributes and namespaces
of the corresponding ancestor of <var>N</var>. But the ancestor has
a type annotation of <code>xs:anyType</code>, has the properties
<code>nilled</code>, <code>is-id</code>, and <code>is-idref</code>
set to false, and has no children other than the child that is a
copy of <var>N</var> or one of its ancestors.<span class=
"definition">]</span></p>
<p>More formally, a <a title="snapshot" class="termref" href=
"#dt-snapshot">snapshot</a> of a node is the result of the
following function.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="fn:snapshot" as="node()?" identity-sensitive="no"&gt;
  &lt;xsl:param name="nodes" as="node()*"/&gt;
  
  &lt;!-- create a copy of the tree containing the supplied node, retaining 
       * only the supplied node, its attributes and namespaces
       * the ancestors of the supplied node, 
       * their attributes and namespaces;
       * the descendants of the supplied node, 
       * their attributes and namespaces;
       --&gt;
  &lt;xsl:for-each select="$nodes"&gt;
    &lt;xsl:variable name="origin" select="."/&gt;
    &lt;xsl:variable name="root-copy" as="node()"&gt;
      &lt;xsl:apply-templates select="root($origin)" mode="snapshot"&gt;
        &lt;xsl:with-param name="origin" select="$origin" tunnel="yes"/&gt;
      &lt;/xsl:apply-templates&gt;
    &lt;/xsl:variable&gt;
  
    &lt;!-- find and return the node in the copied tree 
         that corresponds to the origin node
       --&gt; 
    &lt;xsl:sequence select="
         $root-copy/descendant-or-self::node()/(.|@*|namespace::*)
                              [f:corresponds(., $origin)]"/&gt;
  &lt;/xsl:for-each&gt;    
&lt;/xsl:function&gt;

&lt;xsl:template match="." mode="snapshot"&gt;
  &lt;xsl:param name="origin" as="node()" tunnel="yes"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test=". is $origin"&gt;
      &lt;xsl:copy-of select="." validation="preserve"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test=". intersect $origin/ancestor::node()"&gt;
      &lt;xsl:copy validation="strip"&gt;
        &lt;xsl:copy-of select="@*" validation="preserve"/&gt;
        &lt;xsl:apply-templates mode="snapshot"/&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise/&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;!-- f:corresponds compares two nodes and returns true if all 
       the following are true:
     * they are at the same depth in their respective trees
     * they have the same name (or none)
     * they have the same node kind
     The tests on node name and node kind are needed only when 
     the origin node is an attribute or namespace.
     --&gt;
&lt;xsl:function name="f:corresponds" as="xs:boolean"&gt;
  &lt;xsl:param name="node1" as="node()"/&gt;
  &lt;xsl:param name="node2" as="node()"/&gt;
  &lt;xsl:sequence select="
    count($node1/ancestor::node()) = count($node2/ancestor::node()) and
    deep-equal(node-name($node1), node-name($node2)) and
    f:node-kind($node1) = f:node-kind($node2)"/&gt;    
&lt;/xsl:function&gt;

&lt;!-- f:node-kind returns the node kind of a node as a string
     --&gt;
&lt;xsl:function name="f:node-kind" as="xs:string"&gt;
  &lt;xsl:param name="node" as="node()"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$node instance of document-node()"&gt;D&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of element(*)"&gt;E&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of attribute(*)"&gt;A&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of text()"&gt;T&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of comment()"&gt;C&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of 
                          processing-instruction()"&gt;P&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of namespace-node()"&gt;N&lt;/xsl:when&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
 
</pre></div>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href="#func-snapshot"><code>snapshot</code></a> function
is available for use (and is primarily intended for use) when a
source document is processed using streaming. It can also be used
when not streaming. The effect is to take a copy of the subtree
rooted at the current node, along with copies of the ancestors and
their attributes, and to make this available as a normal tree, that
can be processed without any of the restrictions that apply while
streaming, for example only being able to process children once.
The copy, of course, does not include siblings of the context node
or of its ancestors, so any attempt to navigate to these siblings
will result in an empty sequence being returned.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Using <code>snapshot()</code> while streaming:</p>
<p>This example copies from the source document all employees who
work in marketing and are based in Dubai. It assumes that employees
are grouped by location. Because there are two accesses using the
child axis (referencing <code>department</code> and
<code>salary</code>), it is not possible to do this without
buffering each employee in memory. The <a href=
"#func-snapshot"><code>snapshot</code></a> function is used in
preference to the simpler <a href=
"#func-copy-of"><code>copy-of</code></a> so that access to
attributes of the parent <code>location</code> element remains
possible.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']"&gt;
    &lt;employee&gt;
      &lt;location code="{../@code}"/&gt;
      &lt;salary value="{salary}"/&gt;
    &lt;/employee&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="streamability" id="streamability"></a>19 <a href=
"#streamability" style=
"text-decoration: none">Streamability</a></h2>
<p>This section describes the analysis that determines whether
constructs in the stylesheet are streamable. <span>More precisely,
the analysis determines properties of constructs such as template
rules, and the values of these properties determine whether
constructs are <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a>, which
in turn (see <a href="#streamability-guarantees"><i>19.10
Streamability Guarantees</i></a>) imposes rules on how the
constructs are handled by processors that implement the <a title=
"streaming feature" class="termref" href=
"#dt-streaming-feature">streaming feature</a>. The analysis has no
effect on the behavior of processors that do not implement this
feature.</span></p>
<p>The analysis is relevant to constructs such as streamable
template rules and the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction that
process a single streamed input document. The <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, which
processes multiple streamed inputs, has its own rules.</p>
<p>The rules in this section operate on the expression tree (more
properly, construct tree) that is typically output by the XSLT and
XPath parser. For the most part, the rules depend only on
identifying the syntactic constructs that are present.</p>
<p>The rules in this section generally consider each <a title=
"component" class="termref" href="#dt-component">component</a> in
the stylesheet (and in the case of <a title="template rule" class=
"termref" href="#dt-template-rule">template rules</a>, each
template rule) in isolation. The exception is that where a
component contains references to other components (such as global
variables, functions, or named templates), then information from
the signature of the referenced component is sometimes used. This
is invariably information that cannot be changed if a component is
overridden in a different <a title="package" class="termref" href=
"#dt-package">package</a>. The analysis thus requires as a
pre-condition that function calls and calls on named templates have
been resolved to the extent that the corresponding
function/template signature is known. It also requires that
variable references referring to grouping variables (those declared
in a <code>bind-XXX</code> attribute of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href="#element-merge"><code>xsl:merge</code></a>, or <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element)
have been identified as such.</p>
<p>The detailed way in which the construct tree is derived from the
lexical form of the stylesheet is not described in this
specification. There are many ways in which the tree can be
optimized without affecting the result of the rules in this
section: for example, a sequence constructor containing a single
instruction can be replaced by that instructon, and a parenthesized
expression can be replaced by its content.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-construct" id="dt-construct" title="construct"></a>The term
<b>construct</b> refers to the union of the following: a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="value template" class="termref" href=
"#dt-value-template">value template</a>, an <a title="expression"
class="termref" href="#dt-expression">expression</a>, or a
<a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.<span class="definition">]</span></p>
<p>These <a title="construct" class="termref" href=
"#dt-construct">constructs</a> are classified into <b>construct
kinds</b>: in particular, <a title="instruction" class="termref"
href="#dt-instruction">instructions</a> are classified according to
the name of the XSLT instruction, and <a title="expression" class=
"termref" href="#dt-expression">expressions</a> are classified
according to the most specific production in the XPath grammar that
the expression satisfies. (This means, for example, that
<code>2+2</code> is classified as an <code>AdditiveExpr</code>,
rather than say as a <code>UnionExpr</code>; although it also
satisfies the production rule for <code>UnionExpr</code>,
<code>AdditiveExpr</code> is more specific.)</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand-role" id="dt-operand-role" title="operand role"></a>For
every construct kind, there is a set of zero or more <b>operand
roles</b>.<span class="definition">]</span> For example, an
<code>AdditiveExpr</code> has two operand roles, referred to as the
left-hand operand and the right-hand operand, while an
<code>IfExpr</code> has three, referred to as the condition, the
then-clause, and the else-clause. A function call with three
arguments has three operand roles, called the first, second, and
third arguments. The names of the operand roles for each construct
kind are not formally listed, but should be clear from the
context.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand" id="dt-operand" title="operand"></a>In an actual
instance of a construct, there will be a number of
<b>operands</b>.<span class="definition">]</span> Each operand is
itself a <a title="construct" class="termref" href=
"#dt-construct">construct</a>; the construct tree can be defined as
the transitive relation between constructs and their operands. Each
operand is associated with exactly one of the operand roles for the
construct type. There may be operand roles where the operand is
optional (for example, the <code>separator</code> attribute of the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction), and there may be operand roles that can be occupied
by multiple operands (for example, the <code>xsl:when/@test</code>
condition in <a href="#element-choose"><code>xsl:choose</code></a>,
or the arguments of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-concat"><code>concat</code></a><sup><small>FO30</small></sup>
function).</p>
<p>Operand roles have a number of properties used in the
analysis:</p>
<ul>
<li>
<p>The <a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the operand. This is
explicit in the case of function calls (the required type is
defined in the function signature of the corresponding function).
In other cases it is implicit in the detailed rules for the
construct in question. In practice streamability analysis makes
only modest use of the required type; the main case where it is
relevant is for a function or template call, where knowing that the
required type is atomic enables the inference that the operand
usage for a supplied node is <a title="absorption" class="termref"
href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand-usage" id="dt-operand-usage" title=
"operand usage"></a>The <b>operand usage</b>. This gives
information, in the case where the operand value contains nodes,
about how those nodes are used. The operand usage takes one of the
values <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>, <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, or <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>. <span class=
"definition">]</span>The meanings of these terms are explained in
<a href="#operand-roles"><i>19.4 Operand Roles</i></a>. If the
required type of the operand does not permit nodes to be supplied
<span>(for example because the required type is a function item or
a map)</span>, then the operand usage is <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>, because the
only run-time operation on a supplied node will be to inspect it,
discover it is a node, and raise a type error.</p>
<p>In the particular case where the required type is atomic, and
any supplied nodes are atomized, the operand usage will be
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, because <a title="atomize" class=
"termref" href="#dt-atomization">atomize</a> is a special case of
absorption.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-higher-order-operand" id="dt-higher-order-operand" title=
"higher-order operand"></a>Whether or not the operand is
<b>higher-order</b>. For this purpose an operand <var>O</var> of a
construct <var>C</var> is higher-order if the semantics of
<var>C</var> potentially require <var>O</var> to be evaluated more
than once during a single evaluation of <var>C</var>.<span class=
"definition">]</span> More specifically, <var>O</var> is a
<b>higher-order</b> operand of <var>C</var> if any of the following
conditions is true:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> for evaluation of <var>O</var>
is different from the context item for evaluation of
<var>C</var>.</p>
</li>
<li>
<p><var>C</var> is an <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> and <var>O</var> is a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a> (as with
the <code>from</code> and <code>count</code> attributes of <a href=
"#element-number"><code>xsl:number</code></a>, and the
<code>group-starting-with</code> and <code>group-ending-with</code>
attributes of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>).</p>
</li>
<li>
<p><var>C</var> is an XPath <code>for</code>, <code>some</code>, or
<code>every</code> expression and <var>O</var> is the expression in
its <code>return</code> or <code>satisfies</code> clause.</p>
</li>
<li>
<p><var>C</var> is an inline function declaration and <var>O</var>
is the expression in its body.</p>
</li>
</ul>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-choice-operand-group" id="dt-choice-operand-group" title=
"choice operand group"></a>For some construct kinds, one or more
operand roles may be defined to form a <b>choice operand group</b>.
This concept is used where it is known that <a title="operand"
class="termref" href="#dt-operand">operands</a> are mutually
exclusive (for example the <code>then</code> and <code>else</code>
clauses in a conditional expression).<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-combined-posture" id="dt-combined-posture" title=
"combined posture"></a>The <b>combined posture</b> of a <a title=
"choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> is determined
by the <a title="posture" class="termref" href=
"#dt-posture">postures</a> of the <a title="operand" class=
"termref" href="#dt-operand">operands</a> in the group, and is the
first of the following that applies:<span class=
"definition">]</span></p>
<ol class="enumar">
<li>
<p>If any of the input postures is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>, then the combined posture
is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>.</p>
</li>
<li>
<p>If all of the input postures are <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, then the combined
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>If one or more of the input postures is <a title="climbing"
class="termref" href="#dt-climbing">climbing</a> and the remainder
(if any) are <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the combined posture is <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a>.</p>
</li>
<li>
<p>If one or more of the input postures is <a title="striding"
class="termref" href="#dt-striding">striding</a> and the remainder
(if any) are <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the combined posture is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>If one or more of the input postures is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a> and the remainder
(if any) are either <a title="striding" class="termref" href=
"#dt-striding">striding</a> or <a title="grounded" class="termref"
href="#dt-grounded">grounded</a>, then the combined posture is
<a title="crawling" class="termref" href=
"#dt-crawling">crawling</a>.</p>
</li>
<li>
<p>Otherwise (for example, if the group includes both an operand
with <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> posture and one with <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>
posture), the combined posture is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-type-determined-usage" id="dt-type-determined-usage" title=
"type-determined usage"></a>The <b>type-determined usage</b> of an
operand is as follows: if the required type (ignoring occurrence
indicator) is <code>function(*)</code> or a subtype thereof, then
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>; if the required type (ignoring
occurrence indicator) is <code>xs:anyAtomicType</code> or a subtype
thereof, then <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>; otherwise <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>.<span class=
"definition">]</span></p>
<p>The process of determining whether a construct is streamable
reduces to determining properties of the constructs in the
construct tree. The properties in question (which are described in
greater detail in subsequent sections) are:</p>
<ol class="enumar">
<li>
<p>The <b>static type</b> of the construct. When the construct is
evaluated, its value will always be an instance of this type. The
value is an <a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>;
although type inferencing is capable of determining information
about the cardinality as well as the item type, the streamability
analysis makes no use of this.</p>
</li>
<li>
<p>The <b>context item type</b>: that is, the static type of the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> potentially used as input to
the construct. When the construct is evaluated, the context item
used to evaluate the construct (if it is used at all) will be an
instance of this type.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-posture" id="dt-posture" title="posture"></a>The <b>posture</b>
of the expression. This captures information about the way in which
the streamed input document is positioned on return from evaluating
the construct. The posture takes one of the values <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a>,
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>, or <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>. <span class=
"definition">]</span> The meanings of these terms are explained in
<a href="#posture"><i>19.5 Determining the Posture of a
Construct</i></a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-posture" id="dt-context-posture" title=
"context posture"></a>The <b>context posture</b>. This captures
information about how the <a title="context item" class="termref"
href="#dt-context-item">context item</a> used as input to the
construct is positioned relative to the streamed input. The
<b>context posture</b> of a construct C is the posture of the
expression whose value sets the focus for the evaluation of
C.<span class="definition">]</span>. <span>Rules for determining
the context posture of any construct are given in <a href=
"#determining-context-posture"><i>19.6 Determining the Context
Posture</i></a>.</span></p>
</li>
<li>
<p>The <b>sweep</b> of the construct. The sweep of a construct
gives information about whether and how the evaluation of the
construct changes the current position in a streamed input
document. The possible values are <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. These terms are explained in
<a href="#sweep"><i>19.7 The Sweep of a Construct</i></a>.</p>
</li>
</ol>
<p>The values of these properties for a top-level construct such as
the body of a template rule determine whether the construct is
streamable.</p>
<p>The values of these properties are not independent. For example,
if the static type is atomic, then the posture will always be
grounded; if the sweep is free-ranging, then the posture will
always be roaming.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="construct" class=
"termref" href="#dt-construct">construct</a>, as defined above, are
calculated in relation to a particular streamed input document. If
there is more than one streamed input document, then a construct
that is motionless with respect to one streamed input might be
consuming with respect to another. In practice, though, the
streamability analysis is only ever concerned with one particular
streamed input at a time; constructs are analyzed in relation to
the innermost containing <a href=
"#element-template"><code>xsl:template</code></a>, <a href=
"#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>, or
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element, and this container implicitly defines the streamed input
document that is relevant. The streamed input document affecting a
construct is always the document that contains the context item for
evaluation of that construct, with one exception: a variable
reference to a variable bound in the <code>bind-group</code>
attribute of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> or
the <code>bind-source</code> attribute of an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
To prevent this causing complications, there are rules constraining
where such variable references may appear.</p>
<div class="div2">
<h3><a name="pattern-scanning" id="pattern-scanning"></a>19.1
<a href="#pattern-scanning" style="text-decoration: none">An
Optimization: Pattern-Based Scanning</a></h3>
<p>The rules given later in this chapter for determining
streamability produce the result that the expression
<code>count(//section/head)</code> is not streamable. The reason
for this is that a naive nested loop evaluation of the path
expression <code>//section/head</code> will not always deliver
nodes in document order; this can be seen by examining the source
document below, where a child of the first <code>section</code>
appears in document order <em>after</em> a child of the second
<code>section</code>:</p>
<div class="exampleInner">
<pre>
&lt;section&gt;
  &lt;section&gt;
     &lt;head/&gt;
  &lt;/section&gt;
  &lt;head/&gt;
&lt;/section&gt;  
</pre></div>
<p>An implementation that literally followed the semantics of path
expressions as defined in <a href="#xpath-30">[XPath 3.0]</a> would
therefore require to sort the nodes into document order, and
sorting is incompatible with streaming.</p>
<p>There is however a viable strategy for processing this
expression in a streaming manner, for example to rewrite the
expression as
<code>count(/descendant::head[parent::section])</code>.</p>
<p>In order to make such expressions streamable, implementations
must therefore detect this situation in the construct tree and
perform an appropriate rewrite before continuing with the analysis.
Specifically, any <code>PathExpr</code> <var>E</var> that is the
equivalent expression of some <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> pattern <var>P</var> is
replaced by a call on a streamable function that selects the same
nodes as would have been selected by <var>E</var> in the absence of
streaming restrictions. This function call has a sweep of
<span><a title="consuming" class="termref" href=
"#dt-consuming">consuming</a></span> and a posture of <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>; its
static type is that of the original expression <var>E</var>. This
makes it eligible to be used, for example, as the argument of the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
function.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The function used in this rewrite needs to do more than simply
test all descendant nodes to see if they match the pattern; for
example if the expression is <code>p//q</code> then it must also
check that the relevant <code>p</code> element is indeed a child of
the original context item.</p>
<p>This rewrite will not always succeed in making the construct
streamable. For example <code>&lt;xsl:value-of
select="//head"/&gt;</code> will still fail the streamability
tests, because of the possibility that one <code>head</code>
element is a child of another. This problem can be remedied by
writing <code>&lt;xsl:value-of
select="//head/text()"/&gt;</code>.</p>
<p>It should also be noted that not all downward path expressions
are equivalent to motionless patterns; an example is
<code>a[2]</code>. Positional predicates are allowed in streamable
path expressions, but not in motionless patterns.</p>
<p>In practice, of course, processors may use a different algorithm
if it achieves the same effect.</p>
</div>
</div>
<div class="div2">
<h3><a name="determining-static-type" id=
"determining-static-type"></a>19.2 <a href=
"#determining-static-type" style=
"text-decoration: none">Determining the Static Type of a
Construct</a></h3>
<p>The static type of an <a title="construct" class="termref" href=
"#dt-construct">construct</a> is such that all values produced by
evaluating the construct will conform to that type.</p>
<p>Although all constructs have a static type, the streamability
analysis only needs to know the static type of XPath expressions,
so the rules here are confined to that case. In addition, the
analysis only needs to know the item type, and not the cardinality.
<span>For constructs other than <a title="expression" class=
"termref" href="#dt-expression">expressions</a>, the static type
for the purpose of streamability analysis is taken as
<code>item()</code></span>.</p>
<p>The rules given here are deliberately simple. Implementations
may well be able to compute a more precise static type, but this
will rarely be useful for streamability analysis. The item type for
each kind of XPath expression is determined by the rules below. In
the first column, numbers in square brackets are production numbers
from the XPath 3.0 specification. <span>In the second column, the
<b>Proforma</b> uses an informal notation used both to provide a
reminder of the syntax of the construct in question, and to attach
labels to its operand roles so that they can be referred to in the
text of the third column.</span></p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Construct</th>
<th colspan="1" align="left" valign="top">Proforma</th>
<th colspan="1" align="left" valign="top">Static Item Type</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Expr [6]</td>
<td align="left" valign="top"><code>A,B</code></td>
<td align="left" valign="top">the least common supertype of A and
B</td>
</tr>
<tr>
<td align="left" valign="top">ForExpr [8]</td>
<td align="left" valign="top"><code>for $x in S return
A</code></td>
<td align="left" valign="top">the item type of A</td>
</tr>
<tr>
<td align="left" valign="top">LetExpr [11]</td>
<td align="left" valign="top"><code>let $x := S</code></td>
<td align="left" valign="top">the item type of S</td>
</tr>
<tr>
<td align="left" valign="top">QuantifiedExpr [14]</td>
<td align="left" valign="top"><code>some|every $x in S satisfies
C</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">IfExpr [15]</td>
<td align="left" valign="top"><code>if (C) then T else
E</code></td>
<td align="left" valign="top">the least common supertype of T and
E</td>
</tr>
<tr>
<td align="left" valign="top">OrExpr [16]</td>
<td align="left" valign="top"><code>A or B</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">AndExpr [17]</td>
<td align="left" valign="top"><code>A and B</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">ComparisonExpr [18]</td>
<td align="left" valign="top"><code>A = B, A eq B, A is
B</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">StringConcatExpr [19]</td>
<td align="left" valign="top"><code>A || B</code></td>
<td align="left" valign="top"><code>xs:string</code></td>
</tr>
<tr>
<td align="left" valign="top">RangeExpr [20]</td>
<td align="left" valign="top"><code>A to B</code></td>
<td align="left" valign="top"><code>xs:integer</code></td>
</tr>
<tr>
<td align="left" valign="top">AdditiveExpr [21]</td>
<td align="left" valign="top"><code>A + B</code></td>
<td align="left" valign="top"><code>xs:anyAtomicType</code></td>
</tr>
<tr>
<td align="left" valign="top">MultiplicativeExpr [22]</td>
<td align="left" valign="top"><code>A * B</code></td>
<td align="left" valign="top"><code>xs:anyAtomicType</code></td>
</tr>
<tr>
<td align="left" valign="top">UnionExpr [23]</td>
<td align="left" valign="top"><code>A | B</code></td>
<td align="left" valign="top">the least common supertype of A and
B</td>
</tr>
<tr>
<td align="left" valign="top">IntersectExceptExpr [24]</td>
<td align="left" valign="top"><code>A intersect B, A except
B</code></td>
<td align="left" valign="top">the type of A</td>
</tr>
<tr>
<td align="left" valign="top">InstanceOfExpr [25]</td>
<td align="left" valign="top"><code>A instance of T</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">TreatExpr [26]</td>
<td align="left" valign="top"><code>A treat as T</code></td>
<td align="left" valign="top">the item type of T</td>
</tr>
<tr>
<td align="left" valign="top">CastableExpr [27]</td>
<td align="left" valign="top"><code>A castable as T</code></td>
<td align="left" valign="top"><code>xs:boolean</code></td>
</tr>
<tr>
<td align="left" valign="top">CastExpr [28]</td>
<td align="left" valign="top"><code>A cast as T</code></td>
<td align="left" valign="top">the type T</td>
</tr>
<tr>
<td align="left" valign="top">UnaryExpr [29]</td>
<td align="left" valign="top"><code>-N</code></td>
<td align="left" valign="top">numeric</td>
</tr>
<tr>
<td align="left" valign="top">SimpleMapExpr [34]</td>
<td align="left" valign="top"><code>A ! B</code></td>
<td align="left" valign="top">the type of B</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">PathExpr [35]</td>
<td align="left" valign="top"><code>/</code></td>
<td align="left" valign="top"><code>document-node()</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>/P</code></td>
<td align="left" valign="top">the type of P</td>
</tr>
<tr>
<td align="left" valign="top"><code>//P</code></td>
<td align="left" valign="top">the type of P</td>
</tr>
<tr>
<td align="left" valign="top">RelativePathExpr [36]</td>
<td align="left" valign="top"><code>A/B, A//B</code></td>
<td align="left" valign="top">the type of B</td>
</tr>
<tr>
<td align="left" valign="top">AxisStep [36]</td>
<td align="left" valign="top"><code>A[P]</code></td>
<td align="left" valign="top">the type of A</td>
</tr>
<tr>
<td align="left" valign="top">ForwardStep [39] , ReverseStep
[42]</td>
<td align="left" valign="top"><code>Axis::NodeTest</code></td>
<td align="left" valign="top">If the <code>NodeTest</code> is a
<code>KindTest</code> <var>K</var>, then <var>K</var> (for example,
<code>element()</code> or <code>comment()</code>). Otherwise (the
<code>NodeTest</code> is a <code>NameTest</code>), the type
corresponding to the principal node kind of the axis, for example
<code>element()</code> or <code>attribute()</code>.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">PostfixExpr [48]</td>
<td align="left" valign="top">Filter Expression
<code>A[B]</code></td>
<td align="left" valign="top">the type of A</td>
</tr>
<tr>
<td align="left" valign="top">Dynamic Function Call <code>A(B,
C)</code></td>
<td align="left" valign="top">the return type of the function type
of A</td>
</tr>
<tr>
<td align="left" valign="top">Literal [53]</td>
<td align="left" valign="top"><code>"pH"</code>,
<code>93.7</code></td>
<td align="left" valign="top"><code>xs:string</code>,
<code>xs:integer</code>, <code>xs:decimal</code>, or
<code>xs:double</code>, depending on the form of the literal</td>
</tr>
<tr>
<td align="left" valign="top">VarRef [55]</td>
<td align="left" valign="top">$V</td>
<td align="left" valign="top">For a variable declared using
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a>, and for
parameters of inline function expressions: the declared type of the
variable, defaulting to <code>item()</code>. For variables declared
using for, let, some, and every expressions: the item type of the
expression to which the variable is bound. For the binding
variables of xsl:for-each-group: the type of the relevant
expression in the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction (<code>select</code>, <code>group-by</code>, or
<code>group-adjacent</code>)</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">ParenthesizedExpr
[57]</td>
<td align="left" valign="top"><code>(E)</code></td>
<td align="left" valign="top">the type of E</td>
</tr>
<tr>
<td align="left" valign="top"><code>()</code></td>
<td align="left" valign="top"><code>xs:error</code> (a type that
has no instances)</td>
</tr>
<tr>
<td align="left" valign="top">ContextItemExpr [58]</td>
<td align="left" valign="top"><code>.</code></td>
<td align="left" valign="top">the context item type: see below</td>
</tr>
<tr>
<td align="left" valign="top">FunctionCall [59]</td>
<td align="left" valign="top"><code>F(X, Y)</code></td>
<td align="left" valign="top">the declared result type of function
F</td>
</tr>
<tr>
<td align="left" valign="top">NamedFunctionRef [63]</td>
<td align="left" valign="top"><code>F#n</code></td>
<td align="left" valign="top">the declared function type of the
referenced function F</td>
</tr>
<tr>
<td align="left" valign="top">InlineFunctionExpr [64]</td>
<td align="left" valign="top"><code>function(P) {E}</code></td>
<td align="left" valign="top">the declared type of the anonymous
inline function</td>
</tr>
<tr>
<td align="left" valign="top">MapExpr [202]</td>
<td align="left" valign="top"><code>map{"A":E, "B":F}</code></td>
<td align="left" valign="top"><code>map(*)</code></td>
</tr>
</tbody>
</table>
<p>In some cases the above entries require computation of the least
common type of two types <var>T</var> and <var>U</var>. Since item
types form a lattice rather than a hierarchy, there may be a set of
types <var>V</var> such that <var>T</var> and <var>U</var> are both
subtypes of every type in <var>V</var>, and no type in <var>V</var>
is unambiguously the "least" common type in the sense that all the
others are subtypes of it. In this situation the choice of which
type in <var>V</var> to use as the inferred static type is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The streamability analysis in this chapter is not schema-aware.
There are cases where use of schema type information might enable a
processor to determine that a construct is streamable when it would
be unable to make this determination otherwise. Two examples:</p>
<ul>
<li>
<p>A processor might decide that a construct such as <code>price +
salesTax</code> is streamable if both the child elements have a
simple type such as <code>xs:decimal</code>, or if the order in
which they appear in the input document is known.</p>
</li>
<li>
<p>A processor might decide that a step using the descendant axis,
such as <code>.//title</code>, has <a title="striding" class=
"termref" href="#dt-striding">striding</a> rather than <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>
<a title="posture" class="termref" href="#dt-posture">posture</a>
if it can establish that two <code>title</code> elements will never
overlap (that is, a <code>title</code> cannot contain another
<code>title</code>). This would allow the instruction
<code>&lt;xsl:apply-templates select=".//title"/&gt;</code> to be
used in a streaming template rule.</p>
</li>
</ul>
<p>Although such constructs are not guaranteed streamable according
to this specification, there is nothing to prevent a processor
providing a streamed implementation if it is able to do so.</p>
</div>
</div>
<div class="div2">
<h3><a name="determining-context-item-type" id=
"determining-context-item-type"></a>19.3 <a href=
"#determining-context-item-type" style=
"text-decoration: none">Determining the Context Item Type</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-item-type" id="dt-context-item-type" title=
"context item type"></a>For every expression, it is possible to
establish by static analysis, information about the item type of
the context item for evaluation of that expression. This is called
the <b>context item type</b> of the expression.<span class=
"definition">]</span></p>
<p>The semantics of every <a title="construct" class="termref"
href="#dt-construct">construct</a>, defined in this specification
or in the XPath specification, describe how the focus for
evaluating each operand of the construct is determined. In most
cases the focus is the same as that of the parent construct. In
some cases the focus is determined by evaluating some other
expression, for example in the expressions <code>A/B</code>,
<code>A!B</code>, or <code>A[B]</code>, the focus for evaluating
<var>B</var> is <var>A</var>. More generally:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus-changing-construct" id="dt-focus-changing-construct"
title="focus-changing construct"></a>A <b>focus-changing
construct</b> is a <a title="construct" class="termref" href=
"#dt-construct">construct</a> that has one or more <a title=
"operand" class="termref" href="#dt-operand">operands</a> that are
evaluated with a different <a title="focus" class="termref" href=
"#dt-focus">focus</a> from the parent construct.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples of focus-changing constructs include the instructions
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>; path
expressions, filter expressions, and simple mapping expressions;
and all patterns.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-controlling-operand" id="dt-controlling-operand" title=
"controlling operand"></a>Within a <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a> there
is in many cases one <a title="operand" class="termref" href=
"#dt-operand">operand</a> whose value determines the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for evaluating
other operands; this is referred to as the <b>controlling
operand</b>.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, the controlling operand of a <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is the expression in its <code>select</code> attribute;
the controlling operand of a filter expression <code>E[P]</code> is
<code>E</code>, and the controlling operand of a simple mapping
expression <code>A!B</code> is <code>A</code>.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-controlled-operand" id="dt-controlled-operand" title=
"controlled operand"></a>Within a <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a> there
are one or more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a <a title=
"focus" class="termref" href="#dt-focus">focus</a> determined by
the <a title="controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> <span>(or in some
cases such as <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>, with
an <a title="absent" class="termref" href="#dt-absent">absent</a>
<a title="focus" class="termref" href=
"#dt-focus">focus</a>)</span>; these are referred to as
<b>controlled operands</b>.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, the main controlled operand of a <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is the contained sequence constructor; the controlled
operand of a filter expression <code>E[P]</code> is <code>P</code>,
and the controlled operand of a simple mapping expression
<code>A!B</code> is <code>B</code>.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus-setting-container" id="dt-focus-setting-container" title=
"focus-setting container"></a>The <b>focus-setting container</b> of
a construct <var>C</var> is the innermost <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a>
<var>F</var> (if one exists) such that <var>C</var> is directly or
indirectly contained in a <a title="controlled operand" class=
"termref" href="#dt-controlled-operand">controlled operand</a> of
<var>F</var>. <span>If there is no such construct <var>F</var>,
then the focus-setting container is the containing <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example an <a href=
"#element-function"><code>xsl:function</code></a> or <a href=
"#element-template"><code>xsl:template</code></a>
element.</span><span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, if an instruction appears as a child of <a href=
"#element-for-each"><code>xsl:for-each</code></a>, then its
focus-setting container is the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction; if
an expression appears within the predicate of a filter expression,
its focus-setting container is the filter expression.</p>
</div>
</li>
</ul>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> of a construct
<var>C</var> is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-function"><code>xsl:function</code></a> element, an
inline function declaration, or an <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, then the context item type is <code>xs:error</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is essentially an error case; expressions that depend on
the focus should not normally appear within a construct that sets
the focus to <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</div>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then the
context item type is <code>document-node()</code>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>, then the context item type
is the <a title="match type" class="termref" href=
"#dt-match-type">match type</a> of the match pattern of the
template rule, defined below.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <code>PredicatePattern</code>, then the context
item type is <code>item()</code>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is any
other <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example a global variable
declaration, the context item type is <code>item()</code>.</p>
</li>
<li>
<p>Otherwise, the context item type is the statically-inferred type
(see <a href="#determining-static-type"><i>19.2 Determining the
Static Type of a Construct</i></a>) of the <a title=
"controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> of the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var>.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-match-type" id="dt-match-type" title="match type"></a>The
<b>match type</b> of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> is the most specific
<code>ItemType</code> that is known to match all items that the
pattern can match.<span class="definition">]</span> The match type
of a pattern is the statically-inferred item type of the pattern's
equivalent expression, determined according to the rules in
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a>. For example, the match type of the
pattern <code>para[1]</code> is <code>element()</code>, while that
of the pattern <code>@code[.='x']</code> is
<code>attribute()</code></p>
</div>
<div class="div2">
<h3><a name="operand-roles" id="operand-roles"></a>19.4 <a href=
"#operand-roles" style="text-decoration: none">Operand
Roles</a></h3>
<p>An <a title="operand role" class="termref" href=
"#dt-operand-role">operand role</a> gives information about the
operands of a particular kind of construct. The two important
properties of an operand role are the required type and the operand
usage.</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of an operand role is relevant only
when the value of an operand supplied in that role is a node, or a
sequence that contains nodes. It is one of the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-absorption" id="dt-absorption" title="absorption"></a>An
operand usage of <b>absorption</b> indicates that the construct
reads the subtree(s) rooted at a supplied node(s).<span class=
"definition">]</span> Examples are constructs that atomize their
operands, or that obtain the string value of a supplied node, or
that copy the supplied node to a new tree. Another example is the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function, which compares the subtrees rooted at the nodes supplied
in its first two arguments.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-inspection" id="dt-inspection" title="inspection"></a>An
operand usage of <b>inspection</b> indicates that the construct
accesses properties of a supplied node that are available without
reading its subtree.<span class="definition">]</span> Examples are
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-base-uri"><code>base-uri</code></a><sup><small>FO30</small></sup>,
and the <code>instance of</code> expression which tests the type of
a node (or other item). or functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-boolean"><code>boolean</code></a><sup><small>FO30</small></sup>
which are only interested in the existence of the node, and not in
its properties.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-transmission" id="dt-transmission" title="transmission"></a>An
operand usage of <b>transmission</b> indicates that the construct
will (potentially) return a supplied node as part of its result to
the calling construct (that is, to its parent in the construct
tree).<span class="definition">]</span> It also indicates that
document order is preserved: if the input is in document order,
then the result must be in document order. An example is a filter
expression, where nodes in the base expression (the expression
being filtered) will typically appear in the result of the filter
expression, in their original order.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-navigation" id="dt-navigation" title="navigation"></a>An
operand usage of <b>navigation</b> indicates that the construct may
navigate freely from the supplied node to other nodes in the same
tree, in a way that is not constrained by the streamability
rules.<span class="definition">]</span> This covers several cases:
cases where it is known that the construct performs impermissible
navigation (for example, the <a href=
"#element-number"><code>xsl:number</code></a> instruction) or
reordering (the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
function), or that require look-ahead (the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
function) and also cases where the analysis is unable to determine
what use is made of the node, for example because it is passed as
an argument to a user-defined function, or retained in a
variable.</p>
</li>
</ul>
<p>The assignment of operand usages to each operand role of each
kind of construct is defined in <a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a>.</p>
<div class="div3">
<h4><a name="operand-usage-examples" id=
"operand-usage-examples"></a>19.4.1 <a href=
"#operand-usage-examples" style="text-decoration: none">Examples
showing the Effect of Operand Usage</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e40643" id=
"d7e40643"></a>Example: The Effect of Operand Usage on the
Streamability of a Context Item Expression</div>
<p>Consider the following construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>To assess the streamability, we follow the following logic:</p>
<ol class="enumar">
<li>
<p>The top-level construct is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>. It is evaluated with a document node as the
context item, and with a <a title="striding" class="termref" href=
"#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The sequence constructor has one child <a title="instruction"
class="termref" href="#dt-instruction">instruction</a>, which has
an <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instrunction evaluates its <code>select</code> expression, with the
context item and <a title="posture" class="termref" href=
"#dt-posture">posture</a> unchanged.</p>
</li>
<li>
<p>The step <code>child::*</code> is evaluated with this context
item and posture. The posture transition rules permit this; we now
have a sequence of child elements, and still a <a title="striding"
class="termref" href="#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The same applies to the next step, <code>child::emp</code></p>
</li>
<li>
<p>The content of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> which itself
has a single operand, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is evaluated once for each <code>emp</code> child, with
that child as context item and in a <a title="striding" class=
"termref" href="#dt-striding">striding</a> posture. This
instruction uses the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> of the
<code>select</code> expression is <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>. This means that the
result of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction is therefore <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction (see
<a href="#streamability-xsl-for-each"><i>19.8.4.17 Streamability of
xsl:for-each</i></a>) is therefore <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-stream"><code>xsl:stream</code></a> instruction
is therefore <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is therefore <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
<p>Now consider a slightly different construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:sequence select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>To assess the streamability, we follow the following logic:</p>
<ol class="enumar">
<li>
<p>The top-level construct is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>. It is evaluated with a document node as the
context item, and with a <a title="striding" class="termref" href=
"#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The sequence constructor has one child <a title="instruction"
class="termref" href="#dt-instruction">instruction</a>, which has
an <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction evaluates its <code>select</code> expression, with the
context item and <a title="posture" class="termref" href=
"#dt-posture">posture</a> unchanged.</p>
</li>
<li>
<p>The step <code>child::*</code> is evaluated with this context
item and posture. The posture transition rules permit this; we now
have a sequence of child elements, and still a <a title="striding"
class="termref" href="#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The same applies to the next step, <code>child::emp</code></p>
</li>
<li>
<p>The content of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> which itself
has a single operand, the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction is evaluated once for each <code>emp</code> child, with
that child as context item and in a <a title="striding" class=
"termref" href="#dt-striding">striding</a> posture. This
instruction uses the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> of the
<code>select</code> expression is <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>. This means that
the result of the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction is
<a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction is therefore also <a title="striding" class="termref"
href="#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction (see
<a href="#streamability-xsl-for-each"><i>19.8.4.17 Streamability of
xsl:for-each</i></a>) is therefore <a title="striding" class=
"termref" href="#dt-striding">striding</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-stream"><code>xsl:stream</code></a> instruction
is therefore <a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is therefore not <a title="guaranteed-streamable"
class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
<p>Expressed informally, the result of an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction (or of a
streamable template rule) must not contain streamed nodes. The
reason for this is that once streamed nodes are returned to
constructs that are not declared streamable and therefore have no
streamability constraints, there is no way to analyze what happens
to them, and thus to guarantee streamability.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40900" id=
"d7e40900"></a>Example: The Effect of Operand Roles on the
Streamability of Path Expressions</div>
<p>Consider the expression <code>.//chapter</code>.</p>
<p>When this appears as an argument to the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
it can be streamed (it is a <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> expression, meaning that the
subtree rooted at the context item needs to be read in order to
evaluate the expression). A possible strategy for performing a
streamed evaluation is to read all descendants of the context item
in document order, checking each one to see whether its name is
<code>chapter</code>. The <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the expression will be <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, and
its <a title="posture" class="termref" href=
"#dt-posture">posture</a> will be <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a>.</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> (the usage of the argument to
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>)
is defined as a <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
show that when the posture of an operand is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a> and the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> is <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, the resulting expression is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a></p>
<p>When the same expression appears as an argument to a call on a
user-defined function, and the declared type of the relevant
argument is <code>node()*</code>, then it is not possible to
determine whether the expression is streamable or not, because the
streamability analysis does not attempt to follow the data flow
across functions (also, the function in question could be
overridden in another package). This <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> (where
an expression returns nodes and the processor cannot determine how
those nodes might be used) is defined as <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>. The
expression in this context is classified as <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, which effectively means that
streaming is not guaranteed. Although the expression is not
guaranteed streamable, some processors might do better, for example
by examining what the called function does with the argument, or by
allowing the stylesheet author to make assertions about the
behavior of the called function using <a title=
"extension attribute" class="termref" href=
"#dt-extension-attribute">extension attributes</a>.</p>
<p>When the same expression appears as an argument to the function
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup>,
the processor knows that it will need to access the subtree of each
selected <code>section</code> element in order to compute the
result of the function (the argument to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup>
is classified as having <a title="operand usage" class="termref"
href="#dt-operand-usage">operand usage</a> <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>). The
processor does not know, however, whether these subtrees will be
overlapping (one <code>section</code> might contain another). If
they are overlapping, the expression will not be streamable. The
analysis assumes the worst case, so it classifies the expression as
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, which effectively means that
streaming is not guaranteed. Some processors might do better, for
example by using schema-based inferencing.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="posture" id="posture"></a>19.5 <a href="#posture"
style="text-decoration: none">Determining the Posture of a
Construct</a></h3>
<p>The <b>posture</b> of an construct indicates the relationship of
the nodes selected by the <a title="construct" class="termref"
href="#dt-construct">construct</a> to a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed input document</a>. The value is
one of the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-grounded" id="dt-grounded" title=
"grounded"></a><b>Grounded</b>: indicates that the value returned
by the construct does not contain nodes from the streamed input
document<span class="definition">]</span>. Atomic values and
function items are always grounded; nodes are grounded if it is
known that the they are in a non-streamed document. For example the
expressions <code>doc('x')</code> and <code>copy-of(.)</code> both
return grounded nodes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-climbing" id="dt-climbing" title=
"climbing"></a><b>Climbing</b>: indicates that nodes returned by
the construct are reached by navigating the parent,
ancestor[-or-self], attribute, and/or namespace axes from the node
at the current streaming position.<span class="definition">]</span>
When the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing, use
of certain axes such as <code>parent</code> and
<code>ancestor</code> is permitted, but use of other axes such as
<code>child</code> or <code>descendant</code> violates the
streamability rules.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-crawling" id="dt-crawling" title=
"crawling"></a><b>Crawling</b>: typically indicates that nodes
returned by a construct are reached by navigating the
descendant[-or-self] axis.<span class="definition">]</span> Nodes
reached in this way potentially have overlapping subtrees, so
further downward navigation is not permitted. <span>Expressions
that can be statically determined to return a singleton node (for
example <code>head(.//title)</code>) generate a result with no
overlapping subtrees, so they are striding rather than
crawling.</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-striding" id="dt-striding" title=
"striding"></a><b>Striding</b>: indicates that the result of a
construct is a sequence of nodes, in document order, that are peers
in the sense that none of them is an ancestor or descendant of any
other.<span class="definition">]</span> This is typically achieved
by using one or more steps involving the child axis only. Use of
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup>
function can also result in a striding posture, <span>as can
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup>
that ensure the result will be a singleton node.</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-roaming" id="dt-roaming" title="roaming"></a><b>Roaming</b>:
indicates that the nodes returned by an expression could be
anywhere in the tree, which inevitably means that the construct
cannot be evaluated using streaming.<span class=
"definition">]</span> For example, the <a title="posture" class=
"termref" href="#dt-posture">posture</a> of an axis step using the
<code>following</code> or <code>preceding</code> axis will
typically be <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>, which leads the analysis to conclude
that the construct is not streamable.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>One way to think about the posture values is as labels for
states in a finite state automaton, where the alphabet of symbols
accepted by the automaton is the set of 13 XPath axes, and the
sentence being parsed is a path expression containing a sequence of
axis steps. For example, use of the <code>descendant</code> axis
when the current state is <b>striding</b> moves the new state to
<b>crawling</b>, and use of the <code>parent</code> axis then takes
it to <b>climbing</b>.</p>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a construct is determined in one of
several ways:</p>
<ul>
<li>
<p>For axis steps, the posture of the expression is determined by
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and the choice of
axis. For example, an axis step using the ancestor axis always has
a posture of <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, while an axis step using the child
axis, if the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"striding" class="termref" href="#dt-striding">striding</a>, will
itself have a posture of <a title="striding" class="termref" href=
"#dt-striding">striding</a>. The rules for the posture transitions
produced by axis steps are given in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>.</p>
</li>
<li>
<p>For many other constructs, the posture is determined by the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These determine the result posture in terms of the operands to the
construct and the way in which each operand is used. For example, a
construct that accepts a streamed node as the value of an operand,
and atomizes that node, will generally have a posture of <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>Other constructs have their own special rules, which are all
listed in this chapter. For example, a call on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>
function behaves analogously to an axis step, and is described in
<a href="#streamability-fn-root"><i>19.8.8.10 Streamability of the
root function</i></a>. Special rules are needed for:</p>
<ul>
<li>
<p>Constructs that evaluate an operand more than once, such as an
XPath <code>for</code> expression;</p>
</li>
<li>
<p>Constructs that have alternatives among their operands, such as
an XPath <code>if</code> expression;</p>
</li>
<li>
<p>Constructs that navigate relative to the context item, such as
axis steps;</p>
</li>
<li>
<p>Constructs with implicit inputs, such as the context item
expression <code>.</code> (dot);</p>
</li>
<li>
<p>Constructs that change the focus, such as a filter
expression;</p>
</li>
<li>
<p>Constructs that invoke functions or templates.</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="determining-context-posture" id=
"determining-context-posture"></a>19.6 <a href=
"#determining-context-posture" style=
"text-decoration: none">Determining the Context Posture</a></h3>
<p>In the same way as the type of the context item can be
determined for any construct C by reference to the type of the
construct that establishes the context for the evaluation of C, so
the posture of the context item C can be determined by reference to
the posture of the construct that establishes the context.</p>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of a construct
<var>C</var> is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-function"><code>xsl:function</code></a> declaration, an
inline function declaration, or an <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, then the context posture is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is essentially an error case; expressions that depend on
the context item should not normally appear within these
constructs.</p>
</div>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then the
context posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> whose mode is declared with
<code>streamable="yes"</code>, then the context posture is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, then the context posture is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration with the attribute <code>streamable="yes"</code>, then
the context posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is any
other <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example a global variable
declaration, a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, or a template rule or
attribute set that does not specify <code>streamable="yes"</code>,
then the context posture is <a title="roaming" class="termref"
href="#dt-roaming">roaming</a>.</p>
</li>
<li>
<p>Otherwise, the context posture is the <a title="posture" class=
"termref" href="#dt-posture">posture</a> of the <a title=
"controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> of the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var>.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="sweep" id="sweep"></a>19.7 <a href="#sweep" style=
"text-decoration: none">The Sweep of a Construct</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sweep" id="dt-sweep" title="sweep"></a>Every construct has a
<b>sweep</b>, which is a measure of the extent to which the current
position in the input stream moves during the evaluation of the
expression. The sweep is one of: <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, or
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> .<span class=
"definition">]</span> This list of values is ordered: a <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> expression has <b>wider
sweep</b> than a <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> expression, which has <b>wider
sweep</b> than a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> expression.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-motionless" id="dt-motionless" title="motionless"></a>A
<b>motionless</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed motionless by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a motionless construct is one that can be evaluated
without changing the current position in the input stream.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The context item expression <code>.</code> is classified as
motionless; however a construct that uses <code>.</code> as an
operand (for example, <code>string(.)</code>) might be <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>. The
streamability rules effectively consider expressions such as
<code>.</code> within the context of the containing construct.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-consuming" id="dt-consuming" title="consuming"></a>A
<b>consuming</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed consuming by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a consuming construct is one whose evaluation requires
repositioning of the input stream from the start of the current
node to the end of the current node.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-free-ranging" id="dt-free-ranging" title="free-ranging"></a>A
<b>free-ranging</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed free-ranging by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a free-ranging construct is one whose evaluation may
require access to information that is not available from the
subtree rooted at the current node, together with information about
ancestors of the current node and their attributes.</p>
</div>
<div class="div2">
<h3><a name="classifying-constructs" id=
"classifying-constructs"></a>19.8 <a href="#classifying-constructs"
style="text-decoration: none">Classifying Constructs</a></h3>
<p>This section defines the properties of every kind of <a title=
"construct" class="termref" href="#dt-construct">construct</a> that
may appear in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>. It identifies the <a title=
"operand role" class="termref" href="#dt-operand-role">operand
roles</a> and their <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a>, and it gives the rules that define
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the construct. In cases where the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, there is still an entry for the construct in order to define
its operands and their usages, since this information is needed by
the general rules.</p>
<p>The following sections describe this categorization for each
kind of construct:</p>
<ul>
<li>
<p>Sequence constructors: see <a href=
"#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence
Constructors</i></a></p>
</li>
<li>
<p>Instructions: see <a href="#classifying-instructions"><i>19.8.4
Classifying Instructions</i></a></p>
</li>
<li>
<p>Attribute sets: see <a href=
"#classifying-attribute-sets"><i>19.8.5 Classifying Attribute
Sets</i></a></p>
</li>
<li>
<p>Value templates: see <a href="#classifying-vts"><i>19.8.6
Classifying Value Templates</i></a></p>
</li>
<li>
<p>Expressions: see <a href="#classifying-expressions"><i>19.8.7
Classifying Expressions</i></a></p>
</li>
<li>
<p>Patterns: see <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a></p>
</li>
<li>
<p>Calls to built-in functions: see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a></p>
</li>
</ul>
<div class="div3">
<h4><a name="general-streamability-rules" id=
"general-streamability-rules"></a>19.8.1 <a href=
"#general-streamability-rules" style=
"text-decoration: none">General Rules for Streamability</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-general-streamability-rules" id=
"dt-general-streamability-rules" title=
"general streamability rules"></a>Many <a title="construct" class=
"termref" href="#dt-construct">constructs</a> share the same
streamability rules. These rules, referred to as the <b>general
streamability rules</b>, are defined here.<span class=
"definition">]</span></p>
<p>Examples of constructs that use these rules are: an arithmetic
expression, an <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value template</a>, a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction, and
a call to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function.</p>
<p>The rules determine both the <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a construct. To determine the posture
and sweep of a construct <var>C</var>, assuming these general rules
are applicable to that kind of construct:</p>
<ol class="enumar">
<li>
<p>For each operand of <var>C</var>:</p>
<ol class="enumla">
<li>
<p>Establish:</p>
<ol class="enumlr">
<li>
<p>The static type <var>T</var> of the operand (see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
<var>S</var> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> of the operand (by applying
the rules in this section <span><a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a></span> to that operand, recursively).</p>
</li>
<li>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> <var>U</var> corresponding to
the <a title="operand role" class="termref" href=
"#dt-operand-role">role</a> of the operand within <var>C</var>
(from the information in this section <span><a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a></span>).</p>
</li>
</ol>
</li>
<li>
<p>Compute the adjusted sweep <var>S'</var> of the operand by
taking the first of the following that applies:</p>
<ol class="enumlr">
<li>
<p>If <var>S</var> is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> or <var>P</var> is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>, then
<var>S'</var> is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. (In this case the posture and
sweep of <var>C</var> are <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, regardless of
any other operands.)</p>
</li>
<li>
<p>If <var>P</var> is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then <var>S'</var> is
<var>S</var>.</p>
</li>
<li>
<p>Otherwise (<var>P</var> is not <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, which implies that the
operand is <span>capable of</span> returning streamed nodes),
compute <var>S'</var> as follows:</p>
<ol class="enumua">
<li>
<p>Compute the adjusted usage <var>U'</var> as follows:</p>
<ol class="enumur">
<li>
<p>If <var>U</var> is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a> and <var>T</var> is a childless
node kind (<code>text()</code>, <code>attribute()</code>,
<code>comment()</code>, <code>processing-instruction</code>, or
<code>namespace-node()</code>), then <var>U'</var> is <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is because the entire subtree of such a node is available
without reading further data from the input stream.</p>
</div>
</li>
<li>
<p>Otherwise, <var>U'</var> is <var>U</var>.</p>
</li>
</ol>
</li>
<li>
<p>Compute the adjusted <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> <var>S'</var> from the table below:</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Posture
(P)</th>
<th colspan="4" align="left" valign="top">Adjusted Usage (U')</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Absorption</th>
<th colspan="1" align="left" valign="top">Inspection</th>
<th colspan="1" align="left" valign="top">Transmission</th>
<th colspan="1" align="left" valign="top">Navigation</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">Climbing</th>
<td align="left" valign="top">Free-ranging</td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Striding</th>
<td align="left" valign="top">Consuming</td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Crawling</th>
<td align="left" valign="top">Free-ranging</td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-potentially-consuming" id="dt-potentially-consuming" title=
"potentially consuming"></a>An <a title="operand" class="termref"
href="#dt-operand">operand</a> is <b>potentially consuming</b> if
either or both of the following conditions applies:<span class=
"definition">]</span></p>
<ol class="enumlr">
<li>
<p>The operand's adjusted <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is <a title="transmission"
class="termref" href="#dt-transmission">transmission</a> and the
operand is not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Having computed the adjusted sweep <var>S'(o)</var> of each
operand <var>o</var>, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <var>C</var> are the first of the
following that applies:</p>
<ol class="enumla">
<li>
<p>If <var>C</var> has no operands, then <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If any operand <var>o</var> has an adjusted sweep
<var>S'(o)</var> of <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If more than one operand <span>is <a title=
"potentially consuming" class="termref" href=
"#dt-potentially-consuming">potentially consuming</a></span>,
then:</p>
<ol class="enumlr">
<li>
<p>If all these operands form part of a <a title=
"choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
of <var>C</var> is the <a title="combined posture" class="termref"
href="#dt-combined-posture">combined posture</a> of the operands in
this group, and the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of <var>C</var> is the widest <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the operands
in this group</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
<li>
<p>If exactly one operand <var>o</var> <span>is <a title=
"potentially consuming" class="termref" href=
"#dt-potentially-consuming">potentially consuming</a></span>,
then:</p>
<ol class="enumlr">
<li>
<p>If <var>o</var> is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of <var>C</var>, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <var>o</var> is <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>
or <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, then <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>o</var> is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a> and <var>C</var>
is a function call of a function whose signature indicates a return
type with a maximum cardinality of one (for example a call on
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exactly-one"><code>exactly-one</code></a><sup><small>FO30</small></sup>),
then <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the adjusted <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <var>o</var>.</p>
</li>
<li>
<p>Otherwise (the <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <var>o</var> is <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>), the <a title="posture" class=
"termref" href="#dt-posture">posture</a> and adjusted <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of
<var>o</var>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise (all operands are <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>) <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The rules ensure that if more than one operand is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
that is, if more than one operand reads the subtree of the context
node in a way that would cause the current position of the input
stream to change, then the construct is not streamable.</p>
<p>The rules also prevent multiple streamed nodes being returned in
the result of an expression unless they arise from the same axis
traversal. For example, the expression <code>count((@*, *))</code>
is not streamable. The same applies to <code>if (X) then @name else
name</code>. This is to make static analysis possible: the posture
needs to be statically determined to ensure that streaming does not
fail at execution time. It is permitted, however, for streamed
nodes to be mixed in a sequence with non-streamed nodes or with
atomic values; in this case the posture of the result will be that
of the streamed nodes.</p>
</div>
</div>
<div class="div3">
<h4><a name="general-streamability-examples" id=
"general-streamability-examples"></a>19.8.2 <a href=
"#general-streamability-examples" style=
"text-decoration: none">Examples of the General Streamability
Rules</a></h4>
<p>This section provides some examples of how the general
streamability rules operate. In each example, the emphasis is on
the outermost construct shown; explanations for how the sweep and
posture of its operands are derived are not given, though in many
cases they are explained in earlier examples.</p>
<p>The examples assume that the context item type for evaluation of
the expression shown is an element node, and that its posture is
striding.</p>
<ul>
<li>
<p><code>2 + 2</code> is grounded and motionless, because both the
operands are grounded and motionless.</p>
</li>
<li>
<p><code>price * 2</code> is grounded and consuming, because one of
the operands is consuming and the relevant operand usage is
absorption.</p>
</li>
<li>
<p><code>price - discount</code> is roaming and free-ranging,
because both the operands are consuming (and they are not members
of a parallel operand group).</p>
</li>
<li>
<p><code>price * @discount</code> is grounded and consuming. The
first operand is consuming and the corresponding operand usage is
absorption, while the second operand is motionless, again with an
operand usage of absorption, and its item type is attribute() which
changes the effective usage to inspection.</p>
</li>
<li>
<p><code>a/b/c</code> is striding and consuming. This is determined
not by the general streamability rules, but by the rules for path
expressions in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>.</p>
</li>
<li>
<p><code>a//c</code> is crawling and consuming. This is similarly
determined by the rules for path expressions in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>.</p>
</li>
<li>
<p><code>count(a/b/c)</code> is grounded and consuming, because the
operand (the argument to the count function) is striding and
consuming (see earlier example) and the operand usage is
inspection.</p>
</li>
<li>
<p><code>sum(a/b/c)</code> is grounded and consuming, because the
operand (the argument to the count function) is striding and
consuming (see earlier example) and the operand usage is
absorption.</p>
</li>
<li>
<p><code>count(a//c)</code> is grounded and consuming, because the
operand (the argument to the count function) is crawling and
consuming (see earlier example) and the operand usage is
inspection.</p>
</li>
<li>
<p><code>sum(a//c)</code> is roaming and free-ranging, because the
operand (the argument to the count function) is crawling and
consuming (see earlier example) and the operand usage is
inspection. The reason this cannot be streamed is that the
<code>c</code> elements might have overlapping subtrees.</p>
</li>
<li>
<p><code>"Q{" || namespace-uri(.) || "}" || local-name(.)</code> is
grounded and motionless. The two literal operands are grounded and
motionless because they have no operands; the two function calls
are grounded and motionless because they have a single operand that
is striding and motionless, with an operand usage of
inspection.</p>
</li>
<li>
<p><code>copy-of(.)/head/following-sibling::*</code> is grounded
and consuming. The first operand <code>copy-of(.)/head</code> is
grounded and consuming because, under the rules in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>, its first operand <code>copy-of(.)</code>
is grounded and consuming. This in turn is because <code>.</code>
is striding and motionless, and the operand usage is
absorption.</p>
</li>
<li>
<p><code>distinct-values((., @code))</code> is roaming and
free-ranging. Although it is not difficult to identify a strategy
for evaluating this in a streaming manner, the static analysis
rules make an expression free-ranging if it has two operands with
different posture. This is because in general this prevents
streamability being determined statically.</p>
</li>
<li>
<p><code>if ($discounted) then price else discounted-price</code>
is striding and consuming, because the two branches of the
conditional are both striding and consuming, and they form an
<a title="choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> with usage
transmission.</p>
</li>
<li>
<p><code>if ($gratis) then 0 else price else</code> is striding and
consuming because there is only one consuming operand (the fact
that it is part of a <a title="choice operand group" class=
"termref" href="#dt-choice-operand-group">choice operand group</a>
does not affect the reasoning).</p>
</li>
<li>
<p><code>count((author, editor))</code> is roaming and
free-ranging. The first argument to the <code>count</code> function
is an expression with two operands, both having usage=transmission,
and neither being grounded.</p>
</li>
<li>
<p><code>count((author | editor))</code> is grounded and consuming.
A union expression is not subject to the general streamability
rules; it has its own rules, defined in <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a>, which establish
in this case that the argument to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
is <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>. The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
function does follow the general streamability rules, with an
operand usage of <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>: under rule 1(b)(iii)(B) the
adjusted sweep is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, and rule 2(d)(iii) then applies.</p>
</li>
<li>
<p><code>('{', author, '}')</code> is striding and consuming.
Exactly one operand is consuming; it has usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, so the result has the posture
and sweep of that operand. (The formal analysis treats comma as a
binary operator, but the same result can be obtained by treating
the content of the parenthesized expression as an expression with
three operands.)</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="classifying-sequence-constructors" id=
"classifying-sequence-constructors"></a>19.8.3 <a href=
"#classifying-sequence-constructors" style=
"text-decoration: none">Classifying Sequence Constructors</a></h4>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> are determined by the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
<p>The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> for a sequence constructor
are:</p>
<ol class="enumar">
<li>
<p>The contained <a title="instruction" class="termref" href=
"#dt-instruction">instructions</a>. The <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> for
these operands is <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>Any <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> appearing in
text nodes within the sequence constructor, if text value templates
are enabled. The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> for these operands is
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Some consequences of these rules are:</p>
<ol class="enumar">
<li>
<p>An empty sequence constructor is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, and its <a title=
"posture" class="termref" href="#dt-posture">posture</a> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>A sequence constructor containing a single instruction has the
same <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> as that instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that sequence constructors containing a single
instruction can usefully be dropped from the construct tree.</p>
</div>
</li>
<li>
<p>Informally, a sequence constructor is not streamable if it
contains more than one instruction that moves the position of the
input stream.</p>
</li>
</ol>
</div>
<p>Instructions within a sequence constructor are further
classified to control the use of <a title="accumulator function"
class="termref" href="#dt-accumulator-function">accumulator
functions:</a></p>
<ol class="enumar">
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-pre-descent-instruction" id="dt-pre-descent-instruction" title=
"pre-descent instruction"></a>A <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> having no <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> instruction as a
preceding sibling is referred to as a <b>pre-descent
instruction</b>.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-post-descent-instruction" id="dt-post-descent-instruction"
title="post-descent instruction"></a>A <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> having no <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> instruction as a
following sibling is referred to as a <b>post-descent
instruction</b>.<span class="definition">]</span></p>
</li>
<li>
<p>In addition, the following are classified as <a title=
"post-descent instruction" class="termref" href=
"#dt-post-descent-instruction">post-descent instructions</a>:</p>
<ol class="enumla">
<li>
<p>Any instruction whose parent is an <a href=
"#element-if"><code>xsl:if</code></a> instruction, if the
<code>test</code> expression is a <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> expression;</p>
</li>
<li>
<p>Any instruction whose parent is an <a href=
"#element-when"><code>xsl:when</code></a> instruction, if the
<code>test</code> expression of the parent <a href=
"#element-when"><code>xsl:when</code></a> or of any preceding
sibling of the parent <a href=
"#element-when"><code>xsl:when</code></a> is a <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> expression</p>
</li>
</ol>
</li>
</ol>
<p>In the above rules, an instruction is considered to be <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> if
its adjusted sweep <var>S'</var> is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, as defined by the the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
when applied to the containing sequence constructor.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that for templates that match text or attribute
nodes, an instruction such as <code>&lt;xsl:value-of
select="."/&gt;</code> is not consuming, which means that all
instructions in the template rule qualify as both pre-descent and
post-descent instructions. The same can happen in a template rule
that does not access the string value or typed value of the context
item.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-instructions" id=
"classifying-instructions"></a>19.8.4 <a href=
"#classifying-instructions" style=
"text-decoration: none">Classifying Instructions</a></h4>
<p>This section describes how <a title="instruction" class=
"termref" href="#dt-instruction">instructions</a> are classified
with respect to their streamability. The criteria are given first
for <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a> and
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>,, then for
each XSLT instruction, listed alphabetically.</p>
<div class="div4">
<h5><a name="streamability-literal-result-elements" id=
"streamability-literal-result-elements"></a>19.8.4.1 <a href=
"#streamability-literal-result-elements" style=
"text-decoration: none">Streamability of Literal Result
Elements</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
element</a> follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> are:</p>
<ol class="enumar">
<li>
<p>The contained sequence constructor (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any expressions contained in <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a> among the literal result element's attributes (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute sets</a> named in the
<code>xsl:use-attribute-sets</code> attribute (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-extension-instructions" id=
"streamability-extension-instructions"></a>19.8.4.2 <a href=
"#streamability-extension-instructions" style=
"text-decoration: none">Streamability of extension
instructions</a></h5>
<p>For a processor that recognizes an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the instruction are <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>For a processor that does not recognize an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the instruction are determined by applying the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> contained in
any <a href="#element-fallback"><code>xsl:fallback</code></a>
children (usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
</ol>
<p>Instructions in the XSLT namespace that are present under the
provisions for <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> are treated in the same way as unrecognized
extension instructions.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules mean that if there is no <a href=
"#element-fallback"><code>xsl:fallback</code></a> child
instruction, the containing construct will be classified as
streamable. However, any attempt to execute the instruction will
lead to a dynamic error, so in fact, neither streamed nor
unstreamed evaluation is possible.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-analyze-string" id=
"streamability-xsl-analyze-string"></a>19.8.4.3 <a href=
"#streamability-xsl-analyze-string" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>the <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>);</p>
</li>
<li>
<p>the <code>regex</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>);</p>
</li>
<li>
<p>the sequence constructors contained in the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
elements. These have usage <a title="navigation" class="termref"
href="#dt-navigation">navigation</a>, because they can be evaluated
more than once. The <span><a title="context posture" class=
"termref" href="#dt-context-posture">context posture</a></span> for
the two sequence constructors is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, reflecting the fact
that their context item type is <code>xs:string</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the instruction will usually be the same
as the sweep of the <code>select</code> expression, and its
<a title="posture" class="termref" href="#dt-posture">posture</a>
will be <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. Exceptions occur for example if the
<code>regex</code> attribute is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, or if the contained
sequence constructors refer to a grouping variable bound in a
contained <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-apply-imports" id=
"streamability-xsl-apply-imports"></a>19.8.4.4 <a href=
"#streamability-xsl-apply-imports" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a></h5>
<p>The rules in this section apply also to <a href=
"#element-next-match"><code>xsl:next-match</code></a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of these two instructions follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>An implicit operand: a context item expression (<code>.</code>),
with usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>;</p>
</li>
<li>
<p>The <code>select</code> attribute or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of each
<a href="#element-with-param"><code>xsl:with-param</code></a> child
element, with <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined usage</a> based on
the type declared in the <code>xsl:with-param/@as</code> attribute,
or <code>item()*</code> if absent.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The instruction will normally be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>, provided that
nodes in a streamed document are not passed as parameters to the
called template rule.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-apply-templates" id=
"streamability-xsl-apply-templates"></a>19.8.4.5 <a href=
"#streamability-xsl-apply-templates" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></h5>
<p>If there is no <code>select</code> attribute, the following
analysis assumes the presence of an implicit operand
<code>select="child::node()"</code>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are the first of the following that apply:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expressions and contained sequence
constructors of any child <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
(usage <a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined</a>, based on the type
in the <code>xsl:with-param/@as</code> attribute, defaulting to
<code>item()*</code>)</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
<p>For example, <code>&lt;xsl:apply-templates
select="copy-of(.)"/&gt;</code> is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the implicit or explicit <code>mode</code> attribute
identifies a <a title="mode" class="termref" href=
"#dt-mode">mode</a> that is not declared with
<code>streamable="yes"</code>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When <code>mode="#current"</code> is specified, this is treated
as equivalent to specifying a streamable mode; although it is not
known statically what the mode will be, it is always the case that
if the template is invoked with a streamed node as the context
item, the the current mode must be a streamable mode.</p>
</div>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> are as follows:</p>
<ol class="enumla">
<li>
<p>The (explicit or implicit) <code>select</code> expression, with
usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>;</p>
</li>
<li>
<p>The <code>select</code> attribute or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of each
<a href="#element-with-param"><code>xsl:with-param</code></a> child
element, with <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined usage</a> based on
the type declared in the <code>xsl:with-param/@as</code> attribute,
or <code>item()*</code> if absent.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-assert" id=
"streamability-xsl-assert"></a>19.8.4.6 <a href=
"#streamability-xsl-assert" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-assert"><code>xsl:assert</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-assert"><code>xsl:assert</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> expression (usage <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-attribute" id=
"streamability-xsl-attribute"></a>19.8.4.7 <a href=
"#streamability-xsl-attribute" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-attribute"><code>xsl:attribute</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-attribute"><code>xsl:attribute</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>separator</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>on-empty</code> expression (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-break" id=
"streamability-xsl-break"></a>19.8.4.8 <a href=
"#streamability-xsl-break" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-break"><code>xsl:break</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-break"><code>xsl:break</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-call-template" id=
"streamability-xsl-call-template"></a>19.8.4.9 <a href=
"#streamability-xsl-call-template" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-call-template"><code>xsl:call-template</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-call-template"><code>xsl:call-template</code></a> follow
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>Unless the referenced template has a child <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
with the attribute <code>use="prohibited"</code>, there is an
implicit operand, a context item expression (<code>.</code>): its
<a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:context-item/@as</code> attribute of
the target named template, defaulting to <code>item()*</code> if
absent.</p>
</li>
<li>
<p>The <code>select</code> expression or sequence constructor
content of any contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
element: its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:with-param/@as</code> attribute, or
the <code>xsl:param/@as</code> attribute of the corresponding
parameter on the target named template, whichever is more
restrictive, defaulting to <code>item()*</code> if both are
absent.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Calling <a href=
"#element-call-template"><code>xsl:call-template</code></a> will
usually make stylesheet code unstreamable if a streamed node is
passed explicitly or implicitly to the called template, unless it
is atomized by declaring the expected type to be atomic.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-choose" id=
"streamability-xsl-choose"></a>19.8.4.10 <a href=
"#streamability-xsl-choose" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-choose"><code>xsl:choose</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-choose"><code>xsl:choose</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> attribute of contained <a href=
"#element-when"><code>xsl:when</code></a> elements (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>).</p>
</li>
<li>
<p>The sequence constructors contained within <a href=
"#element-when"><code>xsl:when</code></a> and <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> child elements
(usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>). These sequence constructor
operands form a <a title="choice operand group" class="termref"
href="#dt-choice-operand-group">choice operand group</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect is to allow any of the following:</p>
<ol class="enumar">
<li>
<p>Every sequence constructor in an <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch may read
the input stream. In this situation the <code>test</code>
expressions must be <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Alternatively, the first <code>test</code> expression may
consume the input stream, in which case the sequence constructors
(and any subsequent <code>test</code> expresssions) must be
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-comment" id=
"streamability-xsl-comment"></a>19.8.4.11 <a href=
"#streamability-xsl-comment" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-comment"><code>xsl:comment</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-comment"><code>xsl:comment</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-copy" id=
"streamability-xsl-copy"></a>19.8.4.12 <a href=
"#streamability-xsl-copy" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-copy"><code>xsl:copy</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-copy"><code>xsl:copy</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>select</code> attribute, defaulting
to a context item expression (<code>.</code>) (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained sequence constructor (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>), assessed
with <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> and context item type
based on the <code>select</code> expression if present, or the
outer focus otherwise.</p>
</li>
<li>
<p>Any <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute-sets</a> named in the
<code>use-attribute-sets</code> attribute (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The expression contained in the <code>on-empty</code> attribute,
if present (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-copy-of" id=
"streamability-xsl-copy-of"></a>19.8.4.13 <a href=
"#streamability-xsl-copy-of" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-copy-of"><code>xsl:copy-of</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-document" id=
"streamability-xsl-document"></a>19.8.4.14 <a href=
"#streamability-xsl-document" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-document"><code>xsl:document</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-document"><code>xsl:document</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-element" id=
"streamability-xsl-element"></a>19.8.4.15 <a href=
"#streamability-xsl-element" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-element"><code>xsl:element</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-element"><code>xsl:element</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>on-empty</code> expression (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The attribute sets named in the <code>use-attribute-sets</code>
attribute (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-evaluate" id=
"streamability-xsl-evaluate"></a>19.8.4.16 <a href=
"#streamability-xsl-evaluate" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>xpath</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>context-item</code> expression (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The <code>with-params</code> expression (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The <code>base-uri</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace-context</code> expression (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>select</code> attributes and contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> of any
<a href="#element-with-param"><code>xsl:with-param</code></a> child
elements (usage <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined</a>, based on the
type in the <code>xsl:with-param/@as</code> attribute, defaulting
to <code>item()*</code>)</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, code containing an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction will
usually be streamable provided that streamed nodes are not passed
to the dynamic expression either as the context item or as the
value of a parameter.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-for-each" id=
"streamability-xsl-for-each"></a>19.8.4.17 <a href=
"#streamability-xsl-for-each" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-for-each"><code>xsl:for-each</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction are
the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>). This is a <a title=
"higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a>; its context
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>).
These are <a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operands</a>; their context
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <code>select</code>
expression and the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ordering of sweep values is in increasing order: <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-for-each-group" id=
"streamability-xsl-for-each-group"></a>19.8.4.18 <a href=
"#streamability-xsl-for-each-group" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction are the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>collation</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>group-by</code> or <code>group-adjacent</code>
expression, assessed with a <a title="context posture" class=
"termref" href="#dt-context-posture">context posture</a> of
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> (usage <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>).</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
<li>
<p>The <code>group-starting-with</code> or
<code>group-ending-with</code> patterns if present; these are
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operands</a> with usage
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
</ol>
</li>
<li>
<p>If there is a <code>group-by</code> attribute, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is a <code>group-adjacent</code> attribute that is not
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is no <code>bind-group</code> attribute, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is a <code>group-adjacent</code> attribute but no
<code>bind-grouping-key</code> attribute, then <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweeps</a> of the <code>select</code>
expression and the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
where the ordering of increasing width is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above rules do not explicitly mention any constraints on the
presence or absence of a variable reference to the variable bound
in the <code>bind-group</code> attribute of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. In practice, however, this plays an important role. In
the most common case, the <code>select</code> expression of
<a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
is likely to be <a title="striding" class="termref" href=
"#dt-striding">striding</a>, for example an expression that selects
all the children of a given element. If the instruction binds a
variable <code>$group</code> using the <code>bind-group</code>
attribute, then any reference to this variable will ordinarily be
<a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, which is consistent
with streaming provided there is only one such reference, and if it
appears in a suitable context (for example, not within a
predicate). <span>If there is more than one reference to the
grouping variable, or if it appears in an unsuitable context (for
example, within a predicate), then this will have the same effect
as multiple appearances of other consuming expressions: the
construct as a whole will be <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</span> These
rules are not spelled out explicitly, but rather emerge as a
consequence of the general streamability rules.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-fork" id=
"streamability-xsl-fork"></a>19.8.4.19 <a href=
"#streamability-xsl-fork" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-fork"><code>xsl:fork</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-fork"><code>xsl:fork</code></a> are the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If there are no child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions,
then <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If there is exactly one child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction that
is not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of that
instruction.</p>
</li>
<li>
<p>If any of the child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions is
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
or <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of any of the child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions is
not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that none of the branches of <a href=
"#element-fork"><code>xsl:fork</code></a> can return streamed
nodes. The reason for this is that <a href=
"#element-fork"><code>xsl:fork</code></a> has to assemble its
results in the correct order, and streamed nodes cannot be
re-ordered.</p>
</div>
</li>
<li>
<p>Otherwise, <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of the rules is that each of the child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions can
independently consume the streamed input document, provided that
the result of each child instruction is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
<p>Thus the following example is streamable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="copy-of(author)"/&gt;
   &lt;xsl:sequence select="copy-of(editor)"/&gt;
&lt;/xsl:fork&gt;
</pre></div>
<p>While the following is not streamable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="author"/&gt;
   &lt;xsl:sequence select="editor"/&gt;
&lt;/xsl:fork&gt;
</pre></div>
<p>This is because the latter example attempts to return a sequence
of streamed nodes in an order which might not be document
order.</p>
<p>The only case where <a href=
"#element-fork"><code>xsl:fork</code></a> is permitted to return
streamed nodes is in the case where only one of the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions is
consuming (in which case the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction is
pointless).</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-if" id=
"streamability-xsl-if"></a>19.8.4.20 <a href=
"#streamability-xsl-if" style="text-decoration: none">Streamability
of</a> <a href="#element-if"><code>xsl:if</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-if"><code>xsl:if</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> expression (usage <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-iterate" id=
"streamability-xsl-iterate"></a>19.8.4.21 <a href=
"#streamability-xsl-iterate" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-iterate"><code>xsl:iterate</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction are the
first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-param"><code>xsl:param</code></a> children (usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The sequence constructor contained within the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction itself,
assessed with its content item type and <a title="context posture"
class="termref" href="#dt-context-posture">context posture</a>
based on the <code>select</code> expression (usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any child <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, assessed with a content item type of <code>xs:error</code>
and a <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> to reflect the fact
that any attempt to reference the context item within the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
is an error (usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
</ol>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweeps</a> of the two operands, where
the ordering of increasing width is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If any <a href="#element-break"><code>xsl:break</code></a> or
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instructions appear within the sequence constructor, their
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
will be assessed in the course of evaluating the <a title="posture"
class="termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of the sequence
constructor, by reference to the rules in <a href=
"#streamability-xsl-break"><i>19.8.4.8 Streamability of
xsl:break</i></a> and <a href=
"#streamability-xsl-next-iteration"><i>19.8.4.27 Streamability of
xsl:next-iteration</i></a> respectively.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-map" id=
"streamability-xsl-map"></a>19.8.4.22 <a href=
"#streamability-xsl-map" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-map"><code>xsl:map</code></a></h5>
<p>The <span><a title="posture" class="termref" href=
"#dt-posture">posture</a></span> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <a href=
"#element-map"><code>xsl:map</code></a> instruction are determined
by the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the sequence constructor within the instruction consists
exclusively of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions
(and <a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, which are ignored), and if none of those <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> children is
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
or <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, then the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the <a href=
"#element-map"><code>xsl:map</code></a> instruction is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and the
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> is the
widest sweep of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> children.</p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-map"><code>xsl:map</code></a> instruction are the posture
and sweep of the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence
constructor</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>See discussion in <a href="#maps-streaming"><i>21.1.5 Maps and
Streaming</i></a>.</p>
<p>The effect of the rules is that it is possible to compute
multiple map entries in a single pass of the streamed input
document. For example, the following is streamable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'authors'" select="copy-of(author)"/&gt;
  &lt;xsl:map-entry key="'editors'" select="copy-of(editor)"/&gt;
&lt;/xsl:map&gt;  
</pre></div>
<p>The call on <a href="#func-copy-of"><code>copy-of</code></a> is
necessary to ensure that the content of the map entry is grounded;
it is not possible to create a map whose entries contain references
to streamed nodes.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-map-entry" id=
"streamability-xsl-map-entry"></a>19.8.4.23 <a href=
"#streamability-xsl-map-entry" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-map-entry"><code>xsl:map-entry</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>key</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This effectively means that the <code>select</code> expression
must not return nodes from a streamed input document.</p>
</div>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-merge" id=
"streamability-xsl-merge"></a>19.8.4.24 <a href=
"#streamability-xsl-merge" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-merge"><code>xsl:merge</code></a></h5>
<p>If all <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
are <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> then the instruction is <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<p>Otherwise, the instruction is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction will often process its input using streaming, but the
rule here is concerned with the <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the instruction with respect to the
document containing the context node, which will not usually be one
of the primary inputs to the merging process. A merge operation
that processes several input documents in a streaming manner might
thus be classified as free-ranging with respect to the principal
source document of the transformation.</p>
<p>A more ambitious implementation might attempt to recognize the
case where one of the merge sources involves consuming a subtree of
the principal source document: that is, the case where one merge
source is a <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> expression and the other sources are
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-message" id=
"streamability-xsl-message"></a>19.8.4.25 <a href=
"#streamability-xsl-message" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-message"><code>xsl:message</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-message"><code>xsl:message</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>terminate</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-namespace" id=
"streamability-xsl-namespace"></a>19.8.4.26 <a href=
"#streamability-xsl-namespace" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-namespace"><code>xsl:namespace</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-namespace"><code>xsl:namespace</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-next-iteration" id=
"streamability-xsl-next-iteration"></a>19.8.4.27 <a href=
"#streamability-xsl-next-iteration" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression or <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> content of any
contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
element: its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:with-param/@as</code> attribute, or
the <code>xsl:param/@as</code> attribute of the corresponding
parameter on the containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction,
whichever is more restrictive, defaulting to <code>item()*</code>
if both are absent.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-next-match" id=
"streamability-xsl-next-match"></a>19.8.4.28 <a href=
"#streamability-xsl-next-match" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-next-match"><code>xsl:next-match</code></a></h5>
<p>The rules are the same as for <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>: see
<a href="#streamability-xsl-apply-imports"><i>19.8.4.4
Streamability of xsl:apply-imports</i></a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-xsl-number" id=
"streamability-xsl-number"></a>19.8.4.29 <a href=
"#streamability-xsl-number" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-number"><code>xsl:number</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-number"><code>xsl:number</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>value</code> attribute if present (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> attribute if present (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The attribute value templates in the <code>format</code>,
<code>lang</code>, <code>letter-value</code>, <code>ordinal</code>,
<code>start-at</code>, <code>grouping-separator</code>, and
<code>grouping-size</code> attributes (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>from</code> and <code>count</code> patterns if
present; these are <a title="higher-order operand" class="termref"
href="#dt-higher-order-operand">higher-order operands</a> with
usage <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of these rules is that <a href=
"#element-number"><code>xsl:number</code></a> can be used for
formatting of numbers supplied directly, and for numbering of nodes
in a non-streamed document, but cannot be used for numbering
streamed nodes.</p>
<p>In practice the rules depend very little on the
<code>from</code> and <code>count</code> patterns. This is because
when the instruction is applied to a streamed node, the instruction
will be <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> regardless of these patterns;
while if it is applied to a grounded node or atomic value, the
instruction will be <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> regardless of the values of these
patterns. The only restriction is that the patterns must not
reference a grouping variable.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-perform-sort" id=
"streamability-xsl-perform-sort"></a>19.8.4.30 <a href=
"#streamability-xsl-perform-sort" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a> follow
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>select</code> attribute: usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a> (because order is not
preserved)</p>
</li>
<li>
<p>The expressions in the attribute value templates of <a href=
"#element-sort"><code>xsl:sort</code></a> child elements: usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a></p>
</li>
<li>
<p>The expression in the <code>select</code> attribute <span>or
contained sequence constructor</span> in child <a href=
"#element-sort"><code>xsl:sort</code></a> child elements, with
usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, assessed with <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> based on the
expression in the <code>xsl:perform-sort/@select</code>
attribute.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction cannot be used to sort nodes from the streamed input
document, but it can be used to sort atomic values or <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> nodes,
for example a copy of nodes from the streamed document made using
the <a href="#func-copy-of"><code>copy-of</code></a> function.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-processing-instruction" id=
"streamability-xsl-processing-instruction"></a>19.8.4.31 <a href=
"#streamability-xsl-processing-instruction" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-result-document" id=
"streamability-xsl-result-document"></a>19.8.4.32 <a href=
"#streamability-xsl-result-document" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-result-document"><code>xsl:result-document</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-result-document"><code>xsl:result-document</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>href</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The attribute value templates containing serialization
properties (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-sequence" id=
"streamability-xsl-sequence"></a>19.8.4.33 <a href=
"#streamability-xsl-sequence" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-sequence"><code>xsl:sequence</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-sequence"><code>xsl:sequence</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> attribute value template (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-stream" id=
"streamability-xsl-stream"></a>19.8.4.34 <a href=
"#streamability-xsl-stream" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-stream"><code>xsl:stream</code></a></h5>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The concern here is with the impact of <a href=
"#element-stream"><code>xsl:stream</code></a> on any streaming
template, or ancestor <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, and not
with the streamed processing of the document accessed using the
<code>xsl:stream/@href</code> attribute.</p>
<p>The streamability of the document opened by the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is not
assessed using the rules in this section; it depends only on the
streamability properties of the contained sequence constructor, as
described in <a href="#stream-instruction"><i>18.1 The xsl:stream
Instruction</i></a></p>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-stream"><code>xsl:stream</code></a> are the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If the contained sequence constructor contains, at any depth, a
variable reference whose binding is a <code>bind-group</code>
attribute of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> or
<a href="#element-merge"><code>xsl:merge</code></a> instruction
that is itself an ancestor of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
and <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="grounded" class="termref"
href="#dt-grounded">grounded</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <code>href</code>
attribute value template.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effective prohibition on grouping variable references is
largely to avoid complicating the analysis. It means that posture
and sweep for the constructs within <a href=
"#element-stream"><code>xsl:stream</code></a> need to be computed
only with respect to the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction itself,
and not with respect to the containing template, or an outer
<a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-text" id=
"streamability-xsl-text"></a>19.8.4.35 <a href=
"#streamability-xsl-text" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-text"><code>xsl:text</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-text"><code>xsl:text</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
There are no operands.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The instruction is therefore <a title="grounded" class="termref"
href="#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-try" id=
"streamability-xsl-try"></a>19.8.4.36 <a href=
"#streamability-xsl-try" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-try"><code>xsl:try</code></a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression and/or sequence
constructor of the <a href=
"#element-catch"><code>xsl:catch</code></a> element are <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
then the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the <code>select</code> expression and/or
sequence constructor of the <a href=
"#element-try"><code>xsl:try</code></a> element (whichever is
present);</p>
</li>
<li>
<p>Otherwise, <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-value-of" id=
"streamability-xsl-value-of"></a>19.8.4.37 <a href=
"#streamability-xsl-value-of" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-value-of"><code>xsl:value-of</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-value-of"><code>xsl:value-of</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>separator</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-variable" id=
"streamability-xsl-variable"></a>19.8.4.38 <a href=
"#streamability-xsl-variable" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-variable"><code>xsl:variable</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-variable"><code>xsl:variable</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>).</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of the initialization expression having usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a> is that it is not possible in
streamable constructs to bind a variable to a node in a streamed
document.</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="classifying-attribute-sets" id=
"classifying-attribute-sets"></a>19.8.5 <a href=
"#classifying-attribute-sets" style=
"text-decoration: none">Classifying Attribute Sets</a></h4>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply to <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute sets</a>. The <a title="operand role"
class="termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> are:</p>
<ol class="enumar">
<li>
<p>Any <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction contained in <span>any of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up</span> the attribute set. (Usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>Any attribute set referenced by a
<span><code>use-attribute-sets</code> attribute in any of the
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up</span> the attribute set. (Usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
</ol>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of an attribute set is determined using the general rules in
<a href="#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Attribute sets will always be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, because they return
newly constructed attribute nodes.</p>
<p>Attribute sets will very often be <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, but if they access
the context item, they may be <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> or <a title="free-ranging"
class="termref" href="#dt-free-ranging">free-ranging</a>.</p>
<p>Because attribute sets can be overridden in another <a title=
"package" class="termref" href="#dt-package">package</a>, the
streamability of a construct such as an <a href=
"#element-element"><code>xsl:element</code></a> instruction
containing a <code>use-attribute-sets</code> attribute is based on
the declared streamability of the named attribute sets, as defined
by the <code>streamable</code> attribute of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element. If <code>streamable="yes"</code> is specified, then there
is a requirement that any overriding attribute set should also
specify <code>streamable="yes"</code>, and a streaming processor is
required to check that an attribute set containing such a
declaration does in fact satisfy the streamability rules.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-vts" id="classifying-vts"></a>19.8.6
<a href="#classifying-vts" style=
"text-decoration: none">Classifying Value Templates</a></h4>
<p>A <a title="value template" class="termref" href=
"#dt-value-template">value template</a> (that is, an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> or
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value template</a>) is a <a title=
"construct" class="termref" href="#dt-construct">construct</a>
whose operands are the expressions contained within curly braces.
The required type for this operand role is <code>xs:string</code>
and the <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> is <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>.</p>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a value template are determined using
the general rules in <a href=
"#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a>.</p>
<p>If there are no expressions contained within curly braces, the
value template is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</div>
<div class="div3">
<h4><a name="classifying-expressions" id=
"classifying-expressions"></a>19.8.7 <a href=
"#classifying-expressions" style=
"text-decoration: none">Classifying Expressions</a></h4>
<p>XPath expressions are classified using the rules in this
section.</p>
<p>In the analysis that follows, <a title="expression" class=
"termref" href="#dt-expression">expressions</a> are classified
according to the most specific production rule that they match for
which there is an entry in this section. For example, the
expression <code>3</code> satisfies the productions
<code>NumericLiteral</code>, <code>Literal</code>, and
<code>ArithmeticExpression</code>; the most specific of these for
which there is an entry in this section is <code>Literal</code>. A
production <var>P</var> is considered more specific than a
production <var>Q</var> (<var>Q</var> ≠ <var>P</var>) if every
expression that matches <var>P</var> also matches <var>Q</var>.</p>
<p>The production rules for different kinds of expression are
listed (with their names and numbers) in the order in which they
appear in Appendix A.1 of the XPath 3.0 specification.</p>
<p>Many expressions can be analyzed using the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These are indicated in the table below by means of a simple
proforma in which the <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> are represented by a short
code (A = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, I = <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>, T = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, N = <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>). For example
the proforma <code>A + A</code> indicates that for an arithmetic
expression, both operands have <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
while <code>I or I</code> indicates that for an <code>or</code>
expression, both operands have <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>.
For expressions where further explanation is needed, the table
contains a link to the relevant section.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Construct</th>
<th colspan="1" align="left" valign="top">Proforma or Reference to
Detailed Rules</th>
<th colspan="1" align="left" valign="top">Further Information</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Expr [6]</td>
<td align="left" valign="top"><code>T, T</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ForExpr [8]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-for-expressions"><i>19.8.7.1 Streamability of
for expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">LetExpr [11]</td>
<td align="left" valign="top"><code>let $var := N return
T</code></td>
<td align="left" valign="top">Binding of variables to streamed
nodes is not allowed.</td>
</tr>
<tr>
<td align="left" valign="top">QuantifiedExpr [14]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-quantified-expressions"><i>19.8.7.2
Streamability of Quantified Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">IfExpr [15]</td>
<td align="left" valign="top"><span><code>if (I) then T else
T</code></span></td>
<td align="left" valign="top">The then-clause and else-clause form
a <a title="choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> with usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a></td>
</tr>
<tr>
<td align="left" valign="top">OrExpr [16]</td>
<td align="left" valign="top"><code>I or I</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AndExpr [17]</td>
<td align="left" valign="top"><code>I and I</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">StringConcatExpr [19]</td>
<td align="left" valign="top"><code>A || A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">RangeExpr [20]</td>
<td align="left" valign="top"><code>A to A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AdditiveExpr [21]</td>
<td align="left" valign="top"><code>A + A</code>, <code>A -
A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">MultiplicativeExpr [22]</td>
<td align="left" valign="top"><code>A * A</code>, <code>A div
A</code>, etc</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">UnionExpr [23]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">IntersectExceptExpr [24]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">InstanceOfExpr [25]</td>
<td align="left" valign="top"><code>I instance of TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">TreatExpr [26]</td>
<td align="left" valign="top"><code>T treat as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">CastableExpr [27]</td>
<td align="left" valign="top"><code>A castable as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">CastExpr [28]</td>
<td align="left" valign="top"><code>A cast as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">UnaryExpr [29]</td>
<td align="left" valign="top"><code>+A</code>, <code>-A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">GeneralComp [31]</td>
<td align="left" valign="top"><code>A = A</code>, <code>A &lt;
A</code>, <code>A != A</code>, etc</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ValueComp [32]</td>
<td align="left" valign="top"><code>A eq A</code>, <code>A lt
A</code>, <code>A ne A</code>, etc</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">NodeComp [33]</td>
<td align="left" valign="top"><span><code>I is I</code>, <code>I
&lt;&lt; I</code>, <code>I &gt;&gt; I</code></span></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">SimpleMapExpr [34]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-simple-mapping-expressions"><i>19.8.7.5
Streamability of Simple Mapping Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PathExpr [35]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">RelativePathExpr [36]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AxisStep [38]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ForwardStep [39] , ReverseStep
[42]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PostfixExpr [48]: Filter
Expression</td>
<td align="left" valign="top">See <a href=
"#streamability-of-filter-expressions"><i>19.8.7.8 Streamability of
Filter Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PostfixExpr [48]: Dynamic Function
Call</td>
<td align="left" valign="top">See <a href=
"#streamability-of-dynamic-function-calls"><i>19.8.7.9
Streamability of Dynamic Function Calls</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">Literal [53]</td>
<td align="left" valign="top"></td>
<td align="left" valign="top">There are no operands, so the
construct is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></td>
</tr>
<tr>
<td align="left" valign="top">VarRef [55]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-variable-references"><i>19.8.7.10 Streamability
of Variable References</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">ParenthesizedExpr
[57]</td>
<td align="left" valign="top"><code>(T)</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top"><code>()</code></td>
<td align="left" valign="top">There are no operands, so the
construct is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></td>
</tr>
<tr>
<td align="left" valign="top">ContextItemExpr [58]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-context-item-expression"><i>19.8.7.11
Streamability of the Context Item Expression</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">FunctionCall [59]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">NamedFunctionRef [63]</td>
<td align="left" valign="top"><span>See <a href=
"#streamability-of-named-function-ref"><i>19.8.7.13 Streamability
of Named Function References</i></a></span></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">InlineFunctionExpr [64]</td>
<td align="left" valign="top"><span>See <a href=
"#streamability-of-inline-functions"><i>19.8.7.14 Streamability of
Inline Function Declarations</i></a></span></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">MapExpr [202]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-map-expressions"><i>19.8.7.15 Streamability of
map expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
</tbody>
</table>
<div class="div4">
<h5><a name="streamability-of-for-expressions" id=
"streamability-of-for-expressions"></a>19.8.7.1 <a href=
"#streamability-of-for-expressions" style=
"text-decoration: none">Streamability of</a> <code>for</code>
<a href="#streamability-of-for-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>Writing the expression as <code>for $v in S return R</code>, the
two operand roles are <var>S</var> and <var>R</var>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are determined by the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If <var>R</var> is not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply. The operand roles are:</p>
<ol class="enumla">
<li>
<p>The <code>in</code> expression (<code>S</code>). This has
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> <a title="navigation" class="termref"
href="#dt-navigation">navigation</a>.</p>
</li>
<li>
<p>The <code>return</code> expression (<code>R</code>). This is a
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a> with <a title=
"operand usage" class="termref" href="#dt-operand-usage">usage</a>
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Expressions of the form <code>for $i in 1 to 3 return
$i*2</code>, where there is no reference to a streamed node, are
clearly streamable.</p>
<p>The <code>in</code> expression can also be consuming, for
example <code>for $e in copy-of(emp)</code> return $e/salary.</p>
<p>The rule that <var>R</var> must be grounded prevents the
variable being bound to a node in a streamed document. This
disallows expressions of the form <code>for $x in child::section
return $x/para</code>, because this requires data flow analysis
(tracing from the binding of a variable to its usages), rather than
purely syntactic analysis. Some implementations may be able to
stream such constructs.</p>
<p>The fact that the return clause is a higher-order operand
prevents it from being a consuming expression, for example
<code>for $i in 1 to 3 return salary</code>. Use of a motionless
expression that accesses streamed nodes is however allowed, for
example <code>for $i in 1 to 3 return
name(ancestor::x[$i])</code>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-quantified-expressions" id=
"streamability-of-quantified-expressions"></a>19.8.7.2 <a href=
"#streamability-of-quantified-expressions" style=
"text-decoration: none">Streamability of Quantified
Expressions</a></h5>
<p>Writing the expression as <code>some|every $v in S satisfies
C</code>, the two operand roles are <var>S</var> and
<var>C</var>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are determined by the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If <var>C</var> is not <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>, then <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <var>S</var>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-of-if-expressions" id=
"streamability-of-if-expressions"></a>19.8.7.3 <a href=
"#streamability-of-if-expressions" style=
"text-decoration: none">Streamability of</a> <code>if</code>
<a href="#streamability-of-if-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>Writing the expression as <code>if (C) then T else E</code>,
there are three operand roles: <var>C</var>, <var>T</var>, and
<var>E</var>. The <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of <var>C</var> is <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>,
while the <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of <var>T</var> and <var>E</var> is
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>. Operands <var>T</var> and
<var>E</var> form a <a title="choice operand group" class="termref"
href="#dt-choice-operand-group">choice operand group</a>, meaning
that they can both consume the input stream, provided they have
consistent <a title="posture" class="termref" href=
"#dt-posture">posture</a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-union-expressions" id=
"streamability-of-union-expressions"></a>19.8.7.4 <a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">Streamability of</a>
<code>union</code><a href="#streamability-of-union-expressions"
style="text-decoration: none">,</a> <code>intersect</code><a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">, and</a> <code>except</code> <a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are the first of the following that
applies:</p>
<ol class="enumar">
<li>
<p>If either of the two operands is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> (Example: <code>. |
following-sibling::*</code>).</p>
</li>
<li>
<p>If either of the two operands is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
then the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the other operand (Example: <code>. |
doc('abc.com')//x</code>)</p>
</li>
<li>
<p>If both operands are <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> (Example: <code>@x | @y</code>)</p>
</li>
<li>
<p>If both operands are <a title="striding" class="termref" href=
"#dt-striding">striding</a> or <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, then <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a> and the wider of the
sweeps of the two operands (Example: <code>* | */*</code>).</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a> (Example:
<code>name | @name</code>).</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Essentially the principle is that if both operands are
streamable, then the result is streamable (this assumes an
evaluation strategy where both operands are evaluated during the
same pass of the streamed input document, and the results merged).
But there are caveats because of the need for static streamability
analysis of the result. This prevents constructs such as <code>.. |
*</code> that have heterogeneous posture.</p>
<p>Where the two operands are both <a title="striding" class=
"termref" href="#dt-striding">striding</a>, there are cases where
an implementation could determine that the result is also <a title=
"striding" class="termref" href="#dt-striding">striding</a>: for
example <code>(author | editor)</code>. In general, however, the
combination of two striding operands may produce a sequence of
nodes that have overlapping subtrees (consider <code>author |
author/name</code>), so the result is classified as <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>.</p>
<p>The expression <code>(author | editor)</code>, although it is
not <a title="striding" class="termref" href=
"#dt-striding">striding</a>, can be rewritten in the form
<code>*[self::author or self::editor]</code>, which is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-simple-mapping-expressions" id=
"streamability-of-simple-mapping-expressions"></a>19.8.7.5 <a href=
"#streamability-of-simple-mapping-expressions" style=
"text-decoration: none">Streamability of Simple Mapping
Expressions</a></h5>
<p>The mapping operator <code>!</code> is treated as a
left-associative binary operator, so the expression
<code>a!b!c</code> is processed as <code>(a!b)!c</code>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the expression are the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
right-hand operand, assessed with a <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and type set to
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the first operand.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-path-expressions" id=
"streamability-of-path-expressions"></a>19.8.7.6 <a href=
"#streamability-of-path-expressions" style=
"text-decoration: none">Streamability of Path Expressions</a></h5>
<p>The streamability analysis applies after the expansion of the
<code>//</code> pseudo-operator to
<code>/descendant-or-self::node()/</code>, and after expanding
<code>..</code> to <code>parent::node()</code>, <code>@X</code> to
<code>attribute::X</code>, and an omitted axis to
<code>child::</code>.</p>
<p>Following the rules in XPath, a leading <code>"/"</code> is
converted to <code>(root(self::node()) treat as
document-node())/</code> (with the final <code>"/"</code> omitted
for the expression <code>"/"</code> on its own). This is followed
by a rewrite of the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>,
as described in <a href="#streamability-fn-root"><i>19.8.8.10
Streamability of the root function</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Taken together, these rewrites have the effect that a path
expression such as <code>//a</code> is streamable only if the
statically-determined context item type is
<code>document-node()</code>, which will be the case for example
immediately within <a href=
"#element-stream"><code>xsl:stream</code></a>, or in a template
rule with <code>match="/"</code>.</p>
</div>
<p>A <code>RelativePathExpr</code> with more than two operands
(such as <code>a/b/c</code>) is taken as a tree of binary
expressions (that is, <code>(a/b)/c</code>). This prevents some
optimizations which are possible if the
<code>RelativePathExpr</code> is considered as a whole: these
optimizations should be applied by rewriting the tree before this
analysis takes place, as described in <a href=
"#pattern-scanning"><i>19.1 An Optimization: Pattern-Based
Scanning</i></a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
right-hand operand, assessed with a <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and type set to
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the first operand.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples:</p>
<ul>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is striding, then
the posture of the expression <code>a/b/c</code> is striding,
because (under the rules for AxisStep [38]) a child axis step
evaluated with striding posture creates a new striding posture.</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is striding, then
the posture of the expression <code>a//c</code> is crawling,
because a descendant axis step evaluated with striding posture
creates a new crawling posture.</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is striding, then
the posture of the expression <code>../@status</code> is climbing,
because a parent axis step evaluated with striding posture creates
a new climbing posture, and an attribute axis step evaluated with
climbing posture creates a new climbing posture.</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is striding, then
the posture of the expression
<code>copy-of(.)//a/following-sibling::*</code> is grounded,
because the <a href="#func-copy-of"><code>copy-of</code></a>
evaluated with striding posture creates a grounded posture, and all
subsequent axis steps leave this posture unchanged.</p>
</li>
</ul>
</div>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the expression is the wider <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the two operands, where the ordering
of increasing width is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples:</p>
<ul>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/@code</code> is <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> (the wider of <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/descendant::b</code> is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> (the wider of
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./@code</code> is <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> (the wider of <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
and <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./a</code> is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> (the wider of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and <a title=
"consuming" class="termref" href=
"#dt-consuming">consuming</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/following::b</code> is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a> (the wider of
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./.</code> is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> (the wider of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
</ul>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-axis-steps" id=
"streamability-of-axis-steps"></a>19.8.7.7 <a href=
"#streamability-of-axis-steps" style=
"text-decoration: none">Streamability of Axis Steps</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression are determined by the
first of the following rules that applies:</p>
<ol class="enumar">
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, then
the sweep is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and the posture is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>;</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>, then the
sweep is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> and the posture is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>;</p>
</li>
<li>
<p>If the statically-inferred <a title="context item type" class=
"termref" href="#dt-context-item-type">context item type</a> is
such that the axis will always be empty (for example, applying the
child axis to a text node or the parent axis to a document node),
then the sweep is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and the posture is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>
(because the expression is statically known to return an empty
sequence);</p>
</li>
<li>
<p>If the <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, and the axis is
descendant or descendant-or-self, and there is a predicate in the
<code>PredicateList</code> that is either a numeric literal or a
reference to a variable whose declared type is numeric (for
example, <code>descendant::title[1]</code>), then <a title=
"striding" class="termref" href="#dt-striding">striding</a> and
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>;</p>
</li>
<li>
<p>If the <code>PredicateList</code> contains a
<code>Predicate</code> that is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then the sweep is
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> and the posture is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>;</p>
</li>
<li>
<p>Otherwise, the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression are as determined by
the table below, based on the <span><a title="context posture"
class="termref" href="#dt-context-posture">context
posture</a></span> and the choice of axis:</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Context posture</th>
<th colspan="1" align="left" valign="top">Axis</th>
<th colspan="1" align="left" valign="top">Result posture</th>
<th colspan="1" align="left" valign="top">Sweep</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Grounded</td>
<td align="left" valign="top">any</td>
<td align="left" valign="top">Grounded</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">self, parent, ancestor-or-self,
ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top"><span>parent</span>,
ancestor-or-self, ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">self</td>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">child</td>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">Consuming</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">descendant, descendant-or-self</td>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">Consuming</td>
</tr>
<tr>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top"><span>parent</span>,
ancestor-or-self, ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">self</td>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Any other
combination</td>
<td align="left" valign="top">Roaming</td>
<td align="left" valign="top">Free-ranging</td>
</tr>
</tbody>
</table>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This analysis does not attempt to classify
<code>para[title]</code> as a consuming expression; an
implementation might choose to do so.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-filter-expressions" id=
"streamability-of-filter-expressions"></a>19.8.7.8 <a href=
"#streamability-of-filter-expressions" style=
"text-decoration: none">Streamability of Filter
Expressions</a></h5>
<p>For a filter expression of the form <code>B[P]</code> (where
<var>B</var> might itself be a filter expression), the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> are the
first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If <var>B</var> is <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, and <var>B</var> is
either a numeric literal, or a reference to a variable whose
declared type is numeric, then <a title="crawling" class="termref"
href="#dt-crawling">crawling</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>If <var>P</var> is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, then the <a title="posture" class=
"termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <var>B</var>;</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The first rule allows a construct such as
<code>&lt;xsl:apply-templates select="(//title)[1]"/&gt;</code>,
where a <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> operand would not be guaranteed
streamable.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This section is not applicable to predicates forming part of an
axis step, such as <code>//title[1]</code>, as these are not
technically filter expressions. See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-dynamic-function-calls" id=
"streamability-of-dynamic-function-calls"></a>19.8.7.9 <a href=
"#streamability-of-dynamic-function-calls" style=
"text-decoration: none">Streamability of Dynamic Function
Calls</a></h5>
<p>For a dynamic function call such as <code>$F(X, Y)</code>, the
general rule in <a href="#general-streamability-rules"><i>19.8.1
General Rules for Streamability</i></a> applies. The operands of a
dynamic function call are the expression that computes the function
value itself (here <code>$F</code>), and the argument expressions
(here <code>X</code> and <code>Y</code>).</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of the first operand is
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, reflecting the fact that the only
action needed at evaluation time is to inspect the value (if it is
a node, a type error is raised).</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> for the other operands (the
argument expressions) is in general <a title="navigation" class=
"termref" href="#dt-navigation">navigation</a>, because it is not
known how the function will make use of any supplied nodes.
However, if the static type of the first operand constrains the
type of the argument to be atomic, then the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> for that argument becomes <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>, and if it
constrains it to be a function, the <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> becomes
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-variable-references" id=
"streamability-of-variable-references"></a>19.8.7.10 <a href=
"#streamability-of-variable-references" style=
"text-decoration: none">Streamability of Variable
References</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the variable reference <var>V</var>
are the first of the following that apply:</p>
<ol class="enumar">
<li>
<p>If all the following conditions are satisfied:</p>
<ol class="enumla">
<li>
<p><var>V</var> is a reference to a variable declared in a
<code>bind-group</code> attribute of a containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction <var>F</var></p>
</li>
<li>
<p>The path in the construct tree that connects <var>V</var> to the
sequence constructor forming the body of <var>F</var> is such that
no child construct is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of its parent</p>
</li>
<li>
<p>The <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>V</var> is <var>F</var></p>
</li>
</ol>
<p>then the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>V</var> are the <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> and <a title="posture"
class="termref" href="#dt-posture">posture</a> of the
<code>select</code> expression of <var>F</var>.</p>
</li>
<li>
<p>If all the following conditions are satisfied:</p>
<ol class="enumla">
<li>
<p><var>V</var> is a reference to a variable declared in a
<code>bind-group</code> attribute of a containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction
<var>M</var></p>
</li>
<li>
<p>The path in the construct tree that connects <var>V</var> to the
sequence constructor forming the body of <var>M</var> is such that
no child construct is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of its parent</p>
</li>
<li>
<p>The <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>V</var> is <var>M</var></p>
</li>
</ol>
<p>then the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>V</var> are the <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> and <a title="posture"
class="termref" href="#dt-posture">posture</a> of the sequence
constructor contained in <var>M</var>.</p>
</li>
<li>
<p>If all the following conditions are satisfied:</p>
<ol class="enumla">
<li>
<p><var>V</var> is a reference to a variable declared in a
<code>bind-source</code> attribute of an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child of
a containing <a href="#element-merge"><code>xsl:merge</code></a>
instruction <var>M</var></p>
</li>
<li>
<p>The path in the construct tree that connects <var>V</var> to the
sequence constructor forming the body of <var>M</var> is such that
no child construct is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of its parent</p>
</li>
<li>
<p>The <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>V</var> is <var>M</var></p>
</li>
</ol>
<p>then the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>V</var> are the <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> and <a title="posture"
class="termref" href="#dt-posture">posture</a> of the sequence
constructor contained in <var>M</var>.</p>
</li>
<li>
<p>Otherwise, <var>V</var> is <a title="roaming" class="termref"
href="#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Informally, for streamed evaluation to be possible, a grouping
variable reference must not appear in a construct that is evaluated
repeatedly. For example, if <code>$g</code> is the variable bound
to the current group, then the expression <code>for $i in 1 to 10
return $g</code> would not be streamable.</p>
</div>
<p>Otherwise, the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the expression is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules reflect the fact that a node in a streamed document
can never be bound to a variable, except in the case where it is
part of the current group of nodes bound to a grouping
variable.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-context-item-expression" id=
"streamability-of-context-item-expression"></a>19.8.7.11 <a href=
"#streamability-of-context-item-expression" style=
"text-decoration: none">Streamability of the Context Item
Expression</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression is the <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span>, and the <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> is <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although <code>.</code> is intrinsically motionless, when used
in certain contexts (such as <code>data(.)</code>) the containing
expression will be <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. This arises because of the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a>: the argument to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-data"><code>data</code></a><sup><small>FO30</small></sup>
has usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, and the combination of a <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
operand with usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a> leads to the containing expression
being <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
<p>Similarly, if <code>.</code> is used where the operand usage is
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>, the containing expression will be
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-function-calls" id=
"streamability-of-function-calls"></a>19.8.7.12 <a href=
"#streamability-of-function-calls" style=
"text-decoration: none">Streamability of Function Calls</a></h5>
<p>For calls to built-in functions, see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>.</p>
<p>For a call to a constructor function, the <a href=
"#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a> apply. There is a single operand role (the
argument to the function), with <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
<p>For a call to a <a title="stylesheet function" class="termref"
href="#dt-stylesheet-function">stylesheet function</a>, the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply. There is one <a title="operand role" class="termref" href=
"#dt-operand-role">operand role</a> for each argument in the
function signature, and its <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> is the
<a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
declared type of that argument.</p>
<p>If the function call is a partial function application (that is,
one or more of the arguments is given as <code>?</code>), then:</p>
<ol class="enumar">
<li>
<p>If the function is focus-dependent, then the <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> is <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a></p>
</li>
<li>
<p>Otherwise, the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply. <span>The operands of a partial
function application are the expressions actually supplied as
arguments to the function, ignoring <code>?</code> place-holders;
the corresponding <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
declared type of that argument.</span></p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-of-named-function-ref" id=
"streamability-of-named-function-ref"></a>19.8.7.13 <a href=
"#streamability-of-named-function-ref" style=
"text-decoration: none">Streamability of Named Function
References</a></h5>
<p>A <code>NamedFunctionRef</code> is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <span>unless the
function it refers to is focus-dependent, in which case it is
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a></span>.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-inline-functions" id=
"streamability-of-inline-functions"></a>19.8.7.14 <a href=
"#streamability-of-inline-functions" style=
"text-decoration: none">Streamability of Inline Function
Declarations</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the expression is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the body of the inline function contains a reference to a
variable defined in the <code>bind-group</code> attribute of an
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element external to the inline function, then <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-of-map-expressions" id=
"streamability-of-map-expressions"></a>19.8.7.15 <a href=
"#streamability-of-map-expressions" style=
"text-decoration: none">Streamability of map expressions</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a map expression are the same as the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the equivalent <a href="#element-map"><code>xsl:map</code></a>
instruction. The equivalent <a href=
"#element-map"><code>xsl:map</code></a> instruction is formed by
creating a sequence of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions,
one for each key/value pair in the map expression, where the key
expression becomes the value of <code>xsl:map-entry/@key</code>,
and the value expression becomes the value of
<code>xsl:map-entry/@select</code>; this sequence of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions is
then wrapped in an <a href="#element-map"><code>xsl:map</code></a>
parent instruction.</p>
<p>For example, the map expression <code>map{'red':false(),
'green':true()}</code> translates to the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'red'" select="false()"/&gt;
  &lt;xsl:map-entry key="'green'" select="true()"/&gt;
&lt;/xsl:map&gt;
</pre></div>
<p>The rules for the streamability of <a href=
"#element-map"><code>xsl:map</code></a> appear in <a href=
"#streamability-xsl-map"><i>19.8.4.22 Streamability of
xsl:map</i></a>.</p>
<p>See also <a href="#maps-streaming"><i>21.1.5 Maps and
Streaming</i></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-built-in-functions" id=
"classifying-built-in-functions"></a>19.8.8 <a href=
"#classifying-built-in-functions" style=
"text-decoration: none">Classifying Calls to Built-In
Functions</a></h4>
<p>This section describes the rules that determine the
streamability of calls to built-in functions. These differ from
user-written functions because it is known (defined in the
specification) how nodes supplied as operands are used. Knowledge
of the usage of each operand, together with the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the actual
operands, is in most cases enough to determine the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
function result.</p>
<p>All the built-in functions are listed below. For most functions,
a simple proforma is shown that indicates the operand usage of each
argument, using the code (A = <a title="absorption" class="termref"
href="#dt-absorption">absorption</a>, I = <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>, T = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, N = <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>). So, for
example, the entry <code>fn:remove(T, A)</code> means that for the
function <code>fn:remove#2</code>, the operand usage of the first
argument is <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>, and the operand usage of the
second argument is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. By reference to the general rules
in <a href="#general-streamability-rules"><i>19.8.1 General Rules
for Streamability</i></a>, this demonstrates that if the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"striding" class="termref" href="#dt-striding">striding</a>, the
posture and sweep of the expression <code>sum(remove(*,1))</code>
will be <code>grounded</code> and <code>consuming</code>
respectively.</p>
<p>For functions that default one of their arguments (typically to
the context item), the relevant entry shows the equivalence, and
the posture and sweep can in these cases be computed by filling in
the default value for the relevant argument.</p>
<p>Some functions do not follow the general rules, and these are
listed with a link to the section where the particular rules for
that function are described.</p>
<ul>
<li>
<p><code>fn:abs(A)</code></p>
</li>
<li>
<p><code>fn:accumulator-after</code> – See <a href=
"#streamability-fn-accumulator-after"><i>19.8.8.1 Streamability of
the accumulator-after function</i></a></p>
</li>
<li>
<p><code>fn:accumulator-before</code> – See <a href=
"#streamability-fn-accumulator-before"><i>19.8.8.2 Streamability of
the accumulator-before function</i></a></p>
</li>
<li>
<p><code>fn:adjust-date-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-date-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:adjust-dateTime-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-dateTime-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:adjust-time-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-time-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:analyze-string(A, A)</code></p>
</li>
<li>
<p><code>fn:analyze-string(A, A, A)</code></p>
</li>
<li>
<p><code>fn:available-environment-variables()</code></p>
</li>
<li>
<p><code>fn:avg(A)</code></p>
</li>
<li>
<p><code>fn:base-uri()</code> – Equivalent to
<code>fn:base-uri(.)</code></p>
</li>
<li>
<p><code>fn:base-uri(I)</code></p>
</li>
<li>
<p><code>fn:boolean(I)</code></p>
</li>
<li>
<p><code>fn:ceiling(A)</code></p>
</li>
<li>
<p><code>fn:codepoint-equal(A, A)</code></p>
</li>
<li>
<p><code>fn:codepoints-to-string(A)</code></p>
</li>
<li>
<p><code>fn:collation-key(A)</code></p>
</li>
<li>
<p><code>fn:collation-key(A, A)</code></p>
</li>
<li>
<p><code>fn:collection()</code></p>
</li>
<li>
<p><code>fn:collection(A)</code></p>
</li>
<li>
<p><code>fn:compare(A, A)</code></p>
</li>
<li>
<p><code>fn:compare(A, A, A)</code></p>
</li>
<li>
<p><code>fn:concat(A, A, A)</code></p>
</li>
<li>
<p><code>fn:contains(A, A)</code></p>
</li>
<li>
<p><code>fn:contains(A, A, A)</code></p>
</li>
<li>
<p><code>fn:copy-of()</code> – Equivalent to
<code>fn:copy-of(.)</code></p>
</li>
<li>
<p><code>fn:copy-of(A)</code></p>
</li>
<li>
<p><code>fn:count(I)</code></p>
</li>
<li>
<p><code>fn:current</code> – See <a href=
"#streamability-fn-current"><i>19.8.8.3 Streamability of the
current function</i></a></p>
</li>
<li>
<p><code>fn:current-date()</code></p>
</li>
<li>
<p><code>fn:current-dateTime()</code></p>
</li>
<li>
<p><code>fn:current-group</code> – See <a href=
"#streamability-fn-current-group"><i>19.8.8.4 Streamability of the
current-group function</i></a></p>
</li>
<li>
<p><code>fn:current-grouping-key</code> – See <a href=
"#streamability-fn-current-grouping-key"><i>19.8.8.5 Streamability
of the current-grouping-key function</i></a></p>
</li>
<li>
<p><code>fn:current-time()</code></p>
</li>
<li>
<p><code>fn:data()</code> – Equivalent to
<code>fn:data(.)</code></p>
</li>
<li>
<p><code>fn:data(A)</code></p>
</li>
<li>
<p><code>fn:dateTime(A, A)</code></p>
</li>
<li>
<p><code>fn:day-from-date(A)</code></p>
</li>
<li>
<p><code>fn:day-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:days-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A, A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A, A)</code></p>
</li>
<li>
<p><code>fn:default-collation()</code></p>
</li>
<li>
<p><code>fn:distinct-values(A)</code></p>
</li>
<li>
<p><code>fn:distinct-values(A, A)</code></p>
</li>
<li>
<p><code>fn:doc(A)</code></p>
</li>
<li>
<p><code>fn:doc-available(A)</code></p>
</li>
<li>
<p><code>fn:document(A)</code></p>
</li>
<li>
<p><code>fn:document(A, I)</code></p>
</li>
<li>
<p><code>fn:document-uri()</code> – Equivalent to
<code>fn:document-uri(.)</code></p>
</li>
<li>
<p><code>fn:document-uri(I)</code></p>
</li>
<li>
<p><code>fn:element-available(A)</code></p>
</li>
<li>
<p><code>fn:element-with-id(x)</code> – Equivalent to
<code>fn:element-with-id(x, .)</code></p>
</li>
<li>
<p><code>fn:element-with-id(A, N)</code></p>
</li>
<li>
<p><code>fn:empty(I)</code></p>
</li>
<li>
<p><code>fn:encode-for-uri(A)</code></p>
</li>
<li>
<p><code>fn:ends-with(A, A)</code></p>
</li>
<li>
<p><code>fn:ends-with(A, A, A)</code></p>
</li>
<li>
<p><code>fn:environment-variable(A)</code></p>
</li>
<li>
<p><code>fn:error()</code></p>
</li>
<li>
<p><code>fn:error(A)</code></p>
</li>
<li>
<p><code>fn:error(A, A)</code></p>
</li>
<li>
<p><code>fn:error(A, A, N)</code></p>
</li>
<li>
<p><code>fn:escape-html-uri(A)</code></p>
</li>
<li>
<p><code>fn:exactly-one(T)</code></p>
</li>
<li>
<p><code>fn:exists(I)</code></p>
</li>
<li>
<p><code>fn:false()</code></p>
</li>
<li>
<p><code>fn:filter(N, I)</code></p>
</li>
<li>
<p><code>fn:floor(A)</code></p>
</li>
<li>
<p><code>fn:fold-left(N, A, I)</code></p>
</li>
<li>
<p><code>fn:fold-right(N, A, I)</code></p>
</li>
<li>
<p><code>fn:for-each(N, I)</code></p>
</li>
<li>
<p><code>fn:for-each-pair(N, N, I)</code></p>
</li>
<li>
<p><code>fn:format-date(A, A)</code></p>
</li>
<li>
<p><code>fn:format-date(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-dateTime(A, A)</code></p>
</li>
<li>
<p><code>fn:format-dateTime(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-integer(A, A)</code></p>
</li>
<li>
<p><code>fn:format-integer(A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-number(A, A)</code></p>
</li>
<li>
<p><code>fn:format-number(A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-time(A, A)</code></p>
</li>
<li>
<p><code>fn:format-time(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:function-arity(A)</code></p>
</li>
<li>
<p><code>fn:function-available(A)</code></p>
</li>
<li>
<p><code>fn:function-available(A, A)</code></p>
</li>
<li>
<p><code>fn:function-lookup</code> – See <a href=
"#streamability-fn-function-lookup"><i>19.8.8.6 Streamability of
the function-lookup function</i></a></p>
</li>
<li>
<p><code>fn:function-name(A)</code></p>
</li>
<li>
<p><code>fn:generate-id()</code> – Equivalent to
<code>fn:generate-id(.)</code></p>
</li>
<li>
<p><code>fn:generate-id(I)</code></p>
</li>
<li>
<p><code>fn:has-children()</code> – Equivalent to
<code>fn:has-children(.)</code></p>
</li>
<li>
<p><code>fn:has-children(I)</code></p>
</li>
<li>
<p><code>fn:head(T)</code></p>
</li>
<li>
<p><code>fn:hours-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:hours-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:hours-from-time(A)</code></p>
</li>
<li>
<p><code>fn:id(x)</code> – Equivalent to <code>fn:id(x,
.)</code></p>
</li>
<li>
<p><code>fn:id(A, N)</code></p>
</li>
<li>
<p><code>fn:idref(x)</code> – Equivalent to <code>fn:idref(x,
.)</code></p>
</li>
<li>
<p><code>fn:idref(A, N)</code></p>
</li>
<li>
<p><code>fn:implicit-timezone()</code></p>
</li>
<li>
<p><code>fn:in-scope-prefixes(I)</code></p>
</li>
<li>
<p><code>fn:index-of(A, A)</code></p>
</li>
<li>
<p><code>fn:index-of(A, A, A)</code></p>
</li>
<li>
<p><code>fn:innermost(N)</code></p>
</li>
<li>
<p><code>fn:insert-before(T, A, T)</code></p>
</li>
<li>
<p><code>fn:iri-to-uri(A)</code></p>
</li>
<li>
<p><code>fn:json-to-xml(A)</code></p>
</li>
<li>
<p><code>fn:json-to-xml(A, A)</code></p>
</li>
<li>
<p><code>fn:key(x, x)</code> – Equivalent to <code>fn:key(x, x,
/)</code></p>
</li>
<li>
<p><code>fn:key(A, A, N)</code></p>
</li>
<li>
<p><code>fn:lang(x)</code> – Equivalent to <code>fn:lang(x,
.)</code></p>
</li>
<li>
<p><code>fn:lang(A, I)</code></p>
</li>
<li>
<p><code>fn:last</code> – See <a href=
"#streamability-fn-last"><i>19.8.8.7 Streamability of the last
function</i></a></p>
</li>
<li>
<p><code>fn:local-name()</code> – Equivalent to
<code>fn:local-name(.)</code></p>
</li>
<li>
<p><code>fn:local-name(I)</code></p>
</li>
<li>
<p><code>fn:local-name-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:lower-case(A)</code></p>
</li>
<li>
<p><code>fn:matches(A, A)</code></p>
</li>
<li>
<p><code>fn:matches(A, A, A)</code></p>
</li>
<li>
<p><code>fn:max(A)</code></p>
</li>
<li>
<p><code>fn:max(A, A)</code></p>
</li>
<li>
<p><code>fn:min(A)</code></p>
</li>
<li>
<p><code>fn:min(A, A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-time(A)</code></p>
</li>
<li>
<p><code>fn:month-from-date(A)</code></p>
</li>
<li>
<p><code>fn:month-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:months-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:name()</code> – Equivalent to
<code>fn:name(.)</code></p>
</li>
<li>
<p><code>fn:name(I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri()</code> – Equivalent to
<code>fn:namespace-uri(.)</code></p>
</li>
<li>
<p><code>fn:namespace-uri(I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri-for-prefix(A, I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:nilled()</code> – Equivalent to
<code>fn:nilled(.)</code></p>
</li>
<li>
<p><code>fn:nilled(I)</code></p>
</li>
<li>
<p><code>fn:node-name()</code> – Equivalent to
<code>fn:node-name(.)</code></p>
</li>
<li>
<p><code>fn:node-name(I)</code></p>
</li>
<li>
<p><code>fn:normalize-space()</code></p>
</li>
<li>
<p><code>fn:normalize-space(A)</code></p>
</li>
<li>
<p><code>fn:normalize-unicode(A)</code></p>
</li>
<li>
<p><code>fn:normalize-unicode(A, A)</code></p>
</li>
<li>
<p><code>fn:not(I)</code></p>
</li>
<li>
<p><code>fn:number()</code> – Equivalent to
<code>fn:number(.)</code></p>
</li>
<li>
<p><code>fn:number(A)</code></p>
</li>
<li>
<p><code>fn:one-or-more(T)</code></p>
</li>
<li>
<p><code>fn:outermost</code> – See <a href=
"#streamability-fn-outermost"><i>19.8.8.8 Streamability of the
outermost function</i></a></p>
</li>
<li>
<p><code>fn:parse-xml(A)</code></p>
</li>
<li>
<p><code>fn:parse-xml-fragment(A)</code></p>
</li>
<li>
<p><code>fn:path()</code> – Equivalent to
<code>fn:path(.)</code></p>
</li>
<li>
<p><code>fn:path(N)</code></p>
</li>
<li>
<p><code>fn:position</code> – See <a href=
"#streamability-fn-position"><i>19.8.8.9 Streamability of the
position function</i></a></p>
</li>
<li>
<p><code>fn:prefix-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:QName(A, A)</code></p>
</li>
<li>
<p><code>fn:regex-group(A)</code></p>
</li>
<li>
<p><code>fn:remove(T, A)</code></p>
</li>
<li>
<p><code>fn:replace(A, A, A)</code></p>
</li>
<li>
<p><code>fn:replace(A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:resolve-QName(A, I)</code></p>
</li>
<li>
<p><code>fn:resolve-uri(A)</code></p>
</li>
<li>
<p><code>fn:resolve-uri(A, A)</code></p>
</li>
<li>
<p><code>fn:reverse(N)</code></p>
</li>
<li>
<p><code>fn:root</code> – See <a href=
"#streamability-fn-root"><i>19.8.8.10 Streamability of the root
function</i></a></p>
</li>
<li>
<p><code>fn:round(A)</code></p>
</li>
<li>
<p><code>fn:round(A, A)</code></p>
</li>
<li>
<p><code>fn:round-half-to-even(A)</code></p>
</li>
<li>
<p><code>fn:round-half-to-even(A, A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-time(A)</code></p>
</li>
<li>
<p><code>fn:serialize(A)</code></p>
</li>
<li>
<p><code>fn:serialize(A, A)</code></p>
</li>
<li>
<p><code>fn:serialize-json(A)</code></p>
</li>
<li>
<p><code>fn:serialize-json(A, A)</code></p>
</li>
<li>
<p><code>fn:snapshot()</code> – Equivalent to
<code>fn:snapshot(.)</code></p>
</li>
<li>
<p><code>fn:snapshot(A)</code></p>
</li>
<li>
<p><code>fn:starts-with(A, A)</code></p>
</li>
<li>
<p><code>fn:starts-with(A, A, A)</code></p>
</li>
<li>
<p><code>fn:static-base-uri()</code></p>
</li>
<li>
<p><code>fn:string()</code> – Equivalent to
<code>fn:string(.)</code></p>
</li>
<li>
<p><code>fn:string(A)</code></p>
</li>
<li>
<p><code>fn:string-join(A)</code></p>
</li>
<li>
<p><code>fn:string-join(A, A)</code></p>
</li>
<li>
<p><code>fn:string-length()</code> – Equivalent to
<code>fn:string-length(.)</code></p>
</li>
<li>
<p><code>fn:string-length(A)</code></p>
</li>
<li>
<p><code>fn:string-to-codepoints(A)</code></p>
</li>
<li>
<p><code>fn:subsequence(T, A)</code></p>
</li>
<li>
<p><code>fn:subsequence(T, A, A)</code></p>
</li>
<li>
<p><code>fn:substring(A, A)</code></p>
</li>
<li>
<p><code>fn:substring(A, A, A)</code></p>
</li>
<li>
<p><code>fn:substring-after(A, A)</code></p>
</li>
<li>
<p><code>fn:substring-after(A, A, A)</code></p>
</li>
<li>
<p><code>fn:substring-before(A, A)</code></p>
</li>
<li>
<p><code>fn:substring-before(A, A, A)</code></p>
</li>
<li>
<p><code>fn:sum(A)</code></p>
</li>
<li>
<p><code>fn:sum(A, A)</code></p>
</li>
<li>
<p><code>fn:system-property(A)</code></p>
</li>
<li>
<p><code>fn:tail(T)</code></p>
</li>
<li>
<p><code>fn:timezone-from-date(A)</code></p>
</li>
<li>
<p><code>fn:timezone-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:timezone-from-time(A)</code></p>
</li>
<li>
<p><code>fn:tokenize(A, A)</code></p>
</li>
<li>
<p><code>fn:tokenize(A, A, A)</code></p>
</li>
<li>
<p><code>fn:trace(A, A)</code></p>
</li>
<li>
<p><code>fn:translate(A, A, A)</code></p>
</li>
<li>
<p><code>fn:true()</code></p>
</li>
<li>
<p><code>fn:type-available(A)</code></p>
</li>
<li>
<p><code>fn:unordered(T)</code></p>
</li>
<li>
<p><code>fn:unparsed-entity-public-id</code> – See <a href=
"#streamability-fn-unparsed-entity-public-id"><i>19.8.8.11
Streamability of the unparsed-entity-public-id function</i></a></p>
</li>
<li>
<p><code>fn:unparsed-entity-uri</code> – See <a href=
"#streamability-fn-unparsed-entity-uri"><i>19.8.8.12 Streamability
of the unparsed-entity-uri function</i></a></p>
</li>
<li>
<p><code>fn:unparsed-text(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text(A, A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-available(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-available(A, A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-lines(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-lines(A, A)</code></p>
</li>
<li>
<p><code>fn:upper-case(A)</code></p>
</li>
<li>
<p><code>fn:uri-collection()</code></p>
</li>
<li>
<p><code>fn:uri-collection(A)</code></p>
</li>
<li>
<p><code>fn:year-from-date(A)</code></p>
</li>
<li>
<p><code>fn:year-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:years-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:zero-or-one(T)</code></p>
</li>
<li>
<p><code>map:contains(A, A)</code></p>
</li>
<li>
<p><code>map:entry(A, N)</code></p>
</li>
<li>
<p><code>map:for-each-entry(A, A)</code></p>
</li>
<li>
<p><code>map:get(A, A)</code></p>
</li>
<li>
<p><code>map:keys(A)</code></p>
</li>
<li>
<p><code>map:new()</code></p>
</li>
<li>
<p><code>map:new(A)</code></p>
</li>
<li>
<p><code>map:remove(A, A)</code></p>
</li>
<li>
<p><code>map:size(A)</code></p>
</li>
<li>
<p><code>map:size(A)</code></p>
</li>
<li>
<p><code>math:acos(A)</code></p>
</li>
<li>
<p><code>math:asin(A)</code></p>
</li>
<li>
<p><code>math:atan(A)</code></p>
</li>
<li>
<p><code>math:atan2(A, A)</code></p>
</li>
<li>
<p><code>math:cos(A)</code></p>
</li>
<li>
<p><code>math:exp(A)</code></p>
</li>
<li>
<p><code>math:exp10(A)</code></p>
</li>
<li>
<p><code>math:log(A)</code></p>
</li>
<li>
<p><code>math:log10(A)</code></p>
</li>
<li>
<p><code>math:pi()</code></p>
</li>
<li>
<p><code>math:pow(A, A)</code></p>
</li>
<li>
<p><code>math:sin(A)</code></p>
</li>
<li>
<p><code>math:sqrt(A)</code></p>
</li>
<li>
<p><code>math:tan(A)</code></p>
</li>
</ul>
<div class="div4">
<h5><a name="streamability-fn-accumulator-after" id=
"streamability-fn-accumulator-after"></a>19.8.8.1 <a href=
"#streamability-fn-accumulator-after" style=
"text-decoration: none">Streamability of the</a>
<code>accumulator-after</code> <a href=
"#streamability-fn-accumulator-after" style=
"text-decoration: none">function</a></h5>
<p>See <a href="#streamability-of-accumulators"><i>18.2.7
Streamability of Accumulators</i></a>.</p>
<p>To ensure that the supplied value for the first argument (the
accumulator name) is not dependent on the streamed input document,
its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is classified as <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the function call then follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-accumulator-before" id=
"streamability-fn-accumulator-before"></a>19.8.8.2 <a href=
"#streamability-fn-accumulator-before" style=
"text-decoration: none">Streamability of the</a>
<code>accumulator-before</code> <a href=
"#streamability-fn-accumulator-before" style=
"text-decoration: none">function</a></h5>
<p>See <a href="#streamability-of-accumulators"><i>18.2.7
Streamability of Accumulators</i></a>.</p>
<p>To ensure that the supplied value for the first argument (the
accumulator name) is not dependent on the streamed input document,
its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is classified as <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the function call then follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-current" id=
"streamability-fn-current"></a>19.8.8.3 <a href=
"#streamability-fn-current" style=
"text-decoration: none">Streamability of the</a>
<code>current</code> <a href="#streamability-fn-current" style=
"text-decoration: none">function</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the function is <span><a title="motionless" class="termref"
href="#dt-motionless">motionless</a></span>; the <a title="posture"
class="termref" href="#dt-posture">posture</a> is the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> for evaluation of
the outermost containing XPath expression (that is, the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> that would obtain
if the entire XPath expression were replaced with
<code>"."</code>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the <a href="#func-current"><code>current</code></a> is
supported for streaming, it needs to be used with care. Some common
use cases such as <code>select="$lookup[@name =
current()/name]</code> will fail, because the streamability rules
require a predicate to be motionless. A workaround is to extract
the relevant value into a variable: <code>select="let $n :=
string(name) return $lookup[@name = $n]</code>; in turn this
removes the need for the <a href=
"#func-current"><code>current</code></a> function.</p>
<p>The use of <a href="#func-current"><code>current</code></a>
within a pattern is supported with similar restrictions. In this
case the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is always
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-group" id=
"streamability-fn-current-group"></a>19.8.8.4 <a href=
"#streamability-fn-current-group" style=
"text-decoration: none">Streamability of the</a>
<code>current-group</code> <a href=
"#streamability-fn-current-group" style=
"text-decoration: none">function</a></h5>
<p>XSLT 3.0 introduces the <code>bind-group</code> attribute on the
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction to enable grouping code to be statically analyzed for
streamability. Use of the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
functions is therefore incompatible with streaming.</p>
<p>Specifically: a call on the <a href=
"#func-current-group"><code>current-group</code></a> is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-grouping-key" id=
"streamability-fn-current-grouping-key"></a>19.8.8.5 <a href=
"#streamability-fn-current-grouping-key" style=
"text-decoration: none">Streamability of the</a>
<code>current-grouping-key</code> <a href=
"#streamability-fn-current-grouping-key" style=
"text-decoration: none">function</a></h5>
<p>See <a href="#streamability-fn-current-group"><i>19.8.8.4
Streamability of the current-group function</i></a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-function-lookup" id=
"streamability-fn-function-lookup"></a>19.8.8.6 <a href=
"#streamability-fn-function-lookup" style=
"text-decoration: none">Streamability of the</a>
<code>function-lookup</code> <a href=
"#streamability-fn-function-lookup" style=
"text-decoration: none">function</a></h5>
<p>See <a href="#function-lookup"><i>10.3.5 Dynamic Access to
Functions</i></a> for special rules that relate to streamability of
calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>
function.</p>
<p>With the caveats given there, the function follows the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
for a function with two arguments that both have <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-last" id=
"streamability-fn-last"></a>19.8.8.7 <a href=
"#streamability-fn-last" style=
"text-decoration: none">Streamability of the</a> <code>last</code>
<a href="#streamability-fn-last" style=
"text-decoration: none">function</a></h5>
<p>If the context <a title="posture" class="termref" href=
"#dt-posture">posture</a> for a call on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
function is <a title="striding" class="termref" href=
"#dt-striding">striding</a>, <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, or <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>, then the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
function is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>, and the <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
<p>In all other cases the function is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The cases where <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
can be used without affecting streamability are where the context
item is either <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> or <a title="climbing" class="termref"
href="#dt-climbing">climbing</a>. The latter condition makes
expressions like <code>ancestor::*[@xml:space][last()]</code>
streamable.</p>
<p>There are special rules restricting the use of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
in the predicate of a pattern: see <a href=
"#classifying-patterns"><i>19.8.9 Classifying Patterns</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-outermost" id=
"streamability-fn-outermost"></a>19.8.8.8 <a href=
"#streamability-fn-outermost" style=
"text-decoration: none">Streamability of the</a>
<code>outermost</code> <a href="#streamability-fn-outermost" style=
"text-decoration: none">function</a></h5>
<p>The single argument to this function has <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
<p>The streamability of the function call follows the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
with one exception: if the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the argument is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a>, then the posture
of the result is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are cases where the streaming rules allow the construct
<code>outermost(//para)</code> but do not allow
<code>//para</code>; the function can therefore be useful in cases
where it is known that <code>para</code> elements will not be
nested, as well as cases where the application actually wishes to
process all <code>para</code> elements except those that are nested
within another.</p>
<p>By contrast, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
function offers no streaming benefits. Although it delivers a
subset of the input nodes as its result, in the correct order, it
is classed as navigational because it needs to look aread in the
input stream before deciding whether a node can be included in the
result.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-position" id=
"streamability-fn-position"></a>19.8.8.9 <a href=
"#streamability-fn-position" style=
"text-decoration: none">Streamability of the</a>
<code>position</code> <a href="#streamability-fn-position" style=
"text-decoration: none">function</a></h5>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>
function follows the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. Since it has no operands, this means it is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Within an expression, there are no special difficulties in
evaluating the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>
function.</p>
<p>It does have special treatment within a predicate of a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a>, however:
a pattern is not motionless if it contains a call to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>,
as explained in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-root" id=
"streamability-fn-root"></a>19.8.8.10 <a href=
"#streamability-fn-root" style=
"text-decoration: none">Streamability of the</a> <code>root</code>
<a href="#streamability-fn-root" style=
"text-decoration: none">function</a></h5>
<p>The zero-argument function <code>root()</code> is equivalent to
<code>root(.)</code>.</p>
<p>Given the expression <code>root(X)</code>, if the item type of
<code>X</code> is <code>document-node()</code>, or a subtype
thereof, and if its <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="striding" class="termref"
href="#dt-striding">striding</a>, then <code>root(X)</code> is
rewritten as <code>X</code>. Otherwise, it is rewritten as
<code>head((X)/ancestor-or-self::node())</code>. Streamability
analysis is then applied to the rewritten expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because path expressions starting with <code>/</code> are
rewritten to use the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>
function, this ensures that a leading slash is ignored if the
context item is a document node, for example within a template rule
with <code>match="/"</code>. This improves streamability, because
upwards navigation followed by downward navigation is
disallowed.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-unparsed-entity-public-id" id=
"streamability-fn-unparsed-entity-public-id"></a>19.8.8.11 <a href=
"#streamability-fn-unparsed-entity-public-id" style=
"text-decoration: none">Streamability of the</a>
<code>unparsed-entity-public-id</code> <a href=
"#streamability-fn-unparsed-entity-public-id" style=
"text-decoration: none">function</a></h5>
<p>The function <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
has an implicit dependency on the context item.</p>
<p>If the context item type is anything other than a document node,
the function works without difficulty in streaming mode: in the
same way as attributes of ancestor elements are retained and are
available while processing descendant elements, the unparsed
entities declared in the DTD are retained while processing the body
of the document.</p>
<p>While processing the document node itself, however, the contents
of the DTD might not yet be available. An arbitrary number of
comments and processing instructions are allowed to precede the
DTD.</p>
<p>So the rules are:</p>
<ul>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is grounded, the
posture is grounded and the sweep is motionless</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is roaming, the
posture is roaming and the sweep is free-ranging</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing,
striding, or crawling, the context item type permits a document
node, then the posture is crawling and the sweep is consuming</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing,
striding, or crawling, the context item type does not permit a
document node, then the posture is grounded and the sweep is
motionless</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="streamability-fn-unparsed-entity-uri" id=
"streamability-fn-unparsed-entity-uri"></a>19.8.8.12 <a href=
"#streamability-fn-unparsed-entity-uri" style=
"text-decoration: none">Streamability of the</a>
<code>unparsed-entity-uri</code> <a href=
"#streamability-fn-unparsed-entity-uri" style=
"text-decoration: none">function</a></h5>
<p>The streamability characteristics of this function are the same
as <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>:
see <a href=
"#streamability-fn-unparsed-entity-public-id"><i>19.8.8.11
Streamability of the unparsed-entity-public-id
function</i></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-patterns" id=
"classifying-patterns"></a>19.8.9 <a href="#classifying-patterns"
style="text-decoration: none">Classifying Patterns</a></h4>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Patterns differ from other kinds of construct in that they are
not composable in the same way. It is best to think of a pattern as
specialized syntax for a function that takes an item as its
argument and returns a boolean: true if the pattern matches the
item, otherwise false. When we refer to the type of a pattern,
however, this refers to the types of item that the pattern is
capable of matching, not to the type of value that evaluation of
the pattern returns.</p>
</div>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> is either <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> or <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. (Although there are patterns
that could in principle be evaluated by consuming the element node
that they match, these are of no interest in the analysis, so they
are classified as free-ranging.)</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> if the pattern is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, or <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> otherwise. (This reflects
the fact that a pattern always returns a boolean result; it never
returns a node in a streamed document.)</p>
<p>Informally, a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern is one that can be
evaluated by a streaming processor when the input stream is
positioned at the start <span>of the node being matched</span>,
without advancing the input stream.</p>
<p>A pattern is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> if <span>and only if it satisfies
<span>all</span> the following conditions:</span></p>
<ol class="enumar">
<li>
<p>The pattern does not contain a <a href=
"#doc-xslt30-patterns-RootedPath">RootedPath</a>.</p>
</li>
<li>
<p>If the pattern contains predicates, then every top-level
<code>Predicate</code> in the pattern satisfies both the following
conditions:</p>
<ol class="enumla">
<li>
<p>The expression immediately contained in the predicate is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, <span>when assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="striding"
class="termref" href="#dt-striding">striding</a>, and a context
item type set to the static type of the expression to which the
predicate applies, determined using the rules in <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>.</span></p>
</li>
<li>
<p>The predicate is a <a title="non-positional predicate" class=
"termref" href="#dt-non-positional-predicate">non-positional
predicate</a>.</p>
</li>
</ol>
<p>The use of the term <b>top-level</b> in this rule means that
predicates that are nested within other predicates do not
themselves have to be non-positional, though they may play a role
in the analysis of top-level predicates.</p>
</li>
<li>
<p>The pattern does not contain (at any depth) a variable reference
bound to a variable declared in the <code>bind-group</code>
attribute of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-positional-predicate" id="dt-non-positional-predicate"
title="non-positional predicate"></a>A predicate is a
<b>non-positional predicate</b> if it satisfies both of the
following conditions:<span class="definition">]</span></p>
<ol class="enumar">
<li>
<p>The predicate does not contain a function call or named function
reference to any of the following functions, unless that call or
reference occurs within a nested predicate:</p>
<ol class="enumla">
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup></p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup></p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The exception for nested predicates is to avoid disqualifying
patterns such as <code>match="p[@code =
$status[last()]]</code>.</p>
</div>
</li>
<li>
<p>The expression immediately contained in the predicate is a
non-numeric expression. An expression is non-numeric if its static
item type (see <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a>) <var>S</var>
has the property that there is no SequenceType <var>T</var> (other
than <code>xs:error</code>) such that <code>subtype(T, S) and
(subtype(T, xs:decimal) or subtype(T, xs:double) or subtype(T,
xs:float))</code>. The <code>subtype</code> relation is defined in
<a href="http://www.w3.org/TR/xpath-30/#id-seqtype-subtype">Section
2.5.6.1 The judgement subtype(A, B)</a>
<sup><small>XP30</small></sup></p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A non-positional predicate can be evaluated by considering each
item in the filtered sequence independently; the result never
depends on the position of other items in the sequence or the
length of the sequence.</p>
</div>
<p>A pattern that is not <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> is classified as <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<p>The following list shows examples of motionless patterns:</p>
<ul>
<li>
<p><code>/</code></p>
</li>
<li>
<p><code>*</code></p>
</li>
<li>
<p><code>/*</code></p>
</li>
<li>
<p><code>p</code></p>
</li>
<li>
<p><code>p|q</code></p>
</li>
<li>
<p><code>p/q</code></p>
</li>
<li>
<p><code>p[@status='red']</code></p>
</li>
<li>
<p><code>p[base-uri()]</code></p>
</li>
<li>
<p><code>p[@class or @style]</code></p>
</li>
<li>
<p><code>p[@status]</code></p>
</li>
<li>
<p><code>p[@status = $status-codes[1]]</code></p>
</li>
<li>
<p><code>p[@class | @style]</code></p>
</li>
<li>
<p><code>p[contains(@class, ':')]</code></p>
</li>
<li>
<p><code>p[substring-after(@class, ':')]</code></p>
</li>
<li>
<p><code>p[ancestor::*[@xml:lang]]</code></p>
</li>
<li>
<p><code>text()[starts-with(., '$')]</code></p>
</li>
<li>
<p><code>@price</code></p>
</li>
<li>
<p><code>@price[starts-with(., '$')]</code></p>
</li>
<li>
<p><code>//p/text()[. = 'Introduction']</code></p>
</li>
</ul>
<p>The following list shows examples of patterns that are not
motionless, explaining why not:</p>
<ul>
<li>
<p><code>id('abc')</code> (contains a <code>RootedPath</code>)</p>
</li>
<li>
<p><code>$doc//p</code> (contains a <code>RootedPath</code>)</p>
</li>
<li>
<p><code>p[b]</code> (the predicate is not motionless)</p>
</li>
<li>
<p><code>p[. = 'Introduction']</code> (the predicate is not
motionless)</p>
</li>
<li>
<p><code>p[starts-with(., '$')]</code> (the predicate is not
motionless)</p>
</li>
<li>
<p><code>p[preceding-sibling::p[1] = '']</code> (the predicate is
not motionless)</p>
</li>
<li>
<p><code>p[1]</code> (contains a positional predicate: return type
is numeric)</p>
</li>
<li>
<p><code>p[$pnum + 1]</code> (contains a positional predicate:
return type is numeric)</p>
</li>
<li>
<p><code>p[data(@status)]</code> (contains a positional predicate:
return type is potentially numeric)</p>
</li>
<li>
<p><code>p[position() gt 2]</code> (contains a positional
predicate: calls <code>position()</code>)</p>
</li>
<li>
<p><code>p[last()]</code> (contains a positional predicate: calls
<code>last()</code>)</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="streamability-analysis-examples" id=
"streamability-analysis-examples"></a>19.9 <a href=
"#streamability-analysis-examples" style=
"text-decoration: none">Examples of Streamability Analysis</a></h3>
<p>The examples in this section are intended to illustrate how the
streamability rules are applied "top down" to establish whether
template rules are guaranteed streamable.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e49115" id=
"d7e49115"></a>Example: A recursive-descent template rule</div>
<p>Consider the following template rule, where mode <code>s</code>
is defined with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="para" mode="s"&gt;
  &lt;div class="para"&gt;
    &lt;xsl:apply-templates mode="s"/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The processor is required to establish that this template meets
the streamability rules. Specifically, as stated in <a href=
"#streamable-templates"><i>6.6.3 Streamable Templates</i></a>, it
must satisfy three conditions:</p>
<ol class="enumar">
<li>
<p>The match pattern must be <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The body of the template rule must be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The initializers of any template parameters must be <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>The third condition is satisfied trivially because there are no
parameters.</p>
<p>The first rule depends on the rules for assessing patterns,
which are given in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>. This pattern is motionless because
(a) it does not contain a <code>RootedPath</code>, and (b) it
contains no predicates.</p>
<p>So it remains to determine that the body of the template is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. The proof of this is as follows:</p>
<ol class="enumar">
<li>
<p>The sequence constructor forming the body of the template is
assessed according to the rules in <a href=
"#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence
Constructors</i></a>, which tell us that there is a single operand
(the <code>&lt;div&gt;</code> <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
element</a>) which has <a title="operand usage" class="termref"
href="#dt-operand-usage">operand usage</a> <var>U</var> = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The assessment of the sequence constructor uses the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These rules require us to determine the type <var>T</var>, sweep
<var>S</var>, posture <var>P</var>, and usage <var>U</var> of each
operand. We have already established that there is a single
operand, with <var>U</var> = <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>. Section
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a> tells us that for all instructions, we
can take <var>T</var> = <code>item()</code>. The <a title="posture"
class="termref" href="#dt-posture">posture</a> <var>P</var> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a>
<var>S</var> of the literal result element are established as
follows:</p>
<ol class="enumla">
<li>
<p>The rules for literal result elements (specifically the
<code>&lt;div&gt;</code> element) are given in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>. This particular literal result
element has only one operand (its contained sequence constructor),
with operand usage <var>U</var> = <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
again apply. Again the static type <var>T</var> of the operand is
<code>item()</code>, and we need to determine the <a title=
"posture" class="termref" href="#dt-posture">posture</a>
<var>P</var> and <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> <var>S</var>.</p>
</li>
<li>
<p>To determine the posture and sweep of this sequence constructor
(the one that contains the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) we refer again to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
<ol class="enumlr">
<li>
<p>The sequence constructor has a single operand (the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction); again <var>U</var> = <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>, <var>T</var> =
<code>item()</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are established as follows:</p>
<ol class="enumua">
<li>
<p>The rules that apply are in <a href=
"#streamability-xsl-apply-templates"><i>19.8.4.5 Streamability of
xsl:apply-templates</i></a>.</p>
</li>
<li>
<p>Rule 1 does not apply because the <code>select</code> expression
(which defaults to <code>child::node()</code>) is not <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>. This
is a consequence of the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>, specifically:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of the axis step is
established by the template rule as a whole, as <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Therefore rules 1 and 2 do not apply.</p>
</li>
<li>
<p>The statically-inferred context item type is derived from the
match pattern (<code>match="para"</code>). This gives a type of
<code>element()</code>. The child axis for element nodes is not
necessarily empty, so rule 3 does not apply.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the axis step
<code>child::node()</code> are given by the table in rule 5. The
entry for (context posture = striding, axis = child) gives a
posture of <a title="striding" class="termref" href=
"#dt-striding">striding</a> and a <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a title="consuming" class="termref"
href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the <code>select</code> expression is not <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>. (The same result
can be reached intuitively: an expression that selects streamed
nodes will never be <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.)</p>
</li>
</ol>
</li>
<li>
<p>Rule 2 does not apply because there is no <a href=
"#element-sort"><code>xsl:sort</code></a> element.</p>
</li>
<li>
<p>Rule 3 does not apply because the mode is declared with
<code>streamable="yes"</code>.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are established by the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
as follows:</p>
<ol class="enumur">
<li>
<p>There is a single operand, the implicit
<code>select="child::node()"</code> expression, with usage
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>We have already established that for this operand, the posture
<var>P</var> = <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> = <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>By the rules in <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a>, the type
<var>T</var> of the <code>select</code> expression is
<code>node()</code>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, the adjusted sweep <var>S'</var> for an operand with
(<var>P</var> = <a title="striding" class="termref" href=
"#dt-striding">striding</a>, <var>U</var> = <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>) is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,</p>
</li>
<li>
<p>Rule 2(d) then applies, so the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>So the sequence constructor that contains the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction has one operand with <var>U</var> = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so the sequence constructor itself has <var>P</var> =
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the literal result element has one operand with <var>U</var>
= <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so the literal result element has <var>P</var> = <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>,
<var>S</var> = <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the sequence constructor containing the literal result
element has one operand with <var>U</var> = <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>,
<var>T</var> = <code>item()</code>, <var>P</var> = <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>,
<var>S</var> = <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so this sequence constructor itself has <var>P</var> =
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So we have established that the sequence constructor forming the
body of the template rule is <a title="grounded" class="termref"
href="#dt-grounded">grounded</a>.</p>
</li>
</ol>
<p>Therefore, since the other conditions are also satisfied, the
template is <a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
<p>The analysis presented above could have been simplified by
taking into account the fact that the streamability properties of a
sequence constructor containing a single instruction are identical
to the properties of that instruction. This simplification will be
exploited in the next example.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e49600" id=
"d7e49600"></a>Example: An aggregating template rule</div>
<p>Consider the following template rule, where mode <code>s</code>
is defined with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="transactions[@currency='USD']" mode="s"&gt;
  &lt;total&gt;&lt;xsl:value-of select="sum(transaction/@value)"/&gt;&lt;/total&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Again, as stated in <a href="#streamable-templates"><i>6.6.3
Streamable Templates</i></a>, it must satisfy three conditions:</p>
<ol class="enumar">
<li>
<p>The match pattern must be <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The body of the template rule must be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The initializers of any template parameters must be <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>The third condition is satisfied trivially because there are no
parameters.</p>
<p>The first rule depends on the rules for assessing patterns,
which are given in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>. This pattern is motionless because
(a) it is not a <code>RootedPath</code>, and (b) every predicate is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and <a title=
"non-positional predicate" class="termref" href=
"#dt-non-positional-predicate">non-positional</a>. The analysis
that proves the predicate is motionless and non-positional proceeds
as follows:</p>
<ol class="enumar">
<li>
<p>First establish that that the expression
<code>@currency='USD'</code> is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, as follows:</p>
<ol class="enumla">
<li>
<p>The predicate is a general comparison (<code>GeneralComp</code>)
which follows the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>.</p>
</li>
<li>
<p>There are two operands: a <code>ForwardsAxisStep</code> and a
<code>Literal</code>. Both operand roles are <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The first operand has type <var>T</var> =
<code>attribute()</code>. Its <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are determined by the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>. The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, so the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> are
determined by the entry in the table (rule 5) with context posture
= <a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>attribute</code>: that
is, the result posture is <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The second operand, being a literal, is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, rule 2(e) applies, so the predicate is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a></p>
</li>
</ol>
</li>
<li>
<p>Now establish that that the expression
<code>@currency='USD'</code> is <a title="non-positional predicate"
class="termref" href=
"#dt-non-positional-predicate">non-positional</a>, as follows:</p>
<ol class="enumla">
<li>
<p>Rule 1 is satisfied: the predicate does not call <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>Rule 2 is satisfied: the expression <code>@currency='USD'</code>
is non-numeric. The static type of the expression is determined
using the rules in <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a> as
<code>xs:boolean</code>, and this has no common subtypes with
<code>xs:decimal</code>, <code>xs:double</code>, or
<code>xs:float</code>.</p>
</li>
</ol>
</li>
</ol>
<p>So both conditions in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a> are satisfied, and the pattern is
therefore <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<p>It remains to show that the body of the template rule is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. The proof of this is as follows.
Unlike the previous example, the analysis is shown in simplified
form; in particular the two sequence constructors which each
contain a single instruction are ignored, and replaced in the
construct tree by their contained instruction.</p>
<ol class="enumar">
<li>
<p>We need to show that the <code>&lt;total&gt;</code> <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The rules that apply are in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>.</p>
</li>
<li>
<p>These rules refer to the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. There is one operand, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> child element,
which has <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> <var>U</var> = <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
and type <var>T</var> = <code>item()</code>.</p>
</li>
<li>
<p>So we need to determine the <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
<ol class="enumla">
<li>
<p>The rules are given in <a href=
"#streamability-xsl-value-of"><i>19.8.4.37 Streamability of
xsl:value-of</i></a>.</p>
</li>
<li>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply. There is one operand, the expression
<code>sum(transaction/@value)</code>, which has <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <var>U</var> = <a title="absorption" class="termref"
href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The type <var>T</var> of this operand is the return type defined
in the signature of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>
function, that is, <code>xs:anyAtomicType</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> are established
as follows:</p>
<ol class="enumlr">
<li>
<p>The rules that apply to the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>
are given in <a href="#classifying-built-in-functions"><i>19.8.8
Classifying Calls to Built-In Functions</i></a>.</p>
</li>
<li>
<p>The relevant proforma is <code>fn:sum(A)</code>, indicating that
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, and that there is a single operand with usage <var>U</var> =
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The type <var>T</var> of the operand
<code>transaction/@value</code> is determined (by the rules in
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a>) as <code>attribute()</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the operand
<code>transaction/@value</code> are determined by the rules in
<a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a>, as follows:</p>
<ol class="enumua">
<li>
<p>The expression is expanded to
<code>child::transaction/attribute::value</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the first operand
<code>child::transaction</code> are determined by the rules in
<a href="#streamability-of-axis-steps"><i>19.8.7.7 Streamability of
Axis Steps</i></a>, as follows:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, because the
<a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is the
template rule itself.</p>
</li>
<li>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is
<code>element()</code>, based on the <a title="match type" class=
"termref" href="#dt-match-type">match type</a> of the pattern
<code>match="transactions[@currency='USD']"</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the <code>child</code> axis
applied to an element node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>Rule 5 applies, and the table entry with context posture =
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>child</code> gives a
result <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <a title="striding" class="termref"
href="#dt-striding">striding</a> and a <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the relative path expression
<code>child::transaction/attribute::value</code> is therefore the
<a title="posture" class="termref" href="#dt-posture">posture</a>
of its second operand <code>attribute::value</code>, assessed with
a <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="striding"
class="termref" href="#dt-striding">striding</a>. This is
determined by the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>, as follows:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a>, as we have seen, is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is
<code>element()</code>, based on the type of the first operand
<code>child::transaction</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the <code>attribute</code> axis
applied to an element node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>Rule 5 applies, and the table entry with context posture =
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>attribute</code> gives a
result <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <a title="climbing" class="termref"
href="#dt-climbing">climbing</a> and a <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the relative path expression
<code>child::transaction/attribute::value</code> is therefore
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the relative path expression
<code>child::transaction/attribute::value</code> is the wider of
the sweeps of its two operands, namely <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> and <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>.
That is, it is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the first and only operand to the call on <code>sum()</code>
has <var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>attribute()</code>, <var>P</var> = <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a>, and <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a></p>
</li>
<li>
<p>Rule 1(b) of the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> computes the adjusted sweep <var>S'</var>.
Rule 1(b)(iii)(A) applies, so the effective <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <var>U'</var> is <a title="inspection" class="termref"
href="#dt-inspection">inspection</a>. Rule 1(b)(iii)(A) then
computes the adjusted sweep from the table entry for <var>P</var> =
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, <var>U'</var> = <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>; this shows
<var>S'</var> = <var>S</var>, that is, <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>Rule 2(d) now applies, so the call on <code>sum()</code> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Since the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction has
one operand with <var>U</var> = <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>, <var>T</var> =
<code>xs:anyAtomicType</code>, <var>P</var> = <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, and <var>S</var>
= <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, rule 2(d) again applies, and the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Since the literal result element has one operand with
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, and <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, rule 2(d) again applies, and the
literal result element is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>Therefore the body of the template rule is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, and since the
other conditions are also satisfied, it is <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e50244" id=
"d7e50244"></a>Example: Streamed Grouping</div>
<p>Consider the following code, which is designed to process a
transaction file containing transactions in chronological order,
and output the total value of the transactions for each day.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="go"&gt;
  &lt;out&gt;
    &lt;xsl:stream href="transactions.xml"&gt;
      &lt;xsl:for-each-group select="/account/transaction" 
                          group-adjacent="xs:date(@timestamp)" 
                          bind-group="g" bind-grouping-key="k"&gt;
         &lt;total date="{$k}" value="{sum($g/@value)}"/&gt;
      &lt;/xsl:for-each-group&gt;
    &lt;/xsl:stream&gt;
  &lt;/out&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The rules for <a href=
"#element-stream"><code>xsl:stream</code></a> say that the
instruction is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, and
the task of streamability analysis is to prove that this is the
case. As in the previous example, we will take a short-cut by
making the assumption that a sequence constructor containing a
single instruction can be replaced by that instruction in the
construct tree.</p>
<p>So the task is to show that the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, which we can do as follows:</p>
<ol class="enumar">
<li>
<p>The relevant rules are to be found in <a href=
"#streamability-xsl-for-each-group"><i>19.8.4.18 Streamability of
xsl:for-each-group</i></a>.</p>
</li>
<li>
<p>Rule 1 applies only if the <code>select</code> expression is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. It is easy to see informally that this
is not the case (an expression that returns streamed nodes is never
grounded). More formally:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression is a path expression; the
rules in <a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a> apply.</p>
</li>
<li>
<p>The expression is rewritten as <code>((root(.) treat as
document-node())/child::account)/child::transaction</code></p>
</li>
<li>
<p>The left-hand operand <code>(root(.) treat as
document-node())/child::account</code> is also a path expression,
so the rules in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a> apply recursively:</p>
<ol class="enumlr">
<li>
<p>The left-hand operand <code>root(.) treat as
document-node()</code> follows the rules for a
<code>TreatExpr</code> in <a href=
"#classifying-expressions"><i>19.8.7 Classifying
Expressions</i></a>; the proforma <code>T treat as TYPE</code>
indicates that the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply with a single operand having usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>This single operand <code>root(.)</code> follows the rules in
<a href="#streamability-fn-root"><i>19.8.8.10 Streamability of the
root function</i></a>. The item type of the operand <code>.</code>
is the <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a>, which is the type
established by the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, namely
<code>document-node()</code>. Under these conditions
<code>root(.)</code> is rewritten as <code>.</code>, so the
<a title="posture" class="termref" href="#dt-posture">posture</a>
is the <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> establised by the
<a href="#element-stream"><code>xsl:stream</code></a> instruction,
namely <a title="striding" class="termref" href=
"#dt-striding">striding</a>. The <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> is <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the expression <code>root(.) treat as
document-node()</code> are the same as the <a title="posture"
class="termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <code>root(.)</code>,
namely <a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></p>
</li>
<li>
<p>The right-hand operand <code>child::account</code> is governed
by the rules in <a href="#streamability-of-axis-steps"><i>19.8.7.7
Streamability of Axis Steps</i></a>. The <a title="context posture"
class="termref" href="#dt-context-posture">context posture</a> is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, and the axis is <code>child</code>, so
the result posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the sweep is <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the path expression is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
right-hand operand, that is <a title="striding" class="termref"
href="#dt-striding">striding</a>, and its sweep is the wider sweep
of the two operands, that is <a title="consuming" class="termref"
href="#dt-consuming">consuming</a></p>
</li>
</ol>
</li>
<li>
<p>Returning to the outer path expression, the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the right hand
operand <code>child::transaction</code> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, and its sweep is
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>select</code> expression as
a whole is the posture of the right hand operand, that is <a title=
"striding" class="termref" href="#dt-striding">striding</a>; and
its sweep is the wider of the sweeps of the operands, which is
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Rule 2 does not apply: there is no <code>group-by</code>
attribute.</p>
</li>
<li>
<p>Rule 3 does not apply: there is a <code>group-adjacent</code>
attribute, but it is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>. The reasoning is as follows:</p>
<ol class="enumla">
<li>
<p>The value is a call to the constructor function
<code>xs:date</code>. The rules in <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a> apply. There is a single operand, whose
required type is atomic, so the <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> is <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>These rules refer to the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, so we need to determine the <a title=
"context item type" class="termref" href=
"#dt-context-item-type">context item type</a>, <a title="posture"
class="termref" href="#dt-posture">posture</a>, and <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the operand
expression <code>@timestamp</code>. This is done as follows:</p>
<ol class="enumlr">
<li>
<p>The expression is an <code>AxisStep</code>, so the relevant
rules are in <a href="#streamability-of-axis-steps"><i>19.8.7.7
Streamability of Axis Steps</i></a>.</p>
</li>
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the <a title=
"controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> of the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a>, that is,
is the <code>select</code> expression of the containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, which as established above is <a title="striding"
class="termref" href="#dt-striding">striding</a>. The <a title=
"context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is similarly the
inferred type of the <code>select</code> expression, and is
<code>element()</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the attribute axis for an element
node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there is no predicate.</p>
</li>
<li>
<p>So the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression <code>@timestamp</code>
are given by the table in Rule 5 as <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Returning to the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> for the expression
<code>xs:date(@timestamp)</code>, the first operand has
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>attribute()</code>, <var>P</var> = <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a>, <var>S</var> =
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Under Rule 1(b)(iii)(A), because <var>T</var> =
<code>attribute()</code>, the operand usage <var>U'</var> becomes
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
<li>
<p>Under Rule 1(b)(iii)(A), <var>S'</var> = <var>S</var> =
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Under Rule 2(e), the expression <code>xs:date(@timestamp)</code>
is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Rule 4 (under <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>) does
not apply, because there is no <code>group-starting-with</code> or
<code>group-ending-with</code> attribute.</p>
</li>
<li>
<p>Rule 5 does not apply, because there is no <a href=
"#element-sort"><code>xsl:sort</code></a> child.</p>
</li>
<li>
<p>Rule 6 does not apply, because there is a
<code>bind-group</code> attribute.</p>
</li>
<li>
<p>Rule 7 does not apply, because both <code>group-adjacent</code>
and <code>bind-grouping-key</code> are present.</p>
</li>
<li>
<p>So Rule 8 applies. This relies on knowing the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the sequence
constructor containined in the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction: that is, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>total</code> <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>. This is
calculated as follows:</p>
<ol class="enumla">
<li>
<p>The rules that apply are in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply; there are two operands, the attribute value templates
<code>{$k}</code> and <code>{sum($g/@value}</code>, and in each
case the usage is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. We can simplify the analysis by
observing that that the empty <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> contained in the literal result element can be
ignored, since it is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Consider first the operand <code>{$k}</code>.</p>
<ol class="enumlr">
<li>
<p>Section <a href="#classifying-vts"><i>19.8.6 Classifying Value
Templates</i></a> applies. This refers to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>;
there is a single operand, the expression <code>$k</code>, with
usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The rules for the expression <code>$k</code> are given in
<a href="#streamability-of-variable-references"><i>19.8.7.10
Streamability of Variable References</i></a>. These establish that
the expression is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>It follows that the operand <code>{$k}</code> expression is also
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Now consider the operand <code>{sum($g/@value)}</code>.</p>
</li>
<li>
<p>Section <a href="#classifying-vts"><i>19.8.6 Classifying Value
Templates</i></a> applies. This refers to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>;
there is a single operand, the expression
<code>sum($g/@value)</code>, with usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The rules for the <code>sum</code> function appear in <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>. The proforma is given there as
<code>fn:sum(A)</code>, which means that the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, and that the single operand <code>$g/@value</code> has usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. So we need to establish the
<a title="posture" class="termref" href="#dt-posture">posture</a>,
<a title="sweep" class="termref" href="#dt-sweep">sweep</a>, and
type of this expression, which we can do as follows:</p>
<ol class="enumlr">
<li>
<p>The expression is a <code>RelativePathExpr</code>, so section
<a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a> applies.</p>
</li>
<li>
<p>The expression is expanded to
<code>$g/attribute::value</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the left-hand operand <code>$g</code>
are defined in <a href=
"#streamability-of-variable-references"><i>19.8.7.10 Streamability
of Variable References</i></a>, which has special rules for a
variable bound in the <code>bind-group</code> attribute of a
containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. Specifically, the <a title="posture" class="termref"
href="#dt-posture">posture</a> of <code>$g</code> is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
<code>select</code> expression, that is <a title="striding" class=
"termref" href="#dt-striding">striding</a>, and its <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> is the <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the
<code>select</code> expression, that is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the right hand operand
<code>@value</code> are defined in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>. The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the left-hand
operand <code>$g</code>, namely <a title="striding" class="termref"
href="#dt-striding">striding</a>; the table in Rule 5 applies,
giving the result <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>RelativePathExpr</code> is
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the right hand operand, namely
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>. The <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <code>RelativePathExpr</code> is
the wider of the <a title="sweep" class="termref" href=
"#dt-sweep">sweeps</a> of its operands, which is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The type of the expression <code>$g/@value</code> is determined
using the rules in <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a> as
<code>attribute()</code>.</p>
</li>
</ol>
</li>
<li>
<p>So the <code>sum</code> function has a single operand with
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>P</var> = <a title="climbing"
class="termref" href="#dt-climbing">climbing</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, <var>T</var> =
<code>attribute()</code>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, Rule 1(b)(iii)(A) gives the adjusted usage as
<var>U'</var> = <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, and Rule 1(b)(iii)(B) gives the
adjusted sweep as <var>S'</var> = <var>S</var> = <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.
Rule 2(d) gives the posture and sweep of the call to
<code>sum</code> as <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the literal result element has two operands, one of which is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, the other <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
determines that the literal result element is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the content of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, which means that the instruction is
<a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="streamability-guarantees" id=
"streamability-guarantees"></a>19.10 <a href=
"#streamability-guarantees" style=
"text-decoration: none">Streamability Guarantees</a></h3>
<p>Certain constructs allow a stylesheet author to declare that a
construct is streamable. Specifically:</p>
<ol class="enumar">
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-mode"><code>xsl:mode</code></a> declares that all
template rules in that mode <span>(and all template rules that
specify <code>mode="#all"</code>)</span> are streamable;</p>
</li>
<li>
<p>The <code>xsl:stream</code> instruction implicitly declares that
its contained sequence constructor is streamable;</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declares that the attribute set in question is streamable;</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-merge"><code>xsl:merge</code></a> declares that the
merging process is streamable.</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declares
that the accumulator can be evaluated on a streamed document.</p>
</li>
</ol>
<p>In each case the construct in question is said to be
<b>guaranteed-streamable</b> if it satisfies two conditions:</p>
<ol class="enumar">
<li>
<p>Streamability is declared by specifying
<code>streamable="yes"</code>.</p>
</li>
<li>
<p>Streamability analysis following the rules defined in this
specification determines that streamed processing is possible (the
detailed conditions vary from one construct to another).</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-guaranteed-streamable" id="dt-guaranteed-streamable" title=
"guaranteed-streamable"></a>A <b>guaranteed-streamable</b>
construct is a <a title="construct" class="termref" href=
"#dt-construct">construct</a> that is declared to be streamable and
that follows the particular rules for that construct to make
streaming possible, as defined by the analysis in this
specification.<span class="definition">]</span></p>
<p>For a streaming processor, that is, a processor that claims
conformance with the <a title="streaming feature" class="termref"
href="#dt-streaming-feature">streaming feature</a>:</p>
<ol class="enumar">
<li>
<p>If a construct is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> then it
<span class="verb">must</span> be processed using streaming.</p>
</li>
<li>
<p>If a construct is declared as streamable but is not <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> (that is, if
it fails to satisfy the conditions for streamability defined in
this specification), then the processor <span class=
"verb">must</span> be prepared to do any one of the following at
user option:</p>
<ol class="enumla">
<li>
<p>Signal a static error <span class="error">[see <a href=
"#err-XTSE3430">ERR XTSE3430</a>]</span></p>
</li>
<li>
<p>Process the stylesheet as if it were a non-streaming processor
(see below)</p>
</li>
<li>
<p>Process the stylesheet with streaming if it is able to do so, or
signal a static error <span class="error">[see <a href=
"#err-XTSE3430">ERR XTSE3430</a>]</span> if it is not able to do
so.</p>
</li>
</ol>
</li>
</ol>
<p><a name="err-XTSE3430" id="err-XTSE3430"><span class=
"error">[ERR XTSE3430]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
stylesheet contains a construct that is declared to be streamable
but which is not <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a>, unless
the user has indicated that the processor is to handle this
situation by processing the stylesheet without streaming or by
making use of processor extensions to the streamability rules where
available.</p>
<p>For a non-streaming processor, the processor <span class=
"verb">must</span> evaluate the <span>construct</span> delivering
the same results as if execution used streaming, but with no
constraints on the evaluation strategy. (Processing <span class=
"verb">may</span>, of course, fail due to insufficient memory being
available, or for other reasons.)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not attempt to legislate precisely what
constitutes evaluation "using streaming". The most important test
is that the amount of memory needed should be for practical
purposes independent of the size of the source document, and in
particular that the finite size of memory available should not
impose a limit on the size of source document that can be
processed.</p>
<p>The rules are designed to ensure that streaming processors can
analyze streamability using rules different from those in this
specification, provided that all constructs that are <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification are actually streamable by the implementation.
Furthermore, non-streaming processors are not required to analyze
streamability at all.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="add-func" id="add-func"></a>20 <a href="#add-func"
style="text-decoration: none">Additional Functions</a></h2>
<p>This section describes XSLT-specific additions to the <a title=
"core function" class="termref" href="#dt-core-function">core
function</a> library. Some of these additional functions also make
use of information specified by <a title="declaration" class=
"termref" href="#dt-declaration">declarations</a> in the
stylesheet; this section also describes these declarations.</p>
<div class="div2">
<h3><a name="func-document" id="func-document"></a>20.1 <a href=
"#func-document" style="text-decoration: none">fn:document</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Provides access to XML documents identified by a URI.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-document" id="function-document"></a></p>
<div class="proto"><code class=
"function">document</code>(<code class=
"arg">$uri-sequence</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :document function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">document</code>(</td>
<td valign="baseline"><code class="arg">$uri-sequence</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$base-node</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">node()</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.
It depends on static base uri.</p>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-document"><code>document</code></a> function
allows access to XML documents identified by a URI.</p>
<p>The first argument contains a sequence of URI references. The
second argument, if present, is a node whose base URI is used to
resolve any relative URI references contained in the first
argument.</p>
<p>A sequence of absolute URI references is obtained as
follows.</p>
<ul>
<li>
<p>For an item in <code>$uri-sequence</code> that is an instance of
<code>xs:string</code>, <code>xs:anyURI</code>, or
<code>xs:untypedAtomic</code>, the value is cast to
<code>xs:anyURI</code>. If the resulting URI reference is an
absolute URI reference then it is used <em>as is</em>. If it is a
relative URI reference, then it is resolved against the base URI of
<code>$base-node</code> if supplied, or against the base URI from
the static context otherwise (this will usually be the base URI of
the stylesheet module). A relative URI <span>reference</span> is
resolved against a base URI using the rules defined in <a href=
"#RFC3986">[RFC3986]</a>.</p>
</li>
<li>
<p>For an item in <code>$uri-sequence</code> that is a node, the
node is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>. The result <span class=
"verb">must</span> be a sequence whose items are all instances of
<code>xs:string</code>, <code>xs:anyURI</code>, or
<code>xs:untypedAtomic</code>. Each of these values is cast to
<code>xs:anyURI</code>, and if the resulting URI reference is an
absolute URI reference then it is used <em>as is</em>. If it is a
relative URI reference, then it is resolved against the base URI of
<code>$base-node</code> if supplied, or against the base URI of the
node that contained it otherwise.</p>
</li>
</ul>
<p>Each of these absolute URI references is then processed as
follows. Any fragment identifier that is present in the URI
reference is removed, and the resulting absolute URI is cast to a
string and then passed to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. This returns a document node. If an error occurs
during evaluation of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, the processor <span class="verb">may</span> either signal
this error in the normal way, or <span class="verb">may</span>
recover by ignoring the failure, in which case the failing URI will
not contribute any nodes to the result of the <a href=
"#func-document"><code>document</code></a> function.</p>
<p>If the URI reference contained no fragment identifier, then this
document node is included in the sequence of nodes returned by the
<a href="#func-document"><code>document</code></a> function.</p>
<p>If the URI reference contained a fragment identifier, then the
fragment identifier is interpreted according to the rules for the
media type of the resource representation identified by the URI,
and is used to select zero or more nodes that are
descendant-or-self nodes of the returned document node. As
described in <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>, the media type is available as part of the
evaluation context for a transformation.</p>
<p>The sequence of nodes returned by the function is in document
order, with no duplicates. This order has no necessary relationship
to the order in which URIs were supplied in the
<code>$uri-sequence</code> argument.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1160" id="err-XTDE1160"><span class=
"error">[ERR XTDE1160]</span></a> When a URI reference contains a
fragment identifier, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the media
type is not one that is recognized by the processor, or if the
fragment identifier does not conform to the rules for fragment
identifiers for that media type, or if the fragment identifier
selects something other than a sequence of nodes (for example, if
it selects a range of characters within a text node).</p>
<p>A processor <span class="verb">may</span> provide an option
which, if selected, causes the processor instead of signaling this
error, to ignore the fragment identifier and return the document
node.</p>
<p>The set of media types recognized by a processor is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p><a name="err-XTDE1162" id="err-XTDE1162"><span class=
"error">[ERR XTDE1162]</span></a> When a URI reference is a
relative reference, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if no base URI
is available to resolve the relative reference. This can arise for
example when the URI is contained in a node that has no base URI
(for example a parentless text node), or when the second argument
to the function is a node that has no base URI, or when the base
URI from the static context is undefined.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>One effect of these rules is that unless XML entities or
<code>xml:base</code> are used, and provided that the base URI of
the stylesheet module is known, <code>document("")</code> refers to
the document node of the containing stylesheet module (the
definitive rules are in <a href="#RFC3986">[RFC3986]</a>). The XML
resource containing the stylesheet module is processed exactly as
if it were any other XML document, for example there is no special
recognition of <a href="#element-text"><code>xsl:text</code></a>
elements, and no special treatment of comments and processing
instructions.</p>
<p>The XPath rules for function calling ensure that it is a type
error if the supplied value of the second argument is anything
other than a single node. If <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
enabled, then a sequence of nodes may be supplied, and the first
node in the sequence will be used.</p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="key" id="key"></a>20.2 <a href="#key" style=
"text-decoration: none">Keys</a></h3>
<p>Keys provide a way to work with documents that contain an
implicit cross-reference structure. They make it easier to locate
the nodes within a document that have a given value for a given
attribute or child element, and they provide a hint to the
implementation that certain access paths in the document need to be
efficient.</p>
<div class="div3">
<h4><a name="xsl-key" id="xsl-key"></a>20.2.1 <a href="#xsl-key"
style="text-decoration: none">The</a> <a href=
"#element-key"><code>xsl:key</code></a> <a href="#xsl-key" style=
"text-decoration: none">Declaration</a></h4>
<p class="element-syntax"><a name="element-key" id=
"element-key"></a><code>&lt;!-- Category: declaration --&gt;<br />
&lt;xsl:key<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;use? = <var>expression</var><br />
&#160;&#160;composite? = "yes" | "no"<br />
&#160;&#160;collation? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:key&gt;</code></p>
<p>The <a href="#element-key"><code>xsl:key</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> is used to declare <a title="key"
class="termref" href="#dt-key">keys</a>. The <code>name</code>
attribute specifies the name of the key. The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>. The
<code>match</code> attribute is a <a href=
"#doc-xslt30-patterns-Pattern30">Pattern</a>; an <a href=
"#element-key"><code>xsl:key</code></a> element applies to all
nodes that match the pattern specified in the <code>match</code>
attribute.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-key" id="dt-key" title="key"></a>A <b>key</b> is defined as a
set of <a href="#element-key"><code>xsl:key</code></a> declarations
in the <span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same
name.<span class="definition">]</span></p>
<p>The key name is scoped to the containing <a title="package"
class="termref" href="#dt-package">package</a>, and is available
for use in calls to the <a href="#func-key"><code>key</code></a>
function within that package.</p>
<p>The value of the key may be specified either using the
<code>use</code> attribute or by means of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><a name="err-XTSE1205" id="err-XTSE1205"><span class=
"error">[ERR XTSE1205]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-key"><code>xsl:key</code></a> declaration has a
<code>use</code> attribute and has non-empty content, or if it has
empty content and no <code>use</code> attribute.</p>
<p>If the <code>use</code> attribute is present, its value is an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> specifying the values of the key.
The expression will be evaluated with <span>a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on the node that
matches the pattern</span>. The result of evaluating the expression
is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>.</p>
<p>Similarly, if a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is
present, it is used to determine the values of the key. The
sequence constructor will be evaluated with the node that matches
the pattern as the context node. The result of evaluating the
sequence constructor is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-key-specifier" id="dt-key-specifier" title=
"key specifier"></a>The expression in the <code>use</code>
attribute and the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> within an
<a href="#element-key"><code>xsl:key</code></a> declaration are
referred to collectively as the <b>key specifier</b>. The key
specifier determines the values that may be used to find a node
using this <a title="key" class="termref" href=
"#dt-key">key</a>.<span class="definition">]</span></p>
<p>When evaluation of the <a title="key specifier" class="termref"
href="#dt-key-specifier">key specifier</a> results in a sequence
(after atomization) containing more than one atomic value, the
effect depends on the value of the <code>composite</code>
attribute:</p>
<ul>
<li>
<p>When the attribute is absent or has the value <code>no</code>,
each atomic value in the sequence acts as an individual key. For
example, if <code>match="book" use="author" composite="no"</code>
is specified, then a <code>book</code> element may be located using
the value of any <code>author</code> element.</p>
</li>
<li>
<p>When the attribute is present and has the value
<code>yes</code>, the sequence of atomic values is treated as a
composite key that must be matched in its entirety. For example, if
<code>match="book" use="author" composite="yes"</code> is
specified, then a <code>book</code> element may be located using
the value of all its <code>author</code> elements, supplied in the
correct order.</p>
</li>
</ul>
<p>If there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same package</span> with the same key name, then they must
all have the same effective value for their <code>composite</code>
attribute. The effective value is the actual value of the attribute
if present, or "no" if the attribute is absent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no requirement that all the values of a key should have
the same type.</p>
</div>
<p>The presence of an <a href=
"#element-key"><code>xsl:key</code></a> declaration makes it easy
to find a node that matches the <code>match</code> pattern if the
values of the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> (when applied to that node)
are known. It also provides a hint to the implementation that
access to the nodes by means of these values needs to be efficient
(many implementations are likely to construct an index or hash
table to achieve this).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An <a href="#element-key"><code>xsl:key</code></a> declaration
is not bound to a specific source document. The source document to
which it applies is determined only when the <a href=
"#func-key"><code>key</code></a> function is used to locate nodes
using the key. Keys can be used to locate nodes within any source
document (including temporary trees), but each use of the <a href=
"#func-key"><code>key</code></a> function searches one document
only.</p>
</div>
<p>The optional <code>collation</code> attribute is used only when
deciding whether two strings are equal for the purposes of key
matching. Specifically, two key values <code>$a</code> and
<code>$b</code> are considered equal if the result of the function
call <span><code>deep-equal($a, $b, $collation)</code> is
true</span>. The effective collation for an <a href=
"#element-key"><code>xsl:key</code></a> declaration is the
collation specified in its <code>collation</code> attribute if
present, resolved against the base URI of the <a href=
"#element-key"><code>xsl:key</code></a> element, or the <a title=
"default collation" class="termref" href=
"#dt-default-collation">default collation</a> that is in scope for
the <a href="#element-key"><code>xsl:key</code></a> declaration
otherwise; the effective collation must be the same for all the
<a href="#element-key"><code>xsl:key</code></a> declarations making
up a <a title="key" class="termref" href="#dt-key">key</a>.</p>
<p><a name="err-XTSE1210" id="err-XTSE1210"><span class=
"error">[ERR XTSE1210]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-key"><code>xsl:key</code></a> declaration has a
<code>collation</code> attribute whose value (after resolving
against the base URI) is not a URI recognized by the implementation
as referring to a collation.</p>
<p><a name="err-XTSE1220" id="err-XTSE1220"><span class=
"error">[ERR XTSE1220]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
are several <a href="#element-key"><code>xsl:key</code></a>
declarations in the <span>same <a title="package" class="termref"
href="#dt-package">package</a></span> with the same key name and
different effective collations. Two collations are the same if
their URIs are equal under the rules for comparing
<code>xs:anyURI</code> values, or if the implementation can
determine that they are different URIs referring to the same
collation.</p>
<p><a name="err-XTSE1222" id="err-XTSE1222"><span class=
"error">[ERR XTSE1222]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
are several <a href="#element-key"><code>xsl:key</code></a>
declarations in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> with the same key name and
different effective values for the <code>composite</code>
attribute.</p>
<p>It is possible to have:</p>
<ul>
<li>
<p>multiple <a href="#element-key"><code>xsl:key</code></a>
declarations with the same name;</p>
</li>
<li>
<p>a node that matches the <code>match</code> patterns of several
different <a href="#element-key"><code>xsl:key</code></a>
declarations, whether these have the same key name or different key
names;</p>
</li>
<li>
<p>a node that returns more than one value from its <a title=
"key specifier" class="termref" href="#dt-key-specifier">key
specifier</a> <span>(which can be treated either as separate
individual key values, or as a single composite key
value)</span>;</p>
</li>
<li>
<p>a key value that identifies more than one node (the key values
for different nodes do not need to be unique).</p>
</li>
</ul>
<p>An <a href="#element-key"><code>xsl:key</code></a> declaration
with higher <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> does not override
another of lower import precedence; all the <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
stylesheet are effective regardless of their import precedence.</p>
</div>
<div class="div3">
<h4><a name="func-key" id="func-key"></a>20.2.2 <a href="#func-key"
style="text-decoration: none">fn:key</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the nodes that match a supplied key value.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-key" id="function-key"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :key function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">key</code>(</td>
<td valign="baseline"><code class="arg">$key-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key-value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :key function">
<tr>
<td valign="baseline" rowspan="3"><code class=
"function">key</code>(</td>
<td valign="baseline"><code class="arg">$key-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key-value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$top</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">node()</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
<p>The three-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-key"><code>key</code></a> function does for
keys what the <span><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-element-with-id"><code>
element-with-id</code></a><sup><small>FO30</small></sup></span>
function does for IDs.</p>
<p>The <code>$key-name</code> argument specifies the name of the
<a title="key" class="termref" href="#dt-key">key</a>. The value of
the argument <span class="verb">must</span> be a <span>string
containing an <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The <code>$key-value</code> argument to the <a href=
"#func-key"><code>key</code></a> function is considered as a
sequence. <span>The effect depends on the value of the
<code>composite</code> attribute of the corresponding
<code>xsl:key</code> declaration.</span></p>
<ul>
<li>
<p><span>If <code>composite</code> is <code>no</code> or
absent,</span> the set of requested key values is formed by
atomizing the supplied value of the argument, using the standard
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. Each
of the resulting atomic values is considered as a requested key
value. The result of the function is a sequence of nodes, in
document order and with duplicates removed, comprising those nodes
in the selected subtree (see below) that are matched by an <a href=
"#element-key"><code>xsl:key</code></a> declaration whose name is
the same as the supplied key name, where the result of evaluating
the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> contains a value that is
equal to one of these requested key values, under the rules
appropriate to the XPath <code>eq</code> operator for the two
values in question, using the <code>collation</code> attributes of
the <a href="#element-key"><code>xsl:key</code></a> declaration
when comparing strings. No error is reported if two values are
encountered that are not comparable; they are regarded for the
purposes of this function as being not equal.</p>
<p>If the second argument is an empty sequence, the result of the
function will be an empty sequence.</p>
</li>
<li>
<p>If <code>composite</code> is <code>yes</code>, the requested key
value is the sequence formed by atomizing the supplied value of the
argument, using the standard <a title="function conversion rules"
class="termref" href="#dt-function-conversion-rules">function
conversion rules</a>. The result of the function is a sequence of
nodes, in document order and with duplicates removed, comprising
those nodes in the selected subtree (see below) that are matched by
an <a href="#element-key"><code>xsl:key</code></a> declaration
whose name is the same as the supplied key name, where the result
of evaluating the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> is deep-equal to the
requested key value, under the rules appropriate to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function applied to the two values in question, using the
<code>collation</code> attributes of the <a href=
"#element-key"><code>xsl:key</code></a> declaration when comparing
strings. Note that the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function reports no error if two values are encountered that are
not comparable; they are regarded for the purposes of this function
as being not equal.</p>
<p>If the second argument is an empty sequence, the result of the
function will be the set of nodes having an empty sequence as the
value of the key specifier.</p>
</li>
</ul>
<p>Different rules apply when <span><a title="XSLT 1.0 behavior"
class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 compatible
behavior</a> is enabled.</span></p>
<p>A key (that is, a set of <a href=
"#element-key"><code>xsl:key</code></a> declarations sharing the
same key name) is processed in backwards compatible mode if (a) at
least one of the xsl:key elements in the definition of the key
enables backwards compatible behavior, and (b) the effective value
of the <code>composite</code> attribute is <code>no</code>.</p>
<p>When a key is processed in backwards compatible mode, then:</p>
<div style="margin-left: 2em">
<p>The result of evaluating the key specifier in any <a href=
"#element-key"><code>xsl:key</code></a> declaration having this key
name is converted after atomization to a sequence of strings, by
applying a cast to each item in the sequence.</p>
<p>When the first argument to the <a href=
"#func-key"><code>key</code></a> function specifies this key name,
then the value of the second argument is converted after
atomization to a sequence of strings, by applying a cast to each
item in the sequence. The values are then compared as strings.</p>
</div>
<p>The third argument is used to identify the selected subtree. If
the argument is present, the selected subtree is the set of nodes
that have <var>$top</var> as an ancestor-or-self node. If the
argument is omitted, the selected subtree is the document
containing the context node. This means that the third argument
effectively defaults to <code>/</code>.</p>
<p>The result of the <a href="#func-key"><code>key</code></a>
function can be described more specifically as follows. The result
is a sequence containing every node <var>$N</var> that satisfies
the following conditions:</p>
<ul>
<li>
<p><code>$N/ancestor-or-self::node() intersect $top</code> is
non-empty. (If the third argument is omitted, <code>$top</code>
defaults to <code>/</code>)</p>
</li>
<li>
<p><var>$N</var> matches the pattern specified in the
<code>match</code> attribute of an <a href=
"#element-key"><code>xsl:key</code></a> declaration whose
<code>name</code> attribute matches the name specified in the
<code>$key-name</code> argument.</p>
</li>
<li>
<p><span>When <code>composite="no"</code>,</span> and the <a title=
"key specifier" class="termref" href="#dt-key-specifier">key
specifier</a> of that <a href=
"#element-key"><code>xsl:key</code></a> declaration is evaluated
with a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>$N</var>,
the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> value of the resulting sequence
includes a value that compares equal to at least one item in the
atomized value of the sequence supplied as <code>$key-value</code>,
under the rules of the <code>eq</code> operator with the collation
selected as described above.</p>
<p><span>When <code>composite="yes"</code>,</span> and the
<a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> of that <a href=
"#element-key"><code>xsl:key</code></a> declaration is evaluated
with a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>$N</var>,
the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> value of the resulting sequence
compares equal to the atomized value of the sequence supplied as
<code>$key-value</code>, under the rules of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function with the collation selected as described above.</p>
</li>
</ul>
<p>The sequence returned by the <a href=
"#func-key"><code>key</code></a> function will be in document
order, with duplicates (that is, nodes having the same identity)
removed.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1260" id="err-XTDE1260"><span class=
"error">[ERR XTDE1260]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value is not a valid QName, or if there is no namespace declaration
in scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-key"><code>xsl:key</code></a> declaration in the
<span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
<p><a name="err-XTDE1270" id="err-XTDE1270"><span class=
"error">[ERR XTDE1270]</span></a> It is a <span><a title="" class=
"termref" href="#">dynamic error</a></span> to call the <a href=
"#func-key"><code>key</code></a> function with two arguments if
there is no <a title="context node" class="termref" href=
"#dt-context-node">context node</a>, or if the root of the tree
containing the context node is not a document node; or to call the
function with three arguments if the root of the tree containing
the node supplied in the third argument is not a document node.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Untyped atomic values are converted to strings, not to the type
of the other operand. This means, for example, that if the
expression in the <code>use</code> attribute returns a date,
supplying an untyped atomic value in the call to the <a href=
"#func-key"><code>key</code></a> function will return an empty
sequence.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<div class="example">
<div class="exampleHeader"><a name="d7e52090" id=
"d7e52090"></a>Example: Using a Key to Follow
Cross-References</div>
<p>Given a declaration</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="idkey" match="div" use="@id"/&gt;
</pre></div>
<p>an expression <code>key("idkey",@ref)</code> will return the
same nodes as <code>id(@ref)</code>, assuming that the only ID
attribute declared in the XML source document is:</p>
<div class="exampleInner">
<pre>
&lt;!ATTLIST div id ID #IMPLIED&gt;
</pre></div>
<p>and that the <code>ref</code> attribute of the context node
contains no whitespace.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e52112" id=
"d7e52112"></a>Example: Using a Key to Generate Hyperlinks</div>
<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>
<div class="exampleInner">
<pre>
&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;
</pre></div>
<p>and a <code>function</code> element to refer to function
names</p>
<div class="exampleInner">
<pre>
&lt;function&gt;sqrt&lt;/function&gt;
</pre></div>
<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
  &lt;/xsl:template&gt;
</pre></div>
</div>
<p>When called with two arguments, the <a href=
"#func-key"><code>key</code></a> function always returns nodes that
are in the same document as the context node. To retrieve a node
from any other document, it is necessary either to change the
context node, or to supply a third argument.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e52138" id=
"d7e52138"></a>Example: Using Keys to Reference other
Documents</div>
<p>For example, suppose a document contains bibliographic
references in the form
<code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a
separate XML document <code>bib.xml</code> containing a
bibliographic database with entries in the form:</p>
<div class="exampleInner">
<pre>
&lt;entry name="XSLT"&gt;...&lt;/entry&gt;
</pre></div>
<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This relies on the ability in XPath 2.0 to have a function call
on the right-hand side of the <code>/</code> operator in a path
expression.</p>
</div>
<p>The following code would also work:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e52168" id=
"d7e52168"></a>Example: Using a Composite Key</div>
<p>This example uses a composite key consisting of first name and
last name to locate employees in an employee file.</p>
<p>The key can be defined like this:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/&gt;                     
         
</pre></div>
<p>A particular employee can then be located using the function
call:</p>
<div class="exampleInner">
<pre>
key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))
</pre></div>
</div>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="misc-func" id="misc-func"></a>20.3 <a href=
"#misc-func" style="text-decoration: none">Miscellaneous Additional
Functions</a></h3>
<div class="div3">
<h4><a name="func-current" id="func-current"></a>20.3.1 <a href=
"#func-current" style="text-decoration: none">fn:current</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the item that is the context item for the evaluation of
the containing XPath expression</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current" id="function-current"></a></p>
<div class="proto"><code class=
"function">current</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-current"><code>current</code></a> function,
used within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, returns the item that was the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> at the point where the
expression was invoked from the XSLT <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This is referred to
as the current item. For an outermost expression (an expression not
occurring within another expression), the current item is always
the same as the context item. Thus,</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="current()"/&gt;
</pre></div>
<p>means the same as</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="."/&gt;
</pre></div>
<p>However, within square brackets, or on the right-hand side of
the <code>/</code> operator, the current item is generally
different from the context item.</p>
<p>If the <a href="#func-current"><code>current</code></a> function
is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, its value is the <span>item</span> that
is being matched against the pattern.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1360" id="err-XTDE1360"><span class=
"error">[ERR XTDE1360]</span></a> If the <a href=
"#func-current"><code>current</code></a> function is evaluated
within an expression that is evaluated when the context item is
absent, a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs.</p>
<p>When the <a href="#func-current"><code>current</code></a> is
called by means of a dynamic function call (for example,
<code>current#0()</code>), it is evaluated as if the context item
is absent (<span class="error">[see <a href="#err-XTDE1360">ERR
XTDE1360</a>]</span>).</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;
</pre></div>
<p>will process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a
<code>name</code> attribute with value equal to the value of the
current item's <code>ref</code> attribute. This is different
from</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;
</pre></div>
<p>which means the same as</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;
</pre></div>
<p>and so would process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a
<code>name</code> attribute and a <code>ref</code> attribute with
the same value.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-unparsed-entity-uri" id=
"func-unparsed-entity-uri"></a>20.3.2 <a href=
"#func-unparsed-entity-uri" style=
"text-decoration: none">fn:unparsed-entity-uri</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the URI (system identifier) of an unparsed entity</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-unparsed-entity-uri" id=
"function-unparsed-entity-uri"></a></p>
<div class="proto"><code class=
"function">unparsed-entity-uri</code>(<code class=
"arg">$entity-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyURI</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function returns the URI of the unparsed entity whose name is given
by the value of the <code>$entity-name</code> argument, in the
document containing the <a title="context node" class="termref"
href="#dt-context-node">context node</a>. It returns the
zero-length <code>xs:anyURI</code> if there is no such entity. This
function maps to the <code>dm:unparsed-entity-system-id</code>
accessor defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1370" id="err-XTDE1370"><span class=
"error">[ERR XTDE1370]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-unparsed-entity-public-id" id=
"func-unparsed-entity-public-id"></a>20.3.3 <a href=
"#func-unparsed-entity-public-id" style=
"text-decoration: none">fn:unparsed-entity-public-id</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the public identifier of an unparsed entity</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-unparsed-entity-public-id" id=
"function-unparsed-entity-public-id"></a></p>
<div class="proto"><code class=
"function">unparsed-entity-public-id</code>(<code class=
"arg">$entity-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyURI</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function returns the public identifier of the unparsed entity whose
name is given by the value of the <code>$entity-name</code>
argument, in the document containing the <a title="context node"
class="termref" href="#dt-context-node">context node</a>. It
returns the zero-length string if there is no such entity, or if
the entity has no public identifier. This function maps to the
<code>dm:unparsed-entity-public-id</code> accessor defined in
<a href="#xpath-datamodel-30">[Data Model]</a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1380" id="err-XTDE1380"><span class=
"error">[ERR XTDE1380]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-system-property" id=
"func-system-property"></a>20.3.4 <a href="#func-system-property"
style="text-decoration: none">fn:system-property</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the value of a system property</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-system-property" id=
"function-system-property"></a></p>
<div class="proto"><code class=
"function">system-property</code>(<code class=
"arg">$property-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$property-name</code> argument <span class=
"verb">must</span> evaluate to a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a>. The <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> is expanded as described in <a href="#qname"><i>5.1
Qualified Names</i></a>.</p>
<p>The <a href=
"#func-system-property"><code>system-property</code></a> function
returns a string representing the value of the system property
identified by the name. If there is no such system property, the
zero-length string is returned.</p>
<p>Implementations <span class="verb">must</span> provide the
following system properties, which are all in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>:</p>
<ul>
<li>
<p><code>xsl:version</code>, a number giving the version of XSLT
implemented by the <a title="processor" class="termref" href=
"#dt-processor">processor</a>; for implementations conforming to
the version of XSLT specified by this document, this is the string
<span><code>"3.0"</code></span>. The value will always be a string
in the lexical space of the decimal data type defined in XML Schema
(see <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows
the value to be converted to a number for the purpose of magnitude
comparisons.</p>
</li>
<li>
<p><code>xsl:vendor</code>, a string identifying the implementer of
the <a title="processor" class="termref" href=
"#dt-processor">processor</a></p>
</li>
<li>
<p><code>xsl:vendor-url</code>, a string containing a URL
identifying the implementer of the <a title="processor" class=
"termref" href="#dt-processor">processor</a>; typically this is the
host page (home page) of the implementer's Web site.</p>
</li>
<li>
<p><code>xsl:product-name</code>, a string containing the name of
the implementation, as defined by the implementer. This
<span class="verb">should</span> normally remain constant from one
release of the product to the next. It <span class=
"verb">should</span> also be constant across platforms in cases
where the same source code is used to produce compatible products
for multiple execution platforms.</p>
</li>
<li>
<p><code>xsl:product-version</code>, a string identifying the
version of the implementation, as defined by the implementer. This
<span class="verb">should</span> normally vary from one release of
the product to the next, and at the discretion of the implementer
it <span class="verb">may</span> also vary across different
execution platforms.</p>
</li>
<li>
<p><code>xsl:is-schema-aware</code>, returns the string
<code>"yes"</code> in the case of a processor that claims
conformance as a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a>, or <code>"no"</code> in the case of a <a title=
"basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a>.</p>
</li>
<li>
<p><code>xsl:supports-serialization</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
<a title="serialization feature" class="termref" href=
"#dt-serialization-feature">serialization feature</a>, or
<code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-backwards-compatibility</code>, returns the
string <code>"yes"</code> in the case of a processor that offers
the <span><a title="XSLT 1.0 compatibility feature" class="termref"
href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility
feature</a></span>, or <code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-namespace-axis</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the XPath
namespace axis even when not in backwards compatible mode, or
<code>"no"</code> otherwise. Note that a processor that supports
backwards compatible mode must support the namespace axis when in
that mode, so this property is not relevant to that case.</p>
</li>
<li>
<p><code>xsl:supports-streaming</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
streaming feature (see <a href="#streaming-feature"><i>26.5
Streaming Feature</i></a>), or <code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-dynamic-evaluation</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
dynamic evaluation feature (see <a href=
"#dynamic-evaluation-feature"><i>26.6 Dynamic Evaluation
Feature</i></a>), or <code>"no"</code> otherwise.</p>
</li>
</ul>
<p>Some of these properties relate to the conformance levels and
features offered by the <a title="processor" class="termref" href=
"#dt-processor">processor</a>: these options are described in
<a href="#conformance"><i>26 Conformance</i></a>.</p>
<p>The actual values returned for the above properties are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>The set of system properties that are supported, in addition to
those listed above, is also <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.
Implementations <span class="verb">must not</span> define
additional system properties in the XSLT namespace.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1390" id="err-XTDE1390"><span class=
"error">[ERR XTDE1390]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value supplied as the <code>$property-name</code> argument is not a
valid QName, or if there is no namespace declaration in scope for
the prefix of the QName. If the processor is able to detect the
error statically (for example, when the argument is supplied as a
string literal), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>An implementation must not return the value
<code><span>3.0</span></code> as the value of the
<code>xsl:version</code> system property unless it is conformant to
XSLT <span>3.0</span>.</p>
<p>It is recognized that vendors who are enhancing XSLT 1.0
<span>or 2.0</span> processors may wish to release interim
implementations before all the mandatory features of this
specification are implemented. Since such products are not
conformant to XSLT 3.0, this specification cannot define their
behavior. However, implementers of such products are encouraged to
return a value for the <code>xsl:version</code> system property
that is intermediate between 1.0 and 3.0, and to provide the
<a href=
"#func-element-available"><code>element-available</code></a> and
<a href=
"#func-function-available"><code>function-available</code></a>
functions to allow users to test which features have been fully
implemented.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div1">
<h2><a name="additional-types" id="additional-types"></a>21
<a href="#additional-types" style="text-decoration: none">XPath
Extensions</a></h2>
<p>XSLT 3.0 extends the type system and data model of XPath 3.0
with additional datatypes and associated functions and operators
defined in this section.</p>
<div class="div2">
<h3><a name="map" id="map"></a>21.1 <a href="#map" style=
"text-decoration: none">Maps</a></h3>
<p>A map is an additional kind of item.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-map" id="dt-map" title="map"></a>A map consists of a set of
entries. Each entry comprises a key which is an arbitrary atomic
value, and an arbitrary sequence called the associated
value.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-same-key" id="dt-same-key" title="same key"></a>Within a map,
no two entries have the <b>same key</b>. <span>Two atomic values
<code>K1</code> and <code>K2</code> are the <b>same key</b> for
this purpose if the relation <code>deep-equal(K1, K2, $UCC)</code>
holds, where <code>$UCC</code> is the Unicode codepoint
collation.</span><span class="definition">]</span></p>
<p>To put it another way, the keys are the same if either <code>K1
eq K2</code> is true under the Unicode codepoint collation, or if
both <code>K1</code> and <code>K2</code> are <code>NaN</code>. It
is not necessary that all the keys should be mutually comparable
(for example, they can include a mixture of integers and
strings).</p>
<p>The function call <code>map:get($map, $key)</code> can be used
to retrieve the value associated with a given key.</p>
<p>A <a title="map" class="termref" href="#dt-map">map</a> can also
be viewed as a function from keys to associated values. To achieve
this, a map is also a function item. The properties of this
function are as follows:</p>
<ul>
<li>
<p>The <b>name</b> of the function is absent.</p>
</li>
<li>
<p>The <b>arity</b> of the function is 1 (one).</p>
</li>
<li>
<p>The <b>parameter names</b> comprise a sequence of one QName,
conventionally <code>$key</code>, though the choice of name has no
observable consequences.</p>
</li>
<li>
<p>The <b>signature</b> is <code>function($key as
xs:anyAtomicValue) as item()*</code> (with no annotations).</p>
</li>
<li>
<p>The <b>implementation</b> is the expression <code>map:get($self,
$key)</code></p>
</li>
<li>
<p>The <b>non-local-variable-bindings</b> comprise a single
variable, <code>$self</code>, whose value is the map itself.</p>
</li>
</ul>
<p>Calling the function has the same effect as calling the
<code>get</code> function: the expression <code>$map($key)</code>
returns the same result as <code>get($map, $key)</code>. For
example, if <code>$books-by-isbn</code> is a map whose keys are
ISBNs and whose associated values are <code>book</code> elements,
then the expression <code>$books-by-isbn("0470192747")</code>
returns the <code>book</code> element with the given ISBN. The fact
that a map is a function item allows it to be passed as an argument
to higher-order functions that expect a function item as one of
their arguments.</p>
<p>Like all other values, <a title="map" class="termref" href=
"#dt-map">maps</a> are immutable. For example, the <a href=
"#func-map-remove"><code>map:remove</code></a> function creates a
new map by removing an entry from an existing map, but the existing
map is not changed by the operation.</p>
<p>Like sequences, <a title="map" class="termref" href=
"#dt-map">maps</a> have no identity. It is meaningful to compare
the contents of two maps, but there is no way of asking whether
they are "the same map": two maps with the same content are
indistinguishable.</p>
<div class="div3">
<h4><a name="map-type" id="map-type"></a>21.1.1 <a href="#map-type"
style="text-decoration: none">The Type of a Map</a></h4>
<p>The syntax of <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>
as defined in XPath is extended as follows:</p>
<h5><a name="d7e52977" id="d7e52977"></a>MapType</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="NT-ItemType-2" id=
"NT-ItemType-2"></a>[69]&#160;&#160;&#160;</td>
<td><code>ItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>KindTest | ("item" "(" ")") | FunctionTest |
AtomicOrUnionType | ParenthesizedItemType<br />
| MapType</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-MapType" id=
"NT-MapType"></a>[201]&#160;&#160;&#160;</td>
<td><code>MapType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'map' '(' ( '*' | (<a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-AtomicOrUnionType">AtomicOrUnionType</a><sup><small>XP30</small></sup>
',' <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>)
')'</code></td>
</tr>
</tbody>
</table>
<p>The following rules express the matching rules for a map item
type and a map, and extend the set of rules given in <a href=
"http://www.w3.org/TR/xpath-30/#id-matching-item">Section 2.5.5.2
Matching an ItemType and an Item</a>
<sup><small>XP30</small></sup>:</p>
<ul>
<li>
<p>The <code>ItemType</code> <code>map(K, V)</code> matches an item
<var>M</var> if (a) <var>M</var> is a <a title="map" class=
"termref" href="#dt-map">map</a>, and (b) every entry in
<var>M</var> has a key that matches <code>K</code> and an
associated value that matches <code>V</code>. For example,
<code>map(xs:integer, element(employee))</code> matches a map if
all the keys in the map are integers, and all the associated values
are <code>employee</code> elements. Note that a map (like a
sequence) carries no intrinsic type information separate from the
types of its entries, and the type of existing entries in a map
does not constrain the type of new entries that can be added to the
map.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In consequence, <code>map(K, V)</code> matches an empty map,
whatever the types <var>K</var> and <var>V</var> might be.</p>
</div>
</li>
<li>
<p>The <code>ItemType</code> <code>map(*)</code> matches any map
regardless of its contents. It is equivalent to
<code>map(xs:anyAtomicType, item()*)</code>.</p>
</li>
</ul>
<p>A map also acts as a function. This means that maps match
certain function item types. Specifically, the following rule
extends the list of rules in <a href=
"http://www.w3.org/TR/xpath-30/#id-function-test">Section 2.5.5.7
Function Test</a> <sup><small>XP30</small></sup>:</p>
<ul>
<li>
<p><code>function(*)</code> matches any map.</p>
</li>
<li>
<p><code>function(xs:anyAtomicType) as item()*</code> matches any
map.</p>
</li>
</ul>
<p>Because of the rules for subtyping of function types according
to their signature, it follows that the item type <code>function(A)
as item()*</code>, where A is an atomic type, also matches any map,
regardless of the type of the keys actually found in the map. For
example, a map whose keys are all strings can be supplied where the
required type is <code>function(xs:integer) as item()*</code>; a
call on the map that treats it as a function with an integer
argument will always succeed, and will always return an empty
sequence.</p>
<p>The function signature of the map, treated as a function, is
always <code>function(xs:anyAtomicType) as item()*</code>,
regardless of the actual types of the keys and values in the map.
This means that a function item type with a more specific return
type, such as <code>function(xs:anyAtomicType) as
xs:integer</code>, does not match a map in the sense required to
satisfy the <code>instance of</code> operator. However, the rules
for function coercion mean that any map can be supplied as a value
in a context where such a type is the required type, and a type
error will only occur if an actual call on the map (treated as a
function) returns a value that is not an instance of the required
return type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>So, given a map <code>$M</code> whose keys are integers and
whose results are strings, such as <code>map{0:"no",
1:"yes"}</code>, the following relations hold, among others:</p>
<ul>
<li>
<p><code>$M instance of map(*)</code></p>
</li>
<li>
<p><code>$M instance of map(xs:integer, xs:string)</code></p>
</li>
<li>
<p><code>$M instance of map(xs:decimal,
xs:anyAtomicType)</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:int, xs:string))</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:integer, xs:token))</code></p>
</li>
<li>
<p><code>$M instance of function(*)</code></p>
</li>
<li>
<p><code>$M instance of function(xs:anyAtomicType) as
item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:integer) as item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:int) as item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:string) as item()*</code></p>
</li>
<li>
<p><code>not($M instance of function(xs:integer) as
xs:string)</code></p>
</li>
</ul>
<p>The last case might seem surprising; however, function coercion
ensures that <code>$M</code> can be used successfully anywhere that
the required type is <code>function(xs:integer) as
xs:string</code>.</p>
</div>
<p>The rules for judging whether one item type is a subtype of
another, given in <a href=
"http://www.w3.org/TR/xpath-30/#id-itemtype-subtype">Section
2.5.6.2 The judgement subtype-itemtype(Ai, Bi)</a>
<sup><small>XP30</small></sup>, are extended with some additional
rules. The judgement <code>subtype-itemtype(Ai, Bi)</code> is true
if:</p>
<ul>
<li>
<p><code>Ai</code> is <code>map(*)</code> and <code>Bi</code> is
<code>map(K, V)</code>, for any <code>K</code> and
<code>V</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code>
is <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Kb,
Ka)</code> and <code>subtype-itemtype(Vb, Va)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>function(*)</code> and <code>Bi</code>
is <code>map(*)</code>, (or, because of the transitivity rules, any
other map type).</p>
</li>
<li>
<p><code>Ai</code> is <code>function(xs:anyAtomicType) as
item()*</code> and <code>Bi</code> is <code>map(*)</code>, (or,
because of the transitivity rules, any other map type).</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="map-functions" id="map-functions"></a>21.1.2 <a href=
"#map-functions" style="text-decoration: none">Functions that
Operate on Maps</a></h4>
<p>The functions defined in this section use a conventional
namespace prefix <code>map</code>, which is assumed to be bound to
the namespace URI
<code>http://www.w3.org/2005/xpath-functions/map</code>.</p>
<p>There is no operation to atomize a map or convert it to a
string.</p>
<p>The number of entries in the map may be obtained as
<code>count(map:keys($map))</code>.</p>
<div class="div4">
<h5><a name="func-map-new" id="func-map-new"></a>21.1.2.1 <a href=
"#func-map-new" style="text-decoration: none">map:new</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Creates a new map: either an empty map, or a map that combines
entries from a number of existing maps.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-new" id="function-new"></a></p>
<div class="proto"><code class="function">new</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></div>
<div class="proto"><code class="function">new</code>(<code class=
"arg">$maps</code><code class=
"as">&#160;as&#160;</code><code class="type">map(*)*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">map(*)</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-new"><code>map:new</code></a>
constructs and returns a new map.</p>
<p>The zero-argument form of the function returns an empty
<a title="map" class="termref" href="#dt-map">map</a>. It is
equivalent to calling the one-argument form of the function with an
empty sequence as the value of the first argument.</p>
<p>The one-argument form of the function returns a <a title="map"
class="termref" href="#dt-map">map</a> that is formed by combining
the contents of the maps supplied in the <code>$input</code>
argument.</p>
<p>The supplied maps are combined as follows:</p>
<ol class="enumar">
<li>
<p>There is one entry in the new map for each distinct key value
present in the union of the input maps, where two keys are distinct
if they are not the <span><a title="same key" class="termref" href=
"#dt-same-key">same key</a></span>.</p>
</li>
<li>
<p>The associated value for each such key is taken from the last
map in the input sequence <code>$input</code> that contains an
entry with this key.</p>
</li>
</ol>
<p>There is no requirement that the supplied input maps should have
the same or compatible types. The type of a map (for example
<code>map(xs:integer, xs:string)</code>) is descriptive of the
entries it currently contains, but is not a constraint on how the
map may be combined with other maps.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:new()</code> returns
<code>map{}</code>. <em>(Returns an empty map).</em></p>
<p>The expression <code>map:new(())</code> returns
<code>map{}</code>. <em>(Returns an empty map).</em></p>
<p>The expression <code>map:new((map:entry(0, "no"), map:entry(1,
"yes")))</code> returns <code>map{0:"no", 1:"yes"}</code>.
<em>(Returns a map with two entries).</em></p>
<p>The expression <code>map:new(($week, {7:"Unbekannt"}))</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag",
7:"Unbekannt"}</code>. <em>(The value of the existing map is
unchanged; a new map is created containing all the entries from
<code>$week</code>, supplemented with a new entry.).</em></p>
<p>The expression <code>map:new(($week, {6:"Sonnabend"}))</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Sonnabend"}</code>.
<em>(The value of the existing map is unchanged; a new map is
created containing all the entries from <code>$week</code>, with
one entry replaced by a new entry. Both input maps contain an entry
with the key value <code>6</code>; the one used in the result is
the one that comes last in the input sequence.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-keys" id="func-map-keys"></a>21.1.2.2
<a href="#func-map-keys" style=
"text-decoration: none">map:keys</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a sequence containing all the key values present in a
map</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-keys" id="function-keys"></a></p>
<div class="proto"><code class="function">keys</code>(<code class=
"arg">$input</code><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-keys"><code>map:keys</code></a>
takes any <a title="map" class="termref" href="#dt-map">map</a> as
its <code>$input</code> argument and returns the keys that are
present in the map as a sequence of atomic values, in <a title=""
class="termref" href="#">implementation-dependent</a> order.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The number of items in the result will be the same as the number
of entries in the map, and the result sequence will contain no
duplicate values.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:keys(map{1:"yes", 2:"no"})</code>
returns some permutation of <code>(1,2)</code>. <em>(The result is
in <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-contains" id="func-map-contains"></a>21.1.2.3
<a href="#func-map-contains" style=
"text-decoration: none">map:contains</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Tests whether a supplied map contains an entry for a given
key</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-contains" id="function-contains"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :contains function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">contains</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-contains"><code>map:contains</code></a> returns true if
the <a title="map" class="termref" href="#dt-map">map</a> supplied
as <code>$map</code> contains an entry with <span>the <a title=
"same key" class="termref" href="#dt-same-key">same key</a>
as</span> the supplied value of <code>$key</code>; otherwise it
returns false. The equality comparison uses the <span>Unicode
codepoint collation</span>; no error occurs if the map contains
keys that are not comparable with the supplied
<code>$key</code>.</p>
<p>If the supplied key is <code>xs:untypedAtomic</code>, it
<span>is compared as an instance of</span> <code>xs:string</code>.
If the supplied key is the <code>xs:float</code> or
<code>xs:double</code> value <code>NaN</code>, the function
<span>returns true if there is an entry whose key is
<code>NaN</code>, or false otherwise</span>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:contains($week, 2)</code> returns
<code>true()</code>.</p>
<p>The expression <code>map:contains($week, 9)</code> returns
<code>false()</code>.</p>
<p>The expression <code>map:contains(map{}, "xyz")</code> returns
<code>false()</code>.</p>
<p>The expression <code>map:contains(map{"xyz":23}, "xyz")</code>
returns <code>true()</code>.</p>
<p>The expression <code>map:contains(map{"abc":23, "xyz":()},
"xyz")</code> returns <code>true()</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-get" id="func-map-get"></a>21.1.2.4 <a href=
"#func-map-get" style="text-decoration: none">map:get</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the value associated with a supplied key in a given
map.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-get" id="function-get"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :get function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">get</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-get"><code>map:get</code></a>
attempts to find an entry within the <a title="map" class="termref"
href="#dt-map">map</a> supplied as <code>$map</code> that has
<span>the <a title="same key" class="termref" href=
"#dt-same-key">same key</a> as</span> the supplied value of
<code>$key</code>. If there is such an entry, it returns the
associated value; otherwise it returns an empty sequence. The
comparison uses the <span>Unicode codepoint collation</span>; no
error occurs if the map contains keys that are not comparable with
the supplied <code>$key</code>.</p>
<p>If the supplied key is <code>xs:untypedAtomic</code>, it is
<span>compared as an instance of</span> <code>xs:string</code>. If
the supplied key is the <code>xs:float</code> or
<code>xs:double</code> value <code>NaN</code>, the function returns
<span>the value in the entry whose key is <code>NaN</code>, if
there is such an entry, or the empty sequence otherwise</span>.</p>
<p>Where values of different numeric types are numerically very
close to each other, it can happen that the map contains two
entries whose keys both match the supplied key, but which are not
equal to each other. In this situation the entry that is returned
is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>A return value of <code>()</code> from <a href=
"#func-map-get"><code>map:get</code></a> could indicate that the
key is present in the map with an associated value of
<code>()</code>, or it could indicate that the key is not present
in the map. The two cases can be distinguished by calling <a href=
"#func-map-contains"><code>map:contains</code></a>.</p>
<p>Invoking the <a title="map" class="termref" href=
"#dt-map">map</a> as a function item has the same effect as calling
<code>get</code>: that is, when <code>$map</code> is a map, the
expression <code>$map($K)</code> is equivalent to
<code>map:get($map, $K)</code>. Similarly, the expression
<code>map:get(map:get(map:get($map, 'employee'), 'name'),
'first')</code> can be written as
<code>$map('employee')('name')('first')</code>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:get($week, 4)</code> returns
<code>"Donnerstag"</code>.</p>
<p>The expression <code>map:get($week, 9)</code> returns
<code>()</code>. <em>(When the key is not present, the function
returns an empty sequence.).</em></p>
<p>The expression <code>map:get(map:entry(7,()), 7)</code> returns
<code>()</code>. <em>(An empty sequence as the result can also
signify that the key is present and the associated value is an
empty sequence.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-entry" id="func-map-entry"></a>21.1.2.5
<a href="#func-map-entry" style=
"text-decoration: none">map:entry</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Creates a map that contains a single entry (a key-value
pair).</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-entry" id="function-entry"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :entry function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">entry</code>(</td>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-entry"><code>map:entry</code></a> returns a new
<a title="map" class="termref" href="#dt-map">map</a> which
contains a single entry. The key of the entry in the new map is
<code>$key</code>, and its associated value is
<code>$value</code>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function <code>map:entry</code> is intended primarily for
use in conjunction with the function <code>map:new</code>. For
example, a map containing seven entries may be constructed like
this:</p>
<div class="exampleInner">
<pre>
map:new((
   map:entry("Su", "Sunday"),
   map:entry("Mo", "Monday"),
   map:entry("Tu", "Tuesday"),
   map:entry("We", "Wednesday"),
   map:entry("Th", "Thursday"),
   map:entry("Fr", "Friday"),
   map:entry("Sa", "Saturday")
   ))
</pre></div>
<p>Unlike the map expression (<code>{...}</code>), this technique
can be used to construct a map with a variable number of entries,
for example:</p>
<div class="exampleInner">
<pre>
map:new(for $b in //book return map:entry($b/isbn, $b))
</pre></div>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:entry("M", "Monday")</code> returns
<code>{"M":"Monday"}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-remove" id="func-map-remove"></a>21.1.2.6
<a href="#func-map-remove" style=
"text-decoration: none">map:remove</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Constructs a new map by removing an entry from an existing
map</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-remove" id="function-remove"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :remove function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">remove</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-remove"><code>map:remove</code></a> returns a new
<a title="map" class="termref" href="#dt-map">map</a>. The entries
in the new map correspond to the entries of <code>$map</code>,
excluding any entry whose key is <span>the <a title="same key"
class="termref" href="#dt-same-key">same key</a> as</span>
<code>$key</code>.</p>
<p>No failure occurs if the input map contains no entry with the
supplied key; the input map is returned unchanged</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:remove($week, 4)</code> returns
<code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
5:"Freitag", 6:"Samstag"}</code>.</p>
<p>The expression <code>map:remove($week, 23)</code> returns
<code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-for-each-entry" id=
"func-map-for-each-entry"></a>21.1.2.7 <a href=
"#func-map-for-each-entry" style=
"text-decoration: none">map:for-each-entry</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Applies a supplied function to every entry in a map, returning
the concatenation of the results.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-for-each-entry" id=
"function-for-each-entry"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :for-each-entry function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">for-each-entry</code>(</td>
<td valign="baseline"><code class="arg">$input</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$action</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">function($key as
xs:anyAtomicType, $value as item()*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-for-each-entry"><code>map:for-each-entry</code></a>
takes any <a title="map" class="termref" href="#dt-map">map</a> as
its <code>$input</code> argument and applies the supplied function
to each entry in the map, in <a title="" class="termref" href=
"#">implementation-dependent</a> order; the result is the sequence
obtained by concatenating the results of these function calls.</p>
<p>The function supplied as <code>$action</code> takes two
arguments. It is called supplying the key of the map entry as the
first argument, and the associated value as the second
argument.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:for-each-entry(map{1:"yes", 2:"no"},
function($k, $v){$k})</code> returns some permutation of
<code>(1,2)</code>. <em>(This function call is equivalent to
calling <code>map:keys</code>. The result is in
implementation-dependent order.).</em></p>
<p>The expression
<code>distinct-values(map:for-each-entry(map{1:"yes", 2:"no"},
function($k, $v){$v})</code> returns some permutation of
<code>("yes", "no")</code>. <em>(This function call returns the
distinct values present in the map, in implementation-dependent
order.).</em></p>
<p>The expression <code>map:new(map:for-each-entry(map{"a":1,
"b":2}, function($k, $v){map:entry($k, $v+1)})</code> returns
<code>map{"a":2, "b":3}</code>. <em>(This function call returns a
map with the same keys as the input map, with the value of each
entry increased by one.).</em></p>
<div class="example">
<div class="exampleHeader"><a name="d7e54116" id=
"d7e54116"></a>Example: Converting a Map to an Element Node</div>
<p>This example converts the entries in a map to attributes on a
newly constructed element node.</p>
<div class="exampleInner">
<pre>
   &lt;xsl:variable name="dimensions" 
                 select="map{'height': 3, 'width': 4, 'depth': 5}"/&gt;
   
   &lt;xsl:function name="f:make-attribute" as="attribute()"&gt;
     &lt;xsl:param name="key" as="xs:string"/&gt;
     &lt;xsl:param name="value" as="xs:anyAtomicType"/&gt;
     &lt;xsl:attribute name="{$key}" select="string($value)"/&gt;
   &lt;/xsl:function&gt;
   
   &lt;xsl:template name="convert"&gt;
     &lt;box&gt;
       &lt;xsl:sequence select="map:for-each-entry(
                               $dimensions, f:make-attribute#2)"/&gt;
     &lt;/box&gt;
   &lt;/xsl:template&gt;  
   
</pre></div>
<p>The result is the element <code>&lt;box height="3" width="4"
depth="5"/&gt;</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-collation-key" id=
"func-collation-key"></a>21.1.2.8 <a href="#func-collation-key"
style="text-decoration: none">fn:collation-key</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Given a key value and a collation, generates an internal value
with the property that the internal value is the same for any two
keys that compare equal under the given collation.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-collation-key" id=
"function-collation-key"></a></p>
<div class="proto"><code class=
"function">collation-key</code>(<code class=
"arg">$key</code><code class="as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :collation-key function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">collation-key</code>(</td>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$collation</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>Calling the one-argument version of this function is equivalent
to calling the two-argument version supplying the default collation
as the second argument.</p>
<p>The function returns an <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> value with
the property that <code>collation-key($K1, $C) eq
collation-key($K2, $C)</code> if and only if <code>compare($K1,
$K2, $C) = 0</code>.</p>
<p>If the collation URI is a relative reference, it is resolved
against the static base URI.</p>
<p>An implementation is free to generate a collation key in any
convenient way provided that it always generates the same collation
key for two strings that are equal under the collation, and
different collation keys for strings that are not equal. This holds
only within a single <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>; an implementation is under
no obligation to generate the same collation keys during a
subsequent unrelated query or transformation.</p>
<p>It is possible to define collations that do not have the ability
to generate collation keys. Supplying such a collation will cause
the function to fail. The ability to generate collation keys is an
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> property of
the collation.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>An error is raised <a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOCH0004" title=
"FOCH0004"><span class="error">[ERR FOCH0004]</span></a>
<sup><small>FO30</small></sup> if the specified collation does not
support the generation of collation keys.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function is provided primarily for use with maps. If a map
is required where codepoint equality is inappropriate for comparing
keys, then a common technique is to normalize the key value so that
equality matching becomes feasible. There are many ways keys can be
normalized, for example by use of functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-upper-case"><code>upper-case</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-lower-case"><code>lower-case</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup>, or
<code>normalize-unicode</code>, but this function provides a way of
normalizing them according to the rules of a specified collation.
For example, if the collation ignores accents, then the function
will generate the same collation key for two input strings that
differ only in their use of accents.</p>
<p>The result of the function can be of any atomic type.</p>
<p>For collations based on the Unicode Collation Algorithm, an
algorithm for computing collation keys is provided in <a href=
"#UNICODE-TR10">[UNICODE TR10]</a>. This algorithm generates binary
collation keys, which might be materialized as a value of type
<code>xs:hexBinary</code> or <code>xs:base64Binary</code>.
Implementations are <span class="verb">not required</span> to use
this algorithm.</p>
<p>This specification does not mandate that collation keys should
retain ordering. This is partly because the primary use case is for
maps, where only equality comparisons are required, and partly to
allow the use of binary data types (which are currently unordered
types) for the result. The specification may be revised in a future
release to specify that ordering is preserved.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$C</code> :=</p>
<div class="exampleInner">
<pre>
"http://www.w3.org/2005/xpath-functions/collations/UCA?strength=primary"
</pre></div>
<p>The expression <code>map:new((map{collation-key("A", $C):1},
map{collation-key("a", $C):2}))(collation-key("A", $C))</code>
returns <code>2</code>. <em>(Given that the keys of the two entries
are equal under the rules of the chosen collation, only one of the
entries can appear in the result; the one that is chosen is the one
from the last map in the input sequence. ).</em></p>
<p>The expression <code>let $M : map{collation-key("A", $C):1,
collation-key("B", $C):2} return $M(collation-key("a", $C))</code>
returns <code>1</code>. <em>(The strings "A" and "a" have the same
collation key under this collation.).</em></p>
<p>As the above examples illustrate, it is important that when the
<code>collation-key</code> function is used to add entries to a
map, then it must also be used when retrieving entries from the
map. This process can be made less error-prone by encapsulating the
map within a function: <code>function($k) {$M(collation-key($k,
$collation)}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-deep-equal" id="func-deep-equal"></a>21.1.2.10
<a href="#func-deep-equal" style=
"text-decoration: none">fn:deep-equal</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>This function assesses whether two sequences are deep-equal to
each other. The function as described here extends the definition
of the XPath 3.0 <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
to explain how it should handle maps; it is intended to replace the
existing <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function at some stage in the future.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-deep-equal" id="function-deep-equal"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :deep-equal function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">deep-equal</code>(</td>
<td valign="baseline"><code class="arg">$parameter1</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$parameter2</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :deep-equal function">
<tr>
<td valign="baseline" rowspan="3"><code class=
"function">deep-equal</code>(</td>
<td valign="baseline"><code class="arg">$parameter1</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$parameter2</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$collation</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function delivers the same result as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
except when (at some level of recursion) it is necessary to compare
two function items. In the case of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>,
comparing two function items raises a dynamic error. In the case of
this function, two function items that are both maps are compared
as follows.</p>
<p>If two items <code>$i1</code> and <code>$i2</code> to be
compared are both <a title="map" class="termref" href=
"#dt-map">maps</a>, the result is <code>true</code> if and only if
all the following conditions apply:</p>
<ol class="enumar">
<li>
<p>Both maps have the same number of entries.</p>
</li>
<li>
<p>For every entry in the first map, there is an entry in the
second map that:</p>
<ol class="enumla">
<li>
<p>has the <a title="same key" class="termref" href=
"#dt-same-key">same key</a> (note that the collation is not used
when comparing keys), and</p>
</li>
<li>
<p>has the same associated value (compared using the
<code>fn:deep-equal</code> function, under the collation supplied
in the original call to <code>fn:deep-equal</code>).</p>
</li>
</ol>
</li>
</ol>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>An error is raised <a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOTY0015" title=
"FOTY0015"><span class="error">[ERR FOTY0015]</span></a>
<sup><small>FO30</small></sup> if either input sequence contains a
function item <span>that is not a map.</span></p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>fn:deep-equal(map{}, map{})</code> returns
<code>true()</code>.</p>
<p>The expression <code>fn:deep-equal(map{"a":1, "b":2}, map{"b":2,
"a":1.0})</code> returns <code>true()</code>.</p>
<p>The expression <code>fn:deep-equal(map{"a":xs:double('NaN')},
map{"a":xs:float('NaN')})</code> returns <code>true()</code>.</p>
<p>let <code>$at</code> :=</p>
<div class="exampleInner">
<pre>
&lt;attendees&gt;
  &lt;name last='Parker' first='Peter'/&gt;
  &lt;name last='Barker' first='Bob'/&gt;
  &lt;name first='Peter' last='Parker'/&gt;
&lt;/attendees&gt;
</pre></div>
<p>The expression <code>fn:deep-equal($at, $at/*)</code> returns
<code>false()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1],
$at/name[2])</code> returns <code>false()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1],
$at/name[3])</code> returns <code>true()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1], 'Peter
Parker')</code> returns <code>false()</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="div3">
<h4><a name="map-instructions" id="map-instructions"></a>21.1.3
<a href="#map-instructions" style="text-decoration: none">Map
Instructions</a></h4>
<p>Two instructions are added to XSLT to facilitate the
construction of maps.</p>
<p class="element-syntax"><a name="element-map" id=
"element-map"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:map&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map&gt;</code></p>
<p>The instruction <a href="#element-map"><code>xsl:map</code></a>
constructs and returns a new map.</p>
<p>The contained sequence constructor <span class=
"verb">must</span> evaluate to a sequence of maps: call this
<code>$maps</code>.</p>
<p>The result of the instruction is then given by the XPath
expression:</p>
<div class="exampleInner">
<pre>
   
let $keys := Smaps!map:keys(.)
return if (count($keys) = count(distinct-values($keys)))
       then map:new($maps)                        
       else error()
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Informally: if there are duplicate keys among the sequence of
maps, a dynamic error occurs. Otherwise, the resulting map contains
the union of the map entries from the supplied sequence of
maps.</p>
</div>
<p><a name="err-XTDE3365" id="err-XTDE3365"><span class=
"error">[ERR XTDE3365]</span></a> A <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> occurs if the
set of keys in the maps resulting from evaluating the sequence
constructor contains duplicates.</p>
<p>There is no requirement that the supplied input maps should have
the same or compatible types. The type of a map (for example
<code>map(xs:integer, xs:string)</code>) is descriptive of the
entries it currently contains, but is not a constraint on how the
map may be combined with other maps.</p>
<p><a name="err-XTTE3375" id="err-XTTE3375"><span class=
"error">[ERR XTTE3375]</span></a> A type error occurs if the result
of evaluating the sequence constructor is not an instance of the
required type <code>map(*)*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the effect of this rule is that the sequence
constructor contained in the <a href=
"#element-map"><code>xsl:map</code></a> instruction is severely
constrained: it doesn't make sense, for example, for it to contain
instructions such as <a href=
"#element-element"><code>xsl:element</code></a> that create new
nodes. As with other type errors, processors are free to signal the
error statically if they are able to determine that the sequence
constructor would always fail when evaluated.</p>
</div>
<p class="element-syntax"><a name="element-map-entry" id=
"element-map-entry"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:map-entry<br />
&#160;&#160;<b>key</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map-entry&gt;</code></p>
<p>The instruction <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> constructs and
returns a singleton map: that is, a map which contains one key and
one value. Such a map is primarily used as a building block when
constructing maps using the <a href=
"#element-map"><code>xsl:map</code></a> instruction.</p>
<p>The <code>select</code> attribute and the contained sequence
constructor are mutually exclusive: if a <code>select</code>
attribute is present, then the content <span class=
"verb">must</span> be empty except optionally for <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions.</p>
<p><a name="err-XTSE3280" id="err-XTSE3280"><span class=
"error">[ERR XTSE3280]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> element is
present unless the element has has no children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
<p>The key of the entry in the new map is the value obtained by
evaluating the expression in the <code>key</code> attribute,
converted to the required type <code>xs:anyAtomicType</code> by
applying the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>.
If the supplied key (after conversion) is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:string</code>.</p>
<p>The associated value is the value obtained by evaluating the
expression in the <code>select</code> attribute, or the contained
sequence constructor, with no conversion. If there is no
<code>select</code> attribute and the sequence constructor is
empty, the associated value is the empty sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e54626" id=
"d7e54626"></a>Example: Using XSLT instructions to create a fixed
map</div>
<p>The following example binds a variable to a map whose content is
statically known:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e54634" id=
"d7e54634"></a>Example: Using XSLT instructions to create a
computed map</div>
<p>The following example binds a variable to a map acting as an
index into a source document:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="map-expressions" id="map-expressions"></a>21.1.4
<a href="#map-expressions" style="text-decoration: none">Map
Expressions</a></h4>
<p>A new kind of expression is added to the syntax of XPath.</p>
<p>The syntax of <a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-PrimaryExpr">PrimaryExpr</a><sup><small>XP30</small></sup>
is extended to permit <code>MapExpr</code> as an additional
alternative.</p>
<h5><a name="d7e54654" id="d7e54654"></a>MapExpr</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="NT-PrimaryExpr" id=
"NT-PrimaryExpr"></a>[52]&#160;&#160;&#160;</td>
<td><code>PrimaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>Literal | VarRef | ParenthesizedExpr | ContextItemExpr |
FunctionCall | FunctionItemExpr<br />
| MapExpr</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-MapExpr" id=
"NT-MapExpr"></a>[202]&#160;&#160;&#160;</td>
<td><code>MapExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map{" (KeyExpr ":" ValueExpr ("," KeyExpr ":" ValueExpr
)*)? "}"</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-KeyExpr" id=
"NT-KeyExpr"></a>[203]&#160;&#160;&#160;</td>
<td><code>KeyExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-ExprSingle">ExprSingle</a><sup><small>XP30</small></sup></code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-ValueExpr" id=
"NT-ValueExpr"></a>[204]&#160;&#160;&#160;</td>
<td><code>ValueExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-ExprSingle">ExprSingle</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some circumstances, it is necessary to include whitespace
before or after the colon to ensure that this grammar is correctly
parsed; this arises for example when the <code>KeyExpr</code> ends
with a name and the <code>ValueExpr</code> starts with a name.</p>
</div>
<p>The value of the expression is a map whose entries correspond to
the key-value pairs obtained by evaluating the successive
<code>KeyExpr</code> and <code>ValueExpr</code> expressions.</p>
<p>Each <code>KeyExpr</code> expression is evaluated and atomized;
a dynamic error occurs if the result is not a single atomic value.
If the key value is of type <code>xs:untypedAtomic</code> it is
converted to <code>xs:string</code>. The associated value is the
result of evaluating the corresponding <code>ValueExpr</code>. If
two or more entries have the <span><a title="same key" class=
"termref" href="#dt-same-key">same key</a></span> then <span>a
dynamic error occurs <span class="error">[see <a href=
"#err-XTDE3365">ERR XTDE3365</a>]</span></span>.</p>
<p>For example, the following expression constructs a map with
seven entries:</p>
<div class="exampleInner">
<pre>
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Unlike the <a href="#func-map-new"><code>map:new</code></a>
function, the number of entries in a map that is constructed using
a map expression is known statically.</p>
</div>
</div>
<div class="div3">
<h4><a name="maps-streaming" id="maps-streaming"></a>21.1.5
<a href="#maps-streaming" style="text-decoration: none">Maps and
Streaming</a></h4>
<p>Maps have many uses, but their introduction to XSLT 3.0 was
strongly motivated by streaming use cases. In essence, when a
source document is processed in streaming mode, data that is
encountered in the course of processing may need to be retained in
variables for subsequent use, because the nodes cannot be
revisited. This creates a need for a flexible data structure to
accommodate such temporary data, and maps were designed to fulfil
this need.</p>
<p>The <a href="#element-map"><code>xsl:map</code></a> instruction,
and the XPath <code>MapExpr</code> construct, are exceptions to the
general rule that during streaming, only one downward selection
(one consuming subexpression) is permitted. They share this
characteristic with <a href=
"#element-fork"><code>xsl:fork</code></a>. As with <a href=
"#element-fork"><code>xsl:fork</code></a>, a streaming processor is
expected to be able to construct the map during a single pass of
the streamed input document, which may require multiple expressions
to be evaluated in parallel.</p>
<p>In the case of the <a href=
"#element-map"><code>xsl:map</code></a> instruction, this applies
only in the case where the instruction consists exclusively of
<a href="#element-map-entry"><code>xsl:map-entry</code></a> (and
<a href="#element-fallback"><code>xsl:fallback</code></a>)
children, and not in more complex cases where the map entries are
constructed dynamically (for example using a control flow
implemented using <a href=
"#element-choose"><code>xsl:choose</code></a>, <a href=
"#element-for-each"><code>xsl:for-each</code></a>, or <a href=
"#element-call-template"><code>xsl:call-template</code></a>).</p>
<p>For example, the following XPath expression is streamable,
despite making two downward selections:</p>
<div class="exampleInner">
<pre>
let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} 
return ($m('price') - $m('discount'))
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>Because the <code>return</code> clause is motionless, the
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
<code>let</code> expression is the sweep of the map expression (the
expression in curly braces).</p>
</li>
<li>
<p>The sweep of a map expression is the maximum sweep of its
key/value pairs.</p>
</li>
<li>
<p>For both key/value pairs, the key is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and the value
is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The expression carefully atomizes both values, because retaining
references to streamed nodes in a variable is not permitted.</p>
</li>
<li>
<p>Therefore the map expression, and hence the expression as a
whole, is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>See also: <a href=
"#streamability-of-map-expressions"><i>19.8.7.15 Streamability of
map expressions</i></a>, <a href=
"#streamability-xsl-map"><i>19.8.4.22 Streamability of
xsl:map</i></a>, <a href=
"#streamability-xsl-map-entry"><i>19.8.4.23 Streamability of
xsl:map-entry</i></a></p>
</div>
<div class="div3">
<h4><a name="map-examples" id="map-examples"></a>21.1.6 <a href=
"#map-examples" style="text-decoration: none">Examples using
Maps</a></h4>
<p>This section gives some examples of where maps can be
useful.</p>
<div class="example">
<div class="exampleHeader"><a name="maps-with-iterate" id=
"maps-with-iterate"></a>Example: Using Maps with xsl:iterate</div>
<p>This example uses maps in conjunction with the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction to find
the highest-earning employee in each department, in a single
streaming pass of an input document containing employee
records.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map:new()"/&gt;
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:new($highest-earners, 
                                      map:entry($this/department, $this))"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="example-complex-numbers" id=
"example-complex-numbers"></a>Example: Using Maps to Implement
Complex Numbers</div>
<p>A complex number might be represented as a map with two entries,
the keys being the <code>xs:boolean</code> value <code>true</code>
for the real part, and the <code>xs:boolean</code> value
<code>false</code> for the imaginary part. A library for
manipulation of complex numbers might include functions such as the
following:</p>
<div class="exampleInner">
<pre>

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ $REAL : $real, $IMAG : $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="map-as-index" id=
"map-as-index"></a>Example: Using a Map as an Index</div>
<p>Given a set of <code>book</code> elements, it is possible to
construct an index in the form of a map allowing the books to be
retrieved by ISBN number.</p>
<p>Assume the book elements have the form:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;
</pre></div>
<p>An index may be constructed as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:new(for $b in //book return map{$b/isbn : $b})"/&gt;
</pre></div>
<p>This index may then be used to retrieve the book for a given
ISBN using either of the expressions <code>map:get($isbn-index,
"0470192747")</code> or <code>$isbn-index("0470192747")</code>.</p>
<p>In this simple form, this replicates the functionality available
using <a href="#element-key"><code>xsl:key</code></a> and the
<a href="#func-key"><code>key</code></a> function. However, it also
provides capabilities not directly available using the <a href=
"#func-key"><code>key</code></a> function: for example, the index
can include <code>book</code> elements in multiple source
documents. It also allows processing of all the books using a
construct such as <code>&lt;xsl:for-each
select="map:keys($isbn-index)"&gt;</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="map-as-class" id=
"map-as-class"></a>Example: A Map containing Named Functions</div>
<p>As in JavaScript, a map whose keys are strings and whose
associated values are function items can be used in a similar way
to a class in object-oriented programming languages.</p>
<p>Suppose an application needs to handle customer order
information that may arrive in three different formats, with
different hierarchic arrangements:</p>
<ol class="enumar">
<li>
<p>Flat structure:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;
</pre></div>
</li>
<li>
<p>Orders within customer elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
</pre></div>
</li>
<li>
<p>Orders within product elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;
</pre></div>
</li>
</ol>
<p>An application can isolate itself from these differences by
defining a set of functions to navigate the relationships between
customers, orders, and products: <code>orders-for-customer</code>,
<code>orders-for-product</code>, <code>customer-for-order</code>,
<code>product-for-order</code>. These functions can be implemented
in different ways for the three different input formats. For
example, with the first format the implementation might be:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map{
            'orders-for-customer' : 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' : 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' : 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' : 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;
</pre></div>
<p>Having established which input format is in use, the application
can bind the appropriate implementation of these functions to a
variable such as <code>$input-navigator</code>, and can then
process the input using XPath expressions such as the following,
which selects all products for which there is no order:
<code>//product[empty($input-navigator("orders-for-product")(.))]</code></p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="json" id="json"></a>21.2 <a href="#json" style=
"text-decoration: none">Processing JSON Data</a></h3>
<p>JSON is a popular format for exchange of structured data on the
web: it is specified in <a href="#rfc4627">[RFC 4627]</a> and in
<span><a href="#ECMA-404">[ECMA-404]</a></span>. This section
describes facilities allowing JSON data to be processed using
XSLT.</p>
<div class="div3">
<h4><a name="json-to-xml-mapping" id=
"json-to-xml-mapping"></a>21.2.1 <a href="#json-to-xml-mapping"
style="text-decoration: none">XML Representation of JSON</a></h4>
<p>This specification defines a mapping from JSON data to XML
(specifically, to XDM instances). A function <a href=
"#func-json-to-xml"><code>json-to-xml</code></a> is provided to
take a JSON string as input and convert it to the XML
representation. Two stylesheet modules are provided to perform the
reverse transformation: one produces JSON in compact linear form,
the other in indented form suitable for display, editing, or
printing.</p>
<p>The XML representation is designed to be capable of representing
any valid JSON text other than one that uses characters which are
not valid in XML. The transformation is lossless: that is, distinct
JSON texts convert to distinct XML representations. When converting
JSON to XML, options are provided to reject unsupported characters,
to replace them with a substitute character, or to leave them in
backslash-escaped form.</p>
<p>The following example demonstrates the correspondence of a JSON
text and the corresponding XML representation.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e54974" id=
"d7e54974"></a>Example: A JSON Text and its XML
Representation</div>
<p>Consider the following JSON text:</p>
<div class="exampleInner">
<pre>
  { "first name" : "John",
    "last name" : "Smith",
    "retired" : true,
    "address" :  {
       "street address" : "21 2nd Street",
       "city" : "New York",
       "state" : "NY",
       "postal code" : 10021 
    }, 
    "phone numbers" :  [ 
       { "home": "212 732-1234", 
         "fax": "646 123-4567"
       }
     ],
    "date of birth" : null
  }
               
</pre></div>
<p>The XML representation of this text is as follows. Whitespace is
included in the XML representation for purposes of illustration,
and is ignored by the stylesheets that convert XML to JSON, but it
will not be present in the output of the <a href=
"#func-json-to-xml"><code>json-to-xml</code></a> function.</p>
<div class="exampleInner">
<pre>
  &lt;map xmlns="http://www.w3.org/2013/XSL/json"&gt;
    &lt;string key='first name'&gt;John&lt;/string&gt;
    &lt;string key='last name'&gt;Smith&lt;/string&gt;
    &lt;boolean key="retired"&gt;true&lt;/boolean&gt;
    &lt;map key='address'&gt;
        &lt;string key='street address'&gt;21 2nd Street&lt;/string&gt;
        &lt;string key='city'&gt;New York&lt;/string&gt;
        &lt;string key='state'&gt;NY&lt;/string&gt;
        &lt;number key='postal code'&gt;10021&lt;/number&gt;        
    &lt;/map&gt;
    &lt;array key='phone numbers'&gt;
        &lt;map&gt;
            &lt;string key="home"&gt;212 732-1234&lt;/string&gt;
            &lt;string key="fax"&gt;646 123-4567&lt;/string&gt;
        &lt;/map&gt;    
    &lt;/array&gt;
    &lt;null key="date of birth"/&gt;
&lt;/map&gt;                
                  
               
</pre></div>
</div>
<p>An XSD 1.0 schema for the XML representation is provided in
<a href="#schema-for-json"><i>B.1 Schema for the XML Representation
of JSON</i></a>. It is not necessary to import this schema (using
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a>) unless
the stylesheet makes explicit reference to the components defined
in the schema. If the stylesheet does import a schema for the
namespace <code>http://www.w3.org/2013/XSL/json</code>, then:</p>
<ol class="enumar">
<li>
<p>The processor (if it is schema-aware) <span class=
"verb">must</span> recognize an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration for this namespace, whether or not the
<code>schema-location</code> is supplied.</p>
</li>
<li>
<p>If a <code>schema-location</code> is provided, then the schema
document at that location <span class="verb">must</span> be
equivalent to the schema document at <a href=
"#schema-for-json"><i>B.1 Schema for the XML Representation of
JSON</i></a>; the effect if it is not is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a></p>
</li>
</ol>
<p>The rules governing the mapping from JSON to XML are as follows.
In these rules, the term "an element named N" is to be interpreted
as meaning "an element node whose local name is N and whose
namespace URI is <code>http://www.w3.org/2013/XSL/json</code>"</p>
<ol class="enumar">
<li>
<p>The JSON value <code>null</code> is represented by an element
named <code>null</code>, with empty content.</p>
</li>
<li>
<p>The JSON values <code>true</code> and <code>false</code> are
represented by an element named <code>boolean</code>, with content
conforming to the type <code>xs:boolean</code>.</p>
</li>
<li>
<p>A JSON number is represented by an element named
<code>number</code>, with content conforming to the type
<code>xs:double</code>, with the additional restriction that the
value must not be positive or negative infinity, nor
<code>NaN</code>.</p>
</li>
<li>
<p>A JSON string is represented by an element named
<code>string</code>, with content conforming to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>A JSON array is represented by an element named
<code>array</code>. The content is a sequence of child elements
representing the members of the array in order, each such element
being the representation of the array member obtained by applying
these rules recursively.</p>
</li>
<li>
<p>A JSON object is represented by an element named
<code>map</code>. The content is a sequence of child elements each
of which represents one of the name/value pairs in the object. The
representation of the name/value pair <var>N:V</var> is obtained by
taking the element that represents the value <var>V</var> (by
applying these rules recursively) and adding an attribute with name
<code>key</code> (in no namespace), whose value is <var>N</var> as
an instance of <code>xs:string</code>.</p>
</li>
</ol>
<p>The attribute <code>escaped="true"</code> may be specified on a
<code>string</code> element to indicate that the string value
contains backslash-escaped characters that are to be interpreted
according to the JSON rules. The attribute
<code>escaped-key="true"</code> may be specified on any element
with a <code>key</code> attribute to indicate that the key value
contains backslash-escaped characters that are to be interpreted
according to the JSON rules. Both attributes have the default value
<code>false</code>.</p>
<p>Although the order of entries in a JSON object is generally
considered to have no significance, the function
<code>json-to-xml</code> and the stylesheets that perform the
reverse transformation both retain order.</p>
<p>The XDM representation of a JSON value may either be untyped
(all elements annotated as <code>xs:untyped</code>, attributes as
<code>xs:untypedAtomic</code>), or it may be typed. If it is typed,
then it <span class="verb">must</span> have the type annotations
obtained by validating the untyped representation against the
schema given in <a href="#schema-for-json"><i>B.1 Schema for the
XML Representation of JSON</i></a>. If it is untyped, then it
<span class="verb">must</span> be an XDM instance such that
validation against this schema would succeed.</p>
</div>
<div class="div3">
<h4><a name="func-json-to-xml" id="func-json-to-xml"></a>21.2.2
<a href="#func-json-to-xml" style=
"text-decoration: none">fn:json-to-xml</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Parses a string supplied in the form of a JSON text, returning
the results in the form of an XML <span>document node</span>.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-json-to-xml" id=
"function-json-to-xml"></a></p>
<div class="proto"><code class=
"function">json-to-xml</code>(<code class=
"arg">$json-text</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">document-node()</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :json-to-xml function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">json-to-xml</code>(</td>
<td valign="baseline"><code class="arg">$json-text</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$options</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">document-node()</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on static base uri.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The effect of the one-argument form of this function is the same
as calling the two-argument form with an empty map as the value of
the <code>$options</code> argument.</p>
<p>The first argument is a JSON-text (see below) in the form of a
string. The function parses this string to return an XDM node.</p>
<p>The <code>$options</code> argument can be used to control the
way in which the parsing takes place. The value of the argument is
a map. The options defined in this specification have keys that are
strings. The effect of any map entries whose keys are not defined
in this specification is implementation-defined;
implementation-defined options <span class="verb">should</span> use
QNames as keys. Implementations <span class="verb">must</span>
ignore any entries in the map whose keys are not defined in this
specification, unless the key has a specific <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
meaning.</p>
<p>The entries that may appear in the <code>$options</code> map are
as follows. The keys are <code>xs:string</code> values:</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Key</th>
<th colspan="1" align="left" valign="top">Value</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="4" align="left" valign="top"><code>spec</code></td>
<td colspan="2" align="left" valign="top">Determines the
specification of JSON that is to be used. The value <span class=
"verb">must</span> be a string; the effect of supplying any value
other than "<code>RFC4627"</code>,
<span><code>"ECMA-404"</code></span>, or <code>"liberal"</code> is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
default is <code>"RFC4627"</code>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>"RFC4627"</code></td>
<td align="left" valign="top">The input must conform to <a href=
"#rfc4627">[RFC 4627]</a>, with no deviations from the grammar
permitted.</td>
</tr>
<tr>
<td align="left" valign="top">
<span><code>"ECMA-404"</code></span></td>
<td align="left" valign="top">The input must conform to the
specification in <span><code>"ECMA-404"</code></span>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>"liberal"</code></td>
<td align="left" valign="top">Indicates any implementation-defined
superset of RFC4627 (or equivalently, an implementation that
recovers from some or all errors in the input).</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">
<code>validate</code></td>
<td colspan="2" align="left" valign="top">If the
<code>$options</code> map contains an entry with the key
<code>"validate"</code>, then the value <span class=
"verb">must</span> be an <code>xs:boolean</code>. The default is
<code>true</code> for a schema-aware processor, <code>false</code>
for a non-schema-aware processor. If the value <code>true</code> is
supplied and the processor is not schema-aware, a dynamic error
results <span class="error">[see <a href="#err-XTDE3245">ERR
XTDE3245</a>]</span>. It is not necessary that the containing
stylesheet should import the relevant schema.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">Indicates that the resulting XDM
instance must be typed; that is, the element and attribute nodes
must carry the type annotations that result from validation against
the schema given at <a href="#schema-for-json"><i>B.1 Schema for
the XML Representation of JSON</i></a>, or against an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> schema if
the <code>spec</code> option has the value
<code>liberal</code>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">Indicates that the the XDM instance
must be untyped.</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">
<code>unescape</code></td>
<td colspan="2" align="left" valign="top">If the
<code>$options</code> map contains an entry with the key
<code>"unescape"</code>, then the value <span class=
"verb">must</span> be an <code>xs:boolean</code>. The value
determines whether escape sequences (marked by a backslash) in the
input are expanded. The default is <code>true</code>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">In the result, any
<code>string</code> element whose string value contains a backslash
character must have the attribute value
<code>escaped="true"</code>, and any element that contains a
<code>key</code> attribute whose string value contains a backslash
character must have the attribute <code>escaped-key="true"</code>.
(The value of the <code>escaped</code> and <code>key-escaped</code>
attributes is immaterial when there is no backslash present, and it
is never necessary to include either attribute when the value is
<code>false</code>.) The escaped representation in this case
<span class="verb">may</span> be used for any character, whether or
not it was escaped in the original JSON input.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">The attributes <code>escaped</code>
and <code>escaped-key</code> will never be present with the value
<code>true</code>. If the input contains escape sequences
representing characters or codepoints that are not valid characters
in the version of XML supported by the implementation, <span>such
characters are replaced by the Unicode replacement character
(xFFFD), or as described in the next paragraph</span>.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">
<code>fallback</code></td>
<td colspan="2" align="left" valign="top">Provides a function which
is called when an invalid character is encountered.</td>
</tr>
<tr>
<td align="left" valign="top">Function with signature
<code>function(xs:string) as xs:string</code></td>
<td align="left" valign="top">When an invalid character is
encountered this function is called supplying the escaped form of
the character as the argument. The function returns a string which
is inserted into the result in place of the invalid character. The
function also has the option of raising a dynamic error.</td>
</tr>
</tbody>
</table>
<p>The various structures that can occur in JSON are transformed
recursively to XDM values according to the rules given in <a href=
"#json-to-xml-mapping"><i>21.2.1 XML Representation of
JSON</i></a>.</p>
<p>The function returns <span>a document node, whose only child
is</span> the element node representing the outermost construct in
the JSON text.</p>
<p>The function is not <a title="" class="termref" href="#"></a>:
that is, if the function is called twice with the same arguments,
it is <a title="" class="termref" href=
"#">implementation-dependent</a> whether the same node is returned
on both occasions.</p>
<p>The base URI of the returned document node is taken from the
static base URI of the function call.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE3240" id="err-XTDE3240"><span class=
"error">[ERR XTDE3240]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$input</code> does not conform to the JSON grammar,
as selected using the explicit or implicit <code>spec</code>
option.</p>
<p><a name="err-XTDE3245" id="err-XTDE3245"><span class=
"error">[ERR XTDE3245]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of the <code>validate</code> option is <code>true</code> and
the processor is not schema-aware.</p>
<p><a name="err-XTDE3250" id="err-XTDE3250"><span class=
"error">[ERR XTDE3250]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$input</code> contains an escaped representation of
a character (or codepoint) that is not a valid character in the
version of XML supported by the implementation, unless the
<code>unescape</code> option is set to false.</p>
<p><a name="err-XTDE3260" id="err-XTDE3260"><span class=
"error">[ERR XTDE3260]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$options</code> includes an entry whose key is
"spec" and whose value is not a single <code>xs:string</code>, or
an entry whose key is "validate" or "unescape" and whose value is
not a single <code>xs:boolean</code>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>To read a JSON file, this function can be used in conjunction
with the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>
unparsed-text</code></a><sup><small>FO30</small></sup>
function.</p>
<p>ECMA-404 differs from RFC 4627 in two respects: it does not
allow the input to depart from the JSON grammar, but it does allow
the top-level construct in the input to be a string, boolean,
number, or null, rather than requiring an object or array.</p>
<p>Many JSON implementations allow commas to be used after the last
item in an object or array, although the specification does not
permit it. The option <code>spec="liberal"</code> is provided to
allow such deviations from the specification to be accepted. Some
JSON implementations also allow constructors such as <code>new
Date("2000-12-13")</code> to appear as values: specifying
<code>spec="liberal"</code> allows such extensions to be accepted,
but does not guarantee it. If such extensions are accepted, the
resulting value is implementation-defined, and will not necessarily
conform to the schema at <a href="#schema-for-json"><i>B.1 Schema
for the XML Representation of JSON</i></a>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>json-to-xml('{"x": 1, "y":
[3,4,5]}')</code> returns <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;number
key="x"&gt;1&lt;/number&gt; &lt;array key="y"&gt;
&lt;number&gt;3&lt;/number&gt; &lt;number&gt;4&lt;/number&gt;
&lt;number&gt;5&lt;/number&gt; &lt;/array&gt;
&lt;/map&gt;</code>.</p>
<p>The expression <code>json-to-xml('"abcd"', map{'spec':
'RFC4627'})</code> raises error <code>FOJS0001</code>. <em>(This is
an error because RFC4627 requires the outermost construct in JSON
to be an array or object, not a string.).</em></p>
<p>The expression <code>json-to-xml('"abcd"', map{'spec':
'ECMA-404'})</code> returns <code>&lt;string
xmlns="http://www.w3.org/2013/XSL/json"&gt;abcd&lt;/string&gt;</code>.</p>
<p>The expression <code>json-to-xml('{"x": "\\", "y":
"\u0025"}')</code> returns one of the following: <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;string
key="x"&gt;\&lt;/string&gt; &lt;string key="y"&gt;%&lt;/string&gt;
&lt;/map&gt;</code> or <code>map{"x": "\","y": "%"}</code>.</p>
<p>The expression <code>json-to-xml('{"x": "\\", "y": "\u0025"}',
map{'unescape': false()})</code> returns <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;string
escaped="true" key="x"&gt;\\&lt;/string&gt; &lt;string
escaped="true" key="y"&gt;\u0025&lt;/string&gt;
&lt;/map&gt;</code>.</p>
<p>The following example illustrates use of the fallback function
to handle characters that are invalid in XML.</p>
<div class="exampleInner">
<pre>
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:err="http://example.com/ns/errors"
                xmlns:f="http://example.com/ns/functions"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                exclude-result-prefixes="xs err f"
                version="3.0"&gt;

&lt;xsl:template match="someElement"&gt;
  &lt;xsl:variable name="jsonstr" 
                select="unparsed-text('http://example.com/endpoint')"/&gt;
  &lt;xsl:variable name="options" 
                select="map{'spec':'liberal', 'fallback':f:convert#1}"/&gt;
  &lt;xsl:variable name="json" 
                select="json-to-xml($jsonstr, $options)"/&gt;

  &lt;!-- now do something with that json --&gt;
&lt;/xsl:template&gt;

&lt;xsl:function name="f:convert" as="xs:string"&gt;
  &lt;xsl:param name="char" as="xs:string"/&gt;
    &lt;xsl:variable name="c0chars" select="{
     '\u0000':'[NUL]',
     '\u0001':'[SOH]',
     '\u0002':'[STX]',
     ...
     '\u001E':'[RS]',
     '\u001F':'[US]'}"/&gt;
  &lt;xsl:variable name="replacement" select="$c0chars($char)"/&gt;
  &lt;xsl:sequence select="if (exists($replacement)) then $replacement
      else error(xs:QName('err:invalid-char'), 
           'Error: '||$char||' is not a terminal control char.'))"/&gt;
&lt;/xsl:function&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="xml-to-json" id="xml-to-json"></a>21.2.3 <a href=
"#xml-to-json" style="text-decoration: none">Converting XML to
JSON</a></h4>
<p>Two stylesheets are provided whose effect is to convert the XML
representation of JSON defined in <a href=
"#json-to-xml-mapping"><i>21.2.1 XML Representation of JSON</i></a>
to a string conforming to the JSON grammar. The stylesheets are
listed in <a href="#json-in-xml"><i>B XML Representation of
JSON</i></a>. <span>They are presented as separate packages which
may be incorporated into a user stylesheet using <a href=
"#element-use-package"><code>xsl:use-package</code></a>.</span></p>
<p>The first stylesheet, <code>xml-to-json.xsl</code>, produces a
JSON string containing minimal whitespace. The second,
<code>xml-to-json-indented.xsl</code>, produces a JSON string with
whitespace indentation designed for human legibility.</p>
<p>The stylesheets are designed to be configurable by setting
parameter values or by overriding selected template rules or
functions.</p>
<p>The stylesheets define the punctuation characters of JSON as
parameters which can be overridden. This is intended to allow the
stylesheets to be adapted to produce map literals suitable for use
in other languages (PHP, for example, uses <code>"=&gt;"</code>
rather than <code>":"</code> to separate keys from values). Setting
the punctuation characters can also be used to alter the amount of
whitespace in the result.</p>
<p>The conversion can be effected either by calling the public
function <code>j:xml-to-json</code>, which takes an XML node as its
argument and produces the JSON string as its output, or by applying
templates to the XML node in mode <code>j:xml-to-json</code>: this
delivers a sequence of text nodes, which may be processed for
example using:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="json"&gt;
  &lt;xsl:apply-templates select="$json-as-xml"/&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>or:</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="output.json" method="text"&gt;
  &lt;xsl:apply-templates select="$json-as-xml"/&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>The stylesheets do not validate that the input conforms to the
schema defined at <a href="#schema-for-json"><i>B.1 Schema for the
XML Representation of JSON</i></a>, and the effect of using them
with input that does not conform to this schema is
unpredictable.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="diagnostics" id="diagnostics"></a>22 <a href=
"#diagnostics" style="text-decoration: none">Diagnostics</a></h2>
<div class="div2">
<h3><a name="message" id="message"></a>22.1 <a href="#message"
style="text-decoration: none">Messages</a></h3>
<p class="element-syntax"><a name="element-message" id=
"element-message"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:message<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;terminate? = { "yes" | "no" }<br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:message&gt;</code></p>
<p>The <a href="#element-message"><code>xsl:message</code></a>
instruction sends a message in an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. The
<a href="#element-message"><code>xsl:message</code></a> instruction
causes the creation of a new document, which is typically
serialized and output to an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
destination. The result of the <a href=
"#element-message"><code>xsl:message</code></a> instruction is an
empty sequence.</p>
<p>The content of the message may be specified by using either or
both of the optional <code>select</code> attribute and the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-message"><code>xsl:message</code></a> instruction.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction contains a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
then the sequence obtained by evaluating this sequence constructor
is used to construct the content of the new document node, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction has a <code>select</code> attribute, then the value of
the attribute <span class="verb">must</span> be an XPath
expression. The effect of the <a href=
"#element-message"><code>xsl:message</code></a> instruction is then
the same as if a single <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
this <code>select</code> attribute were added to the start of the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction has no content and no <code>select</code> attribute,
then an empty message is produced.</p>
<p>The tree produced by the <a href=
"#element-message"><code>xsl:message</code></a> instruction is not
technically a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>. The tree has no URI
and processors are not <span class="verb">required</span> to make
the tree accessible to applications.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In many cases, the XML document produced using <a href=
"#element-message"><code>xsl:message</code></a> will consist of a
document node owning a single text node. However, it may contain a
more complex structure.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation might implement <a href=
"#element-message"><code>xsl:message</code></a> by popping up an
alert box or by writing to a log file. Because the order of
execution of instructions is implementation-defined, the order in
which such messages appear is not predictable.</p>
</div>
<p>The <code>terminate</code> attribute is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<p>If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>terminate</code> attribute is <code>yes</code>, then the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
<span>signal a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a></span> after sending the
message. <span>This error may be caught in the same way as any
other dynamic error using <a href=
"#element-catch"><code>xsl:catch</code></a>.</span> The default
value is <code>no</code>. Note that because the order of evaluation
of instructions is <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, this
gives no guarantee that any particular instruction will or will not
be evaluated before processing terminates.</p>
<p>The optional <code>error-code</code> attribute may be used to
indicate the error code associated with the message. This may be
used irrespective of the value of <code>terminate</code>. The error
code is an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>. If no error code is specified, or
if the value is not a valid EQName, the error code will have local
part <code>XTMM9000</code> and namespace URI
<code>http://www.w3.org/2005/xqt-errors</code>. User-defined error
codes <span class="verb">should</span> be in a namespace other than
<code>http://www.w3.org/2005/xqt-errors</code>. When the value of
<code>terminate</code> is <code>yes</code>, the error code may be
matched in an <a href="#element-catch"><code>xsl:catch</code></a>
element to catch the error and cause processing to continue
normally.</p>
<p><a name="err-XTMM9000" id="err-XTMM9000"><span class=
"error">[ERR XTMM9000]</span></a> When a transformation is
terminated by use of <code>xsl:message terminate="yes"</code>, the
effect is the same as when a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> occurs during
the transformation. <span>The default error code is
<code>XTMM9000</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-message"><code>xsl:message</code></a>
instruction.</span></p>
<div class="example">
<div class="exampleHeader"><a name="d7e55837" id=
"d7e55837"></a>Example: Localizing Messages</div>
<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes
an additional input file to the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. For example,
suppose messages for a language <code><var>L</var></code> are
stored in an XML file <code>resources/<var>L</var>.xml</code> in
the form:</p>
<div class="exampleInner">
<pre>
&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</pre></div>
<p>Then a stylesheet could use the following approach to localize
messages:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>Any <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> that occurs while evaluating
the <code>select</code> expression or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and any
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> that occurs while
processing the result, <span>does not cause the transformation to
fail; at worst, it means that no message is output, or that the
only message that is output is one that relates to the error that
occurred.</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An example of such an error is the serialization error that
occurs when processing the instruction <code>&lt;xsl:message
select="@code"/&gt;</code> (on the grounds that free-standing
attributes cannot be serialized). Making such errors recoverable
means that it is implementation-defined whether or not they are
signaled to the user and whether they cause termination of the
transformation. If the processor chooses to recover from the error,
the content of any resulting message is
implementation-dependent.</p>
<p>One possible recovery action is to include a description of the
error in the generated message text.</p>
</div>
</div>
<div class="div2">
<h3><a name="assertions" id="assertions"></a>22.2 <a href=
"#assertions" style="text-decoration: none">Assertions</a></h3>
<p>The <a href="#element-assert"><code>xsl:assert</code></a>
instruction is used to assert that the value of a particular
expression is true; if the value of the expression is false, and
assertions are enabled, then a dynamic error occurs.</p>
<p class="element-syntax"><a name="element-assert" id=
"element-assert"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:assert<br />
&#160;&#160;<b>test</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:assert&gt;</code></p>
<p>By default, assertions are enabled. Checking of assertions may
be disabled in several ways:</p>
<ol class="enumar">
<li>
<p>As with any other instruction, assertions may be disabled by use
of the <code>use-when</code> attribute: see <a href=
"#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a>.</p>
</li>
<li>
<p>An implementation <span class="verb">should</span> provide an
external mechanism to disable assertion checking for the stylesheet
as a whole (either statically or dynamically). The detail of such
mechanisms is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
</li>
</ol>
<p>If assertion checking is enabled, the instruction is evaluated
as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>test</code> attribute is evaluated.
If the effective boolean value of the result is <code>true</code>,
the assertion succeeds, and no further action is taken. If the
effective boolean value is false, or if a dynamic error occurs
during evaluation of the expression, then the assertion fails.</p>
</li>
<li>
<p>If the assertion fails, then the effect of the instruction is
governed by the rules for evaluation of an <a href=
"#element-message"><code>xsl:message</code></a> instruction with
the same <code>select</code> attribute, <code>error-code</code>
attribute, and contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
and with the value <code>terminate="yes"</code>. However, the
default error code if the <code>error-code</code> attribute is
omitted is <code>XTMM9001</code> rather than
<code>XTMM9000</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To the extent that the behavior of <a href=
"#element-message"><code>xsl:message</code></a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>, this rule
does not prevent an implementation treating <a href=
"#element-assert"><code>xsl:assert</code></a> and <a href=
"#element-message"><code>xsl:message</code></a> differently.</p>
</div>
</li>
</ol>
<p><a name="err-XTMM9001" id="err-XTMM9001"><span class=
"error">[ERR XTMM9001]</span></a> When a transformation is
terminated by use of <code>xsl:assert</code>, the effect is the
same as when a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the
transformation. The default error code is <code>XTMM9001</code>;
this may be overridden using the <code>error-code</code> attribute
of the <a href="#element-assert"><code>xsl:assert</code></a>
instruction.</p>
<p>As with any other dynamic error, an error caused by an assertion
failing may be trapped using <a href=
"#element-try"><code>xsl:try</code></a>: see <a href=
"#try-catch"><i>8.3 Try/Catch</i></a>.</p>
<p>The result of the <a href=
"#element-assert"><code>xsl:assert</code></a> instruction is an
empty sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e56026" id=
"d7e56026"></a>Example: Using Assertions with Static
Parameters</div>
<p>The following example shows a stylesheet function that checks
that the value of its supplied argument is in range. The check is
performed only if the <a title="static parameter" class="termref"
href="#dt-static-parameter">static parameter</a>
<code>$DEBUG</code> is set to true.</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations should avoid optimizing <a href=
"#element-assert"><code>xsl:assert</code></a> instructions away. As
a guideline, if the result of a sequence constructor is required by
the transformation, the implementation should ensure that all
<a href="#element-assert"><code>xsl:assert</code></a> instructions
in that sequence constructor are evaluated. Conversely, if the
result of a sequence constructor is not required by the
transformation, its <a href=
"#element-assert"><code>xsl:assert</code></a> instructions should
not be evaluated.</p>
<p>This recommendation is not intended to prevent optimizations
such as lazy evaluation, where evaluation of a sequence constructor
may finish early, as soon as enough information is available to
evaluate the containing instruction.</p>
</div>
<p>An implementation <span class="verb">may</span> provide a user
option allowing a processor to treat assertions as being true
without explicit checking. This option <span class="verb">must
not</span> be enabled by default. If such an option is in force,
the effect of any assertion not being true is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, given the assertion <code>&lt;xsl:assert
test="count(//title)=1"/&gt;</code>, a processor might generate
code for the expression <code>&lt;xsl:value-of
select="//title"/&gt;</code> that stops searching for
<code>title</code> elements after finding the first one. In the
event that the source document contains more than one
<code>title</code>, execution of the stylesheet may fail in
arbitrary ways, or it may produce incorrect output.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="extension" id="extension"></a>23 <a href="#extension"
style="text-decoration: none">Extensibility and Fallback</a></h2>
<p>XSLT allows two kinds of extension, extension instructions and
extension functions.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-instruction" id="dt-extension-instruction" title=
"extension instruction"></a>An <b>extension instruction</b> is an
element within a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> that is in
a namespace (not the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a>) designated as an
extension namespace.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-function" id="dt-extension-function" title=
"extension function"></a>An <b>extension function</b> is a function
that is available for use within an XPath <a title="expression"
class="termref" href="#dt-expression">expression</a>, other than a
<a title="core function" class="termref" href=
"#dt-core-function">core function</a> defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>, an additional
function defined in this XSLT specification, a constructor function
named after an atomic type, or a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> defined using an <a href=
"#element-function"><code>xsl:function</code></a>
declaration.<span class="definition">]</span>.</p>
<p>This specification does not define any mechanism for creating or
binding implementations of <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and it is
not <span class="verb">required</span> that implementations support
any such mechanism. Such mechanisms, if they exist, are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Therefore,
an XSLT stylesheet that <span class="verb">must</span> be portable
between XSLT implementations cannot rely on particular extensions
being available. XSLT provides mechanisms that allow an XSLT
stylesheet to determine whether the implementation makes particular
extensions available, and to specify what happens if those
extensions are not available. If an XSLT stylesheet is careful to
make use of these mechanisms, it is possible for it to take
advantage of extensions and still retain portability.</p>
<div class="div2">
<h3><a name="extension-functions" id="extension-functions"></a>23.1
<a href="#extension-functions" style=
"text-decoration: none">Extension Functions</a></h3>
<p>The set of functions that can be called from a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> may include one or more <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of an extension function always has a non-null namespace
URI.</p>
<div class="div3">
<h4><a name="func-function-available" id=
"func-function-available"></a>23.1.1 <a href=
"#func-function-available" style=
"text-decoration: none">fn:function-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Determines whether a particular function is or is not available
for use. The function is particularly useful for calling within an
<code>[xsl:]use-when</code> attribute (see <a href=
"#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a>) to test whether a particular <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> is available.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-function-available" id=
"function-function-available"></a></p>
<div class="proto"><code class=
"function">function-available</code>(<code class=
"arg">$function-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :function-available function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">function-available</code>(</td>
<td valign="baseline"><code class="arg">$function-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$arity</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:integer</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces, and known function signatures.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>A function is said to be available within an XPath expression if
it is present in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-func-signatures">statically
known function signatures</a><sup><small>XP30</small></sup> for
that expression (see <a href="#static-context"><i>5.4.1
Initializing the Static Context</i></a>). Functions in the static
context are uniquely identified by the name of the function (a
QName) in combination with its <a title="arity" class="termref"
href="#dt-arity">arity</a>.</p>
<p>The value of the <code>$function-name</code> argument
<span class="verb">must</span> be a string containing a <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>. The lexical
QName is expanded into an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> using the namespace
declarations in scope for the <a title="expression" class="termref"
href="#dt-expression">expression</a>. If the value is an unprefixed
lexical QName, then the <a title="standard function namespace"
class="termref" href="#dt-standard-function-namespace">standard
function namespace</a> is used in the expanded QName.</p>
<p>The two-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function returns true if and only if there is an available function
whose name matches the value of the <code>$function-name</code>
argument and whose <a title="arity" class="termref" href=
"#dt-arity">arity</a> matches the value of the <code>$arity</code>
argument.</p>
<p>The single-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function returns true if and only if there is at least one
available function (with some arity) whose name matches the value
of the <code>$function-name</code> argument.</p>
<p><span>When the containing expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
true</span>, the <a href=
"#func-function-available"><code>function-available</code></a>
function returns false in respect of a function name and arity for
which no implementation is available (other than the fallback error
function that raises a dynamic error whenever it is called). This
means that it is possible (as in XSLT 1.0) to use logic such as the
following to test whether a function is available before calling
it:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e56279" id=
"d7e56279"></a>Example: Calling an extension function with
backwards compatibility enabled</div>
<div class="exampleInner">
<pre>
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;
</pre></div>
</div>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1400" id="err-XTDE1400"><span class=
"error">[ERR XTDE1400]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The fact that a function with a given name is available gives no
guarantee that any particular call on the function will be
successful. For example, it is not possible to determine the types
of the arguments expected.</p>
<p>The introduction of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function
in XPath 3.0 reduces the need for <a href=
"#func-function-available"><code>function-available</code></a>,
since <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> not only
tests whether a function is available, but also returns a function
item that enables it to be dynamically called.</p>
<p>If a function is present in the static context but with no
useful functionality (for example, if the system has been
configured for security reasons so that <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-available-environment-variables">
<code>available-environment-variables</code></a><sup><small>FO30</small></sup>
returns no information), then <a href=
"#func-function-available"><code>function-available</code></a> when
applied to that function should return false.</p>
<p>It is not necessary that there be a direct equivalence between
the results of <a href=
"#func-function-available"><code>function-available</code></a> anr
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> in all
cases. For example, there may be <a title="extension function"
class="termref" href="#dt-extension-function">extension
functions</a> whose side-effects are such that for security
reasons, dynamic calls to the function are disallowed; <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> might then
not provide access to the function. The main use-case for <a href=
"#func-function-available"><code>function-available</code></a>, by
contrast, is for use in <code>[xsl:]use-when</code> conditions to
test whether static calls on the function are possible.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<div class="example">
<div class="exampleHeader"><a name="d7e56368" id=
"d7e56368"></a>Example: Stylesheet portable between XSLT 1.0, XSLT
2.0, and XSLT 3.0</div>
<p>A stylesheet that is designed to use XSLT 2.0 facilities when
running under an <span>XSLT 2.0 or XSLT 3.0 processor</span>, but
to fall back to XSLT 1.0 capabilities when not, might be written
using the code:</p>
<div class="exampleInner">
<pre>
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches(/doc/title, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
                translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;
</pre></div>
<p>Here an <span>XSLT 2.0 or XSLT 3.0</span> processor will always
take the <a href="#element-when"><code>xsl:when</code></a> branch,
while a 1.0 processor will follow the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch. The
single-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function is used here, because that is the only version available
in XSLT 1.0. Under the rules of XSLT 1.0, the call on the
<code>matches</code> function is not an error, because it is never
evaluated.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e56395" id=
"d7e56395"></a>Example: Stylesheet portable between XSLT 3.0 and a
future version of XSLT</div>
<p>A stylesheet that is designed to use facilities in some future
XSLT version when they are available, but to fall back to
<span>XSLT 2.0 or XSLT 3.0</span> capabilities when not, might be
written using code such as the following. This hypothesizes the
availability in some future version of a function <code>pad</code>
which pads a string to a fixed length with spaces:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
                                                  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 
</pre></div>
<p>In this case the two-argument version of <a href=
"#func-function-available"><code>function-available</code></a> is
used, because there is no requirement for this code to run under
XSLT 1.0.</p>
</div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="calling-extension-functions" id=
"calling-extension-functions"></a>23.1.2 <a href=
"#calling-extension-functions" style=
"text-decoration: none">Calling Extension Functions</a></h4>
<p>If the function name used in a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> identifies an extension function,
then to evaluate the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>,
the processor will first evaluate each of the arguments in the
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>.
If the processor has information about the datatypes expected by
the extension function, then it <span class="verb">may</span>
perform any necessary type conversions between the XPath datatypes
and those defined by the implementation language. If multiple
extension functions are available with the same name, the processor
<span class="verb">may</span> decide which one to invoke based on
the number of arguments, the types of the arguments, or any other
criteria. The result returned by the implementation is returned as
the result of the function call, again after any necessary
conversions between the datatypes of the implementation language
and those of XPath. The details of such type conversions are
outside the scope of this specification.</p>
<p><a name="err-XTDE1420" id="err-XTDE1420"><span class=
"error">[ERR XTDE1420]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
arguments supplied to a call on an extension function do not
satisfy the rules defined for that particular extension function,
or if the extension function reports an error, or if the result of
the extension function cannot be converted to an XPath value.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations may also provide mechanisms allowing extension
functions to report recoverable dynamic errors, or to execute
within an environment that treats some or all of the errors listed
above as recoverable.</p>
</div>
<p><a name="err-XTDE1425" id="err-XTDE1425"><span class=
"error">[ERR XTDE1425]</span></a> <span>When the containing element
is processed with <a title="XSLT 1.0 behavior" class="termref"
href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>,</span> it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate an extension
function call if no implementation of the extension function is
available.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When <span>XSLT 1.0 behavior</span> is not enabled, this is a
static error <a href="http://www.w3.org/TR/xpath-30/#ERRXPST0017"
title="XPST0017"><span class="error">[ERR XPST0017]</span></a>
<sup><small>XP30</small></sup>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no prohibition on calling extension functions that have
side-effects (for example, an extension function that writes data
to a file). However, the order of execution of XSLT instructions is
not defined in this specification, so the effects of such functions
are unpredictable.</p>
</div>
<p>Implementations are not <span class="verb">required</span> to
perform full validation of values returned by extension functions.
It is an error for an extension function to return a string
containing characters that are not permitted in XML, but the
consequences of this error are <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
implementation <span class="verb">may</span> raise an error,
<span class="verb">may</span> convert the string to a string
containing valid characters only, or <span class="verb">may</span>
treat the invalid characters as if they were permitted
characters.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ability to execute extension functions represents a
potential security weakness, since untrusted stylesheets may invoke
code that has privileged access to resources on the machine where
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> executes. Implementations may
therefore provide mechanisms that restrict the use of extension
functions by untrusted stylesheets.</p>
</div>
<p>All observations in this section regarding the errors that can
occur when invoking extension functions apply equally when invoking
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>.</p>
</div>
<div class="div3">
<h4><a name="external-objects" id="external-objects"></a>23.1.3
<a href="#external-objects" style="text-decoration: none">External
Objects</a></h4>
<p>An implementation <span class="verb">may</span> allow an
extension function to return an object that does not have any
natural representation in the XDM data model, whether as an atomic
value, a node, <span>or a function item</span>. For example, an
extension function <code>sql:connect</code> might return an object
that represents a connection to a relational database; the
resulting connection object might be passed as an argument to calls
on other extension functions such as <code>sql:insert</code> and
<code>sql:select</code>.</p>
<p>The way in which such objects are represented in the type system
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. They might
be represented by a completely new datatype, or they might be
mapped to existing datatypes such as <code>integer</code>,
<code>string</code>, or <code>anyURI</code>.</p>
</div>
<div class="div3">
<h4><a name="func-type-available" id=
"func-type-available"></a>23.1.4 <a href="#func-type-available"
style="text-decoration: none">fn:type-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Used to control how a stylesheet behaves if a particular schema
type is or is not available in the static context.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-type-available" id=
"function-type-available"></a></p>
<div class="proto"><code class=
"function">type-available</code>(<code class=
"arg">$type-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces, and schema definitions.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>A schema type (that is, a simple type or a complex type) is said
to be available within an XPath expression if it is a type
definition that is present in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-is-types">in-scope schema
types</a><sup><small>XP30</small></sup> for that expression (see
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>). This includes built-in types, types imported
using <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>, and
extension types defined by the implementation.</p>
<p>The value of the <code>$type-name</code> argument <span class=
"verb">must</span> be a string containing a <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>. The EQName is
expanded into an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> using the namespace
declarations in scope for the <a title="expression" class="termref"
href="#dt-expression">expression</a>. If the value is an unprefixed
lexical QName, then the default namespace is used in the expanded
QName.</p>
<p>The function returns true if and only if there is an available
type whose name matches the value of the <code>$type-name</code>
argument.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1428" id="err-XTDE1428"><span class=
"error">[ERR XTDE1428]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href=
"#func-type-available"><code>type-available</code></a> function is
of limited use within an <code>[xsl:]use-when</code> expression,
because the static context for the expression does not include any
user-defined types.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="extension-instruction" id=
"extension-instruction"></a>23.2 <a href="#extension-instruction"
style="text-decoration: none">Extension Instructions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-namespace" id="dt-extension-namespace" title=
"extension namespace"></a>The <a title="extension instruction"
class="termref" href="#dt-extension-instruction">extension
instruction</a> mechanism allows namespaces to be designated as
<b>extension namespaces</b>. When a namespace is designated as an
extension namespace and an element with a name from that namespace
occurs in a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, then the
element is treated as an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> rather than as a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result
element</a>.<span class="definition">]</span> The namespace
determines the semantics of the instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since an element that is a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element is
not occurring <em>in a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence
constructor</a></em> , <a title="user-defined data element" class=
"termref" href="#dt-data-element">user-defined data elements</a>
(see <a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>) are not extension elements as defined here, and
nothing in this section applies to them.</p>
</div>
<div class="div3">
<h4><a name="designating-extension-namespace" id=
"designating-extension-namespace"></a>23.2.1 <a href=
"#designating-extension-namespace" style=
"text-decoration: none">Designating an Extension Namespace</a></h4>
<p>A namespace is designated as an extension namespace by using an
<code>[xsl:]extension-element-prefixes</code> attribute on an
element in the stylesheet (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>). The
attribute <span class="verb">must</span> be in the XSLT namespace
only if its parent element is <em>not</em> in the XSLT namespace.
The value of the attribute is a whitespace-separated list of
namespace prefixes. The namespace bound to each of the prefixes is
designated as an extension namespace.</p>
<p>The default namespace (as declared by <code>xmlns</code>) may be
designated as an extension namespace by including
<code>#default</code> in the list of namespace prefixes.</p>
<p><a name="err-XTSE1430" id="err-XTSE1430"><span class=
"error">[ERR XTSE1430]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
is no namespace bound to the prefix on the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute or, when
<code>#default</code> is specified, if there is no default
namespace.</p>
<p>The designation of a namespace as an extension namespace is
effective for the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute and for all
descendants of that element within the same stylesheet module.</p>
</div>
<div class="div3">
<h4><a name="func-element-available" id=
"func-element-available"></a>23.2.2 <a href=
"#func-element-available" style=
"text-decoration: none">fn:element-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Determines whether a particular instruction is or is not
available for use. The function is particularly useful for calling
within an <code>[xsl:]use-when</code> attribute (see <a href=
"#conditional-inclusion"><i>3.14 Conditional Element
Inclusion</i></a>) to test whether a particular <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> is
available.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-element-available" id=
"function-element-available"></a></p>
<div class="proto"><code class=
"function">element-available</code>(<code class=
"arg">$element-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The value of the <code>$element-name</code> argument
<span class="verb">must</span> be a string containing an <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix, the it is
expanded into an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> using the namespace
declarations in the static context of the <a title="expression"
class="termref" href="#dt-expression">expression</a>. If there is a
default namespace in scope, then it is used to expand an unprefixed
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p>If the resulting <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> is in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, the function returns true if and only if the local
name matches the name of an XSLT element that is defined in this
specification and implemented by the XSLT processor.</p>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> has a null namespace URI,
the <a href=
"#func-element-available"><code>element-available</code></a>
function will return false.</p>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> is not in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, the function returns true if and only if the
processor has an implementation available of an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> with the
given expanded QName. This applies whether or not the namespace has
been designated as an <a title="extension namespace" class=
"termref" href="#dt-extension-namespace">extension
namespace</a>.</p>
<p>If the processor does not have an implementation of a particular
extension instruction available, and such an extension instruction
is evaluated, then the processor <span class="verb">must</span>
perform fallback for the element as specified in <a href=
"#fallback"><i>23.2.3 Fallback</i></a>. An implementation
<span class="verb">must not</span> signal an error merely because
the stylesheet contains an extension instruction for which no
implementation is available.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1440" id="err-XTDE1440"><span class=
"error">[ERR XTDE1440]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>For element names in the XSLT namespace:</p>
<ul>
<li>
<p>Where conformance rules make some features of the specification
optional, for example the <a href=
"#element-stream"><code>xsl:stream</code></a> element, this
function can be used (typically in a <code>use-when</code>
expression) to determine whether the feature is available in a
particular processor. It can also be useful to distinguish
processors that implement XSLT 3.0 from processors that implement
other (older or newer) versions of the specification, and to
distinguish full implementations from incomplete
implementations.</p>
</li>
<li>
<p>In earlier versions of this specification, <a href=
"#func-element-available"><code>element-available</code></a> was
defined to return true only for elements classified as
instructions. The distinction between instructions and other
elements, however, is sometimes rather technical, and in XSLT 3.0
the effect of the function has therefore been aligned to do what
its name might suggest.</p>
</li>
<li>
<p>If an instruction is recognized but offers no useful
functionality (for example, if the system has been configured for
security reasons so that <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> always raises an
error), then <a href=
"#func-element-available"><code>element-available</code></a> when
applied to that instruction <span class="verb">should</span> return
false.</p>
</li>
</ul>
<p>For element names in other namespaces:</p>
<ul>
<li>
<p>The result of the <a href=
"#func-element-available"><code>element-available</code></a> does
not depend on whether or not the namespace of the supplied
instruction name has been designated as an extension element
namespace; it tests whether the instruction would be available if
the namespace were designated as such.</p>
</li>
</ul>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="fallback" id="fallback"></a>23.2.3 <a href="#fallback"
style="text-decoration: none">Fallback</a></h4>
<p class="element-syntax"><a name="element-fallback" id=
"element-fallback"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:fallback&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:fallback&gt;</code></p>
<p>The content of an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and when
performing fallback, the value returned by the <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is the
result of evaluating this sequence constructor.</p>
<p>When not performing fallback, evaluating an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element returns
an empty sequence: the content of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is
ignored.</p>
<p>There are two situations where a <a title="processor" class=
"termref" href="#dt-processor">processor</a> performs fallback:
when an extension instruction that is not available is evaluated,
and when an instruction in the XSLT namespace, that is not defined
in XSLT <span>3.0</span>, is evaluated within a region of the
stylesheet for which <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Fallback processing is not invoked in other situations, for
example it is not invoked when an XPath expression uses
unrecognized syntax or contains a call to an unknown function. To
handle such situations dynamically, the stylesheet should call
functions such as <a href=
"#func-system-property"><code>system-property</code></a> and
<a href=
"#func-function-available"><code>function-available</code></a> to
decide what capabilities are available.</p>
</div>
<p><a name="err-XTDE1450" id="err-XTDE1450"><span class=
"error">[ERR XTDE1450]</span></a> When a <a title="processor"
class="termref" href="#dt-processor">processor</a> performs
fallback for an <a title="extension instruction" class="termref"
href="#dt-extension-instruction">extension instruction</a> that is
not recognized, if the instruction element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then
the content of each of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> children
<span class="verb">must</span> be evaluated; it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if it has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is different from the situation with unrecognized <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
elements</a>. As explained in <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a>, an unrecognized XSLT element
appearing within a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is a
static error unless (a) <a title="forwards compatible behavior"
class="termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled, and (b) the instruction has an
<a href="#element-fallback"><code>xsl:fallback</code></a>
child.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="result-trees" id="result-trees"></a>24 <a href=
"#result-trees" style="text-decoration: none">Final Result
Trees</a></h2>
<p>The output of a transformation is a set of one or more <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>.</p>
<p>A <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> can be created
explicitly, by evaluating an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. As explained in <a href=
"#executing-a-transformation"><i>2.4 Executing a
Transformation</i></a>, a final result tree is also created
implicitly if no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is evaluated, or if the result of evaluating the
<a title="initial template" class="termref" href=
"#dt-initial-template">initial template</a> is a non-empty
sequence.</p>
<p>The way in which a <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> is delivered to
an application is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<p>Serialization of <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result trees</a> is described
further in <a href="#serialization"><i>25 Serialization</i></a></p>
<div class="div2">
<h3><a name="creating-result-trees" id=
"creating-result-trees"></a>24.1 <a href="#creating-result-trees"
style="text-decoration: none">Creating Final Result Trees</a></h3>
<p class="element-syntax"><a name="element-result-document" id=
"element-result-document"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:result-document<br />
&#160;&#160;format? = { <var>eqname</var> }<br />
&#160;&#160;href? = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;method? = { "xml" | "html" | "xhtml" | "text" |
<var>eqname</var> }<br />
&#160;&#160;byte-order-mark? = { "yes" | "no" }<br />
&#160;&#160;cdata-section-elements? = { <var>eqnames</var> }<br />
&#160;&#160;doctype-public? = { <var>string</var> }<br />
&#160;&#160;doctype-system? = { <var>string</var> }<br />
&#160;&#160;encoding? = { <var>string</var> }<br />
&#160;&#160;escape-uri-attributes? = { "yes" | "no" }<br />
&#160;&#160;html-version? = { <var>decimal</var> }<br />
&#160;&#160;include-content-type? = { "yes" | "no" }<br />
&#160;&#160;indent? = { "yes" | "no" }<br />
&#160;&#160;item-separator? = { <var>string</var> }<br />
&#160;&#160;media-type? = { <var>string</var> }<br />
&#160;&#160;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD"
| "fully-normalized" | "none" | <var>nmtoken</var> }<br />
&#160;&#160;omit-xml-declaration? = { "yes" | "no" }<br />
&#160;&#160;parameter-document? = { <var>uri</var> }<br />
&#160;&#160;standalone? = { "yes" | "no" | "omit" }<br />
&#160;&#160;suppress-indentation? = { <var>eqnames</var> }<br />
&#160;&#160;undeclare-prefixes? = { "yes" | "no" }<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;output-version? = { <var>nmtoken</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:result-document&gt;</code></p>
<p>The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is used to create a <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a>. The
content of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element is a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children of the document node of the tree. A document node is
created, and the sequence obtained by evaluating the sequence
constructor is used to construct the content of the document, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>. The tree rooted at this
document node forms the final result tree.</p>
<p>The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction defines the URI of the result tree, and may optionally
specify the output format to be used for serializing this tree.</p>
<p>The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute, if specified, <span class=
"verb">must</span> be a <span><a title="EQName" class="termref"
href="#dt-eqname">EQName</a></span>. The value is expanded using
the namespace declarations in scope for the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element. The resulting <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> <span class=
"verb">must</span> match the expanded QName of a named <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
This identifies the <a href=
"#element-output"><code>xsl:output</code></a> declaration that will
control the serialization of the <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
(see <a href="#serialization"><i>25 Serialization</i></a>), if the
result tree is serialized. If the <code>format</code> attribute is
omitted, the unnamed <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> is used to
control serialization of the result tree.</p>
<p><a name="err-XTDE1460" id="err-XTDE1460"><span class=
"error">[ERR XTDE1460]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute is not a valid <a title="EQName"
class="termref" href="#dt-eqname">EQName</a>, or if it does not
match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of an <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
If the processor is able to detect the error statically (for
example, when the <code>format</code> attribute contains no curly
brackets), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The only way to select the unnamed <a title="output definition"
class="termref" href="#dt-output-definition">output definition</a>
is to omit the <code>format</code> attribute.</p>
</div>
<p>The <code>parameter-document</code> attribute allows
serialization parameters to be supplied in an external document.
The external document must contain an
<code>output:serialization-parameters</code> element with the
format described in <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">
Section 3.1 Setting Serialization Parameters by Means of a Data
Model Instance</a> <sup><small>SER30</small></sup>, and the
parameters are interpreted as described in that specification.</p>
<p>If present, the effective value of the URI supplied in the
<code>parameter-document</code> attribute is dereferenced, after
resolution against the base URI of the
<code>xsl:result-document</code> element if it is a relative
reference. If the location of the stylesheet at development time is
different from the deployed location, any relative reference should
be resolved against the deployed location. A serialization error
occurs if the result of dereferencing the URI is ill-formed or
invalid; but if no document can be found at the specified location,
the attribute <code>may</code> be ignored.</p>
<p>A serialization parameter specified in the
<code>parameter-document</code> takes precedence over a value
supplied directly as an attribute of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
which in turn takes precedence over a value supplied in the
selected output definition, except that the values of the
<code>cdata-section-elements</code> and
<code>suppress-indentation</code> attributes are merged in the same
way as when multiple <code>xsl:output</code> declarations are
merged.</p>
<p>The attributes <code>method</code>, <code>byte-order-mark</code>
<code>cdata-section-elements</code>, <code>doctype-public</code>,
<code>doctype-system</code>, <code>encoding</code>,
<code>escape-uri-attributes</code>,
<span><code>html-version</code></span>, <code>indent</code>,
<span><code>item-separator</code>,</span> <code>media-type</code>,
<code>normalization-form</code>, <code>omit-xml-declaration</code>,
<code>standalone</code>,
<span><code>suppress-indentation</code>,</span>
<code>undeclare-prefixes</code>, <code>use-character-maps</code>,
and <code>output-version</code> may be used to override attributes
defined in the selected <a title="output definition" class=
"termref" href="#dt-output-definition">output definition</a>.</p>
<p>With the exception of <code>use-character-maps</code>, these
attributes are all defined as <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a>, so their values may be set dynamically. For any of
these attributes that is present on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
overrides or supplements the corresponding value from the output
definition. This works in the same way as when one <a href=
"#element-output"><code>xsl:output</code></a> declaration overrides
another:</p>
<ul>
<li>
<p>In the case of <code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span>, the value of the
serialization parameter is the union of the expanded names of the
elements named in this instruction and the elements named in the
selected output definition;</p>
</li>
<li>
<p>In the case of <code>use-character-maps</code>, the character
maps referenced in this instruction supplement and take precedence
over those defined in the selected output definition;</p>
</li>
<li>
<p>In the case of <code>doctype-public</code> and
<code>doctype-system</code>, setting the effective value of the
attribute to a zero-length string has the effect of overriding any
value for these attributes obtained from the output definition. The
corresponding serialization parameter is not set (is "absent").</p>
</li>
<li>
<p>In the case of <code>item-separator</code>, setting the
effective value of the attribute to the special value
<code>"#absent"</code> has the effect of overriding any value for
this attribute obtained from the output definition. The
corresponding serialization parameter is not set (is "absent"). it
is not possible to set the value of the serialization parameter to
the literal 7-character string "#absent".</p>
</li>
<li>
<p>In all other cases, the effective value of an attribute actually
present on this instruction takes precedence over the value defined
in the selected output definition.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the case of the attributes <code>method</code>,
<code>cdata-section-elements</code>,
<span><code>suppress-indentation</code></span>, and
<code>use-character-maps</code>, the <a title="effective value"
class="termref" href="#dt-effective-value">effective value</a> of
the attribute contains a space-separated list of <a title="EQName"
class="termref" href="#dt-eqname">EQNames</a>. If any of these is a
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix, the prefix is
expanded using the in-scope namespaces for the
<code>xsl:result-document</code> element. In the case of
<code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span>, an unprefixed element
name is expanded using the default namespace. In the case of the
<code>method</code> attribute, if the method is not one of the
system-defined methods (xml, html, xhtml, text) then the expanded
name must have a non-absent namespace.</p>
</div>
<p>The <code>output-version</code> attribute on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction overrides the <code>version</code> attribute on
<a href="#element-output"><code>xsl:output</code></a> (it has been
renamed because <code>version</code> is available with a different
meaning as a standard attribute: see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>). In all
other cases, attributes correspond if they have the same name.</p>
<p>There are some serialization parameters that apply to some
output methods but not to others. For example, the
<code>indent</code> attribute has no effect on the
<code>text</code> output method. If a value is supplied for an
attribute that is inapplicable to the output method, its value is
not passed to the serializer. The processor <span class=
"verb">may</span> validate the value of such an attribute, but is
not <span class="verb">required</span> to do so.</p>
<p>The <code>item-separator</code> serialization parameter defined
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> is not available in <a href=
"#element-result-document"><code>xsl:result-document</code></a>; it
is not applicable, because the sequence that is serialized by XSLT
is always a singleton document node. Formally therefore, the
serializer is invoked passing an empty string as the value of this
parameter.</p>
<p>The <code>href</code> attribute is optional. The default value
is the zero-length string. The <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a> of the
attribute <span class="verb">must</span> be a <a title=
"URI Reference" class="termref" href="#dt-uri-reference">URI
Reference</a>, which may be absolute or relative. There
<span class="verb">may</span> be <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
restrictions on the form of absolute URI that may be used, but the
implementation is not <span class="verb">required</span> to enforce
any restrictions. Any valid relative URI <span>reference</span>
<span class="verb">must</span> be accepted. Note that the
zero-length string is a valid relative URI
<span>reference</span>.</p>
<p>The base URI of the document node at the root of the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is based on the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>href</code>
attribute. If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is a relative URI
<span>reference</span>, then it is resolved relative to the
<a title="base output URI" class="termref" href=
"#dt-base-output-uri">base output URI</a>. If the implementation
provides an API to access final result trees, then it <span class=
"verb">must</span> allow a final result tree to be identified by
means of this base URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The base URI of the <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> is not
necessarily the same thing as the URI of its serialized
representation on disk, if any. For example, a server (or browser
client) might store final result trees only in memory, or in an
internal disk cache. As long as the processor satisfies requests
for those URIs, it is irrelevant where they are actually written on
disk, if at all.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It will often be the case that one <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
contains links to another final result tree produced during the
same transformation, in the form of a relative URI
<span>reference</span>. The mechanism of associating a URI with a
final result tree has been chosen to allow the integrity of such
links to be preserved when the trees are serialized.</p>
<p>As well as being potentially significant in any API that
provides access to final result trees, the base URI of the new
document node is relevant if the final result tree, rather than
being serialized, is supplied as input to a further
transformation.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction to validate the contents of the new document, and to
determine the <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> that elements and attributes
within the <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> will carry. The
permitted values and their semantics are described in <a href=
"#validating-document-nodes"><i>24.2.2 Validating Document
Nodes</i></a>.</p>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">may</span> allow a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to be serialized.
Serialization is described in <a href="#serialization"><i>25
Serialization</i></a>. However, an implementation (for example, a
<a title="processor" class="termref" href=
"#dt-processor">processor</a> running in an environment with no
access to writable filestore) is not <span class=
"verb">required</span> to support the serialization of <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>. An implementation
that does not support the serialization of final result trees
<span class="verb">may</span> ignore the <code>format</code>
attribute and the serialization attributes. Such an implementation
<span class="verb">must</span> provide the application with some
means of access to the (un-serialized) result tree, using its URI
to identify it.</p>
<p>Implementations may provide additional mechanisms, outside the
scope of this specification, for defining the way in which
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are processed. Such
mechanisms <span class="verb">may</span> make use of the
XSLT-defined attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
and/or <a href="#element-output"><code>xsl:output</code></a>
elements, or they <span class="verb">may</span> use additional
elements or attributes in an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
namespace.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e57698" id=
"d7e57698"></a>Example: Multiple Result Documents</div>
<p>The following example takes an XHTML document as input, and
breaks it up so that the text following each &lt;h1&gt; element is
included in a separate document. A new document
<code>toc.html</code> is constructed to act as an index:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
        version="3.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
        
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;       
         
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;         
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<p>There are restrictions on the use of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, designed to ensure that the results are fully
interoperable even when processors optimize the sequence in which
instructions are evaluated. Informally, the restriction is that the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction can only be used while writing a final result tree, not
while writing to a temporary tree or a sequence. This restriction
is defined formally as follows.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-output-state" id="dt-output-state" title=
"output state"></a>Each instruction in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated
in one of two possible <b>output states</b>: <a title=
"final output state" class="termref" href=
"#dt-final-output-state">final output state</a> or <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>
<span class="definition">]</span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-final-output-state" id="dt-final-output-state" title=
"final output state"></a>The first of the two <a title=
"output state" class="termref" href="#dt-output-state">output
states</a> is called <b>final output</b> state. This state applies
when instructions are writing to a <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result
tree</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-temporary-output-state" id="dt-temporary-output-state" title=
"temporary output state"></a>The second of the two <a title=
"output state" class="termref" href="#dt-output-state">output
states</a> is called <b>temporary output</b> state. This state
applies when instructions are writing to a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> or any other non-final
destination.<span class="definition">]</span></p>
<p>The instructions in the <a title="initial template" class=
"termref" href="#dt-initial-template">initial template</a> are
evaluated in <a title="final output state" class="termref" href=
"#dt-final-output-state">final output state</a>. An instruction is
evaluated in the same <a title="output state" class="termref" href=
"#dt-output-state">output state</a> as its calling instruction,
except that <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, <a href=
"#element-with-param"><code>xsl:with-param</code></a>, <a href=
"#element-function"><code>xsl:function</code></a>, <a href=
"#element-key"><code>xsl:key</code></a>, <a href=
"#element-sort"><code>xsl:sort</code></a>, <span>and <a href=
"#element-merge-key"><code>xsl:merge-key</code></a></span> always
evaluate the instructions in their contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> in <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>.</p>
<p><a name="err-XTDE1480" id="err-XTDE1480"><span class=
"error">[ERR XTDE1480]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> to
evaluate the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction in <a title="temporary output state" class="termref"
href="#dt-temporary-output-state">temporary output state</a>.</p>
<p><a name="err-XTDE1490" id="err-XTDE1490"><span class=
"error">[ERR XTDE1490]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> for a
transformation to generate two or more <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result trees</a>
with the same URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note, this means that it is an error to evaluate more than one
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction that omits the <code>href</code> attribute, or to
evaluate any <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction that omits the <code>href</code> attribute if an
initial <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is created
implicitly.</p>
</div>
<p>In addition, an implementation <span class="verb">may</span>
report this error if it is able to detect that two or more final
result trees are generated with different URIs that refer to the
same physical resource.</p>
<p>Technically, the result of evaluating the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is an empty sequence. This means it does not contribute
any nodes to the result of the sequence constructor it is part
of.</p>
<p><a name="err-XTDE1500" id="err-XTDE1500"><span class=
"error">[ERR XTDE1500]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> for a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> to write to an external resource
and read from the same resource during a single transformation,
<span>if the same absolute URI is used to access the resource in
both cases</span>.</p>
<p>In addition, an implementation <span class="verb">may</span>
report this error if it is able to detect that a transformation
writes to a resource and reads from the same resource using
different URIs that refer to the same physical resource. Note that
if the error is not detected, it is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the document that is read from the resource reflects its state
before or after the result tree is written.</p>
</div>
<div class="div2">
<h3><a name="validation" id="validation"></a>24.2 <a href=
"#validation" style="text-decoration: none">Validation</a></h3>
<p>It is possible to control the <a title="type annotation" class=
"termref" href="#dt-annotation">type annotation</a> applied to
individual element and attribute nodes as they are constructed.
This is done using the <code>type</code> and
<code>validation</code> attributes of the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, or the <code>xsl:type</code> and
<code>xsl:validation</code> attributes of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
<p>The <code>[xsl:]type</code> attribute is used to request
validation of an element or attribute against a specific simple or
complex type defined in a schema. The <code>[xsl:]validation</code>
attribute is used to request validation against the global element
or attribute declaration whose name matches the name of the element
or attribute being validated.</p>
<p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are mutually exclusive. Both are optional, but if one is
present then the other <span class="verb">must</span> be omitted.
If both attributes are omitted, the effect is the same as
specifying the <code>validation</code> attribute with the value
specified in the <span><code>[xsl:]default-validation</code>
attribute of the innermost containing element having such an
attribute</span>; if this is not specified, the effect is the same
as specifying <code>validation="strip"</code>.</p>
<p>The <code>[xsl:]default-validation</code> attribute defines the
default value of the <code>validation</code> attribute of all
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, and of the <code>xsl:validation</code> attribute of
all <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a> <span>,
appearing within its scope</span>. It also determines the
validation applied to the implicit <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
created in the absence of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. This default applies within the containing <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title="package"
class="termref" href="#dt-package">package</a>: it does not extend
to included or imported stylesheet modules or used packages. If the
attribute is omitted, the default is <code>strip</code>. The
permitted values are <code>preserve</code> and
<code>strip</code>.</p>
<p><a name="err-XTSE1505" id="err-XTSE1505"><span class=
"error">[ERR XTSE1505]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if both
the <code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are present on the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, or on a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a>.</p>
<p>The detailed rules for validation vary depending on the kind of
node being validated. The rules for element and attribute nodes are
given in <a href="#validating-constructed-nodes"><i>24.2.1
Validating Constructed Elements and Attributes</i></a>, while those
for document nodes are given in <a href=
"#validating-document-nodes"><i>24.2.2 Validating Document
Nodes</i></a>.</p>
<div class="div3">
<h4><a name="validating-constructed-nodes" id=
"validating-constructed-nodes"></a>24.2.1 <a href=
"#validating-constructed-nodes" style=
"text-decoration: none">Validating Constructed Elements and
Attributes</a></h4>
<div class="div4">
<h5><a name="validating-using-validation-attribute" id=
"validating-using-validation-attribute"></a>24.2.1.1 <a href=
"#validating-using-validation-attribute" style=
"text-decoration: none">Validation using the</a>
<code>[xsl:]validation</code> <a href=
"#validating-using-validation-attribute" style=
"text-decoration: none">Attribute</a></h5>
<p>The <code>[xsl:]validation</code> attribute defines the
validation action to be taken. It determines not only the <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> of the node that is constructed by the relevant
instruction itself, but also the type annotations of all element
and attribute nodes that have the constructed node as an ancestor.
Conceptually, the validation requested for a child element or
attribute node is applied before the validation requested for its
parent element. For example, if the instruction that constructs a
child element specifies <code>validation="strict"</code>, this will
cause the child element to be checked against an element
declaration, but if the instruction that constructs its parent
element specifies <code>validation="strip"</code>, then the final
effect will be that the child node is annotated as
<code>xs:untyped</code>.</p>
<p>In the paragraphs below, the term <em>contained nodes</em> means
the elements and attributes that have the newly constructed node as
an ancestor.</p>
<ul>
<li>
<p>The value <code>strip</code> indicates that the new node and
each of the contained nodes will have the <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> <code>xs:untyped</code> if it is an element, or
<code>xs:untypedAtomic</code> if it is an attribute. Any previous
type annotation present on a contained element or attribute node
(for example, a type annotation that is present on an element
copied from a source document) is also replaced by
<code>xs:untyped</code> or <code>xs:untypedAtomic</code> as
appropriate. The typed value of the node is changed to be the same
as its string value, as an instance of
<code>xs:untypedAtomic</code>. In the case of elements the
<code>nilled</code> property is set to <code>false</code>. The
values of the <code>is-id</code> and <code>is-idrefs</code>
properties are unchanged. Schema validation is not invoked.</p>
</li>
<li>
<p>The value <code>preserve</code> indicates that nodes that are
copied will retain their <a title="type annotation" class="termref"
href="#dt-annotation">type annotations</a>, but nodes whose content
is newly constructed will be annotated as <code>xs:anyType</code>
in the case of elements, or <code>xs:untypedAtomic</code> in the
case of attributes. Schema validation is not invoked. The detailed
effect depends on the instruction:</p>
<ul>
<li>
<p>In the case of <a href=
"#element-element"><code>xsl:element</code></a> and literal result
elements, the new element has a <a title="type annotation" class=
"termref" href="#dt-annotation">type annotation</a> of
<code>xs:anyType</code>, and the type annotations of contained
nodes are retained unchanged.</p>
</li>
<li>
<p>In the case of <a href=
"#element-attribute"><code>xsl:attribute</code></a>, the effect is
exactly the same as specifying <code>validation="strip"</code>:
that is, the new attribute will have the type annotation
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>In the case of <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, all the nodes that
are copied will retain their type annotations unchanged.</p>
</li>
<li>
<p>In the case of <a href=
"#element-copy"><code>xsl:copy</code></a>, the effect depends on
the kind of node being copied.</p>
<ol class="enumar">
<li>
<p>Where the node being copied is an attribute, the copied
attribute will retain its <a title="type annotation" class=
"termref" href="#dt-annotation">type annotation</a>.</p>
</li>
<li>
<p>Where the node being copied is an element, the copied element
will have a <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> of <code>xs:anyType</code>
(because this instruction does not copy the content of the element,
it would be wrong to assume that the type is unchanged); but any
contained nodes will have their type annotations retained in the
same way as with <a href=
"#element-element"><code>xsl:element</code></a>.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>The value <code>strict</code> indicates that <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotations</a> are established by performing strict schema
validity assessment on the element or attribute node created by
this instruction as follows:</p>
<ul>
<li>
<p>In the case of an element, a top-level element declaration is
identified whose local name and namespace (if any) match the name
of the element, and schema-validity assessment is carried out
according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Element)",
clauses 1.1 and 2, using the top-level element declaration as the
"declaration stipulated by the processor", which is mentioned in
clause 1.1.1.1). The element is considered valid if the result of
the schema validity assessment is a PSVI in which the relevant
element node has a <code>validity</code> property whose value is
<code>valid</code>. If there is no matching element declaration, or
if the element is not considered valid, the transformation fails
<span class="error">[see <a href="#err-XTTE1510">ERR
XTTE1510</a>]</span>, <span class="error">[see <a href=
"#err-XTTE1512">ERR XTTE1512</a>]</span>. In effect this means that
the element being validated <span class="verb">must</span> be
declared using a top-level declaration in the schema, and
<span class="verb">must</span> conform to its declaration. The
process of validation applies recursively to contained elements and
attributes to the extent required by the schema definition.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not an error if the identified type definition is a simple
type, although <a href="#xmlschema-1">[XML Schema Part 1]</a> does
not define explicitly that this case is permitted.</p>
</div>
</li>
<li>
<p>In the case of an attribute, a top-level attribute declaration
is identified whose local name and namespace (if any) match the
name of the attribute, and schema-validity assessment is carried
out according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.2.4 "Attribute Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Attribute)").
The attribute is considered valid if the result of the schema
validity assessment is a PSVI in which the relevant attribute node
has a <code>validity</code> property whose value is
<code>valid</code>. If the attribute is not considered valid, the
transformation fails <span class="error">[see <a href=
"#err-XTTE1510">ERR XTTE1510</a>]</span>. In effect this means that
the attribute being validated <span class="verb">must</span> be
declared using a top-level declaration in the schema, and
<span class="verb">must</span> conform to its declaration.</p>
</li>
<li>
<p>The schema components used to validate an element or attribute
may be located in any way described by <a href="#xmlschema-1">[XML
Schema Part 1]</a> (see section 4.3.2, <em>How schema documents are
located on the Web</em>). The components in the schema constructed
from the synthetic schema document (see <a href=
"#import-schema"><i>3.16 Importing Schema Components</i></a>) will
always be available for validating constructed nodes; if additional
schema components are needed, they <span class="verb">may</span> be
located in other ways, for example implicitly from knowledge of the
namespace in which the elements and attributes appear, or using the
<code>xsi:schemaLocation</code> attribute of elements within the
tree being validated.</p>
</li>
<li>
<p>If no validation is performed for a node, which can happen when
the schema specifies <code>lax</code> or <code>skip</code>
validation for that node or for a subtree, then the node is
annotated as <code>xs:anyType</code> in the case of an element, and
<code>xs:untypedAtomic</code> in the case of an attribute.</p>
</li>
</ul>
</li>
<li>
<p>The value <code>lax</code> has the same effect as the value
<code>strict</code>, except that whereas <code>strict</code>
validation fails if there is no matching top-level element
declaration or if the outcome of validity assessment is a
<code>validity</code> property of <code>invalid</code> or
<code>notKnown</code>, <code>lax</code> validation fails only if
the outcome of validity assessment is a <code>validity</code>
property of <code>invalid</code>. That is, <code>lax</code>
validation does not cause a <a title="type error" class="termref"
href="#dt-type-error">type error</a> when the outcome is
<code>notKnown</code>.</p>
<p>In practice this means that the element or attribute being
validated <span class="verb">must</span> conform to its declaration
if a top-level declaration is available. If no such declaration is
available, then the element or attribute is not validated, but its
attributes and children are validated, again with lax validation.
Any nodes whose validation outcome is a <code>validity</code>
property of <code>notKnown</code> are annotated as
<code>xs:anyType</code> in the case of an element, and
<code>xs:untypedAtomic</code> in the case of an attribute.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When the parent element lacks a declaration, the XML Schema
specification defines the recursive checking of children and
attributes as optional. For this specification, this recursive
checking is required.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an element that is being validated has an
<code>xsi:type</code> attribute, then the value of the
<code>xsi:type</code> attribute will be taken into account when
performing the validation. However, the presence of an
<code>xsi:type</code> attribute will not of itself cause an element
to be validated: if validation against a named type is required, as
distinct from validation against a top-level element declaration,
then it must be requested using the XSLT <code>[xsl:]type</code>
attribute on the instruction that invokes the validation, as
described in section <a href="#validation-xsl-type"><i>24.2.1.2
Validation using the [xsl:]type Attribute</i></a></p>
</div>
</li>
</ul>
<p><a name="err-XTTE1510" id="err-XTTE1510"><span class=
"error">[ERR XTTE1510]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and schema validity assessment concludes that
the validity of the element or attribute is invalid or unknown, a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs. As with other type errors, the error <span class=
"verb">may</span> be signaled statically if it can be detected
statically.</p>
<p><a name="err-XTTE1512" id="err-XTTE1512"><span class=
"error">[ERR XTTE1512]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and there is no matching top-level declaration
in the schema, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
<p><a name="err-XTTE1515" id="err-XTTE1515"><span class=
"error">[ERR XTTE1515]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value <code>lax</code>,
and schema validity assessment concludes that the element or
attribute is invalid, a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>No mechanism is provided to validate an element or attribute
against a local declaration in a schema. Such validation can
usually be achieved by applying validation to a containing element
for which a top-level element declaration exists.</p>
</div>
</div>
<div class="div4">
<h5><a name="validation-xsl-type" id=
"validation-xsl-type"></a>24.2.1.2 <a href="#validation-xsl-type"
style="text-decoration: none">Validation using the</a>
<code>[xsl:]type</code> <a href="#validation-xsl-type" style=
"text-decoration: none">Attribute</a></h5>
<p>The <code>[xsl:]type</code> attribute takes as its value a
<code>QName</code>. This <span class="verb">must</span> be the name
of a type definition included in the <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet. If the QName has no prefix, it is expanded using
the default namespace established using the effective
<code>[xsl:]xpath-default-namespace</code> attribute if there is
one; otherwise, it is taken as being a name in no namespace.</p>
<p>If the <code>[xsl:]type</code> attribute is present, then the
newly constructed element or attribute is validated against the
type definition identified by this attribute.</p>
<ul>
<li>
<p>In the case of an element, schema-validity assessment is carried
out according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Element)",
clauses 1.2 and 2), using this type definition as the
"processor-stipulated type definition". The element is considered
valid if the result of the schema validity assessment is a PSVI in
which the relevant element node has a <code>validity</code>
property whose value is <code>valid</code>.</p>
</li>
<li>
<p>In the case of an attribute, the attribute is considered valid
if (in the terminology of XML Schema) the attribute's normalized
value is locally valid with respect to that type definition
according to the rules for "String Valid" (<a href=
"#xmlschema-1">[XML Schema Part 1]</a>, section 3.14.4).
(Normalization here refers to the process of normalizing whitespace
according to the rules of the <code>whiteSpace</code> facet for the
datatype).</p>
</li>
<li>
<p>If the element or attribute is not considered valid, as defined
above, the transformation fails <span class="error">[see <a href=
"#err-XTTE1540">ERR XTTE1540</a>]</span>.</p>
</li>
</ul>
<p>If an element node is validated against the type
<code>xs:untyped</code>, the effect is the same as specifying
<code>validation="strip"</code>: that is, the elements and
attributes in the subtree rooted at the target element are copied
with a type annotation of <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> respectively.</p>
<p>If an element or attribute node is validated against the type
<code>xs:untypedAtomic</code>, the effect is the same as specifying
<code>[xsl:]type="xs:string"</code> except that when validation
succeeds, the returned element or attribute has a type annotation
of <code>xs:untypedAtomic</code>. Validation fails in the case of
an element with element children.</p>
<p><a name="err-XTSE1520" id="err-XTSE1520"><span class=
"error">[ERR XTSE1520]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>type</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:type</code> attribute of a literal
result element, is not a valid <code>QName</code>, or if it uses a
prefix that is not defined in an in-scope namespace declaration, or
if the QName is not the name of a type definition included in the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet.</p>
<p><a name="err-XTSE1530" id="err-XTSE1530"><span class=
"error">[ERR XTSE1530]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>type</code> attribute of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
refers to a complex type definition.</p>
<p><a name="err-XTTE1535" id="err-XTTE1535"><span class=
"error">[ERR XTTE1535]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the value
of the <code>type</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction refers
to a complex type definition and one or more of the items being
copied is an attribute node.</p>
<p><a name="err-XTTE1540" id="err-XTTE1540"><span class=
"error">[ERR XTTE1540]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an
<code>[xsl:]type</code> attribute is defined for a constructed
element or attribute, and the outcome of schema validity assessment
against that type is that the <code>validity</code> property of
that element or attribute information item is other than
<code>valid</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Like other type errors, this error may be signaled statically if
it can be detected statically. For example, the instruction
<code>&lt;xsl:attribute name="dob"
type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
result in a static error being signaled. If the error is not
signaled statically, it will be signaled when the instruction is
evaluated.</p>
</div>
</div>
<div class="div4">
<h5><a name="validation-process" id=
"validation-process"></a>24.2.1.3 <a href="#validation-process"
style="text-decoration: none">The Validation Process</a></h5>
<p>As well as checking for validity against the schema, the
validity assessment process causes <a title="type annotation"
class="termref" href="#dt-annotation">type annotations</a> to be
associated with element and attribute nodes. If default values for
elements or attributes are defined in the schema, the validation
process will where necessary create new nodes containing these
default values.</p>
<p>Validation of an element or attribute node only takes into
account constraints on the content of the element or attribute.
Validation rules affecting the document as a whole are not applied.
Specifically, this means:</p>
<ul>
<li>
<p>The validation rule "Validation Root Valid (ID/IDREF)" is not
applied. This means that validation will not fail if there are
non-unique ID values or dangling IDREF values in the subtree being
validated.</p>
</li>
<li>
<p>The validation rule "Validation Rule: Identity-constraint
Satisfied" <span class="verb">should</span> be applied.</p>
</li>
<li>
<p>There is no check that the document contains unparsed entities
whose names match the values of nodes of type
<code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. (XSLT
<span>3.0</span> provides no facility to construct unparsed
entities within a tree.)</p>
</li>
<li>
<p>There is no check that the document contains notations whose
names match the values of nodes of type <code>xs:NOTATION</code>.
(The XDM data model makes no provision for notations to be
represented in the tree.)</p>
</li>
</ul>
<p>With these caveats, validating a newly constructed element,
using strict or lax validation, is equivalent to the following
steps:</p>
<ol class="enumar">
<li>
<p>The element is serialized to textual XML form, according to the
rules defined in <a href="#xslt-xquery-serialization-30">[XSLT and
XQuery Serialization]</a> using the XML output method, with all
parameters defaulted. Note that this process discards any existing
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotations</a>.</p>
</li>
<li>
<p>The resulting XML document is parsed to create an XML
Information Set (see <a href="#xml-infoset">[XML Information
Set]</a>.)</p>
</li>
<li>
<p>The Information Set produced in the previous step is validated
according to the rules in <a href="#xmlschema-1">[XML Schema Part
1]</a>. The result of this step is a Post-Schema Validation Infoset
(PSVI). If the validation process is not successful (as defined
above), a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is raised.</p>
</li>
<li>
<p>The PSVI produced in the previous step is converted back into
the XDM data model by the mapping described in <a href=
"#xpath-datamodel-30">[Data Model]</a> (<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#PSVI2Types">Section 3.3.1
Mapping PSVI Additions to Node Properties</a>
<sup><small>DM30</small></sup>). This process creates nodes with
simple or complex <a title="type annotation" class="termref" href=
"#dt-annotation">type annotations</a> based on the types
established during schema validation.</p>
</li>
</ol>
<p>Validating an attribute using strict or lax validation requires
a modified version of this procedure. A copy of the attribute is
first added to an element node that is created for the purpose, and
namespace fixup (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>) is performed on this element node. The name of this
element is of no consequence, but it must be the same as the name
of a synthesized element declaration of the form:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></div>
<p>where A is the name of the attribute being validated.</p>
<p>This synthetic element is then validated using the procedure
given above for validating elements, and if it is found to be
valid, a copy of the validated attribute is made, retaining its
<a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a>, but detaching it from the
containing element (and thus, from any namespace nodes).</p>
<p>The XDM data model does not permit an attribute node with no
parent to have a typed value that includes a namespace-qualified
name, that is, a value whose type is derived from
<code>xs:QName</code> or <code>xs:NOTATION</code>. This restriction
is imposed because these types rely on the namespace nodes of a
containing element to resolve namespace prefixes. Therefore, it is
an error to validate a parentless attribute against such a type.
This affects the instructions <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, and <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>.</p>
<p><a name="err-XTTE1545" id="err-XTTE1545"><span class=
"error">[ERR XTTE1545]</span></a> A <a title="type error" class=
"termref" href="#dt-type-error">type error</a> occurs if a
<code>type</code> or <code>validation</code> attribute is defined
(explicitly or implicitly) for an instruction that constructs a new
attribute node, if the effect of this is to cause the attribute
value to be validated against a type that is derived from, or
constructed by list or union from, the primitive types
<code>xs:QName</code> or <code>xs:NOTATION</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="validating-document-nodes" id=
"validating-document-nodes"></a>24.2.2 <a href=
"#validating-document-nodes" style=
"text-decoration: none">Validating Document Nodes</a></h4>
<p>It is possible to apply validation to a document node. This
happens when a new document node is constructed by one of the
instructions <span><a href=
"#element-stream"><code>xsl:stream</code></a></span>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<a href="#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, and this
instruction has a <code>type</code> attribute, or a
<code>validation</code> attribute with the value
<code>strict</code> or <code>lax</code>.</p>
<p>Document-level validation is not applied to the document node
that is created implicitly when a variable-binding element has no
<code>select</code> attribute and no <code>as</code> attribute (see
<a href="#temporary-trees"><i>9.4 Creating Implicit Document
Nodes</i></a>). This is equivalent to using
<code>validation="preserve"</code> on <a href=
"#element-document"><code>xsl:document</code></a>: nodes within
such trees retain their <a title="type annotation" class="termref"
href="#dt-annotation">type annotation</a>. Similarly, validation is
not applied to document nodes created using <a href=
"#element-message"><code>xsl:message</code></a> <span>or <a href=
"#element-assert"><code>xsl:assert</code></a></span>.</p>
<p>The values <code>validation="preserve"</code> and
<code>validation="strip"</code> do not request validation. In the
first case, all element and attribute nodes within the tree rooted
at the new document node retain their <a title="type annotation"
class="termref" href="#dt-annotation">type annotations</a>. In the
second case, elements within the tree have their type annotation
set to <code>xs:untyped</code>, while attributes have their type
annotation set to <code>xs:untypedAtomic</code>.</p>
<p>When validation is requested for a document node (that is, when
<code>validation</code> is set to <code>strict</code> or
<code>lax</code>, or when a <code>type</code> attribute is
present), the following processing takes place:</p>
<ul>
<li>
<p><a name="err-XTTE1550" id="err-XTTE1550"><span class=
"error">[ERR XTTE1550]</span></a> A <a title="type error" class=
"termref" href="#dt-type-error">type error</a> occurs unless the
children of the document node comprise exactly one element node, no
text nodes, and zero or more comment and processing instruction
nodes, in any order.</p>
</li>
<li>
<p>The single element node child is validated, using the supplied
values of the <code>validation</code> and <code>type</code>
attributes, as described in <a href=
"#validating-constructed-nodes"><i>24.2.1 Validating Constructed
Elements and Attributes</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>type</code> attribute on <span><a href=
"#element-stream"><code>xsl:stream</code></a></span>, <a href=
"#element-document"><code>xsl:document</code></a> and <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
and on <a href="#element-copy"><code>xsl:copy</code></a> and
<a href="#element-copy-of"><code>xsl:copy-of</code></a> when
copying a document node, thus refers to the required type of the
element node that is the only element child of the document node.
It does not refer to the type of the document node itself.</p>
</div>
</li>
<li>
<p>The validation rule "Validation Root Valid (ID/IDREF)" is
applied to the single element node child of the document node. This
means that validation will fail if there are non-unique ID values
or dangling IDREF values in the document tree.</p>
</li>
<li>
<p>Identity constraints, as defined in section 3.11 of <a href=
"#xmlschema-1">[XML Schema Part 1]</a>, are checked. (This refers
to constraints defined using <code>xs:unique</code>,
<code>xs:key</code>, and <code>xs:keyref</code>.)</p>
</li>
<li>
<p>There is no check that the tree contains unparsed entities whose
names match the values of nodes of type <code>xs:ENTITY</code> or
<code>xs:ENTITIES</code>. This is because there is no facility in
XSLT <span>3.0</span> to create unparsed entities in a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>. It is possible to add unparsed entity declarations to the
result document by referencing a suitable DOCTYPE during
serialization.</p>
</li>
<li>
<p>There is no check that the document contains notations whose
names match the values of nodes of type <code>xs:NOTATION</code>.
This is because notations are not part of the XDM data model. It is
possible to add notations to the result document by referencing a
suitable DOCTYPE during serialization.</p>
</li>
<li>
<p>All other children of the document node (comments and processing
instructions) are copied unchanged.</p>
</li>
</ul>
<p><a name="err-XTTE1555" id="err-XTTE1555"><span class=
"error">[ERR XTTE1555]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if, when
validating a document node, document-level constraints (such as
ID/IDREF constraints) are not satisfied.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="serialization" id="serialization"></a>25 <a href=
"#serialization" style=
"text-decoration: none">Serialization</a></h2>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">may</span> output
a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as a sequence of
octets, although it is not <span class="verb">required</span> to be
able to do so (see <a href="#conformance"><i>26
Conformance</i></a>). Stylesheet authors can use <a href=
"#element-output"><code>xsl:output</code></a> declarations to
specify how they wish result trees to be serialized. If a processor
serializes a final result tree, it <span class="verb">must</span>
do so as specified by these declarations.</p>
<p>The rules governing the output of the serializer are defined in
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. The serialization is controlled using a number
of serialization parameters. The values of these serialization
parameters may be set within the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, using the <a href=
"#element-output"><code>xsl:output</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations.</p>
<p class="element-syntax"><a name="element-output" id=
"element-output"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:output<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;method? = "xml" | "html" | "xhtml" | "text" |
<var>eqname</var><br />
&#160;&#160;byte-order-mark? = "yes" | "no"<br />
&#160;&#160;cdata-section-elements? = <var>eqnames</var><br />
&#160;&#160;doctype-public? = <var>string</var><br />
&#160;&#160;doctype-system? = <var>string</var><br />
&#160;&#160;encoding? = <var>string</var><br />
&#160;&#160;escape-uri-attributes? = "yes" | "no"<br />
&#160;&#160;html-version? = <var>decimal</var><br />
&#160;&#160;include-content-type? = "yes" | "no"<br />
&#160;&#160;indent? = "yes" | "no"<br />
&#160;&#160;item-separator? = <var>string</var><br />
&#160;&#160;media-type? = <var>string</var><br />
&#160;&#160;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" |
"fully-normalized" | "none" | <var>nmtoken</var><br />
&#160;&#160;omit-xml-declaration? = "yes" | "no"<br />
&#160;&#160;parameter-document? = <var>uri</var><br />
&#160;&#160;standalone? = "yes" | "no" | "omit"<br />
&#160;&#160;suppress-indentation? = <var>eqnames</var><br />
&#160;&#160;undeclare-prefixes? = "yes" | "no"<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;version? = <var>nmtoken</var>&#160;/&gt;</code></p>
<p>The <a href="#element-output"><code>xsl:output</code></a>
declaration is optional; if used, it <span class="verb">must</span>
always appear as a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element within a stylesheet
module.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> may contain multiple <a href=
"#element-output"><code>xsl:output</code></a> declarations and may
include or import stylesheet modules that also contain <a href=
"#element-output"><code>xsl:output</code></a> declarations. The
name of an <a href="#element-output"><code>xsl:output</code></a>
declaration is the value of its <code>name</code> attribute, if
any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-output-definition" id="dt-output-definition" title=
"output definition"></a>All the <a href=
"#element-output"><code>xsl:output</code></a> declarations
<span>within a <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name are
grouped into a named <b>output definition</b>; those that have no
name are grouped into a single unnamed output
definition.<span class="definition">]</span></p>
<p>An output definition is scoped to a package. If this is a
library package the output definition applies only to <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions within the same package. If it is the top-level
package, the output definition applies to <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions within the same package and also to the implicit
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p>A stylesheet always includes an unnamed <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a>; in the absence of an
unnamed <a href="#element-output"><code>xsl:output</code></a>
declaration, the unnamed output definition is equivalent to the one
that would be used if the stylesheet contained an <a href=
"#element-output"><code>xsl:output</code></a> declaration having no
attributes.</p>
<p>A named <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> is used when its name
matches the <code>format</code> attribute used in an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element. The unnamed output definition is used when an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element omits the <code>format</code> attribute. It is also used
when serializing the <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> that is created
implicitly in the absence of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element.</p>
<p>All the <a href="#element-output"><code>xsl:output</code></a>
elements making up an <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> are effectively
merged. For those attributes whose values are namespace-sensitive,
the merging is done after <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QNames</a> have been converted
into <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QNames</a>. For the
<code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span> attributes, the output
definition uses the union of the values from all the constituent
<a href="#element-output"><code>xsl:output</code></a> declarations.
For the <code>use-character-maps</code> attribute, the output
definition uses the concatenation of the sequences of <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QNames</a> values from all the constituent <a href=
"#element-output"><code>xsl:output</code></a> declarations, taking
them in order of increasing <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>, or
where several have the same import precedence, in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>. For other
attributes, the <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> uses the value of
that attribute from the <a href=
"#element-output"><code>xsl:output</code></a> declaration with the
highest <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
<p>The <code>parameter-document</code> attribute allows
serialization parameters to be supplied in an external document.
The external document must contain an
<code>output:serialization-parameters</code> element with the
format described in <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">
Section 3.1 Setting Serialization Parameters by Means of a Data
Model Instance</a> <sup><small>SER30</small></sup>, and the
parameters are interpreted as described in that specification.</p>
<p>If present, the URI supplied in the
<code>parameter-document</code> attribute is dereferenced, after
resolution against the base URI of the <code>xsl:output</code>
element if it is a relative reference. If the location of the
stylesheet at development time is different from the deployed
location, any relative reference should be resolved against the
deployed location. A serialization error occurs if the result of
dereferencing the URI is ill-formed or invalid; but if no document
can be found at the specified location, the attribute
<code>may</code> be ignored.</p>
<p>A serialization parameter specified in the
<code>parameter-document</code> takes precedence over a value
supplied directly in the output declaration, except that the values
of the <code>cdata-section-elements</code> and
<code>suppress-indentation</code> attributes are merged in the same
way as when multiple <code>xsl:output</code> declarations are
merged.</p>
<p><a name="err-XTSE1560" id="err-XTSE1560"><span class=
"error">[ERR XTSE1560]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two
<a href="#element-output"><code>xsl:output</code></a> declarations
within an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specify explicit
values for the same attribute (other than
<code>cdata-section-elements</code> and
<code>use-character-maps</code>), with the values of the attributes
being not equal, unless there is another <a href=
"#element-output"><code>xsl:output</code></a> declaration within
the same <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> that has higher
import precedence and that specifies an explicit value for the same
attribute.</p>
<p>If none of the <a href=
"#element-output"><code>xsl:output</code></a> declarations within
an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specifies a value for
a particular attribute, then the corresponding serialization
parameter takes a default value. The default value depends on the
chosen output method.</p>
<p>There are some serialization parameters that apply to some
output methods but not to others. For example, the
<code>indent</code> attribute has no effect on the
<code>text</code> output method. If a value is supplied for an
attribute that is inapplicable to the output method, its value is
not passed to the serializer. The processor <span class=
"verb">may</span> validate the value of such an attribute, but is
not <span class="verb">required</span> to do so.</p>
<p>An implementation <span class="verb">may</span> allow the
attributes of the <a href=
"#element-output"><code>xsl:output</code></a> declaration to be
overridden, or the default values to be changed, using the API that
controls the transformation.</p>
<p>The location to which <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result trees</a> are
serialized (whether in filestore or elsewhere) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> (which in
practice <span class="verb">may</span> mean that it is controlled
using an implementation-defined API). However, these locations
<span class="verb">must</span> satisfy the constraint that when two
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are both created
(implicitly or explicitly) using relative URI
<span>references</span> in the <code>href</code> attribute of the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, then these relative URI <span>references</span> may be
used to construct references from one tree to the other, and such
references <span class="verb">must</span> remain valid when both
result trees are serialized.</p>
<p>The <code>method</code> attribute on the <a href=
"#element-output"><code>xsl:output</code></a> element identifies
the overall method that is to be used for outputting the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p><a name="err-XTSE1570" id="err-XTSE1570"><span class=
"error">[ERR XTSE1570]</span></a> The value <span class=
"verb">must</span> (if present) be a valid <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a>. If it is a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> with no a prefix, then it identifies a method specified
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> and <span class="verb">must</span> be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, or
<code>text</code>. If it is a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> with a prefix,
then the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>; the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> identifies the output
method; the behavior in this case is not specified by this
document.</p>
<p>The default for the <code>method</code> attribute depends on the
contents of the tree being serialized, and is chosen as follows. If
the document node of the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> has an
element child, and any text nodes preceding the first element child
of the document node of the result tree contain only whitespace
characters, then:</p>
<ul>
<li>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of this first element child
has local part <code>html</code> (in lower case), and namespace URI
<code>http://www.w3.org/1999/xhtml</code>, then the default output
method is normally <code>xhtml</code>. However, if the
<code>version</code> attribute of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element of
the <a title="principal stylesheet module" class="termref" href=
"#dt-principal-stylesheet-module">principal stylesheet module</a>
has the value <code>1.0</code>, and if the result tree is generated
implicitly (rather than by an explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction), then the default output method in this situation is
<code>xml</code>.</p>
</li>
<li>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of this first element child
has local part <code>html</code> (in any combination of upper and
lower case) and a null namespace URI, then the default output
method is <code>html</code>.</p>
</li>
</ul>
<p>In all other cases, the default output method is
<code>xml</code>.</p>
<p>The default output method is used if the selected <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> does not include a
<code>method</code> attribute.</p>
<p>The other attributes on <a href=
"#element-output"><code>xsl:output</code></a> provide parameters
for the output method. The following attributes are allowed:</p>
<ul>
<li>
<p>The value of the <code>encoding</code> attribute provides the
value of the <code>encoding</code> parameter to the serialization
method. The default value is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>, but in the
case of the <code>xml</code> and <code>xhtml</code> methods it
<span class="verb">must</span> be either <code>UTF-8</code> or
<code>UTF-16</code>.</p>
</li>
<li>
<p>The <code>byte-order-mark</code> attribute defines whether a
byte order mark is written at the start of the file. If the value
<code>yes</code> is specified, a byte order mark is written; if
<code>no</code> is specified, no byte order mark is written. The
default value depends on the encoding used. If the encoding is
<code>UTF-16</code>, the default is <code>yes</code>; for
<code>UTF-8</code> it is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, and for
all other encodings it is <code>no</code>. The value of the byte
order mark indicates whether high order bytes are written before or
after low order bytes; the actual byte order used is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, unless
it is defined by the selected encoding.</p>
</li>
<li>
<p>The <code>cdata-section-elements</code> attribute is a
whitespace-separated list of QNames. The default value is an empty
list. After expansion of these names using the in-scope namespace
declarations for the <a href=
"#element-output"><code>xsl:output</code></a> declaration in which
they appear, this list of names provides the value of the
<code>cdata-section-elements</code> parameter to the serialization
method. In the case of an unprefixed name, the default namespace
(that is, the namespace declared using <code>xmlns="uri"</code>) is
used.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This differs from the rule for most other QNames used in a
stylesheet. The reason is that these names refer to elements in the
result document, and therefore follow the same convention as the
name of a literal result element or the <code>name</code> attribute
of <a href="#element-element"><code>xsl:element</code></a>.</p>
</div>
</li>
<li>
<p>The value of the <code>doctype-system</code> attribute provides
the value of the <code>doctype-system</code> parameter to the
serialization method. <span>If the attribute is absent or has a
zero-length string as its value, then the serialization parameter
is not set (is "absent").</span></p>
</li>
<li>
<p>The value of the <code>doctype-public</code> attribute provides
the value of the <code>doctype-public</code> parameter to the
serialization method. <span>If the attribute is absent or has a
zero-length string as its value, then the serialization parameter
is not set (is "absent").</span></p>
<p>The value of <code>doctype-public</code> must conform to the
rules for a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PubidLiteral">PubidLiteral</a><sup><small>XML</small></sup>
(see <a href="#REC-xml">[XML 1.0]</a>).</p>
</li>
<li>
<p>The value of the <code>escape-uri-attributes</code> attribute
provides the value of the <code>escape-uri-attributes</code>
parameter to the serialization method. The default value is
<code>yes</code>.</p>
</li>
<li>
<p>The value of the <code>html-version</code> attribute provides
the value of the <code>html-version</code> parameter to the
serialization method. The set of permitted values, and the default
value, are <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. A
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> will be reported
if the requested version is not supported by the
implementation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This serialization parameter is new in version 3.0. If it is
absent, the html output method uses the value of the
<code>version</code> parameter in its place. For XHTML
serialization, the <code>html-version</code> parameter indicates
the version of XHTML to be used, while the <code>version</code>
parameter indicates the version of XML.</p>
</div>
</li>
<li>
<p>The value of the <code>include-content-type</code> attribute
provides the value of the <code>include-content-type</code>
parameter to the serialization method. The default value is
<code>yes</code>.</p>
</li>
<li>
<p>The value of the <code>indent</code> attribute provides the
value of the <code>indent</code> parameter to the serialization
method. The default value is <code>yes</code> in the case of the
<code>html</code> and <code>xhtml</code> output methods,
<code>no</code> in the case of the <code>xml</code> output
method.</p>
</li>
<li>
<p>The value of the <code>item-separator</code> attribute provides
the value of the <code>item-separator</code> parameter to the
serialization method. The value of the serialization parameter can
be any string (including a zero-length string), or absent. To set
the parameter to absent, the <code>item-separator</code> attribute
can either be omitted, or set to the special value
<code>item-separator="#absent"</code>; it is not possible to set
the value of the serialization parameter to the literal 7-character
string "#absent".</p>
</li>
<li>
<p>The value of the <code>media-type</code> attribute provides the
value of the <code>media-type</code> parameter to the serialization
method. The default value is <code>text/xml</code> in the case of
the <code>xml</code> output method, <code>text/html</code> in the
case of the <code>html</code> and <code>xhtml</code> output
methods, and <code>text/plain</code> in the case of the
<code>text</code> output method.</p>
</li>
<li>
<p>The value of the <code>normalization-form</code> attribute
provides the value of the <code>normalization-form</code> parameter
to the serialization method. A value that is an
<code>NMTOKEN</code> other than one of those enumerated for the
<code>normalization-form</code> attribute specifies an
implementation-defined normalization form; the behavior in this
case is not specified by this document. The default value is
<code>none</code>.</p>
</li>
<li>
<p>The value of the <code>omit-xml-declaration</code> attribute
provides the value of the <code>omit-xml-declaration</code>
parameter to the serialization method. The default value is
<code>no</code>.</p>
</li>
<li>
<p>The value of the <code>standalone</code> attribute provides the
value of the <code>standalone</code> parameter to the serialization
method. The default value is <code>omit</code>; this means that no
<code>standalone</code> attribute is to be included in the XML
declaration.</p>
</li>
<li>
<p>The <code>suppress-indentation</code> attribute is a
whitespace-separated list of QNames. The default value is an empty
list. After expansion of these names using the in-scope namespace
declarations for the <a href=
"#element-output"><code>xsl:output</code></a> declaration in which
they appear, this list of names provides the value of the
<code>suppress-indentation</code> parameter to the serialization
method. In the case of an unprefixed name, the default namespace
(that is, the namespace declared using <code>xmlns="uri"</code>) is
used.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This differs from the rule for most other QNames used in a
stylesheet. The reason is that these names refer to elements in the
result document, and therefore follow the same convention as the
name of a literal result element or the <code>name</code> attribute
of <a href="#element-element"><code>xsl:element</code></a>.</p>
</div>
</li>
<li>
<p>The <code>undeclare-prefixes</code> attribute is relevant only
when producing output with <code>method="xml"</code> and
<code>version="1.1"</code> (or later). It defines whether namespace
undeclarations (of the form <code>xmlns:foo=""</code>) <span class=
"verb">should</span> be output when a child element has no
namespace node with the same name (that is, namespace prefix) as a
namespace node of its parent element. The default value is
<code>no</code>: this means that namespace undeclarations are not
output, which has the effect that when the resulting XML is
reparsed, the new tree may contain namespace nodes on the child
element that were not there in the original tree before
serialization.</p>
</li>
<li>
<p>The <code>use-character-maps</code> attribute provides a list of
named character maps that are used in conjunction with this
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>. The way this
attribute is used is described in <a href="#character-maps"><i>25.1
Character Maps</i></a>. The default value is an empty list.</p>
</li>
<li>
<p>The value of the <code>version</code> attribute provides the
value of the <code>version</code> parameter to the serialization
method. The set of permitted values, and the default value, are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. A
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> will be reported
if the requested version is not supported by the
implementation.</p>
</li>
</ul>
<p>The <code>item-separator</code> serialization parameter defined
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> is not available in <a href=
"#element-output"><code>xsl:output</code></a>; it is not
applicable, because the sequence that is serialized by XSLT is
always a singleton document node. Formally therefore, the
serializer is always invoked passing an empty string as the value
of this parameter.</p>
<p>If the processor performs serialization, then it must signal any
serialization errors that occur. These have the same effect as
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic errors</a>: that is, the processor must
signal the error and must not finish as if the transformation had
been successful.</p>
<div class="div2">
<h3><a name="character-maps" id="character-maps"></a>25.1 <a href=
"#character-maps" style="text-decoration: none">Character
Maps</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-character-map" id="dt-character-map" title=
"character map"></a>A <b>character map</b> allows a specific
character appearing in a text or attribute node in the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to be substituted by
a specified string of characters during serialization.<span class=
"definition">]</span> The effect of character maps is defined in
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>.</p>
<p>The character map that is supplied as a parameter to the
serializer is determined from the <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements referenced from the <a href=
"#element-output"><code>xsl:output</code></a> declaration for the
selected <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>.</p>
<p>The <a href=
"#element-character-map"><code>xsl:character-map</code></a> element
is a declaration that may appear as a child of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
<p class="element-syntax"><a name="element-character-map" id=
"element-character-map"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:character-map<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-character-maps? =
<var>eqnames</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-output-character">xsl:output-character</a>*) --&gt;<br />
&lt;/xsl:character-map&gt;</code></p>
<p>The <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declaration declares a character map with a name and a set of
character mappings. The character mappings are specified by means
of <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements contained either directly within the <a href=
"#element-character-map"><code>xsl:character-map</code></a>
element, or in further character maps referenced in the
<code>use-character-maps</code> attribute.</p>
<p>The <span class="verb">required</span> <code>name</code>
attribute provides a name for the character map. When a character
map is used by an <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> or another
character map, the character map with the highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p>The name of a character map is local to the <a title="package"
class="termref" href="#dt-package">package</a> in which its
declaration appears; it may be referenced only from within the same
package.</p>
<p><a name="err-XTSE1580" id="err-XTSE1580"><span class=
"error">[ERR XTSE1580]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains two or more character maps
with the same name and the same <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>,
unless it also contains another character map with the same name
and higher import precedence.</p>
<p>The optional <code>use-character-maps</code> attribute lists the
names of further character maps that are included into this
character map.</p>
<p><a name="err-XTSE1590" id="err-XTSE1590"><span class=
"error">[ERR XTSE1590]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a name
in the <code>use-character-maps</code> attribute of the <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements does not match the <code>name</code> attribute of any
<a href="#element-character-map"><code>xsl:character-map</code></a>
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
<p><a name="err-XTSE1600" id="err-XTSE1600"><span class=
"error">[ERR XTSE1600]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
character map references itself, directly or indirectly, via a name
in the <code>use-character-maps</code> attribute.</p>
<p>It is not an error if the same character map is referenced more
than once, directly or indirectly.</p>
<p>An <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, after recursive
expansion of character maps referenced via its
<code>use-character-maps</code> attribute, may contain several
mappings for the same character. In this situation, the last
character mapping takes precedence. To establish the ordering, the
following rules are used:</p>
<ul>
<li>
<p>Within a single <a href=
"#element-character-map"><code>xsl:character-map</code></a>
element, the characters defined in character maps referenced in the
<code>use-character-maps</code> attribute are considered before the
characters defined in the child <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements.</p>
</li>
<li>
<p>The character maps referenced in a single
<code>use-character-maps</code> attribute are considered in the
order in which they are listed in that attribute. The expansion is
depth-first: each referenced character map is fully expanded before
the next one is considered.</p>
</li>
<li>
<p>Two <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements appearing as children of the same <a href=
"#element-character-map"><code>xsl:character-map</code></a> element
are considered in document order.</p>
</li>
</ul>
<p>The <a href=
"#element-output-character"><code>xsl:output-character</code></a>
element is defined as follows:</p>
<p class="element-syntax"><a name="element-output-character" id=
"element-output-character"></a><code>&lt;xsl:output-character<br />
&#160;&#160;<b>character</b> = <var>char</var><br />
&#160;&#160;<b>string</b> = <var>string</var>&#160;/&gt;</code></p>
<p>The character map that is passed as a parameter to the
serializer contains a mapping for the character specified in the
<code>character</code> attribute to the string specified in the
<code>string</code> attribute.</p>
<p>Character mapping is not applied to characters for which output
escaping has been disabled as described in <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>.</p>
<p>If a character is mapped, then it is not subjected to XML or
HTML escaping.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60180" id=
"d7e60180"></a>Example: Using Character Maps to Generate Non-XML
Output</div>
<p>Character maps can be useful when producing serialized output in
a format that resembles, but is not strictly conformant to, HTML or
XML. For example, when the output is a JSP page, there might be a
need to generate the output:</p>
<div class="exampleInner">
<pre>
&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;
</pre></div>
<p>Although this output is not well-formed XML or HTML, it is valid
in Java Server Pages. This can be achieved by allocating three
Unicode characters (which are not needed for any other purpose) to
represent the strings <code>&lt;%</code>, <code>%&gt;</code>, and
<code>"</code>, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;
</pre></div>
<p>When this character map is referenced in the <a href=
"#element-output"><code>xsl:output</code></a> declaration, the
required output can be produced by writing the following in the
stylesheet:</p>
<div class="exampleInner">
<pre>
&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;
</pre></div>
<p>This works on the assumption that when an apostrophe or
quotation mark is generated as part of an attribute value by the
use of character maps, the serializer will (where possible) use the
other choice of delimiter around the attribute value.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60209" id=
"d7e60209"></a>Example: Constructing a Composite Character
Map</div>
<p>The following example illustrates a composite character map
constructed in a modular fashion:</p>
<div class="exampleInner">
<pre>
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When character maps are used, there is no guarantee that the
serialized output will be well-formed XML (or HTML). Furthermore,
the fact that the result tree was validated against a schema gives
no guarantee that the serialized output will still be valid against
the same schema. Conversely, it is possible to use character maps
to produce schema-valid output from a result tree that would fail
validation.</p>
</div>
</div>
<div class="div2">
<h3><a name="disable-output-escaping" id=
"disable-output-escaping"></a>25.2 <a href=
"#disable-output-escaping" style="text-decoration: none">Disabling
Output Escaping</a></h3>
<p>Normally, when using the XML, HTML, or XHTML output method, the
serializer will escape special characters such as
<code>&amp;</code> and <code>&lt;</code> when outputting text
nodes. This ensures that the output is well-formed. However, it is
sometimes convenient to be able to produce output that is almost,
but not quite well-formed XML; for example, the output may include
ill-formed sections which are intended to be transformed into
well-formed XML by a subsequent non-XML-aware process. For this
reason, XSLT defines a mechanism for disabling output escaping.</p>
<p>This feature is <a title="deprecated" class="termref" href=
"#dt-deprecated">deprecated</a>.</p>
<p>This is an optional feature: it is not <span class=
"verb">required</span> that a XSLT processor that implements the
serialization option <span class="verb">should</span> offer the
ability to disable output escaping, and there is no conformance
level that requires this feature.</p>
<p>This feature requires an extension to the serializer described
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. Conceptually, the <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
provides an additional boolean property
<code>disable-escaping</code> associated with every character in a
text node. When this property is set, the normal action of the
serializer to escape special characters such as <code>&amp;</code>
and <code>&lt;</code> is suppressed.</p>
<p>An <a href="#element-value-of"><code>xsl:value-of</code></a> or
<a href="#element-text"><code>xsl:text</code></a> element may have
a <code>disable-output-escaping</code> attribute; the allowed
values are <code>yes</code> or <code>no</code>. The default is
<code>no</code>; if the value is <code>yes</code>, then every
character in the text node generated by evaluating the <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> element <span class=
"verb">should</span> have the <code>disable-escaping</code>
property set.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60297" id=
"d7e60297"></a>Example: Disable Output Escaping</div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
</pre></div>
<p>should generate the single character <code>&lt;</code>.</p>
</div>
<p>If output escaping is disabled for an <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> instruction evaluated
when <a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> is in
effect, the request to disable output escaping is ignored.</p>
<p>Similarly, if an <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> instruction specifies
that output escaping is to be disabled when writing to a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> that is not being
serialized, the request to disable output escaping is ignored.</p>
<p>If output escaping is disabled for text within an element that
would normally be output using a CDATA section, because the element
is listed in the <code>cdata-section-elements</code>, then the
relevant text will not be included in a CDATA section. In effect,
CDATA is treated as an alternative escaping mechanism, which is
disabled by the <code>disable-output-escaping</code> option.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60339" id=
"d7e60339"></a>Example: Interaction of Output Escaping and
CDATA</div>
<p>For example, if <code>&lt;xsl:output
cdata-section-elements="title"/&gt;</code> is specified, then the
following instructions:</p>
<div class="exampleInner">
<pre>
&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;
</pre></div>
<p>should generate the output:</p>
<div class="exampleInner">
<pre>
&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;
</pre></div>
</div>
<p>The <code>disable-output-escaping</code> attribute may be used
with the <code>html</code> output method as well as with the
<code>xml</code> output method. The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since
this method does not perform any output escaping.</p>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> will only be able to disable output
escaping if it controls how the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> is
output. This might not always be the case. For example, the result
tree might be used as a <a title="source tree" class="termref"
href="#dt-source-tree">source tree</a> for another XSLT
transformation instead of being output. It is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
(and under what circumstances) disabling output escaping is
supported. <span>If disabling output escaping is not supported, any
request to disable output escaping is ignored.</span></p>
<p>If output escaping is disabled for a character that is not
representable in the encoding that the <a title="processor" class=
"termref" href="#dt-processor">processor</a> is using for output,
the request to disable output escaping is ignored in respect of
that character.</p>
<p>Since disabling output escaping might not work with all
implementations and can result in XML that is not well-formed, it
<span class="verb">should</span> be used only when there is no
alternative.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When disable-output-escaping is used, there is no guarantee that
the serialized output will be well-formed XML (or HTML).
Furthermore, the fact that the result tree was validated against a
schema gives no guarantee that the serialized output will still be
valid against the same schema. Conversely, it is possible to use
disable-output-escaping to produce schema-valid output from a
result tree that would fail validation.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facility to define character maps for use during
serialization, as described in <a href="#character-maps"><i>25.1
Character Maps</i></a>, has been produced as an alternative
mechanism that can be used in many situations where disabling of
output escaping was previously necessary, without the same
difficulties.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="conformance" id="conformance"></a>26 <a href=
"#conformance" style="text-decoration: none">Conformance</a></h2>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> that claims conformance with this
specification <span class="verb">must</span> satisfy the
conformance requirements for a <a title="basic XSLT processor"
class="termref" href="#dt-basic-xslt-processor">basic XSLT
processor</a> and for each of the optional features with which it
claims conformance.</p>
<p>The following optional features are defined:</p>
<ol class="enumar">
<li>
<p>The schema-awareness feature, defined in <a href=
"#schema-aware-conformance"><i>26.2 Schema-Awareness Conformance
Feature</i></a></p>
</li>
<li>
<p>The serialization feature, defined in <a href=
"#serialization-feature"><i>26.3 Serialization Feature</i></a></p>
</li>
<li>
<p>The backwards compatibility feature, defined in <a href=
"#backwards-compatibility-feature"><i>26.4 Compatibility
Features</i></a></p>
</li>
<li>
<p>The streaming feature, defined in <a href=
"#streaming-feature"><i>26.5 Streaming Feature</i></a>.</p>
</li>
<li>
<p>The dynamic evaluation feature, defined in <a href=
"#dynamic-evaluation-feature"><i>26.6 Dynamic Evaluation
Feature</i></a>.</p>
</li>
<li>
<p>The XQuery invocation feature, defined in <a href=
"#xquery-invocation-feature"><i>26.7 XQuery Invocation
Feature</i></a>.</p>
</li>
</ol>
<p>A processor that does not claim conformance with an optional
feature <span class="verb">must</span> satisfy the requirements for
processors that do not implement that feature.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no conformance level or feature defined in this
specification that requires implementation of the static typing
features described in <a href="#xpath-30">[XPath 3.0]</a>. An XSLT
processor may provide a user option to invoke static typing, but to
be conformant with this specification it must allow a stylesheet to
be processed with static typing disabled. The interaction of XSLT
stylesheets with the static typing feature of <span>XPath
3.0</span> has not been specified, so the results of using static
typing, if available, are implementation-defined.</p>
</div>
<p>An XSLT processor takes as its inputs a stylesheet and
<span>zero</span> or more XDM trees conforming to the data model
defined in <a href="#xpath-datamodel-30">[Data Model]</a>. It is
not <span class="verb">required</span> that the processor supports
any particular method of constructing XDM trees, but conformance
can only be tested if it provides a mechanism that enables XDM
trees representing the stylesheet and primary source document to be
constructed and supplied as input to the processor.</p>
<p>The output of the XSLT processor consists of zero or more
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>. It is not
<span class="verb">required</span> that the processor supports any
particular method of accessing a final result tree, but if it does
not support the serialization <span>feature</span>, conformance can
only be tested if it provides some alternative mechanism that
enables access to the results of the transformation.</p>
<p>Certain facilities in this specification are described as
producing <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> results. A
claim that asserts conformance with this specification <span class=
"verb">must</span> be accompanied by documentation stating the
effect of each implementation-defined feature. For convenience, a
non-normative checklist of implementation-defined features is
provided at <a href="#implementation-defined-features"><i>F
Checklist of Implementation-Defined Features</i></a>.</p>
<p>A conforming <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span> signal
any <a title="static error" class="termref" href=
"#dt-static-error">static error</a> occurring in the stylesheet, or
in any XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, except where specified otherwise
either for individual error conditions or under the general
provisions for <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> (see <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a>). After signaling such an error, the
processor <span class="verb">may</span> continue for the purpose of
signaling additional errors, but <span class="verb">must</span>
terminate abnormally without performing any transformation.</p>
<p>When a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the course of a
transformation, <span>and is not caught using <a href=
"#element-catch"><code>xsl:catch</code></a>,</span> the processor
<span class="verb">must</span> signal it and <span class=
"verb">must</span> eventually terminate abnormally. If a
recoverable error occurs, the processor <span class=
"verb">must</span> either signal it and terminate abnormally, or it
<span class="verb">must</span> take the defined recovery action and
continue processing.</p>
<p>Some errors, notably <a title="type error" class="termref" href=
"#dt-type-error">type errors</a>, <span class="verb">may</span> be
treated as <a title="static error" class="termref" href=
"#dt-static-error">static errors</a> or <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic errors</a> at the
discretion of the processor.</p>
<p>A conforming processor <span class="verb">may</span> impose
limits on the processing resources consumed by the processing of a
stylesheet.</p>
<div class="div2">
<h3><a name="basic-conformance" id="basic-conformance"></a>26.1
<a href="#basic-conformance" style="text-decoration: none">Basic
XSLT Processor</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-basic-xslt-processor" id="dt-basic-xslt-processor" title=
"basic XSLT processor"></a>A <b>basic XSLT processor</b> is an XSLT
processor that implements all the mandatory requirements of this
specification with the exception of constructs explicitly
associated with an optional feature.<span class=
"definition">]</span> These constructs are listed below.</p>
<p>The mandatory requirements of this specification are taken to
include the mandatory requirements of <span>XPath 3.0</span>, as
described in <a href="#xpath-30">[XPath 3.0]</a>. A requirement is
mandatory unless the specification includes wording (such as the
use of the words <span class="verb">should</span> or <span class=
"verb">may</span>) that clearly indicates that it is optional.</p>
</div>
<div class="div2">
<h3><a name="schema-aware-conformance" id=
"schema-aware-conformance"></a>26.2 <a href=
"#schema-aware-conformance" style=
"text-decoration: none">Schema-Awareness Conformance
Feature</a></h3>
<p>A conformant processor <span class="verb">must</span> either be
a conformant <a title="schema-aware XSLT processor" class="termref"
href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a> or a conformant <a title="non-schema-aware processor"
class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware
processor</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-aware-xslt-processor" id=
"dt-schema-aware-xslt-processor" title=
"schema-aware XSLT processor"></a>A <b>schema-aware XSLT
processor</b> is an XSLT processor that implements the mandatory
requirements of this specification connected with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type
attributes</code>, and the ability to handle input documents whose
nodes have type annotations other than <code>xs:untyped</code> and
<code>xs:untypedAtomic</code>. The mandatory requirements of this
specification are taken to include the mandatory requirements of
<span>XPath 3.0</span>, as described in <a href="#xpath-30">[XPath
3.0]</a>. A requirement is mandatory unless the specification
includes wording (such as the use of the words <span class=
"verb">should</span> or <span class="verb">may</span>) that clearly
indicates that it is optional.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-schema-aware-processor" id="dt-non-schema-aware-processor"
title="non-schema-aware processor"></a>A <b>non-schema-aware
processor</b> is a processor that does not claim conformance with
the schema-aware conformance feature. Such a processor <span class=
"verb">must</span> handle constructs associated with schema-aware
processing as described in this section.<span class=
"definition">]</span></p>
<p><a name="err-XTSE1650" id="err-XTSE1650"><span class=
"error">[ERR XTSE1650]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> includes an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A processor that rejects an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration will also reject any reference to a user-defined type
defined in a schema, or to a user-defined element or attribute
declaration; it will not, however, reject references to the
built-in types listed in <a href="#built-in-types"><i>3.15 Built-in
Types</i></a>.</p>
</div>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a> is
not able to validate input documents, and is not able to handle
input documents containing type annotations other than
<code>xs:untyped</code> or <code>xs:untypedAtomic</code>.
Therefore, such a processor <span class="verb">must</span> treat
<span>any <code>[xsl:]validation</code> attribute with a value of
<code>preserve</code> or <code>lax</code>, or a
<code>[xsl:]default-validation</code> attribute with a value of
<code>preserve</code></span> as if the value were
<code>strip</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The values <code>lax</code> and <code>preserve</code> indicate
that the validation to be applied depends on the calling
application, so it is appropriate for the request to be treated
differently by different kinds of processor. By contrast,
requesting <code>strict</code> validation, either through the
<code>[xsl:]validation</code> attribute or the <code>type</code>
attribute, indicates that the stylesheet is expecting to deal with
typed data, and therefore cannot be processed without performing
the validation.</p>
</div>
<p><a name="err-XTSE1660" id="err-XTSE1660"><span class=
"error">[ERR XTSE1660]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> includes an <code>[xsl:]type</code>
attribute, or an <code>[xsl:]validation</code> or
<code>[xsl:]default-validation</code> attribute with a value other
than <code>strip</code><span>, <code>preserve</code>, or
<code>lax</code></span>.</p>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
constrains the data model as follows:</p>
<ul>
<li>
<p>Atomic values <span class="verb">must</span> belong to one of
the atomic types listed in <a href="#built-in-types"><i>3.15
Built-in Types</i></a> (except as noted below).</p>
<p>An atomic value may also belong to an implementation-defined
type that has been added to the context for use with <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> or <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>.</p>
<p>The set of constructor functions available are limited to those
that construct values of the above atomic types.</p>
<p>The static context, which defines the full set of type names
recognized by an XSLT processor and also by the XPath processor,
includes these atomic types, plus <code>xs:anyType</code>,
<code>xs:anySimpleType</code>, <code>xs:untyped</code>, and
<code>xs:anyAtomicType</code>.</p>
</li>
<li>
<p>Element nodes <span class="verb">must</span> be annotated with
the <a title="type annotation" class="termref" href=
"#dt-annotation">type annotation</a> <code>xs:untyped</code>, and
attribute nodes with the type annotation
<code>xs:untypedAtomic</code>.</p>
</li>
</ul>
<p><a name="err-XTDE1665" id="err-XTDE1665"><span class=
"error">[ERR XTDE1665]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
input to the processor includes a node with a <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>, or an atomic value of a type other
than those which a basic XSLT processor supports. This error will
not arise if the <code>input-type-annotations</code> attribute is
set to <code>strip</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although this is expressed in terms of a requirement to detect
invalid input, an alternative approach is for a non-schema-aware
processor to prevent this error condition occurring, by not
providing any interfaces that would allow the situation to arise. A
processor might, for example, implement a mapping from the PSVI to
the data model that loses all non-trivial <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotations</a>; or it might not accept input from a PSVI at
all.</p>
<p>The phrase <em>input to the processor</em> is deliberately wide:
it includes the tree containing the <span><a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span>, trees
passed as <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, trees
accessed using the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions, and trees returned by <a title="extension function"
class="termref" href="#dt-extension-function">extension
functions</a> and <a title="extension instruction" class="termref"
href="#dt-extension-instruction">extension instructions</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="serialization-feature" id=
"serialization-feature"></a>26.3 <a href="#serialization-feature"
style="text-decoration: none">Serialization Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization-feature" id="dt-serialization-feature" title=
"serialization feature"></a>A processor that claims conformance
with the <b>serialization feature</b> <span class=
"verb">must</span> support the conversion of a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to a sequence of
octets following the rules defined in <a href=
"#serialization"><i>25 Serialization</i></a>.<span class=
"definition">]</span> It <span class="verb">must</span> respect all
the attributes of the <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations, and <span class="verb">must</span> provide all four
output methods, <code>xml</code>, <code>xhtml</code>,
<code>html</code>, and <code>text</code>. Where the specification
uses words such as <span class="verb">must</span> and <span class=
"verb">required</span>, then it <span class="verb">must</span>
serialize the result tree in precisely the way described; in other
cases it <span class="verb">may</span> use an alternative,
equivalent representation.</p>
<p>A processor may claim conformance with the serialization feature
whether or not it supports the setting
<code>disable-output-escaping="yes"</code> on <a href=
"#element-text"><code>xsl:text</code></a>, or <a href=
"#element-value-of"><code>xsl:value-of</code></a>.</p>
<p>A processor that does not claim conformance with the
serialization feature <span class="verb">must not</span> signal an
error merely because the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> contains <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations, or serialization attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. Such a processor <span class="verb">may</span> check
that these declarations and attributes have valid values, but is
not <span class="verb">required</span> to do so. Apart from
optional validation, these declarations <span class=
"verb">should</span> be ignored.</p>
</div>
<div class="div2">
<h3><a name="backwards-compatibility-feature" id=
"backwards-compatibility-feature"></a>26.4 <a href=
"#backwards-compatibility-feature" style=
"text-decoration: none">Compatibility Features</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-1.0-compatibility-feature" id="dt-1.0-compatibility-feature"
title="XSLT 1.0 compatibility feature"></a>A processor that claims
conformance with the <b>XSLT 1.0 compatibility feature</b>
<span class="verb">must</span> support the processing of stylesheet
instructions and XPath expressions with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>.<span class="definition">]</span></p>
<p>Note that a processor that does not claim conformance with the
<a title="XSLT 1.0 compatibility feature" class="termref" href=
"#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
instruction is evaluated whose <a title="effective version" class=
"termref" href="#dt-effective-version">effective version</a> is
1.0. <span class="error">[see <a href="#err-XTDE0160">ERR
XTDE0160</a>]</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason this is a dynamic error rather than a static error is
to allow stylesheets to contain conditional logic, following
different paths depending on whether the XSLT processor implements
<span>XSLT 1.0, 2.0, or 3.0</span>. The selection of which path to
use can be controlled by using the <a href=
"#func-system-property"><code>system-property</code></a> function
to test the <code>xsl:version</code> system property.</p>
</div>
<p>A processor that claims conformance with the <a title=
"XSLT 1.0 compatibility feature" class="termref" href=
"#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
<span class="verb">must</span> permit the use of the namespace axis
in XPath expressions when backwards compatible behavior is enabled.
In all other circumstances, support for the namespace axis is
optional.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are no incompatibilities between 3.0 and 2.0 that would
justify a 2.0-compatibility mode. When a 3.0 processor encounters a
stylesheet that specifies <code>version="2.0"</code>, evaluation
therefore proceeds exactly as if it specified
<code>version="3.0"</code>. However, a software product may invoke
an XSLT 2.0 processor in preference to an XSLT 3.0 processor when
the stylesheet specifies <code>version="3.0"</code>, in which case
any use of new 3.0 constructs will be rejected.</p>
</div>
</div>
<div class="div2">
<h3><a name="streaming-feature" id="streaming-feature"></a>26.5
<a href="#streaming-feature" style=
"text-decoration: none">Streaming Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streaming-feature" id="dt-streaming-feature" title=
"streaming feature"></a>A processor that claims conformance with
the <b>streaming feature</b> <span class="verb">must</span> use
streamed processing in cases where (a) streaming is requested (for
example by using the attribute <code>streamable="yes"</code> on
<a href="#element-mode"><code>xsl:mode</code></a>, or the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) and (b)
the constructs in question are <a title="guaranteed-streamable"
class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification.<span class="definition">]</span></p>
<p>A processor that does not claim conformance with the streaming
feature is not required to use streamed processing and is not
required to determine whether any construct is guaranteed
streamable. Such a processor must, however, implement the semantics
of all constructs in the language provided that enough memory is
available to perform the processing without streaming.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>"yes"</code> in response
to the function call
<code>system-property('xsl:supports-streaming')</code>; a processor
that does not conform with the feaure <span class=
"verb">must</span> return the value <code>"no"</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <em>streamed processing</em> as used here means the
ability to process arbitrarily large input documents without
ever-increasing memory requirements.</p>
</div>
</div>
<div class="div2">
<h3><a name="dynamic-evaluation-feature" id=
"dynamic-evaluation-feature"></a>26.6 <a href=
"#dynamic-evaluation-feature" style="text-decoration: none">Dynamic
Evaluation Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-dynamic-evaluation-feature" id="dt-dynamic-evaluation-feature"
title="dynamic evaluation feature"></a>A processor that claims
conformance with the <b>dynamic evaluation feature</b> <span class=
"verb">must</span> evaluate the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> function as
described in this specification.<span class=
"definition">]</span></p>
<p>A processor that does not claim conformance with the dynamic
evaluation feature <span class="verb">must</span> report a dynamic
error if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated. It <span class="verb">must not</span> report a static
error merely because of the presence of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction in
the stylesheet, unless a processor that conforms with the feature
would report the same static error.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>"yes"</code> in response
to the function call
<code>system-property('xsl:supports-dynamic-evaluation')</code>; a
processor that does not conform with the feaure <span class=
"verb">must</span> return the value <code>"no"</code>.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>true</code> in response
to the function call
<code>element-available('xsl:evaluate')</code>; a processor that
does not conform with the feaure <span class="verb">must</span>
return the value <code>false</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A processor may allow dynamic evaluation to be enabled and
disabled by means of configuration settings, perhaps for security
reasons. In consequence, it may be impossible to tell during static
analysis of the stylesheet whether or not the feature will be
available during execution. A stylesheet author wanting to check
whether the feature is available should therefore make the test
using a run-time call on <code>system-property</code>, rather than
relying on tests in an <code>[xsl:]use-when</code> attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="xquery-invocation-feature" id=
"xquery-invocation-feature"></a>26.7 <a href=
"#xquery-invocation-feature" style="text-decoration: none">XQuery
Invocation Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xquery-invocation-feature" id="dt-xquery-invocation-feature"
title="XQuery Invocation Feature"></a>A processor that claims
conformance with the <b>XQuery invocation feature</b> <span class=
"verb">must</span> allow XQuery library modules to be referenced in
<a href="#element-use-package"><code>xsl:use-package</code></a>,
and must allow the using package to reference the public functions
and variables declared in the referenced library
module.<span class="definition">]</span></p>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="references" id="references"></a>A <a href=
"#references" style="text-decoration: none">References</a></h2>
<div class="div2">
<h3><a name="normative-references" id=
"normative-references"></a>A.1 <a href="#normative-references"
style="text-decoration: none">Normative References</a></h3>
<dl>
<dt class="label"><span><a name="xpath-datamodel-30" id=
"xpath-datamodel-30"></a>Data Model</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-30/"><cite>XQuery and XPath
Data Model (XDM) 3.0</cite></a>, Norman Walsh, John Snelson,
Editors. World Wide Web Consortium, 22 October 2013. This version
is http://www.w3.org/TR/2013/PR-xpath-datamodel-30-20131022/. The
<a href="http://www.w3.org/TR/xpath-datamodel-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-30" id=
"xpath-functions-30"></a>Functions and Operators</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-30/"><cite>XQuery and XPath
Functions and Operators 3.0</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 22 October 2013. This version is
http://www.w3.org/TR/2013/PR-xpath-functions-30-20131022/. The
<a href="http://www.w3.org/TR/xpath-functions-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-30/.</div>
</dd>
<dt class="label"><span><a name="xml-infoset" id=
"xml-infoset"></a>XML Information Set</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-infoset"><cite>XML
Information Set (Second Edition)</cite></a>, Richard Tobin and John
Cowan, Editors. World Wide Web Consortium, 04&#160;Feb&#160;2004.
This version is http://www.w3.org/TR/2004/REC-xml-infoset-20040204.
The <a href="http://www.w3.org/TR/xml-infoset">latest version</a>
is available at http://www.w3.org/TR/xml-infoset.</div>
</dd>
<dt class="label"><span><a name="ISO15924" id="ISO15924"></a>ISO
15924</span></dt>
<dd>
<div>ISO (International Organization for Standardization)
<em>Information and documentation — Codes for the representation of
names of scripts</em> ISO 15924:2004, January 2004.</div>
</dd>
<dt class="label"><span><a name="ISO15924_register" id=
"ISO15924_register"></a>ISO 15924 Register</span></dt>
<dd>
<div>Unicode Consortium. <em>Codes for the representation of names
of scripts — Alphabetical list of four-letter script codes.</em>
See <a href=
"http://www.unicode.org/iso15924/iso15924-codes.html">http://www.unicode.org/iso15924/iso15924-codes.html</a>.
Retrieved February 2013; continually updated.</div>
</dd>
<dt class="label"><span><a name="xslt-xquery-serialization-30" id=
"xslt-xquery-serialization-30"></a>XSLT and XQuery
Serialization</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/"><cite>XSLT and
XQuery Serialization 3.0</cite></a>, Henry Zongaro, Editor. World
Wide Web Consortium, 22 October 2013. This version is
http://www.w3.org/TR/2013/PR-xslt-xquery-serialization-30-20131022/.
The <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/">latest
version</a> is available at
http://www.w3.org/TR/xslt-xquery-serialization-30/.</div>
</dd>
<dt class="label"><span><a name="rfc4627" id="rfc4627"></a>RFC
4627</span></dt>
<dd>
<div>IETF. <em>The application/json Media Type for JavaScript
Object Notation (JSON).</em> July 2006. See <a href=
"http://www.ietf.org/rfc/rfc4627.txt">http://www.ietf.org/rfc/rfc4627.txt</a></div>
</dd>
<dt class="label"><span><a name="ECMA-404" id=
"ECMA-404"></a>ECMA-404</span></dt>
<dd>
<div>ECMA International. <em>The JSON Data Interchange Format</em>
October 2013. See <a href=
"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">
http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</a>.</div>
</dd>
<dt class="label"><span><a name="UNICODE" id=
"UNICODE"></a>UNICODE</span></dt>
<dd>
<div>Unicode Consortium. <em>The Unicode Standard</em> as updated
from time to time by the publication of new versions. See <a href=
"http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
for the latest version and additional information on versions of
the standard and of the Unicode Character Database. The version of
Unicode to be used is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations are recommended to use the latest Unicode
version.</div>
</dd>
<dt class="label"><span><a name="UNICODE-TR10" id=
"UNICODE-TR10"></a>UNICODE TR10</span></dt>
<dd>
<div>Unicode Consortium. <em>Unicode Technical Standard #10.
Unicode Collation Algorithm</em>. Unicode Technical Report. See
<a href=
"http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>.</div>
</dd>
<dt class="label"><span><a name="UNICODE-TR35" id=
"UNICODE-TR35"></a>UNICODE TR35</span></dt>
<dd>
<div>Unicode Consortium. <em>Unicode Technical Standard #35.
Unicode Locale Data Markup Language</em>. Unicode Technical Report.
See <a href=
"http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a>.</div>
</dd>
<dt class="label"><span><a name="REC-xml" id="REC-xml"></a>XML
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.0. W3C Recommendation.</em> See <a href=
"http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</a>.
The edition of XML 1.0 must be no earlier than the Third Edition;
the edition used is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</div>
</dd>
<dt class="label"><span><a name="xml11" id="xml11"></a>XML
1.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml11/"><cite>Extensible Markup
Language (XML) 1.1 (Second Edition)</cite></a>, François Yergeau,
Eve Maler, John Cowan, <em>et. al.</em>, Editors. World Wide Web
Consortium, 16&#160;Aug&#160;2006. This version is
http://www.w3.org/TR/2006/REC-xml11-20060816. The <a href=
"http://www.w3.org/TR/xml11/">latest version</a> is available at
http://www.w3.org/TR/xml11/.</div>
</dd>
<dt class="label"><span><a name="xmlbase" id="xmlbase"></a>XML
Base</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlbase/"><cite>XML Base (Second
Edition)</cite></a>, Jonathan Marsh and Richard Tobin, Editors.
World Wide Web Consortium, 28&#160;Jan&#160;2009. This version is
http://www.w3.org/TR/2009/REC-xmlbase-20090128/. The <a href=
"http://www.w3.org/TR/xmlbase/">latest version</a> is available at
http://www.w3.org/TR/xmlbase/.</div>
</dd>
<dt class="label"><span><a name="xml-id" id=
"xml-id"></a>xml:id</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-id/"><cite>xml:id Version
1.0</cite></a>, Norman Walsh, Daniel Veillard, and Jonathan Marsh,
Editors. World Wide Web Consortium, 09&#160;Sep&#160;2005. This
version is http://www.w3.org/TR/2005/REC-xml-id-20050909/. The
<a href="http://www.w3.org/TR/xml-id/">latest version</a> is
available at http://www.w3.org/TR/xml-id/.</div>
</dd>
<dt class="label"><span><a name="xml-names" id=
"xml-names"></a>Namespaces in XML</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-names"><cite>Namespaces in
XML 1.0 (Third Edition)</cite></a>, Dave Hollander, Andrew Layman,
Henry S. Thompson, <em>et. al.</em>, Editors. World Wide Web
Consortium, 08&#160;Dec&#160;2009. This version is
http://www.w3.org/TR/2009/REC-xml-names-20091208/. The <a href=
"http://www.w3.org/TR/xml-names">latest version</a> is available at
http://www.w3.org/TR/xml-names.</div>
</dd>
<dt class="label"><span><a name="xml-names11" id=
"xml-names11"></a>Namespaces in XML 1.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-names11/"><cite>Namespaces
in XML 1.1 (Second Edition)</cite></a>, Dave Hollander, Andrew
Layman, Richard Tobin, and Tim Bray, Editors. World Wide Web
Consortium, 16&#160;Aug&#160;2006. This version is
http://www.w3.org/TR/2006/REC-xml-names11-20060816. The <a href=
"http://www.w3.org/TR/xml-names11/">latest version</a> is available
at http://www.w3.org/TR/xml-names11/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-1" id=
"xmlschema-1"></a>XML Schema Part 1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema
Part 1: Structures Second Edition</cite></a>, Henry S. Thompson,
David Beech, Murray Maloney, and Noah Mendelsohn, Editors. World
Wide Web Consortium, 28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-2" id=
"xmlschema-2"></a>XML Schema Part 2</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a>, Ashok Malhotra and
Paul V. Biron, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-2/.</div>
</dd>
<dt class="label"><span><a name="xmlschema11-1" id=
"xmlschema11-1"></a>XML Schema</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema Definition Language
(XSD) 1.1 Part 1: Structures</em>. W3C Working Draft 3 December
2009. See <a href=
"http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a></div>
</dd>
<dt class="label"><span><a name="xpath-30" id="xpath-30"></a>XPath
3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-30/"><cite>XML Path
Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 22
October 2013. This version is
http://www.w3.org/TR/2013/PR-xpath-30-20131022/. The <a href=
"http://www.w3.org/TR/xpath-30/">latest version</a> is available at
http://www.w3.org/TR/xpath-30/.</div>
</dd>
<dt class="label"><span><a name="XSLT-Mime-Type" id=
"XSLT-Mime-Type"></a>XSLT Media Type</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Registration of MIME Media Type
application/xslt+xml</em>. In <a href=
"http://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">
Appendix B.1 of the XSLT 2.0 specification.</a></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="other-references" id="other-references"></a>A.2
<a href="#other-references" style="text-decoration: none">Other
References</a></h3>
<dl>
<dt class="label"><span><a name="DOM-Level-2-Core" id=
"DOM-Level-2-Core"></a>DOM Level 2</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/DOM-Level-2-Core/"><cite>Document Object
Model (DOM) Level 2 Core Specification</cite></a>, Lauren Wood,
Arnaud Le Hors, Mike Champion, <em>et. al.</em>, Editors. World
Wide Web Consortium, 13&#160;Nov&#160;2000. This version is
http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The
<a href="http://www.w3.org/TR/DOM-Level-2-Core/">latest version</a>
is available at http://www.w3.org/TR/DOM-Level-2-Core/.</div>
</dd>
<dt class="label"><span><a name="rfc2119" id=
"rfc2119"></a>rfc2119</span></dt>
<dd>
<div>S. Bradner. <em>Key words for use in RFCs to Indicate
Requirement Levels</em>. IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3986" id=
"RFC3986"></a>RFC3986</span></dt>
<dd>
<div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3987" id=
"RFC3987"></a>RFC3987</span></dt>
<dd>
<div>M. Duerst, M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
</dd>
<dt class="label"><span><a name="STX" id="STX"></a>STX</span></dt>
<dd>
<div>Petr Cimprich <em>et al</em>, <em>Streaming Transformations
for XML (STX) Version 1.0</em>. Working Draft 27 April 2007. See
<a href=
"http://stx.sourceforge.net/documents/spec-stx-20070427.html">http://stx.sourceforge.net/documents/spec-stx-20070427.html</a></div>
</dd>
<dt class="label"><span><a name="xlink" id=
"xlink"></a>XLink</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xlink/"><cite>XML Linking
Language (XLink) Version 1.0</cite></a>, Steven DeRose, David
Orchard, and Eve Maler, Editors. World Wide Web Consortium,
27&#160;Jun&#160;2001. This version is
http://www.w3.org/TR/2001/REC-xlink-20010627/. The <a href=
"http://www.w3.org/TR/xlink/">latest version</a> is available at
http://www.w3.org/TR/xlink/.</div>
</dd>
<dt class="label"><span><a name="SCHEMA-AND-XML-1.1" id=
"SCHEMA-AND-XML-1.1"></a>XML Schema 1.0 and XML 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Processing XML 1.1 documents
with XML Schema 1.0 processors</em>. W3C Working Group Note 11 May
2005. See <a href=
"http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</a></div>
</dd>
<dt class="label"><span><a name="xml-stylesheet" id=
"xml-stylesheet"></a>XML Stylesheet</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xml-stylesheet"><cite>Associating Style
Sheets with XML documents 1.0 (Second Edition)</cite></a>, Simon
Pieters, James Clark, and Henry S. Thompson, Editors. World Wide
Web Consortium, 28&#160;Oct&#160;2010. This version is
http://www.w3.org/TR/2010/REC-xml-stylesheet-20101028. The <a href=
"http://www.w3.org/TR/xml-stylesheet">latest version</a> is
available at http://www.w3.org/TR/xml-stylesheet.</div>
</dd>
<dt class="label"><span><a name="xptr-framework" id=
"xptr-framework"></a>XPointer Framework</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xptr-framework/"><cite>XPointer
Framework</cite></a>, Paul Grosso, Eve Maler, Norman Walsh, and
Jonathan Marsh, Editors. World Wide Web Consortium,
25&#160;Mar&#160;2003. This version is
http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The
<a href="http://www.w3.org/TR/xptr-framework/">latest version</a>
is available at http://www.w3.org/TR/xptr-framework/.</div>
</dd>
<dt class="label"><span><a name="xsl11" id=
"xsl11"></a>XSL-FO</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xsl11/"><cite>Extensible
Stylesheet Language (XSL) Version 1.1</cite></a>, Anders Berglund,
Editor. World Wide Web Consortium, 05&#160;Dec&#160;2006. This
version is http://www.w3.org/TR/2006/REC-xsl11-20061205/. The
<a href="http://www.w3.org/TR/xsl11/">latest version</a> is
available at http://www.w3.org/TR/xsl11/.</div>
</dd>
<dt class="label"><span><a name="xslt" id="xslt"></a>XSLT
1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations
(XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web
Consortium, 16&#160;Nov&#160;1999. This version is
http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href=
"http://www.w3.org/TR/xslt">latest version</a> is available at
http://www.w3.org/TR/xslt.</div>
</dd>
<dt class="label"><span><a name="xslt20" id="xslt20"></a>XSLT
2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt20/"><cite>XSL
Transformations (XSLT) Version 2.0 (Second Edition)</cite></a>,
Michael Kay, Editor. World Wide Web Consortium, 23 January 2007.
This version is http://www.w3.org/TR/2007/REC-xslt20-20070123/. The
<a href="http://www.w3.org/TR/xslt20/">latest version</a> is
available at http://www.w3.org/TR/xslt20/.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="json-in-xml" id="json-in-xml"></a>B <a href=
"#json-in-xml" style="text-decoration: none">XML Representation of
JSON</a></h2>
<p>This appendix contains the schema for the XML representation of
JSON described in <a href="#json-to-xml-mapping"><i>21.2.1 XML
Representation of JSON</i></a>, together with the stylesheets used
for converting from this XML representation to strings matching the
JSON grammar.</p>
<p>These schema documents and stylesheets are also available as
separate resources (links are listed at the top of this
document).</p>
<div class="div2">
<h3><a name="schema-for-json" id="schema-for-json"></a>B.1 <a href=
"#schema-for-json" style="text-decoration: none">Schema for the XML
Representation of JSON</a></h3>
<p>The schema is reproduced below:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    elementFormDefault="qualified"
    targetNamespace="http://www.w3.org/2013/XSL/json"
    xmlns:j="http://www.w3.org/2013/XSL/json"&gt;
    
    &lt;!-- 
     * This is a schema for the XML representation of JSON used as the target for the
     * XSLT 3.0 function fn:json-to-xml()
     *
     * The schema is made available under the terms of the W3C software notice and license
     * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
     *
    --&gt;
    
    &lt;xs:element name="map" type="j:mapType"&gt;
        &lt;xs:unique name="unique-key"&gt;
            &lt;xs:selector xpath="*"/&gt;
            &lt;xs:field xpath="@key"/&gt;
        &lt;/xs:unique&gt;
    &lt;/xs:element&gt;
    
    &lt;xs:element name="array" type="j:arrayType"/&gt;
    
    &lt;xs:element name="string" type="j:stringType"/&gt;
    
    &lt;xs:element name="number" type="j:numberType"/&gt;
    
    &lt;xs:element name="boolean" type="xs:boolean"/&gt;
    
    &lt;xs:element name="null" type="j:nullType"/&gt;
    
    &lt;xs:complexType name="nullType"&gt;
        &lt;xs:sequence/&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="stringType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="escaped" type="xs:boolean" use="optional" default="false"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:simpleType name="numberType"&gt;
        &lt;xs:restriction base="xs:double"&gt;
            &lt;!-- exclude positive and negative infinity, and NaN --&gt;
            &lt;xs:minExclusive value="-INF"/&gt;
            &lt;xs:maxExclusive value="INF"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    
    &lt;xs:complexType name="arrayType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="j:map"/&gt;
            &lt;xs:element ref="j:array"/&gt;
            &lt;xs:element ref="j:string"/&gt;
            &lt;xs:element ref="j:number"/&gt;
            &lt;xs:element ref="j:boolean"/&gt;
            &lt;xs:element ref="j:null"/&gt;
        &lt;/xs:choice&gt;       
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="mapType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element name="map"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:mapType"&gt;
                            &lt;xs:attribute name="key" type="xs:string"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
                &lt;xs:unique name="unique-key-2"&gt;
                    &lt;xs:selector xpath="*"/&gt;
                    &lt;xs:field xpath="@key"/&gt;
                &lt;/xs:unique&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="array"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:arrayType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="string"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:stringType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="number"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:numberType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="boolean"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="xs:boolean"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="null"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:attributeGroup ref="j:key-group"/&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:attributeGroup name="key-group"&gt;
        &lt;xs:attribute name="key" type="xs:string"/&gt;
        &lt;xs:attribute name="escaped-key" type="xs:boolean" use="optional" default="false"/&gt;
    &lt;/xs:attributeGroup&gt;
    
&lt;/xs:schema&gt;
</pre></div>
<div class="div2">
<h3><a name="xml-to-json-stylesheet" id=
"xml-to-json-stylesheet"></a>B.2 <a href="#xml-to-json-stylesheet"
style="text-decoration: none">Stylesheet for converting XML to JSON
(without indentation)</a></h3>
<p>The stylesheet is reproduced below:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xsl:package name="http://www.w3.org/2013/XSLT/xml-to-json.xsl"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:j="http://www.w3.org/2013/XSL/json"
    exclude-result-prefixes="xs j"
    default-mode="j:xml-to-json"
    version="3.0"
    package-version="3.0"&gt;
    
    &lt;!-- 
        * This is a stylesheet for converting XML to JSON (with minimal whitespace). 
        * It expects the XML to be in the format produced by the XSLT 3.0 function
        * fn:json-to-xml(), but is designed to be highly customizable.
        *
        * The stylesheet is made available under the terms of the W3C software notice and license
        * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
        *
    --&gt;    

&lt;xsl:stylesheet&gt;

    &lt;!-- The delimiter to be used before and after keys in a map --&gt;
    &lt;xsl:param name="j:key-delimiter" as="xs:string"&gt;"&lt;/xsl:param&gt;
    
    &lt;!-- The delimiter to be used before and after string values --&gt;
    &lt;xsl:param name="j:string-delimiter" as="xs:string"&gt;"&lt;/xsl:param&gt;

    &lt;!-- The separator to be used between keys and values --&gt;
    &lt;xsl:param name="j:colon" as="xs:string"&gt;:&lt;/xsl:param&gt;

    &lt;!-- The separator to be used between entries in a map --&gt;
    &lt;xsl:param name="j:entry-separator" as="xs:string"&gt;,&lt;/xsl:param&gt;
    
    &lt;!-- The opening delimiter of an array --&gt;
    &lt;xsl:param name="j:start-array" as="xs:string"&gt;[&lt;/xsl:param&gt;
    
    &lt;!-- The closing delimiter of an array --&gt;
    &lt;xsl:param name="j:end-array" as="xs:string"&gt;]&lt;/xsl:param&gt;
    
    &lt;!-- The opening delimiter of a map --&gt;
    &lt;xsl:param name="j:start-map" as="xs:string"&gt;{&lt;/xsl:param&gt;
    
    &lt;!-- The closing delimiter of a map --&gt;
    &lt;xsl:param name="j:end-map" as="xs:string"&gt;}&lt;/xsl:param&gt;
    
    &lt;!-- The separator to be used between members of an array --&gt;
    &lt;xsl:param name="j:array-separator" as="xs:string" select="$j:comma"/&gt;
    
    &lt;xsl:template name="j:start-array"&gt;
        &lt;xsl:value-of select="$j:start-array"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:end-array"&gt;
        &lt;xsl:value-of select="$j:end-array"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:start-map"&gt;
        &lt;xsl:value-of select="$j:start-map"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:end-map"&gt;
        &lt;xsl:value-of select="$j:end-map"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:map-separator"&gt;
        &lt;xsl:value-of select="$j:map-separator"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:array-separator"&gt;
        &lt;xsl:value-of select="$j:array-separator"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- Entry point: function to convert a supplied XML node to a JSON string --&gt;
    &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt;
        &lt;xsl:param name="xml" as="node()"/&gt;
        &lt;xsl:apply-templates select="$xml"/&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Conversion of XML to JSON can be achieved by applying templates to the XML root in this mode --&gt;
    &lt;xsl:mode name="j:xml-to-json" streamable="yes" visibility="public" on-no-match="shallow-copy"/&gt;

    &lt;!-- Template rule for j:map elements, representing JSON objects --&gt;
    &lt;xsl:template match="j:map"&gt;
        &lt;xsl:call-template name="j:start-map"/&gt;
        &lt;xsl:for-each select="*"&gt;
            &lt;xsl:if test="position() gt 1"&gt;
                &lt;xsl:call-template name="j:map-separator"/&gt;
            &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="@key"/&gt;
            &lt;xsl:call-template name="j:entry-separator"/&gt;
            &lt;xsl:apply-templates select="."/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:call-template name="j:end-map"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:array elements, representing JSON arrays --&gt;
    &lt;xsl:template match="j:array"&gt;
        &lt;xsl:call-template name="j:start-array"/&gt;
        &lt;xsl:for-each select="*"&gt;
            &lt;xsl:if test="position() gt 1"&gt;
                &lt;xsl:call-template name="j:array-separator"/&gt;
            &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="."/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:call-template name="j:end-array"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:string elements in which special characters are already escaped --&gt;
    &lt;xsl:template match="j:string[@escaped='true']"&gt;
        &lt;xsl:value-of select="concat($j:string-delimiter, ., $j:string-delimiter)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:string elements in which special characters need to be escaped --&gt;
    &lt;xsl:template match="j:string[not(@escaped='true')]"&gt;
        &lt;xsl:value-of select="concat($j:string-delimiter, j:escape(.), $j:string-delimiter)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:number and j:boolean elements (representing JSON numbers and booleans) --&gt;
    &lt;xsl:template match="j:number | j:boolean"&gt;
        &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for JSON null elements (representing JSON null values) --&gt;
    &lt;xsl:template match="j:null"&gt;
        &lt;xsl:text&gt;null&lt;/xsl:text&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where special characters in the key are already escaped --&gt;
    &lt;xsl:template match="j:*/@key[../@key-escaped='true']"&gt;
        &lt;xsl:value-of select="concat($j:key-delimiter, ., $j:key-delimiter)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where special characters in the key need to be escaped --&gt;
    &lt;xsl:template match="j:*/@key[not(../@key-escaped='true')]"&gt;
        &lt;xsl:value-of select="concat($j:key-delimiter, j:escape(.), $j:key-delimiter)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching (and discarding) text nodes in the XML: typically ignorable whitespace --&gt;
    &lt;xsl:template match="text()"/&gt;

    &lt;!-- Function to escape special characters --&gt;
    &lt;xsl:function name="j:escape" as="xs:string"&gt;
        &lt;xsl:param name="in" as="xs:string"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:for-each select="string-to-codepoints($in)"&gt;
                &lt;xsl:choose&gt;
                    &lt;xsl:when test=". gt 65535"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) idiv 1024 + 55296))"/&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) mod 1024 + 56320))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 34"&gt;\"&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 92"&gt;\\&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 08"&gt;\b&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 09"&gt;\t&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 10"&gt;\n&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 12"&gt;\f&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 13"&gt;\r&lt;/xsl:when&gt;
                    &lt;xsl:when test=". lt 32 or (. ge 127 and . le 160)"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4(.))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                        &lt;xsl:value-of select="codepoints-to-string(.)"/&gt;
                    &lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
            &lt;/xsl:for-each&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Function to convert a UTF16 codepoint into a string of four hex digits --&gt;
    &lt;xsl:function name="j:hex4" as="xs:string"&gt;
        &lt;xsl:param name="ch" as="xs:integer"/&gt;
        &lt;xsl:variable name="hex" select="'0123456789abcdef'"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 4096 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 256 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 16 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch mod 16 + 1, 1)"/&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

&lt;/xsl:stylesheet&gt;
    
&lt;/xsl:package&gt;    
</pre></div>
<div class="div2">
<h3><a name="xml-to-json-stylesheet-indented" id=
"xml-to-json-stylesheet-indented"></a>B.3 <a href=
"#xml-to-json-stylesheet-indented" style=
"text-decoration: none">Stylesheet for converting XML to JSON (with
indentation)</a></h3>
<p>The stylesheet is reproduced below:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;


&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:j="http://www.w3.org/2013/XSL/json"
    exclude-result-prefixes="xs j"
    version="2.0"&gt;
    
    &lt;!-- 
        * This is a stylesheet for converting XML to JSON (indented for readability). 
        * It expects the XML to be in the format produced by the XSLT 3.0 function
        * fn:json-to-xml(), but is designed to be highly customizable.
        *
        * The stylesheet is made available under the terms of the W3C software notice and license
        * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
        *
    --&gt;    
    
    &lt;xsl:import href="xml-to-json.xsl"/&gt;
    
    &lt;xsl:param name="indent-spaces" as="xs:integer" select="3"/&gt;
    
    &lt;xsl:param name="j:colon" as="xs:string"&gt; : &lt;/xsl:param&gt;
    
    &lt;xsl:template name="j:start-array"&gt;
        &lt;xsl:text&gt; [&amp;#xa;&lt;/xsl:text&gt;
        &lt;xsl:variable name="depth" select="count(ancestor::*)"/&gt;
        &lt;xsl:for-each select="1 to ($depth + 1) * $indent-spaces"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:for-each&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:end-array"&gt;
        &lt;xsl:text&gt; ] &lt;/xsl:text&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:start-map"&gt;
        &lt;xsl:text&gt; {&amp;#xa;&lt;/xsl:text&gt;
        &lt;xsl:variable name="depth" select="count(ancestor::*)"/&gt;
        &lt;xsl:for-each select="1 to ($depth + 1) * $indent-spaces"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:for-each&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:end-map"&gt;
        &lt;xsl:text&gt; } &lt;/xsl:text&gt;
    &lt;/xsl:template&gt;
   
    &lt;xsl:template name="j:map-separator"&gt;
        &lt;xsl:variable name="depth" select="count(ancestor::*)"/&gt;
        &lt;xsl:text&gt;,&amp;#xa;&lt;/xsl:text&gt;
        &lt;xsl:for-each select="1 to $depth * $indent-spaces"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:for-each&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template name="j:array-separator"&gt;
        &lt;xsl:variable name="depth" select="count(ancestor::*)"/&gt;
        &lt;xsl:text&gt;,&amp;#xa;&lt;/xsl:text&gt;
        &lt;xsl:for-each select="1 to $depth * $indent-spaces"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:for-each&gt;
    &lt;/xsl:template&gt;
    
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="glossary" id="glossary"></a>C Glossary
(Non-Normative)</h2>
<dl>
<dt><a href="#dt-absent">absent</a></dt>
<dd>
<p>A component of the context that has no value is said to be
<b>absent</b>.</p>
</dd>
<dt><a href="#dt-absorption">absorption</a></dt>
<dd>
<p>An operand usage of <b>absorption</b> indicates that the
construct reads the subtree(s) rooted at a supplied node(s).</p>
</dd>
<dt><a href="#dt-accumulator">accumulator</a></dt>
<dd>
<p>An <b>accumulator</b> defines a value that is computed
progressively while processing the nodes of a document in document
order. The value for a given node is available via a pair of
functions, one giving the value for a node before processing its
descendants, and one giving the value for the same node after
processing its descendants.</p>
</dd>
<dt><a href="#dt-accumulator-function">accumulator
function</a></dt>
<dd>
<p>The functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> are
referred to as the <b>accumulator functions</b>.</p>
</dd>
<dt><a href="#dt-alias">alias</a></dt>
<dd>
<p>A stylesheet can use the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element to declare that a <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is being used as an <b>alias</b> for a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>.</p>
</dd>
<dt><a href="#dt-arity">arity</a></dt>
<dd>
<p>The <b>arity</b> of a stylesheet function is the number of
<a href="#element-param"><code>xsl:param</code></a> elements in the
function definition.</p>
</dd>
<dt><a href="#dt-atomization">atomize</a></dt>
<dd>
<p>The term <b>atomization</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-atomization">Section 2.4.2
Atomization</a> <sup><small>XP30</small></sup>. It is a process
that takes as input a sequence of <span>items</span>, and returns a
sequence of atomic values, in which the nodes are replaced by their
typed values as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.</p>
</dd>
<dt><a href="#dt-attribute-set">attribute set</a></dt>
<dd>
<p>An <b>attribute set</b> is defined as a set of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the same <a title="package" class="termref" href=
"#dt-package">package</a> that share the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
</dd>
<dt><a href="#dt-attribute-value-template">attribute value
template</a></dt>
<dd>
<p>In an attribute that is designated as an <b>attribute value
template</b>, such as an attribute of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> can be used by surrounding the
expression with curly brackets (<code>{}</code>), following the
general rules for <a title="value template" class="termref" href=
"#dt-value-template">value templates</a></p>
</dd>
<dt><a href="#dt-backwards-compatible-behavior">backwards
compatible behavior</a></dt>
<dd>
<p>An element is processed with <b>backwards compatible
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is less than
<code>3.0</code>.</p>
</dd>
<dt><a href="#dt-base-output-uri">base output URI</a></dt>
<dd>
<p>The <b>base output URI</b> is a URI to be used as the base URI
when resolving a relative URI <span>reference</span> allocated to a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>. If the
transformation generates more than one final result tree, then
typically each one will be allocated a URI relative to this base
URI.</p>
</dd>
<dt><a href="#dt-basic-xslt-processor">basic XSLT
processor</a></dt>
<dd>
<p>A <b>basic XSLT processor</b> is an XSLT processor that
implements all the mandatory requirements of this specification
with the exception of constructs explicitly associated with an
optional feature.</p>
</dd>
<dt><a href="#dt-character-map">character map</a></dt>
<dd>
<p>A <b>character map</b> allows a specific character appearing in
a text or attribute node in the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> to be
substituted by a specified string of characters during
serialization.</p>
</dd>
<dt><a href="#dt-choice-operand-group">choice operand
group</a></dt>
<dd>
<p>For some construct kinds, one or more operand roles may be
defined to form a <b>choice operand group</b>. This concept is used
where it is known that <a title="operand" class="termref" href=
"#dt-operand">operands</a> are mutually exclusive (for example the
<code>then</code> and <code>else</code> clauses in a conditional
expression).</p>
</dd>
<dt><a href="#dt-circularity">circularity</a></dt>
<dd>
<p>A <b>circularity</b> is said to exist if a construct such as a
<a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a>, an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, or a <a title="key" class="termref" href=
"#dt-key">key</a>, is defined in terms of itself. For example, if
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the value of a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> <var>X</var> references a global variable
<var>Y</var>, then the value for <var>Y</var> <span class=
"verb">must</span> be computed before the value of <var>X</var>. A
circularity exists if it is impossible to do this for all global
variable definitions.</p>
</dd>
<dt><a href="#dt-climbing">climbing</a></dt>
<dd>
<p><b>Climbing</b>: indicates that nodes returned by the construct
are reached by navigating the parent, ancestor[-or-self],
attribute, and/or namespace axes from the node at the current
streaming position.</p>
</dd>
<dt><a href="#dt-collation">collation</a></dt>
<dd>
<p>Facilities in XSLT <span>3.0</span> and XPath <span>3.0</span>
that require strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them is to be
sorted before the other.</p>
</dd>
<dt><a href="#dt-combined-posture">combined posture</a></dt>
<dd>
<p>The <b>combined posture</b> of a <a title="choice operand group"
class="termref" href="#dt-choice-operand-group">choice operand
group</a> is determined by the <a title="posture" class="termref"
href="#dt-posture">postures</a> of the <a title="operand" class=
"termref" href="#dt-operand">operands</a> in the group, and is the
first of the following that applies:</p>
</dd>
<dt><a href="#dt-compatible">compatible</a></dt>
<dd>
<p>The signatures of two <a title="component" class="termref" href=
"#dt-component">components</a> are <b>compatible</b> if they
present the same interface to the user of the component. The
additional rules depend on the kind of component.</p>
</dd>
<dt><a href="#dt-component">component</a></dt>
<dd>
<p>The term <b>component</b> is used to refer to any of the
following: a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, a <a title="mode" class="termref" href=
"#dt-mode">mode</a>, <span>an <a title="accumulator function"
class="termref" href=
"#dt-accumulator-function">accumulator</a></span> an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, a <span><a title="key" class="termref" href=
"#dt-key">key</a></span>, <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a>, or a
<a title="mode" class="termref" href="#dt-mode">mode</a>.</p>
</dd>
<dt><a href="#dt-composite-merge-key-value">composite merge key
value</a></dt>
<dd>
<p>The ordered collection of <a title="merge key value" class=
"termref" href="#dt-merge-key-value">merge key values</a> computed
for one item in a <a title="merge input sequence" class="termref"
href="#dt-merge-input-sequence">merge input sequence</a> (one for
each <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>) is
referred to as a <b>composite merge key value</b>.</p>
</dd>
<dt><a href="#dt-construct">construct</a></dt>
<dd>
<p>The term <b>construct</b> refers to the union of the following:
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="value template" class="termref" href=
"#dt-value-template">value template</a>, an <a title="expression"
class="termref" href="#dt-expression">expression</a>, or a
<a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#dt-consuming">consuming</a></dt>
<dd>
<p>A <b>consuming</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed consuming by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-containing-package">containing package</a></dt>
<dd>
<p>A component declaration results in multiple components, one in
the package in which the declaration appears, and potentially one
in each package that uses the declaring package, directly or
indirectly, subject to the visibility of the component. Each of
these multiple compenents has the same <a title="declaring package"
class="termref" href="#dt-declaring-package">declaring package</a>,
but each has a different <b>containing package</b>. For the
original component, the declaring package and the containing
package are the same; for a copy of a component made as a result of
a <a href="#element-use-package"><code>xsl:use-package</code></a>
declaration, the declaring package will be the original package,
and the containing package will be the package in which the
<a href="#element-use-package"><code>xsl:use-package</code></a>
declaration appears.</p>
</dd>
<dt><a href="#dt-context-item">context item</a></dt>
<dd>
<p>The <b>context item</b> is the item currently being processed.
An item (see <a href="#xpath-datamodel-30">[Data Model]</a>) is
either an atomic value (such as an integer, date, or string), a
node, <span>or a function item</span>. The context item is
initially set to the <span><a title="initial context item" class=
"termref" href="#dt-initial-context-item">initial context
item</a></span> supplied when the transformation is invoked (see
<a href="#initiating"><i>2.3 Initiating a Transformation</i></a>).
It changes whenever instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; each item in such a sequence
becomes the context item while that item is being processed.</p>
</dd>
<dt><a href="#dt-context-item-type">context item type</a></dt>
<dd>
<p>For every expression, it is possible to establish by static
analysis, information about the item type of the context item for
evaluation of that expression. This is called the <b>context item
type</b> of the expression.</p>
</dd>
<dt><a href="#dt-context-node">context node</a></dt>
<dd>
<p>If the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is a node (as distinct from an
atomic value such as an integer), then it is also referred to as
the <b>context node</b>. The context node is not an independent
variable, it changes whenever the context item changes. When the
context item is an atomic value <span>or a function item</span>,
there is no context node.</p>
</dd>
<dt><a href="#dt-context-position">context position</a></dt>
<dd>
<p>The <b>context position</b> is the position of the context item
within the sequence of items currently being processed. It changes
whenever the context item changes. When an instruction such as
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> or
<a href="#element-for-each"><code>xsl:for-each</code></a> is used
to process a sequence of items, the first item in the sequence is
processed with a context position of 1, the second item with a
context position of 2, and so on.</p>
</dd>
<dt><a href="#dt-context-posture">context posture</a></dt>
<dd>
<p>The <b>context posture</b>. This captures information about how
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> used as input to the construct
is positioned relative to the streamed input. The <b>context
posture</b> of a construct C is the posture of the expression whose
value sets the focus for the evaluation of C.</p>
</dd>
<dt><a href="#dt-context-size">context size</a></dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence
of items currently being processed. It changes whenever
instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; during the processing of each one
of those items, the context size is set to the count of the number
of items in the sequence (or equivalently, the position of the last
item in the sequence).</p>
</dd>
<dt><a href="#dt-controlled-operand">controlled operand</a></dt>
<dd>
<p>Within a <a title="focus-changing construct" class="termref"
href="#dt-focus-changing-construct">focus-changing construct</a>
there are one or more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a <a title=
"focus" class="termref" href="#dt-focus">focus</a> determined by
the <a title="controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> <span>(or in some
cases such as <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>, with
an <a title="absent" class="termref" href="#dt-absent">absent</a>
<a title="focus" class="termref" href=
"#dt-focus">focus</a>)</span>; these are referred to as
<b>controlled operands</b>.</p>
</dd>
<dt><a href="#dt-controlling-operand">controlling operand</a></dt>
<dd>
<p>Within a <a title="focus-changing construct" class="termref"
href="#dt-focus-changing-construct">focus-changing construct</a>
there is in many cases one <a title="operand" class="termref" href=
"#dt-operand">operand</a> whose value determines the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for evaluating
other operands; this is referred to as the <b>controlling
operand</b>.</p>
</dd>
<dt><a href="#dt-core-function">core function</a></dt>
<dd>
<p>The term <b>core function</b> means a function that is specified
in <a href="#xpath-functions-30">[Functions and Operators]</a> and
that is in the <a title="standard function namespace" class=
"termref" href="#dt-standard-function-namespace">standard function
namespace</a>.</p>
</dd>
<dt><a href="#dt-crawling">crawling</a></dt>
<dd>
<p><b>Crawling</b>: typically indicates that nodes returned by a
construct are reached by navigating the descendant[-or-self]
axis.</p>
</dd>
<dt><a href="#dt-current-captured-substrings">current captured
substrings</a></dt>
<dd>
<p>While the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction is active, a set of <b>current captured substrings</b>
is available, corresponding to the parenthesized sub-expressions of
the regular expression.</p>
</dd>
<dt><a href="#dt-current-group">current group</a></dt>
<dd>
<p>The evaluation context for XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> includes a
component called the <b>current group</b>, which is a sequence.</p>
</dd>
<dt><a href="#dt-current-group-value">current group value</a></dt>
<dd>
<p>The <b>current group value</b> is the <a title="group" class=
"termref" href="#dt-group">group</a> itself, as a sequence of
items</p>
</dd>
<dt><a href="#dt-current-grouping-key">current grouping
key</a></dt>
<dd>
<p>The evaluation context for XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> includes a
component called the <b>current grouping key</b>, which is <span>a
sequence of atomic values</span>. The current grouping key is the
<a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> shared in common by all the
items within the <a title="current group" class="termref" href=
"#dt-current-group">current group</a>.</p>
</dd>
<dt><a href="#dt-current-grouping-key-value">current grouping key
value</a></dt>
<dd>
<p>The <b>current grouping key value</b> is a single atomic value,
or in the case of a composite key, a sequence of atomic values,
containing the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> of the items in the <a title=
"current group value" class="termref" href=
"#dt-current-group-value">current group value</a>.</p>
</dd>
<dt><a href="#dt-current-mode">current mode</a></dt>
<dd>
<p>At any point in the processing of a stylesheet, there is a
<b>current mode</b>. When the transformation is initiated, the
current mode is the <span><a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a></span>, as described in
<a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.
Whenever an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is evaluated, the current mode becomes the mode
selected by this instruction.</p>
</dd>
<dt><a href="#dt-current-template-rule">current template
rule</a></dt>
<dd>
<p>At any point in the processing of a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, there may be a
<b>current template rule</b>. Whenever a <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> is
chosen as a result of evaluating <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, the
template rule becomes the current template rule for the evaluation
of the rule's sequence constructor. When an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, or <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span>
instruction is evaluated, or when evaluating a sequence constructor
contained in an <a href="#element-sort"><code>xsl:sort</code></a>
or <a href="#element-key"><code>xsl:key</code></a> element, or when
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made,</span> the current template rule becomes
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span> for the evaluation of that
instruction or function.</p>
</dd>
<dt><a href="#dt-decimal-format">decimal format</a></dt>
<dd>
<p>All the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in a <span>package</span> that share the same name are
grouped into a named <b>decimal format</b>; those that have no name
are grouped into a single unnamed decimal format.</p>
</dd>
<dt><a href="#dt-declaration">declaration</a></dt>
<dd>
<p>Top-level elements fall into two categories: declarations, and
user-defined data elements. Top-level elements whose names are in
the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>.
Top-level elements in any other namespace are <a title=
"user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a> (see <a href=
"#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</dd>
<dt><a href="#dt-declaration-order">declaration order</a></dt>
<dd>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> within a <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> have a total ordering
known as <b>declaration order</b>. The order of declarations within
a stylesheet level is the same as the document order that would
result if each stylesheet module were inserted textually in place
of the <a href="#element-include"><code>xsl:include</code></a>
element that references it.</p>
</dd>
<dt><a href="#dt-declaring-package">declaring package</a></dt>
<dd>
<p>The <b>declaring package</b> of a <a title="component" class=
"termref" href="#dt-component">component</a> is the package that
contains the declaration <span>(or, in the case of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> and
<a href="#element-key"><code>xsl:key</code></a>, multiple
declarations)</span> of the component.</p>
</dd>
<dt><a href="#dt-default-collation">default collation</a></dt>
<dd>
<p>In this specification the term <b>default collation</b> means
the collation that is used by XPath operators such as
<code>eq</code> and <code>lt</code> appearing in XPath expressions
within the stylesheet.</p>
</dd>
<dt><a href="#dt-default-priority">default priority</a></dt>
<dd>
<p>If no <code>priority</code> attribute is specified on an
<a href="#element-template"><code>xsl:template</code></a> element,
a <b>default priority</b> is computed, based on the syntax of the
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
supplied in the <code>match</code> attribute.</p>
</dd>
<dt><a href="#dt-defining-element">defining element</a></dt>
<dd>
<p>A string in the form of a lexical QName may occur as the value
of an attribute node in a stylesheet module, or within an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in an attribute <span>or
text node within a stylesheet module</span>, or as the result of
evaluating an XPath expression contained in such a node. The
element containing this attribute <span>or text</span> node is
referred to as the <b>defining element</b> of the lexical
QName.</p>
</dd>
<dt><a href="#dt-deprecated">deprecated</a></dt>
<dd>
<p>Some constructs defined in this specification are described as
being <b>deprecated</b>. The use of this term implies that
stylesheet authors <span class="verb">should not</span> use the
construct, and that the construct may be removed in a later version
of this specification.</p>
</dd>
<dt><a href="#dt-dynamic-error">dynamic error</a></dt>
<dd>
<p>An error that is not detected until a source document is being
transformed is referred to as a <b>dynamic error</b>.</p>
</dd>
<dt><a href="#dt-dynamic-evaluation-feature">dynamic evaluation
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>dynamic
evaluation feature</b> <span class="verb">must</span> evaluate the
<a href="#element-evaluate"><code>xsl:evaluate</code></a> function
as described in this specification.</p>
</dd>
<dt><a href="#dt-effective-value">effective value</a></dt>
<dd>
<p>The result of evaluating a value template is referred to as its
<b>effective value</b>.</p>
</dd>
<dt><a href="#dt-effective-version">effective version</a></dt>
<dd>
<p>The <b>effective version</b> of an element in a <span><a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title=
"package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span> is the decimal
value of the <code>[xsl:]version</code> attribute (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>) on that
element or on the innermost ancestor element that has such an
attribute, excluding the <code>version</code> attribute on an
<a href="#element-output"><code>xsl:output</code></a> element.</p>
</dd>
<dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet
module</a></dt>
<dd>
<p>An <b>embedded stylesheet module</b> is a stylesheet module that
is embedded within another XML document, typically the source
document that is being transformed.</p>
</dd>
<dt><a href="#dt-eqname">EQName</a></dt>
<dd>
<p>An <b>EQName</b> is a string representing a <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> where the string, after removing leading and trailing
whitespace, is in the form defined by the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
production in the XPath specification.</p>
</dd>
<dt><a href="#dt-expanded-qname">expanded QName</a></dt>
<dd>
<p>An <b>expanded QName</b> is a value in the value space of the
<code>xs:QName</code> datatype as defined in the XDM data model
(see <a href="#xpath-datamodel-30">[Data Model]</a>): that is, a
triple containing namespace prefix (optional), namespace URI
(optional), and local name. Two expanded QNames are equal if the
namespace URIs are the same (or both absent) and the local names
are the same. The prefix plays no part in the comparison, but is
used only if the expanded QName needs to be converted back to a
string.</p>
</dd>
<dt><a href="#dt-exposed-visibility">exposed visibility</a></dt>
<dd>
<p>The <b>exposed visibility</b> of a component is established by
an <a href="#element-expose"><code>xsl:expose</code></a> element in
the package manifest.</p>
</dd>
<dt><a href="#dt-expression">expression</a></dt>
<dd>
<p>Within this specification, the term <b>XPath expression</b>, or
simply <b>expression</b>, means a string that matches the
production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>
defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
</dd>
<dt><a href="#dt-extension-attribute">extension attribute</a></dt>
<dd>
<p>An element from the XSLT namespace may have any attribute not
from the XSLT namespace, provided that the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> (see <a href="#xpath-30">[XPath 3.0]</a>) of the
attribute has a non-null namespace URI. These attributes are
referred to as <b>extension attributes</b>.</p>
</dd>
<dt><a href="#dt-extension-function">extension function</a></dt>
<dd>
<p>An <b>extension function</b> is a function that is available for
use within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, other than a <a title=
"core function" class="termref" href="#dt-core-function">core
function</a> defined in <a href="#xpath-functions-30">[Functions
and Operators]</a>, an additional function defined in this XSLT
specification, a constructor function named after an atomic type,
or a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined using an
<a href="#element-function"><code>xsl:function</code></a>
declaration.</p>
</dd>
<dt><a href="#dt-extension-instruction">extension
instruction</a></dt>
<dd>
<p>An <b>extension instruction</b> is an element within a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is in a
namespace (not the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>) designated as an extension
namespace.</p>
</dd>
<dt><a href="#dt-extension-namespace">extension namespace</a></dt>
<dd>
<p>The <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> mechanism
allows namespaces to be designated as <b>extension namespaces</b>.
When a namespace is designated as an extension namespace and an
element with a name from that namespace occurs in a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, then the
element is treated as an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> rather than as a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
</dd>
<dt><a href="#dt-final-output-state">final output state</a></dt>
<dd>
<p>The first of the two <a title="output state" class="termref"
href="#dt-output-state">output states</a> is called <b>final
output</b> state. This state applies when instructions are writing
to a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
</dd>
<dt><a href="#dt-final-result-tree">final result tree</a></dt>
<dd>
<p>A <b>final result tree</b> is a <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> that forms part of
the final output of a transformation. Once created, the contents of
a final result tree are not accessible within the stylesheet
itself.</p>
</dd>
<dt><a href="#dt-focus">focus</a></dt>
<dd>
<p>When a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated,
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> keeps track of which items are being
processed by means of a set of implicit variables referred to
collectively as the <b>focus</b>.</p>
</dd>
<dt><a href="#dt-focus-changing-construct">focus-changing
construct</a></dt>
<dd>
<p>A <b>focus-changing construct</b> is a <a title="construct"
class="termref" href="#dt-construct">construct</a> that has one or
more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a different
<a title="focus" class="termref" href="#dt-focus">focus</a> from
the parent construct.</p>
</dd>
<dt><a href="#dt-focus-setting-container">focus-setting
container</a></dt>
<dd>
<p>The <b>focus-setting container</b> of a construct <var>C</var>
is the innermost <a title="focus-changing construct" class=
"termref" href="#dt-focus-changing-construct">focus-changing
construct</a> <var>F</var> (if one exists) such that <var>C</var>
is directly or indirectly contained in a <a title=
"controlled operand" class="termref" href=
"#dt-controlled-operand">controlled operand</a> of <var>F</var>.
<span>If there is no such construct <var>F</var>, then the
focus-setting container is the containing <a title="declaration"
class="termref" href="#dt-declaration">declaration</a>, for example
an <a href="#element-function"><code>xsl:function</code></a> or
<a href="#element-template"><code>xsl:template</code></a>
element.</span></p>
</dd>
<dt><a href="#dt-forwards-compatible-behavior">forwards compatible
behavior</a></dt>
<dd>
<p>An element is processed with <b>forwards compatible behavior</b>
if its <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is greater than
<code>3.0</code>.</p>
</dd>
<dt><a href="#dt-free-ranging">free-ranging</a></dt>
<dd>
<p>A <b>free-ranging</b> construct is any <a title="construct"
class="termref" href="#dt-construct">construct</a> deemed
free-ranging by the rules in this section (<a href=
"#streamability"><i>19 Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-function-conversion-rules">function conversion
rules</a></dt>
<dd>
<p>Except where otherwise indicated, the actual value of an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> is converted to the <a title=
"required type" class="termref" href="#dt-required-type">required
type</a> using the <b>function conversion rules</b>. These are the
rules defined in <a href="#xpath-30">[XPath 3.0]</a> for converting
the supplied argument of a function call to the required type of
that argument, as defined in the function signature. The relevant
rules are those that apply when <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to
<code>false</code>.</p>
</dd>
<dt><a href="#dt-function-parameter">function parameter</a></dt>
<dd>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-function"><code>xsl:function</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>function parameter</b>. A function parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the function is called, using a function call in an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.</p>
</dd>
<dt><a href="#dt-general-streamability-rules">general streamability
rules</a></dt>
<dd>
<p>Many <a title="construct" class="termref" href=
"#dt-construct">constructs</a> share the same streamability rules.
These rules, referred to as the <b>general streamability rules</b>,
are defined here.</p>
</dd>
<dt><a href="#dt-global-variable">global variable</a></dt>
<dd>
<p>A top-level <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable-binding element</a>
declares a <b>global variable</b> that is visible everywhere
(except <span>within its own declaration, and</span> where it is
<a title="shadows" class="termref" href="#dt-shadows">shadowed</a>
by another binding).</p>
</dd>
<dt><a href="#dt-grounded">grounded</a></dt>
<dd>
<p><b>Grounded</b>: indicates that the value returned by the
construct does not contain nodes from the streamed input
document</p>
</dd>
<dt><a href="#dt-group">group</a></dt>
<dd>
<p>The <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction allocates the items in an input sequence into
<b>groups</b> of items (that is, it establishes a collection of
sequences) based either on common values of a grouping key, or on a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
that the initial or final <span>item</span> in a group must
match.</p>
</dd>
<dt><a href="#dt-grouping-key">grouping key</a></dt>
<dd>
<p>If either of the <code>group-by</code> or
<code>group-adjacent</code> attributes is present, then for each
item in the <a title="population" class="termref" href=
"#dt-population">population</a> a set of <b>grouping keys</b> is
calculated, as follows: the expression contained in the
<code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated; the result is atomized; and any
<code>xs:untypedAtomic</code> values are cast to
<code>xs:string</code>. <span>If <code>composite="yes"</code> is
specified, there is a single grouping key whose value is the
resulting sequence; otherwise, there is a set of grouping keys,
consisting of the distinct atomic values present in the result
sequence.</span></p>
</dd>
<dt><a href=
"#dt-guaranteed-streamable">guaranteed-streamable</a></dt>
<dd>
<p>A <b>guaranteed-streamable</b> construct is a <a title=
"construct" class="termref" href="#dt-construct">construct</a> that
is declared to be streamable and that follows the particular rules
for that construct to make streaming possible, as defined by the
analysis in this specification.</p>
</dd>
<dt><a href="#dt-higher-order-operand">higher-order
operand</a></dt>
<dd>
<p>Whether or not the operand is <b>higher-order</b>. For this
purpose an operand <var>O</var> of a construct <var>C</var> is
higher-order if the semantics of <var>C</var> potentially require
<var>O</var> to be evaluated more than once during a single
evaluation of <var>C</var>.</p>
</dd>
<dt><a href="#dt-homonymous">homonymous</a></dt>
<dd>
<p>Two <a title="component" class="termref" href=
"#dt-component">components</a> are said to be <b>homonymous</b> if
they have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>.</p>
</dd>
<dt><a href="#dt-identical-types">identical (types)</a></dt>
<dd>
<p>Types S and T are considered <b>identical</b> for the purpose of
these rules if and only if <code>subtype(S, T)</code> and
<code>subtype(T, S)</code> both hold, where the subtype relation is
defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-seqtype-subtype">Section 2.5.6.1
The judgement subtype(A, B)</a> <sup><small>XP30</small></sup>.</p>
</dd>
<dt><a href="#dt-implementation">implementation</a></dt>
<dd>
<p>A specific product that performs the functions of an <a title=
"processor" class="termref" href="#dt-processor">XSLT processor</a>
is referred to as an <b>implementation</b>.</p>
</dd>
<dt><a href=
"#dt-implementation-defined">implementation-defined</a></dt>
<dd>
<p>In this specification, the term <b>implementation-defined</b>
refers to a feature where the implementation is allowed some
flexibility, and where the choices made by the implementation
<span class="verb">must</span> be described in documentation that
accompanies any conformance claim.</p>
</dd>
<dt><a href=
"#dt-implementation-dependent">implementation-dependent</a></dt>
<dd>
<p>The term <b>implementation-dependent</b> refers to a feature
where the behavior <span class="verb">may</span> vary from one
implementation to another, and where the vendor is not expected to
provide a full specification of the behavior.</p>
</dd>
<dt><a href="#dt-import-precedence">import precedence</a></dt>
<dd>
<p>A <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> <var>D</var> in the stylesheet is
defined to have lower <b>import precedence</b> than another
declaration <var>E</var> if the stylesheet level containing
<var>D</var> would be visited before the stylesheet level
containing <var>E</var> in a post-order traversal of the import
tree (that is, a traversal of the import tree in which a stylesheet
level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.</p>
</dd>
<dt><a href="#dt-import-tree">import tree</a></dt>
<dd>
<p>The <a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> making up a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
are treated as forming an <b>import tree</b>. In the import tree,
each stylesheet level has one child for each <a href=
"#element-import"><code>xsl:import</code></a> declaration that it
contains.</p>
</dd>
<dt><a href="#dt-in-scope-schema-component">in-scope schema
component</a></dt>
<dd>
<p>The <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> that may be referenced
by name in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> are referred to as the <b>in-scope
schema components</b>. This set is the same throughout all the
modules of a stylesheet.</p>
</dd>
<dt><a href="#dt-initial-context-item">initial context
item</a></dt>
<dd>
<p>An item that acts as the <b>initial context item</b> for the
transformation. This item is accessible within the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
as the initial value of the XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> <code>.</code>
(dot) and <code>self::node()</code>, as described in <a href=
"#focus"><i>5.4.3.1 Maintaining Position: the Focus</i></a></p>
</dd>
<dt><a href="#dt-initial-function">initial function</a></dt>
<dd>
<p>The transformation is performed by evaluating an <b>initial
function</b>.</p>
</dd>
<dt><a href="#dt-initial-item">initial item</a></dt>
<dd>
<p>For each <a title="group" class="termref" href=
"#dt-group">group</a>, the item within the group that is first in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a> is known as the
<b>initial item</b> of the group.</p>
</dd>
<dt><a href="#dt-initial-mode">initial mode</a></dt>
<dd>
<p>The initial mode, if specified, <span class="verb">must</span>
either be the default mode, or a mode that is explicitly named
<span>either in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span> in
the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> declaration
within the stylesheet. If an initial mode is supplied, then in
searching for the <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that best matches the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span>, the
processor considers only those rules that apply to the initial
mode. If no initial mode is supplied, then the mode used is that
named in the <span><code>default-mode</code> attribute of the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element of the <a title="principal stylesheet module" class=
"termref" href="#dt-principal-stylesheet-module">principal
stylesheet module</a>; or failing that, the mode named in the
<code>default-mode</code> attribute of its containing <a href=
"#element-package"><code>xsl:package</code></a> element;</span> or
in the absence of such an attribute, the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p>
</dd>
<dt><a href="#dt-initial-sequence">initial sequence</a></dt>
<dd>
<p>The sequence to be sorted is referred to as the <b>initial
sequence</b>.</p>
</dd>
<dt><a href="#dt-initial-template">initial template</a></dt>
<dd>
<p>The transformation is performed by evaluating an <b>initial
template</b>. If a <a title="named template" class="termref" href=
"#dt-named-template">named template</a> is supplied when the
transformation is initiated, then this is the initial template;
otherwise, the initial template is the <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> selected
according to the rules of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction for processing the <span><a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> in the
initial <a title="mode" class="termref" href=
"#dt-mode">mode</a>.</p>
</dd>
<dt><a href="#dt-inspection">inspection</a></dt>
<dd>
<p>An operand usage of <b>inspection</b> indicates that the
construct accesses properties of a supplied node that are available
without reading its subtree.</p>
</dd>
<dt><a href="#dt-instruction">instruction</a></dt>
<dd>
<p>An <b>instruction</b> is either an <a title="XSLT instruction"
class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or
an <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
</dd>
<dt><a href="#dt-key">key</a></dt>
<dd>
<p>A <b>key</b> is defined as a set of <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name.</p>
</dd>
<dt><a href="#dt-key-specifier">key specifier</a></dt>
<dd>
<p>The expression in the <code>use</code> attribute and the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> within an
<a href="#element-key"><code>xsl:key</code></a> declaration are
referred to collectively as the <b>key specifier</b>. The key
specifier determines the values that may be used to find a node
using this <a title="key" class="termref" href=
"#dt-key">key</a>.</p>
</dd>
<dt><a href="#dt-lexical-qname">lexical QName</a></dt>
<dd>
<p>A <b>lexical QName</b> is a string representing a <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> where the string, after removing leading and trailing
whitespace, is within the lexical space of the
<code>xs:QName</code> datatype as defined in XML Schema (see
<a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local
name optionally preceded by a namespace prefix and a colon.</p>
</dd>
<dt><a href="#dt-literal-namespace-uri">literal namespace
URI</a></dt>
<dd>
<p>A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> is called a
<b>literal namespace URI</b>.</p>
</dd>
<dt><a href="#dt-literal-result-element">literal result
element</a></dt>
<dd>
<p>In a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an element in
the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that does not belong to the
<a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> and that is not an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>) is
classified as a <b>literal result element</b>.</p>
</dd>
<dt><a href="#dt-local-variable">local variable</a></dt>
<dd>
<p>As well as being allowed as a <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a>, the <a href=
"#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a>. Such a
variable is known as a <b>local variable</b>.</p>
</dd>
<dt><a href="#dt-map">map</a></dt>
<dd>
<p>A map consists of a set of entries. Each entry comprises a key
which is an arbitrary atomic value, and an arbitrary sequence
called the associated value.</p>
</dd>
<dt><a href="#dt-match-type">match type</a></dt>
<dd>
<p>The <b>match type</b> of a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> is the most specific
<code>ItemType</code> that is known to match all items that the
pattern can match.</p>
</dd>
<dt><a href="#dt-merge-activation">merge activation</a></dt>
<dd>
<p>A <b>merge activation</b> is a single evaluation of the sequence
constructor contained within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element,
which occurs once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a>.</p>
</dd>
<dt><a href="#dt-merge-input-sequence">merge input
sequence</a></dt>
<dd>
<p>A <b>merge input sequence</b> is an arbitrary <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup>
of items which is already sorted according to the <a title=
"merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> for the
corresponding <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a>.</p>
</dd>
<dt><a href="#dt-merge-key-component">merge key component</a></dt>
<dd>
<p>A <b>merge key component</b> specifies one component of a
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>; it
corresponds to a single <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element in the
stylesheet.</p>
</dd>
<dt><a href="#dt-merge-key-specification">merge key
specification</a></dt>
<dd>
<p>A <b>merge key specification</b> consists of one or more
adjacent <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements which
together define how the <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequences</a>
selected by a <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a> are
sorted. Each <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element defines
one <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a>.</p>
</dd>
<dt><a href="#dt-merge-key-value">merge key value</a></dt>
<dd>
<p>For each item in a <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequence</a>,
a value is computed for each <a title="merge key component" class=
"termref" href="#dt-merge-key-component">merge key component</a>
within the <a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>. The
value computed for an item by using the <var>N</var>th <a title=
"merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> is referred to as
the <var>N</var>th <b>merge key value</b> of that item.</p>
</dd>
<dt><a href="#dt-merge-source-definition">merge source
definition</a></dt>
<dd>
<p>A <b>merge source definition</b> is the definition of one kind
of input to the merge operation. It selects zero or more <a title=
"merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequences</a>, and it
includes a <a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> to define
how the <span><a title="merge key value" class="termref" href=
"#dt-merge-key-value">merge key values</a></span> are computed for
each such merge input sequence.</p>
</dd>
<dt><a href="#dt-mode">mode</a></dt>
<dd>
<p><b>Modes</b> allow a node in a <a title="source tree" class=
"termref" href="#dt-source-tree">source tree</a> to be processed
multiple times, each time producing a different result. They also
allow different sets of <a title="template rule" class="termref"
href="#dt-template-rule">template rules</a> to be active when
processing different trees, for example when processing documents
loaded using the <a href="#func-document"><code>document</code></a>
function (see <a href="#func-document"><i>20.1 fn:document</i></a>)
or when processing <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>.</p>
</dd>
<dt><a href="#dt-mode-definition">mode definition</a></dt>
<dd>
<p>All the <a href="#element-mode"><code>xsl:mode</code></a>
declarations in a stylesheet that share the same name are grouped
into a named <b>mode definition</b>; those that have no name are
grouped into a single unnamed mode definition.</p>
</dd>
<dt><a href="#dt-motionless">motionless</a></dt>
<dd>
<p>A <b>motionless</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed motionless by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-named-template">named template</a></dt>
<dd>
<p>Templates can be invoked by name. An <a href=
"#element-template"><code>xsl:template</code></a> element with a
<code>name</code> attribute defines a <b>named template</b>.</p>
</dd>
<dt><a href="#dt-namespace-fixup">namespace fixup</a></dt>
<dd>
<p>The rules for the individual XSLT instructions that construct a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> (see <a href=
"#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>)
prescribe some of the situations in which namespace nodes are
written to the tree. These rules, however, are not sufficient to
ensure that the prescribed constraints are always satisfied. The
XSLT processor <span class="verb">must</span> therefore add
additional namespace nodes to satisfy these constraints. This
process is referred to as <b>namespace fixup</b>.</p>
</dd>
<dt><a href="#dt-navigation">navigation</a></dt>
<dd>
<p>An operand usage of <b>navigation</b> indicates that the
construct may navigate freely from the supplied node to other nodes
in the same tree, in a way that is not constrained by the
streamability rules.</p>
</dd>
<dt><a href="#dt-non-contextual-function-call">non-contextual
function call</a></dt>
<dd>
<p>The term <b>non-contextual function call</b> is used to refer to
function calls that do not pass the dynamic context to the called
function. This includes all calls on <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a> and all <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-function-invocation">dynamic
function invocations</a><sup><small>XP30</small></sup>, (that is
calls to function items as permitted by XPath 3.0). It does not
include calls to all <a title="core function" class="termref" href=
"#dt-core-function">core functions</a> in particular those that
explicitly depend on the context, such as the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-regex-group"><code>regex-group</code></a> functions. It is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether,
and under what circumstances, calls to <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> are
non-contextual.</p>
</dd>
<dt><a href="#dt-non-positional-predicate">non-positional
predicate</a></dt>
<dd>
<p>A predicate is a <b>non-positional predicate</b> if it satisfies
both of the following conditions:</p>
</dd>
<dt><a href="#dt-non-schema-aware-processor">non-schema-aware
processor</a></dt>
<dd>
<p>A <b>non-schema-aware processor</b> is a processor that does not
claim conformance with the schema-aware conformance feature. Such a
processor <span class="verb">must</span> handle constructs
associated with schema-aware processing as described in this
section.</p>
</dd>
<dt><a href="#dt-operand">operand</a></dt>
<dd>
<p>In an actual instance of a construct, there will be a number of
<b>operands</b>.</p>
</dd>
<dt><a href="#dt-operand-role">operand role</a></dt>
<dd>
<p>For every construct kind, there is a set of zero or more
<b>operand roles</b>.</p>
</dd>
<dt><a href="#dt-operand-usage">operand usage</a></dt>
<dd>
<p>The <b>operand usage</b>. This gives information, in the case
where the operand value contains nodes, about how those nodes are
used. The operand usage takes one of the values <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>, or <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</dd>
<dt><a href="#dt-first-appearance">order of first
appearance</a></dt>
<dd>
<p>There is a <span>total</span> ordering among <a title="group"
class="termref" href="#dt-group">groups</a> referred to as the
<b>order of first appearance</b>. A group <var>G</var> is defined
to precede a group <var>H</var> in order of first appearance if the
<a title="initial item" class="termref" href=
"#dt-initial-item">initial item</a> of <var>G</var> precedes the
initial item of <var>H</var> in population order. If two groups
<var>G</var> and <var>H</var> have the same initial item (because
the item is in both groups) then <var>G</var> precedes <var>H</var>
if the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> of <var>G</var> precedes the
grouping key of <var>H</var> in the sequence that results from
evaluating the <code>group-by</code> expression of this initial
item.</p>
</dd>
<dt><a href="#dt-output-definition">output definition</a></dt>
<dd>
<p>All the <a href="#element-output"><code>xsl:output</code></a>
declarations <span>within a <a title="package" class="termref"
href="#dt-package">package</a></span> that share the same name are
grouped into a named <b>output definition</b>; those that have no
name are grouped into a single unnamed output definition.</p>
</dd>
<dt><a href="#dt-output-state">output state</a></dt>
<dd>
<p>Each instruction in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> is evaluated in one of two
possible <b>output states</b>: <a title="final output state" class=
"termref" href="#dt-final-output-state">final output state</a> or
<a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a></p>
</dd>
<dt><a href="#dt-override">override</a></dt>
<dd>
<p>A component in a using package may <b>override</b> a component
in a used package, provided that the <a title="visibility" class=
"termref" href="#dt-visibility">visibility</a> of the component in
the used package is either <code>abstract</code> or
<code>public</code>. The overriding declaration is written as a
child of the <a href=
"#element-override"><code>xsl:override</code></a> element, which in
turn appears as a child of <a href=
"#element-use-package"><code>xsl:use-package</code></a>.</p>
</dd>
<dt><a href="#dt-package">package</a></dt>
<dd>
<p>A <b>package</b> is represented by an <a href=
"#element-package"><code>xsl:package</code></a> element, which will
generally be the outermost element of an XML document.</p>
</dd>
<dt><a href="#dt-package-manifest">package manifest</a></dt>
<dd>
<p>The content of the <a href=
"#element-package"><code>xsl:package</code></a> element is referred
to as the <b>package manifest</b></p>
</dd>
<dt><a href="#dt-parameter">parameter</a></dt>
<dd>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
declares a <b>parameter</b>, which may be a <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title=
"template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a>, a <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a><span>, or an
<a href="#element-iterate"><code>xsl:iterate</code></a>
parameter</span>. A parameter is a <a title="variable" class=
"termref" href="#dt-variable">variable</a> with the additional
property that its value can be set by the caller.</p>
</dd>
<dt><a href="#dt-pattern">pattern</a></dt>
<dd>
<p>A <b>pattern</b> specifies a set of conditions on an
<span>item</span>. An <span>item</span> that satisfies the
conditions matches the pattern; an <span>item</span> that does not
satisfy the conditions does not match the pattern.</p>
</dd>
<dt><a href="#dt-picture-string">picture string</a></dt>
<dd>
<p>The <b>picture string</b> is the string supplied as the second
argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.</p>
</dd>
<dt><a href="#dt-place-marker">place marker</a></dt>
<dd>
<p>The <a href="#element-number"><code>xsl:number</code></a>
instruction performs two tasks: firstly, determining a <b>place
marker</b> (this is a sequence of integers, to allow for hierarchic
numbering schemes such as <code>1.12.2</code> or
<code>3(c)ii</code>), and secondly, formatting the place marker for
output as a text node in the result sequence.</p>
</dd>
<dt><a href="#dt-population">population</a></dt>
<dd>
<p>The sequence of items to be grouped, which is referred to as the
<b>population</b>, is determined by evaluating the XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
contained in the <code>select</code> attribute.</p>
</dd>
<dt><a href="#dt-population-order">population order</a></dt>
<dd>
<p>The population is treated as a sequence; the order of items in
this sequence is referred to as <b>population order</b></p>
</dd>
<dt><a href="#dt-post-descent-instruction">post-descent
instruction</a></dt>
<dd>
<p>A <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> having no
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instruction as a following sibling is
referred to as a <b>post-descent instruction</b>.</p>
</dd>
<dt><a href="#dt-posture">posture</a></dt>
<dd>
<p>The <b>posture</b> of the expression. This captures information
about the way in which the streamed input document is positioned on
return from evaluating the construct. The posture takes one of the
values <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, <a title="striding" class="termref"
href="#dt-striding">striding</a>, <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a>, <a title="roaming"
class="termref" href="#dt-roaming">roaming</a>, or <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>.</p>
</dd>
<dt><a href="#dt-potential-visibility">potential
visibility</a></dt>
<dd>
<p>The <b>potential visibility</b> of a component is established
when the component is declared or accepted into a package.</p>
</dd>
<dt><a href="#dt-potentially-consuming">potentially
consuming</a></dt>
<dd>
<p>An <a title="operand" class="termref" href=
"#dt-operand">operand</a> is <b>potentially consuming</b> if either
or both of the following conditions applies:</p>
</dd>
<dt><a href="#dt-pre-descent-instruction">pre-descent
instruction</a></dt>
<dd>
<p>A <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> having no
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instruction as a preceding sibling is
referred to as a <b>pre-descent instruction</b>.</p>
</dd>
<dt><a href="#dt-principal-stylesheet-module">principal stylesheet
module</a></dt>
<dd>
<p>For a given transformation, one <a title="stylesheet module"
class="termref" href="#dt-stylesheet-module">stylesheet module</a>
functions as the <b>principal stylesheet module</b>. The complete
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> is assembled by finding the
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> referenced directly
or indirectly from the principal stylesheet module using <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a> elements: see
<a href="#include"><i>3.12.2 Stylesheet Inclusion</i></a> and
<a href="#import"><i>3.12.3 Stylesheet Import</i></a>.</p>
</dd>
<dt><a href="#dt-priority">priority</a></dt>
<dd>
<p>The <b>priority</b> of a template rule is specified by the
<code>priority</code> attribute on the <a href=
"#element-template"><code>xsl:template</code></a> declaration. If
no priority is specified explicitly for a template rule, its
<a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> is used, as defined in
<a href="#default-priority"><i>6.5 Default Priority for Template
Rules</i></a>.</p>
</dd>
<dt><a href="#dt-processing-order">processing order</a></dt>
<dd>
<p>There is another <span>total</span> ordering among groups
referred to as <b>processing order</b>. If group <var>R</var>
precedes group <var>S</var> in processing order, then in the result
sequence returned by the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction the items generated by processing group <var>R</var>
will precede the items generated by processing group
<var>S</var>.</p>
</dd>
<dt><a href="#dt-processor">processor</a></dt>
<dd>
<p>The software responsible for transforming source trees into
result trees using an XSLT stylesheet is referred to as the
<b>processor</b>. This is sometimes expanded to <em>XSLT
processor</em> to avoid any confusion with other processors, for
example an XML processor.</p>
</dd>
<dt><a href="#dt-raw-result">raw result</a></dt>
<dd>
<p>The result of invoking the selected component, after any
required conversion to the declared result type of the component,
is referred to as the <b>raw result</b>.</p>
</dd>
<dt><a href="#dt-reference-resolution">reference
resolution</a></dt>
<dd>
<p>The process of identifying the <a title="component" class=
"termref" href="#dt-component">component</a> to which a <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> applies (possibly
chosen from several <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> alternatives) is called
<b>reference binding</b>.</p>
</dd>
<dt><a href="#dt-required-type">required type</a></dt>
<dd>
<p>The context within a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> where an XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
appears may specify the <b>required type</b> of the expression. The
required type indicates the type of the value that the expression
is expected to return.</p>
</dd>
<dt><a href="#dt-reserved-namespace">reserved namespace</a></dt>
<dd>
<p>The XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as <b>reserved
namespaces</b> and <span class="verb">must</span> be used only as
specified in this and related specifications.</p>
</dd>
<dt><a href="#dt-result-tree">result tree</a></dt>
<dd>
<p>The term <b>result tree</b> is used to refer to any tree
constructed by <a title="instruction" class="termref" href=
"#dt-instruction">instructions</a> in the stylesheet. A result tree
is either a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>.</p>
</dd>
<dt><a href="#dt-roaming">roaming</a></dt>
<dd>
<p><b>Roaming</b>: indicates that the nodes returned by an
expression could be anywhere in the tree, which inevitably means
that the construct cannot be evaluated using streaming.</p>
</dd>
<dt><a href="#dt-same-key">same key</a></dt>
<dd>
<p>Within a map, no two entries have the <b>same key</b>. <span>Two
atomic values <code>K1</code> and <code>K2</code> are the <b>same
key</b> for this purpose if the relation <code>deep-equal(K1, K2,
$UCC)</code> holds, where <code>$UCC</code> is the Unicode
codepoint collation.</span></p>
</dd>
<dt><a href="#dt-schema-component">schema component</a></dt>
<dd>
<p>Type definitions and element and attribute declarations are
referred to collectively as <b>schema components</b>.</p>
</dd>
<dt><a href="#dt-schema-instance-namespace">schema instance
namespace</a></dt>
<dd>
<p>The <b>schema instance namespace</b>
<code>http://www.w3.org/2001/XMLSchema-instance</code> is used as
defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p>
</dd>
<dt><a href="#dt-schema-namespace">schema namespace</a></dt>
<dd>
<p>The <b>schema namespace</b>
<code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
<a href="#xmlschema-1">[XML Schema Part 1]</a></p>
</dd>
<dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a></dt>
<dd>
<p>A <b>schema-aware XSLT processor</b> is an XSLT processor that
implements the mandatory requirements of this specification
connected with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type
attributes</code>, and the ability to handle input documents whose
nodes have type annotations other than <code>xs:untyped</code> and
<code>xs:untypedAtomic</code>. The mandatory requirements of this
specification are taken to include the mandatory requirements of
<span>XPath 3.0</span>, as described in <a href="#xpath-30">[XPath
3.0]</a>. A requirement is mandatory unless the specification
includes wording (such as the use of the words <span class=
"verb">should</span> or <span class="verb">may</span>) that clearly
indicates that it is optional.</p>
</dd>
<dt><a href="#dt-sequence-constructor">sequence
constructor</a></dt>
<dd>
<p>A <b>sequence constructor</b> is a sequence of zero or more
sibling nodes in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that can be evaluated to return a
sequence of nodes, atomic values, <span>and function items</span>.
The way that the resulting sequence is used depends on the
containing instruction.</p>
</dd>
<dt><a href="#dt-serialization">serialization</a></dt>
<dd>
<p>A frequent requirement is to output a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as an XML document
(or in other formats such as HTML). This process is referred to as
<b>serialization</b>.</p>
</dd>
<dt><a href="#dt-serialization-error">serialization error</a></dt>
<dd>
<p>If a transformation has successfully produced a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, it is still possible
that errors may occur in serializing the result tree. For example,
it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a
<b>serialization error</b>.</p>
</dd>
<dt><a href="#dt-serialization-feature">serialization
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>serialization
feature</b> <span class="verb">must</span> support the conversion
of a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to a sequence of
octets following the rules defined in <a href=
"#serialization"><i>25 Serialization</i></a>.</p>
</dd>
<dt><a href="#dt-shadows">shadows</a></dt>
<dd>
<p>A binding <b>shadows</b> another binding if the binding occurs
at a point where the other binding is visible, and the bindings
have the same name.</p>
</dd>
<dt><a href="#dt-simplified-stylesheet-module">simplified
stylesheet module</a></dt>
<dd>
<p>A <b>simplified stylesheet module</b> is a tree, or part of a
tree, consisting of a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a> together with its descendant nodes and associated
attributes and namespaces. This element is not itself in the XSLT
namespace, but it <span class="verb">must</span> have an
<code>xsl:version</code> attribute, which implies that it
<span class="verb">must</span> have a namespace node that declares
a binding for the XSLT namespace. For further details see <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>.</p>
</dd>
<dt><a href="#dt-singleton-focus">singleton focus</a></dt>
<dd>
<p>A <b>singleton focus</b> based on an item <var>J</var> has the
<span><a title="context item" class="termref" href=
"#dt-context-item">context item</a> (and therefore the <a title=
"context node" class="termref" href="#dt-context-node">context
node</a>, if <var>J</var> is a node)</span> set to <var>J</var>,
and the <a title="context position" class="termref" href=
"#dt-context-position">context position</a> and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> both set to 1 (one).</p>
</dd>
<dt><a href="#dt-snapshot">snapshot</a></dt>
<dd>
<p>A <b>snapshot</b> of a node <var>N</var> is a deep copy of
<var>N</var>, as produced by the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
<code>copy-namespaces</code> set to <code>yes</code> and
<code>validation</code> set to <code>preserve</code>, with the
additional property that for every ancestor of <var>N</var>, the
copy also has a corresponding ancestor whose name, node-kind, and
base URI are the same as the corresponding ancestor of
<var>N</var>, and that has copies of the attributes and namespaces
of the corresponding ancestor of <var>N</var>. But the ancestor has
a type annotation of <code>xs:anyType</code>, has the properties
<code>nilled</code>, <code>is-id</code>, and <code>is-idref</code>
set to false, and has no children other than the child that is a
copy of <var>N</var> or one of its ancestors.</p>
</dd>
<dt><a href="#dt-sort-key-component">sort key component</a></dt>
<dd>
<p>Within a <a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>, each
<a href="#element-sort"><code>xsl:sort</code></a> element defines
one <b>sort key component</b>.</p>
</dd>
<dt><a href="#dt-sort-key-specification">sort key
specification</a></dt>
<dd>
<p>A <b>sort key specification</b> is a sequence of one or more
adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements
which together define rules for sorting the items in an input
sequence to form a sorted sequence.</p>
</dd>
<dt><a href="#dt-sort-key-value">sort key value</a></dt>
<dd>
<p>For each item in the <a title="initial sequence" class="termref"
href="#dt-initial-sequence">initial sequence</a>, a value is
computed for each <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a> within the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>. The value
computed for an item by using the <var>N</var>th sort key component
is referred to as the <var>N</var>th <b>sort key value</b> of that
item.</p>
</dd>
<dt><a href="#dt-sorted-sequence">sorted sequence</a></dt>
<dd>
<p>The sequence after sorting as defined by the <a href=
"#element-sort"><code>xsl:sort</code></a> elements is referred to
as the <b>sorted sequence</b>.</p>
</dd>
<dt><a href="#dt-source-tree">source tree</a></dt>
<dd>
<p>The term <b>source tree</b> means any tree provided as input to
the transformation. This includes the document containing the
<span><a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a></span> if any,
documents containing nodes supplied as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, documents
obtained from the results of functions such as <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>documents read using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction,</span>
and documents returned by extension functions or extension
instructions. In the context of a particular XSLT instruction, the
term <b>source tree</b> means any tree provided as input to that
instruction; this may be a source tree of the transformation as a
whole, or it may be a <a title="temporary tree" class="termref"
href="#dt-temporary-tree">temporary tree</a> produced during the
course of the transformation.</p>
</dd>
<dt><a href="#dt-stable">stable</a></dt>
<dd>
<p>A <a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is said to
be <b>stable</b> if its first <a href=
"#element-sort"><code>xsl:sort</code></a> element has no
<code>stable</code> attribute, or has a <code>stable</code>
attribute whose <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is <code>yes</code>.</p>
</dd>
<dt><a href="#dt-standalone-stylesheet-module">standalone
stylesheet module</a></dt>
<dd>
<p>A <b>standalone stylesheet module</b> is a stylesheet module
that comprises the whole of an XML document.</p>
</dd>
<dt><a href="#dt-standard-attributes">standard attributes</a></dt>
<dd>
<p>There are a number of <b>standard attributes</b> that may appear
on any <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a>: specifically
<code>default-collation</code>, <code>default-mode</code>,
<code>default-validation</code>,
<code>exclude-result-prefixes</code>,
<span><code>expand-text</code>,</span>
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and <code>xpath-default-namespace</code>.</p>
</dd>
<dt><a href="#dt-standard-error-namespace">standard error
namespace</a></dt>
<dd>
<p>The <b>standard error namespace</b>
<code>http://www.w3.org/2005/xqt-errors</code> is used for error
codes defined in this specification and related specifications. It
is also used for the names of certain predefined variables
accessible within the scope of an <a href=
"#element-catch"><code>xsl:catch</code></a> element.</p>
</dd>
<dt><a href="#dt-standard-function-namespace">standard function
namespace</a></dt>
<dd>
<p>The <b>standard function namespace</b>
<code>http://www.w3.org/2005/xpath-functions</code> is used for
functions in the function library defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a> and for
standard functions defined in this specification.</p>
</dd>
<dt><a href="#dt-standard-stylesheet-module">standard stylesheet
module</a></dt>
<dd>
<p>A <b>standard stylesheet module</b> is a tree, or part of a
tree, consisting of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element (see
<a href="#stylesheet-element"><i>3.8 Stylesheet Element</i></a>)
together with its descendant nodes and associated attributes and
namespaces.</p>
</dd>
<dt><a href="#dt-static-error">static error</a></dt>
<dd>
<p>An error that can be detected by examining a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
before execution starts (that is, before the source document and
values of stylesheet parameters are available) is referred to as a
<b>static error</b>.</p>
</dd>
<dt><a href="#dt-static-expression">static expression</a></dt>
<dd>
<p>A <b>static expression</b> is an XPath <a title="expression"
class="termref" href="#dt-expression">expression</a> whose value
must be computed during static analysis of the stylesheet.</p>
</dd>
<dt><a href="#dt-static-parameter">static parameter</a></dt>
<dd>
<p>A <a title="static variable" class="termref" href=
"#dt-static-variable">static variable</a> declared using an
<a href="#element-param"><code>xsl:param</code></a> element is
referred to as a <b>static parameter</b>.</p>
</dd>
<dt><a href="#dt-static-variable">static variable</a></dt>
<dd>
<p>A <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> <a title="variable-binding element"
class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> having
the attribute <code>static="yes"</code> declares a <b>static
variable</b>: that is, a <a title="global variable" class="termref"
href="#dt-global-variable">global variable</a> whose value is known
during static analysis of the stylesheet.</p>
</dd>
<dt><a href="#dt-streamable-mode">streamable mode</a></dt>
<dd>
<p>A <b>streamable mode</b> is a <a title="mode" class="termref"
href="#dt-mode">mode</a> that is declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration with the
attribute <code>streamable="yes"</code>.</p>
</dd>
<dt><a href="#dt-streamed-document">streamed document</a></dt>
<dd>
<p>A <b>streamed document</b> is a <a title="source tree" class=
"termref" href="#dt-source-tree">source tree</a> that is processed
using streaming, that is, without constructing a complete tree of
nodes in memory.</p>
</dd>
<dt><a href="#dt-streamed-document-node">streamed node</a></dt>
<dd>
<p>A <b>streamed node</b> is a node in a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.</p>
</dd>
<dt><a href="#dt-streaming">streaming</a></dt>
<dd>
<p>The term <b>streaming</b> refers to a manner of processing in
which documents (such as source and result documents) are not
represented by a complete tree of nodes occupying memory
proportional to document size, but instead are processed "on the
fly" as a sequence of events, similar in concept to the stream of
events notified by an XML parser to represent markup in lexical
XML.</p>
</dd>
<dt><a href="#dt-streaming-feature">streaming feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>streaming
feature</b> <span class="verb">must</span> use streamed processing
in cases where (a) streaming is requested (for example by using the
attribute <code>streamable="yes"</code> on <a href=
"#element-mode"><code>xsl:mode</code></a>, or the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) and (b)
the constructs in question are <a title="guaranteed-streamable"
class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification.</p>
</dd>
<dt><a href="#dt-striding">striding</a></dt>
<dd>
<p><b>Striding</b>: indicates that the result of a construct is a
sequence of nodes, in document order, that are peers in the sense
that none of them is an ancestor or descendant of any other.</p>
</dd>
<dt><a href="#dt-string-value">string value</a></dt>
<dd>
<p>The term <b>string value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section
5.13 string-value Accessor</a> <sup><small>DM30</small></sup>.
Every node has a <a title="string value" class="termref" href=
"#dt-string-value">string value</a>. For example, the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an element is the concatenation of the <a title=
"string value" class="termref" href="#dt-string-value">string
values</a> of all its descendant text nodes.</p>
</dd>
<dt><a href="#dt-stylesheet">stylesheet</a></dt>
<dd>
<p>A transformation in the XSLT language is expressed in the form
of a <b>stylesheet</b>, whose syntax is well-formed XML <a href=
"#REC-xml">[XML 1.0]</a> conforming to the Namespaces in XML
Recommendation <a href="#xml-names">[Namespaces in XML]</a>.</p>
</dd>
<dt><a href="#dt-stylesheet-function">stylesheet function</a></dt>
<dd>
<p>An <a href="#element-function"><code>xsl:function</code></a>
declaration declares the name, parameters, and implementation of a
<b>stylesheet function</b> that can be called from any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> within the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
</dd>
<dt><a href="#dt-stylesheet-level">stylesheet level</a></dt>
<dd>
<p>A <b>stylesheet level</b> is a collection of <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> connected using
<a href="#element-include"><code>xsl:include</code></a>
declarations: specifically, two stylesheet modules <var>A</var> and
<var>B</var> are part of the same stylesheet level if one of them
includes the other by means of an <a href=
"#element-include"><code>xsl:include</code></a> declaration, or if
there is a third stylesheet module <var>C</var> that is in the same
stylesheet level as both <var>A</var> and <var>B</var>.</p>
</dd>
<dt><a href="#dt-stylesheet-module">stylesheet module</a></dt>
<dd>
<p>A <span><a title="package" class="termref" href=
"#dt-package">package</a></span> consists of one or more
<b>stylesheet modules</b>, each one forming all or part of an XML
document.</p>
</dd>
<dt><a href="#dt-stylesheet-parameter">stylesheet
parameter</a></dt>
<dd>
<p>A top-level <a href="#element-param"><code>xsl:param</code></a>
element declares a <b>stylesheet parameter</b>. A stylesheet
parameter is a global variable with the additional property that
its value can be supplied by the caller when a transformation is
initiated.</p>
</dd>
<dt><a href="#dt-supplied-value">supplied value</a></dt>
<dd>
<p>The value of the variable is computed using the <a title=
"expression" class="termref" href="#dt-expression">expression</a>
given in the <code>select</code> attribute or the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, as described
in <a href="#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>. This value is referred to as the <b>supplied
value</b> of the variable.</p>
</dd>
<dt><a href="#dt-sweep">sweep</a></dt>
<dd>
<p>Every construct has a <b>sweep</b>, which is a measure of the
extent to which the current position in the input stream moves
during the evaluation of the expression. The sweep is one of:
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, or <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> .</p>
</dd>
<dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt>
<dd>
<p>The <b>symbolic identifier</b> of a <a title="component" class=
"termref" href="#dt-component">component</a> is a composite name
used to identify the component uniquely within a package. The
symbolic identifier comprises the kind of component (stylesheet
function, named template, <span>accumulator</span>, attribute set,
global variable, or mode), the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
component (namespace URI plus local name), and in the case of
stylesheet functions, the <a title="arity" class="termref" href=
"#dt-arity">arity</a>.</p>
</dd>
<dt><a href="#dt-symbolic-reference">symbolic reference</a></dt>
<dd>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of a component includes
constructs that can be interpreted as references to other <a title=
"component" class="termref" href="#dt-component">components</a> by
means of their <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. These
constructs are generically referred to as <b>symbolic
references</b>. Examples of constructs that give rise to symbolic
references are the <code>name</code> attribute of <a href=
"#element-call-template"><code>xsl:call-template</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, and <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>; the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>;
XPath variable references referring to global variables; and XPath
function calls referring to <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
<span>or <a title="accumulator function" class="termref" href=
"#dt-accumulator-function">accumulator functions</a></span>.</p>
</dd>
<dt><a href="#dt-tail-position">tail position</a></dt>
<dd>
<p>An <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> <var>J</var> is in a <b>tail
position</b> within a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
<var>SC</var> if it satisfies one of the following conditions:</p>
</dd>
<dt><a href="#dt-target-expression">target expression</a></dt>
<dd>
<p>The string that results from evaluating the expression in the
<code>xpath</code> attribute is referred to as the <b>target
expression</b>.</p>
</dd>
<dt><a href="#dt-target-namespace-uri">target namespace
URI</a></dt>
<dd>
<p>The namespace URI that is to be used in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> as a substitute for a <a title="literal namespace URI"
class="termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is called the <b>target namespace URI</b>.</p>
</dd>
<dt><a href="#dt-template">template</a></dt>
<dd>
<p>An <a href="#element-template"><code>xsl:template</code></a>
declaration defines a <b>template</b>, which contains a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span>; this
sequence constructor is evaluated to determine the result of the
template</span>. A template can serve either as a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>, invoked by matching <span>items</span> against a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>,
or as a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, invoked explicitly by
name. It is also possible for the same template to serve in both
capacities.</p>
</dd>
<dt><a href="#dt-template-parameter">template parameter</a></dt>
<dd>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-template"><code>xsl:template</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>template parameter</b>. A template parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the template is called, using any of the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>.</p>
</dd>
<dt><a href="#dt-template-rule">template rule</a></dt>
<dd>
<p>A stylesheet contains a set of <b>template rules</b> (see
<a href="#rules"><i>6 Template Rules</i></a>). A template rule has
three parts: a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> that is matched against nodes, a
(possibly empty) set of <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameters</a>,
and a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is
evaluated to produce a sequence of items.</p>
</dd>
<dt><a href="#dt-temporary-output-state">temporary output
state</a></dt>
<dd>
<p>The second of the two <a title="output state" class="termref"
href="#dt-output-state">output states</a> is called <b>temporary
output</b> state. This state applies when instructions are writing
to a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> or any other non-final
destination.</p>
</dd>
<dt><a href="#dt-temporary-tree">temporary tree</a></dt>
<dd>
<p>The term <b>temporary tree</b> means any tree that is neither a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> nor a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
</dd>
<dt><a href="#dt-text-value-template">text value template</a></dt>
<dd>
<p>In a text node that is designated as a <b>text value
template</b>, <a title="expression" class="termref" href=
"#dt-expression">expressions</a> can be used by surrounding each
expression with curly brackets (<code>{}</code>).</p>
</dd>
<dt><a href="#dt-top-level">top-level</a></dt>
<dd>
<p>An element occurring as a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a><span>,
<a href="#element-transform"><code>xsl:transform</code></a>, or
<a href="#element-override"><code>xsl:override</code></a></span>
element is called a <b>top-level</b> element.</p>
</dd>
<dt><a href="#dt-transmission">transmission</a></dt>
<dd>
<p>An operand usage of <b>transmission</b> indicates that the
construct will (potentially) return a supplied node as part of its
result to the calling construct (that is, to its parent in the
construct tree).</p>
</dd>
<dt><a href="#dt-traversal">traversal</a></dt>
<dd>
<p>A <b>traversal</b> of a tree is a sequence of <a title=
"traversal-event" class="termref" href=
"#dt-traversal-event">traversal events</a>.</p>
</dd>
<dt><a href="#dt-traversal-event">traversal-event</a></dt>
<dd>
<p>a <b>traversal event</b> (shortened to <b>event</b> in this
section) is a pair comprising a phase (start or end) and a
node.</p>
</dd>
<dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt>
<dd>
<p>A parameter passed to a template may be defined as a <b>tunnel
parameter</b>. Tunnel parameters have the property that they are
automatically passed on by the called template to any further
templates that it calls, and so on recursively.</p>
</dd>
<dt><a href="#dt-annotation">type annotation</a></dt>
<dd>
<p>The term <b>type annotation</b> is used in this specification to
refer to the value returned by the <code>dm:type-name</code>
accessor of a node: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section
5.14 type-name Accessor</a> <sup><small>DM30</small></sup>.</p>
</dd>
<dt><a href="#dt-type-error">type error</a></dt>
<dd>
<p>Certain errors are classified as <b>type errors</b>. A type
error occurs when the value supplied as input to an operation is of
the wrong type for that operation, for example when an integer is
supplied to an operation that expects a node.</p>
</dd>
<dt><a href="#dt-type-determined-usage">type-determined
usage</a></dt>
<dd>
<p>The <b>type-determined usage</b> of an operand is as follows: if
the required type (ignoring occurrence indicator) is
<code>function(*)</code> or a subtype thereof, then <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>;
if the required type (ignoring occurrence indicator) is
<code>xs:anyAtomicType</code> or a subtype thereof, then <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>;
otherwise <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</dd>
<dt><a href="#dt-typed-value">typed value</a></dt>
<dd>
<p>The term <b>typed value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section
5.15 typed-value Accessor</a> <sup><small>DM30</small></sup>. Every
node, <span>other than an element whose type annotation identifies
it as having</span> element-only content, has a <a title=
"string value" class="termref" href="#dt-string-value">typed
value</a>. For example, the <a title="typed value" class="termref"
href="#dt-typed-value">typed value</a> of an attribute of type
<code>xs:IDREFS</code> is a sequence of zero or more
<code>xs:IDREF</code> values.</p>
</dd>
<dt><a href="#dt-unnamed-mode">unnamed mode</a></dt>
<dd>
<p>There is always an <b>unnamed mode</b> available. The unnamed
mode is the default mode used when no <code>mode</code> attribute
is specified on an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction or <a href=
"#element-template"><code>xsl:template</code></a> declaration,
unless a different default mode has been specified using the
<span><code>[xsl:]default-mode</code> attribute of a containing
element</span>.</p>
</dd>
<dt><a href="#dt-uri-reference">URI Reference</a></dt>
<dd>
<p>Within this specification, the term <b>URI Reference</b>, unless
otherwise stated, refers to a string in the lexical space of the
<code>xs:anyURI</code> datatype as defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>.</p>
</dd>
<dt><a href="#dt-use">use</a></dt>
<dd>
<p>If a package <var>Q</var> contains an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
that references package <var>P</var>, then package <var>Q</var> is
said to <b>use</b> package <var>P</var>. In this relationship
package <var>Q</var> is referred to as the <b>using</b> package,
package <var>P</var> as the <b>used</b> package.</p>
</dd>
<dt><a href="#dt-data-element">user-defined data element</a></dt>
<dd>
<p>In addition to <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a>, the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
contain among its children any element not from the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, provided that the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
element has a non-null namespace URI. Such elements are referred to
as <b>user-defined data elements</b>.</p>
</dd>
<dt><a href="#dt-value">value</a></dt>
<dd>
<p>A variable is a binding between a name and a value. The
<b>value</b> of a variable is any sequence (of nodes, atomic
values, <span>and/or function items</span>), as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>.</p>
</dd>
<dt><a href="#dt-value-template">value template</a></dt>
<dd>
<p>Collectively, attribute value templates and text value templates
are referred to as <b>value templates</b>.</p>
</dd>
<dt><a href="#dt-variable">variable</a></dt>
<dd>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element declares a <b>variable</b>, which may be a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> or a <a title="local variable" class="termref" href=
"#dt-local-variable">local variable</a>.</p>
</dd>
<dt><a href="#dt-variable-binding-element">variable-binding
element</a></dt>
<dd>
<p>The two elements <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are referred to as
<b>variable-binding elements</b></p>
</dd>
<dt><a href="#dt-visibility">visibility</a></dt>
<dd>
<p>The <b>visibility</b> of a <a title="component" class="termref"
href="#dt-component">component</a> is one of: <code>private</code>,
<code>public</code>, <code>abstract</code>, <code>final</code>, or
<code>hidden</code>.</p>
</dd>
<dt><a href="#dt-whitespace-text-node">whitespace text
node</a></dt>
<dd>
<p>A <b>whitespace text node</b> is a text node whose content
consists entirely of whitespace characters (that is, #x09, #x0A,
#x0D, or #x20).</p>
</dd>
<dt><a href="#xml-namespace">XML namespace</a></dt>
<dd>
<p>The <b>XML namespace</b>, defined in <a href=
"#xml-names">[Namespaces in XML]</a> as
<code>http://www.w3.org/XML/1998/namespace</code>, is used for
attributes such as <code>xml:lang</code>, <code>xml:space</code>,
and <code>xml:id</code>.</p>
</dd>
<dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility
mode</a></dt>
<dd>
<p>The term <b>XPath 1.0 compatibility mode</b> is defined in
<a href="http://www.w3.org/TR/xpath-30/#static_context">Section
2.1.1 Static Context</a> <sup><small>XP30</small></sup>. This is a
setting in the static context of an XPath expression; it has two
values, <code>true</code> and <code>false</code>. When the value is
set to true, the semantics of function calls and certain other
operations are adjusted to give a greater degree of backwards
compatibility between <span>XPath 3.0</span> and XPath 1.0.</p>
</dd>
<dt><a href="#dt-xquery-invocation-feature">XQuery Invocation
Feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>XQuery
invocation feature</b> <span class="verb">must</span> allow XQuery
library modules to be referenced in <a href=
"#element-use-package"><code>xsl:use-package</code></a>, and must
allow the using package to reference the public functions and
variables declared in the referenced library module.</p>
</dd>
<dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt>
<dd>
<p>An element in the stylesheet is processed with <b>XSLT 1.0
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is equal to
1.0.</p>
</dd>
<dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>XSLT 1.0
compatibility feature</b> <span class="verb">must</span> support
the processing of stylesheet instructions and XPath expressions
with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>.</p>
</dd>
<dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt>
<dd>
<p>An element is processed with <b>XSLT 2.0 behavior</b> if its
<a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 2.0.</p>
</dd>
<dt><a href="#dt-xslt-element">XSLT element</a></dt>
<dd>
<p>An <b>XSLT element</b> is an element in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a> whose syntax and semantics are defined in this
specification.</p>
</dd>
<dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt>
<dd>
<p>An <b>XSLT instruction</b> is an <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT element</a> whose syntax
summary in this specification contains the annotation <code>&lt;!--
category: instruction --&gt;</code>.</p>
</dd>
<dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt>
<dd>
<p>The <b>XSLT namespace</b> has the URI
<code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
identify elements, attributes, and other names that have a special
meaning defined in this specification.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="element-syntax-summary" id=
"element-syntax-summary"></a>D Element Syntax Summary
(Non-Normative)</h2>
<p>The syntax of each XSLT element is summarized below, together
with the context in the stylesheet where the element may appear.
Some elements (specifically, instructions) are allowed as a child
of any element that is allowed to contain a sequence constructor.
These elements are:</p>
<ul>
<li>Literal result elements</li>
<li>Extension instructions, if so defined</li>
</ul>
<p><b><a href="#element-accept">xsl:accept</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accept">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:accept<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract" | "hidden" | "absent"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-use-package">xsl:use-package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-accumulator">xsl:accumulator</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accumulator">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:accumulator<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>initial-value</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br />
&lt;/xsl:accumulator&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-accumulator-rule">xsl:accumulator-rule</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accumulator-rule">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:accumulator-rule<br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;phase? = "start" | "end"<br />
&#160;&#160;<b>new-value</b> =
<var>expression</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-accumulator">xsl:accumulator</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-analyze-string">xsl:analyze-string</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:analyze-string">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:analyze-string<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;<b>regex</b> = { <var>string</var> }<br />
&#160;&#160;flags? = { <var>string</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-matching-substring">xsl:matching-substring</a>?, <a href=
"#element-non-matching-substring">xsl:non-matching-substring</a>?,
<a href="#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:analyze-string&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-apply-imports">xsl:apply-imports</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:apply-imports">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:apply-imports&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:apply-imports&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-apply-templates">xsl:apply-templates</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:apply-templates">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:apply-templates<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;mode? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>
| <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br />
&lt;/xsl:apply-templates&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-assert">xsl:assert</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:assert">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:assert<br />
&#160;&#160;<b>test</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:assert&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-attribute">xsl:attribute</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:attribute">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:attribute<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:attribute&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-attribute-set">xsl:attribute-set</a></li>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-attribute-set">xsl:attribute-set</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:attribute-set">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:attribute-set<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-attribute">xsl:attribute</a>* --&gt;<br />
&lt;/xsl:attribute-set&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-break">xsl:break</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:break">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:break<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:break&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-call-template">xsl:call-template</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:call-template">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:call-template<br />
&#160;&#160;<b>name</b> = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:call-template&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-catch">xsl:catch</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:catch">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:catch<br />
&#160;&#160;errors? = <var>tokens</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:catch&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-try">xsl:try</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-character-map">xsl:character-map</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:character-map">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:character-map<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-character-maps? =
<var>eqnames</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-output-character">xsl:output-character</a>*) --&gt;<br />
&lt;/xsl:character-map&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-choose">xsl:choose</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:choose">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-when">xsl:when</a>+, <a href=
"#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
&lt;/xsl:choose&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-comment">xsl:comment</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:comment">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:comment<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:comment&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-context-item">xsl:context-item</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:context-item">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:context-item<br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" |
"prohibited"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-mode">xsl:mode</a></li>
<li><a href="#element-template">xsl:template</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-copy">xsl:copy</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:copy">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:copy<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;copy-namespaces? = "yes" | "no"<br />
&#160;&#160;inherit-namespaces? = "yes" | "no"<br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:copy&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-copy-of">xsl:copy-of</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:copy-of">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:copy-of<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;copy-namespaces? = "yes" | "no"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-decimal-format">xsl:decimal-format</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:decimal-format">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:decimal-format<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;decimal-separator? = <var>char</var><br />
&#160;&#160;grouping-separator? = <var>char</var><br />
&#160;&#160;infinity? = <var>string</var><br />
&#160;&#160;minus-sign? = <var>char</var><br />
&#160;&#160;NaN? = <var>string</var><br />
&#160;&#160;percent? = <var>char</var><br />
&#160;&#160;per-mille? = <var>char</var><br />
&#160;&#160;zero-digit? = <var>char</var><br />
&#160;&#160;digit? = <var>char</var><br />
&#160;&#160;pattern-separator? =
<var>char</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-document">xsl:document</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:document">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:document<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:document&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-element">xsl:element</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:element">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:element<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;inherit-namespaces? = "yes" | "no"<br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:element&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-evaluate">xsl:evaluate</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:evaluate">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:evaluate<br />
&#160;&#160;<b>xpath</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;base-uri? = { <var>uri</var> }<br />
&#160;&#160;with-params? = <var>expression</var><br />
&#160;&#160;context-item? = <var>expression</var><br />
&#160;&#160;namespace-context? = <var>expression</var><br />
&#160;&#160;schema-aware? = { "yes" | "no" }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:evaluate&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-expose">xsl:expose</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:expose">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:expose<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-fallback">xsl:fallback</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:fallback">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:fallback&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:fallback&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-for-each">xsl:for-each</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:for-each">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:for-each<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-for-each-group">xsl:for-each-group</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:for-each-group">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:for-each-group<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;group-by? = <var>expression</var><br />
&#160;&#160;group-adjacent? = <var>expression</var><br />
&#160;&#160;group-starting-with? = <var>pattern</var><br />
&#160;&#160;group-ending-with? = <var>pattern</var><br />
&#160;&#160;bind-group? = <var>eqname</var><br />
&#160;&#160;bind-grouping-key? = <var>eqname</var><br />
&#160;&#160;composite? = "yes" | "no"<br />
&#160;&#160;collation? = { <var>uri</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each-group&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-fork">xsl:fork</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:fork">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:fork&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-sequence">xsl:sequence</a> | <a href=
"#element-fallback">xsl:fallback</a>))+ --&gt;<br />
&lt;/xsl:fork&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-function">xsl:function</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:function">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:function<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;override-extension-function? = "yes" | "no"<br />
&#160;&#160;<span class="grayed">[override]?</span> = "yes" |
"no"<br />
&#160;&#160;identity-sensitive? = "yes" | "no"<br />
&#160;&#160;cache? = "full" | "partial" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:function&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-if">xsl:if</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:if">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:if<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:if&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-import">xsl:import</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:import">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:import<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-import-schema">xsl:import-schema</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:import-schema">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:import-schema<br />
&#160;&#160;namespace? = <var>uri</var><br />
&#160;&#160;schema-location? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
&lt;/xsl:import-schema&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-include">xsl:include</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:include">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:include<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-iterate">xsl:iterate</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:iterate">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:iterate<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>,
<a href="#element-on-completion">xsl:on-completion</a>?)
--&gt;<br />
&lt;/xsl:iterate&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-key">xsl:key</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:key">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:key<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;use? = <var>expression</var><br />
&#160;&#160;composite? = "yes" | "no"<br />
&#160;&#160;collation? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:key&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-map">xsl:map</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:map">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:map&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-map-entry">xsl:map-entry</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:map-entry">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:map-entry<br />
&#160;&#160;<b>key</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map-entry&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-matching-substring">xsl:matching-substring</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:matching-substring">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:matching-substring&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:matching-substring&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-analyze-string">xsl:analyze-string</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge">xsl:merge</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:merge">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge<br />
&#160;&#160;bind-group? = <var>eqname</var><br />
&#160;&#160;bind-key? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-merge-source">xsl:merge-source</a>+, <a href=
"#element-merge-action">xsl:merge-action</a>, <a href=
"#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:merge&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-action">xsl:merge-action</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-action">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:merge-action&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:merge-action&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge">xsl:merge</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-key">xsl:merge-key</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-key">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge-key<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-key&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge-source">xsl:merge-source</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-source">xsl:merge-source</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-source">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge-source<br />
&#160;&#160;for-each? = <var>expression</var><br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;bind-source? = <var>eqname</var><br />
&#160;&#160;streamable? = "yes" | "no"<br />
&#160;&#160;sort-before-merge? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-merge-key">xsl:merge-key</a>+ --&gt;<br />
&lt;/xsl:merge-source&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge">xsl:merge</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-message">xsl:message</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:message">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:message<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;terminate? = { "yes" | "no" }<br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:message&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-mode">xsl:mode</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:mode">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:mode<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;streamable? = "yes" | "no"<br />
&#160;&#160;on-no-match? = "deep-copy" | "shallow-copy" |
"deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br />
&#160;&#160;on-multiple-match? = "use-last" | "fail"<br />
&#160;&#160;warning-on-no-match? = "yes" | "no"<br />
&#160;&#160;warning-on-multiple-match? = "yes" | "no"<br />
&#160;&#160;typed? = "yes" | "no" | "strict" | "lax" |
"unspecified"<br />
&#160;&#160;visibility? = "public" | "private" |
"final"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?) --&gt;<br />
&lt;/xsl:mode&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-namespace">xsl:namespace</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:namespace">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:namespace<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:namespace&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-namespace-alias">xsl:namespace-alias</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:namespace-alias">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:namespace-alias<br />
&#160;&#160;<b>stylesheet-prefix</b> = <var>prefix</var> |
"#default"<br />
&#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
"#default"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-next-iteration">xsl:next-iteration</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:next-iteration">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:next-iteration&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a>*) --&gt;<br />
&lt;/xsl:next-iteration&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-next-match">xsl:next-match</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:next-match">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:next-match&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:next-match&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-non-matching-substring">xsl:non-matching-substring</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:non-matching-substring">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:non-matching-substring&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:non-matching-substring&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-analyze-string">xsl:analyze-string</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-number">xsl:number</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:number">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:number<br />
&#160;&#160;value? = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;level? = "single" | "multiple" | "any"<br />
&#160;&#160;count? = <var>pattern</var><br />
&#160;&#160;from? = <var>pattern</var><br />
&#160;&#160;format? = { <var>string</var> }<br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;letter-value? = { "alphabetic" | "traditional" }<br />
&#160;&#160;ordinal? = { <var>string</var> }<br />
&#160;&#160;start-at? = { <var>integer</var> }<br />
&#160;&#160;grouping-separator? = { <var>char</var> }<br />
&#160;&#160;grouping-size? = { <var>integer</var>
}&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-on-completion">xsl:on-completion</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:on-completion">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:on-completion<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:on-completion&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-iterate">xsl:iterate</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-otherwise">xsl:otherwise</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:otherwise">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:otherwise&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-choose">xsl:choose</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-output">xsl:output</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:output">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:output<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;method? = "xml" | "html" | "xhtml" | "text" |
<var>eqname</var><br />
&#160;&#160;byte-order-mark? = "yes" | "no"<br />
&#160;&#160;cdata-section-elements? = <var>eqnames</var><br />
&#160;&#160;doctype-public? = <var>string</var><br />
&#160;&#160;doctype-system? = <var>string</var><br />
&#160;&#160;encoding? = <var>string</var><br />
&#160;&#160;escape-uri-attributes? = "yes" | "no"<br />
&#160;&#160;html-version? = <var>decimal</var><br />
&#160;&#160;include-content-type? = "yes" | "no"<br />
&#160;&#160;indent? = "yes" | "no"<br />
&#160;&#160;item-separator? = <var>string</var><br />
&#160;&#160;media-type? = <var>string</var><br />
&#160;&#160;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" |
"fully-normalized" | "none" | <var>nmtoken</var><br />
&#160;&#160;omit-xml-declaration? = "yes" | "no"<br />
&#160;&#160;parameter-document? = <var>uri</var><br />
&#160;&#160;standalone? = "yes" | "no" | "omit"<br />
&#160;&#160;suppress-indentation? = <var>eqnames</var><br />
&#160;&#160;undeclare-prefixes? = "yes" | "no"<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;version? = <var>nmtoken</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-output-character">xsl:output-character</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:output-character">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:output-character<br />
&#160;&#160;<b>character</b> = <var>char</var><br />
&#160;&#160;<b>string</b> = <var>string</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-character-map">xsl:character-map</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-override">xsl:override</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:override">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:override&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-template">xsl:template</a> | <a href=
"#element-function">xsl:function</a> | <a href=
"#element-accumulator">xsl:accumulator</a> | <a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a> | <a href=
"#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br />
&lt;/xsl:override&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-use-package">xsl:use-package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-package">xsl:package</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:package">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:package<br />
&#160;&#160;name? = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*, (<a href=
"#element-stylesheet">xsl:stylesheet</a> | <a href=
"#element-transform">xsl:transform</a>), <a href=
"#element-expose">xsl:expose</a>*) --&gt;<br />
&lt;/xsl:package&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>None</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-param">xsl:param</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:param">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;required? = "yes" | "no"<br />
&#160;&#160;tunnel? = "yes" | "no"<br />
&#160;&#160;static? = "yes" | "no"<br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:param&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
<li><a href="#element-function">xsl:function</a></li>
<li><a href="#element-template">xsl:template</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-perform-sort">xsl:perform-sort</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:perform-sort">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:perform-sort<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:perform-sort&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-preserve-space">xsl:preserve-space</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:preserve-space">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:preserve-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-processing-instruction">xsl:processing-instruction</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:processing-instruction">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:processing-instruction&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-result-document">xsl:result-document</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:result-document">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:result-document<br />
&#160;&#160;format? = { <var>eqname</var> }<br />
&#160;&#160;href? = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;method? = { "xml" | "html" | "xhtml" | "text" |
<var>eqname</var> }<br />
&#160;&#160;byte-order-mark? = { "yes" | "no" }<br />
&#160;&#160;cdata-section-elements? = { <var>eqnames</var> }<br />
&#160;&#160;doctype-public? = { <var>string</var> }<br />
&#160;&#160;doctype-system? = { <var>string</var> }<br />
&#160;&#160;encoding? = { <var>string</var> }<br />
&#160;&#160;escape-uri-attributes? = { "yes" | "no" }<br />
&#160;&#160;html-version? = { <var>decimal</var> }<br />
&#160;&#160;include-content-type? = { "yes" | "no" }<br />
&#160;&#160;indent? = { "yes" | "no" }<br />
&#160;&#160;item-separator? = { <var>string</var> }<br />
&#160;&#160;media-type? = { <var>string</var> }<br />
&#160;&#160;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD"
| "fully-normalized" | "none" | <var>nmtoken</var> }<br />
&#160;&#160;omit-xml-declaration? = { "yes" | "no" }<br />
&#160;&#160;parameter-document? = { <var>uri</var> }<br />
&#160;&#160;standalone? = { "yes" | "no" | "omit" }<br />
&#160;&#160;suppress-indentation? = { <var>eqnames</var> }<br />
&#160;&#160;undeclare-prefixes? = { "yes" | "no" }<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;output-version? = { <var>nmtoken</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:result-document&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-sequence">xsl:sequence</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:sequence">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:sequence<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sequence&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-sort">xsl:sort</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:sort">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:sort<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;stable? = { "yes" | "no" }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sort&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-apply-templates">xsl:apply-templates</a></li>
<li><a href="#element-for-each">xsl:for-each</a></li>
<li><a href="#element-for-each-group">xsl:for-each-group</a></li>
<li><a href="#element-perform-sort">xsl:perform-sort</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-stream">xsl:stream</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:stream">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:stream<br />
&#160;&#160;<b>href</b> = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:stream&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-strip-space">xsl:strip-space</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:strip-space">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:strip-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-stylesheet">xsl:stylesheet</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:stylesheet">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:stylesheet<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;version? = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*,
<var>other-declarations</var>) --&gt;<br />
&lt;/xsl:stylesheet&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>None</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-template">xsl:template</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:template">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:template<br />
&#160;&#160;match? = <var>pattern</var><br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;priority? = <var>decimal</var><br />
&#160;&#160;mode? = <var>tokens</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?, <a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:template&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-text">xsl:text</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:text">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:text<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
&lt;/xsl:text&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-transform">xsl:transform</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:transform">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:transform<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;version? = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = "yes" | "no"<br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-use-package">xsl:use-package</a>*,
<var>other-declarations</var>) --&gt;<br />
&lt;/xsl:transform&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>None</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-try">xsl:try</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:try">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:try<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>,
<a href="#element-catch">xsl:catch</a>, (<a href=
"#element-catch">xsl:catch</a> | <a href=
"#element-fallback">xsl:fallback</a>)*) --&gt;<br />
&lt;/xsl:try&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-use-package">xsl:use-package</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:use-package">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:use-package<br />
&#160;&#160;<b>name</b> = <var>uri</var><br />
&#160;&#160;package-version? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-accept">xsl:accept</a> | <a href=
"#element-override">xsl:override</a>)* --&gt;<br />
&lt;/xsl:use-package&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-value-of">xsl:value-of</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:value-of">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:value-of<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:value-of&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-variable">xsl:variable</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:variable">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:variable<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;static? = "yes" | "no"<br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:variable&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
<li><a href="#element-function">xsl:function</a></li>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-when">xsl:when</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:when">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:when<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:when&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-choose">xsl:choose</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-with-param">xsl:with-param</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:with-param">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:with-param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;tunnel? = "yes" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:with-param&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-apply-templates">xsl:apply-templates</a></li>
<li><a href="#element-apply-imports">xsl:apply-imports</a></li>
<li><a href="#element-call-template">xsl:call-template</a></li>
<li><a href="#element-next-match">xsl:next-match</a></li>
</ul>
</td>
</tr>
</table>
</div>
<div class="div1">
<h2><a name="error-summary" id="error-summary"></a>E Summary of
Error Conditions (Non-Normative)</h2>
<p>This appendix provides a summary of error conditions that a
processor may signal. This list includes all error codes defined in
this specification, but this is not an exhaustive list of all
errors that can occur. Implementations <span class=
"verb">must</span> signal errors using these error codes, and
applications can test for these codes; however, when more than one
rule in the specification is violated, different processors will
not necessarily signal the same error code. Implementations are not
<span class="verb">required</span> to signal errors using the
descriptive text used here.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The appendix is non-normative because the same information is
given normatively elsewhere.</p>
</div>
<p><b>Static errors</b></p>
<dl>
<dt><a href="#err-XTSE0010"><span class="error">ERR
XTSE0010</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an XSLT-defined element is
used in a context where it is not permitted, if a <span class=
"verb">required</span> attribute is omitted, or if the content of
the element does not correspond to the content that is allowed for
the element.</p>
</dd>
<dt><a href="#err-XTSE0020"><span class="error">ERR
XTSE0020</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an attribute (other than an
attribute written using curly brackets in a position where an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted) contains a value that is not one of the permitted values
for that attribute.</p>
</dd>
<dt><a href="#err-XTSE0080"><span class="error">ERR
XTSE0080</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to use a <a title=
"reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a> in the name of a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a named
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, or a <a title=
"character map" class="termref" href="#dt-character-map">character
map</a>.</p>
</dd>
<dt><a href="#err-XTSE0090"><span class="error">ERR
XTSE0090</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for an element from the XSLT
namespace to have an attribute whose namespace is either null (that
is, an attribute with an unprefixed name) or the XSLT namespace,
other than attributes defined for the element in this document.</p>
</dd>
<dt><a href="#err-XTSE0110"><span class="error">ERR
XTSE0110</span></a></dt>
<dd>
<p>The value of the <code>version</code> attribute if present
<span class="verb">must</span> be a number: specifically, it
<span class="verb">must</span> be a valid instance of the type
<code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>.</p>
</dd>
<dt><a href="#err-XTSE0120"><span class="error">ERR
XTSE0120</span></a></dt>
<dd>
<p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element <span class="verb">must not</span> have any text node
children.</p>
</dd>
<dt><a href="#err-XTSE0125"><span class="error">ERR
XTSE0125</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of an
<code>[xsl:]default-collation</code> attribute, after resolving
against the base URI, contains no URI that the implementation
recognizes as a collation URI.</p>
</dd>
<dt><a href="#err-XTSE0130"><span class="error">ERR
XTSE0130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element has a
child element whose name has a null namespace URI.</p>
</dd>
<dt><a href="#err-XTSE0150"><span class="error">ERR
XTSE0150</span></a></dt>
<dd>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> that is
used as the outermost element of a simplified stylesheet module
<span class="verb">must</span> have an <code>xsl:version</code>
attribute.</p>
</dd>
<dt><a href="#err-XTSE0165"><span class="error">ERR
XTSE0165</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the processor is not able to
retrieve the resource identified by the URI reference [ in the
<code>href</code> attribute of <a href=
"#element-include"><code>xsl:include</code></a> or <a href=
"#element-import"><code>xsl:import</code></a> ] , or if the
resource that is retrieved does not contain a stylesheet
module.</p>
</dd>
<dt><a href="#err-XTSE0170"><span class="error">ERR
XTSE0170</span></a></dt>
<dd>
<p>An <a href="#element-include"><code>xsl:include</code></a>
element <span class="verb">must</span> be a <a title="top-level"
class="termref" href="#dt-top-level">top-level</a> element.</p>
</dd>
<dt><a href="#err-XTSE0180"><span class="error">ERR
XTSE0180</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a stylesheet module directly
or indirectly includes itself.</p>
</dd>
<dt><a href="#err-XTSE0190"><span class="error">ERR
XTSE0190</span></a></dt>
<dd>
<p>An <a href="#element-import"><code>xsl:import</code></a> element
<span class="verb">must</span> be a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element.</p>
</dd>
<dt><a href="#err-XTSE0210"><span class="error">ERR
XTSE0210</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a stylesheet module directly
or indirectly imports itself.</p>
</dd>
<dt><a href="#err-XTSE0215"><span class="error">ERR
XTSE0215</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
that contains an <code>xs:schema</code> element has a
<code>schema-location</code> attribute, or if it has a
<code>namespace</code> attribute that conflicts with the target
namespace of the contained schema.</p>
</dd>
<dt><a href="#err-XTSE0220"><span class="error">ERR
XTSE0220</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the synthetic schema
document does not satisfy the constraints described in <a href=
"#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in
Schema Construction and Structure</em>). This includes, without
loss of generality, conflicts such as multiple definitions of the
same name.</p>
</dd>
<dt><a href="#err-XTSE0260"><span class="error">ERR
XTSE0260</span></a></dt>
<dd>
<p>Within an <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a> that is <span class=
"verb">required</span> to be empty, any content other than comments
or processing instructions, including any <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> preserved using
the <code>xml:space="preserve"</code> attribute, is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTSE0265"><span class="error">ERR
XTSE0265</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there is a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> in a <a title=
"package" class="termref" href="#dt-package">package</a> that
specifies <code>input-type-annotations="strip"</code> and another
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that specifies
<code>input-type-annotations="preserve"</code>, <span>or if a
stylesheet module specifies the value <code>strip</code> or
<code>preserve</code> and the same value is not specified on the
<a href="#element-package"><code>xsl:package</code></a> element of
the containing package.</span></p>
</dd>
<dt><a href="#err-XTSE0270"><span class="error">ERR
XTSE0270</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if <span>within any <a title=
"package" class="termref" href="#dt-package">package</a></span> the
same <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration if both have the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>.
Two NameTests are considered the same if they match the same set of
names (which can be determined by comparing them after expanding
namespace prefixes to URIs).</p>
</dd>
<dt><a href="#err-XTSE0280"><span class="error">ERR
XTSE0280</span></a></dt>
<dd>
<p>In the case of a prefixed <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> used as the
value <span>(or as part of the value)</span> of an attribute in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, or appearing within an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> in the stylesheet, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a title=
"defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches the prefix of the <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTSE0340"><span class="error">ERR
XTSE0340</span></a></dt>
<dd>
<p>Where an attribute is defined to contain a <a title="pattern"
class="termref" href="#dt-pattern">pattern</a>, it is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if the pattern does not match the production <a href=
"#doc-xslt30-patterns-Pattern30">Pattern30</a>.</p>
</dd>
<dt><a href="#err-XTSE0350"><span class="error">ERR
XTSE0350</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an unescaped left curly
bracket appears in a fixed part of a value template without a
matching right curly bracket.</p>
</dd>
<dt><a href="#err-XTSE0370"><span class="error">ERR
XTSE0370</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an unescaped right curly
bracket occurs in a fixed part of a value template.</p>
</dd>
<dt><a href="#err-XTSE0500"><span class="error">ERR
XTSE0500</span></a></dt>
<dd>
<p>An <a href="#element-template"><code>xsl:template</code></a>
element <span class="verb">must</span> have either a
<code>match</code> attribute or a <code>name</code> attribute, or
both. An <a href="#element-template"><code>xsl:template</code></a>
element that has no <code>match</code> attribute <span class=
"verb">must</span> have no <code>mode</code> attribute and no
<code>priority</code> attribute. <span>An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>name</code> attribute <span class="verb">must</span> have
no <code>visibility</code> attribute.</span></p>
</dd>
<dt><a href="#err-XTSE0530"><span class="error">ERR
XTSE0530</span></a></dt>
<dd>
<p>The value of the <code>priority</code> attribute [ of the
<a href="#element-template"><code>xsl:template</code></a> element]
<span class="verb">must</span> conform to the rules for the
<code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>. Negative values are permitted.</p>
</dd>
<dt><a href="#err-XTSE0542"><span class="error">ERR
XTSE0542</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration specifying
<code>initial="no"</code> contains an <a href=
"#element-context-item"><code>xsl:context-item</code></a>
element.</p>
</dd>
<dt><a href="#err-XTSE0545"><span class="error">ERR
XTSE0545</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a named or unnamed <a title=
"mode" class="termref" href="#dt-mode">mode</a> contains two
conflicting values for the same attribute in different <a href=
"#element-mode"><code>xsl:mode</code></a> declarations having the
same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another definition of the same attribute with higher import
precedence. The attributes in question are the attributes other
than <code>name</code> on the <a href=
"#element-mode"><code>xsl:mode</code></a> element, and the
<code>as</code> attribute on the contained <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
if present.</p>
</dd>
<dt><a href="#err-XTSE0548"><span class="error">ERR
XTSE0548</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there is both (a) a
<a title="mode definition" class="termref" href=
"#dt-mode-definition">mode definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
that has the effective attribute values
<code>streamable="yes"</code> and <code>initial="yes"</code>, and
(b) a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
whose initializing expression is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> with respect to its
context item, as defined in <a href="#streamability"><i>19
Streamability</i></a>.</p>
</dd>
<dt><a href="#err-XTSE0550"><span class="error">ERR
XTSE0550</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the list of modes [in the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> ] is empty, if
the same token is included more than once in the list, if the list
contains an invalid token, or if the token <code>#all</code>
appears together with any other value.</p>
</dd>
<dt><a href="#err-XTSE0580"><span class="error">ERR
XTSE0580</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the values of the
<code>name</code> attribute of two <span>sibling <a href=
"#element-param"><code>xsl:param</code></a> elements represent the
same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a></span>.</p>
</dd>
<dt><a href="#err-XTSE0620"><span class="error">ERR
XTSE0620</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute and has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE0630"><span class="error">ERR
XTSE0630</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> contains more
than one <span>non-hidden</span> binding of a global variable with
the same name and same <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a>, unless it also
contains another binding with the same name and higher import
precedence.</p>
</dd>
<dt><a href="#err-XTSE0650"><span class="error">ERR
XTSE0650</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> contains an
<a href="#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute does not match the
<code>name</code> attribute of any <span><a title="named template"
class="termref" href="#dt-named-template">named template</a>
visible in the containing <a title="package" class="termref" href=
"#dt-package">package</a> (this includes any template defined in
this package, as well as templates accepted from used packages
whose visibility in this package is not <code>hidden</code>). For
more details of the process of binding the called template, see
<a href="#component-references"><i>3.6.2.6 Binding References to
Components</i></a>.</span></p>
</dd>
<dt><a href="#err-XTSE0660"><span class="error">ERR
XTSE0660</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <span><a title="package"
class="termref" href="#dt-package">package</a></span> contains more
than one <span>non-hidden</span> <a title="template" class=
"termref" href="#dt-template">template</a> with the same name and
the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains a <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and higher <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
</dd>
<dt><a href="#err-XTSE0670"><span class="error">ERR
XTSE0670</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two or more sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements have
<code>name</code> attributes that represent the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
</dd>
<dt><a href="#err-XTSE0680"><span class="error">ERR
XTSE0680</span></a></dt>
<dd>
<p>In the case of <a href=
"#element-call-template"><code>xsl:call-template</code></a>, it is
a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to pass a non-tunnel parameter
named <var>x</var> to a template that does not have a
<span>non-tunnel</span> <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a>
named <var>x</var>, unless <span>the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is processed with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0
behavior</a></span>.</p>
</dd>
<dt><a href="#err-XTSE0690"><span class="error">ERR
XTSE0690</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a template that is invoked
using <a href=
"#element-call-template"><code>xsl:call-template</code></a>
declares a <a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> specifying
<code>required="yes"</code> and not specifying
<code>tunnel="yes"</code>, if no value for this parameter is
supplied by the calling <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE0710"><span class="error">ERR
XTSE0710</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>use-attribute-sets</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, or <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element, or the <code>xsl:use-attribute-sets</code> attribute of a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, is not a
whitespace-separated sequence of <span><a title="EQName" class=
"termref" href="#dt-eqname">EQNames</a></span>, or if it contains a
QName that does not match the <code>name</code> attribute of any
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration in the stylesheet.</p>
</dd>
<dt><a href="#err-XTSE0720"><span class="error">ERR
XTSE0720</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
directly or indirectly references itself via the names contained in
the <code>use-attribute-sets</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE0740"><span class="error">ERR
XTSE0740</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> has a name that
is in no namespace.</p>
</dd>
<dt><a href="#err-XTSE0760"><span class="error">ERR
XTSE0760</span></a></dt>
<dd>
<p>Because arguments to a stylesheet function call <span class=
"verb">must</span> all be specified, the <a href=
"#element-param"><code>xsl:param</code></a> elements within an
<a href="#element-function"><code>xsl:function</code></a> element
<span class="verb">must not</span> specify a default value: this
means they <span class="verb">must</span> be empty, and
<span class="verb">must not</span> have a <code>select</code>
attribute.</p>
</dd>
<dt><a href="#err-XTSE0770"><span class="error">ERR
XTSE0770</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for a <span><a title="package"
class="termref" href="#dt-package">package</a></span> to contain
two or more <span>non-hidden</span> functions with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a>, the same <a title="arity"
class="termref" href="#dt-arity">arity</a>, and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another function with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> and arity,
and a higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE0805"><span class="error">ERR
XTSE0805</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an attribute on a literal
result element is in the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of
the attributes explicitly defined in this specification.</p>
</dd>
<dt><a href="#err-XTSE0808"><span class="error">ERR
XTSE0808</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a namespace prefix is used
within the <code>[xsl:]exclude-result-prefixes</code> attribute and
there is no namespace binding in scope for that prefix.</p>
</dd>
<dt><a href="#err-XTSE0809"><span class="error">ERR
XTSE0809</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value
<code>#default</code> is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and the parent
element of the <code>[xsl:]exclude-result-prefixes</code> attribute
has no default namespace.</p>
</dd>
<dt><a href="#err-XTSE0810"><span class="error">ERR
XTSE0810</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if <span>within a <a title=
"package" class="termref" href="#dt-package">package</a></span>
there is more than one such declaration [more than one <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration] with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and the same <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a> and different
values for the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, unless
there is also an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and a higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE0812"><span class="error">ERR
XTSE0812</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a value other than
<code>#default</code> is specified for either the
<code>stylesheet-prefix</code> or the <code>result-prefix</code>
attributes of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element when there is no in-scope binding for that namespace
prefix.</p>
</dd>
<dt><a href="#err-XTSE0840"><span class="error">ERR
XTSE0840</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element is
present unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0870"><span class="error">ERR
XTSE0870</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element is
present when the content of the element is non-empty</p>
</dd>
<dt><a href="#err-XTSE0880"><span class="error">ERR
XTSE0880</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is present unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0910"><span class="error">ERR
XTSE0910</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element is
present when the element has content other than one or more
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, or if the <code>select</code> attribute is absent
when the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0940"><span class="error">ERR
XTSE0940</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-comment"><code>xsl:comment</code></a> element is present
unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0975"><span class="error">ERR
XTSE0975</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>value</code>
attribute of <a href="#element-number"><code>xsl:number</code></a>
is present unless the <code>select</code>, <code>level</code>,
<code>count</code>, and <code>from</code> attributes are all
absent.</p>
</dd>
<dt><a href="#err-XTSE1015"><span class="error">ERR
XTSE1015</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-sort"><code>xsl:sort</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE1017"><span class="error">ERR
XTSE1017</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-sort"><code>xsl:sort</code></a> element other than the
first in a sequence of sibling <a href=
"#element-sort"><code>xsl:sort</code></a> elements has a
<code>stable</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1040"><span class="error">ERR
XTSE1040</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction with a <code>select</code> attribute has any content
other than <a href="#element-sort"><code>xsl:sort</code></a> and
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
</dd>
<dt><a href="#err-XTSE1060"><span class="error">ERR
XTSE1060</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-group"><code>current-group</code></a> function is
used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE1070"><span class="error">ERR
XTSE1070</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE1080"><span class="error">ERR
XTSE1080</span></a></dt>
<dd>
<p>These four attributes [the <code>group-by</code>,
<code>group-adjacent</code>, <code>group-starting-with</code>, and
<code>group-ending-with</code> attributes of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> ] are
mutually exclusive: it is a <a title="static error" class="termref"
href="#dt-static-error">static error</a> if none of these four
attributes is present or if more than one of them is present.</p>
</dd>
<dt><a href="#err-XTSE1090"><span class="error">ERR
XTSE1090</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to specify the
<code>collation</code> attribute <span>or the
<code>composite</code> attribute</span> if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code>
attribute is specified.</p>
</dd>
<dt><a href="#err-XTSE1130"><span class="error">ERR
XTSE1130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction contains neither an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
nor an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element.</p>
</dd>
<dt><a href="#err-XTSE1205"><span class="error">ERR
XTSE1205</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-key"><code>xsl:key</code></a> declaration has a
<code>use</code> attribute and has non-empty content, or if it has
empty content and no <code>use</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1210"><span class="error">ERR
XTSE1210</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-key"><code>xsl:key</code></a> declaration has a
<code>collation</code> attribute whose value (after resolving
against the base URI) is not a URI recognized by the implementation
as referring to a collation.</p>
</dd>
<dt><a href="#err-XTSE1220"><span class="error">ERR
XTSE1220</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> with the same key name and
different effective collations. Two collations are the same if
their URIs are equal under the rules for comparing
<code>xs:anyURI</code> values, or if the implementation can
determine that they are different URIs referring to the same
collation.</p>
</dd>
<dt><a href="#err-XTSE1222"><span class="error">ERR
XTSE1222</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> with the same key name and
different effective values for the <code>composite</code>
attribute.</p>
</dd>
<dt><a href="#err-XTSE1290"><span class="error">ERR
XTSE1290</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a named or unnamed <a title=
"decimal format" class="termref" href="#dt-decimal-format">decimal
format</a> contains two conflicting values for the same attribute
in different <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations having the same <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>,
unless there is another definition of the same attribute with
higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE1295"><span class="error">ERR
XTSE1295</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the character specified in
the <code>zero-digit</code> attribute is not a digit or is a digit
that does not have the numeric value zero.</p>
</dd>
<dt><a href="#err-XTSE1300"><span class="error">ERR
XTSE1300</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if, for any named or unnamed
decimal format, the variables representing characters used in a
<a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> do not each have distinct
values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-sign</var>, <var>percent-sign</var>,
<var>per-mille-sign</var>, <var>digit-zero-sign</var>,
<var>digit-sign</var>, and <var>pattern-separator-sign</var>.</p>
</dd>
<dt><a href="#err-XTSE1430"><span class="error">ERR
XTSE1430</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there is no namespace bound
to the prefix on the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute or, when
<code>#default</code> is specified, if there is no default
namespace.</p>
</dd>
<dt><a href="#err-XTSE1505"><span class="error">ERR
XTSE1505</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if both the
<code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are present on the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, or on a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a>.</p>
</dd>
<dt><a href="#err-XTSE1520"><span class="error">ERR
XTSE1520</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:type</code> attribute of a literal
result element, is not a valid <code>QName</code>, or if it uses a
prefix that is not defined in an in-scope namespace declaration, or
if the QName is not the name of a type definition included in the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet.</p>
</dd>
<dt><a href="#err-XTSE1530"><span class="error">ERR
XTSE1530</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
refers to a complex type definition</p>
</dd>
<dt><a href="#err-XTSE1560"><span class="error">ERR
XTSE1560</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two <a href=
"#element-output"><code>xsl:output</code></a> declarations within
an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specify explicit
values for the same attribute (other than
<code>cdata-section-elements</code> and
<code>use-character-maps</code>), with the values of the attributes
being not equal, unless there is another <a href=
"#element-output"><code>xsl:output</code></a> declaration within
the same <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> that has higher
import precedence and that specifies an explicit value for the same
attribute.</p>
</dd>
<dt><a href="#err-XTSE1570"><span class="error">ERR
XTSE1570</span></a></dt>
<dd>
<p>The value [of the <code>method</code> attribute on <a href=
"#element-output"><code>xsl:output</code></a> ] <span class=
"verb">must</span> (if present) be a valid <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a>. If it is a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> with no a prefix, then it identifies a method specified
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> and <span class="verb">must</span> be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, or
<code>text</code>.</p>
</dd>
<dt><a href="#err-XTSE1580"><span class="error">ERR
XTSE1580</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> contains two
or more character maps with the same name and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains another character map with the same name and higher import
precedence.</p>
</dd>
<dt><a href="#err-XTSE1590"><span class="error">ERR
XTSE1590</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a name in the
<code>use-character-maps</code> attribute of the <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements does not match the <code>name</code> attribute of any
<a href="#element-character-map"><code>xsl:character-map</code></a>
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
</dd>
<dt><a href="#err-XTSE1600"><span class="error">ERR
XTSE1600</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a character map references
itself, directly or indirectly, via a name in the
<code>use-character-maps</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1650"><span class="error">ERR
XTSE1650</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> includes an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
</dd>
<dt><a href="#err-XTSE1660"><span class="error">ERR
XTSE1660</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> includes an <code>[xsl:]type</code>
attribute, or an <code>[xsl:]validation</code> or
<code>[xsl:]default-validation</code> attribute with a value other
than <code>strip</code><span>, <code>preserve</code>, or
<code>lax</code></span>.</p>
</dd>
<dt><a href="#err-XTSE2200"><span class="error">ERR
XTSE2200</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of a
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element is not equal to the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
another <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child of
the same <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE3010"><span class="error">ERR
XTSE3010</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the exposed visibility of a
component is inconsistent with its potential visibility, as defined
in the above table, unless the token that matches the component is
a wildcard, in which case it is treated as not matching that
component.</p>
</dd>
<dt><a href="#err-XTSE3020"><span class="error">ERR
XTSE3020</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-expose"><code>xsl:expose</code></a> element matches no
components in the containing package, unless the tokens in the
<code>names</code> attribute are all wildcards.</p>
</dd>
<dt><a href="#err-XTSE3030"><span class="error">ERR
XTSE3030</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-accept"><code>xsl:accept</code></a> element matches no
components in the used package, unless the tokens in its
<code>names</code> attribute are all wildcards.</p>
</dd>
<dt><a href="#err-XTSE3040"><span class="error">ERR
XTSE3040</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the visibility assigned to a
component by an <a href=
"#element-accept"><code>xsl:accept</code></a> element is
incompatible with the visibility of the corresponding component in
the used package, as defined by the above table, unless the token
that matches the component name is a wildcard, in which case the
<a href="#element-accept"><code>xsl:accept</code></a> element is
treated as not matching that component.</p>
</dd>
<dt><a href="#err-XTSE3050"><span class="error">ERR
XTSE3050</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements in
a <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> cause two or more
<a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> components to be accepted with a
visibility other than <code>hidden</code>.</p>
</dd>
<dt><a href="#err-XTDE3052"><span class="error">ERR
XTDE3052</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an invocation of an absent
component (that is, an abstract component accepted into a using
package with <code>visibility="absent"</code>) is evaluated.</p>
</dd>
<dt><a href="#err-XTSE3055"><span class="error">ERR
XTSE3055</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a component declaration
appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> is <a title=
"homonymous" class="termref" href="#dt-homonymous">homonymous</a>
with any other declaration in the using package, regardless of
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, including any other
overriding declaration in the package manifest of the using
package.</p>
</dd>
<dt><a href="#err-XTSE3058"><span class="error">ERR
XTSE3058</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a component declaration
appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> does not match
(is not <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> with) some component in the used
package.</p>
</dd>
<dt><a href="#err-XTSE3060"><span class="error">ERR
XTSE3060</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the component referenced by
an <a href="#element-override"><code>xsl:override</code></a>
declaration has <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> other than <code>public</code> or
<code>abstract</code></p>
</dd>
<dt><a href="#err-XTSE3070"><span class="error">ERR
XTSE3070</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the signature of an
overriding component is not <a title="compatible" class="termref"
href="#dt-compatible">compatible</a> with the signature of the
component that it is overriding.</p>
</dd>
<dt><a href="#err-XTSE3080"><span class="error">ERR
XTSE3080</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a top-level package intended
for execution (as distinct from a library package) contains
symbolic references referring to components whose visibility is
<code>abstract</code>.</p>
</dd>
<dt><a href="#err-XTSE3120"><span class="error">ERR
XTSE3120</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element appears other than in a <a title="tail position" class=
"termref" href="#dt-tail-position">tail position</a> within the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE3125"><span class="error">ERR
XTSE3125</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of <a href="#element-break"><code>xsl:break</code></a> or
<a href="#element-on-completion"><code>xsl:on-completion</code></a>
is present and the instruction has children.</p>
</dd>
<dt><a href="#err-XTSE3130"><span class="error">ERR
XTSE3130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>name</code>
attribute of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child of an
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element does not match the <code>name</code> attribute of an
<a href="#element-param"><code>xsl:param</code></a> child of the
<span>innermost</span> containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction.</p>
</dd>
<dt><a href="#err-XTSE3140"><span class="error">ERR
XTSE3140</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href="#element-try"><code>xsl:try</code></a>
element is present and the element has children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
</dd>
<dt><a href="#err-XTSE3150"><span class="error">ERR
XTSE3150</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-catch"><code>xsl:catch</code></a> element is present
unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE3185"><span class="error">ERR
XTSE3185</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of <a href=
"#element-sequence"><code>xsl:sequence</code></a> is present and
the instruction has children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a>.</p>
</dd>
<dt><a href="#err-XTSE3190"><span class="error">ERR
XTSE3190</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two sibling <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
have the same name, whether explicit or implicit.</p>
</dd>
<dt><a href="#err-XTSE3200"><span class="error">ERR
XTSE3200</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE3220"><span class="error">ERR
XTSE3220</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a variable bound in the
<code>bind-group</code> or <code>bind-grouping-key</code> attribute
of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is referenced within an expression in the
<code>lang</code>, <code>order</code>, <code>collation</code>,
<code>stable</code>, <code>case-order</code>, or
<code>data-type</code> attributes of an <a href=
"#element-sort"><code>xsl:sort</code></a> child of that <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE3230"><span class="error">ERR
XTSE3230</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the
<code>bind-grouping-key</code> attribute is present on an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction unless either the <code>group-by</code> or
<code>group-adjacent</code> attribute is present.</p>
</dd>
<dt><a href="#err-XTSE3270"><span class="error">ERR
XTSE3270</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the set of variable names
declared using the <code>bind-group</code> and
<code>bind-key</code> attributes of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction and the
<code>bind-source</code> attributes of its <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
contains any duplicates.</p>
</dd>
<dt><a href="#err-XTSE3280"><span class="error">ERR
XTSE3280</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> element is
present unless the element has has no children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
</dd>
<dt><a href="#err-XTSE3340"><span class="error">ERR
XTSE3340</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-template"><code>xsl:template</code></a> declaration has
the name <code>xsl:initial-template</code> and contains an <a href=
"#element-param"><code>xsl:param</code></a> that specifies
<code>required="yes"</code>.</p>
</dd>
<dt><a href="#err-XTSE3350"><span class="error">ERR
XTSE3350</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for a <a title="package" class=
"termref" href="#dt-package">package</a> to contain two or more
non-hidden accumulators with the same <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> and
the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another accumulator with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>, and a
higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE3360"><span class="error">ERR
XTSE3360</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for a <a title="package" class=
"termref" href="#dt-package">package</a> to contain a non-hidden
accumulator if either the pre-descent or post-descent functions
have the same name as a non-hidden <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> in the same package.</p>
</dd>
<dt><a href="#err-XTSE3370"><span class="error">ERR
XTSE3370</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the the
<code>visibility</code> attribute of a stylesheet parameter that
specifies <code>required="yes"</code> and does not specify
<code>static="yes"</code> is present with a value other than
<code>public</code>, <code>final</code>, or <code>abstract</code>,
or if an <a href="#element-expose"><code>xsl:expose</code></a> or
<a href="#element-accept"><code>xsl:accept</code></a> declaration
attempts to modify the visibility of such a component to a value
other than <code>public</code>, <code>final</code>, or
<code>abstract</code>.</p>
</dd>
<dt><a href="#err-XTSE3430"><span class="error">ERR
XTSE3430</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the stylesheet contains a
construct that is declared to be streamable but which is not
<a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>, unless the
user has indicated that the processor is to handle this situation
by processing the stylesheet without streaming or by making use of
processor extensions to the streamability rules where
available.</p>
</dd>
</dl>
<p><b>Type errors</b></p>
<dl>
<dt><a href="#err-XTTE0505"><span class="error">ERR
XTTE0505</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> cannot be
converted to the required type.</p>
</dd>
<dt><a href="#err-XTTE0510"><span class="error">ERR
XTTE0510</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction with no <code>select</code> attribute is evaluated when
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
</dd>
<dt><a href="#err-XTTE0570"><span class="error">ERR
XTTE0570</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a> of a
variable cannot be converted to the required type.</p>
</dd>
<dt><a href="#err-XTTE0590"><span class="error">ERR
XTTE0590</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the conversion of the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of a parameter to its required type fails.</p>
</dd>
<dt><a href="#err-XTTE0600"><span class="error">ERR
XTTE0600</span></a></dt>
<dd>
<p>If a default value is given explicitly, that is, if there is
either a <code>select</code> attribute or a non-empty <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, then it is a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> if the default value cannot be converted to the required
type, using the <a title="function conversion rules" class=
"termref" href="#dt-function-conversion-rules">function conversion
rules</a>.</p>
</dd>
<dt><a href="#err-XTTE0780"><span class="error">ERR
XTTE0780</span></a></dt>
<dd>
<p>If the <code>as</code> attribute [of <a href=
"#element-function"><code>xsl:function</code></a> ] is specified,
then the result evaluated by the <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>) is converted to the required type,
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>.
It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if this conversion fails.</p>
</dd>
<dt><a href="#err-XTTE0790"><span class="error">ERR
XTTE0790</span></a></dt>
<dd>
<p>If the value of a parameter to a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> cannot be converted to the required type, a <a title=
"type error" class="termref" href="#dt-type-error">type error</a>
is signaled.</p>
</dd>
<dt><a href="#err-XTTE0950"><span class="error">ERR
XTTE0950</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> to use the <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy
a node that has namespace-sensitive content if the
<code>copy-namespaces</code> attribute has the value
<code>no</code> and its explicit or implicit
<code>validation</code> attribute has the value
<code>preserve</code>. It is also a type error if either of these
instructions (with <code>validation="preserve"</code>) is used to
copy an attribute having namespace-sensitive content, unless the
parent element is also copied. A node has namespace-sensitive
content if its typed value contains an item of type
<code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived
therefrom. The reason this is an error is because the validity of
the content depends on the namespace context being preserved.</p>
</dd>
<dt><a href="#err-XTTE0990"><span class="error">ERR
XTTE0990</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
evaluated, with no <code>value</code> or <code>select</code>
attribute, when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
</dd>
<dt><a href="#err-XTTE1000"><span class="error">ERR
XTTE1000</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>select</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
anything other than a single node.</p>
</dd>
<dt><a href="#err-XTTE1020"><span class="error">ERR
XTTE1020</span></a></dt>
<dd>
<p>If any <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key value</a>, after <a title="atomize"
class="termref" href="#dt-atomization">atomization</a> and any type
conversion <span class="verb">required</span> by the
<code>data-type</code> attribute, is a sequence containing more
than one item, then the effect depends on whether the <a href=
"#element-sort"><code>xsl:sort</code></a> element <span>is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0
behavior,</span> the effective sort key value is the first item in
the sequence. In other cases, this is a <a title="type error"
class="termref" href="#dt-type-error">type error</a>.</p>
</dd>
<dt><a href="#err-XTTE1100"><span class="error">ERR
XTTE1100</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>group-adjacent</code> expression is an empty sequence or a
sequence containing more than one item, <span>unless
<code>composite="yes"</code> is specified.</span></p>
</dd>
<dt><a href="#err-XTTE1510"><span class="error">ERR
XTTE1510</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and schema validity assessment concludes that
the validity of the element or attribute is invalid or unknown, a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs. As with other type errors, the error <span class=
"verb">may</span> be signaled statically if it can be detected
statically.</p>
</dd>
<dt><a href="#err-XTTE1512"><span class="error">ERR
XTTE1512</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and there is no matching top-level declaration
in the schema, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
</dd>
<dt><a href="#err-XTTE1515"><span class="error">ERR
XTTE1515</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value <code>lax</code>,
and schema validity assessment concludes that the element or
attribute is invalid, a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
</dd>
<dt><a href="#err-XTTE1535"><span class="error">ERR
XTTE1535</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction refers
to a complex type definition and one or more of the items being
copied is an attribute node.</p>
</dd>
<dt><a href="#err-XTTE1540"><span class="error">ERR
XTTE1540</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <code>[xsl:]type</code>
attribute is defined for a constructed element or attribute, and
the outcome of schema validity assessment against that type is that
the <code>validity</code> property of that element or attribute
information item is other than <code>valid</code>.</p>
</dd>
<dt><a href="#err-XTTE1545"><span class="error">ERR
XTTE1545</span></a></dt>
<dd>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs if a <code>type</code> or
<code>validation</code> attribute is defined (explicitly or
implicitly) for an instruction that constructs a new attribute
node, if the effect of this is to cause the attribute value to be
validated against a type that is derived from, or constructed by
list or union from, the primitive types <code>xs:QName</code> or
<code>xs:NOTATION</code>.</p>
</dd>
<dt><a href="#err-XTTE1550"><span class="error">ERR
XTTE1550</span></a></dt>
<dd>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs [when a document node is
validated] unless the children of the document node comprise
exactly one element node, no text nodes, and zero or more comment
and processing instruction nodes, in any order.</p>
</dd>
<dt><a href="#err-XTTE1555"><span class="error">ERR
XTTE1555</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if, when validating a document
node, document-level constraints (such as ID/IDREF constraints) are
not satisfied.</p>
</dd>
<dt><a href="#err-XTTE2230"><span class="error">ERR
XTTE2230</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if some item selected by a
particular merge key in one input sequence is not comparable using
the XPath <code>le</code> operator with some item selected by the
corresponding sort key in another input sequence.</p>
</dd>
<dt><a href="#err-XTTE3090"><span class="error">ERR
XTTE3090</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a href=
"#element-context-item"><code>xsl:context-item</code></a> child of
<a href="#element-template"><code>xsl:template</code></a> specifies
that a context item is required and none is supplied by the caller,
that is, if the context item is absent at the point where <a href=
"#element-call-template"><code>xsl:call-template</code></a> is
evaluated.</p>
</dd>
<dt><a href="#err-XTTE3100"><span class="error">ERR
XTTE3100</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when the <code>typed</code> attribute
of that mode specifies the value <code>yes</code>,
<code>strict</code>, or <code>lax</code>.</p>
</dd>
<dt><a href="#err-XTTE3110"><span class="error">ERR
XTTE3110</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is anything other than <code>xs:untyped</code>
or <code>xs:untypedAtomic</code> when the <code>typed</code>
attribute of that mode specifies the value <code>no</code>.</p>
</dd>
<dt><a href="#err-XTTE3170"><span class="error">ERR
XTTE3170</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>namespace-context</code> attribute of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
anything other than a single node.</p>
</dd>
<dt><a href="#err-XTTE3180"><span class="error">ERR
XTTE3180</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>select</code> expression [of the <a href=
"#element-copy"><code>xsl:copy</code></a> element] is a sequence of
more than one item.</p>
</dd>
<dt><a href="#err-XTTE3210"><span class="error">ERR
XTTE3210</span></a></dt>
<dd>
<p>If the result of evaluating the <code>context-item</code>
expression [of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction] is a
sequence containing more than one item, then a <a title=
"type error" class="termref" href="#dt-type-error">type error</a>
is signaled.</p>
</dd>
<dt><a href="#err-XTTE3300"><span class="error">ERR
XTTE3300</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>xsl:on-empty</code> attribute [on a literal result element]
does not satisfy the required type <code>element()?</code>. That
is, the expression must deliver either a single element node, or an
empty sequence.</p>
</dd>
<dt><a href="#err-XTTE3310"><span class="error">ERR
XTTE3310</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>on-empty</code> attribute [on the <a href=
"#element-element"><code>xsl:element</code></a> instruction] does
not satisfy the required type <code>element()?</code>. That is, the
expression must deliver either a single element node, or an empty
sequence.</p>
</dd>
<dt><a href="#err-XTTE3320"><span class="error">ERR
XTTE3320</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>on-empty</code> attribute [on the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction]
does not satisfy the required type <code>attribute()?</code>. That
is, the expression must deliver either a single attribute node, or
an empty sequence.</p>
</dd>
<dt><a href="#err-XTTE3330"><span class="error">ERR
XTTE3330</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>on-empty</code> attribute [on the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction] does not
satisfy the required type <code>node()?</code>. That is, the
expression must deliver either a single node, or an empty
sequence.</p>
</dd>
<dt><a href="#err-XTTE3375"><span class="error">ERR
XTTE3375</span></a></dt>
<dd>
<p>A type error occurs if the result of evaluating the sequence
constructor [within an <a href=
"#element-map"><code>xsl:map</code></a> instruction] is not an
instance of the required type <code>map(*)*</code>.</p>
</dd>
</dl>
<p><b>Dynamic errors</b></p>
<dl>
<dt><a href="#err-XTDE0030"><span class="error">ERR
XTDE0030</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of an attribute written
using curly brackets, in a position where an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted, is a value that is not one of the permitted values for
that attribute. If the processor is able to detect the error
statically (for example, when any XPath expressions within the
curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.</p>
</dd>
<dt><a href="#err-XTDE0040"><span class="error">ERR
XTDE0040</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a template name that does
not match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of a named template defined
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, <span>whose visibility is
<code>public</code> or <code>final</code></span>.</p>
</dd>
<dt><a href="#err-XTDE0041"><span class="error">ERR
XTDE0041</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a function name and arity
that does not match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> and arity of a named
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, whose visibility is
<code>public</code> or <code>final</code>.</p>
</dd>
<dt><a href="#err-XTDE0044"><span class="error">ERR
XTDE0044</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> and if no input
sequence is supplied (either explicitly, or defaulted to the
<a title="initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a>).</p>
</dd>
<dt><a href="#err-XTDE0045"><span class="error">ERR
XTDE0045</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> (other than the
unnamed mode) that does not match <span>either the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> in the <code>name</code> attribute of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span>
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in the <code>mode</code>
attribute of any template defined in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
</dd>
<dt><a href="#err-XTDE0050"><span class="error">ERR
XTDE0050</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if a stylesheet declares a
visible <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied when the stylesheet is primed. A stylesheet parameter is
visible if it is not masked by another global variable or parameter
with the same name and higher <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>.
<span>If the parameter is a <a title="static parameter" class=
"termref" href="#dt-static-parameter">static parameter</a> then the
value <span class="verb">must</span> be supplied prior to the
static analysis phase.</span></p>
</dd>
<dt><a href="#err-XTDE0060"><span class="error">ERR
XTDE0060</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"initial template" class="termref" href=
"#dt-initial-template">initial template</a> defines a <a title=
"template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> that specifies
<code>required="yes"</code>.</p>
</dd>
<dt><a href="#err-XTDE0160"><span class="error">ERR
XTDE0160</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an element has an
<a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of <var>V</var> (with
<var>V</var> &lt; 3.0) when the implementation does not support
backwards compatible behavior for XSLT version <var>V</var>.</p>
</dd>
<dt><a href="#err-XTDE0290"><span class="error">ERR
XTDE0290</span></a></dt>
<dd>
<p>Where the result of evaluating an XPath expression (or an
attribute value template) is required to be a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a>, or if it is permitted to be a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a> and the
actual value takes the form of a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a>, then unless
otherwise specified it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the value
has a prefix and the <a title="defining element" class="termref"
href="#dt-defining-element">defining element</a> has no namespace
node whose name matches that prefix. This error <span class=
"verb">may</span> be signaled as a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the value of
the expression can be determined statically.</p>
</dd>
<dt><a href="#err-XTDE0410"><span class="error">ERR
XTDE0410</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence used
to construct the content of an element node contains a namespace
node or attribute node that is preceded in the sequence by a node
that is neither a namespace node nor an attribute node.</p>
</dd>
<dt><a href="#err-XTDE0420"><span class="error">ERR
XTDE0420</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence used
to construct the content of a document node contains a namespace
node or attribute node.</p>
</dd>
<dt><a href="#err-XTDE0430"><span class="error">ERR
XTDE0430</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains two or more namespace nodes having the same name but
different <a title="string value" class="termref" href=
"#dt-string-value">string values</a> (that is, namespace nodes that
map the same prefix to different namespace URIs).</p>
</dd>
<dt><a href="#err-XTDE0440"><span class="error">ERR
XTDE0440</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains a namespace node with no name and the element node being
constructed has a null namespace URI (that is, it is an error to
define a default namespace when the element is in no
namespace).</p>
</dd>
<dt><a href="#err-XTDE0450"><span class="error">ERR
XTDE0450</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains a function item.</p>
</dd>
<dt><a href="#err-XTDE0540"><span class="error">ERR
XTDE0540</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the conflict resolution
algorithm for template rules leaves more than one matching template
rule <span>when the declaration of the relevant <a title="mode"
class="termref" href="#dt-mode">mode</a> has an
<code>on-multiple-match</code> attribute with the value
<code>fail</code></span>.</p>
</dd>
<dt><a href="#err-XTDE0555"><span class="error">ERR
XTDE0555</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
used to process a node using a mode whose declaration specifies
<code>on-no-match="fail"</code> when there is no <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> whose match pattern matches that
node.</p>
</dd>
<dt><a href="#err-XTDE0560"><span class="error">ERR
XTDE0560</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a> is
evaluated when the <a title="current template rule" class="termref"
href="#dt-current-template-rule">current template rule</a> is
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span>.</p>
</dd>
<dt><a href="#err-XTDE0610"><span class="error">ERR
XTDE0610</span></a></dt>
<dd>
<p>If an optional parameter has no <code>select</code> attribute
and has an empty <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, and if
there is an <code>as</code> attribute, then the default value of
the parameter is an empty sequence. If the empty sequence is not a
valid instance of the required type defined in the <code>as</code>
attribute, then the parameter is treated as a required parameter,
which means that it is a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> if the caller supplies
no value for the parameter.</p>
</dd>
<dt><a href="#err-XTDE0640"><span class="error">ERR
XTDE0640</span></a></dt>
<dd>
<p>In general, a <a title="circularity" class="termref" href=
"#dt-circularity">circularity</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a>.</p>
</dd>
<dt><a href="#err-XTDE0700"><span class="error">ERR
XTDE0700</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if a template that is invoked
using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
declares a <a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied by the calling instruction. The same error is reported in
the case of a <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> whether invoked using
one of these three instructions or by <a href=
"#element-call-template"><code>xsl:call-template</code></a>, as
explained in <a href="#tunnel-params"><i>10.1.2 Tunnel
Parameters</i></a>.</p>
</dd>
<dt><a href="#err-XTDE0820"><span class="error">ERR
XTDE0820</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-element"><code>xsl:element</code></a> instruction] is not
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTDE0830"><span class="error">ERR
XTDE0830</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-element"><code>xsl:element</code></a> instruction with no
<code>namespace</code> attribute, it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-element"><code>xsl:element</code></a> instruction.</p>
</dd>
<dt><a href="#err-XTDE0835"><span class="error">ERR
XTDE0835</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute [of the <a href=
"#element-element"><code>xsl:element</code></a> instruction] is not
in the lexical space of the <code>xs:anyURI</code> datatype or if
it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0850"><span class="error">ERR
XTDE0850</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction] is
not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTDE0855"><span class="error">ERR
XTDE0855</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is the string <code>xmlns</code>.</p>
</dd>
<dt><a href="#err-XTDE0860"><span class="error">ERR
XTDE0860</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTDE0865"><span class="error">ERR
XTDE0865</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute [of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction] is
not in the lexical space of the <code>xs:anyURI</code> datatype or
if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0890"><span class="error">ERR
XTDE0890</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
instruction] is not both an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
and a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p>
</dd>
<dt><a href="#err-XTDE0905"><span class="error">ERR
XTDE0905</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the string value of the
new namespace node is not valid in the lexical space of the
datatype <code>xs:anyURI</code>, or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0920"><span class="error">ERR
XTDE0920</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction] is
neither a zero-length string nor an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
or if it is <code>xmlns</code>.</p>
</dd>
<dt><a href="#err-XTDE0925"><span class="error">ERR
XTDE0925</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
generates a namespace node whose name is <code>xml</code> and whose
string value is not
<code>http://www.w3.org/XML/1998/namespace</code>, or a namespace
node whose string value is
<code>http://www.w3.org/XML/1998/namespace</code> and whose name is
not <code>xml</code>.</p>
</dd>
<dt><a href="#err-XTDE0930"><span class="error">ERR
XTDE0930</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if evaluating the
<code>select</code> attribute or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of an <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
results in a zero-length string.</p>
</dd>
<dt><a href="#err-XTDE0980"><span class="error">ERR
XTDE0980</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if any undiscarded item in
the atomized sequence supplied as the value of the
<code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> cannot be converted
to an integer, or if the resulting integer is less than 0
(zero).</p>
</dd>
<dt><a href="#err-XTDE1001"><span class="error">ERR
XTDE1001</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>start-at</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not in
the lexical space of <code>xs:integer</code>. The error may be
signaled statically if it can be detected statically.</p>
</dd>
<dt><a href="#err-XTDE1030"><span class="error">ERR
XTDE1030</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if, for any <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>, the set of
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> evaluated for all the
items in the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, after any type
conversion requested, contains a pair of ordinary values for which
the result of the XPath <code>lt</code> operator is an error.</p>
</dd>
<dt><a href="#err-XTDE1035"><span class="error">ERR
XTDE1035</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <code>collation</code>
attribute of <a href="#element-sort"><code>xsl:sort</code></a>
(after resolving against the base URI) is not a URI that is
recognized by the implementation as referring to a collation.</p>
</dd>
<dt><a href="#err-XTDE1061"><span class="error">ERR
XTDE1061</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-group"><code>current-group</code></a> function is
used when the current group is <a title="absent" class="termref"
href="#dt-absent">absent</a> <span>, or when it is invoked in the
course of evaluating a pattern</span>. The error <span class=
"verb">may</span> be reported statically if it can be detected
statically.</p>
</dd>
<dt><a href="#err-XTDE1071"><span class="error">ERR
XTDE1071</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used when the current grouping key is <a title="absent"
class="termref" href="#dt-absent">absent</a>, <span>or when it is
invoked in the course of evaluating a pattern.</span>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt><a href="#err-XTDE1110"><span class="error">ERR
XTDE1110</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the collation URI
specified to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
(after resolving against the base URI) is a collation that is not
recognized by the implementation. (For notes, <span class=
"error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
</dd>
<dt><a href="#err-XTDE1140"><span class="error">ERR
XTDE1140</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>regex</code>
attribute [of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction] does not conform to the <span class=
"verb">required</span> syntax for regular expressions, as specified
in <a href="#xpath-functions-30">[Functions and Operators]</a>. If
the regular expression is known statically (for example, if the
attribute does not contain any <a title="expression" class=
"termref" href="#dt-expression">expressions</a> enclosed in curly
brackets) then the processor <span class="verb">may</span> signal
the error as a <a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1145"><span class="error">ERR
XTDE1145</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>flags</code>
attribute [of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction] has a value other than the values defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. If the value
of the attribute is known statically (for example, if the attribute
does not contain any <a title="expression" class="termref" href=
"#dt-expression">expressions</a> enclosed in curly brackets) then
the processor <span class="verb">may</span> signal the error as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1160"><span class="error">ERR
XTDE1160</span></a></dt>
<dd>
<p>When a URI reference [supplied to the <a href=
"#func-document"><code>document</code></a> function] contains a
fragment identifier, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the media
type is not one that is recognized by the processor, or if the
fragment identifier does not conform to the rules for fragment
identifiers for that media type, or if the fragment identifier
selects something other than a sequence of nodes (for example, if
it selects a range of characters within a text node).</p>
</dd>
<dt><a href="#err-XTDE1162"><span class="error">ERR
XTDE1162</span></a></dt>
<dd>
<p>When a URI reference [supplied to the <a href=
"#func-document"><code>document</code></a> function] is a relative
reference, it is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if no base URI is available
to resolve the relative reference. This can arise for example when
the URI is contained in a node that has no base URI (for example a
parentless text node), or when the second argument to the function
is a node that has no base URI, or when the base URI from the
static context is undefined.</p>
</dd>
<dt><a href="#err-XTDE1260"><span class="error">ERR
XTDE1260</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value [of the first
argument to the <a href="#func-key"><code>key</code></a> function]
is not a valid QName, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-key"><code>xsl:key</code></a> declaration in the
<span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1270"><span class="error">ERR
XTDE1270</span></a></dt>
<dd>
<p>It is a <span><a title="" class="termref" href="#">dynamic
error</a></span> to call the <a href=
"#func-key"><code>key</code></a> function with two arguments if
there is no <a title="context node" class="termref" href=
"#dt-context-node">context node</a>, or if the root of the tree
containing the context node is not a document node; or to call the
function with three arguments if the root of the tree containing
the node supplied in the third argument is not a document node.</p>
</dd>
<dt><a href="#err-XTDE1360"><span class="error">ERR
XTDE1360</span></a></dt>
<dd>
<p>If the <a href="#func-current"><code>current</code></a> function
is evaluated within an expression that is evaluated when the
context item is absent, a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> occurs.</p>
</dd>
<dt><a href="#err-XTDE1370"><span class="error">ERR
XTDE1370</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
<dt><a href="#err-XTDE1380"><span class="error">ERR
XTDE1380</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
<dt><a href="#err-XTDE1390"><span class="error">ERR
XTDE1390</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value supplied as the
<code>$property-name</code> argument [to the <a href=
"#func-system-property"><code>system-property</code></a> function]
is not a valid QName, or if there is no namespace declaration in
scope for the prefix of the QName. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1400"><span class="error">ERR
XTDE1400</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href=
"#func-function-available"><code>function-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1420"><span class="error">ERR
XTDE1420</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the arguments supplied to
a call on an extension function do not satisfy the rules defined
for that particular extension function, or if the extension
function reports an error, or if the result of the extension
function cannot be converted to an XPath value.</p>
</dd>
<dt><a href="#err-XTDE1425"><span class="error">ERR
XTDE1425</span></a></dt>
<dd>
<p><span>When the containing element is processed with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>,</span> it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate an extension
function call if no implementation of the extension function is
available.</p>
</dd>
<dt><a href="#err-XTDE1428"><span class="error">ERR
XTDE1428</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href="#func-type-available"><code>type-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1440"><span class="error">ERR
XTDE1440</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href=
"#func-element-available"><code>element-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1450"><span class="error">ERR
XTDE1450</span></a></dt>
<dd>
<p>When a <a title="processor" class="termref" href=
"#dt-processor">processor</a> performs fallback for an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> that is not
recognized, if the instruction element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then
the content of each of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> children
<span class="verb">must</span> be evaluated; it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if it has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children.</p>
</dd>
<dt><a href="#err-XTDE1460"><span class="error">ERR
XTDE1460</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute [of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element] is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if it does not match the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
If the processor is able to detect the error statically (for
example, when the <code>format</code> attribute contains no curly
brackets), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1480"><span class="error">ERR
XTDE1480</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction in <a title="temporary output state" class="termref"
href="#dt-temporary-output-state">temporary output state</a>.</p>
</dd>
<dt><a href="#err-XTDE1490"><span class="error">ERR
XTDE1490</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> for a transformation to
generate two or more <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result trees</a> with the same
URI.</p>
</dd>
<dt><a href="#err-XTDE1500"><span class="error">ERR
XTDE1500</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> for a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> to write to an
external resource and read from the same resource during a single
transformation, <span>if the same absolute URI is used to access
the resource in both cases</span>.</p>
</dd>
<dt><a href="#err-XTDE1665"><span class="error">ERR
XTDE1665</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
input to the processor includes a node with a <a title=
"type annotation" class="termref" href="#dt-annotation">type
annotation</a> other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>, or an atomic value of a type other
than those which a basic XSLT processor supports.</p>
</dd>
<dt><a href="#err-XTDE2210"><span class="error">ERR
XTDE2210</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if there are two <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements that
occupy corresponding positions among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of two
different <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
and that have differing <a title="effective value" class="termref"
href="#dt-effective-value">effective values</a> for any of the
attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code>. Values are considered to differ if the
attribute is present on one element and not on the other, or if it
is present on both elements with <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> that are
not equal to each other. In the case of the <code>collation</code>
attribute, the values are compared as absolute URIs after resolving
against the base URI.The error <span class="verb">may</span> be
reported statically if it is detected statically.</p>
</dd>
<dt><a href="#err-XTDE2220"><span class="error">ERR
XTDE2220</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if any input sequence to an
<a href="#element-merge"><code>xsl:merge</code></a> instruction
contains two items that are not correctly sorted according to the
merge key values defined on the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
corresponding <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
when compared using the collation rules defined by the attributes
of the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
unless the attribute <code>sort-before-merge</code> is present with
the value <code>yes</code>.</p>
</dd>
<dt><a href="#err-XTDE3160"><span class="error">ERR
XTDE3160</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"target expression" class="termref" href=
"#dt-target-expression">target expression</a> [of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction] is
not a valid XPath 3.0 expression (that is, if a static error occurs
when analyzing the string according to the rules of the XPath 3.0
specification).</p>
</dd>
<dt><a href="#err-XTDE3175"><span class="error">ERR
XTDE3175</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated when use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> has been
statically or dynamically disabled.</p>
</dd>
<dt><a href="#err-XTDE3240"><span class="error">ERR
XTDE3240</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$input</code> does not conform to the JSON grammar, as
selected using the explicit or implicit <code>spec</code>
option.</p>
</dd>
<dt><a href="#err-XTDE3245"><span class="error">ERR
XTDE3245</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of the
<code>validate</code> option is <code>true</code> and the processor
is not schema-aware.</p>
</dd>
<dt><a href="#err-XTDE3250"><span class="error">ERR
XTDE3250</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$input</code> contains an escaped representation of a
character (or codepoint) that is not a valid character in the
version of XML supported by the implementation, unless the
<code>unescape</code> option is set to false.</p>
</dd>
<dt><a href="#err-XTDE3260"><span class="error">ERR
XTDE3260</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$options</code> includes an entry whose key is "spec" and
whose value is not a single <code>xs:string</code>, or an entry
whose key is "validate" or "unescape" and whose value is not a
single <code>xs:boolean</code>.</p>
</dd>
<dt><a href="#err-XTDE3340"><span class="error">ERR
XTDE3340</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value [of the first
argument to the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function] is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration visible in the <a title="package" class="termref" href=
"#dt-package">package</a> in which the function call appears. If
the processor is able to detect the error statically (for example,
when the argument is supplied as a string literal), then the
processor <span class="verb">may</span> optionally signal this as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE3350"><span class="error">ERR
XTDE3350</span></a></dt>
<dd>
<p>It is a <a title="" class="termref" href="#">dynamic error</a>
to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when there is no <a title="context item" class="termref"
href="#dt-context-item">context item</a>.</p>
</dd>
<dt><a href="#err-XTTE3360"><span class="error">ERR
XTTE3360</span></a></dt>
<dd>
<p>It is a <a title="" class="termref" href="#">type error</a> to
call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node, or when it is an
attribute or namespace node.</p>
</dd>
<dt><a href="#err-XTDE3365"><span class="error">ERR
XTDE3365</span></a></dt>
<dd>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs if the set of keys in
the maps resulting from evaluating the sequence constructor [within
an <a href="#element-map"><code>xsl:map</code></a> instruction]
contains duplicates.</p>
</dd>
<dt><a href="#err-XTDE3370"><span class="error">ERR
XTDE3370</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called and (a) the accumulator has the property
<code>streamable="no"</code>, and (b) the context item is a node in
a streamed document.</p>
</dd>
<dt><a href="#err-XTDE3380"><span class="error">ERR
XTDE3380</span></a></dt>
<dd>
<p>If the accumulator is declared with the attribute
<code>streamable="yes"</code> then it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of either (a) the sequence constructor
contained in a template rule invoked in a <a title="mode" class=
"termref" href="#dt-mode">mode</a> declared with
<code>streamable="yes"</code>, or (b) the sequence constructor
contained in an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, or both.
Call the nearest such construct in the chain of causation the
<b>controlling sequence constructor</b>.</p>
</dd>
<dt><a href="#err-XTDE3390"><span class="error">ERR
XTDE3390</span></a></dt>
<dd>
<p>If the accumulator is declared with the attribute
<code>streamable="yes"</code> then it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the context item at the point of
evaluating this function is the same node as the context item for
the evaluation of the <b>controlling sequence constructor</b>.</p>
</dd>
<dt><a href="#err-XTDE3400"><span class="error">ERR
XTDE3400</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function for an accumulator <var>A</var> is evaluated <b>in the
course of</b> evaluating the <code>new-value</code> expression of
any accumulator rule for the same accumulator <var>A</var>.</p>
</dd>
<dt><a href="#err-XTDE3410"><span class="error">ERR
XTDE3410</span></a></dt>
<dd>
<p>If the accumulator is declared with the attribute
<code>streamable="yes"</code> then it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of a <a title=
"pre-descent instruction" class="termref" href=
"#dt-pre-descent-instruction">pre-descent instruction</a> within
the <b>controlling sequence constructor</b>.</p>
</dd>
<dt><a href="#err-XTDE3420"><span class="error">ERR
XTDE3420</span></a></dt>
<dd>
<p>If the accumulator is declared with the attribute
<code>streamable="yes"</code> then it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is called unless the evaluation is performed <b>in the
course of</b> the evaluation of a <a title=
"post-descent instruction" class="termref" href=
"#dt-post-descent-instruction">post-descent instruction</a> within
the <b>controlling sequence constructor</b>.</p>
</dd>
<dt><a href="#err-XTMM9000"><span class="error">ERR
XTMM9000</span></a></dt>
<dd>
<p>When a transformation is terminated by use of <code>xsl:message
terminate="yes"</code>, the effect is the same as when a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> occurs during the transformation. <span>The default error
code is <code>XTMM9000</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-message"><code>xsl:message</code></a>
instruction.</span></p>
</dd>
<dt><a href="#err-XTMM9001"><span class="error">ERR
XTMM9001</span></a></dt>
<dd>
<p>When a transformation is terminated by use of
<code>xsl:assert</code>, the effect is the same as when a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> occurs during the transformation. The default error code
is <code>XTMM9001</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-assert"><code>xsl:assert</code></a> instruction.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="implementation-defined-features" id=
"implementation-defined-features"></a>F Checklist of
Implementation-Defined Features (Non-Normative)</h2>
<p>This appendix provides a summary of XSLT language features whose
effect is explicitly <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
conformance rules (see <a href="#conformance"><i>26
Conformance</i></a>) require vendors to provide documentation that
explains how these choices have been exercised.</p>
<ol>
<li>
<p>The way in which a <a title="base output URI" class="termref"
href="#dt-base-output-uri">base output URI</a> is established is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> (See
<a href="#priming-stylesheet"><i>2.3.2 Priming a
Stylesheet</i></a>)</p>
</li>
<li>
<p>The way in which an XSLT processor is invoked, and the way in
which values are supplied for the source document, starting node,
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title=
"base output URI" class="termref" href="#dt-base-output-uri">base
output URI</a>, are implementation-defined. (See <a href=
"#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p>
</li>
<li>
<p>The mechanisms for creating new <a title="extension instruction"
class="termref" href="#dt-extension-instruction">extension
instructions</a> and <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#extensibility"><i>2.8 Extensibility</i></a>)</p>
</li>
<li>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
type errors are signaled statically. (See <a href="#errors"><i>2.11
Error Handling</i></a>)</p>
</li>
<li>
<p>Mechanisms to locate the source or executable code of a
<a title="package" class="termref" href="#dt-package">package</a>
are implementation-defined. (See <a href=
"#package-dependencies"><i>3.6.1 Dependencies between
Packages</i></a>)</p>
</li>
<li>
<p>The set of namespaces that are specially recognized by the
implementation (for example, for user-defined data elements, and
<a title="extension attribute" class="termref" href=
"#dt-extension-attribute">extension attributes</a>) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</li>
<li>
<p>The effect of user-defined data elements whose name is in a
namespace recognized by the implementation is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of any element in the
stylesheet is not 1.0 or 2.0 but is less than 3.0, the <span class=
"verb">recommended</span> action is to report a static error;
however, processors <span class="verb">may</span> recognize such
values and process the element in an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. (See
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>)</p>
</li>
<li>
<p>It is implementation-defined whether an <span>XSLT 3.0</span>
processor supports backwards compatible behavior for any XSLT
version earlier than XSLT 3.0. (See <a href="#backwards"><i>3.10
Backwards Compatible Processing</i></a>)</p>
</li>
<li>
<p>It is implementation-defined what forms of URI reference are
acceptable in the <code>href</code> attribute of the <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a> elements, for
example, the URI schemes that may be used, the forms of fragment
identifier that may be used, and the media types that are
supported. (See <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>)</p>
</li>
<li>
<p>An implementation may define mechanisms, above and beyond
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
that allow <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> such as type
definitions to be made available within a stylesheet. (See <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>)</p>
</li>
<li>
<p>It is implementation-defined which versions of XML and XML
Namespaces (1.0 and/or 1.1) are supported. (See <a href=
"#xml-versions"><i>4.1 XML Versions</i></a>)</p>
</li>
<li>
<p>Limits on the value space of primitive datatypes, where not
fixed by <a href="#xmlschema-2">[XML Schema Part 2]</a>, are
implementation-defined. (See <a href="#limits"><i>4.7
Limits</i></a>)</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">statically known
documents</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">statically
known collections</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-default-collection">statically
known default collection type</a><sup><small>XP30</small></sup> is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>Implementations may provide user options that relax the
requirement for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions (and therefore, by implication, the <a href=
"#func-document"><code>document</code></a> function) to return
stable results. The manner in which such user options are provided,
if at all, is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>. (See
<a href="#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a>)</p>
</li>
<li>
<p>The implicit timezone for a transformation is
implementation-defined. (See <a href=
"#evaluation-context"><i>5.4.3.2 Other Components of the XPath
Dynamic Context</i></a>)</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-default-collection">default
collection</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#evaluation-context"><i>5.4.3.2 Other Components of the
XPath Dynamic Context</i></a>)</p>
</li>
<li>
<p>The availability of dynamic context information within <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a>)</p>
</li>
<li>
<p>The default values for the <code>warning-on-no-match</code> and
<code>warning-on-multiple-match</code> attributes of <a href=
"#element-mode"><code>xsl:mode</code></a> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#declaring-modes"><i>6.6.1 Declaring Modes</i></a>)</p>
</li>
<li>
<p>The form of any warnings output when there is no matching
template rule or when there are multiple matching template rules is
implementation-defined. (See <a href="#declaring-modes"><i>6.6.1
Declaring Modes</i></a>)</p>
</li>
<li>
<p>The mechanism by which the caller supplies a value for a
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#global-variables"><i>9.5 Global Variables and
Parameters</i></a>)</p>
</li>
<li>
<p>The set of extension functions available in the static context
for the target expression of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#evaluate-static-context"><i>10.4.1 Static context for the
target expression</i></a>)</p>
</li>
<li>
<p>If an <code>xml:id</code> attribute that has not been subjected
to attribute value normalization is copied from a source tree to a
result tree, it is implementation-defined whether attribute value
normalization will be applied during the copy process. (See
<a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>)</p>
</li>
<li>
<p>The numbering sequences supported by the <a href=
"#element-number"><code>xsl:number</code></a> instructions, beyond
those defined in this specification, are implementation-defined.
(See <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>There <span class="verb">may</span> be implementation-defined
upper bounds on the numbers that can be formatted by <a href=
"#element-number"><code>xsl:number</code></a> using any particular
numbering sequence. (See <a href="#convert"><i>12.3 Number to
String Conversion Attributes</i></a>)</p>
</li>
<li>
<p>The set of languages for which numbering is supported by
<a href="#element-number"><code>xsl:number</code></a>, and the
method of choosing a default language, are implementation-defined.
(See <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>With <a href="#element-number"><code>xsl:number</code></a>, it
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> what
combinations of values of the format token, the language, and the
<code>ordinal</code> attribute are supported. (See <a href=
"#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>If the <code>data-type</code> attribute of the <a href=
"#element-sort"><code>xsl:sort</code></a> element has a value other
than <code>text</code> or <code>number</code>, the effect is
implementation-defined. (See <a href=
"#comparing-sort-keys"><i>13.1.2 Comparing Sort Key
Values</i></a>)</p>
</li>
<li>
<p>The facilities for defining collations and allocating URIs to
identify them are implementation-defined. (See <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>)</p>
</li>
<li>
<p>The algorithm used by <a href=
"#element-sort"><code>xsl:sort</code></a> to locate a collation,
given the values of the <code>lang</code> and
<code>case-order</code> attributes, is implementation-defined. (See
<a href="#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>)</p>
</li>
<li>
<p>The set of media types recognized by the processor, for the
purpose of interpreting fragment identifiers in URI references
passed to the <a href="#func-document"><code>document</code></a>
function, is implementation-defined. (See <a href=
"#func-document"><i>20.1 fn:document</i></a>)</p>
</li>
<li>
<p>The values returned by the <a href=
"#func-system-property"><code>system-property</code></a> function,
and the names of the additional properties that are recognized, are
implementation-defined. (See <a href=
"#func-system-property"><i>20.3.4 fn:system-property</i></a>)</p>
</li>
<li>
<p>The destination and formatting of messages written using the
<a href="#element-message"><code>xsl:message</code></a> instruction
are implementation-defined. (See <a href="#message"><i>22.1
Messages</i></a>)</p>
</li>
<li>
<p>The detail of any external mechanism allowing a processor to
disable checking of assertions is implementation-defined. (See
<a href="#assertions"><i>22.2 Assertions</i></a>)</p>
</li>
<li>
<p>This specification does not define any mechanism for creating or
binding implementations of <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and it is
not <span class="verb">required</span> that implementations support
any such mechanism. Such mechanisms, if they exist, are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#extension"><i>23 Extensibility and Fallback</i></a>)</p>
</li>
<li>
<p>The effect of an extension function returning a string
containing characters that are not permitted in XML is
implementation-defined. (See <a href=
"#calling-extension-functions"><i>23.1.2 Calling Extension
Functions</i></a>)</p>
</li>
<li>
<p>The way in which external objects are represented in the type
system is implementation-defined. (See <a href=
"#external-objects"><i>23.1.3 External Objects</i></a>)</p>
</li>
<li>
<p>The way in which a final result tree is delivered to an
application is implementation-defined. (See <a href=
"#result-trees"><i>24 Final Result Trees</i></a>)</p>
</li>
<li>
<p>There <span class="verb">may</span> be <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
restrictions on the form of absolute URI that may be used in the
<code>href</code> attribute of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. (See <a href="#creating-result-trees"><i>24.1 Creating
Final Result Trees</i></a>)</p>
</li>
<li>
<p>Implementations <span class="verb">may</span> provide additional
mechanisms allowing users to define the way in which <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are processed. (See
<a href="#creating-result-trees"><i>24.1 Creating Final Result
Trees</i></a>)</p>
</li>
<li>
<p>If serialization is supported, then the location to which a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized is
implementation-defined, subject to the constraint that relative URI
<span>references</span> used to reference one tree from another
remain valid. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>The default value of the <code>encoding</code> attribute of the
<a href="#element-output"><code>xsl:output</code></a> element is
implementation-defined. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>It is implementation-defined which versions of XML, HTML, and
XHTML are supported in the <code>version</code> attribute of the
<a href="#element-output"><code>xsl:output</code></a> declaration.
(See <a href="#serialization"><i>25 Serialization</i></a>)</p>
</li>
<li>
<p>The default value of the <code>byte-order-mark</code>
serialization parameter is implementation-defined in the case of
UTF-8 encoding. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>It is implementation-defined whether, and under what
circumstances, disabling output escaping is supported. (See
<a href="#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>)</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="XSLT-defined-functions" id=
"XSLT-defined-functions"></a>G List of XSLT-defined functions
(Non-Normative)</h2>
<p>This appendix acts as an index of functions defined in this
specification, to augment the set of functions defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<!--{xsl-query} XSLT Processor: Saxonica SAXON HE 9.4.0.3-->
<!--{xmlspec} XSLT Processor: SaxonicaSAXONHE 9.4.0.3-->
<dl>
<dt class="label"><a href=
"#func-accumulator-after"><code>accumulator-after</code></a></dt>
<dd>See <a href="#func-accumulator-after"><i>18.2.5
fn:accumulator-after</i></a></dd>
<dt class="label"><a href=
"#func-accumulator-before"><code>accumulator-before</code></a></dt>
<dd>See <a href="#func-accumulator-before"><i>18.2.4
fn:accumulator-before</i></a></dd>
<dt class="label"><a href=
"#func-collation-key"><code>collation-key</code></a></dt>
<dd>See <a href="#func-collation-key"><i>21.1.2.8
fn:collation-key</i></a></dd>
<dt class="label"><a href=
"#func-copy-of"><code>copy-of</code></a></dt>
<dd>See <a href="#func-copy-of"><i>18.3 fn:copy-of</i></a></dd>
<dt class="label"><a href=
"#func-current"><code>current</code></a></dt>
<dd>See <a href="#func-current"><i>20.3.1 fn:current</i></a></dd>
<dt class="label"><a href=
"#func-current-group"><code>current-group</code></a></dt>
<dd>See <a href="#func-current-group"><i>14.2.1
fn:current-group</i></a></dd>
<dt class="label"><a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a></dt>
<dd>See <a href="#func-current-grouping-key"><i>14.2.2
fn:current-grouping-key</i></a></dd>
<dt class="label"><a href=
"#func-deep-equal"><code>deep-equal</code></a></dt>
<dd>See <a href="#func-deep-equal"><i>21.1.2.10
fn:deep-equal</i></a></dd>
<dt class="label"><a href=
"#func-document"><code>document</code></a></dt>
<dd>See <a href="#func-document"><i>20.1 fn:document</i></a></dd>
<dt class="label"><a href=
"#func-element-available"><code>element-available</code></a></dt>
<dd>See <a href="#func-element-available"><i>23.2.2
fn:element-available</i></a></dd>
<dt class="label"><a href=
"#func-function-available"><code>function-available</code></a></dt>
<dd>See <a href="#func-function-available"><i>23.1.1
fn:function-available</i></a></dd>
<dt class="label"><a href=
"#func-json-to-xml"><code>json-to-xml</code></a></dt>
<dd>See <a href="#func-json-to-xml"><i>21.2.2
fn:json-to-xml</i></a></dd>
<dt class="label"><a href="#func-key"><code>key</code></a></dt>
<dd>See <a href="#func-key"><i>20.2.2 fn:key</i></a></dd>
<dt class="label"><a href=
"#func-map-contains"><code>map:contains</code></a></dt>
<dd>See <a href="#func-map-contains"><i>21.1.2.3
map:contains</i></a></dd>
<dt class="label"><a href=
"#func-map-entry"><code>map:entry</code></a></dt>
<dd>See <a href="#func-map-entry"><i>21.1.2.5
map:entry</i></a></dd>
<dt class="label"><a href=
"#func-map-for-each-entry"><code>map:for-each-entry</code></a></dt>
<dd>See <a href="#func-map-for-each-entry"><i>21.1.2.7
map:for-each-entry</i></a></dd>
<dt class="label"><a href=
"#func-map-get"><code>map:get</code></a></dt>
<dd>See <a href="#func-map-get"><i>21.1.2.4 map:get</i></a></dd>
<dt class="label"><a href=
"#func-map-keys"><code>map:keys</code></a></dt>
<dd>See <a href="#func-map-keys"><i>21.1.2.2 map:keys</i></a></dd>
<dt class="label"><a href=
"#func-map-new"><code>map:new</code></a></dt>
<dd>See <a href="#func-map-new"><i>21.1.2.1 map:new</i></a></dd>
<dt class="label"><a href=
"#func-map-remove"><code>map:remove</code></a></dt>
<dd>See <a href="#func-map-remove"><i>21.1.2.6
map:remove</i></a></dd>
<dt class="label"><a href=
"#func-regex-group"><code>regex-group</code></a></dt>
<dd>See <a href="#func-regex-group"><i>17.2
fn:regex-group</i></a></dd>
<dt class="label"><a href=
"#func-snapshot"><code>snapshot</code></a></dt>
<dd>See <a href="#func-snapshot"><i>18.4 fn:snapshot</i></a></dd>
<dt class="label"><a href=
"#func-system-property"><code>system-property</code></a></dt>
<dd>See <a href="#func-system-property"><i>20.3.4
fn:system-property</i></a></dd>
<dt class="label"><a href=
"#func-type-available"><code>type-available</code></a></dt>
<dd>See <a href="#func-type-available"><i>23.1.4
fn:type-available</i></a></dd>
<dt class="label"><a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a></dt>
<dd>See <a href="#func-unparsed-entity-public-id"><i>20.3.3
fn:unparsed-entity-public-id</i></a></dd>
<dt class="label"><a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a></dt>
<dd>See <a href="#func-unparsed-entity-uri"><i>20.3.2
fn:unparsed-entity-uri</i></a></dd>
</dl>
</div>
<div class="div1">
<h2><a name="schema-for-xslt" id="schema-for-xslt"></a>H Schema for
XSLT Stylesheets (Non-Normative)</h2>
<p>The following XSD 1.1 schema describes the structure of an XSLT
stylesheet module. It does not define all the constraints that
apply to a stylesheet (for example, it does not attempt to define a
datatype that precisely represents attributes containing XPath
<a title="expression" class="termref" href=
"#dt-expression">expressions</a>). However, every valid stylesheet
module conforms to this schema, unless it contains elements that
invoke <a title="forwards compatible behavior" class="termref"
href="#dt-forwards-compatible-behavior">forwards compatible
behavior</a>.</p>
<p>A copy of this schema is available at <a href=
"http://www.w3.org/2012/07/schema-for-xslt30.xsd">http://www.w3.org/2012/07/schema-for-xslt30.xsd</a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The schema as written uses a lax wildcard to permit literal
result elements to appear in a sequence constructor. This assumes
that the schema used for validation will not contain any global
element declaration that matches the element name of a literal
result element. The content model for an element such as
<code>invoice</code> appearing within a stylesheet is not the same
as the content model for the same element appearing within a source
document (it is likely to contain XSLT instructions rather than
other elements from the target vocabulary): therefore, including
such declarations in the schema used for validating a stylesheet is
inappropriate.</p>
<p>The reason that lax validation rather than skip validation is
used is so that XSLT instructions appearing as children of the
literal result element will themselves be validated, using the
appropriate global element declaration.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The schema uses XSD 1.1 assertions to represent some of the
non-grammatical constraints appearing in the specification, for
example the rule that some elements can have either a
<code>select</code> attribute or a contained sequence constructor,
but not both. At this stage, no attempt has been made to represent
every such constraint, even where it is not difficult to express
the rule. There will always be some constraints that cannot be
expressed at all, for example those that require access to multiple
stylesheet modules, those that require access to the in-scope
schema components, and those that involve parsing a non-regular
grammar, such as the grammar for patterns.</p>
<p>Apart from assertions, the only other significant use of XSD 1.1
features is that the elements <a href=
"#element-param"><code>xsl:param</code></a> and <a href=
"#element-variable"><code>xsl:variable</code></a> are in two
substitution groups: one containing all instructions, and one
containing all declarations. If the schema needs to be converted to
an XSD 1.0 schema, removing all assertions is straightforward; the
other change needed is to remove <a href=
"#element-param"><code>xsl:param</code></a> and <a href=
"#element-variable"><code>xsl:variable</code></a> from the
substitution group for declarations, and instead permit them
explicitly as children of <a href=
"#element-transform"><code>xsl:transform</code></a>.</p>
</div>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--* &lt;!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200105//EN"
       "http://www.w3.org/2001/XMLSchema.dtd" [
&lt;!ENTITY % schemaAttrs "
  xmlns:xs   CDATA #IMPLIED
  xmlns:xsl  CDATA #IMPLIED
  xmlns:xsd  CDATA #IMPLIED"
&gt;
&lt;!ENTITY % p "xs:"&gt;
&lt;!ENTITY % s ":xs"&gt;
]&gt; *--&gt;

&lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="text/xsl"?&gt; 
&lt;!--* &lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="application/xslt+xml"?&gt;  *--&gt;
&lt;!--* &lt;?xml-stylesheet href="../../../www.w3.org/2008/09/xsd.xsl" type="application/xslt+xml"?&gt; *--&gt;

&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified"&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;This is an XSD 1.1 schema for XSLT 3.0 stylesheets.
      It defines all the elements that appear in the XSLT namespace; it also provides hooks that
      allow the inclusion of user-defined literal result elements, extension instructions, and
      top-level data elements.&lt;/p&gt;
      
      &lt;p&gt;This schema is available for use under the conditions of the W3C
      Software License published at http://www.w3.org/Consortium/Legal/copyright-software-19980720&lt;/p&gt;
      
      &lt;p&gt;The schema is organized as follows:&lt;/p&gt;
      &lt;ul&gt;
         &lt;li&gt;PART A: definitions of complex types and model groups used
         as the basis for element definitions&lt;/li&gt;
         &lt;li&gt;PART B: definitions of individual XSLT elements&lt;/li&gt; 
         &lt;li&gt;PART C: definitions for literal result elements&lt;/li&gt; 
         &lt;li&gt;PART D: definitions of simple types used in attribute definitions&lt;/li&gt;
      &lt;/ul&gt;
      
      &lt;p&gt;The schema has a number of limitations:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;The XSLT specification allows additional elements and attributes to be present
        where forwards compatibility is invoked. This schema does not.&lt;/li&gt;
        &lt;li&gt;The XSLT specification allows arbitrary content in a part of the stylesheet
        that is excluded by virtue of a use-when attribute. This schema does not.&lt;/li&gt;
        &lt;li&gt;The handling of literal result elements in this schema is imperfect; although
        various options are allowed, none matches the specification exactly. For example,
        the content of a literal result element uses lax validation, which permits child
        elements in the XSLT namespace that have no declaration in this schema.&lt;/li&gt;
        &lt;li&gt;The schema makes no attempt to check XPath expressions for syntactic or
        semantic correctness, nor to check that component references are resolved (for example
        that a template named in xsl:call-template has a declaration). Doing this in general
        requires cross-document validation, which is beyond the scope of XSD.&lt;/li&gt;
        &lt;li&gt;The schema imports the schema for XSD 1.0 schema documents. In stylesheets that contain
        an inline XSD 1.1 schema, this import should be replaced with one for the schema for XSD 1.1
        schema documents.&lt;/li&gt;
       &lt;/ul&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;

  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt;
  &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt;

  &lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported
--&gt;

  &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
    schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART A: definitions of complex types and model groups used as the basis for
      element definitions &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:complexType name="generic-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements; it contains the
                definitions of the standard attributes that may appear on any element.&lt;/p&gt;    
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve"
      default="strip"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
    &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements with
                the exception of &lt;code&gt;xsl:output&lt;/code&gt;; it contains the
                definitions of the &lt;code&gt;version&lt;/code&gt; attribute that may appear on any element.
                &lt;/p&gt;
             &lt;p&gt;The &lt;code&gt;xsl:output&lt;/code&gt; does not use this definition because, although it
             has a &lt;code&gt;version&lt;/code&gt; attribute, the syntax and semantics of this attribute are
             unrelated to the standard &lt;code&gt;version&lt;/code&gt; attribute allowed on other elements.&lt;/p&gt;    
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="sequence-constructor"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements that
                allow a sequence constructor as their content.
                &lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-and-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type allows a sequence constructor and a select attribute.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-or-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type allows a sequence constructor or a select attribute, but not both.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;xs:assert test="not(exists(@select) and (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="sequence-constructor-group"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements that
                allow a sequence constructor as their content.
                &lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:instruction"/&gt;
      &lt;xs:group ref="xsl:result-elements"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

  &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; 
      PART B: definitions of individual XSLT elements 
      Elements are listed in alphabetical order. 
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:element name="accept"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any variations that the containing package wishes to make to the visibility of
            components made available from a library package. For example, it may indicate that
            some of the public components in the library package are not to be made available
            to the containing package.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type" use="required"/&gt;
          &lt;xs:attribute name="names" type="xsl:EQNames" use="required"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1"  maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" /&gt;
          &lt;xs:attribute name="post-descent" type="xsl:EQName" /&gt;
          &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="accumulator-rule"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern" use="required"/&gt;
          &lt;xs:attribute name="phase"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="start"/&gt;
                &lt;xs:enumeration value="end"/&gt;
              &lt;/xs:restriction&gt;           
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="new-value" type="xsl:expression" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="regex" type="xsl:avt" use="required"/&gt;
          &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sort"/&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
          &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="on-empty" type="xsl:expression"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:attribute"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="break" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="catch"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="errors" type="xs:token" use="optional"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="comment" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="prohibited"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="on-empty" type="xsl:expression"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt;
          &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
          &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt;
          &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
          &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt;
          &lt;xs:attribute name="per-mille" type="xsl:char" default="~"/&gt;
          &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt;
          &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
          &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="on-empty" type="xsl:expression"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="xpath" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt;
          &lt;xs:attribute name="context-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt;
          &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt;
          &lt;xs:attribute name="with-params" type="xsl:expression"/&gt;         
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="expose"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            the visibility of components that are made available (or not) by this package
            to other using packages.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="bind-group" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="bind-grouping-key" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="count((@group-by, @group-adjacent, @group-starting-with, @group-ending-with)) = 1"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;These four attributes are mutually exclusive: it is a static error 
                  if none of these four attributes is present or if more than one of them is present.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@collation) or exists(@composite)) then (exists(@group-by) or exists(@group-adjacent)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is an error to specify the collation attribute or the composite attribute 
                  if neither the group-by attribute nor group-adjacent attribute is specified.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@bind-grouping-key)) then (exists(@group-by) or exists(@group-adjacent)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if the bind-grouping-key attribute is present on an 
                  xsl:for-each-group instruction unless either the group-by or group-adjacent attribute is present.    
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sequence"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName-in-namespace" use="required"/&gt;
          &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="identity-sensitive" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cache" type="xsl:caching-values"/&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies (empty($e/@select) and empty($e/child::node()))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no default value.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@visibility)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@required)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;required&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;
          &lt;xs:assert test="not(exists(@schema-location) and exists(xs:schema))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;XTSE0215: It is a static error if an xsl:import-schema element that contains an 
                xs:schema element has a schema-location attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern" use="required"/&gt;
          &lt;xs:attribute name="use" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map" type="xsl:sequence-constructor" substitutionGroup="xsl:instruction"/&gt;
  
  &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="key" type="xsl:expression" use="required"/&gt;            
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="bind-group" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="bind-key" type="xsl:EQName"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-source"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="for-each" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
          &lt;xs:attribute name="bind-source" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="initial" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="shallow-skip"/&gt;
          &lt;xs:attribute name="on-multiple-match" type="xsl:on-multiple-match-type" default="use-last"/&gt;
          &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt;
          &lt;xs:attribute name="visibility"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xsl:visibility-type"&gt;
                &lt;xs:enumeration value="public"/&gt;
                &lt;xs:enumeration value="private"/&gt;
                &lt;xs:enumeration value="final"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:assert test="not(normalize-space(@initial) = 'no' and exists(xsl:context-item))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:mode declaration specifying initial="no" 
                  contains an xsl:context-item element.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default" use="required"/&gt;
          &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
          &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
          &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;
          &lt;xs:attribute name="start-at" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
          &lt;xs:assert test="if (exists(@value)) then empty((@select, @count, @from)) and @level='single' else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if the value attribute of xsl:number is present unless the 
                  select, level, count, and from attributes are all absent.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;         
          &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="otherwise" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:generic-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="method" type="xsl:method"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="html-version" type="xs:decimal"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="output-character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="character" type="xsl:char" use="required"/&gt;
          &lt;xs:attribute name="string" type="xs:string" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="override"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any overriding definitions of components that the containing package wishes to make 
            to the components made available from a library package.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt;
            &lt;xs:element ref="xsl:function"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;
            &lt;xs:element ref="xsl:attribute-set"/&gt;
          &lt;/xs:choice&gt;          
          &lt;xs:assert test="every $e in * satisfies exists($e/@name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;Every component that is overridden (in particular, templates) must have a &lt;code&gt;name&lt;/code&gt; attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:template satisfies empty($e/@match)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A template that is overridden must not have a &lt;code&gt;match&lt;/code&gt; attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;  
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;   
  &lt;/xs:element&gt;
    
  &lt;xs:element name="package"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:use-package" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:transform" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:expose" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt;
          &lt;xs:assert test="every $s in (.//xsl:stylesheet, .//xsl:transform)[@input-type-annotations]
                           satisfies normalize-space($s/@input-type-annotations) = normalize-space(./@input-type-annotations)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;XTSE0265: It is a static error if a stylesheet module specifies the value strip 
                or preserve and the same value is not specified on the xsl:package element 
                of the containing package
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;Declaration of the &lt;code&gt;xsl:param&lt;/code&gt; element, used both defining function
            parameters, template parameters, parameters to &lt;code&gt;xsl:iterate&lt;/code&gt;,
            and global stylesheet parameters.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type" use="optional"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;          
          &lt;xs:assert test="if (normalize-space(@static) = 'yes') 
                           then normalize-space(@visibility) = ('', 'private', 'final') 
                           else true()"&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
                  &lt;p&gt;When the static attribute is present with the value yes, 
                    the visibility attribute must not have a value other than private 
                    or final.&lt;/p&gt;
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes')
                           then empty((*,text())) and exists(@select)
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the attribute static="yes" is specified, 
                  the xsl:param element must have empty content.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  

  &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="format" type="xsl:avt"/&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
          &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="html-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
          &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
          &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sequence" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="sort"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="stable" type="xsl:avt"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

  &lt;xs:element name="stream" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="href" type="xsl:avt" use="required"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
          &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:assert test="exists(@match) or exists(@name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element must have either a match attribute or a name attribute, or both.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (empty(@match)) then (empty(@mode) and empty(@priority)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element that has no match attribute must have no mode attribute and no priority attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(exists(@visibility) and empty(@name))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element that has no name attribute must have no visibility attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') then empty(* except (xsl:context-item, xsl:param)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;If the visibility attribute is present with the value abstract then (a) the sequence constructor defining 
                  the template body must be empty: that is, the only permitted children are xsl:context-item and xsl:param&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;If the visibility attribute is present with the value abstract then there must be no match attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@visibility)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a template must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="text-element-base-type"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"/&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;

  &lt;!--* first cut (for reference)
&lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
*--&gt;

  &lt;xs:complexType name="text-element-type"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="text" substitutionGroup="xsl:instruction" type="xsl:text-element-type"/&gt;


  &lt;xs:complexType name="transform-element-base-type"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"&gt;
          &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
              &lt;p&gt;The version attribute indicates the version of XSLT that 
                the stylesheet module requires. The attribute is required, 
                unless the xsl:stylesheet element is a child of an xsl:package 
                element, in which case it is optional: the default is then 
                taken from the parent xsl:package element.&lt;/p&gt;
            &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
        &lt;/xs:attribute&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="transform"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:transform-element-base-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
              &lt;!-- weaker than XSLT 1.0 --&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"
            default="unspecified"/&gt;
          &lt;!--* The 'static' attribute may be used on 'param' and 'variable'
              * only when they are top-level elements. *--&gt;
          &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[@static]
            satisfies
            $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]
            "&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The static attribute must not be present on an xsl:variable or xsl:param 
                  element unless it is a top-level element.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:catch"/&gt;
              &lt;xs:element ref="xsl:fallback"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="use-package"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:package&lt;/code&gt; and defines a dependency
            of the containing package on another package, identified by URI in the &lt;code&gt;name&lt;/code&gt;
            attribute. The &lt;code&gt;package-version&lt;/code&gt; attribute indicates which version of the
            library package is required, or may indicate a range of versions.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:accept"/&gt;
            &lt;xs:element ref="xsl:override"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;Declaration of the &lt;code&gt;xsl:variable&lt;/code&gt; element, used both for local
            and global variable bindings.&lt;/p&gt;
            &lt;p&gt;This definition takes advantage of the ability in XSD 1.1 for an element
                to belong to more than one substitution group. A global variable
                is a declaration, while a local variable can appear as an instruction
                in a sequence constructor.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" use="optional"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type" use="optional"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes') 
                           then normalize-space(@visibility) = ('', 'private', 'final') 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the static attribute is present with the value yes, 
                  the visibility attribute must not have a value other than private 
                  or final.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes')
                           then (empty((*,text())) and @select) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the attribute static="yes" is specified, 
                  the xsl:variable element must have empty content,
                  and the select attribute must be present to 
                  define the value of the variable.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;          
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="when"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="with-param"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" use="required"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART C: definition of literal result elements There are three ways to define
      the literal result elements permissible in a stylesheet. (a) do nothing. This allows any
      element to be used as a literal result element, provided it is not in the XSLT namespace (b)
      declare all permitted literal result elements as members of the xsl:literal-result-element
      substitution group (c) redefine the model group xsl:result-elements to accommodate all
      permitted literal result elements. Literal result elements are allowed to take certain
      attributes in the XSLT namespace. These are defined in the attribute group
      literal-result-element-attributes, which can be included in the definition of any literal
      result element. &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

  &lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
    &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve"
      default="strip"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt;
    &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:EQNames" default=""/&gt;
    &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt;
    &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt;
    &lt;xs:attribute name="type" form="qualified" type="xsl:EQName"/&gt;
    &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt;
  &lt;/xs:attributeGroup&gt;

  &lt;xs:group name="result-elements"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:literal-result-element"/&gt;
      &lt;xs:any namespace="##other" processContents="lax"/&gt;
      &lt;xs:any namespace="##local" processContents="lax"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;


  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART D: definitions of simple types used in stylesheet attributes
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:simpleType name="avt"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; This type is used for all attributes that allow an attribute value
        template. The general rules for the syntax of attribute value templates, and the specific
        rules for each such attribute, are described in the XSLT 2.1 Recommendation.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="caching-values"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "full", "partial", or "no". &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="full"/&gt;
      &lt;xs:enumeration value="partial"/&gt;
      &lt;xs:enumeration value="no"/&gt;
    &lt;/xs:restriction&gt;
    
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="char"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A string containing exactly one character. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:length value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
   &lt;xs:simpleType name="component-kind-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes a kind of component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="template"/&gt;
      &lt;xs:enumeration value="function"/&gt;
      &lt;xs:enumeration value="variable"/&gt;
      &lt;xs:enumeration value="attribute-set"/&gt;
      &lt;xs:enumeration value="mode"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="default-mode-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The default-mode attribute of xsl:stylesheet, xsl:transform, 
        xsl:package (or any other xsl:* element): either a QName or #unnamed. 
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="expression"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; An XPath 2.0 expression. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="item-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; An XPath 2.1 ItemType&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="input-type-annotations-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes how type annotations in source documents are handled.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="level"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The level attribute of xsl:number: one of single, multiple, or any.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="single"/&gt;
      &lt;xs:enumeration value="multiple"/&gt;
      &lt;xs:enumeration value="any"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="mode"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The mode attribute of xsl:apply-templates: either a QName, or #current, or
        #unnamed, or #default. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
          &lt;xs:enumeration value="#current"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="modes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The mode attribute of xsl:template: either a list, each member being either
        a QName or #default or #unnamed; or the value #all &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;   
      &lt;xs:union&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction&gt;           
            &lt;xs:simpleType&gt;
              &lt;xs:list&gt;
                &lt;xs:simpleType&gt;
                  &lt;xs:union memberTypes="xsl:EQName"&gt;
                    &lt;xs:simpleType&gt;
                      &lt;xs:restriction base="xs:token"&gt;
                        &lt;xs:enumeration value="#default"/&gt;
                        &lt;xs:enumeration value="#unnamed"/&gt;
                      &lt;/xs:restriction&gt;
                    &lt;/xs:simpleType&gt;
                  &lt;/xs:union&gt;
                &lt;/xs:simpleType&gt;
              &lt;/xs:list&gt;
            &lt;/xs:simpleType&gt;
            &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
                  &lt;p&gt;XTSE0550: It is a static error if the same token is included more than once in the list.
                  &lt;/p&gt;
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:assertion&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:enumeration value="#all"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:union&gt;     
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="nametests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A list of NameTests, as defined in the XPath 2.0 Recommendation. Each
        NameTest is either a QName, or "*", or "prefix:*", or "*:localname" &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:union memberTypes="xsl:EQName"&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:token"&gt;
              &lt;xs:enumeration value="*"/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:token"&gt;
              &lt;xs:pattern value="\i\c*:\*"/&gt;
              &lt;xs:pattern value="\*:\i\c*"/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
        &lt;/xs:union&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-multiple-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the action to be taken when there are several template rules to match an item in a given mode.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="use-last"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-no-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the action to be taken when there is no template rule to match an item in a given mode.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="deep-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy"/&gt;
      &lt;xs:enumeration value="deep-skip"/&gt;
      &lt;xs:enumeration value="shallow-skip"/&gt;
      &lt;xs:enumeration value="text-only-copy"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefixes"&gt;
    &lt;xs:list itemType="xs:NCName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list-or-all"&gt;
    &lt;xs:union memberTypes="xsl:prefix-list"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list"&gt;
    &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="method"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The method attribute of xsl:output: Either one of the recognized names
        "xml", "xhtml", "html", "text", or a QName that must include a prefix. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="xml"/&gt;
          &lt;xs:enumeration value="xhtml"/&gt;
          &lt;xs:enumeration value="html"/&gt;
          &lt;xs:enumeration value="text"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xsl:EQName"&gt;
          &lt;xs:pattern value="\c*:\c*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="pattern"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A match pattern as defined in the XSLT 2.1 Recommendation. The syntax for
        patterns is a restricted form of the syntax for XPath 2.0 expressions. Change since XSLT
        2.0: Patterns may now match any item (not only nodes) &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:expression"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-or-default"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Either a namespace prefix, or #default. Used in the xsl:namespace-alias
        element. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQNames"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A list of QNames. Used in the [xsl:]use-attribute-sets attribute of various
        elements, and in the cdata-section-elements attribute of xsl:output &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:EQName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQName"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; 
        &lt;p&gt;An extended QName. This schema does not use the built-in type xs:QName, but rather
        defines its own QName type. This may be either a local name, or a prefixed QName, or a name written
        using the extended QName notation Q{uri}local&lt;/p&gt;
        &lt;p&gt;Although xs:QName would define the correct validation on these
        attributes, a schema processor would expand unprefixed QNames incorrectly when constructing
        the PSVI, because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be
        in the default namespace, which is not the correct assumption for XSLT. The data type is therefore
        defined as a union of NCName and QName, so that an unprefixed name will be validated as an 
        NCName and will therefore not be treated as having the semantics of an unprefixed xs:QName. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName xs:QName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="Q\{.*\}\i\c*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="EQName-in-namespace"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; 
        &lt;p&gt;A subtype of EQNames that excludes no-namespace names&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
        &lt;xs:restriction base="xsl:EQName"&gt;
          &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt;
        &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;  
  
  &lt;xs:simpleType name="sequence-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The description of a data type, conforming to the SequenceType production
        defined in the XPath 2.0 Recommendation &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="typed-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes whether a mode is designed to match typed or untyped nodes.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="uri-list"&gt;
    &lt;xs:list itemType="xs:anyURI"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-strip-or-preserve"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes different ways of type-annotating an element or attribute.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:validation-type"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes different ways of type-annotating an element or attribute.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the visibility of a component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
      &lt;xs:enumeration value="hidden"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-not-hidden-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the visibility of a component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:visibility-type"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "yes" or "no". &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no-or-omit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "yes" or "no" or "omit". &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="omit"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="zero-digit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A digit that has the numerical value zero. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:char"&gt;
      &lt;xs:pattern value="\p{Nd}"/&gt;
      &lt;xs:assertion test="matches(string-join(codepoints-to-string(for $i in 0 to 9 
                          return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</pre></div>
<div class="div1">
<h2><a name="acknowledgements" id="acknowledgements"></a>I
Acknowledgements (Non-Normative)</h2>
<p>This specification was developed and approved for publication by
the W3C XSL Working Group (WG). WG approval of this specification
does not necessarily imply that all WG members voted for its
approval.</p>
<p>The chair of the XSL WG is Sharon Adler. The active membership
of the XSL WG at the time of publication comprises:</p>
<blockquote>
<p>Sharon Adler (Chair)<br />
Anders Berglund<br />
Oliver Becker<br />
Carine Bournez (W3C team)<br />
Abel Braaksma<br />
Florent Georges<br />
Michael Kay (Editor)<br />
Jirka Kosek<br />
Michael Sperberg-McQueen<br />
Mohamed Zergaoui</p>
</blockquote>
<p>The Working Group wishes to acknowledge the contribution of
those who have participated in the work at earlier stages, as well
as the pioneering work of the developers of STX (see <a href=
"#STX">[STX]</a>) which has formed an important intellectual input
to the design of XSLT 3.0 and has demonstrated the feasibility of
creating a streaming transformation language based on the core XSLT
concept of recursive descent of the source tree using rule-based
templates.</p>
</div>
<div class="div1">
<h2><a name="changes-since-2.0" id="changes-since-2.0"></a>J
Changes since XSLT 2.0 (Non-Normative)</h2>
<div class="div2">
<h3><a name="xslt-changes-since-2.0" id=
"xslt-changes-since-2.0"></a>J.1 <a href="#xslt-changes-since-2.0"
style="text-decoration: none">Changes in this
Specification</a></h3>
<ol class="enumar">
<li>
<p>A stylesheet may now consist of multiple packages. The language
specification for packages has been designed with a view to
allowing packages to be compiled independently of each other. The
specification provides control over the interface offered by a
package to other packages; in particular it allows functions,
variables, named templates and other components to be declared as
public, private, final, or abstract.</p>
</li>
<li>
<p>A new <a href="#element-mode"><code>xsl:mode</code></a>
declaration is added.</p>
<ol class="enumla">
<li>
<p>A mode may be declared to be streamable, and rules are given
that constrain what the template rules in a streamable mode can
do.</p>
</li>
<li>
<p>The <a href="#element-mode"><code>xsl:mode</code></a>
declaration may contain an <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
to declare the expected type of the <a title="initial context item"
class="termref" href="#dt-initial-context-item">initial context
item</a> when this mode is the <a title="initial mode" class=
"termref" href="#dt-initial-mode">initial mode</a>.</p>
</li>
<li>
<p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration
may define the action to be taken when there is no matching
template rule, and the action to be taken when there are multiple
matching template rules.</p>
</li>
<li>
<p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration
may indicate that the template rules in a given mode are designed
to process typed (schema-validated) nodes only, or untyped nodes
only. It may also indicate that element names appearing in match
patterns for the mode are only to match elements in the source
document that have been validated against the corresponding element
declarations in the schema.</p>
</li>
<li>
<p>A default mode can be declared for a stylesheet module, making
it easier to reuse existing stylesheet modules to construct a
composite stylesheet.</p>
</li>
</ol>
</li>
<li>
<p>Several new instructions are introduced with the aim of making
it easier to write streamable transformations, although most of
these instructions can also be used without streaming:</p>
<ol class="enumla">
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is provided specifically to read and process an input
document using streaming.</p>
</li>
<li>
<p>The <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction allows iterative processing of a sequence, with the
ability for the processing of one item to depend on the results of
processing of previous items, and with the ability to terminate the
iteration before all the items in the sequence have been
processed.</p>
</li>
<li>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction allows several input sequences to be merged into a
single output sequence, based on the value of a merge key.</p>
</li>
<li>
<p>The <a href="#element-fork"><code>xsl:fork</code></a>
instruction allows multiple results to be computed during a single
pass of a streamed input document.</p>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction can now contain a sequence constructor as an
alternative to using the <code>select</code> attribute. This is
primarily for use cases involving <a href=
"#element-fork"><code>xsl:fork</code></a>.</p>
</li>
</ol>
</li>
<li>
<p>Other changes introduced to facilitate the writing of streamable
stylesheets include:</p>
<ol class="enumla">
<li>
<p>The new <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> declaration <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> is
introduced. An accumulator represents information about a node in a
document that can be computed during a streamed pass over the
document, starting at the start and ending at that node.</p>
</li>
<li>
<p>An <code>[xsl:]on-empty</code> attribute is provided for
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, and literal
result elements, to control their behavior when the content of the
constructed node would otherwise be empty.</p>
</li>
<li>
<p>New functions <a href="#func-copy-of"><code>copy-of</code></a>
and <a href="#func-snapshot"><code>snapshot</code></a> are
provided, to enable streaming applications to operate in
"windowing" mode, where the input document is divided into a
sequence of small subtrees processed one at a time.</p>
</li>
</ol>
</li>
<li>
<p>Some further new instructions are provided, unrelated to
streaming:</p>
<ol class="enumla">
<li>
<p>The <a href="#element-try"><code>xsl:try</code></a> instruction
allows recovery from dynamic errors.</p>
</li>
<li>
<p>A new <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is provided, to allow evaluation of XPath expressions
constructed dynamically from strings, or read from a source
document.</p>
</li>
<li>
<p>The <a href="#element-assert"><code>xsl:assert</code></a>
instruction allows arbitrary assertions about the state of
variables or the input document, improving testability and
robustness.</p>
</li>
</ol>
</li>
<li>
<p>Text nodes within a sequence constructor may now contain
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> (XPath
expressions enclosed in curly brackets), if this is enabled by
setting <code>expand-text="yes"&gt;</code> on an enclosing
element.</p>
</li>
<li>
<p>The syntax of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a> has been generalized. Patterns may now
match any item (not only nodes). In consequence, <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> can
now process sequences of atomic values as well as nodes, and
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
the <code>group-starting-with</code> and
<code>group-ending-with</code> options can also process atomic
sequences. As a further consequence, the <a title=
"initial context item" class="termref" href=
"#dt-initial-context-item">initial context item</a> supplied when
initiating a transformation is no longer required to be a node.</p>
</li>
<li>
<p>A new datatype, called a <b>map</b>, has been introduced,
together with supporting functions, operators, and type syntax.
Maps allow more complex data structures to be created than is
possible using atomic values and nodes alone. This has particular
applications to streamed processing: since a streamed application
can visit each node of its primary input document only once, it
often needs more advanced data structures to retain what it has
already seen in the document.</p>
</li>
<li>
<p>Miscellaneous changes to existing instructions and declarations
include:</p>
<ol class="enumla">
<li>
<p>The regular expression supplied to the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction is now permitted to be one that matches a zero-length
string.</p>
</li>
<li>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction now has a <code>select</code> attribute, which is
convenient when it is used inside a function where there is no
context item.</p>
</li>
<li>
<p>Composite keys are supported in <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>.</p>
</li>
<li>
<p>Two new attributes have been added to <a href=
"#element-function"><code>xsl:function</code></a> to provide
increased scope for optimization: <code>identity-sensitive</code>
and <code>cache</code>. The first indicates whether the identity of
nodes passed in the arguments or result of the function is
significant; the second indicates whether the function is to cache
its results (memoization).</p>
</li>
<li>
<p>The <code>override</code> attribute of <a href=
"#element-function"><code>xsl:function</code></a> is renamed
<code>override-extension-function</code>, retaining the old name as
a deprecated synonym.</p>
</li>
<li>
<p>The rule requiring <a href=
"#element-import"><code>xsl:import</code></a> declarations to
precede all other declarations in a stylesheet module has been
removed.</p>
</li>
<li>
<p>Composite keys are supported in <a href=
"#element-key"><code>xsl:key</code></a>.</p>
</li>
<li>
<p>A new attribute on <a href=
"#element-message"><code>xsl:message</code></a> allows
specification of the error code to be returned with
<code>terminate="yes"</code> is specified.</p>
</li>
<li>
<p>The rules for handling conflicts between <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
have changed. A conflict that can be detected statically is now
signaled as a static error; a run-time conflict between two
declarations having the same precedence and priority is now
resolved by taking whichever comes last in declaration order.</p>
</li>
<li>
<p>An <a href="#element-template"><code>xsl:template</code></a>
declaration may contain an <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
to declare the required type of the context item when the template
is called.</p>
</li>
<li>
<p>An empty <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction with
no <code>select</code> attribute is now permitted; its effect is to
construct a zero-length text node.</p>
</li>
<li>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
and <a href="#element-param"><code>xsl:param</code></a> elements
may now specify <code>static="yes"</code>, denoting that the
variable is available statically (informally, "at compile time").
Static variables and parameters make the
<code>[xsl:]use-when</code> mechanism more useful, especially in
conjunction with <a href=
"#element-assert"><code>xsl:assert</code></a>.</p>
</li>
</ol>
</li>
<li>
<p>New functions are available to import and export data in JSON
format.</p>
</li>
<li>
<p>A <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT Processor</a> now recognizes
all the built-in types defined in XML Schema.</p>
</li>
<li>
<p>A <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT Processor</a> will now accept
the attribute <code>validation="lax"</code> and interpret it in the
same way as a schema-aware processor when there is no schema
component available to perform the validation.</p>
</li>
<li>
<p>Some functions, including <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-generate-id"><code>generate-id</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-dateTime"><code>
format-dateTime</code></a><sup><small>FO30</small></sup>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-time"><code>format-time</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>
unparsed-text</code></a><sup><small>FO30</small></sup> have been
moved from this specification to the core Functions and Operators
specification, to make them available in other host languages.</p>
</li>
<li>
<p>The rule that effectively prevented references to external
documents in <code>[xsl:]use-when</code> expressions has been
removed.</p>
</li>
<li>
<p>A default value is defined for the named template to be used
when initiating a transformation (specifically,
<code>xsl:initial-template</code>).</p>
</li>
<li>
<p>Serialization to HTML5 and XHTML5 is supported. To this end, a
new serialization parameter <code>html-version</code> is provided
in <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
The adjective "non-recoverable" in describing other dynamic errors
becomes redundant and has therefore been dropped (the term was in
any case misleading since the introduction of a try/catch
mechanism). Error codes of the form <code>XTREnnnn</code> have been
renumbered <code>XTDEnnnn</code>.</p>
<p>Dynamic errors occurring during pattern evaluation are always
masked (they cause the pattern to report a non-match.)</p>
</li>
<li>
<p>The new serialization parameter <code>html-version</code> is
supported in <a href="#element-output"><code>xsl:output</code></a>
and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.
Note that the <code>item-separator</code> attribute is not
available in XSLT because the value that is serialized by XSLT is
always a singleton document node.</p>
</li>
<li>
<p>A family of collation URIs is defined for selecting collations
based on the Unicode Collation Algorithm.</p>
</li>
<li>
<p>Serialization parameters can now be specified in an external
parameter document.</p>
</li>
<li>
<p>The effect of specifying the type <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when validating by type is now
defined.</p>
</li>
<li>
<p>The <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
elements now allow a <code>parameter-document</code> attribute
allowing serialization to be configured in an external
document.</p>
</li>
<li>
<p>The set of constructs that set <a title="temporary output state"
class="termref" href="#dt-temporary-output-state">temporary output
state</a> has been reduced, and no longer includes instructions
that create nodes, such as <a href=
"#element-attribute"><code>xsl:attribute</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>. However,
<a href="#element-merge-key"><code>xsl:merge-key</code></a> has
been added to the list.</p>
</li>
<li>
<p>The possibilities for invocation of a stylesheet have been
expanded; they now include the ability to directly execute a
stylesheet function; to supply parameters to the initial template;
and to return the results of the invoked template or function as a
raw value, without construction of a result tree.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="xpath-changes-since-2.0" id=
"xpath-changes-since-2.0"></a>J.2 <a href=
"#xpath-changes-since-2.0" style="text-decoration: none">Changes in
Other Related Specifications</a></h3>
<p>A number of changes affecting XSLT 2.0 have been made in other
related specifications. Some of the more significant changes are as
follows:</p>
<ol class="enumar">
<li>
<p>A number of new functions have been defined whose aim is to
facilitate streaming. These include <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text-lines">
<code>unparsed-text-lines</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>XPath 3.0 supports a subset of the <code>let</code> expression
from XQuery.</p>
</li>
<li>
<p>XPath 3.0 supports function items as first-class values
(functions can, for example, be bound to variables and passed as
parameters to other functions.)</p>
</li>
<li>
<p>XPath 3.0 supports a new syntax for writing expanded names using
the namespace URI and local part only, avoiding the need to create
a static context that binds namespace prefixes. This is intended to
be particularly useful when XPath expressions are
software-generated. Complementing this, a new function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-path"><code>path</code></a><sup><small>FO30</small></sup>
is available to generate a (namespace-context-independent) path to
any node that can subsequently be evaluated using the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction, or
otherwise.</p>
</li>
</ol>
</div>
</div>
<div class="div1">
<h2><a name="changes-since-july-2012" id=
"changes-since-july-2012"></a>K Changes since the Working Draft of
10 July 2012 (Non-Normative)</h2>
<p>This section lists all significant changes since the Working
Draft published on 10 July 2012.</p>
<ol class="enumar">
<li>
<p>Text nodes within a sequence constructor may now contain
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> (XPath
expressions enclosed in curly brackets), if this is enabled by
setting <code>expand-text="yes"&gt;</code> on an enclosing
element.</p>
</li>
<li>
<p>An empty <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction with
no <code>select</code> attribute is now permitted; its effect is to
construct a zero-length text node.</p>
</li>
<li>
<p>Static variables and parameters are introduced, to make the
<code>[xsl:]use-when</code> mechanism more useful, especially in
conjunction with <a href=
"#element-assert"><code>xsl:assert</code></a>.</p>
</li>
<li>
<p>The rule requiring <a href=
"#element-import"><code>xsl:import</code></a> declarations to
precede all other declarations in a stylesheet module has been
removed.</p>
</li>
<li>
<p>The rule that effectively prevented references to external
documents in <code>[xsl:]use-when</code> expressions has been
removed.</p>
</li>
<li>
<p>The <code>enabled</code> attribute of <a href=
"#element-assert"><code>xsl:assert</code></a> is removed; its
effect can now be achieved more conveniently using a
<code>use-when</code> attribute.</p>
</li>
<li>
<p>A default value is defined for the named template to be used
when initiating a transformation (specifically,
<code>xsl:initial-template</code>).</p>
</li>
<li>
<p>The <code>override</code> attribute of <a href=
"#element-function"><code>xsl:function</code></a> is renamed
<code>override-extension-function</code>, retaining the old name as
a deprecated synonym.</p>
</li>
<li>
<p>The rules for conformance against optional features have been
refactored.</p>
</li>
<li>
<p>(In the July 2012 draft but omitted from the change list): The
<a href="#element-sequence"><code>xsl:sequence</code></a>
instruction can now contain a sequence constructor as an
alternative to using the <code>select</code> attribute. This is
primarily for use cases involving <a href=
"#element-fork"><code>xsl:fork</code></a>.</p>
</li>
<li>
<p>A new attribute <code>with-params</code> is provided on <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>, to allow
parameters to be computed dynamically in the form of a map. This
works alongside the existing mechanism using <a href=
"#element-with-param"><code>xsl:with-param</code></a> children.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
The adjective "non-recoverable" in describing other dynamic errors
becomes redundant and has therefore been dropped (the term was in
any case misleading since the introduction of a try/catch
mechanism). Error codes of the form <code>XTREnnnn</code> have been
renumbered <code>XTDEnnnn</code>.</p>
</li>
<li>
<p>The new serialization parameters <code>html-version</code> and
<code>item-separator</code> are supported in <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
<li>
<p>Two new attributes have been added to <a href=
"#element-function"><code>xsl:function</code></a> to provide
increased scope for optimization: <code>identity-sensitive</code>
and <code>cache</code>.</p>
</li>
<li>
<p>A family of collation URIs is defined for selecting collations
based on the Unicode Collation Algorithm.</p>
</li>
<li>
<p>The <code>on-empty</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a> is no longer ignored in
cases where the selected node is not a document or element
node.</p>
</li>
<li>
<p>Serialization parameters can now be specified in an external
parameter document.</p>
</li>
<li>
<p>The effect of specifying the type <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when validating by type is now
defined.</p>
</li>
<li>
<p>Maps no longer have an associated collation. In its place, a new
<a href="#func-collation-key"><code>collation-key</code></a>
function is introduced to allow key values to be normalized
according to the rules of a given collation.</p>
</li>
<li>
<p>The syntax for patterns has been rewritten. The grammar is now
closely aligned with the XPath 3.0 grammar, so that it can be
readily verified that the grammar is a subset of XPath, and that
there are no needless restrictions (this was necessary to fix some
bugs in this area). The type-based syntax <code>~typename</code>
used in earlier drafts was found not to be well-aligned with
practical use cases for matching atomic values, and has been
replaced by the construct <code>.[ Expr ]</code> which tests the
item using an arbitrary boolean expression.</p>
</li>
<li>
<p>Accumulators are now classified as components for the purpose of
defining packages; in addition, the rules for overriding them using
<a href="#element-import"><code>xsl:import</code></a> are now
defined. The <code>name</code> and <code>initial-value</code>
attributes of an accumulator are now mandatory.</p>
</li>
<li>
<p>The regular expression supplied to the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction is now permitted to be one that matches a zero-length
string.</p>
</li>
<li>
<p>The <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
elements now allow a <code>parameter-document</code> attribute
allowing serialization to be configured in an external
document.</p>
</li>
<li>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has been made part of an optional feature, the dynamic
evaluation feature.</p>
</li>
<li>
<p>Dynamic errors occurring during pattern evaluation are always
masked (they cause the pattern to report a non-match.)</p>
</li>
<li>
<p>Stylesheet parameters that specify <code>required="yes"</code>
must have visibility equal to <code>public</code>.</p>
</li>
<li>
<p>The meaning of <code>on-no-match="deep-skip"</code> has been
changed when the selected node is a document node; in this case it
is now equivalent to <code>shallow-skip</code>.</p>
</li>
<li>
<p>Redundant parentheses at the outermost level of a pattern in a
template rule now have no effect on the semantics: they do not
affect the default priority, and they do not prevent the branches
of a union being effectively treated as separate template
rules.</p>
</li>
<li>
<p>The method for invoking accumulator functions has changed;
instead of user-defined functions, there are now two built-in
functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> that
take the accumulator name as an argument.</p>
</li>
<li>
<p>The attributes <code>default-collation</code> and
<code>default-mode</code> can now be specified on any element.</p>
</li>
<li>
<p>The attribute <code>initial</code> on <a href=
"#element-mode"><code>xsl:mode</code></a> is dropped, as the same
effect can be achieved using the <code>visibility</code>
attribute.</p>
</li>
<li>
<p>It is now a dynamic error for a map expression or an <a href=
"#element-map"><code>xsl:map</code></a> instruction to generate
duplicate keys.</p>
</li>
<li>
<p>There has been a substantial rewrite of section <a href=
"#streamability"><i>19 Streamability</i></a>. Some of the changes
are to relax restrictions on streamability that were found to be a
nuisance; others are to fix errors in the analysis rules that meant
some constructs (such as the <a href=
"#func-copy-of"><code>copy-of</code></a> function) could not
effectively be used for their intended purpose. Other changes are
simply for clarity or conciseness of exposition. The new concept of
<a title="posture" class="termref" href="#dt-posture">posture</a>
reintroduces (under a different guise) the path analysis that was
described in graphical terms in an earlier working draft.</p>
</li>
<li>
<p>References to ECMA-262 (for the specification of JSON) have been
replaced with references to ECMA-404.</p>
</li>
<li>
<p>Attributes <code>validation</code> and <code>type</code> have
been added to the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction to
control schema-validation of streamed input documents.</p>
</li>
<li>
<p>The process of initiating a stylesheet is revised to allow
applications to invoke public functions as well as public template
rules, to allow parameters to the initial template or function to
be supplied, and to get the "raw result" of invoking a public
template or function, without the result being wrapped into a
result tree.</p>
</li>
<li>
<p>The syntax for map expressions has changed to use colon
(<code>:</code>) as the separator between key and value, rather
than <code>:=</code>.</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="incompatibilities" id="incompatibilities"></a>L
Incompatibilities with XSLT 2.0 (Non-Normative)</h2>
<p>This section lists all known incompatibilities with XSLT 2.0,
that is, situations wher a stylesheet that is error-free according
to the XSLT 2.0 specification and where all elements have an
effective version of <code>2.0</code> or less, will produce
different results depending on whether it is run under an XSLT 2.0
processor or an XSLT 3.0 processor.</p>
<ol class="enumar">
<li>
<p>XSLT 2.0 gave implementations freedom what to do when a node
selected by <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
matched more than one <a title="template rule" class="termref"
href="#dt-template-rule">template rule</a>. XSLT 3.0 is more
prescriptive in this situation. The behavior prescribed in XSLT 3.0
(selecting the template rule that is last in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>) is compatible with
the action of some XSLT 2.0 processors but not necessarily
others.</p>
</li>
<li>
<p>It is now a static error if the same <code>NameTest</code>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration with the same precedence and priority. Previously this
was a dynamic error, and processors were allowed to recover from
the error.</p>
</li>
<li>
<p>The current group and current grouping key are now absent rather
than empty when not in use, which means that attempting to refer to
them in this state gives a dynamic error.</p>
</li>
<li>
<p>As a consequence of functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>
moving from this specification to <a href=
"#xpath-functions-30">[Functions and Operators]</a>, error codes
associated with these functions have changed.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
Error codes of the form <code>XTREnnnn</code> have been renumbered
<code>XTDEnnnn</code>.</p>
</li>
<li>
<p>In previous versions of the specification, the <a href=
"#func-element-available"><code>element-available</code></a>
function when applied to names in the XSLT namespace was defined to
return <code>false</code> in the case of XSLT elements other than
instructions. (Actual practise in implementations was not always
consistent with this rule). In XSLT 3.0 the rules have been changed
so that it returns <code>true</code> for the names of such
elements, bringing the specification of the function into line with
the intuitive meaning of its name.</p>
</li>
<li>
<p>(This is not strictly speaking an incompatibility, as conforming
XSLT 2.0 stylesheets will continue to function correctly without
error. It can be considered as migration advice, a warning that
care is needed when introducing new XSLT 3.0 features.)</p>
<p>When a function or template has a parameter with a declared type
of <code>item()</code>, it should not assume (as it could in XSLT
2.0) that when the supplied item is not a node, it must be an
atomic value, and vice versa. In XSLT 3.0 there is a third option:
it might be a function. Functions and templates that fail to cater
for this possibility may fail with a type error if the caller
supplies a function as the relevant parameter value.</p>
</li>
</ol>
</div>
</div>
</body>
</html>
