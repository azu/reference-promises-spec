<!-- http://www.w3.org/TR/xpath-31/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--{xml-fix} XSLT Processor: SAXON 9.3.0.5 from Saxonica SAXON EE 9.3.0.5--><!--This document was created at 20140424 1055-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XML Path Language (XPath) 3.1</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"//www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XML Path Language (XPath)
3.1</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C First Public
Working Draft 24 April 2014</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/WD-xpath-31-20140424/">http://www.w3.org/TR/2014/WD-xpath-31-20140424/</a></dd>
<dt>Latest version of XPath 3.1:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-31/">http://www.w3.org/TR/xpath-31/</a></dd>
<dt>Most recent version of XPath 3:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-3/">http://www.w3.org/TR/xpath-3/</a></dd>
<dt>Most recent version of XPath:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath/">http://www.w3.org/TR/xpath/</a></dd>
<dt>Most recent Recommendation of XPath:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/REC-xpath-30-20140408/">http://www.w3.org/TR/2014/REC-xpath-30-20140408/</a></dd>
<dt>Editors:</dt>
<dd>Jonathan Robie, <span>EMC Corporation</span> <a href=
"mailto:jonathan.robie@emc.com">&lt;jonathan.robie@emc.com&gt;</a></dd>
<dd>Michael Dyck, Invited Expert <a href=
"mailto:jmdyck@ibiblio.org">&lt;jmdyck@ibiblio.org&gt;</a></dd>
</dl>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-31">
<strong>translations</strong></a>.</p>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2014/WD-xpath-31-20140424/xpath-31.xml">XML</a>
and&#160;<a href=
"http://www.w3.org/TR/2014/WD-xpath-31-20140424/xpath-31-diff.html">Change
markings relative to previous edition</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2014&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href=
"http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p class="xpath">XPath 3.1 is an expression language that allows
the processing of values conforming to the data model defined in
<a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM)
3.1]</a>. The data model provides a tree representation of XML
documents as well as atomic values such as integers, strings, and
booleans, and sequences that may contain both references to nodes
in an XML document and atomic values. The result of an XPath
expression may be a selection of nodes from the input documents, or
an atomic value, or more generally, any sequence allowed by the
data model. The name of the language derives from its most
distinctive feature, the path expression, which provides a means of
hierarchic addressing of the nodes in an XML tree. XPath 3.1 is a
superset of <a href="#xpath-30">[XML Path Language (XPath) Version
3.0]</a>. A list of changes made since XPath 3.0 can be found in
<a href="#id-revision-log"><b>J Change Log</b></a>. The main new
features in XPath 3.1 are:</p>
<ol class="enumar">
<li>
<p><a href="#id-maps"><b>3.11.1 Maps</b></a>.</p>
</li>
<li>
<p><a href="#id-arrays"><b>3.11.2 Arrays</b></a>.</p>
</li>
</ol>
<p class="xpath">A backwards compatibility mode is provided to
ensure that nearly all XPath 1.0 expressions continue to deliver
the same result with XPath 3.1; exceptions to this policy are noted
in [<a href="#id-backwards-compatibility"><b>I Backwards
Compatibility with XPath 1.0</b></a>].</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#first-wd">First
Public Working Draft</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html">Process
Document</a>. It was jointly developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
W3C <a href="http://www.w3.org/Style/XSL/">XSLT Working Group</a>,
each of which is part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>. The Working
Groups expect to advance this specification to <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
Status.</p>
<p>This First Public Working Draft specifies XPath version 3.1, a
fully compatible extension of <a href=
"http://www.w3.org/TR/xpath-30/">XPath version 3.0</a>.</p>
<p>This specification is designed to be referenced normatively from
other specifications defining a host language for it; it is not
intended to be implemented outside a host language. The
implementability of this specification has been tested in the
context of its normative inclusion in host languages defined by the
<a href="http://www.w3.org/TR/xquery-30/">XQuery 3.0</a> and XSLT
3.0 (expected in 2014) specifications; see the <a href=
"http://dev.w3.org/2011/QT3-test-suite/ReportingResults/">XQuery
3.0 implementation report</a> (and, in the future, the WGs expect
that there will also be a — possibly member-only — XSLT 3.0
implementation report) for details.</p>
<p>Please report errors in this document using W3C's <a href=
"https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[XPath31]” in
the subject line of your report, whether made in Bugzilla or in
email. Please use multiple Bugzilla entries (or, if necessary,
multiple email messages) if you have more than one comment to make.
Archives of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>Publication as a First Public Working Draft does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by groups operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XML Query Working Group and also maintains a
<a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also include
instructions for disclosing a patent. An individual who has actual
knowledge of a patent which the individual believes contains
<a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">Introduction</a><br />
2 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#context">Expression
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#id-processing-model">Processing Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#id-data-model-generation">Data Model Generation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#id-schema-import-processing">Schema Import Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#id-expression-processing">Expression Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1
<a href="#id-static-analysis">Static Analysis Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2
<a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#id-consistency-constraints">Consistency Constraints</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#errors">Error
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#id-kinds-of-errors">Kinds of Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#id-identifying-errors">Identifying and Reporting Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#id-handling-dynamic">Handling Dynamic Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#id-errors-and-opt">Errors and Optimization</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#id-important-concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#id-document-order">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href=
"#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.5 <a href=
"#id-uri-literals">URI Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.6 <a href=
"#id-resolve-relative-uri">Resolving a Relative URI
Reference</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#id-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
"#id-predefined-types">Predefined Schema Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
"#id-namespace-sensitive">Namespace-sensitive Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
"#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4 <a href=
"#id-sequencetype-syntax">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5 <a href=
"#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.1
<a href="#id-matching-value">Matching a SequenceType and a
Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.2
<a href="#id-matching-item">Matching an ItemType and an
Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.3
<a href="#id-element-test">Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.4
<a href="#id-schema-element-test">Schema Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.5
<a href="#id-attribute-test">Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.6
<a href="#id-schema-attribute-test">Schema Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.7
<a href="#id-function-test">Function Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.8
<a href="#id-map-test">Map Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.5.9
<a href="#id-array-test">Array Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6 <a href=
"#id-sequencetype-subtype">SequenceType Subtype
Relationships</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6.1
<a href="#id-seqtype-subtype">The judgement subtype(A, B)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.6.2
<a href="#id-itemtype-subtype">The judgement subtype-itemtype(Ai,
Bi)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.7 <a href=
"#id-xs-error">xs:error</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#comments">Comments</a><br />
3 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;3.1 <a href=
"#id-primary-expressions">Primary Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
"#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
"#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href=
"#id-function-calls">Static Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.1
<a href="#id-eval-function-call">Evaluating Static and Dynamic
Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.2
<a href="#id-function-conversion-rules">Function Conversion
Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5.3
<a href="#id-function-coercion">Function Coercion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.6 <a href=
"#id-named-function-ref">Named Function References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.7 <a href=
"#id-inline-func">Inline Function Expressions</a><br />
&#160;&#160;&#160;&#160;3.2 <a href=
"#id-postfix-expression">Postfix Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#id-filter-expression">Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#id-dynamic-function-invocation">Dynamic Function Call</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#id-arrow-operator">Arrow operator (=&gt;)</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#id-path-expressions">Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
"#id-relative-path-expressions">Relative Path Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1.1
<a href="#id-path-operator">Path operator (/)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
"#id-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2.1
<a href="#axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2.2
<a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.3 <a href=
"#id-predicate">Predicates within Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.4 <a href=
"#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.5 <a href=
"#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;3.4 <a href=
"#id-sequence-expressions">Sequence Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.1 <a href=
"#construct_seq">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.2 <a href=
"#combining_seq">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#id-arithmetic">Arithmetic
Expressions</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#id-string-concat-expr">String
Concatenation Expressions</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#id-comparisons">Comparison
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.1 <a href=
"#id-value-comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.2 <a href=
"#id-general-comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.7.3 <a href=
"#id-node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;3.8 <a href=
"#id-logical-expressions">Logical Expressions</a><br />
&#160;&#160;&#160;&#160;3.9 <a href="#id-for-expressions">For
Expressions</a><br />
&#160;&#160;&#160;&#160;3.10 <a href="#id-let-expressions">Let
Expressions</a><br />
&#160;&#160;&#160;&#160;3.11 <a href="#id-maps-and-arrays">Maps and
Arrays</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.1 <a href=
"#id-maps">Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.1.1
<a href="#id-map-constructors">Map Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.1.2
<a href="#id-map-lookup">Map Lookup</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.2 <a href=
"#id-arrays">Arrays</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.2.1
<a href="#id-array-constructors">Array Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.2.2
<a href="#id-array-lookup">Array Lookup</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.11.2.3
<a href="#d2e15024">Converting Arrays to Sequences</a><br />
&#160;&#160;&#160;&#160;3.12 <a href="#id-conditionals">Conditional
Expressions</a><br />
&#160;&#160;&#160;&#160;3.13 <a href=
"#id-quantified-expressions">Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;3.14 <a href=
"#id-expressions-on-datatypes">Expressions on
SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.1 <a href=
"#id-instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.2 <a href=
"#id-cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.3 <a href=
"#id-castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.4 <a href=
"#id-constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.5 <a href=
"#id-treat">Treat</a><br />
&#160;&#160;&#160;&#160;3.15 <a href="#id-map-operator">Simple map
operator (!)</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XPath 3.1 Grammar</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#id-grammar">EBNF</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href=
"#EBNFNotation">Notation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.2 <a href=
"#extra-grammatical-constraints">Extra-grammatical
Constraints</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.3 <a href=
"#notes-on-parsing">Grammar Notes</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#lexical-structure">Lexical
structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href=
"#terminal-symbols">Terminal Symbols</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href=
"#id-terminal-delimitation">Terminal Delimitation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3 <a href=
"#id-eol-handling">End-of-Line Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.1
<a href="#id-xml10-eol-handling">XML 1.0 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.2
<a href="#id-xml11-eol-handling">XML 1.1 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4 <a href=
"#whitespace-rules">Whitespace Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.1
<a href="#DefaultWhitespaceHandling">Default Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.2
<a href="#ExplicitWhitespaceHandling">Explicit Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;A.3 <a href=
"#id-reserved-fn-names">Reserved Function Names</a><br />
&#160;&#160;&#160;&#160;A.4 <a href=
"#id-precedence-order">Precedence Order (Non-Normative)</a><br />
B <a href="#id-type-promotion-and-operator-mapping">Type Promotion
and Operator Mapping</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type
Promotion</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator
Mapping</a><br />
C <a href="#id-xp-context-components">Context Components</a><br />
&#160;&#160;&#160;&#160;C.1 <a href=
"#id-xp-static-context-components">Static Context
Components</a><br />
&#160;&#160;&#160;&#160;C.2 <a href=
"#id-xp-evaluation-context-components">Dynamic Context
Components</a><br />
D <a href="#id-impl-defined-items">Implementation-Defined
Items</a><br />
E <a href="#id-references">References</a><br />
&#160;&#160;&#160;&#160;E.1 <a href=
"#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;E.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;E.3 <a href=
"#id-background-material">Background Material</a><br />
F <a href="#id-xpath-conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;F.1 <a href=
"#id-xpath-static-typing">Static Typing Feature</a><br />
G <a href="#id-errors">Error Conditions</a><br />
H <a href="#id-glossary">Glossary</a> (Non-Normative)<br />
I <a href="#id-backwards-compatibility">Backwards Compatibility
with XPath 1.0</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;I.1 <a href=
"#id-incompat-in-true-mode">Incompatibilities when Compatibility
Mode is true</a><br />
&#160;&#160;&#160;&#160;I.2 <a href=
"#id-incompat-in-false-mode">Incompatibilities when Compatibility
Mode is false</a><br />
&#160;&#160;&#160;&#160;I.3 <a href=
"#id-incompat-when-using-schema">Incompatibilities when using a
Schema</a><br />
J <a href="#id-revision-log">Change Log</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href=
"#id-incompatibilities">Incompatibilities</a><br />
&#160;&#160;&#160;&#160;J.2 <a href=
"#id-changes-this-draft">Changes introduced since XQuery
3.0</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.1 <a href=
"#id-changes-CR-substantive">Substantive Changes</a><br />
&#160;&#160;&#160;&#160;J.3 <a href=
"#id-changes-prior-drafts">Changes introduced in prior Working
Drafts</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="id-introduction" id="id-introduction"></a>1
Introduction</h2>
<p class="xpath">The primary purpose of XPath is to address the
nodes of <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML
1.1]</a> trees. XPath gets its name from its use of a path notation
for navigating through the hierarchical structure of an XML
document. XPath uses a compact, non-XML syntax to facilitate use of
XPath within URIs and XML attribute values.</p>
<p>[<a name="dt-datamodel" id="dt-datamodel" title=
"data model">Definition</a>: XPath 3.1 operates on the abstract,
logical structure of an XML document, rather than its surface
syntax. This logical structure, known as the <b>data model</b>, is
defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data
Model (XDM) 3.1]</a>.]</p>
<p class="xpath">XPath is designed to be embedded in a <b>host
language</b> such as <a href="#xslt-30">[XSL Transformations (XSLT)
Version 3.0]</a> or <a href="#xquery-31">[XQuery 3.1: An XML Query
Language]</a>.</p>
<p>XQuery Version 3.0 is an extension of XPath Version 3.0. In
general, any expression that is syntactically valid and executes
successfully in both XPath 3.0 and XQuery 3.0 will return the same
result in both languages. There are a few exceptions to this
rule:</p>
<ul>
<li>
<p>Because XQuery expands <span class="xpath">predefined entity
references and character references</span> and XPath does not,
expressions containing these produce different results in the two
languages. For instance, the value of the string literal
<code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and
<code>&amp;amp;</code> in XPath. (XPath is often embedded in other
languages, which may expand predefined entity references or
character references before the XPath expression is evaluated.)</p>
</li>
<li>
<p>If XPath 1.0 compatibility mode is enabled, XPath behaves
differently from XQuery in a number of ways, <span class=
"xpath">which are noted throughout this document, and listed in
<a href="#id-incompat-in-false-mode"><b>I.2 Incompatibilities when
Compatibility Mode is false</b></a>.</span></p>
</li>
</ul>
<p>Because these languages are so closely related, their grammars
and language descriptions are generated from a common source to
ensure consistency, and the editors of these specifications work
together closely.</p>
<p>XPath 3.1 also depends on and is closely related to the
following specifications:</p>
<ul>
<li>
<p><a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM)
3.1]</a> defines the data model that underlies all XPath 3.1
expressions.</p>
</li>
<li>
<p>The type system of XPath 3.1 is based on XML Schema. It is
implementation-defined whether the type system is based on <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.</p>
</li>
<li>
<p>The built-in function library and the operators supported by
XPath 3.1 are defined in <a href="#xpath-functions-31">[XQuery and
XPath Functions and Operators 3.1]</a>.</p>
</li>
</ul>
<p class="path">[<a name="dt-xpath-30-processor" id=
"dt-xpath-30-processor" title="XPath 3.0 Processor">Definition</a>:
An <b>XPath 3.0 Processor</b> processes a query according to the
XPath 3.0 specification.] [<a name="dt-xpath-20-processor" id=
"dt-xpath-20-processor" title="XPath 2.0 Processor">Definition</a>:
An <b>XPath 2.0 Processor</b> processes a query according to the
XPath 2.0 specification.] [<a name="dt-xpath-10-processor" id=
"dt-xpath-10-processor" title="XPath 1.0 Processor">Definition</a>:
An <b>XPath 1.0 Processor</b> processes a query according to the
XPath 1.0 specification.]</p>
<p>This document specifies a grammar for XPath 3.1, using the same
basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless
otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical
structure</b></a>), whitespace is not significant in <span class=
"xpath">expressions</span>. Grammar productions are introduced
together with the features that they describe, and a complete
grammar is also presented in the appendix [<a href="#nt-bnf"><b>A
XPath 3.1 Grammar</b></a>]. The appendix is the normative
version.</p>
<p>In the grammar productions in this document, named symbols are
underlined and literal text is enclosed in double quotes. For
example, the following productions describe the syntax of a static
function call:</p>
<h5><a name="d2e341" id="d2e341"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e342.doc-xpath31-FunctionCall" id=
"noid_d3e342.doc-xpath31-FunctionCall"></a>[63]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a> <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e343.doc-xpath31-ArgumentList" id=
"noid_d3e343.doc-xpath31-ArgumentList"></a>[49]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xpath31-Argument">Argument</a> (","
<a href="#doc-xpath31-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>The productions should be read as follows: A static function
call consists of an <a href="#doc-xpath31-EQName">EQName</a>
followed by an <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a>. The argument list
consists of an opening parenthesis, an optional list of one or more
arguments (separated by commas), and a closing parenthesis.</p>
<p>This document normatively defines the static and dynamic
semantics of XPath 3.1. In this document, examples and material
labeled as "Note" are provided for explanatory purposes and are not
normative.</p>
<p>Certain aspects of language processing are described in this
specification as <b>implementation-defined</b> or
<b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>Implementation-defined</b> indicates an aspect that may differ
between implementations, but must be specified by the implementor
for each particular implementation.]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.]</p>
</li>
</ul>
<p class="xpath">A language aspect described in this specification
as <b>implementation-defined</b> or <b>implementation dependent</b>
may be further constrained by the specifications of a host language
in which XPath is embedded.</p>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>2 Basics</h2>
<p>The basic building block of XPath 3.1 is the <b>expression</b>,
which is a string of <a href="#Unicode">[Unicode]</a> characters;
the version of Unicode to be used is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. The
language provides several kinds of expressions which may be
constructed from keywords, symbols, and operands. In general, the
operands of an expression are other expressions. XPath 3.1 allows
expressions to be nested with full generality.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification contains no assumptions or requirements
regarding the character set encoding of strings of <a href=
"#Unicode">[Unicode]</a> characters.</p>
</div>
<p>Like XML, XPath 3.1 is a case-sensitive language. Keywords in
XPath 3.1 use lower-case characters and are not reserved—that is,
names in XPath 3.1 expressions are allowed to be the same as
language keywords, except for certain unprefixed function-names
listed in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function
Names</b></a>.</p>
<p>[<a name="dt-value" id="dt-value" title="value">Definition</a>:
In the <a title="data model" href="#dt-datamodel">data model</a>, a
<b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.] [<a name="dt-sequence" id=
"dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is
an ordered collection of zero or more <a title="item" href=
"#dt-item">items</a>.] [<a name="dt-item" id="dt-item" title=
"item">Definition</a>: An <b>item</b> is either an <a title=
"atomic value" href="#dt-atomic-value">atomic value</a>, a
<a title="node" href="#dt-node">node</a>, or a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.]
[<a name="dt-atomic-value" id="dt-atomic-value" title=
"atomic value">Definition</a>: An <b>atomic value</b> is a value in
the value space of an <b>atomic type</b>, as defined in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.] [<a name="dt-node" id="dt-node" title=
"node">Definition</a>: A <b>node</b> is an instance of one of the
<b>node kinds</b> defined in <a href="#xpath-datamodel-31">[XQuery
and XPath Data Model (XDM) 3.1]</a>.] Each node has a unique
<b>node identity</b>, a <b>typed value</b>, and a <b>string
value</b>. In addition, some nodes have a <b>name</b>. The <b>typed
value</b> of a node is a sequence of zero or more atomic values.
The <b>string value</b> of a node is a value of type
<code>xs:string</code>. The <b>name</b> of a node is a value of
type <code>xs:QName</code>.</p>
<p>[<a name="dt-singleton" id="dt-singleton" title=
"singleton">Definition</a>: A sequence containing exactly one item
is called a <b>singleton</b>.] An item is identical to a singleton
sequence containing that item. Sequences are never nested—for
example, combining the values 1, (2, 3), and ( ) into a single
sequence results in the sequence (1, 2, 3). [<a name=
"dt-empty-sequence" id="dt-empty-sequence" title=
"empty sequence">Definition</a>: A sequence containing zero items
is called an <b>empty sequence</b>.]</p>
<p>[<a name="dt-data-model-instance" id="dt-data-model-instance"
title="XDM instance">Definition</a>: The term <b>XDM instance</b>
is used, synonymously with the term <a title="value" href=
"#dt-value">value</a>, to denote an unconstrained <a title=
"sequence" href="#dt-sequence">sequence</a> of <a title="item"
href="#dt-item">items</a> in the <a title="data model" href=
"#dt-datamodel">data model</a>.]</p>
<p>In the XPath 3.1 grammar, most names are specified using the
<a href="#doc-xpath31-EQName">EQName</a> production, which allows
<a title="lexical QName" href="#dt-qname">lexical QNames</a>, and
also allows a namespace URI to be specified as a literal:</p>
<h5><a name="d2e565" id="d2e565"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-EQName" id=
"doc-xpath31-EQName"></a>[110]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-QName">QName</a> | <a href=
"#doc-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-QName" id=
"doc-xpath31-QName"></a>[120]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-QName">QName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e548.doc-xpath31-NCName" id=
"noid_d3e548.doc-xpath31-NCName"></a>[121]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-URIQualifiedName" id=
"doc-xpath31-URIQualifiedName"></a>[115]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xpath31-NCName">NCName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-BracedURILiteral" id=
"doc-xpath31-BracedURILiteral"></a>[116]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-BracedURILiteral">BracedURILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" [^{}]* "}"</code></td>
</tr>
</tbody>
</table>
<p>Names in XPath 3.1 can be bound to namespaces, and are based on
the syntax and semantics defined in <a href="#XMLNAMES">[XML
Names]</a>. [<a name="dt-qname" id="dt-qname" title=
"lexical QName">Definition</a>: A <b>lexical QName</b> is a name
that conforms to the syntax of <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a>.]
A <a title="lexical QName" href="#dt-qname">lexical QName</a>
consists of an optional namespace prefix and a local name. If the
namespace prefix is present, it is separated from the local name by
a colon. A <a title="lexical QName" href="#dt-qname">lexical
QName</a> with a prefix can be converted into an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> by
resolving its namespace prefix to a namespace URI, using the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. The
semantics of a <a title="lexical QName" href="#dt-qname">lexical
QName</a> without a prefix depend on the expression in which it is
found.</p>
<p>[<a name="dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName">Definition</a>: An <b>expanded QName</b> consists
of an optional namespace URI and a local name. An expanded QName
also retains its original namespace prefix (if any), to facilitate
casting the expanded QName into a string.] Two <a title=
"expanded QName" href="#dt-expanded-qname">expanded QNames</a> are
equal if their namespace URIs are equal and their local names are
equal (even if their namespace prefixes are not equal). Namespace
URIs and local names are compared on a codepoint basis, without
further normalization.</p>
<p>The <a href="#doc-xpath31-EQName">EQName</a> production allows
expanded QNames to be specified using either a <a href=
"#doc-xpath31-QName">QName</a> or a <a href=
"#doc-xpath31-URIQualifiedName">URIQualifiedName</a>, which allows
the namespace URI to be specified as a literal. The namespace URI
value is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. It is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>] if
the namespace URI for an EQName is
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<p>Here are some examples of <a href=
"#doc-xpath31-EQName">EQName</a>s:</p>
<ul>
<li>
<p><code>pi</code> is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> without a namespace prefix.</p>
</li>
<li>
<p><code>math:pi</code> is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> with a namespace prefix.</p>
</li>
<li>
<p><code>Q{http://www.w3.org/2005/xpath-functions/math}pi</code>
specifies the namespace URI using a <a href=
"#doc-xpath31-BracedURILiteral">BracedURILiteral</a>; it is not a
<a title="lexical QName" href="#dt-qname">lexical QName</a>.</p>
</li>
</ul>
<p><span class="xpath">This document uses the following namespace
prefixes to represent the namespace URIs with which they are
listed. Use of these namespace prefix bindings in this document is
not normative.</span></p>
<ul>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>err = http://www.w3.org/2005/xqt-errors</code> (see
<a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting
Errors</b></a>).</p>
</li>
</ul>
<p>Element nodes have a property called <b>in-scope namespaces</b>.
[<a name="dt-in-scope-namespaces" id="dt-in-scope-namespaces"
title="in-scope namespaces">Definition</a>: The <b>in-scope
namespaces</b> property of an element node is a set of namespace
bindings, each of which associates a namespace prefix with a URI.]
For a given element, one namespace binding may have an empty
prefix; the URI of this namespace binding is the default namespace
within the scope of the element.</p>
<p class="xpath">In <a href="#xpath">[XML Path Language (XPath)
Version 1.0]</a>, the in-scope namespaces of an element node are
represented by a collection of <b>namespace nodes</b> arranged on a
<b>namespace axis</b>. As of XPath 2.0, the namespace axis is
deprecated and need not be supported by a host language. A host
language that does not support the namespace axis need not
represent namespace bindings in the form of nodes.</p>
<p>[<a name="dt-URI" id="dt-URI" title="URI">Definition</a>: Within
this specification, the term <b>URI</b> refers to a Universal
Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a>
and extended in <a href="#RFC3987">[RFC3987]</a> with the new name
<b>IRI</b>.] The term URI has been retained in preference to IRI to
avoid introducing new names for concepts such as "Base URI" that
are defined or referenced across the whole family of XML
specifications.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In most contexts, processors are not required to raise errors if
a URI is not lexically valid according to <a href=
"#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>. See
<a href="#id-uri-literals"><b>2.4.5 URI Literals</b></a> for
details.</p>
</div>
<div class="div2">
<h3><a name="context" id="context"></a>2.1 Expression Context</h3>
<p>[<a name="dt-expression-context" id="dt-expression-context"
title="expression context">Definition</a>: The <b>expression
context</b> for a given expression consists of all the information
that can affect the result of the expression.]</p>
<p>This information is organized into two categories called the
<a title="static context" href="#dt-static-context">static
context</a> and the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a>.</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>2.1.1 Static
Context</h4>
<p>[<a name="dt-static-context" id="dt-static-context" title=
"static context">Definition</a>: The <b>static context</b> of an
expression is the information that is available during static
analysis of the expression, prior to its evaluation.] This
information can be used to decide whether the expression contains a
<a title="static error" href="#dt-static-error">static
error</a>.</p>
<p>The individual components of the <a title="static context" href=
"#dt-static-context">static context</a> are described below.
<span class="xpath">A default initial value for each component must
be specified by the host language. The scope of each component is
specified in <a href="#id-xp-static-context-components"><b>C.1
Static Context Components</b></a>.</span></p>
<ul>
<li>
<p>[<a name="dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode">Definition</a>: <b>XPath 1.0
compatibility mode.</b> <span class="xpath">This value is
<code>true</code> if rules for backward compatibility with XPath
Version 1.0 are in effect; otherwise it is
<code>false</code>.</span> ]</p>
</li>
<li>
<p>[<a name="dt-static-namespaces" id="dt-static-namespaces" title=
"statically known namespaces">Definition</a>: <b>Statically known
namespaces.</b> This is a mapping from prefix to namespace URI that
defines all the namespaces that are known during static processing
of a given expression.] The URI value is whitespace normalized
according to the rules for the <code>xs:anyURI</code> type in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a>. Note the difference between
<a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a>, which is a
dynamic property of an element node, and <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, which is a
static property of an expression.</p>
</li>
<li>
<p>[<a name="dt-def-elemtype-ns" id="dt-def-elemtype-ns" title=
"default element/type namespace">Definition</a>: <b>Default
element/type namespace.</b> This is a namespace URI or <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where an element or type name is expected.]
The URI value is whitespace normalized according to the rules for
the <code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</li>
<li>
<p>[<a name="dt-def-fn-ns" id="dt-def-fn-ns" title=
"default function namespace">Definition</a>: <b>Default function
namespace.</b> This is a namespace URI or <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where a function name is expected.] The URI
value is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</li>
<li>
<p>[<a name="dt-issd" id="dt-issd" title=
"in-scope schema definitions">Definition</a>: <b>In-scope schema
definitions.</b> This is a generic term for all the element
declarations, attribute declarations, and schema type definitions
that are in scope during static analysis of an expression.] It
includes the following three parts:</p>
<ul>
<li>
<p>[<a name="dt-is-types" id="dt-is-types" title=
"in-scope schema type">Definition</a>: <b>In-scope schema
types.</b> Each schema type definition is identified either by an
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a <b>named type</b>) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
]</p>
</li>
<li>
<p>[<a name="dt-is-elems" id="dt-is-elems" title=
"in-scope element declarations">Definition</a>: <b>In-scope element
declarations.</b> Each element declaration is identified either by
an <a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a top-level element declaration) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). ] An element
declaration includes information about the element's <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> affiliation.</p>
<p>[<a name="dt-substitution-group" id="dt-substitution-group"
title="substitution group">Definition</a>: <b>Substitution
groups</b> are defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> and <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1.
Informally, the substitution group headed by a given element
(called the <b>head element</b>) consists of the set of elements
that can be substituted for the head element without affecting the
outcome of schema validation.]</p>
</li>
<li>
<p>[<a name="dt-is-attrs" id="dt-is-attrs" title=
"in-scope attribute declarations">Definition</a>: <b>In-scope
attribute declarations.</b> Each attribute declaration is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level attribute
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration). ]</p>
</li>
</ul>
</li>
<li>
<p>[<a name="dt-in-scope-variables" id="dt-in-scope-variables"
title="in-scope variables">Definition</a>: <b>In-scope
variables.</b> This is a mapping from <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> to type. It defines
the set of variables that are available for reference within an
expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the
variable, and the type is the <a title="static type" href=
"#dt-static-type">static type</a> of the variable.]</p>
<p>An expression that binds a variable extends the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a>, within the scope of the variable, with the variable
and its type. Within the body of an <a title=
"inline function expression" href="#dt-inline-func">inline function
expression</a> , the <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> are extended by the
names and types of the <b>function parameters</b>.</p>
</li>
<li>
<p>[<a name="dt-context-item-static-type" id=
"dt-context-item-static-type" title=
"context item static type">Definition</a>: <b>Context item static
type.</b> This component defines the <a title="static type" href=
"#dt-static-type">static type</a> of the context item within the
scope of a given expression.]</p>
</li>
<li>
<p>[<a name="dt-known-func-signatures" id=
"dt-known-func-signatures" title=
"statically known function signatures">Definition</a>:
<b>Statically known function signatures.</b> This is a mapping from
(expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function
signature</a><sup><small>DM31</small></sup>. ] The entries in this
mapping define the set of <b>statically known functions</b> — those
functions that are available to be called from a <a title=
"static function call" href="#dt-static-function-call">static
function call</a>, or referenced from a <a title=
"named function reference" href="#dt-named-function-ref">named
function reference</a>. Each such function is uniquely identified
by its <a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> and arity (number of parameters). Given a statically
known function's expanded QName and arity, this component supplies
the function's <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-signature">signature</a><sup><small>DM31</small></sup>,
which specifies various static properties of the function,
including types.</p>
<p>The <span>statically known</span> function signatures include
the signatures of functions from a variety of sources, including
built-in functions described in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>, <span class="xpath">and <a title="constructor function"
href="#dt-constructor-function">constructor functions</a></span> .
<span class="xpath">Implementations must ensure that no two
functions have the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and the same arity (even if
the signatures are consistent).</span></p>
</li>
<li>
<p>[<a name="dt-static-collations" id="dt-static-collations" title=
"statically known collations">Definition</a>: <b>Statically known
collations.</b> This is an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> mapping
from URI to collation. It defines the names of the collations that
are available for use in processing expressions.] [<a name=
"dt-collation" id="dt-collation" title="collation">Definition</a>:
A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.]</p>
</li>
<li>
<p>[<a name="dt-def-collation" id="dt-def-collation" title=
"default collation">Definition</a>: <b>Default collation.</b> This
identifies one of the collations in <a title=
"statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.]</p>
</li>
<li>
<p>[<a name="dt-static-base-uri" id="dt-static-base-uri" title=
"Static Base URI">Definition</a>: <b>Static Base URI.</b> This is
an absolute URI, used to resolve <span class="xpath">relative URI
references.</span> ] <span class="xpath">If <var>E</var> is a
subexpression of <var>F</var> then the Static Base URI of
<var>E</var> is the same as the Static Base URI of <var>F</var>.
There are no constructs in XPath that require resolution of
relative URI references during static analysis.</span> The Static
Base URI is available during dynamic evaluation by use of the
<code>fn:static-base-uri</code> function, and is used implicitly
during dynamic evaluation by functions such as <code>fn:doc</code>.
Relative URI references are resolved as described in <a href=
"#id-resolve-relative-uri"><b>2.4.6 Resolving a Relative URI
Reference</b></a>.</p>
</li>
<li>
<p>[<a name="dt-known-docs" id="dt-known-docs" title=
"statically known documents">Definition</a>: <b>Statically known
documents.</b> This is a mapping from strings to types. The string
represents the absolute URI of a resource that is potentially
available using the <code>fn:doc</code> function. The type is the
<a title="static type" href="#dt-static-type">static type</a> of a
call to <code>fn:doc</code> with the given URI as its literal
argument. ] If the argument to <code>fn:doc</code> is a string
literal that is not present in <b>statically known documents</b>,
then the <a title="static type" href="#dt-static-type">static
type</a> of <code>fn:doc</code> is
<code>document-node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known documents</b> is to
provide static type information, not to determine which documents
are available. A URI need not be found in the <b>statically known
documents</b> to be accessed using <code>fn:doc</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-collections" id="dt-known-collections" title=
"statically known collections">Definition</a>: <b>Statically known
collections.</b> This is a mapping from strings to types. The
string represents the absolute URI of a resource that is
potentially available using the <code>fn:collection</code>
function. The type is the type of the sequence of nodes that would
result from calling the <code>fn:collection</code> function with
this URI as its argument.] If the argument to
<code>fn:collection</code> is a string literal that is not present
in <b>statically known collections</b>, then the <a title=
"static type" href="#dt-static-type">static type</a> of
<code>fn:collection</code> is <code>node()*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known collections</b> is to
provide static type information, not to determine which collections
are available. A URI need not be found in the <b>statically known
collections</b> to be accessed using
<code>fn:collection</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-default-collection" id=
"dt-known-default-collection" title=
"statically known default collection type">Definition</a>:
<b>Statically known default collection type.</b> This is the type
of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.] Unless
initialized to some other value by an implementation, the value of
<b>statically known default collection type</b> is
<code>node()*</code>.</p>
</li>
<li>
<p>[<a name="dt-static-decimal-formats" id=
"dt-static-decimal-formats" title=
"statically known decimal formats">Definition</a>: <b>Statically
known decimal formats.</b> This is a mapping from QName to decimal
format, with one default format that has no visible name. Each
format is used for serializing decimal numbers using
<code>fn:format-number()</code>.]</p>
<p>Each decimal format contains three sets of properties, which
control the interpretation of characters in the picture string
supplied to the <code>fn:format-number</code> function, and also
specify characters that may appear in the result of formatting the
number.</p>
<p>The following attributes specify characters used to format the
number per se:</p>
<ul>
<li>
<p>[<a name="id-static-decimal-separator" id=
"id-static-decimal-separator" title=
"decimal-separator">Definition</a>: <b>decimal-separator</b>
specifies the character used for the decimal-separator-symbol; the
default value is the period character (.)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-exponent-separator" id=
"id-static-decimal-format-exponent-separator" title=
"exponent-separator">Definition</a>: <b>exponent-separator</b>
Defines the character used to separate the mantissa from the
exponent in scientific notation both in the picture string and in
the formatted number; the default value is the character (e).]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-grouping-separator" id=
"id-static-decimal-format-grouping-separator" title=
"grouping-separator">Definition</a>: <b>grouping-separator</b>
specifies the character used for the grouping-separator-symbol,
which is typically used as a thousands separator; the default value
is the comma character (,)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-percent-sign" id=
"id-static-decimal-format-percent-sign" title=
"percent-sign">Definition</a>: <b>percent</b> specifies the
character used for the percent-symbol; the default value is the
percent character (%)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-per-mille-sign" id=
"id-static-decimal-format-per-mille-sign" title=
"per-mille-sign">Definition</a>: <b>per-mille</b> specifies the
character used for the per-mille-symbol; the default value is the
Unicode per-mille character (#x2030)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-zero-digit" id=
"id-static-decimal-format-zero-digit" title=
"zero-digit">Definition</a>: <b>zero-digit</b> specifies the
character used for the zero-digit-symbol; the default value is the
digit zero (0). This character must be a digit (category Nd in the
Unicode property database), and it must have the numeric value
zero. This attribute implicitly defines the Unicode character that
is used to represent each of the values 0 to 9 in the final result
string: Unicode is organized so that each set of decimal digits
forms a contiguous block of characters in numerical sequence.]</p>
</li>
</ul>
<p>The following attributes control the interpretation of
characters in the picture string supplied to the format-number
function. In each case the value must be a single character.</p>
<ul>
<li>
<p>[<a name="id-static-decimal-format-digit-sign" id=
"id-static-decimal-format-digit-sign" title=
"digit-sign">Definition</a>: <b>digit-sign</b> specifies the
character used for the digit-sign in the picture string; the
default value is the number sign character (#)]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-pattern-separator-sign" id=
"id-static-decimal-format-pattern-separator-sign" title=
"pattern-separator-sign">Definition</a>: <b>pattern-separator</b>
specifies the character used for the pattern-separator-symbol,
which separates positive and negative sub-pictures in a picture
string; the default value is the semi-colon character (;)]</p>
</li>
</ul>
<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>
<ul>
<li>
<p>[<a name="id-static-decimal-format-infinity" id=
"id-static-decimal-format-infinity" title=
"infinity">Definition</a>: <b>infinity</b> specifies the string
used for the infinity-symbol; the default value is the string
"Infinity"]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-NaN" id=
"id-static-decimal-format-NaN" title="NaN">Definition</a>:
<b>NaN</b> specifies the string used for the NaN-symbol, which is
used to represent the value NaN (not-a-number); the default value
is the string "NaN"]</p>
</li>
<li>
<p>[<a name="id-static-decimal-format-minus-sign" id=
"id-static-decimal-format-minus-sign" title=
"minus-sign">Definition</a>: <b>minus-sign</b> specifies the
character used for the minus-sign-symbol; the default value is the
hyphen-minus character (-, #x2D). The value must be a single
character.]</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>2.1.2 Dynamic
Context</h4>
<p>[<a name="dt-dynamic-context" id="dt-dynamic-context" title=
"dynamic context">Definition</a>: The <b>dynamic context</b> of an
expression is defined as information that is available at the time
the expression is evaluated.] If evaluation of an expression relies
on some part of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> that is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>,
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
<p>The individual components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> are described below.
<span class="xpath">Further rules governing the semantics of these
components can be found in <a href=
"#id-xp-evaluation-context-components"><b>C.2 Dynamic Context
Components</b></a>.</span></p>
<p>The <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> consists of all the
components of the <a title="static context" href=
"#dt-static-context">static context</a>, and the additional
components listed below.</p>
<p>[<a name="dt-focus" id="dt-focus" title="focus">Definition</a>:
The first three components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (context item, context
position, and context size) are called the <b>focus</b> of the
expression. ] The focus enables the processor to keep track of
which items are being processed by the expression. If any component
in the focus is defined, all components of the focus are defined.
[<a name="dt-singleton-focus" id="dt-singleton-focus" title=
"singleton focus">Definition</a>: A <b>singleton focus</b> is a
focus that refers to a single item; in a singleton focus, context
item is set to the item, context position = 1 and context size =
1.]</p>
<p>Certain language constructs, notably the <a title=
"path expression" href="#dt-path-expression">path operator</a>
<code>E1/E2</code>, the <a title="path expression" href=
"#dt-path-expression">simple mapping operator</a>, and the
<a title="" href="#dt-predicate">predicate</a> <code>E1[E2]</code>,
create a new focus for the evaluation of a sub-expression. In these
constructs, <code>E2</code> is evaluated once for each item in the
sequence that results from evaluating <code>E1</code>. Each time
<code>E2</code> is evaluated, it is evaluated with a different
focus. The focus for evaluating <code>E2</code> is referred to
below as the <b>inner focus</b>, while the focus for evaluating
<code>E1</code> is referred to as the <b>outer focus</b>. The inner
focus exists only while <code>E2</code> is being evaluated. When
this evaluation is complete, evaluation of the containing
expression continues with its original focus unchanged.</p>
<ul>
<li>
<p>[<a name="dt-context-item" id="dt-context-item" title=
"context item">Definition</a>: The <b>context item</b> is the
<a title="item" href="#dt-item">item</a> currently being
processed.] [<a name="dt-context-node" id="dt-context-node" title=
"context node">Definition</a>: When the context item is a node, it
can also be referred to as the <b>context node</b>.] The context
item is returned by an expression consisting of a single dot
(<code>.</code>). When an expression <code>E1/E2</code> or
<code>E1[E2]</code> is evaluated, each item in the sequence
obtained by evaluating <code>E1</code> becomes the context item in
the inner focus for an evaluation of <code>E2</code>.</p>
<p>[<a name="dt-initial-context-item" id="dt-initial-context-item"
title="initial context item">Definition</a>: The <b>initial context
item</b> is a context item that an implementation can set before
processing a query begins. The query body and the prolog of every
module in a query share the same initial context item.]</p>
</li>
<li>
<p>[<a name="dt-context-position" id="dt-context-position" title=
"context position">Definition</a>: The <b>context position</b> is
the position of the context item within the sequence of items
currently being processed.] It changes whenever the context item
changes. When the focus is defined, the value of the context
position is an integer greater than zero. The context position is
returned by the expression <code>fn:position()</code>. When an
expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated,
the context position in the inner focus for an evaluation of
<code>E2</code> is the position of the context item in the sequence
obtained by evaluating <code>E1</code>. The position of the first
item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p>
</li>
<li>
<p>[<a name="dt-context-size" id="dt-context-size" title=
"context size">Definition</a>: The <b>context size</b> is the
number of items in the sequence of items currently being
processed.] Its value is always an integer greater than zero. The
context size is returned by the expression <code>fn:last()</code>.
When an expression <code>E1/E2</code> or <code>E1[E2]</code> is
evaluated, the context size in the inner focus for an evaluation of
<code>E2</code> is the number of items in the sequence obtained by
evaluating <code>E1</code>.</p>
</li>
<li>
<p>[<a name="dt-variable-values" id="dt-variable-values" title=
"variable values">Definition</a>: <b>Variable values</b>. This is a
mapping from <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> to value. It contains the
same <a title="expanded QName" href="#dt-expanded-qname">expanded
QNames</a> as the <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> in the <a title=
"static context" href="#dt-static-context">static context</a> for
the expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the variable
and the value is the dynamic value of the variable, which includes
its <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a>.]</p>
</li>
<li>
<p>[<a name="dt-named-functions" id="dt-named-functions" title=
"named functions">Definition</a>: <b>Named functions</b>. This is a
mapping from (expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.
] It supplies a function for each signature in <a title=
"statically known function signatures" href=
"#dt-known-func-signatures">statically known function
signatures</a> and may supply other functions (see <a href=
"#id-consistency-constraints"><b>2.2.4 Consistency
Constraints</b></a>). Named functions can include functions with
implementation-dependent implementations; these functions do not
have a static context or a dynamic context of their own.</p>
</li>
<li>
<p>[<a name="dt-date-time" id="dt-date-time" title=
"current dateTime">Definition</a>: <b>Current dateTime.</b> This
information represents an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xpath">an
expression</span>, and includes an explicit timezone. It can be
retrieved by the <code>fn:current-dateTime</code> function. If
invoked multiple times during the execution of <span class=
"xpath">an expression</span>, this function always returns the same
result.]</p>
</li>
<li>
<p>[<a name="dt-timezone" id="dt-timezone" title=
"implicit timezone">Definition</a>: <b>Implicit timezone.</b> This
is the timezone to be used when a date, time, or dateTime value
that does not have a timezone is used in a comparison or arithmetic
operation. The implicit timezone is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> for the range of valid values of a timezone.]</p>
</li>
<li>
<p>[<a name="dt-default-language" id="dt-default-language" title=
"default language">Definition</a>: <b>Default language.</b> This is
the natural language used when creating human-readable output (for
example, by the functions <code>fn:format-date</code> and
<code>fn:format-integer</code>) if no other language is requested.
The value is a language code as defined by the type
<code>xs:language</code>.]</p>
</li>
<li>
<p>[<a name="dt-default-calendar" id="dt-default-calendar" title=
"default calendar">Definition</a>: <b>Default calendar.</b> This is
the calendar used when formatting dates in human-readable output
(for example, by the functions <code>fn:format-date</code> and
<code>fn:format-dateTime</code>) if no other calendar is requested.
The value is a string.]</p>
</li>
<li>
<p>[<a name="dt-default-place" id="dt-default-place" title=
"default place">Definition</a>: <b>Default place.</b> This is a
geographical location used to identify the place where events
happened (or will happen) when formatting dates and times using
functions such as <code>fn:format-date</code> and
<code>fn:format-dateTime</code>, if no other place is specified. It
is used when translating timezone offsets to civil timezone names,
and when using calendars where the translation from ISO dates/times
to a local representation is dependent on geographical location.
Possible representations of this information are an ISO country
code or an Olson timezone name, but implementations are free to use
other representations from which the above information can be
derived.]</p>
</li>
<li>
<p>[<a name="dt-available-docs" id="dt-available-docs" title=
"available documents">Definition</a>: <b>Available documents.</b>
This is a mapping of strings to document nodes. Each string
represents the absolute URI of a resource. The document node is the
root of a tree that represents that resource using the <a title=
"data model" href="#dt-datamodel">data model</a>. The document node
is returned by the <code>fn:doc</code> function when applied to
that URI.] The set of available documents is not limited to the set
of <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, and it may be
empty.</p>
<p>If there are one or more URIs in <a title="available documents"
href="#dt-available-docs">available documents</a> that map to a
document node <code>D</code>, then the document-uri property of
<code>D</code> must either be absent, or must be one of these
URIs.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that given a document node <code>$N</code>, the
result of <code>fn:doc(fn:document-uri($N)) is $N</code> will
always be <code>true</code>, unless
<code>fn:document-uri($N)</code> is an empty sequence.</p>
</div>
</li>
<li>
<p>[<a name="dt-available-text-resources" id=
"dt-available-text-resources" title=
"available text resources">Definition</a>: <b>Available text
resources</b>. This is a mapping of strings to text resources. Each
string represents the absolute URI of a resource. The resource is
returned by the <code>fn:unparsed-text</code> function when applied
to that URI.] The set of available text resources is not limited to
the set of <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, and it may be
empty.</p>
</li>
<li>
<p>[<a name="dt-available-collections" id=
"dt-available-collections" title=
"available node collections">Definition</a>: <b>Available node
collections.</b> This is a mapping of strings to sequences of
nodes. Each string represents the absolute URI of a resource. The
sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument. ] The set of available node collections is not
limited to the set of <a title="statically known collections" href=
"#dt-known-collections">statically known collections</a>, and it
may be empty.</p>
<p>For every document node <code>D</code> that is in the target of
a mapping in <a title="available node collections" href=
"#dt-available-collections">available node collections</a>, or that
is the root of a tree containing such a node, the document-uri
property of <code>D</code> must either be absent, or must be a URI
<code>U</code> such that <a title="available documents" href=
"#dt-available-docs">available documents</a> contains a mapping
from <code>U</code> to <code>D</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that for any document node <code>$N</code> retrieved
using the <code>fn:collection</code> function, either directly or
by navigating to the root of a node that was returned, the result
of <code>fn:doc(fn:document-uri($N)) is $N</code> will always be
<code>true</code>, unless <code>fn:document-uri($N)</code> is an
empty sequence. This implies a requirement for the
<code>fn:doc</code> and <code>fn:collection</code> functions to be
consistent in their effect. If the implementation uses catalogs or
user-supplied URI resolvers to dereference URIs supplied to the
<code>fn:doc</code> function, the implementation of the
<code>fn:collection</code> function must take these mechanisms into
account. For example, an implementation might achieve this by
mapping the collection URI to a set of document URIs, which are
then resolved using the same catalog or URI resolver that is used
by the <code>fn:doc</code> function.</p>
</div>
</li>
<li>
<p>[<a name="dt-default-collection" id="dt-default-collection"
title="default node collection">Definition</a>: <b>Default node
collection.</b> This is the sequence of nodes that would result
from calling the <code>fn:collection</code> function with no
arguments.] The value of <b>default collection</b> may be
initialized by the implementation.</p>
</li>
<li>
<p>[<a name="dt-available-resource-collections" id=
"dt-available-resource-collections" title=
"available resource collections">Definition</a>: <b>Available
resource collections.</b> This is a mapping of strings to sequences
of URIs. The string represents the absolute URI of a resource which
can be interpreted as an aggregation of a number of individual
resources each of which has its own URI. The sequence of URIs
represents the result of the <code>fn:uri-collection</code>
function when that URI is supplied as the argument. ] There is no
implication that the URIs in this sequence can be successfully
dereferenced, or that the resources they refer to have any
particular media type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation <strong>may</strong> maintain some consistent
relationship between the available node collections and the
available resource collections, for example by ensuring that the
result of <code>fn:uri-collection(X)!fn:doc(.)</code> is the same
as the result of <code>fn:collection(X)</code>. However, this is
not required. The <code>fn:uri-collection</code> function is more
general than <code>fn:collection</code> in that it allows access to
resources other than XML documents; at the same time,
<code>fn:collection</code> allows access to nodes that might lack
individual URIs, for example nodes corresponding to XML fragments
stored in the rows of a relational database.</p>
</div>
</li>
<li>
<p>[<a name="dt-default-resource-collection" id=
"dt-default-resource-collection" title=
"default resource collection">Definition</a>: <b>Default resource
collection.</b> This is the sequence of URIs that would result from
calling the <code>fn:uri-collection</code> function with no
arguments.] The value of <b>default resource collection</b> may be
initialized by the implementation.</p>
</li>
<li>
<p>[<a name="dt-environment-variables" id=
"dt-environment-variables" title=
"environment variables">Definition</a>: <b>Environment
variables.</b> This is a mapping from names to values. Both the
names and the values are strings. The names are compared using an
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collation,
and are unique under this collation. The set of environment
variables is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> and
<strong>may</strong> be empty.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A possible implementation is to provide the set of POSIX
environment variables (or their equivalent on other operating
systems) appropriate to the process in which the <span class=
"xpath">expression is evaluated</span>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>2.2
Processing Model</h3>
<p>XPath 3.1 is defined in terms of the <a title="data model" href=
"#dt-datamodel">data model</a> and the <a title=
"expression context" href="#dt-expression-context">expression
context</a>.</p>
<img src="ProcMod-XPath.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>Figure 1 provides a schematic overview of the processing steps
that are discussed in detail below. Some of these steps are
completely outside the domain of XPath 3.1; in Figure 1, these are
depicted outside the line that represents the boundaries of the
language, an area labeled <b>external processing</b>. The external
processing domain includes generation of an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a> that represents the
data to be queried (see <a href=
"#id-data-model-generation"><b>2.2.1 Data Model
Generation</b></a>), schema import processing (see <a href=
"#id-schema-import-processing"><b>2.2.2 Schema Import
Processing</b></a>) and serialization. The area inside the
boundaries of the language is known as the <span class=
"xpath"><b>XPath processing domain</b></span> , which includes the
static analysis and dynamic evaluation phases (see <a href=
"#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>). Consistency constraints on the <span class=
"xpath">XPath</span> processing domain are defined in <a href=
"#id-consistency-constraints"><b>2.2.4 Consistency
Constraints</b></a>.</p>
<div class="div3">
<h4><a name="id-data-model-generation" id=
"id-data-model-generation"></a>2.2.1 Data Model Generation</h4>
<p>Before <span class="xpath">an expression</span> can be
processed, its input data must be represented as an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>.
This process occurs outside the domain of XPath 3.1, which is why
Figure 1 represents it in the external processing domain. Here are
some steps by which an XML document might be converted to an
<a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a>:</p>
<ol class="enumar">
<li>
<p>A document may be parsed using an XML parser that generates an
<b>XML Information Set</b> (see <a href="#XINFO">[XML
Infoset]</a>). The parsed document may then be validated against
one or more schemas. This process, which is described in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>, results in an abstract information structure
called the <b>Post-Schema Validation Infoset</b> (PSVI). If a
document has no associated schema, its Information Set is
preserved. (See DM1 in Fig. 1.)</p>
</li>
<li>
<p>The Information Set or PSVI may be transformed into an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> by a
process described in <a href="#xpath-datamodel-31">[XQuery and
XPath Data Model (XDM) 3.1]</a>. (See DM2 in Fig. 1.)</p>
</li>
</ol>
<p>The above steps provide an example of how an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>
might be constructed. An XDM instance might also be synthesized
directly from a relational database, or constructed in some other
way (see DM3 in Fig. 1.) XPath 3.1 is defined in terms of the
<a title="data model" href="#dt-datamodel">data model</a>, but it
does not place any constraints on how XDM instances are
constructed.</p>
<p>[<a name="dt-type-annotation" id="dt-type-annotation" title=
"type annotation">Definition</a>: Each element node and attribute
node in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> has a <b>type
annotation</b> (described in <a href="#xpath-datamodel-31">[XQuery
and XPath Data Model (XDM) 3.1]</a>). The type annotation of a node
is a reference to an XML Schema type. ] The <code>type-name</code>
of a node is the name of the type referenced by its <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>.
If the <a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a> was derived from a validated XML document as described
in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3
Construction from a PSVI</a> <sup><small>DM31</small></sup>, the
type annotations of the element and attribute nodes are derived
from schema validation. XPath 3.1 does not provide a way to
directly access the type annotation of an element or attribute
node.</p>
<p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as
might occur in a schemaless document) is given the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>.</p>
<p>The value of an element is represented by the children of the
element node, which may include text nodes and other element nodes.
The <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node indicates how the values in its
child text nodes are to be interpreted. An element that has not
been validated (such as might occur in a schemaless document) is
annotated with the schema type <code>xs:untyped</code>. An element
that has been validated and found to be partially valid is
annotated with the schema type <code>xs:anyType</code>. If an
element node is annotated as <code>xs:untyped</code>, all its
descendant element nodes are also annotated as
<code>xs:untyped</code>. However, if an element node is annotated
as <code>xs:anyType</code>, some of its descendant element nodes
may have a more specific <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</div>
<div class="div3">
<h4><a name="id-schema-import-processing" id=
"id-schema-import-processing"></a>2.2.2 Schema Import
Processing</h4>
<p class="xpath">The <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> in the <a title=
"static context" href="#dt-static-context">static context</a> are
provided by the host language (see step SI1 in Figure 1) and must
satisfy the consistency constraints defined in <a href=
"#id-consistency-constraints"><b>2.2.4 Consistency
Constraints</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-expression-processing" id=
"id-expression-processing"></a>2.2.3 Expression Processing</h4>
<p>XPath 3.1 defines two phases of processing called the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> and the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1).
During the static analysis phase, <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
During the dynamic evaluation phase, only <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a> or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
These kinds of errors are defined in <a href=
"#id-kinds-of-errors"><b>2.3.1 Kinds of Errors</b></a>.</p>
<p>Within each phase, an implementation is free to use any strategy
or algorithm whose result conforms to the specifications in this
document.</p>
<div class="div4">
<h5><a name="id-static-analysis" id=
"id-static-analysis"></a>2.2.3.1 Static Analysis Phase</h5>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: The <b>static analysis
phase</b> depends on the expression itself and on the <a title=
"static context" href="#dt-static-context">static context</a>. The
<b>static analysis phase</b> does not depend on input data (other
than schemas).]</p>
<p>During the static analysis phase, the <span class="xpath">XPath
expression</span> is parsed into an internal representation called
the <b>operation tree</b> (step SQ1 in Figure 1). A parse error is
raised as a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>]. The <a title="static context"
href="#dt-static-context">static context</a> is initialized by the
implementation (step SQ2). The <a title="static context" href=
"#dt-static-context">static context</a> is used to resolve schema
type names, function names, namespace prefixes, and variable names
(step SQ4). If a name of one of these kinds in the <b>operation
tree</b> is not found in the <a title="static context" href=
"#dt-static-context">static context</a>, a <a title="static error"
href="#dt-static-error">static error</a> ([<a href="#ERRXPST0008"
title="err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017"
title="err:XPST0017">err:XPST0017</a>]) is raised (however, see
exceptions to this rule in <a href="#id-element-test"><b>2.5.5.3
Element Test</b></a> and <a href="#id-attribute-test"><b>2.5.5.5
Attribute Test</b></a>.)</p>
<p>The <b>operation tree</b> is then <b>normalized</b> by making
explicit the implicit operations such as <a title="atomization"
href="#dt-atomization">atomization</a> and extraction of <a title=
"effective boolean value" href="#dt-ebv">Effective Boolean
Values</a> (step SQ5).</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, a processor may
perform type analysis. The effect of type analysis is to assign a
<a title="static type" href="#dt-static-type">static type</a> to
each expression in the operation tree. [<a name="dt-static-type"
id="dt-static-type" title="static type">Definition</a>: The
<b>static type</b> of an expression is the best inference that the
processor is able to make statically about the type of the result
of the expression.] This specification does not define the rules
for type analysis nor the static types that are assigned to
particular expressions: the only constraint is that the inferred
type must match all possible values that the expression is capable
of returning.</p>
<p>Examples of inferred static types might be:</p>
<ul>
<li>
<p>For the expression <code>concat(a,b)</code> the inferred static
type is <code>xs:string</code></p>
</li>
<li>
<p>For the expression <code>$a = $v</code> the inferred static type
is <code>xs:boolean</code></p>
</li>
<li>
<p>For the expression <code>$s[exp]</code> the inferred static type
has the same item type as the static type of <code>$s</code>, but a
cardinality that allows the empty sequence even if the static type
of <code>$s</code> does not allow an empty sequence.</p>
</li>
<li>
<p>The inferred static type of the expression <code>data($x)</code>
(whether written explicitly or inserted into the operation tree in
places where atomization is implicit) depends on the inferred
static type of <code>$x</code>: for example, if <code>$x</code> has
type <code>element(*, xs:integer)</code> then <code>data($x)</code>
has static type <code>xs:integer</code>.</p>
</li>
</ul>
<p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing
were published normatively in <a href="#xquery-semantics">[XQuery
1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were
allowed to refine these rules to infer a more precise type where
possible. In XQuery 3.0 and XPath 3.0, the rules for static type
inferencing are entirely implementation-defined.</p>
<p>Every kind of expression also imposes requirements on the type
of its operands. For example, with the expression
<code>substring($a, $b, $c)</code>, <code>$a</code> must be of type
<code>xs:string</code> (or something that can be converted to
<code>xs:string</code> by the function calling rules), while
<code>$b</code> and <code>$c</code> must be of type
<code>xs:double</code>.</p>
<p>If the Static Typing Feature is in effect, a processor must
raise a type error during static analysis if the inferred static
type of an expression is not subsumed by the required type of the
context where the expression is used. For example, the call of
substring above would cause a type error if the inferred static
type of <code>$a</code> is <code>xs:integer</code>; equally, a type
error would be reported during static analysis if the inferred
static type is <code>xs:anyAtomicType</code>.</p>
<p>If the Static Typing Feature is not in effect, a processor may
raise a type error during static analysis only if the inferred
static type of an expression has no overlap (intersection) with the
required type: so for the first argument of substring, the
processor may raise an error if the inferred type is
<code>xs:integer</code>, but not if it is
<code>xs:anyAtomicType</code>. Alternatively, if the Static Typing
Feature is not in effect, the processor may defer all type checking
until the dynamic evaluation phase.</p>
</div>
<div class="div4">
<h5><a name="id-dynamic-evaluation" id=
"id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase</h5>
<p>[<a name="dt-dynamic-evaluation" id="dt-dynamic-evaluation"
title="dynamic evaluation phase">Definition</a>: The <b>dynamic
evaluation phase</b> is the phase during which the value of an
expression is computed.] It occurs after completion of the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>.</p>
<p>The dynamic evaluation phase can occur only if no errors were
detected during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. If the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect, all <a title="type error" href="#dt-type-error">type
errors</a> are detected during static analysis and serve to inhibit
the dynamic evaluation phase.</p>
<p>The dynamic evaluation phase depends on the <b>operation
tree</b> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn
draws information from the external environment (step DQ3) and the
<a title="static context" href="#dt-static-context">static
context</a> (step DQ2). The dynamic evaluation phase may create new
data-model values (step DQ4) and it may extend the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
(step DQ5)—for example, by binding values to variables.</p>
<p>[<a name="dt-dynamic-type" id="dt-dynamic-type" title=
"dynamic type">Definition</a>: A <b>dynamic type</b> is associated
with each value as it is computed. The dynamic type of a value may
be more specific than the <a title="static type" href=
"#dt-static-type">static type</a> of the expression that computed
it (for example, the static type of an expression might be
<code>xs:integer*</code>, denoting a sequence of zero or more
integers, but at evaluation time its value may have the dynamic
type <code>xs:integer</code>, denoting exactly one integer.)]</p>
<p>If an operand of an expression is found to have a <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not
appropriate for that operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Even though static typing can catch many <a title="type error"
href="#dt-type-error">type errors</a> before an expression is
executed, it is possible for an expression to raise an error during
evaluation that was not detected by static analysis. For example,
an expression may contain a cast of a string into an integer, which
is statically valid. However, if the actual value of the string at
run time cannot be cast into an integer, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> will result. Similarly,
an expression may apply an arithmetic operator to a value whose
<a title="static type" href="#dt-static-type">static type</a> is
<code>xs:untypedAtomic</code>. This is not a <a title=
"static error" href="#dt-static-error">static error</a>, but at run
time, if the value cannot be successfully cast to a <a title=
"numeric" href="#dt-numeric">numeric</a> type, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> will be
raised.</p>
<p>When the <a title="static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect, it is also possible for static analysis of an expression to
raise a <a title="type error" href="#dt-type-error">type error</a>,
even though execution of the expression on certain inputs would be
successful. For example, an expression might contain a function
that requires an element as its parameter, and the static analysis
phase might infer the <a title="static type" href=
"#dt-static-type">static type</a> of the function parameter to be
an optional element. This case is treated as a <a title=
"type error" href="#dt-type-error">type error</a> and inhibits
evaluation, even though the function call would have been
successful for input data in which the optional element is
present.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-consistency-constraints" id=
"id-consistency-constraints"></a>2.2.4 Consistency Constraints</h4>
<p>In order for XPath 3.1 to be well defined, the input <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>, the
<a title="static context" href="#dt-static-context">static
context</a>, and the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> must be mutually
consistent. The consistency constraints listed below are
prerequisites for correct functioning of an XPath 3.1
implementation. Enforcement of these consistency constraints is
beyond the scope of this specification. This specification does not
define the result of <span class="xpath">an expression</span> under
any condition in which one or more of these constraints is not
satisfied.</p>
<ul>
<li>
<p>For every node that has a type annotation, if that type
annotation is found in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a> (ISSD), then its
definition in the ISSD must be equivalent to its definition in the
type annotation.</p>
</li>
<li>
<p>Every element name, attribute name, or schema type name
referenced in <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> or <a title=
"statically known function signatures" href=
"#dt-known-func-signatures">statically known function
signatures</a> must be in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, unless it is an element name referenced as part of
an <a href="#doc-xpath31-ElementTest">ElementTest</a> or an
attribute name referenced as part of an <a href=
"#doc-xpath31-AttributeTest">AttributeTest</a>.</p>
</li>
<li>
<p>Any reference to a global element, attribute, or type name in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> must have a corresponding element, attribute
or type definition in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a>.</p>
</li>
<li>
<p>For each mapping of a string to a document node in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, if there exists a mapping of the same string to a
document type in <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, the document node
must match the document type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>For each mapping of a string to a sequence of nodes in <a title=
"available node collections" href=
"#dt-available-collections">available node collections</a>, if
there exists a mapping of the same string to a type in <a title=
"statically known collections" href=
"#dt-known-collections">statically known collections</a>, the
sequence of nodes must match the type, using the matching rules in
<a href="#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The sequence of nodes in the <a title="default node collection"
href="#dt-default-collection">default collection</a> must match the
<a title="statically known default collection type" href=
"#dt-known-default-collection">statically known default collection
type</a>, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The value of the <a title="context item" href=
"#dt-context-item">context item</a> must match the <a title=
"context item static type" href=
"#dt-context-item-static-type">context item static type</a>, using
the matching rules in <a href="#id-sequencetype-matching"><b>2.5.5
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each (variable, type) pair in <a title="in-scope variables"
href="#dt-in-scope-variables">in-scope variables</a> and the
corresponding (variable, value) pair in <a title="variable values"
href="#dt-variable-values">variable values</a> such that the
variable names are equal, the value must match the type, using the
matching rules in <a href="#id-sequencetype-matching"><b>2.5.5
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>In the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, the prefix
<code>xml</code> must not be bound to any namespace URI other than
<code>http://www.w3.org/XML/1998/namespace</code>, and no prefix
other than <code>xml</code> may be bound to this namespace URI. The
prefix <code>xmlns</code> must not be bound to any namespace URI,
and no prefix may be bound to the namespace URI
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
<li>
<p>For each <code>(expanded QName, arity) -&gt; FunctionTest</code>
entry in <a title="statically known function signatures" href=
"#dt-known-func-signatures">statically known function
signatures</a>, there must exist an <code>(expanded QName, arity)
-&gt; function</code> entry in <a title="named functions" href=
"#dt-named-functions">named functions</a> such that the function's
<a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-signature">signature</a><sup><small>DM31</small></sup>
is <code>FunctionTest</code>.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.3 Error Handling</h3>
<div class="div3">
<h4><a name="id-kinds-of-errors" id="id-kinds-of-errors"></a>2.3.1
Kinds of Errors</h4>
<p>As described in <a href="#id-expression-processing"><b>2.2.3
Expression Processing</b></a>, XPath 3.1 defines a <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>, which does not depend on input data, and a <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, which does depend on input data. Errors may
be raised during each phase.</p>
<p>[<a name="dt-static-error" id="dt-static-error" title=
"static error">Definition</a>: An error that can be detected during
the static analysis phase, and is not a type error, is a <b>static
error</b>.] A syntax error is an example of a <a title=
"static error" href="#dt-static-error">static error</a>.</p>
<p>[<a name="dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error">Definition</a>: A <b>dynamic error</b> is an error
that must be detected during the dynamic evaluation phase and may
be detected during the static analysis phase. Numeric overflow is
an example of a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> . ]</p>
<p>[<a name="dt-type-error" id="dt-type-error" title=
"type error">Definition</a>: A <b>type error</b> may be raised
during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"static type" href="#dt-static-type">static type</a> of an
expression does not match the expected type of the context in which
the expression occurs. During the dynamic evaluation phase, a
<a title="type error" href="#dt-type-error">type error</a> occurs
when the <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> of a value does not match the expected type of the context
in which the value occurs.]</p>
<p>The outcome of the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a> is either success
or one or more <a title="type error" href="#dt-type-error">type
errors</a>, <a title="static error" href="#dt-static-error">static
errors</a>, or statically-detected <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a>. The result of the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a> is either a result value, a <a title=
"type error" href="#dt-type-error">type error</a>, or a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>If more than one error is present, or if an error condition
comes within the scope of more than one error defined in this
specification, then any non-empty subset of these errors may be
reported.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect and the <a title="static type" href="#dt-static-type">static
type</a> assigned to an expression other than <code>()</code> or
<code>data(())</code> is <code>empty-sequence()</code>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0005" title="err:XPST0005">err:XPST0005</a>].
This catches cases in which a query refers to an element or
attribute that is not present in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, possibly because of a spelling error.</p>
<p>Independently of whether the <a title="static typing feature"
href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is
in effect, if an implementation can determine during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> that <span class="xpath">an XPath expression</span>, if
evaluated, would necessarily raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> or that an expression, if
evaluated, would necessarily raise a <a title="type error" href=
"#dt-type-error">type error</a>, the implementation may (but is not
required to) report that error during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>.</p>
<p>An implementation can raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> for a <span class="xpath">an
XPath expression</span> statically only if the query can never
execute without raising that error, as in the following
example:</p>
<div class="exampleInner">
<pre>
error()
</pre></div>
<p>The following example contains a type error, which can be
reported statically even if the implementation can not prove that
the expression will actually be evaluated.</p>
<div class="exampleInner">
<pre>
if (empty($arg))
then
  "cat" * 2
else
  0
</pre></div>
<p>[<a name="dt-warning" id="dt-warning" title=
"warning">Definition</a>: In addition to <a title="static error"
href="#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XPath 3.1
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.]</p>
<p>In addition to the errors defined in this specification, an
implementation may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> for a reason beyond the scope
of this specification. For example, limitations may exist on the
maximum numbers or sizes of various objects. <span>An error must be
raised if such a limitation is exceeded [<a href="#ERRXPDY0130"
title="err:XPDY0130">err:XPDY0130</a>].</span></p>
</div>
<div class="div3">
<h4><a name="id-identifying-errors" id=
"id-identifying-errors"></a>2.3.2 Identifying and Reporting
Errors</h4>
<p>The errors defined in this specification are identified by
QNames that have the form <code>err:XPYYnnnn</code>, where:</p>
<ul>
<li>
<p><code>err</code> denotes the namespace for XPath and XQuery
errors, <code>http://www.w3.org/2005/xqt-errors</code>. This
binding of the namespace prefix <code>err</code> is used for
convenience in this document, and is not normative.</p>
</li>
<li>
<p><code>XP</code> identifies the error as an XPath error (some
errors, originally defined by XQuery and later added to XPath, use
the code <code>XQ</code> instead).</p>
</li>
<li>
<p><code>YY</code> denotes the error category, using the following
encoding:</p>
<ul>
<li>
<p><code>ST</code> denotes a static error.</p>
</li>
<li>
<p><code>DY</code> denotes a dynamic error.</p>
</li>
<li>
<p><code>TY</code> denotes a type error.</p>
</li>
</ul>
</li>
<li>
<p><code>nnnn</code> is a unique numeric code.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The namespace URI for XPath and XQuery errors is not expected to
change from one version of <span class="xpath">XPath</span> to
another. However, the contents of this namespace may be extended to
include additional error definitions.</p>
</div>
<p>The method by which an XPath 3.1 processor reports error
information to the external environment is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>An error can be represented by a URI reference that is derived
from the error QName as follows: an error with namespace URI
<em><code>NS</code></em> and local part <em><code>LP</code></em>
can be represented as the URI reference <em><code>NS</code></em>
<code>#</code> <em><code>LP</code></em> . For example, an error
whose QName is <code>err:XPST0017</code> could be represented as
<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Along with a code identifying an error, implementations may wish
to return additional information, such as the location of the error
or the processing phase in which it was detected. If an
implementation chooses to do so, then the mechanism that it uses to
return this information is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-handling-dynamic" id=
"id-handling-dynamic"></a>2.3.3 Handling Dynamic Errors</h4>
<p>Except as noted in this document, if any operand of an
expression raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>, the expression also raises a
<a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>. If an expression can validly return a value or raise a
dynamic error, the implementation may choose to return the value or
raise the dynamic error (see <a href="#id-errors-and-opt"><b>2.3.4
Errors and Optimization</b></a>). For example, the logical
expression <code>expr1 and expr2</code> may return the value
<code>false</code> if either operand returns <code>false</code>, or
may raise a dynamic error if either operand raises a dynamic
error.</p>
<p>If more than one operand of an expression raises an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:</p>
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
<p>both the sub-expressions <code>($x div $y)</code> and
<code>xs:decimal($z)</code> may raise an error. The implementation
may choose which error is raised by the "<code>+</code>"
expression. Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>
<p>[<a name="dt-error-value" id="dt-error-value" title=
"error value">Definition</a>: In addition to its identifying QName,
a dynamic error may also carry a descriptive string and one or more
additional values called <b>error values</b>.] An implementation
may provide a mechanism whereby an application-defined error
handler can process error values and produce diagnostic messages.
<span>XQuery 3.1 provides standard error handling via <a href=
"http://www.w3.org/TR/xquery-31/#id-try-catch">Section 3.16
Try/Catch Expressions</a> <sup><small>XQ31</small></sup></span>
.</p>
<p>A dynamic error may be raised by a <a title="built-in function"
href="#dt-built-in-function">built-in function</a> or operator. For
example, the <code>div</code> operator raises an error if its
operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators
are defined in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>.</p>
<p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which always raises a dynamic error
and never returns a value. This function is defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>. For example, the following function call raises a dynamic
error, providing a QName that identifies the error, a descriptive
string, and a diagnostic value (assuming that the prefix
<code>app</code> is bound to a namespace containing
application-defined error codes):</p>
<div class="exampleInner">
<pre>
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</pre></div>
</div>
<div class="div3">
<h4><a name="id-errors-and-opt" id="id-errors-and-opt"></a>2.3.4
Errors and Optimization</h4>
<p>Because different implementations may choose to evaluate or
optimize an expression in different ways, certain aspects of
raising <a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a> are <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>, as
described in this section.</p>
<p>An implementation is always free to evaluate the operands of an
operator in any order.</p>
<p>In some cases, a processor can determine the result of an
expression without accessing all the data that would be implied by
the formal expression semantics. For example, the formal
description of <a title="filter expression" href=
"#dt-filter-expression">filter expressions</a> suggests that
<code>$s[1]</code> should be evaluated by examining all the items
in sequence <code>$s</code>, and selecting all those that satisfy
the predicate <code>position()=1</code>. In practice, many
implementations will recognize that they can evaluate this
expression by taking the first item in the sequence and then
exiting. If <code>$s</code> is defined by an expression such as
<code>//book[author eq 'Berners-Lee']</code>, then this strategy
may avoid a complete scan of a large document and may therefore
greatly improve performance. However, a consequence of this
strategy is that a dynamic error or type error that would be
detected if the expression semantics were followed literally might
not be detected at all if the evaluation exits early. In this
example, such an error might occur if there is a <code>book</code>
element in the input data with more than one <code>author</code>
subelement.</p>
<p>The extent to which a processor may optimize its access to data,
at the cost of not raising errors, is defined by the following
rules.</p>
<p>Consider an expression <em>Q</em> that has an operand
(sub-expression) <em>E</em>. In general the value of <em>E</em> is
a sequence. At an intermediate stage during evaluation of the
sequence, some of its items will be known and others will be
unknown. If, at such an intermediate stage of evaluation, a
processor is able to establish that there are only two possible
outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or
an error, then the processor may deliver the result <em>V</em>
without evaluating further items in the operand <em>E</em>. For
this purpose, two values are considered to represent the same
outcome if their items are pairwise the same, where nodes are the
same if they have the same identity, and values are the same if
they are equal and have exactly the same type.</p>
<p>There is an exception to this rule: If a processor evaluates an
operand <em>E</em> (wholly or in part), then it is required to
establish that the actual value of the operand <em>E</em> does not
violate any constraints on its cardinality. For example, the
expression <code>$e eq 0</code> results in a type error if the
value of <code>$e</code> contains two or more items. A processor is
not allowed to decide, after evaluating the first item in the value
of <code>$e</code> and finding it equal to zero, that the only
possible outcomes are the value <code>true</code> or a type error
caused by the cardinality violation. It must establish that the
value of <code>$e</code> contains no more than one item.</p>
<p>These rules apply to all the operands of an expression
considered in combination: thus if an expression has two operands
<em>E1</em> and <em>E2</em>, it may be evaluated using any samples
of the respective sequences that satisfy the above rules.</p>
<p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and
<em>B</em> is an operand of <em>C</em>, then the processor needs to
evaluate only a sufficient sample of <em>B</em> to determine the
value of <em>C</em>, and needs to evaluate only a sufficient sample
of <em>A</em> to determine this sample of <em>B</em>.</p>
<p>The effect of these rules is that the processor is free to stop
examining further items in a sequence as soon as it can establish
that further items would not affect the result except possibly by
causing an error. For example, the processor may return
<code>true</code> as the result of the expression <code>S1 =
S2</code> as soon as it finds a pair of equal values from the two
sequences.</p>
<p>Another consequence of these rules is that where none of the
items in a sequence contributes to the result of an expression, the
processor is not obliged to evaluate any part of the sequence.
Again, however, the processor cannot dispense with a required
cardinality check: if an empty sequence is not permitted in the
relevant context, then the processor must ensure that the operand
is not an empty sequence.</p>
<p>Examples:</p>
<ul>
<li>
<p>If an implementation can find (for example, by using an index)
that at least one item returned by <code>$expr1</code> in the
following example has the value <code>47</code>, it is allowed to
return <code>true</code> as the result of the <code>some</code>
expression, without searching for another item returned by
<code>$expr1</code> that would raise an error if it were
evaluated.</p>
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</li>
<li>
<p>In the following example, if an implementation can find (for
example, by using an index) the <code>product</code> element-nodes
that have an <code>id</code> child with the value <code>47</code>,
it is allowed to return these nodes as the result of the <a title=
"path expression" href="#dt-path-expression">path expression</a>,
without searching for another <code>product</code> node that would
raise an error because it has an <code>id</code> child whose value
is not an integer.</p>
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</li>
</ul>
<p>For a variety of reasons, including optimization,
implementations may rewrite expressions into a different form.
There are a number of rules that limit the extent of this
freedom:</p>
<ul>
<li>
<p>Other than the raising or not raising of errors, the result of
evaluating a rewritten expression must conform to the semantics
defined in this specification for the original expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This allows an implementation to return a result in cases where
the original expression would have raised an error, or to raise an
error in cases where the original expression would have returned a
result. The main cases where this is likely to arise in practice
are (a) where a rewrite changes the order of evaluation, such that
a subexpression causing an error is evaluated when the expression
is written one way and is not evaluated when the expression is
written a different way, and (b) where intermediate results of the
evaluation cause overflow or other out-of-range conditions.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule does not mean that the result of the expression will
always be the same in non-error cases as if it had not been
rewritten, because there are many cases where the result of an
expression is to some degree <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> or
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</li>
<li>
<p>Conditional and typeswitch expressions must not raise a dynamic
error in respect of subexpressions occurring in a branch that is
not selected, and must not return the value delivered by a branch
unless that branch is selected. Thus, the following example must
not raise a dynamic error if the document <code>abc.xml</code> does
not exist:</p>
<div class="exampleInner">
<pre>
if (doc-available('abc.xml')) then doc('abc.xml') else ()
</pre></div>
</li>
<li>
<p>As stated earlier, an expression must not be rewritten to
dispense with a required cardinality check: for example,
<code>string-length(//title)</code> must raise an error if the
document contains more than one title element.</p>
</li>
<li>
<p>Expressions must not be rewritten in such a way as to create or
remove static errors. The static errors in this specification are
defined for the original expression, and must be preserved if the
expression is rewritten.</p>
</li>
</ul>
<p>Expression rewrite is illustrated by the following examples.</p>
<ul>
<li>
<p>Consider the expression <code>//part[color eq "Red"]</code>. An
implementation might choose to rewrite this expression as
<code>//part[color = "Red"][color eq "Red"]</code>. The
implementation might then process the expression as follows: First
process the "<code>=</code>" predicate by probing an index on parts
by color to quickly find all the parts that have a Red color; then
process the "<code>eq</code>" predicate by checking each of these
parts to make sure it has only a single color. The result would be
as follows:</p>
<ul>
<li>
<p>Parts that have exactly one color that is Red are returned.</p>
</li>
<li>
<p>If some part has color Red together with some other color, an
error is raised.</p>
</li>
<li>
<p>The existence of some part that has no color Red but has
multiple non-Red colors does not trigger an error.</p>
</li>
</ul>
</li>
<li>
<p>The expression in the following example cannot raise a casting
error if it is evaluated exactly as written (i.e., left to right).
Since neither predicate depends on the context position, an
implementation might choose to reorder the predicates to achieve
better performance (for example, by taking advantage of an index).
This reordering could cause the expression to raise an error.</p>
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
<p>To avoid unexpected errors caused by expression rewrite, tests
that are designed to prevent dynamic errors should be expressed
using conditional expressions. For example, the above expression
can be written as follows:</p>
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>2.4 Concepts</h3>
<p>This section explains some concepts that are important to the
processing of XPath 3.1 expressions.</p>
<div class="div3">
<h4><a name="id-document-order" id="id-document-order"></a>2.4.1
Document Order</h4>
<p>An ordering called <b>document order</b> is defined among all
the nodes accessible during processing of a given <span class=
"xpath">expression</span>, which may consist of one or more
<b>trees</b> (documents or fragments). Document order is defined in
<a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM)
3.1]</a>, and its definition is repeated here for convenience.
Document order is a total ordering, although the relative order of
some nodes is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.
[<a name="dt-document-order" id="dt-document-order" title=
"document order">Definition</a>: Informally, <b>document order</b>
is the order in which nodes appear in the XML serialization of a
document.] [<a name="stable" id="stable" title=
"stable">Definition</a>: Document order is <b>stable</b>, which
means that the relative order of two nodes will not change during
the processing of a given <span class="xpath">expression</span>,
even if this order is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.]
[<a name="dt-reverse-document-order" id="dt-reverse-document-order"
title="reverse document order">Definition</a>: The node ordering
that is the reverse of document order is called <b>reverse document
order</b>.]</p>
<p>Within a tree, document order satisfies the following
constraints:</p>
<ol class="enumar">
<li>
<p>The root node is the first node.</p>
</li>
<li>
<p>Every node occurs before all of its children and
descendants.</p>
</li>
<li>
<p>Namespace nodes immediately follow the element node with which
they are associated. The relative order of namespace nodes is
stable but <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Attribute nodes immediately follow the <span class=
"xpath">namespace nodes of the</span> element node with which they
are associated. The relative order of attribute nodes is stable but
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p>
</li>
<li>
<p>Children and descendants occur before following siblings.</p>
</li>
</ol>
<p>The relative order of nodes in distinct trees is stable but
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>,
subject to the following constraint: If any node in a given tree T1
is before any node in a different tree T2, then all nodes in tree
T1 are before all nodes in tree T2.</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>2.4.2
Atomization</h4>
<p>The semantics of some XPath 3.1 operators depend on a process
called <a title="atomization" href=
"#dt-atomization">atomization</a>. Atomization is applied to a
value when the value is used in a context in which a sequence of
atomic values is required. The result of atomization is either a
sequence of atomic values or a <a title="type error" href=
"#dt-type-error">type error</a> [err:FOTY0012]. [<a name=
"dt-atomization" id="dt-atomization" title=
"atomization">Definition</a>: <b>Atomization</b> of a sequence is
defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.]</p>
<p>The semantics of <code>fn:data</code> are repeated here for
convenience. The result of <code>fn:data</code> is the sequence of
atomic values produced by applying the following rules to each item
in the input sequence:</p>
<ul>
<li>
<p>If the item is an atomic value, it is returned.</p>
</li>
<li>
<p>If the item is a node, its <a title="typed value" href=
"#dt-typed-value">typed value</a> is returned (<span>a <a title=
"type error" href="#dt-type-error">type error</a></span>
[err:FOTY0012] is raised if the node has no typed value.)</p>
</li>
<li>
<p>If the item is a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
<span>or map a <a title="type error" href="#dt-type-error">type
error</a></span> [err:FOTY0012] is raised.</p>
</li>
<li>
<p>If the item is an array <code>$a</code>, atomization is defined
as <code>seq($a) ! fn:data(.)</code>, which is equivalent to
atomizing the members of the array.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This definition recursively atomizes members that are arrays.
Hence, the result of atomizing the array <code>[ [1, 2, 3], [4, 5,
6] ]</code> is the sequence <code>(1, 2, 3, 4, 5, 6)</code>.</p>
</div>
</li>
</ul>
<p>Atomization is used in processing the following types of
expressions:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Comparison expressions</p>
</li>
<li>
<p>Function calls and returns</p>
</li>
<li>
<p>Cast expressions</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>2.4.3 Effective Boolean
Value</h4>
<p>Under certain circumstances (listed below), it is necessary to
find the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of a value. [<a name="dt-ebv"
id="dt-ebv" title="effective boolean value">Definition</a>: The
<b>effective boolean value</b> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>.]</p>
<p>The dynamic semantics of <code>fn:boolean</code> are repeated
here for convenience:</p>
<ol class="enumar">
<li>
<p>If its operand is an empty sequence, <code>fn:boolean</code>
returns <code>false</code>.</p>
</li>
<li>
<p>If its operand is a sequence whose first item is a node,
<code>fn:boolean</code> returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:boolean</code>
or derived from <code>xs:boolean</code>, <code>fn:boolean</code>
returns the value of its operand unchanged.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:string</code>,
<code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type
derived from one of these, <code>fn:boolean</code> returns
<code>false</code> if the operand value has zero length; otherwise
it returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of any <a title="numeric" href=
"#dt-numeric">numeric</a> type or derived from a numeric type,
<code>fn:boolean</code> returns <code>false</code> if the operand
value is <code>NaN</code> or is numerically equal to zero;
otherwise it returns <code>true</code>.</p>
</li>
<li>
<p>In all other cases, <code>fn:boolean</code> raises a type error
[err:FORG0006].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For instance, <code>fn:boolean</code> raises a type error if the
operand is a function, a map, or an array.</p>
</div>
</li>
</ol>
<p>The <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of a sequence is computed implicitly during
processing of the following types of expressions:</p>
<ul>
<li>
<p>Logical expressions (<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p>The <code>fn:not</code> function</p>
</li>
<li>
<p>Certain types of <a title="" href=
"#dt-predicate">predicates</a>, such as <code>a[b]</code></p>
</li>
<li>
<p>Conditional expressions (<code>if</code>)</p>
</li>
<li>
<p>Quantified expressions (<code>some</code>,
<code>every</code>)</p>
</li>
<li>
<p>General comparisons, in <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The definition of <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> is <em>not</em> used when
casting a value to the type <code>xs:boolean</code>, for example in
a <code>cast</code> expression or when passing a value to a
function whose expected parameter is of type
<code>xs:boolean</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>2.4.4
Input Sources</h4>
<p>XPath 3.1 has a set of functions that provide access to input
data. These functions are of particular importance because they
provide a way in which an expression can reference a document or a
collection of documents. The input functions are described
informally here; they are defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
<p>An expression can access input data either by calling one of the
input functions or by referencing some part of the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
that is initialized by the external environment, such as a
<a title="variable values" href="#dt-variable-values">variable</a>
or <a title="context item" href="#dt-context-item">context
item</a>.</p>
<p>The input functions supported by XPath 3.1 are as follows:</p>
<ul>
<li>
<p>The <code>fn:doc</code> function takes a string containing a
URI. If that URI is associated with a document in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, <code>fn:doc</code> returns a document node whose
content is the <a title="data model" href="#dt-datamodel">data
model</a> representation of the given document; otherwise it raises
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>.</p>
</li>
<li>
<p>The <code>fn:unparsed-text</code> function takes a string
containing a URI, which must identify a resource that can be read
as text; otherwise it raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</li>
<li>
<p>The <code>fn:environment-variable</code> and
<code>fn:available-environment-variables</code> identify
environment variables that are available in the dynamic
context.</p>
</li>
<li>
<p>The <code>fn:collection</code> function with one argument takes
a string containing a URI. If that URI is associated with a
collection in <a title="available node collections" href=
"#dt-available-collections">available node collections</a>,
<code>fn:collection</code> returns the data model representation of
that collection; otherwise it raises a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>. A collection may be any
sequence of nodes. For example, the expression
<code>fn:collection("http://example.org")//customer</code>
identifies all the <code>customer</code> elements that are
descendants of nodes found in the collection whose URI is
<code>http://example.org</code>.</p>
</li>
<li>
<p>The <code>fn:collection</code> function with zero arguments
returns the <a title="default node collection" href=
"#dt-default-collection">default collection</a>, an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
sequence of nodes.</p>
</li>
<li>
<p>The <code>fn:uri-collection</code> function returns a sequence
of <code>xs:anyURI</code> values representing the URIs in a
resource collection.</p>
</li>
<li>
<p>The <code>fn:uri-collection</code> function with zero arguments
returns the URIs in the <a title="default resource collection"
href="#dt-default-resource-collection">default resource
collection</a>.</p>
</li>
</ul>
<p>These input functions are all specified in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>, which specifies error conditions and other details not
described here.</p>
</div>
<div class="div3">
<h4><a name="id-uri-literals" id="id-uri-literals"></a>2.4.5 URI
Literals</h4>
<p>XPath 3.1 requires a statically known, valid URI in a <a href=
"#doc-xpath31-BracedURILiteral">BracedURILiteral</a>. An
implementation may raise a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXQST0046" title=
"err:XQST0046">err:XQST0046</a>] if the value of a Braced URI
Literal is of nonzero length and is neither an absolute URI nor a
relative URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>xs:anyURI</code> type is designed to anticipate the
introduction of Internationalized Resource Identifiers (IRI's) as
defined in <a href="#RFC3987">[RFC3987]</a>.</p>
</div>
<p>Whitespace is normalized using the whitespace normalization
rules of <code>fn:normalize-space</code>. If the result of
whitespace normalization contains only whitespace, the
corresponding URI consists of the empty string.</p>
<p>A Braced URI Literal or URI Literal is not subjected to
percent-encoding or decoding as defined in <a href=
"#RFC3986">[RFC3986]</a>.</p>
</div>
<div class="div3">
<h4><a name="id-resolve-relative-uri" id=
"id-resolve-relative-uri"></a>2.4.6 Resolving a Relative URI
Reference</h4>
<p>[<a name="dt-resolve-relative-uri" id="dt-resolve-relative-uri"
title="resolve">Definition</a>: To <b>resolve a relative URI</b>
<code>$rel</code> against a base URI <code>$base</code> is to
expand it to an absolute URI, as if by calling the function
<code>fn:resolve-uri($rel, $base)</code>.] During static analysis,
the base URI is the Static Base URI. During dynamic evaluation, the
base URI used to resolve a relative URI reference depends on the
semantics of the expression.</p>
<p>Any process that attempts to <a title="resolve" href=
"#dt-resolve-relative-uri">resolve URI</a> against a base URI, or
to dereference the URI, may apply percent-encoding or decoding as
defined in the relevant RFCs.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-types" id="id-types"></a>2.5 Types</h3>
<p>The type system of XPath 3.1 is based on <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>.</p>
<p>[<a name="dt-sequence-type" id="dt-sequence-type" title=
"sequence type">Definition</a>: A <b>sequence type</b> is a type
that can be expressed using the <a href=
"#doc-xpath31-SequenceType">SequenceType</a> syntax. Sequence types
are used whenever it is necessary to refer to a type in an XPath
3.1 expression. The term <b>sequence type</b> suggests that this
syntax is used to describe the type of an XPath 3.1 value, which is
always a sequence.]</p>
<p>[<a name="dt-schema-type" id="dt-schema-type" title=
"schema type">Definition</a>: A <b>schema type</b> is a type that
is (or could be) defined using the facilities of <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> (including the built-in types of <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>).] A schema type can be used as a type annotation
on an element or attribute node (unless it is a non-instantiable
type such as <code>xs:NOTATION</code> or
<code>xs:anyAtomicType</code>, in which case its derived types can
be so used). Every schema type is either a <b>complex type</b> or a
<b>simple type</b>; simple types are further subdivided into
<b>list types</b>, <b>union types</b>, and <b>atomic types</b> (see
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> for definitions and
explanations of these terms.)</p>
<p>[<a name="dt-generalized-atomic-type" id=
"dt-generalized-atomic-type" title=
"generalized atomic type">Definition</a>: A <b>generalized atomic
type</b> is a type which is either (a) an atomic type or (b) a
<a title="pure union type" href="#dt-pure-union-type">pure union
type</a> ].</p>
<p>[<a name="dt-pure-union-type" id="dt-pure-union-type" title=
"pure union type">Definition</a>: A <b>pure union type</b> is an
XML Schema union type that satisfies the following constraints: (1)
<code>{variety}</code> is <code>union</code>, (2) the
<code>{facets}</code> property is empty, (3) no type in the
transitive membership of the union type has <code>{variety}</code>
<code>list</code>, and (4) no type in the transitive membership of
the union type is a type with <code>{variety}</code>
<code>union</code> having a non-empty <code>{facets}</code>
property].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The definition of <a title="pure union type" href=
"#dt-pure-union-type">pure union type</a> excludes union types
derived by non-trivial restriction from other union types, as well
as union types that include list types in their membership. Pure
union types have the property that every instance of an atomic type
defined as one of the member types of the union is also a valid
instance of the union type.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The current (second) edition of XML Schema 1.0 contains an error
in respect of the substitutability of a union type by one of its
members: it fails to recognize that this is unsafe if the union is
derived by restriction from another union.</p>
<p>This problem is fixed in XSD 1.1, but the effect of the
resolution is that an atomic value labeled with an atomic type
cannot be treated as being substitutable for a union type without
explicit validation. This specification therefore allows union
types to be used as item types only if they are defined directly as
the union of a number of atomic types.</p>
</div>
<p><a title="generalized atomic type" href=
"#dt-generalized-atomic-type">Generalized atomic types</a>
represent the intersection between the categories of <a title=
"sequence type" href="#dt-sequence-type">sequence type</a> and
<a title="schema type" href="#dt-schema-type">schema type</a>. A
generalized atomic type, such as <code>xs:integer</code> or
<code>my:hatsize</code>, is both a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> and a <a title="schema type"
href="#dt-schema-type">schema type</a>.</p>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>2.5.1 Predefined Schema Types</h4>
<p class="xpath">The <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a> in the <a title=
"static context" href="#dt-static-context">static context</a> are
initialized with a set of predefined schema types that is
determined by the host language. This set may include some or all
of the schema types in the namespace
<code>http://www.w3.org/2001/XMLSchema</code>, represented in this
document by the namespace prefix <code>xs</code>. The schema types
in this namespace are defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> and
augmented by additional types defined in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>.
An implementation that has based its type system on <a href=
"#XMLSchema10">[XML Schema 1.0]</a> is not required to support the
<code>xs:dateTimeStamp</code> type.</p>
<p>The schema types defined in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>
are summarized below.</p>
<ol class="enumar">
<li>
<p>[<a name="dt-untyped" id="dt-untyped" title=
"xs:untyped">Definition</a>: <code>xs:untyped</code> is used as the
<a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node that has not been validated, or
has been validated in <code>skip</code> mode.] No predefined schema
types are derived from <code>xs:untyped</code>.</p>
</li>
<li>
<p>[<a name="dt-untypedAtomic" id="dt-untypedAtomic" title=
"xs:untypedAtomic">Definition</a>: <code>xs:untypedAtomic</code> is
an atomic type that is used to denote untyped atomic data, such as
text that has not been assigned a more specific type.] An attribute
that has been validated in <code>skip</code> mode is represented in
the <a title="data model" href="#dt-datamodel">data model</a> by an
attribute node with the <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>. No predefined schema types are
derived from <code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>[<a name="dt-dayTimeDuration" id="dt-dayTimeDuration" title=
"xs:dayTimeDuration">Definition</a>:
<code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.]</p>
</li>
<li>
<p>[<a name="dt-yearMonthDuration" id="dt-yearMonthDuration" title=
"xs:yearMonthDuration">Definition</a>:
<code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.]</p>
</li>
<li>
<p>[<a name="dt-anyAtomicType" id="dt-anyAtomicType" title=
"xs:anyAtomicType">Definition</a>: <code>xs:anyAtomicType</code> is
an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is <code>xs:anySimpleType</code>
from which all simple types, including atomic, list, and union
types, are derived. All primitive atomic types, such as
<code>xs:decimal</code> and <code>xs:string</code>, have
<code>xs:anyAtomicType</code> as their base type.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyAtomicType</code> will not appear as the type of an
actual value in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>.</p>
</div>
</li>
<li>
<p>[<a name="dt-xs-error" id="dt-xs-error" title=
"xs:error">Definition</a>: <code>xs:error</code> is a simple type
with no value space, defined in <a href="#XMLSchema11">[XML Schema
1.1]</a>. In implementations that support XML Schema 1.1, it can be
used in the <a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType
Syntax</b></a> to raise errors.]</p>
</li>
</ol>
<p>The relationships among the schema types in the <code>xs</code>
namespace are illustrated in Figure 2. A more complete description
of the XPath 3.1 type hierarchy can be found in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>Figure 2: Hierarchy of Schema Types used in XPath 3.1.</p>
</div>
<div class="div3">
<h4><a name="id-namespace-sensitive" id=
"id-namespace-sensitive"></a>2.5.2 Namespace-sensitive Types</h4>
<p>[<a name="dt-namespace-sensitive" id="dt-namespace-sensitive"
title="namespace-sensitive">Definition</a>: The
<b>namespace-sensitive</b> types are <code>xs:QName</code>,
<code>xs:NOTATION</code>, types derived by restriction from
<code>xs:QName</code> or <code>xs:NOTATION</code>, list types that
have a namespace-sensitive item type, and union types with a
namespace-sensitive type in their transitive membership.]</p>
<p>It is not possible to preserve the type of a <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> value without
also preserving the namespace binding that defines the meaning of
each namespace prefix used in the value. Therefore, XPath 3.1
defines some error conditions that occur only with <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> values. For
instance, casting to a <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a> type raises a
<a title="type error" href="#dt-type-error">type error</a>
<code>[err:FONS0004]</code> if the namespace bindings for the
result cannot be determined.</p>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>2.5.3 Typed
Value and String Value</h4>
<p>Every node has a <b>typed value</b> and a <b>string value</b>,
except for nodes whose value is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
[<a name="dt-typed-value" id="dt-typed-value" title=
"typed value">Definition</a>: The <b>typed value</b> of a node is a
sequence of atomic values and can be extracted by applying the
<code>fn:data</code> function to the node.] [<a name=
"dt-string-value" id="dt-string-value" title=
"string value">Definition</a>: The <b>string value</b> of a node is
a string and can be extracted by applying the
<code>fn:string</code> function to the node.] Definitions of
<code>fn:data</code> and <code>fn:string</code> can be found in
<a href="#xpath-functions-31">[XQuery and XPath Functions and
Operators 3.1]</a>.</p>
<p>An implementation may store both the <a title="typed value"
href="#dt-typed-value">typed value</a> and the <a title=
"string value" href="#dt-string-value">string value</a> of a node,
or it may store only one of these and derive the other as needed.
The string value of a node must be a valid lexical representation
of the typed value of the node, but the node is not required to
preserve the string representation from the original source
document. For example, if the typed value of a node is the
<code>xs:integer</code> value <code>30</code>, its string value
might be "<code>30</code>" or "<code>0030</code>".</p>
<p class="xpath">The <a title="typed value" href=
"#dt-typed-value">typed value</a>, <a title="string value" href=
"#dt-string-value">string value</a>, and <a title="type annotation"
href="#dt-type-annotation">type annotation</a> of a node are
closely related. If the node was created by mapping from an Infoset
or PSVI, the relationships among these properties are defined by
rules in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model
(XDM) 3.1]</a>.</p>
<p>As a convenience to the reader, the relationship between
<a title="typed value" href="#dt-typed-value">typed value</a> and
<a title="string value" href="#dt-string-value">string value</a>
for various kinds of nodes is summarized and illustrated by
examples below.</p>
<ol class="enumar">
<li>
<p>For text and document nodes, the typed value of the node is the
same as its string value, as an instance of the type
<code>xs:untypedAtomic</code>. The string value of a document node
is formed by concatenating the string values of all its descendant
text nodes, in <a title="document order" href=
"#dt-document-order">document order</a>.</p>
</li>
<li>
<p>The typed value of a comment<span class="xpath">,
namespace,</span> or processing instruction node is the same as its
string value. It is an instance of the type
<code>xs:string</code>.</p>
</li>
<li>
<p>The typed value of an attribute node with the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is
the same as its string value, as an instance of
<code>xs:untypedAtomic</code>. The typed value of an attribute node
with any other type annotation is derived from its string value and
type annotation using the lexical-to-value-space mapping defined in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a> Part 2 for the relevant
type.</p>
<p>Example: A1 is an attribute having string value
<code>"3.14E-2"</code> and type annotation <code>xs:double</code>.
The typed value of A1 is the <code>xs:double</code> value whose
lexical representation is <code>3.14E-2</code>.</p>
<p>Example: A2 is an attribute with type annotation
<code>xs:IDREFS</code>, which is a list datatype whose item type is
the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type
(such as <code>xs:IDREFS</code>), its typed value is treated as a
sequence of the <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> from
which it is derived (such as <code>xs:IDREF</code>).</p>
</li>
<li>
<p>For an element node, the relationship between typed value and
string value depends on the node's <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>, as follows:</p>
<ol class="enumla">
<li>
<p>If the type annotation is <code>xs:untyped</code> or
<code>xs:anySimpleType</code> or denotes a complex type with mixed
content (including <code>xs:anyType</code>), then the typed value
of the node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>. However, if the <code>nilled</code>
property of the node is <code>true</code>, then its typed value is
the empty sequence.</p>
<p>Example: E1 is an element node having type annotation
<code>xs:untyped</code> and string value "<code>1999-05-31</code>".
The typed value of E1 is "<code>1999-05-31</code>", as an instance
of <code>xs:untypedAtomic</code>.</p>
<p>Example: E2 is an element node with the type annotation
<code>formula</code>, which is a complex type with mixed content.
The content of E2 consists of the character "<code>H</code>", a
child element named <code>subscript</code> with string value
"<code>2</code>", and the character "<code>O</code>". The typed
value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If the type annotation denotes a simple type or a complex type
with simple content, then the typed value of the node is derived
from its string value and its type annotation in a way that is
consistent with schema validation. However, if the
<code>nilled</code> property of the node is <code>true</code>, then
its typed value is the empty sequence.</p>
<p>Example: E3 is an element node with the type annotation
<code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>.
The string value of E3 is "<code>74.95</code>". The typed value of
E3 is <code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p>
<p>Example: E4 is an element node with the type annotation
<code>hatsizelist</code>, which is a simple type derived from the
atomic type <code>hatsize</code>, which in turn is derived from
<code>xs:integer</code>. The string value of E4 is "<code>7 8
9</code>". The typed value of E4 is a sequence of three values
(<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p>
<p>Example: E5 is an element node with the type annotation
<code>my:integer-or-string</code> which is a union type with member
types <code>xs:integer</code> and <code>xs:string</code>. The
string value of E5 is "<code>47</code>". The typed value of E5 is
<code>47</code> as an <code>xs:integer</code>, since
<code>xs:integer</code> is the member type that validated the
content of E5. In general, when the type annotation of a node is a
union type, the typed value of the node will be an instance of one
of the member types of the union.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an implementation stores only the string value of a node, and
the type annotation of the node is a union type, the implementation
must be able to deliver the typed value of the node as an instance
of the appropriate member type.</p>
</div>
</li>
<li>
<p>If the type annotation denotes a complex type with empty
content, then the typed value of the node is the empty sequence and
its string value is the zero-length string.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with element-only
content, then the typed value of the node is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
The <code>fn:data</code> function raises a <a title="type error"
href="#dt-type-error">type error</a> <code>[err:FOTY0012]</code>
when applied to such a node. The string value of such a node is
equal to the concatenated string values of all its text node
descendants, in document order.</p>
<p>Example: E6 is an element node with the type annotation
<code>weather</code>, which is a complex type whose content type
specifies <code>element-only</code>. E6 has two child elements
named <code>temperature</code> and <code>precipitation</code>. The
typed value of E6 is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>,
and the <code>fn:data</code> function applied to E6 raises an
error.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-sequencetype-syntax" id=
"id-sequencetype-syntax"></a>2.5.4 SequenceType Syntax</h4>
<p>Whenever it is necessary to refer to a type in an XPath 3.1
expression, the <a href=
"#doc-xpath31-SequenceType">SequenceType</a> syntax is used.</p>
<h5><a name="d2e4430" id="d2e4430"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SequenceType" id=
"doc-xpath31-SequenceType"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xpath31-ItemType">ItemType</a> <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ItemType" id=
"doc-xpath31-ItemType"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#doc-xpath31-FunctionTest">FunctionTest</a> |
<a href="#doc-xpath31-MapTest">MapTest</a> | <a href=
"#doc-xpath31-ArrayTest">ArrayTest</a> | <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> | <a href=
"#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-OccurrenceIndicator" id=
"doc-xpath31-OccurrenceIndicator"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AtomicOrUnionType" id=
"doc-xpath31-AtomicOrUnionType"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-KindTest" id=
"doc-xpath31-KindTest"></a>[83]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xpath31-ElementTest">ElementTest</a><br />
| <a href="#doc-xpath31-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xpath31-PITest">PITest</a><br />
| <a href="#doc-xpath31-CommentTest">CommentTest</a><br />
| <a href="#doc-xpath31-TextTest">TextTest</a><br />
| <a href=
"#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#doc-xpath31-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-DocumentTest" id=
"doc-xpath31-DocumentTest"></a>[85]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xpath31-ElementTest">ElementTest</a> | <a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4379.doc-xpath31-ElementTest" id=
"noid_d3e4379.doc-xpath31-ElementTest"></a>[94]&#160;&#160;&#160;</td>
<td><code>ElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xpath31-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4380.doc-xpath31-SchemaElementTest" id=
"noid_d3e4380.doc-xpath31-SchemaElementTest"></a>[96]&#160;&#160;&#160;</td>
<td><code>SchemaElementTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xpath31-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4381.doc-xpath31-ElementDeclaration" id=
"noid_d3e4381.doc-xpath31-ElementDeclaration"></a>[97]&#160;&#160;&#160;</td>
<td><code>ElementDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4382.doc-xpath31-AttributeTest" id=
"noid_d3e4382.doc-xpath31-AttributeTest"></a>[90]&#160;&#160;&#160;</td>
<td><code>AttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xpath31-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4384.doc-xpath31-SchemaAttributeTest" id=
"noid_d3e4384.doc-xpath31-SchemaAttributeTest"></a>[92]&#160;&#160;&#160;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4385.doc-xpath31-AttributeDeclaration" id=
"noid_d3e4385.doc-xpath31-AttributeDeclaration"></a>[93]&#160;&#160;&#160;</td>
<td><code>AttributeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4386.doc-xpath31-ElementNameOrWildcard" id=
"noid_d3e4386.doc-xpath31-ElementNameOrWildcard"></a>[95]&#160;&#160;&#160;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ElementName" id=
"doc-xpath31-ElementName"></a>[99]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4388.doc-xpath31-AttribNameOrWildcard" id=
"noid_d3e4388.doc-xpath31-AttribNameOrWildcard"></a>[91]&#160;&#160;&#160;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AttributeName" id=
"doc-xpath31-AttributeName"></a>[98]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-TypeName" id=
"doc-xpath31-TypeName"></a>[101]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-PITest" id=
"doc-xpath31-PITest"></a>[89]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath31-NCName">NCName</a> | <a href=
"#doc-xpath31-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-CommentTest" id=
"doc-xpath31-CommentTest"></a>[87]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NamespaceNodeTest" id=
"doc-xpath31-NamespaceNodeTest"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-TextTest" id=
"doc-xpath31-TextTest"></a>[86]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AnyKindTest" id=
"doc-xpath31-AnyKindTest"></a>[84]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4397.doc-xpath31-FunctionTest" id=
"noid_d3e4397.doc-xpath31-FunctionTest"></a>[102]&#160;&#160;&#160;</td>
<td><code>FunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4398.doc-xpath31-AnyFunctionTest" id=
"noid_d3e4398.doc-xpath31-AnyFunctionTest"></a>[103]&#160;&#160;&#160;</td>
<td><code>AnyFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4399.doc-xpath31-TypedFunctionTest" id=
"noid_d3e4399.doc-xpath31-TypedFunctionTest"></a>[104]&#160;&#160;&#160;</td>
<td><code>TypedFunctionTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#doc-xpath31-SequenceType">SequenceType</a> ("," <a href=
"#doc-xpath31-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#doc-xpath31-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ParenthesizedItemType" id=
"doc-xpath31-ParenthesizedItemType"></a>[109]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xpath31-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4401.doc-xpath31-MapTest" id=
"noid_d3e4401.doc-xpath31-MapTest"></a>[105]&#160;&#160;&#160;</td>
<td><code>MapTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map" "(" ("*" | (<a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> "," <a href=
"#doc-xpath31-SequenceType">SequenceType</a>)) ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e4402.doc-xpath31-ArrayTest" id=
"noid_d3e4402.doc-xpath31-ArrayTest"></a>[106]&#160;&#160;&#160;</td>
<td><code>ArrayTest</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-WildcardArrayTest">WildcardArrayTest</a> | <a href=
"#doc-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
</tr>
</tbody>
</table>
<p>With the exception of the special type
<code>empty-sequence()</code>, a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> consists of an <b>item
type</b> that constrains the type of each item in the sequence, and
a <b>cardinality</b> that constrains the number of items in the
sequence. Apart from the item type <code>item()</code>, which
permits any kind of item, item types divide into <b>node types</b>
(such as <code>element()</code>), <b>generalized atomic types</b>
(such as <code>xs:integer</code>) and function types (such as
function() as item()*).</p>
<p><a title="lexical QName" href="#dt-qname">Lexical QNames</a>
appearing in a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> have their prefixes expanded
to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> and (where
applicable) the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. Equality
of QNames is defined by the <code>eq</code> operator.</p>
<p>Item types representing element and attribute nodes may specify
the required <a title="type annotation" href=
"#dt-type-annotation">type annotations</a> of those nodes, in the
form of a <a title="schema type" href="#dt-schema-type">schema
type</a>. Thus the item type <code>element(*, us:address)</code>
denotes any element node whose type annotation is (or is derived
from) the schema type named <code>us:address</code>.</p>
<p>The occurrence indicators '+', '*', and '?' bind to the last
<a href="#doc-xpath31-ItemType">ItemType</a> in the <a href=
"#doc-xpath31-SequenceType">SequenceType</a>, as described in
<a href=
"#parse-note-occurrence-indicators">occurrence-indicators</a>
constraint.</p>
<p>Here are some examples of <a title="sequence type" href=
"#dt-sequence-type">sequence types</a> that might be used in XPath
3.1:</p>
<ul>
<li>
<p><code>xs:date</code> refers to the built-in atomic schema type
named <code>xs:date</code></p>
</li>
<li>
<p><code>attribute()?</code> refers to an optional attribute
node</p>
</li>
<li>
<p><code>element()</code> refers to any element node</p>
</li>
<li>
<p><code>element(po:shipto, po:address)</code> refers to an element
node that has the name <code>po:shipto</code> and has the type
annotation <code>po:address</code> (or a schema type derived from
<code>po:address</code>)</p>
</li>
<li>
<p><code>element(*, po:address)</code> refers to an element node of
any name that has the type annotation <code>po:address</code> (or a
type derived from <code>po:address</code>)</p>
</li>
<li>
<p><code>element(customer)</code> refers to an element node named
<code>customer</code> with any type annotation</p>
</li>
<li>
<p><code>schema-element(customer)</code> refers to an element node
whose name is <code>customer</code> (or is in the substitution
group headed by <code>customer</code>) and whose type annotation
matches the schema type declared for a <code>customer</code>
element in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a></p>
</li>
<li>
<p><code>node()*</code> refers to a sequence of zero or more nodes
of any kind</p>
</li>
<li>
<p><code>item()+</code> refers to a sequence of one or more
<a title="item" href="#dt-item">items</a></p>
</li>
<li>
<p><code>function(*)</code> refers to any <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>,
regardless of arity or type</p>
</li>
<li>
<p><code>function(node()) as xs:string*</code> refers to a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
that takes a single argument whose value is a single node, and
returns a sequence of zero or more xs:string values</p>
</li>
<li>
<p><code>(function(node()) as xs:string)*</code> refers to a
sequence of zero or more <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup>,
each of which takes a single argument whose value is a single node,
and returns as its result a single xs:string value</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>2.5.5 SequenceType Matching</h4>
<p>[<a name="dt-sequencetype-matching" id=
"dt-sequencetype-matching" title=
"SequenceType matching">Definition</a>: <b>SequenceType
matching</b> compares the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a value with an expected
<a title="sequence type" href="#dt-sequence-type">sequence
type</a>. ] For example, an <code>instance of</code> expression
returns <code>true</code> if the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a given value matches a
given <a title="sequence type" href="#dt-sequence-type">sequence
type</a>, or <code>false</code> if it does not.</p>
<p>An XPath 3.1 implementation must be able to determine
relationships among the types in type annotations in an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> and
the types in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> (ISSD).</p>
<p>[<a name="dt-subtype-substitution" id="dt-subtype-substitution"
title="subtype substitution">Definition</a>: The use of a value
whose <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> is derived from an expected type is known as <b>subtype
substitution</b>.] Subtype substitution does not change the actual
type of a value. For example, if an <code>xs:integer</code> value
is used where an <code>xs:decimal</code> value is expected, the
value retains its type as <code>xs:integer</code>.</p>
<p>The definition of <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> relies on a
pseudo-function named <code>derives-from(</code> <em>AT</em>,
<em>ET</em> <code>)</code>, which takes an actual simple or complex
schema type <em>AT</em> and an expected simple or complex schema
type <em>ET</em>, and either returns a boolean value or raises a
<a title="type error" href="#dt-type-error">type error</a>
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
This function is defined as follows:</p>
<ul>
<li>
<p><code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> raises a type error [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>] if <em>ET</em> is not present in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> (ISSD).</p>
</li>
<li>
<p><code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> returns <code>true</code> if any of the following
conditions applies:</p>
<ul>
<li>
<p><em>AT</em> is <em>ET</em></p>
</li>
<li>
<p><em>ET</em> is the base type of <em>AT</em></p>
</li>
<li>
<p><em>ET</em> is a pure union type of which <em>AT</em> is a
member type</p>
</li>
<li>
<p>There is a type <em>MT</em> such that <code>derives-from(</code>
<em>AT</em>, <em>MT</em> <code>)</code> and
<code>derives-from(</code> <em>MT</em>, <em>ET</em>
<code>)</code></p>
</li>
</ul>
</li>
<li>
<p>Otherwise, <code>derives-from(</code> <em>AT</em>, <em>ET</em>
<code>)</code> returns <code>false</code></p>
</li>
</ul>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> are given
below, with examples (the examples are for purposes of
illustration, and do not cover all possible cases).</p>
<div class="div4">
<h5><a name="id-matching-value" id="id-matching-value"></a>2.5.5.1
Matching a SequenceType and a Value</h5>
<ul>
<li>
<p>The <a title="sequence type" href="#dt-sequence-type">sequence
type</a> <code>empty-sequence()</code> matches a value that is the
empty sequence.</p>
</li>
<li>
<p>An <a href="#doc-xpath31-ItemType">ItemType</a> with no <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> matches
any value that contains exactly one item if the <a href=
"#doc-xpath31-ItemType">ItemType</a> matches that item (see
<a href="#id-matching-item"><b>2.5.5.2 Matching an ItemType and an
Item</b></a>).</p>
</li>
<li>
<p>An <a href="#doc-xpath31-ItemType">ItemType</a> with an <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> matches
a value if the number of items in the value matches the <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> and the
<a href="#doc-xpath31-ItemType">ItemType</a> matches each of the
items in the value.</p>
</li>
</ul>
<p>An <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>
specifies the number of items in a sequence, as follows:</p>
<ul>
<li>
<p><code>?</code> matches zero or one items</p>
</li>
<li>
<p><code>*</code> matches zero or more items</p>
</li>
<li>
<p><code>+</code> matches one or more items</p>
</li>
</ul>
<p>As a consequence of these rules, any <a title="sequence type"
href="#dt-sequence-type">sequence type</a> whose <a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a> is
<code>*</code> or <code>?</code> matches a value that is an empty
sequence.</p>
</div>
<div class="div4">
<h5><a name="id-matching-item" id="id-matching-item"></a>2.5.5.2
Matching an ItemType and an Item</h5>
<ul>
<li>
<p>An <a href="#doc-xpath31-ItemType">ItemType</a> consisting
simply of an EQName is interpreted as an <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a>. The
expected type <em>AtomicOrUnionType</em> matches an atomic value
whose actual type is <em>AT</em> if <code>derives-from(</code>
<em>AT, AtomicOrUnionType</em> <code>)</code> is
<code>true</code>.</p>
<p>The name of an <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> has its
prefix expanded to a namespace URI by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. If the
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of an <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> is not
defined as a <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, a <a title="static error" href="#dt-static-error">static
error</a> is raised [<a href="#ERRXPST0051" title=
"err:XPST0051">err:XPST0051</a>].</p>
<p>Example: The <a href="#doc-xpath31-ItemType">ItemType</a>
<code>xs:decimal</code> matches any value of type
<code>xs:decimal</code>. It also matches any value of type
<code>shoesize</code>, if <code>shoesize</code> is an atomic type
derived by restriction from <code>xs:decimal</code>.</p>
<p>Example: Suppose <a href="#doc-xpath31-ItemType">ItemType</a>
<code>dress-size</code> is a union type that allows either
<code>xs:decimal</code> values for numeric sizes (e.g. 4, 6, 10,
12), or one of an enumerated set of <code>xs:strings</code> (e.g.
"small", "medium", "large"). The <a href=
"#doc-xpath31-ItemType">ItemType</a> <code>dress-size</code>
matches any of these values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names of non-atomic types such as <code>xs:IDREFS</code> are
not accepted in this context, but can often be replaced by a
<a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> with an
occurrence indicator, such as <code>xs:IDREF+</code>.</p>
</div>
</li>
<li>
<p><code>item()</code> matches any single <a title="item" href=
"#dt-item">item</a>.</p>
<p>Example: <code>item()</code> matches the atomic value
<code>1</code>, the element <code>&lt;a/&gt;</code>, or the
function <code>fn:concat#3</code>.</p>
</li>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>processing-instruction()</code> matches any
processing-instruction node.</p>
</li>
<li>
<p><code>processing-instruction(</code> <em>N</em> <code>)</code>
matches any processing-instruction node whose PITarget is equal to
<code>fn:normalize-space(N)</code>. If
<code>fn:normalize-space(N)</code> is not in the lexical space of
NCName, a type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]</p>
<p>Example: <code>processing-instruction(xml-stylesheet)</code>
matches any processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p>
<p>For backward compatibility with XPath 1.0, the PITarget of a
processing instruction may also be expressed as a string literal,
as in this example:
<code>processing-instruction("xml-stylesheet")</code>.</p>
<p>If the specified PITarget is not a syntactically valid NCName, a
type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(</code> <em>E</em> <code>)</code> matches
any document node that contains exactly one element node,
optionally accompanied by one or more comment and processing
instruction nodes, if <em>E</em> is an <a href=
"#doc-xpath31-ElementTest">ElementTest</a> or <a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a> that matches
the element node (see <a href="#id-element-test"><b>2.5.5.3 Element
Test</b></a> and <a href="#id-schema-element-test"><b>2.5.5.4
Schema Element Test</b></a>).</p>
<p>Example: <code>document-node(element(book))</code> matches a
document node containing exactly one element node that is matched
by the ElementTest <code>element(book)</code>.</p>
</li>
<li>
<p>A <a href=
"#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a>
matches an item if and only if the item matches the <a href=
"#doc-xpath31-ItemType">ItemType</a> that is in parentheses.</p>
</li>
<li>
<p>An <a href="#doc-xpath31-ItemType">ItemType</a> that is an
<a href="#doc-xpath31-ElementTest">ElementTest</a>, <a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a>, <a href=
"#doc-xpath31-AttributeTest">AttributeTest</a>, <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>, or
<a href="#doc-xpath31-FunctionTest">FunctionTest</a> matches an
item as described in the following sections.</p>
</li>
<li>
<p>The <code>ItemType</code> <code>map(K, V)</code> matches an item
<var>M</var> if (a) <var>M</var> is a <a title="map" href=
"#dt-map">map</a>, and (b) every entry in <var>M</var> has a key
that matches <code>K</code> and an associated value that matches
<code>V</code>. For example, <code>map(xs:integer,
element(employee))</code> matches a map if all the keys in the map
are integers, and all the associated values are
<code>employee</code> elements. Note that a map (like a sequence)
carries no intrinsic type information separate from the types of
its entries, and the type of existing entries in a map does not
constrain the type of new entries that can be added to the map.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In consequence, <code>map(K, V)</code> matches an empty map,
whatever the types <var>K</var> and <var>V</var> might be.</p>
</div>
</li>
<li>
<p>The <code>ItemType</code> <code>map(*)</code> matches any map
regardless of its contents. It is equivalent to
<code>map(xs:anyAtomicType, item()*)</code>.</p>
</li>
<li>
<p>The <code>ItemType</code> <code>array(T)</code> matches any
array in which the type of every entry is <code>T</code>.</p>
</li>
<li>
<p>The <code>ItemType</code> <code>array(*)</code> matches any
array regardless of its contents.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-element-test" id="id-element-test"></a>2.5.5.3
Element Test</h5>
<h5><a name="d2e5591" id="d2e5591"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ElementTest" id=
"doc-xpath31-ElementTest"></a>[94]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xpath31-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ElementNameOrWildcard" id=
"doc-xpath31-ElementNameOrWildcard"></a>[95]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5260.doc-xpath31-ElementName" id=
"noid_d3e5260.doc-xpath31-ElementName"></a>[99]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5261.doc-xpath31-TypeName" id=
"noid_d3e5261.doc-xpath31-TypeName"></a>[101]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>An <a href="#doc-xpath31-ElementTest">ElementTest</a> is used to
match an element node by its name and/or <a title="type annotation"
href="#dt-type-annotation">type annotation</a>.</p>
<p>The <a href="#doc-xpath31-ElementName">ElementName</a> and
<a href="#doc-xpath31-TypeName">TypeName</a> of an <a href=
"#doc-xpath31-ElementTest">ElementTest</a> have their prefixes
expanded to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
<a href="#doc-xpath31-ElementName">ElementName</a> need not be
present in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, but the <a href=
"#doc-xpath31-TypeName">TypeName</a> must be present in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>]. Note that <a title=
"substitution group" href="#dt-substitution-group">substitution
groups</a> do not affect the semantics of <a href=
"#doc-xpath31-ElementTest">ElementTest</a>.</p>
<p>An <a href="#doc-xpath31-ElementTest">ElementTest</a> may take
any of the following forms:</p>
<ol class="enumar">
<li>
<p><code>element()</code> and <code>element(*)</code> match any
single element node, regardless of its name or type annotation.</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xpath31-ElementName">ElementName</a> <code>)</code> matches
any element node whose name is <a href=
"#doc-xpath31-ElementName">ElementName</a>, regardless of its type
annotation or <code>nilled</code> property.</p>
<p>Example: <code>element(person)</code> matches any element node
whose name is <code>person</code>.</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xpath31-ElementName">ElementName</a> <code>,</code> <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> matches an
element node whose name is <a href=
"#doc-xpath31-ElementName">ElementName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node, and the <code>nilled</code> property of the node is
<code>false</code>.</p>
<p>Example: <code>element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(</code> <a href=
"#doc-xpath31-ElementName">ElementName</a>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>?)</code> matches an
element node whose name is <a href=
"#doc-xpath31-ElementName">ElementName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node. The <code>nilled</code> property of the node may be
either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(person, surgeon?)</code> matches a nilled
or non-nilled element node whose name is <code>person</code> and
whose type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> matches an
element node regardless of its name, if <code>derives-from(</code>
<em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a>
<code>)</code> is <code>true</code>, where <em>AT</em> is the type
annotation of the element node, and the <code>nilled</code>
property of the node is <code>false</code>.</p>
<p>Example: <code>element(*, surgeon)</code> matches any non-nilled
element node whose type annotation is <code>surgeon</code> (or is
derived from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>?)</code> matches an
element node regardless of its name, if <code>derives-from(</code>
<em>AT</em>, <a href="#doc-xpath31-TypeName">TypeName</a>
<code>)</code> is <code>true</code>, where <em>AT</em> is the type
annotation of the element node. The <code>nilled</code> property of
the node may be either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(*, surgeon?)</code> matches any nilled or
non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>),
regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-element-test" id=
"id-schema-element-test"></a>2.5.5.4 Schema Element Test</h5>
<h5><a name="d2e5941" id="d2e5941"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SchemaElementTest" id=
"doc-xpath31-SchemaElementTest"></a>[96]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xpath31-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ElementDeclaration" id=
"doc-xpath31-ElementDeclaration"></a>[97]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5579.doc-xpath31-ElementName" id=
"noid_d3e5579.doc-xpath31-ElementName"></a>[99]&#160;&#160;&#160;</td>
<td><code>ElementName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
matches an element node against a corresponding element declaration
found in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>.</p>
<p>The <a href="#doc-xpath31-ElementName">ElementName</a> of a
<a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> has
its prefixes expanded to a namespace URI by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, or if
unprefixed, the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. If the
<a href="#doc-xpath31-ElementName">ElementName</a> specified in the
<a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a> is
not found in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href="#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
matches a candidate element node if all of the following conditions
are satisfied:</p>
<ol class="enumar">
<li>
<p>Either:</p>
<ol class="enumla">
<li>
<p>The name <em>N</em> of the candidate node matches the specified
<a href="#doc-xpath31-ElementName">ElementName</a>, or</p>
</li>
<li>
<p>The name <em>N</em> of the candidate node matches the name of an
element declaration that is a member of the actual substitution
group headed by the declaration of element <a href=
"#doc-xpath31-ElementName">ElementName</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term "actual substitution group" is defined in <a href=
"#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group
of an element declaration <em>H</em> includes those element
declarations <em>P</em> that are declared to have <em>H</em> as
their direct or indirect substitution group head, provided that
<em>P</em> is not declared as abstract, and that <em>P</em> is
validly substitutable for <em>H</em>, which means that there must
be no blocking constraints that prevent substitution.</p>
</div>
</li>
<li>
<p>The schema element declaration named <em>N</em> is not
abstract.</p>
</li>
<li>
<p><code>derives-from( AT, ET )</code> is true, where <em>AT</em>
is the type annotation of the candidate node and <em>ET</em> is the
schema type declared in the schema element declaration named
<em>N</em>.</p>
</li>
<li>
<p>If the schema element declaration named <em>N</em> is not
nillable, then the nilled property of the candidate node is
false.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a>
<code>schema-element(customer)</code> matches a candidate element
node in the following two situations:</p>
<ol class="enumar">
<li>
<p>customer is a top-level element declaration in the in-scope
element declarations; the name of the candidate node is customer;
the element declaration of customer is not abstract; the type
annotation of the candidate node is the same as or derived from the
schema type declared in the customer element declaration; and
either the candidate node is not nilled, or customer is declared to
be nillable.</p>
</li>
<li>
<p>customer is a top-level element declaration in the in-scope
element declarations; the name of the candidate node is client;
client is an actual (non-abstract and non-blocked) member of the
substitution group of customer; the type annotation of the
candidate node is the same as or derived from the schema type
declared for the client element; and either the candidate node is
not nilled, or client is declared to be nillable.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-attribute-test" id="id-attribute-test"></a>2.5.5.5
Attribute Test</h5>
<h5><a name="d2e6103" id="d2e6103"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AttributeTest" id=
"doc-xpath31-AttributeTest"></a>[90]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xpath31-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AttribNameOrWildcard" id=
"doc-xpath31-AttribNameOrWildcard"></a>[91]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5720.doc-xpath31-AttributeName" id=
"noid_d3e5720.doc-xpath31-AttributeName"></a>[98]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5721.doc-xpath31-TypeName" id=
"noid_d3e5721.doc-xpath31-TypeName"></a>[101]&#160;&#160;&#160;</td>
<td><code>TypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>An <a href="#doc-xpath31-AttributeTest">AttributeTest</a> is
used to match an attribute node by its name and/or <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
<p>The <a href="#doc-xpath31-AttributeName">AttributeName</a> and
<a href="#doc-xpath31-TypeName">TypeName</a> of an <a href=
"#doc-xpath31-AttributeTest">AttributeTest</a> have their prefixes
expanded to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If
unprefixed, the <a href=
"#doc-xpath31-AttributeName">AttributeName</a> is in no namespace,
but an unprefixed <a href="#doc-xpath31-TypeName">TypeName</a> is
in the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. The
<a href="#doc-xpath31-AttributeName">AttributeName</a> need not be
present in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, but the
<a href="#doc-xpath31-TypeName">TypeName</a> must be present in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>].</p>
<p>An <a href="#doc-xpath31-AttributeTest">AttributeTest</a> may
take any of the following forms:</p>
<ol class="enumar">
<li>
<p><code>attribute()</code> and <code>attribute(*)</code> match any
single attribute node, regardless of its name or type
annotation.</p>
</li>
<li>
<p><code>attribute(</code> <a href=
"#doc-xpath31-AttributeName">AttributeName</a> <code>)</code>
matches any attribute node whose name is <a href=
"#doc-xpath31-AttributeName">AttributeName</a>, regardless of its
type annotation.</p>
<p>Example: <code>attribute(price)</code> matches any attribute
node whose name is <code>price</code>.</p>
</li>
<li>
<p><code>attribute(</code> <a href=
"#doc-xpath31-AttributeName">AttributeName</a>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> matches an
attribute node whose name is <a href=
"#doc-xpath31-AttributeName">AttributeName</a> if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is <code>currency</code> (or is derived from
<code>currency</code>).</p>
</li>
<li>
<p><code>attribute(*,</code> <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> matches an
attribute node regardless of its name, if
<code>derives-from(</code> <em>AT</em>, <a href=
"#doc-xpath31-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(*, currency)</code> matches any
attribute node whose type annotation is <code>currency</code> (or
is derived from <code>currency</code>), regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-attribute-test" id=
"id-schema-attribute-test"></a>2.5.5.6 Schema Attribute Test</h5>
<h5><a name="d2e6321" id="d2e6321"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SchemaAttributeTest" id=
"doc-xpath31-SchemaAttributeTest"></a>[92]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AttributeDeclaration" id=
"doc-xpath31-AttributeDeclaration"></a>[93]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e5907.doc-xpath31-AttributeName" id=
"noid_d3e5907.doc-xpath31-AttributeName"></a>[98]&#160;&#160;&#160;</td>
<td><code>AttributeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> matches
an attribute node against a corresponding attribute declaration
found in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>.</p>
<p>The <a href="#doc-xpath31-AttributeName">AttributeName</a> of a
<a href="#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
has its prefixes expanded to a namespace URI by means of the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. If
unprefixed, an <a href=
"#doc-xpath31-AttributeName">AttributeName</a> is in no namespace.
If the <a href="#doc-xpath31-AttributeName">AttributeName</a>
specified in the <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> is not
found in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> matches
a candidate attribute node if both of the following conditions are
satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href=
"#doc-xpath31-AttributeName">AttributeName</a>.</p>
</li>
<li>
<p><code>derives-from(</code> <em>AT, ET</em> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
candidate node and <em>ET</em> is the schema type declared for
attribute <a href="#doc-xpath31-AttributeName">AttributeName</a> in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a>
<code>schema-attribute(color)</code> matches a candidate attribute
node if <code>color</code> is a top-level attribute declaration in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, the name of the
candidate node is <code>color</code>, and the type annotation of
the candidate node is the same as or derived from the schema type
declared for the <code>color</code> attribute.</p>
</div>
<div class="div4">
<h5><a name="id-function-test" id="id-function-test"></a>2.5.5.7
Function Test</h5>
<h5><a name="d2e6448" id="d2e6448"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-FunctionTest" id=
"doc-xpath31-FunctionTest"></a>[102]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-FunctionTest">FunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AnyFunctionTest" id=
"doc-xpath31-AnyFunctionTest"></a>[103]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AnyFunctionTest">AnyFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-TypedFunctionTest" id=
"doc-xpath31-TypedFunctionTest"></a>[104]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#doc-xpath31-SequenceType">SequenceType</a> ("," <a href=
"#doc-xpath31-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#doc-xpath31-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>A <a href="#doc-xpath31-FunctionTest">FunctionTest</a> matches a
<a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>,
potentially also checking its <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function
signature</a><sup><small>DM31</small></sup> . An <a href=
"#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a> matches any item
that is a function. A <a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a> matches an
item if it is a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
and the function's type signature (as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#function-items">Section
2.8.1 Functions</a> <sup><small>DM31</small></sup>) is a <a title=
"subtype" href="#dt-subtype">subtype</a> of the <a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a>.</p>
<p>Here are some examples of <a href=
"#doc-xpath31-FunctionTest">FunctionTest</a>s:</p>
<ol class="enumar">
<li>
<p><code>function(*)</code> matches any <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.</p>
</li>
<li>
<p><code>function(int, int) as int</code> matches any <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
with the function signature <code>function(int, int) as
int</code>.</p>
</li>
<li>
<p><code>function(*)</code> matches any map.</p>
</li>
<li>
<p><code>function(xs:anyAtomicType) as item()*</code> matches any
map.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>TODO: Add examples for arrays.</p>
</div>
</div>
<div class="div4">
<h5><a name="id-map-test" id="id-map-test"></a>2.5.5.8 Map
Test</h5>
<h5><a name="d2e6556" id="d2e6556"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapTest" id=
"doc-xpath31-MapTest"></a>[105]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-MapTest">MapTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map" "(" ("*" | (<a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> "," <a href=
"#doc-xpath31-SequenceType">SequenceType</a>)) ")"</code></td>
</tr>
</tbody>
</table>
<p>The Map Test <code>map(*)</code> matches any map. The Map Test
<code>map(X, Y)</code> matches any map where the type of every key
is an instance of <code>X</code> and the type of every value is an
instance of <code>Y</code>.</p>
<p>Examples:</p>
<p>Given a map <code>$M</code> whose keys are integers and whose
results are strings, such as <code>map{0:"no", 1:"yes"}</code>,
consider the results of the following expressions:</p>
<ul>
<li>
<p><code>$M instance of map(*)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>$M instance of map(xs:integer, xs:string)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code>
returns <code>true()</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:int, xs:string))</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:integer, xs:token))</code>
returns <code>true()</code></p>
</li>
</ul>
<p>Because of the rules for subtyping of function types according
to their signature, it follows that the item type <code>function(A)
as item()*</code>, where A is an atomic type, also matches any map,
regardless of the type of the keys actually found in the map. For
example, a map whose keys are all strings can be supplied where the
required type is <code>function(xs:integer) as item()*</code>; a
call on the map that treats it as a function with an integer
argument will always succeed, and will always return an empty
sequence.</p>
<p>The function signature of the map, treated as a function, is
always <code>function(xs:anyAtomicType) as item()*</code>,
regardless of the actual types of the keys and values in the map.
This means that a function item type with a more specific return
type, such as <code>function(xs:anyAtomicType) as
xs:integer</code>, does not match a map in the sense required to
satisfy the <code>instance of</code> operator. However, the rules
for function coercion mean that any map can be supplied as a value
in a context where such a type is the required type, and a type
error will only occur if an actual call on the map (treated as a
function) returns a value that is not an instance of the required
return type.</p>
<p>Examples:</p>
<ul>
<li>
<p><code>$M instance of function(*)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>$M instance of function(xs:anyAtomicType) as
item()*</code> returns <code>true()</code></p>
</li>
<li>
<p><code>$M instance of function(xs:integer) as item()*</code>
returns <code>true()</code></p>
</li>
<li>
<p><code>$M instance of function(xs:int) as item()*</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>$M instance of function(xs:string) as item()*</code>
returns <code>true()</code></p>
</li>
<li>
<p><code>not($M instance of function(xs:integer) as
xs:string)</code> returns <code>true()</code></p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The last case might seem surprising; however, function coercion
ensures that <code>$M</code> can be used successfully anywhere that
the required type is <code>function(xs:integer) as
xs:string</code>.</p>
</div>
</div>
<div class="div4">
<h5><a name="id-array-test" id="id-array-test"></a>2.5.5.9 Array
Test</h5>
<h5><a name="d2e6727" id="d2e6727"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ArrayTest" id=
"doc-xpath31-ArrayTest"></a>[106]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ArrayTest">ArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-WildcardArrayTest">WildcardArrayTest</a> | <a href=
"#doc-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-WildcardArrayTest" id=
"doc-xpath31-WildcardArrayTest"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-WildcardArrayTest">WildcardArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-TypedArrayTest" id=
"doc-xpath31-TypedArrayTest"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "(" <a href=
"#doc-xpath31-SequenceType">SequenceType</a> ")"</code></td>
</tr>
</tbody>
</table>
<p>The Wildcard Array Test <code>array(*)</code> matches any array.
The Typed Array Test <code>array(X)</code> matches any array
<span>in which</span> every array member matches the SequenceType
<code>X</code>.</p>
<p>Examples:</p>
<ul>
<li>
<p><code>[ 1, 2 ] instance array(*)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>[] instance of array(xs:string)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>[ "foo" ] instance of array(xs:string)</code> returns
<code>true()</code></p>
</li>
<li>
<p><code>[ "foo" ] instance of array(xs:integer)</code> returns
<code>false()</code></p>
</li>
</ul>
<p>An array also matches certain other ItemTypes, including:</p>
<ul>
<li>
<p><code>item()</code></p>
</li>
<li>
<p><code>function(*)</code></p>
</li>
<li>
<p><code>function(xs:integer) as item()*</code></p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-sequencetype-subtype" id=
"id-sequencetype-subtype"></a>2.5.6 SequenceType Subtype
Relationships</h4>
<p>Given two <a title="sequence type" href=
"#dt-sequence-type">sequence types</a>, it is possible to determine
if one is a subtype of the other. [<a name="dt-subtype" id=
"dt-subtype" title="subtype">Definition</a>: A <a title=
"sequence type" href="#dt-sequence-type">sequence type</a>
<code>A</code> is a <b>subtype</b> of a sequence type
<code>B</code> if the judgement <code>subtype(A, B)</code> is
true.] When the judgement <code>subtype(A, B)</code> is true, it is
always the case that for any value <code>V</code>, <code>(V
instance of A)</code> implies <code>(V instance of B)</code>.</p>
<div class="div4">
<h5><a name="id-seqtype-subtype" id=
"id-seqtype-subtype"></a>2.5.6.1 The judgement <code>subtype(A,
B)</code></h5>
<p>The judgement <code>subtype(A, B)</code> determines if the
<a title="sequence type" href="#dt-sequence-type">sequence type</a>
<code>A</code> is a <a title="subtype" href=
"#dt-subtype">subtype</a> of the sequence type <code>B</code>.
<code>A</code> can either be <code>empty-sequence()</code>,
<code>xs:error</code>, or an <a href=
"#doc-xpath31-ItemType">ItemType</a>, <code>Ai</code>, possibly
followed by an occurrence indicator. Similarly <code>B</code> can
either be <code>empty-sequence()</code>, <code>xs:error</code>, or
an <a href="#doc-xpath31-ItemType">ItemType</a>, <code>Bi</code>,
possibly followed by an occurrence indicator. The result of the
<code>subtype(A, B)</code> judgement can be determined from the
table below, which makes use of the auxiliary judgement
<code>subtype-itemtype(Ai, Bi)</code> defined in <a href=
"#id-itemtype-subtype"><b>2.5.6.2 The judgement
subtype-itemtype(Ai, Bi)</b></a> .</p>
<table border="1" summary="Special characters">
<tbody>
<tr>
<th rowspan="2" colspan="2"></th>
<th colspan="6"><a title="sequence type" href=
"#dt-sequence-type">Sequence type</a> <code>B</code></th>
</tr>
<tr>
<th colspan="1"><code>empty-sequence()</code></th>
<th colspan="1"><code>Bi?</code></th>
<th colspan="1"><code>Bi*</code></th>
<th colspan="1"><code>Bi</code></th>
<th colspan="1"><code>Bi+</code></th>
<td>xs:error</td>
</tr>
<tr>
<th rowspan="6" colspan="1"><a title="sequence type" href=
"#dt-sequence-type">Sequence type</a> <code>A</code></th>
<th colspan="1"><code>empty-sequence()</code></th>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai?</code></th>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai*</code></th>
<td>false</td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai</code></th>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>Ai+</code></th>
<td>false</td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
<td><code>subtype-itemtype(Ai, Bi)</code></td>
<td>false</td>
</tr>
<tr>
<th colspan="1"><code>xs:error</code></th>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><code>xs:error+</code> is treated the same way as
<code>xs:error</code> in the above table. <code>xs:error?</code>
and <code>xs:error*</code> are treated the same way as
<code>empty-sequence()</code>.</p>
</div>
<div class="div4">
<h5><a name="id-itemtype-subtype" id=
"id-itemtype-subtype"></a>2.5.6.2 The judgement
<code>subtype-itemtype(Ai, Bi)</code></h5>
<p>The judgement <code>subtype-itemtype(Ai, Bi)</code> determines
if the <a href="#doc-xpath31-ItemType">ItemType</a> <code>Ai</code>
is a <a title="subtype" href="#dt-subtype">subtype</a> of the
ItemType <code>Bi</code>. <code>Ai</code> is a subtype of
<code>Bi</code> if and only if at least one of the following
conditions applies:</p>
<ol class="enumar">
<li>
<p><code>Ai</code> and <code>Bi</code> are <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionTypes</a>, and
<code>derives-from(Ai, Bi)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Ai</code> is a pure union type, and every type
<code>t</code> in the transitive membership of <code>Ai</code>
satisfies <code>subtype-itemType(t, Bi)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>xs:error</code> and <code>Bi</code> is
a <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a>.</p>
</li>
<li>
<p><code>Bi</code> is <code>item()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>node()</code>, and <code>Ai</code> is a
<a href="#doc-xpath31-KindTest">KindTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is <code>text()</code> and <code>Ai</code> is
also <code>text()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>comment()</code> and <code>Ai</code> is
also <code>comment()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>namespace-node()</code> and
<code>Ai</code> is also <code>namespace-node()</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>processing-instruction()</code> and
<code>Ai</code> is either <code>processing-instruction()</code> or
<code>processing-instruction(N)</code> for any name N.</p>
</li>
<li>
<p><code>Bi</code> is <code>processing-instruction(Bn)</code>, and
<code>Ai</code> is also
<code>processing-instruction(Bn)</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>document-node()</code> and
<code>Ai</code> is either <code>document-node()</code> or
<code>document-node(E)</code> for any <a href=
"#doc-xpath31-ElementTest">ElementTest</a> E.</p>
</li>
<li>
<p><code>Bi</code> is <code>document-node(Be)</code> and
<code>Ai</code> is <code>document-node(Ae)</code>, and
<code>subtype-itemtype(Ae, Be)</code>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>element()</code> or
<code>element(*)</code>, and <code>Ai</code> is an <a href=
"#doc-xpath31-ElementTest">ElementTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>element(Bn)</code> or
<code>element(Bn, xs:anyType?)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>, and
<code>Ai</code> is either <code>element(An)</code>, or
<code>element(An, T?)</code> for any type T.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(Bn, Bt)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is <code>element(An, At)</code>, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(Bn, Bt?)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is either <code>element(An, At)</code> or
<code>element(An, At?)</code>, and <code>derives-from(At,
Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(*, Bt)</code>, <code>Ai</code>
is either <code>element(*, At)</code> or <code>element(N,
At)</code> for any name N, and <code>derives-from(At, Bt)</code>
returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>element(*, Bt?)</code>, <code>Ai</code>
is either <code>element(*, At)</code>, <code>element(*,
At?)</code>, <code>element(N, At)</code>, or <code>element(N,
At?)</code> for any name N, and <code>derives-from(At, Bt)</code>
returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>schema-element(Bn)</code>,
<code>Ai</code> is <code>schema-element(An)</code>, and every
element declaration that is an actual member of the substitution
group of <code>An</code> is also an actual member of the
substitution group of <code>Bn</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The fact that <code>P</code> is a member of the substitution
group of <code>Q</code> does not mean that every element
declaration in the substitution group of <code>P</code> is also in
the substitution group of <code>Q</code>. For example,
<code>Q</code> might block substitution of elements whose type is
derived by extension, while <code>P</code> does not.</p>
</div>
</li>
<li>
<p><code>Bi</code> is either <code>attribute()</code> or
<code>attribute(*)</code>, and <code>Ai</code> is an <a href=
"#doc-xpath31-AttributeTest">AttributeTest</a>.</p>
</li>
<li>
<p><code>Bi</code> is either <code>attribute(Bn)</code> or
<code>attribute(Bn, xs:anyType)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>, and
<code>Ai</code> is either <code>attribute(An)</code>, or
<code>attribute(An, T)</code> for any type T.</p>
</li>
<li>
<p><code>Bi</code> is <code>attribute(Bn, Bt)</code>, the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> of
<code>An</code> equals the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
<code>Ai</code> is <code>attribute(An, At)</code>, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>attribute(*, Bt)</code>,
<code>Ai</code> is either <code>attribute(*, At)</code>, or
<code>attribute(N, At)</code> for any name N, and
<code>derives-from(At, Bt)</code> returns <code>true</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>schema-attribute(Bn)</code>, the
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> of <code>An</code> equals the <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> of <code>Bn</code>,
and <code>Ai</code> is <code>schema-attribute(An)</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>function(*)</code>.</p>
</li>
<li>
<p><code>Bi</code> is <code>function(Ba_1, Ba_2, ... Ba_N) as
Br</code>, <code>Ai</code> is <code>function(Aa_1, Aa_2, ... Aa_M)
as Ar</code>, where ; <code>N</code> (arity of Bi) equals
<code>M</code> (arity of Ai); <code>subtype(Ar, Br)</code>;
<span class="xpath">and</span> for values of <code>I</code> between
1 and <code>N</code>, <code>subtype(Ba_I, Aa_I)</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Function return types are covariant because this rule invokes
subtype(Ar, Br) for return types. Function arguments are
contravariant because this rule invokes subtype(Ba_I, Aa_I) for
arguments.</p>
</div>
</li>
<li>
<p><code>Ai</code> is <code>map(K, V)</code>, for any
<code>K</code> and <code>V</code> and <code>Bi</code> is
<code>map(*)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code>
is <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Ka,
Kb)</code> and <code>subtype(Va, Vb)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(*)</code> (or, because of the
transitivity rules, any other map type), and <code>Bi</code> is
<code>function(*)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(*)</code> (or, because of the
transitivity rules, any other map type), and <code>Bi</code> is
<code>function(xs:anyAtomicType) as item()*</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is
<code>array(*)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is
<code>function(Y)</code>, and <code>X</code> is a subtype of
<code>Y</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>array(*)</code> (or, because of the
transitivity rules, any other array type) and <code>Bi</code> is
<code>function(*)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>array(*)</code> (or, because of the
transitivity rules, any other array type) and <code>Bi</code> is
<code>function(xs:integer) as item()*</code>.</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="id-xs-error" id="id-xs-error"></a>2.5.7 xs:error</h4>
<p>The type <code>xs:error</code> has an empty value space; it
never appears as a dynamic type or as the content type of a dynamic
element or attribute type. <code>xs:error</code> offers an
alternative way of raising errors, in addition to fn:error.</p>
<p>A cast to <code>xs:error</code> raises an error or returns the
empty sequence. Promotion to <code>xs:error</code> is not possible.
Neither <code>xs:error</code> nor <code>xs:error+</code> can ever
match a value. <code>xs:error</code> is a subtype of all simple
types, and a supertype only of itself. <code>xs:error?</code> and
<code>xs:error*</code> are identical to empty-sequence(). A
variable binding with a type declaration xs:error always raises a
type error.</p>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>2.6 Comments</h3>
<h5><a name="d2e7945" id="d2e7945"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Comment" id=
"doc-xpath31-Comment"></a>[119]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#doc-xpath31-CommentContents">CommentContents</a> | <a href=
"#doc-xpath31-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-CommentContents" id=
"doc-xpath31-CommentContents"></a>[124]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath31-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>Comments may be used to provide information relevant to
programmers who read <span class="xpath">an expression</span>.
Comments are lexical constructs only, and do not affect
<span class="xpath">expression</span> processing.</p>
<p>Comments are strings, delimited by the symbols <code>(:</code>
and <code>:)</code>. Comments may be nested.</p>
<p>A comment may be used anywhere <a title="ignorable whitespace"
href="#IgnorableWhitespace">ignorable whitespace</a> is allowed
(see <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default
Whitespace Handling</b></a>).</p>
<p>The following is an example of a comment:</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>3
Expressions</h2>
<p>This section discusses each of the basic kinds of expression.
Each kind of expression has a name such as <code>PathExpr</code>,
which is introduced on the left side of the grammar production that
defines the expression. Since XPath 3.1 is a composable language,
each kind of expression is defined in terms of other expressions
whose operators have a higher precedence. In this way, the
precedence of operators is represented explicitly in the
grammar.</p>
<p>The order in which expressions are discussed in this document
does not reflect the order of operator precedence. In general, this
document introduces the simplest kinds of expressions first,
followed by more complex expressions. For the complete grammar, see
Appendix [<a href="#nt-bnf"><b>A XPath 3.1 Grammar</b></a>].</p>
<p><span class="xpath">The highest-level symbol in the XPath
grammar is XPath.</span></p>
<h5><a name="d2e8010" id="d2e8010"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-XPath" id=
"doc-xpath31-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Expr" id=
"doc-xpath31-Expr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ExprSingle" id=
"doc-xpath31-ExprSingle"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ForExpr">ForExpr</a><br />
| <a href="#doc-xpath31-LetExpr">LetExpr</a><br />
| <a href="#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xpath31-IfExpr">IfExpr</a><br />
| <a href="#doc-xpath31-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p>The XPath 3.1 operator that has lowest precedence is the
<a title="comma operator" href="#dt-comma-operator">comma
operator</a>, which is used to combine two operands to form a
sequence. As shown in the grammar, a general expression (<a href=
"#doc-xpath31-Expr">Expr</a>) can consist of multiple <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a> operands, separated by
commas. The name <a href="#doc-xpath31-ExprSingle">ExprSingle</a>
denotes an expression that does not contain a top-level <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>
(despite its name, an <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a> may evaluate to a sequence
containing more than one item.)</p>
<p>The symbol <a href="#doc-xpath31-ExprSingle">ExprSingle</a> is
used in various places in the grammar where an expression is not
allowed to contain a top-level comma. For example, each of the
arguments of a function call must be an <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a>, because commas are used
to separate the arguments of a function call.</p>
<p>After the comma, the expressions that have next lowest
precedence are <span class="xpath"><a href=
"#doc-xpath31-ForExpr">ForExpr</a>, <a href=
"#doc-xpath31-LetExpr">LetExpr</a>,</span> <a href=
"#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a>, <a href=
"#doc-xpath31-IfExpr">IfExpr</a>, and <a href=
"#doc-xpath31-OrExpr">OrExpr</a>. Each of these expressions is
described in a separate section of this document.</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>3.1 Primary Expressions</h3>
<p>[<a name="dt-primary-expression" id="dt-primary-expression"
title="primary expression">Definition</a>: <b>Primary
expressions</b> are the basic primitives of the language. They
include literals, variable references, context item expressions,
and function calls. A primary expression may also be created by
enclosing any expression in parentheses, which is sometimes helpful
in controlling the precedence of operators.] <span>Map and Array
Constructors are described in <a href="#id-maps-and-arrays"><b>3.11
Maps and Arrays</b></a>.</span></p>
<h5><a name="d2e8125" id="d2e8125"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-PrimaryExpr" id=
"doc-xpath31-PrimaryExpr"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Literal">Literal</a><br />
| <a href="#doc-xpath31-VarRef">VarRef</a><br />
| <a href=
"#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#doc-xpath31-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#doc-xpath31-FunctionCall">FunctionCall</a><br />
| <a href=
"#doc-xpath31-FunctionItemExpr">FunctionItemExpr</a><br />
| <a href="#doc-xpath31-MapConstructor">MapConstructor</a><br />
| <a href=
"#doc-xpath31-ArrayConstructor">ArrayConstructor</a><br />
| <a href=
"#doc-xpath31-UnaryMapLookup">UnaryMapLookup</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-FunctionItemExpr" id=
"doc-xpath31-FunctionItemExpr"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-FunctionItemExpr">FunctionItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#doc-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>3.1.1 Literals</h4>
<p>[<a name="dt-literal" id="dt-literal" title=
"literal">Definition</a>: A <b>literal</b> is a direct syntactic
representation of an atomic value.] XPath 3.1 supports two kinds of
literals: numeric literals and string literals.</p>
<h5><a name="d2e8199" id="d2e8199"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Literal" id=
"doc-xpath31-Literal"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-NumericLiteral">NumericLiteral</a>
| <a href=
"#doc-xpath31-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NumericLiteral" id=
"doc-xpath31-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-IntegerLiteral">IntegerLiteral</a>
| <a href="#doc-xpath31-DecimalLiteral">DecimalLiteral</a> |
<a href="#doc-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-IntegerLiteral" id=
"doc-xpath31-IntegerLiteral"></a>[111]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-DecimalLiteral" id=
"doc-xpath31-DecimalLiteral"></a>[112]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xpath31-Digits">Digits</a>) |
(<a href="#doc-xpath31-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-DoubleLiteral" id=
"doc-xpath31-DoubleLiteral"></a>[113]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xpath31-Digits">Digits</a>) |
(<a href="#doc-xpath31-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#doc-xpath31-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-StringLiteral" id=
"doc-xpath31-StringLiteral"></a>[114]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#doc-xpath31-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href=
"#doc-xpath31-EscapeApos">EscapeApos</a> | [^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-EscapeQuot" id=
"doc-xpath31-EscapeQuot"></a>[117]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-EscapeApos" id=
"doc-xpath31-EscapeApos"></a>[118]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Digits" id=
"doc-xpath31-Digits"></a>[123]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p>The value of a <b>numeric literal</b> containing no
"<code>.</code>" and no <code>e</code> or <code>E</code> character
is an atomic value of type <code>xs:integer</code>. The value of a
numeric literal containing "<code>.</code>" but no <code>e</code>
or <code>E</code> character is an atomic value of type
<code>xs:decimal</code>. The value of a numeric literal containing
an <code>e</code> or <code>E</code> character is an atomic value of
type <code>xs:double</code>. The value of the numeric literal is
determined by casting it to the appropriate type according to the
rules for casting from <code>xs:untypedAtomic</code> to a numeric
type as specified in <a href=
"http://www.w3.org/TR/xpath-functions-31/#casting-from-strings">Section
19.2 Casting from xs:string and xs:untypedAtomic</a>
<sup><small>FO31</small></sup>.</p>
<p id="id-string-literal">The value of a <b>string literal</b> is
an atomic value whose type is <code>xs:string</code> and whose
value is the string denoted by the characters between the
delimiting apostrophes or quotation marks. If the literal is
delimited by apostrophes, two adjacent apostrophes within the
literal are interpreted as a single apostrophe. Similarly, if the
literal is delimited by quotation marks, two adjacent quotation
marks within the literal are interpreted as one quotation mark.</p>
<p>Here are some examples of literal expressions:</p>
<ul>
<li>
<p><code>"12.5"</code> denotes the string containing the characters
'1', '2', '.', and '5'.</p>
</li>
<li>
<p><code>12</code> denotes the <code>xs:integer</code> value
twelve.</p>
</li>
<li>
<p><code>12.5</code> denotes the <code>xs:decimal</code> value
twelve and one half.</p>
</li>
<li>
<p><code>125E2</code> denotes the <code>xs:double</code> value
twelve thousand, five hundred.</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code> denotes a string
containing two quotation marks and one apostrophe.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When XPath expressions are embedded in contexts where quotation
marks have special significance, such as inside XML attributes,
additional escaping may be needed.</p>
</div>
</li>
</ul>
<p>The <code>xs:boolean</code> values <code>true</code> and
<code>false</code> can be constructed by calls to the <a title=
"built-in function" href="#dt-built-in-function">built-in
functions</a> <code>fn:true()</code> and <code>fn:false()</code>,
respectively.</p>
<p>Values of other atomic types can be constructed by calling the
<a title="constructor function" href=
"#dt-constructor-function">constructor function</a> for the given
type. The constructor functions for XML Schema built-in types are
defined in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>. In general, the name of a
constructor function for a given type is the same as the name of
the type (including its namespace). For example:</p>
<ul>
<li>
<p><code>xs:integer("12")</code> returns the integer value
twelve.</p>
</li>
<li>
<p><code>xs:date("2001-08-25")</code> returns an item whose type is
<code>xs:date</code> and whose value represents the date 25th
August 2001.</p>
</li>
<li>
<p><code>xs:dayTimeDuration("PT5H")</code> returns an item whose
type is <code>xs:dayTimeDuration</code> and whose value represents
a duration of five hours.</p>
</li>
</ul>
<p>Constructor functions can also be used to create special values
that have no literal representation, as in the following
examples:</p>
<ul>
<li>
<p><code>xs:float("NaN")</code> returns the special floating-point
value, "Not a Number."</p>
</li>
<li>
<p><code>xs:double("INF")</code> returns the special
double-precision value, "positive infinity."</p>
</li>
</ul>
<p>Constructor functions are available for all <a title=
"generalized atomic type" href=
"#dt-generalized-atomic-type">Generalized atomic types</a>,
including union types. For example, if <code>my:dt</code> is a
user-defined union type whose member types are
<code>xs:date</code>, <code>xs:time</code>, and
<code>xs:dateTime</code>, then the expression
<code>my:dt("2011-01-10")</code> creates an atomic value of type
<code>xs:date</code>. The rules follow XML Schema validation rules
for union types: the effect is to choose the first member type that
accepts the given string in its lexical space.</p>
<p>It is also possible to construct values of various types by
using a <code>cast</code> expression. For example:</p>
<ul>
<li>
<p><code>9 cast as hatsize</code> returns the atomic value
<code>9</code> whose type is <code>hatsize</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>3.1.2 Variable
References</h4>
<h5><a name="d2e8498" id="d2e8498"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-VarRef" id=
"doc-xpath31-VarRef"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#doc-xpath31-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-VarName" id=
"doc-xpath31-VarName"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-variable-reference" id="dt-variable-reference"
title="variable reference">Definition</a>: A <b>variable
reference</b> is an EQName preceded by a $-sign.] An unprefixed
variable reference is in no namespace. Two variable references are
equivalent if their <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> are equal (as defined by
the <code>eq</code> operator). The scope of a variable binding is
defined separately for each kind of expression that can bind
variables.</p>
<p>Every variable reference must match a name in the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a>.</p>
<p>Every variable binding has a static scope. The scope defines
where references to the variable can validly occur. It is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] to
reference a variable that is not in scope. If a variable is bound
in the <a title="static context" href="#dt-static-context">static
context</a> for an expression, that variable is in scope for the
entire expression except where it is occluded by another binding
that uses the same name within that scope.</p>
<p>At evaluation time, the value of a variable reference is the
value to which the relevant variable is bound.</p>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>3.1.3 Parenthesized Expressions</h4>
<h5><a name="d2e8550" id="d2e8550"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ParenthesizedExpr" id=
"doc-xpath31-ParenthesizedExpr"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xpath31-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>Parentheses may be used to override the precedence rules. For
example, the expression <code>(2 + 4) * 5</code> evaluates to
thirty, since the parenthesized expression <code>(2 + 4)</code> is
evaluated first and its result is multiplied by five. Without
parentheses, the expression <code>2 + 4 * 5</code> evaluates to
twenty-two, because the multiplication operator has higher
precedence than the addition operator.</p>
<p>Empty parentheses are used to denote an empty sequence, as
described in <a href="#construct_seq"><b>3.4.1 Constructing
Sequences</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>3.1.4 Context Item Expression</h4>
<h5><a name="d2e8578" id="d2e8578"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ContextItemExpr" id=
"doc-xpath31-ContextItemExpr"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p>A <b>context item expression</b> evaluates to the <a title=
"context item" href="#dt-context-item">context item</a>, which may
be either a node (as in the expression
<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>),
or an atomic value or function (as in the expression <code>(1 to
100)[. mod 5 eq 0]</code>).</p>
<p>If the <a title="context item" href="#dt-context-item">context
item</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>,
a context item expression raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a href="#ERRXPDY0002"
title="err:XPDY0002">err:XPDY0002</a>].</p>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>3.1.5
Static Function Calls</h4>
<p>[<a name="dt-built-in-function" id="dt-built-in-function" title=
"built-in function">Definition</a>: The <b>built-in functions</b>
supported by XPath 3.1 are defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.] <span class="xpath">Additional functions may be provided
in the <a title="static context" href="#dt-static-context">static
context</a>. XPath per se does not provide a way to declare named
functions, but a host language may provide such a
mechanism.</span></p>
<h5><a name="d2e8630" id="d2e8630"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-FunctionCall" id=
"doc-xpath31-FunctionCall"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a> <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e7913.doc-xpath31-ArgumentList" id=
"noid_d3e7913.doc-xpath31-ArgumentList"></a>[49]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xpath31-Argument">Argument</a> (","
<a href="#doc-xpath31-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Argument" id=
"doc-xpath31-Argument"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Argument">Argument</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ExprSingle">ExprSingle</a> |
<a href=
"#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ArgumentPlaceholder" id=
"doc-xpath31-ArgumentPlaceholder"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-static-function-call" id="dt-static-function-call"
title="static function call">Definition</a>: A <b>static function
call</b> consists of an EQName followed by a parenthesized list of
zero or more arguments.] [<a name="dt-arg-expr" id="dt-arg-expr"
title="argument expression">Definition</a>: An argument to a
function call is either an <b>argument expression</b> or an
ArgumentPlaceholder ("?").] If the EQName in a static function call
is a <a title="lexical QName" href="#dt-qname">lexical QName</a>
that has no namespace prefix, it is considered to be in the
<a title="default function namespace" href="#dt-def-fn-ns">default
function namespace.</a></p>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and number of arguments in
a static function call do not match the name and arity of a
<a title="statically known function signatures" href=
"#dt-known-func-signatures">function signature</a> in the <a title=
"static context" href="#dt-static-context">static context</a>, a
<a title="static error" href="#dt-static-error">static error</a> is
raised [<a href="#ERRXPST0017" title=
"err:XPST0017">err:XPST0017</a>].</p>
<p>[<a name="dt-partial-function-application" id=
"dt-partial-function-application" title=
"partial function application">Definition</a>: A static or
<a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic</a> function call is a
<b>partial function application</b> if one or more arguments is an
ArgumentPlaceholder. ]</p>
<p>Evaluation of function calls is described in <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a>.</p>
<p>Since the arguments of a function call are separated by commas,
any <a title="argument expression" href="#dt-arg-expr">argument
expression</a> that contains a top-level <a title="comma operator"
href="#dt-comma-operator">comma operator</a> must be enclosed in
parentheses. Here are some illustrative examples of static function
calls:</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2, 3)</code> denotes a
static function call with three arguments.</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2), 3)</code> denotes a
static function call with two arguments, the first of which is a
sequence of two values.</p>
</li>
<li>
<p><code>my:two-argument-function(1, ())</code> denotes a static
function call with two arguments, the second of which is an empty
sequence.</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2, 3))</code> denotes a
static function call with one argument that is a sequence of three
values.</p>
</li>
<li>
<p><code>my:one-argument-function(( ))</code> denotes a static
function call with one argument that is an empty sequence.</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code> denotes a static
function call with zero arguments.</p>
</li>
</ul>
<div class="div4">
<h5><a name="id-eval-function-call" id=
"id-eval-function-call"></a>3.1.5.1 Evaluating Static and Dynamic
Function Calls</h5>
<p>When a static or dynamic function call <var>FC</var> is
evaluated with respect to a static context <var>SC</var> and a
dynamic context <var>DC</var>, the result is obtained as
follows:</p>
<ol class="enumar">
<li>
<p>[<a name="dt-argumentlist-arity" id="dt-argumentlist-arity"
title="arity">Definition</a>: The number of <code>Argument</code>s
in an <code>ArgumentList</code> is its <b>arity</b>. ]</p>
</li>
<li>
<p>The function to be called or partially applied (call it
<var>F</var>) is obtained as follows:</p>
<ol class="enumla">
<li>
<p>If <var>FC</var> is a static function call: Using the expanded
QName corresponding to <var>FC</var>'s <code>EQName</code>, and the
arity of <var>FC</var>'s <code>ArgumentList</code>, the
corresponding function is looked up in the <a title=
"named functions" href="#dt-named-functions">named functions</a>
component of <var>DC</var>. Let <var>F</var> denote the function
obtained.</p>
</li>
<li>
<p>If <var>FC</var> is a dynamic function call: <var>FC</var>'s
base expression is evaluated with respect to <var>SC</var> and
<var>DC</var>. If this yields a sequence consisting of a single
function with the same arity as the arity of the
<code>ArgumentList</code>, let <var>F</var> denote that function.
Otherwise, a type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
<li>
<p>[<a name="dt-arg-value" id="dt-arg-value" title=
"argument value">Definition</a>: <a title="argument expression"
href="#dt-arg-expr">Argument expressions</a> are evaluated with
respect to <var>DC</var>, producing <b>argument values</b>.] The
order of argument evaluation is <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
and a function need not evaluate an argument if the function can
evaluate its body without evaluating that argument.</p>
</li>
<li>
<p>Each argument value is converted to the corresponding parameter
type in <var>F</var>'s signature by applying the <a title=
"function conversion rules" href="#dt-function-conversion">function
conversion rules</a>, resulting in a <b>converted argument
value</b>.</p>
</li>
<li>
<p>The remainder depends on whether or not <var>FC</var> is a
<a title="partial function application" href=
"#dt-partial-function-application">partial function
application</a>.</p>
<ol class="enumla">
<li>
<p>If <var>FC</var> is a partial function application:</p>
<ol class="enumlr">
<li>
<p>[<a name="dt-fixed-position" id="dt-fixed-position" title=
"fixed position">Definition</a>: In a partial function application,
a <b>fixed position</b> is an argument/parameter position for which
the <code>ArgumentList</code> has an argument expression (as
opposed to an <code>ArgumentPlaceholder</code>). ] (Note that a
partial function application need not have any fixed
positions.)</p>
</li>
<li>
<p>A new function returned (as the value of <var>FC</var>), with
the following properties (as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#function-items">Section
2.8.1 Functions</a> <sup><small>DM31</small></sup>):</p>
<ul>
<li>
<p><b>name</b>: Absent.</p>
</li>
<li>
<p><b>parameter names</b>: The parameter names of <var>F</var>,
removing the parameter names at the fixed positions. (So the
function's arity is the arity of F minus the number of fixed
positions.)</p>
</li>
<li>
<p><b>signature</b>: The signature of <var>F</var>, removing the
parameter type at each of the fixed positions.</p>
</li>
<li>
<p><b>implementation</b>: The implementation of <var>F</var>,
associated with the same contexts as in <var>F</var>. If these
contexts are absent in <var>F</var>, it is associated with
<var>SC</var> and <var>DC</var>.</p>
</li>
<li>
<p><b>nonlocal variable bindings</b>: The nonlocal variable
bindings of <var>F</var>, plus, for each fixed position, a binding
of the converted argument value to the corresponding parameter
name.</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>If <var>FC</var> is not a partial function application:</p>
<ol class="enumlr">
<li>
<p>If <var>F</var>'s implementation is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> (e.g.,
it is a built-in function or external function <span class=
"xpath">or host-language-dependent function</span>, or a partial
application of such a function):</p>
<ul>
<li>
<p><var>F</var>'s implementation is invoked with the converted
argument values using the contexts it is associated with in
<var>F</var>. If these contexts are absent in <var>F</var>, it is
associated with <var>SC</var> and <var>DC</var>.</p>
</li>
<li>
<p>The result is either an instance of <var>F</var>'s return type
or a dynamic error. This result is then the result of evaluating
<var>FC</var>.</p>
</li>
<li>
<p>Errors raised by built-in functions are defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
</li>
<li>
<p>Errors raised by external functions are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> (see
<a href="#id-consistency-constraints"><b>2.2.4 Consistency
Constraints</b></a>).</p>
</li>
<li>
<p>Errors raised by host-language-dependent functions are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
</ul>
</li>
<li>
<p>If <var>F</var>'s implementation is a
<code>FunctionBody</code>:</p>
<ol class="enumua">
<li>
<p>The <code>FunctionBody</code> is evaluated. The dynamic context
for this evaluation is obtained by taking the dynamic context of
the <span class="xpath"><code>InlineFunctionExpr</code></span> that
contains the <code>FunctionBody</code>, and making the following
changes:</p>
<ul>
<li>
<p>The <a title="focus" href="#dt-focus">focus</a> (context item,
context position, and context size) is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</p>
</li>
<li>
<p>In the <a title="variable values" href=
"#dt-variable-values">variable values</a> component of the dynamic
context, each converted argument value is bound to the
corresponding parameter name.</p>
<p>When this is done, the converted argument value retains its most
specific <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a>, even though this type may be derived from the type of the
formal parameter. For example, a function with a parameter
<code>$p</code> of type <code>xs:decimal</code> can be invoked with
an argument of type <code>xs:integer</code>, which is derived from
<code>xs:decimal</code>. During the processing of this function
call, the <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> of <code>$p</code> inside the body of the function is
considered to be <code>xs:integer</code>.</p>
</li>
<li>
<p>F's nonlocal variable bindings are also added to the <a title=
"variable values" href="#dt-variable-values">variable values</a>.
(Note that the names of the nonlocal variables are by definition
disjoint from the parameter names, so there can be no
conflict.)</p>
</li>
</ul>
</li>
<li>
<p>The value returned by evaluating the function body is then
converted to the declared return type of <var>F</var> by applying
the <a title="function conversion rules" href=
"#dt-function-conversion">function conversion rules</a>. The result
is then the result of evaluating <var>FC</var>.</p>
<p>As with argument values, the value returned by a function
retains its most specific type, which may be derived from the
declared return type of <var>F</var>. For example, a function that
has a declared return type of <code>xs:decimal</code> may in fact
return a value of dynamic type <code>xs:integer</code>.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-function-conversion-rules" id=
"id-function-conversion-rules"></a>3.1.5.2 Function Conversion
Rules</h5>
<p>[<a name="dt-function-conversion" id="dt-function-conversion"
title="function conversion rules">Definition</a>: The <b>function
conversion rules</b> are used to convert an argument value to its
expected type; that is, to the declared type of the function
<span class="xpath">parameter.</span> ] The expected type is
expressed as a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>. The function conversion
rules are applied to a given value as follows:</p>
<ul>
<li>
<p>In a static function call, if <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>true</code> and an argument of
a static function is not of the expected type, then the following
conversions are applied sequentially to the argument value V:</p>
<ol class="enumar">
<li>
<p>If the expected type calls for a single item or optional single
item (examples: <code>xs:string</code>, <code>xs:string?</code>,
<code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>,
<code>node()</code>, <code>node()?</code>, <code>item()</code>,
<code>item()?</code>), then the value V is effectively replaced by
V[1].</p>
</li>
<li>
<p>If the expected type is <code>xs:string</code> or
<code>xs:string?</code>, then the value <code>V</code> is
effectively replaced by <code>fn:string(V)</code>.</p>
</li>
<li>
<p>If the expected type is <code>xs:double</code> or
<code>xs:double?</code>, then the value <code>V</code> is
effectively replaced by <code>fn:number(V)</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> has no
effect on dynamic function calls, converting the result of an
inline function to its required type, partial function application,
or implicit function calls that occur when evaluating functions
such as fn:for-each and fn:filter.</p>
</div>
</li>
<li>
<p>If the expected type is a sequence of a <a title=
"generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> (possibly
with an occurrence indicator <code>*</code>, <code>+</code>, or
<code>?</code>), the following conversions are applied:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the given value, resulting in a sequence of atomic
values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>Each item in the atomic sequence that is of type
<code>xs:untypedAtomic</code> is cast to the expected generalized
atomic type. For <a title="built-in function" href=
"#dt-built-in-function">built-in functions</a> where the expected
type is specified as <a title="numeric" href=
"#dt-numeric">numeric</a>, arguments of type
<code>xs:untypedAtomic</code> are cast to <code>xs:double</code>.
If the item is of type <code>xs:untypedAtomic</code> and the
expected type is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is
raised.</p>
</li>
<li>
<p>For each <a title="numeric" href="#dt-numeric">numeric</a> item
in the atomic sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
numeric promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
<li>
<p>For each item of type <code>xs:anyURI</code> in the atomic
sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
URI promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
</ol>
</li>
<li>
<p>If the expected type is a <a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a> (possibly
with an occurrence indicator <code>*</code>, <code>+</code>, or
<code>?</code>), <a title="function coercion" href=
"#dt-function-item-coercion">function coercion</a> is applied to
each function in the given value.</p>
</li>
<li>
<p>If, after the above conversions, the resulting value does not
match the expected type according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
Note that the rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a> permit a
value of a derived type to be substituted for a value of its base
type.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-function-coercion" id=
"id-function-coercion"></a>3.1.5.3 Function Coercion</h5>
<p>Function coercion is a transformation applied to <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup>
during application of the <a title="function conversion rules"
href="#dt-function-conversion">function conversion rules</a>.
[<a name="dt-function-item-coercion" id="dt-function-item-coercion"
title="function coercion">Definition</a>: <b>Function coercion</b>
wraps a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
in a new function with signature the same as the expected type.
This effectively delays the checking of the argument and return
types until the function is invoked.]</p>
<p>Function coercion is only defined to operate on <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">functions</a><sup><small>DM31</small></sup>.
Given a function <var>F</var>, and an expected function type,
function coercion proceeds as follows: If <var>F</var> and the
expected type have different arity, a type error is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
Otherwise, coercion returns a new function with the following
properties (as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#function-items">Section
2.8.1 Functions</a> <sup><small>DM31</small></sup>):</p>
<ul>
<li>
<p><b>name</b>: The name of <var>F</var>.</p>
</li>
<li>
<p><b>parameter names</b>: The parameter names of <var>F</var>.</p>
</li>
<li>
<p><b>signature</b>: <code>Annotations</code> is set to the
annotations of <var>F</var>. <code>TypedFunctionTest</code> is set
to the expected type.</p>
</li>
<li>
<p><b>implementation</b>: In effect, a <code>FunctionBody</code>
that calls <var>F</var>, passing it the parameters of this new
function, in order.</p>
</li>
<li>
<p><b>nonlocal variable bindings</b>: An empty mapping.</p>
</li>
</ul>
<p>If the result of invoking the new function would necessarily
result in a type error, that error may be raised during function
coercion. It is implementation dependent whether this happens or
not.</p>
<p>These rules have the following consequences:</p>
<ul>
<li>
<p>SequenceType matching of the function's arguments and result are
delayed until that function is invoked.</p>
</li>
<li>
<p>The function conversion rules applied to the function's
arguments and result are defined by the SequenceType it has most
recently been coerced to. Additional function conversion rules
could apply when the wrapped function is invoked.</p>
</li>
<li>
<p>If an implementation has static type information about a
function, that can be used to type check the function's argument
and return types during static analysis.</p>
</li>
</ul>
<p>For instance, consider the following query:</p>
<div class="exampleInner">
<pre>
declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()*
{
  $s[$p(.)]
};

let $f := function($a) { starts-with($a, "E") }
return
  local:filter(("Ethel", "Enid", "Gertrude"), $f)
      
</pre></div>
<p>The function <code>$f</code> has a static type of
<code>function(item()*) as item()*</code>. When the
<code>local:filter()</code> function is called, the following
occurs to the function:</p>
<ol class="enumar">
<li>
<p>The function conversion rules result in applying function
coercion to <code>$f</code>, wrapping $f in a new function ($p)
with the signature <code>function(xs:string) as
xs:boolean</code>.</p>
</li>
<li>
<p>$p is matched against the SequenceType of
<code>function(xs:string) as xs:boolean</code>, and succeeds.</p>
</li>
<li>
<p>When $p is invoked inside the predicate, function conversion and
SequenceType matching rules are applied to the context item
argument, resulting in an <code>xs:string</code> value or a type
error.</p>
</li>
<li>
<p>$f is invoked with the <code>xs:string</code>, which returns an
<code>xs:boolean</code>.</p>
</li>
<li>
<p>$p applies function conversion rules to the result sequence from
$f, which already matches its declared return type of
<code>xs:boolean</code>.</p>
</li>
<li>
<p>The <code>xs:boolean</code> is returned as the result of $p.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the semantics of function coercion are specified in
terms of wrapping the functions, static typing will often be able
to reduce the number of places where this is actually
necessary.</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-named-function-ref" id=
"id-named-function-ref"></a>3.1.6 Named Function References</h4>
<h5><a name="d2e9522" id="d2e9522"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NamedFunctionRef" id=
"doc-xpath31-NamedFunctionRef"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-NamedFunctionRef">NamedFunctionRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a> "#" <a href=
"#doc-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8771.doc-xpath31-EQName" id=
"noid_d3e8771.doc-xpath31-EQName"></a>[110]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-QName">QName</a> | <a href=
"#doc-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-named-function-ref" id="dt-named-function-ref"
title="named function reference">Definition</a>: A <b>named
function reference</b> denotes a <a title="named function" href=
"#dt-named-func">named function</a>.] [<a name="dt-named-func" id=
"dt-named-func" title="named function">Definition</a>: A <b>named
function</b> is a function defined in the static context for the
<span class="xpath">expression</span>. To uniquely identify a
particular named function, both its name as an expanded QName and
its arity are required.]</p>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a> that has no namespace prefix, it is
considered to be in the default function namespace.</p>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and arity in a named
function reference do not match the name and arity of a function
signature in the static context, a static error is raised [<a href=
"#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p>
<p>The value of a <code>NamedFunctionRef</code> is the function
obtained by looking up the expanded QName and arity in the
<a title="named functions" href="#dt-named-functions">named
functions</a> component of the dynamic context.</p>
<p>Furthermore, if the function referenced by a
<code>NamedFunctionRef</code> has an implementation-dependent
implementation, then the implementation of the function returned by
the <code>NamedFunctionRef</code> is associated with the static
context of this <code>NamedFunctionRef</code> expression and to the
dynamic context in which it is currently being evaluated.</p>
<p>Certain functions in the <a href="#xpath-functions-31">[XQuery
and XPath Functions and Operators 3.1]</a> specification are
defined to be polymorphic. These are denoted as accepting
parameters of "numeric" type, or returning "numeric" type. Here
"numeric" is a pseudonym for the four primitive numeric types
xs:decimal, xs:integer, xs:float, and xs:double. For the purposes
of named function references, these functions are regarded as
taking arguments and producing results of type xs:anyAtomicType,
with a type error raised at runtime if the argument value provided
is not of the correct numeric type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above way of modeling polymorphic functions is semantically
backwards compatible with <span class="xpath">XPath 2.0</span>. An
implementation that supports static typing can choose to model the
types of these functions more accurately if desired.</p>
</div>
<p>The following are examples of named function references:</p>
<ul>
<li>
<p><code>fn:abs#1</code> references the fn:abs function which takes
a single argument.</p>
</li>
<li>
<p><code>fn:concat#5</code> references the fn:concat function which
takes 5 arguments.</p>
</li>
<li>
<p><code>local:myfunc#2</code> references a function named
local:myfunc which takes 2 arguments.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-inline-func" id="id-inline-func"></a>3.1.7 Inline
Function Expressions</h4>
<h5><a name="d2e9633" id="d2e9633"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-InlineFunctionExpr" id=
"doc-xpath31-InlineFunctionExpr"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" <a href=
"#prod-xpath31-ParamList">ParamList</a>? ")" ("as" <a href=
"#doc-xpath31-SequenceType">SequenceType</a>)? <a href=
"#prod-xpath31-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8862.doc-xpath31-ParamList" id=
"noid_d3e8862.doc-xpath31-ParamList"></a>[2]&#160;&#160;&#160;</td>
<td><code>ParamList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Param">Param</a> ("," <a href=
"#prod-xpath31-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8863.doc-xpath31-Param" id=
"noid_d3e8863.doc-xpath31-Param"></a>[3]&#160;&#160;&#160;</td>
<td><code>Param</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath31-EQName">EQName</a> <a href=
"#prod-xpath31-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8864.doc-xpath31-TypeDeclaration" id=
"noid_d3e8864.doc-xpath31-TypeDeclaration"></a>[78]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xpath31-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8865.doc-xpath31-EnclosedExpr" id=
"noid_d3e8865.doc-xpath31-EnclosedExpr"></a>[5]&#160;&#160;&#160;</td>
<td><code>EnclosedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#doc-xpath31-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8866.doc-xpath31-FunctionBody" id=
"noid_d3e8866.doc-xpath31-FunctionBody"></a>[4]&#160;&#160;&#160;</td>
<td><code>FunctionBody</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-inline-func" id="dt-inline-func" title=
"inline function expression">Definition</a>: An <b>inline function
expression</b> creates an anonymous <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
defined directly in the inline function expression itself.] An
inline function expression specifies the names and SequenceTypes of
the parameters to the function, the SequenceType of the result, and
the body of the function.</p>
<p>If a function parameter is declared using a name but no type,
its default type is item()*. If the result type is omitted from an
inline function expression, its default result type is item()*.</p>
<p>The parameters of an inline function expression are considered
to be variables whose scope is the function body. It is a static
error [<a href="#ERRXQST0039" title=
"err:XQST0039">err:XQST0039</a>] for an inline function expression
to have more than one parameter with the same name.</p>
<p>The static context for the function body is inherited from the
location of the inline function expression, with the exception of
the static type of the context item which is initially <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</p>
<p>The variables in scope for the function body include all
variables representing the function parameters, as well as all
variables that are in scope for the inline function expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Function parameter names can mask variables that would otherwise
be in scope for the function body.</p>
</div>
<p>The result of an inline function expression is a single function
with the following properties (as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#function-items">Section
2.8.1 Functions</a> <sup><small>DM31</small></sup>):</p>
<ul>
<li>
<p><b>name</b>: An absent name. Absent.</p>
</li>
<li>
<p><b>parameter names</b>: The parameter names in the
<code>InlineFunctionExpr</code>'s <code>ParamList</code>.</p>
</li>
<li>
<p><b>signature</b>: A <code>FunctionTest</code> constructed from
the <code>SequenceType</code>s in the
<code>InlineFunctionExpr</code>.</p>
</li>
<li>
<p><b>implementation</b>: The <code>InlineFunctionExpr</code>'s
<code>FunctionBody</code>.</p>
</li>
<li>
<p><b>nonlocal variable bindings</b>: For each nonlocal variable, a
binding of it to its value in the <a title="variable values" href=
"#dt-variable-values">variable values</a> component of the dynamic
context of the <code>InlineFunctionExpr</code>.</p>
</li>
</ul>
<p>The following are examples of some inline function
expressions:</p>
<ul>
<li>
<p>This example creates a function that takes no arguments and
returns a sequence of the first 6 primes:</p>
<div class="exampleInner">
<pre>
function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }
</pre></div>
</li>
<li>
<p>This example creates a function that takes two xs:double
arguments and returns their product:</p>
<div class="exampleInner">
<pre>
function($a as xs:double, $b as xs:double) as xs:double { $a * $b }
</pre></div>
</li>
<li>
<p>This example creates a function that returns its item()*
argument:</p>
<div class="exampleInner">
<pre>
function($a) { $a }
</pre></div>
</li>
<li>
<p>This example creates a sequence of functions each of which
returns a different node from the default collection.</p>
<div class="exampleInner">
<pre>
collection()/(let $a := . return function() { $a })
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-postfix-expression" id=
"id-postfix-expression"></a>3.2 Postfix Expressions</h3>
<h5><a name="d2e9815" id="d2e9815"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-PostfixExpr" id=
"doc-xpath31-PostfixExpr"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-PostfixExpr">PostfixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xpath31-Predicate">Predicate</a> | <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a> | <a href=
"#doc-xpath31-MapLookup">MapLookup</a> | <a href=
"#doc-xpath31-ArrowPostfix">ArrowPostfix</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8990.doc-xpath31-Predicate" id=
"noid_d3e8990.doc-xpath31-Predicate"></a>[51]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xpath31-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e8991.doc-xpath31-ArgumentList" id=
"noid_d3e8991.doc-xpath31-ArgumentList"></a>[49]&#160;&#160;&#160;</td>
<td><code>ArgumentList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xpath31-Argument">Argument</a> (","
<a href="#doc-xpath31-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-filter-expression" id="dt-filter-expression" title=
"filter expression">Definition</a>: An expression followed by a
predicate (that is, <code>E1[E2]</code>) is referred to as a
<b>filter expression</b>: its effect is to return those items from
the value of <code>E1</code> that satisfy the predicate in E2.]
Filter expressions are described in <a href=
"#id-filter-expression"><b>3.2.1 Filter Expressions</b></a></p>
<p>An expression (other than a raw EQName) followed by an argument
list in parentheses (that is, <code>E1(E2, E3, ...)</code>) is
referred to as a <a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic function call</a>. Its
effect is to evaluate <code>E1</code> to obtain a function, and
then call that function, with <code>E2</code>, <code>E3</code>,
<code>...</code> as arguments. Dynamic function are described in
<a href="#id-dynamic-function-invocation"><b>3.2.2 Dynamic Function
Call</b></a>.</p>
<div class="div3">
<h4><a name="id-filter-expression" id=
"id-filter-expression"></a>3.2.1 Filter Expressions</h4>
<h5><a name="d2e9898" id="d2e9898"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9036.doc-xpath31-PostfixExpr" id=
"noid_d3e9036.doc-xpath31-PostfixExpr"></a>[48]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xpath31-Predicate">Predicate</a> | <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a> | <a href=
"#doc-xpath31-MapLookup">MapLookup</a> | <a href=
"#doc-xpath31-ArrowPostfix">ArrowPostfix</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Predicate" id=
"doc-xpath31-Predicate"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xpath31-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>A filter expression consists of a base expression followed by a
predicate, which is an expression written in square brackets. The
result of the filter expression consists of the items returned by
the base expression, filtered by applying the predicate to each
item in turn. The ordering of the items returned by a filter
expression is the same as their order in the result of the primary
expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Where the expression before the square brackets is a <a href=
"#doc-xpath31-ReverseStep">ReverseStep</a> or <a href=
"#doc-xpath31-ForwardStep">ForwardStep</a>, the expression is
technically not a filter expression but an <a href=
"#doc-xpath31-AxisStep">AxisStep</a>. There are minor differences
in the semantics: see <a href="#id-predicate"><b>3.3.3 Predicates
within Steps</b></a></p>
</div>
<p>Here are some examples of filter expressions:</p>
<ul>
<li>
<p>Given a sequence of products in a variable, return only those
products whose price is greater than 100.</p>
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</li>
<li>
<p>List all the integers from 1 to 100 that are divisible by 5.
(See <a href="#construct_seq"><b>3.4.1 Constructing
Sequences</b></a> for an explanation of the <code>to</code>
operator.)</p>
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</li>
<li>
<p>The result of the following expression is the integer 25:</p>
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</li>
<li>
<p>The following example returns the fifth through ninth items in
the sequence bound to variable <code>$orders</code>.</p>
<div class="exampleInner">
<pre>
$orders[fn:position() = (5 to 9)]
</pre></div>
</li>
<li>
<p>The following example illustrates the use of a filter expression
as a <a title="step" href="#dt-step">step</a> in a <a title=
"path expression" href="#dt-path-expression">path expression</a>.
It returns the last chapter or appendix within the book bound to
variable <code>$book</code>:</p>
<div class="exampleInner">
<pre>
$book/(chapter | appendix)[fn:last()]
</pre></div>
</li>
</ul>
<p>For each item in the input sequence, the predicate expression is
evaluated using an <b>inner focus</b>, defined as follows: The
context item is the item currently being tested against the
predicate. The context size is the number of items in the input
sequence. The context position is the position of the context item
within the input sequence.</p>
<p>For each item in the input sequence, the result of the predicate
expression is coerced to an <code>xs:boolean</code> value, called
the <b>predicate truth value</b>, as described below. Those items
for which the predicate truth value is <code>true</code> are
retained, and those for which the predicate truth value is
<code>false</code> are discarded.</p>
<p>The predicate truth value is derived by applying the following
rules, in order:</p>
<ol class="enumar">
<li>
<p>If the value of the predicate expression is a <a title=
"singleton" href="#dt-singleton">singleton</a> atomic value of a
<a title="numeric" href="#dt-numeric">numeric</a> type or derived
from a <a title="numeric" href="#dt-numeric">numeric</a> type, the
predicate truth value is <code>true</code> if the value of the
predicate expression is equal (by the <code>eq</code> operator) to
the <b>context position</b>, and is <code>false</code> otherwise.
[<a name="dt-numeric-predicate" id="dt-numeric-predicate" title=
"numeric predicate">Definition</a>: A predicate whose predicate
expression returns a numeric type is called a <b>numeric
predicate</b>.]</p>
</li>
<li>
<p>Otherwise, the predicate truth value is the <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of the predicate expression.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-dynamic-function-invocation" id=
"id-dynamic-function-invocation"></a>3.2.2 Dynamic Function
Call</h4>
<h5><a name="d2e10051" id="d2e10051"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9163.doc-xpath31-PostfixExpr" id=
"noid_d3e9163.doc-xpath31-PostfixExpr"></a>[48]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xpath31-Predicate">Predicate</a> | <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a> | <a href=
"#doc-xpath31-MapLookup">MapLookup</a> | <a href=
"#doc-xpath31-ArrowPostfix">ArrowPostfix</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ArgumentList" id=
"doc-xpath31-ArgumentList"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ArgumentList">ArgumentList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#doc-xpath31-Argument">Argument</a> (","
<a href="#doc-xpath31-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9165.doc-xpath31-Argument" id=
"noid_d3e9165.doc-xpath31-Argument"></a>[64]&#160;&#160;&#160;</td>
<td><code>Argument</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ExprSingle">ExprSingle</a> |
<a href=
"#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9166.doc-xpath31-ArgumentPlaceholder" id=
"noid_d3e9166.doc-xpath31-ArgumentPlaceholder"></a>[65]&#160;&#160;&#160;</td>
<td><code>ArgumentPlaceholder</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-dynamic-function-invocation" id=
"dt-dynamic-function-invocation" title=
"dynamic function call">Definition</a>: A <b>dynamic function
call</b> consists of a base expression that returns the function
and a parenthesized list of zero or more arguments (<a title=
"argument expression" href="#dt-arg-expr">argument expressions</a>
or ArgumentPlaceholders).]</p>
<p>A dynamic function call is evaluated as described in <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a>.</p>
<p>The following are examples of some dynamic function calls:</p>
<ul>
<li>
<p>This example invokes the function contained in $f, passing the
arguments 2 and 3:</p>
<div class="exampleInner">
<pre>
$f(2, 3)
</pre></div>
</li>
<li>
<p>This example fetches the second item from sequence $f, treats it
as a function and invokes it, passing an <code>xs:string</code>
argument:</p>
<div class="exampleInner">
<pre>
$f[2]("Hi there")
</pre></div>
</li>
<li>
<p>This example invokes the function $f passing no arguments, and
filters the result with a positional predicate:</p>
<div class="exampleInner">
<pre>
$f()[2]
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-arrow-operator" id="id-arrow-operator"></a>3.2.3
Arrow operator (<code>=&gt;</code>)</h4>
<h5><a name="d2e10145" id="d2e10145"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9214.doc-xpath31-PostfixExpr" id=
"noid_d3e9214.doc-xpath31-PostfixExpr"></a>[48]&#160;&#160;&#160;</td>
<td><code>PostfixExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PrimaryExpr">PrimaryExpr</a>
(<a href="#doc-xpath31-Predicate">Predicate</a> | <a href=
"#doc-xpath31-ArgumentList">ArgumentList</a> | <a href=
"#doc-xpath31-MapLookup">MapLookup</a> | <a href=
"#doc-xpath31-ArrowPostfix">ArrowPostfix</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ArrowPostfix" id=
"doc-xpath31-ArrowPostfix"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ArrowPostfix">ArrowPostfix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=&gt;" <a href=
"#prod-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a>
<a href="#doc-xpath31-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-arrow-operator" id="dt-arrow-operator" title=
"arrow operator">Definition</a>: An <b>arrow operator</b> is a
postfix operator that applies a function to an item, using the item
as the first argument to the function.] If <code>$i</code> is an
item and <code>f()</code> is a function, then
<code>$i=&gt;f()</code> is equivalent to <code>f($i)</code>, and
<code>$i=&gt;f($j)</code> is equivalent to <code>f($i,
$j)</code>.</p>
<p>This syntax is particularly helpful when conventional function
call syntax is unreadable, e.g. when applying multiple functions to
an item. For instance, the following expression is difficult to
read due to the nesting of parentheses, and invites syntax errors
due to unbalanced parentheses:</p>
<div class="exampleInner">
<pre>
tokenize((normalize-unicode(upper-case($string))),"\s+")
</pre></div>
<p>Many people consider the following expression easier to read,
and it is much easier to see that the parentheses are balanced:</p>
<div class="exampleInner">
<pre>
$string=&gt;upper-case()=&gt;normalize-unicode()=&gt;tokenize("\s+")
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>3.3
Path Expressions</h3>
<h5><a name="d2e10216" id="d2e10216"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-PathExpr" id=
"doc-xpath31-PathExpr"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#doc-xpath31-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xpath31-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9257.doc-xpath31-RelativePathExpr" id=
"noid_d3e9257.doc-xpath31-RelativePathExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code>RelativePathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-StepExpr">StepExpr</a> (("/" |
"//") <a href="#doc-xpath31-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-path-expression" id="dt-path-expression" title=
"path expression">Definition</a>: A <b>path expression</b> can be
used to locate nodes within trees. A path expression consists of a
series of one or more <a title="step" href="#dt-step">steps</a>,
separated by "<code>/</code>" or "<code>//</code>", and optionally
beginning with "<code>/</code>" or "<code>//</code>".] An initial
"<code>/</code>" or "<code>//</code>" is an abbreviation for one or
more initial steps that are implicitly added to the beginning of
the path expression, as described below.</p>
<p>A path expression consisting of a single step is evaluated as
described in <a href="#id-steps"><b>3.3.2 Steps</b></a>.</p>
<p>A "<code>/</code>" at the beginning of a path expression is an
abbreviation for the initial step <code>(fn:root(self::node())
treat as document-node())/</code> (however, if the "<code>/</code>"
is the entire path expression, the trailing "<code>/</code>" is
omitted from the expansion.) The effect of this initial step is to
begin the path at the root node of the tree that contains the
context node. If the context item is not a node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. At
evaluation time, if the root node above the context node is not a
document node, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
<p>A "<code>//</code>" at the beginning of a path expression is an
abbreviation for the initial steps <code>(fn:root(self::node())
treat as document-node())/descendant-or-self::node()/</code>
(however, "<code>//</code>" by itself is not a valid path
expression [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>].) The effect of these initial
steps is to establish an initial node sequence that contains the
root of the tree in which the context node is found, plus all nodes
descended from this root. This node sequence is used as the input
to subsequent steps in the path expression. If the context item is
not a node, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. At evaluation time, if the root
node above the context node is not a document node, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised [<a href="#ERRXPDY0050" title=
"err:XPDY0050">err:XPDY0050</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The descendants of a node do not include attribute nodes
<span class="xpath">or namespace nodes</span>.</p>
</div>
<div class="div3">
<h4><a name="id-relative-path-expressions" id=
"id-relative-path-expressions"></a>3.3.1 Relative Path
Expressions</h4>
<h5><a name="d2e10339" id="d2e10339"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-RelativePathExpr" id=
"doc-xpath31-RelativePathExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-StepExpr">StepExpr</a> (("/" |
"//") <a href="#doc-xpath31-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>Relative path expressions are binary operators on step
expressions, which are named <code>E1</code> and <code>E2</code> in
this section.</p>
<p>Each non-initial occurrence of "<code>//</code>" in a path
expression is expanded as described in <a href="#abbrev"><b>3.3.5
Abbreviated Syntax</b></a>, leaving a sequence of steps separated
by "<code>/</code>". This sequence of steps is then evaluated from
left to right. Each item produced by the evaluation of
<code>E1</code> is used as the <a title="context item" href=
"#dt-context-item">context item</a> to evaluate <code>E2</code>;
the sequences resulting from all the evaluations of <code>E2</code>
are combined to produce a result.</p>
<p>The following example illustrates the use of relative path
expressions.</p>
<div class="exampleOuter">
<ul>
<li>
<p><code>child::div1/child::para</code></p>
<p>Selects the <code>para</code> element children of the
<code>div1</code> element children of the context node; that is,
the <code>para</code> element grandchildren of the context node
that have <code>div1</code> parents.</p>
</li>
</ul>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since each step in a path provides context nodes for the
following step, in effect, only the last step in a path is allowed
to return a sequence of non-nodes.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">The "<code>/</code>" character can be used
either as a complete path expression or as the beginning of a
longer path expression such as "<code>/*</code>". Also,
"<code>*</code>" is both the multiply operator and a wildcard in
path expressions. This can cause parsing difficulties when
"<code>/</code>" appears on the left-hand side of "<code>*</code>".
This is resolved using the <a href=
"#parse-note-leading-lone-slash">leading-lone-slash</a> constraint.
For example, "<code>/*</code>" and "<code>/ *</code>" are valid
path expressions containing wildcards, but "<code>/*5</code>" and
"<code>/ * 5</code>" raise syntax errors. Parentheses must be used
when "<code>/</code>" is used on the left-hand side of an operator,
as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>"
raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid
expression. The expression "<code>4 + /</code>" is also valid,
because <code>/</code> does not occur on the left-hand side of the
operator.</p>
<p>Similarly, in the expression <code>/ union /*</code>, "union" is
interpreted as an element name rather than an operator. For it to
be parsed as an operator, the expression should be written
<code>(/) union /*</code>.</p>
</div>
<div class="div4">
<h5><a name="id-path-operator" id="id-path-operator"></a>3.3.1.1
Path operator (<code>/</code>)</h5>
<p>The path operator "/" is used to build expressions for locating
nodes within trees. Its left-hand side expression must return a
sequence of nodes. The operator returns either a sequence of nodes,
in which case it additionally performs document ordering and
duplicate elimination, or a sequence of non-nodes.</p>
<p>Each operation <code>E1/E2</code> is evaluated as follows:
Expression <code>E1</code> is evaluated, and if the result is not a
(possibly empty) sequence <code>S</code> of nodes, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0019" title="err:XPTY0019">err:XPTY0019</a>].
Each node in <code>S</code> then serves in turn to provide an inner
focus (the node as the context item, its position in <code>S</code>
as the context position, the length of <code>S</code> as the
context size) for an evaluation of <code>E2</code>, as described in
<a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The
sequences resulting from all the evaluations of <code>E2</code> are
combined as follows:</p>
<ol class="enumar">
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of nodes, these sequences are combined, and
duplicate nodes are eliminated based on node identity. <span class=
"xpath">The resulting node sequence is returned in <a title=
"document order" href="#dt-document-order">document
order</a>.</span></p>
</li>
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of non-nodes, these sequences are
concatenated<span class="xpath">, in order,</span> and
returned.</p>
</li>
<li>
<p>If the multiple evaluations of <code>E2</code> return at least
one node and at least one non-node, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0018"
title="err:XPTY0018">err:XPTY0018</a>].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The semantics of the path operator can also be defined using the
simple mapping operator as follows (forming the union with an empty
sequence <code>($R | ())</code> has the effect of eliminating
duplicates and sorting nodes into document order):</p>
<div class="exampleInner">
<pre>
E1/E2 ::= let $R := E1!E2
  return
    if (every $r in $R satisfies $r instance of node())
    then ($R|())
    else if (every $r in $R satisfies not($r instance of node()))
    then $R
    else error()
</pre></div>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-steps" id="id-steps"></a>3.3.2 Steps</h4>
<h5><a name="d2e10557" id="d2e10557"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-StepExpr" id=
"doc-xpath31-StepExpr"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PostfixExpr">PostfixExpr</a> |
<a href="#doc-xpath31-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9561.doc-xpath31-AxisStep" id=
"noid_d3e9561.doc-xpath31-AxisStep"></a>[38]&#160;&#160;&#160;</td>
<td><code>AxisStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath31-ReverseStep">ReverseStep</a> |
<a href="#doc-xpath31-ForwardStep">ForwardStep</a>) <a href=
"#doc-xpath31-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ForwardStep" id=
"doc-xpath31-ForwardStep"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath31-ForwardAxis">ForwardAxis</a>
<a href="#doc-xpath31-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ReverseStep" id=
"doc-xpath31-ReverseStep"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath31-ReverseAxis">ReverseAxis</a>
<a href="#doc-xpath31-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9564.doc-xpath31-PredicateList" id=
"noid_d3e9564.doc-xpath31-PredicateList"></a>[50]&#160;&#160;&#160;</td>
<td><code>PredicateList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-step" id="dt-step" title="step">Definition</a>: A
<b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=""
href="#dt-predicate">predicates</a>. The value of the step consists
of those items that satisfy the predicates, working from left to
right. A step may be either an <a title="axis step" href=
"#dt-axis-step">axis step</a> or a postfix expression.] Postfix
expressions are described in <a href=
"#id-postfix-expression"><b>3.2 Postfix Expressions</b></a>.</p>
<p>[<a name="dt-axis-step" id="dt-axis-step" title=
"axis step">Definition</a>: An <b>axis step</b> returns a sequence
of nodes that are reachable from the context node via a specified
axis. Such a step has two parts: an <b>axis</b>, which defines the
"direction of movement" for the step, and a <a title="node test"
href="#dt-node-test">node test</a>, which selects nodes based on
their kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] If the context item is
a node, an axis step returns a sequence of zero or more nodes;
otherwise, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. <span class="xpath">The resulting
node sequence is returned in <a title="document order" href=
"#dt-document-order">document order</a>.</span> An axis step may be
either a <b>forward step</b> or a <b>reverse step</b>, followed by
zero or more <a title="" href="#dt-predicate">predicates</a>.</p>
<p>In the <b>abbreviated syntax</b> for a step, the axis can be
omitted and other shorthand notations can be used as described in
<a href="#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.</p>
<p>The unabbreviated syntax for an axis step consists of the axis
name and node test separated by a double colon. The result of the
step consists of the nodes reachable from the context node via the
specified axis that have the node kind, name, and/or <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
specified by the node test. For example, the step
<code>child::para</code> selects the <code>para</code> element
children of the context node: <code>child</code> is the name of the
axis, and <code>para</code> is the name of the element nodes to be
selected on this axis. The available axes are described in <a href=
"#axes"><b>3.3.2.1 Axes</b></a>. The available node tests are
described in <a href="#node-tests"><b>3.3.2.2 Node Tests</b></a>.
Examples of steps are provided in <a href="#unabbrev"><b>3.3.4
Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.3.5
Abbreviated Syntax</b></a>.</p>
<div class="div4">
<h5><a name="axes" id="axes"></a>3.3.2.1 Axes</h5>
<h5><a name="d2e10713" id="d2e10713"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ForwardAxis" id=
"doc-xpath31-ForwardAxis"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ReverseAxis" id=
"doc-xpath31-ReverseAxis"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p class="xpath">XPath defines a full set of <b>axes</b> for
traversing documents, but a <b>host language</b> may define a
subset of these axes. The following axes are defined:</p>
<ul>
<li>
<p>The <code>child</code> axis contains the children of the context
node, which are the nodes returned by the <code>dm:children</code>
accessor in <a href="#xpath-datamodel-31">[XQuery and XPath Data
Model (XDM) 3.1]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only document nodes and element nodes have children. If the
context node is any other kind of node, or if the context node is
an empty document or element node, then the child axis is an empty
sequence. The children of a document node or element node may be
element, processing instruction, comment, or text nodes.
Attribute<span class="xpath">, namespace,</span> and document nodes
can never appear as children.</p>
</div>
</li>
<li>
<p>the <code>descendant</code> axis is defined as the transitive
closure of the child axis; it contains the descendants of the
context node (the children, the children of the children, and so
on)</p>
</li>
<li>
<p>the <code>parent</code> axis contains the sequence returned by
the <code>dm:parent</code> accessor in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>,
which returns the parent of the context node, or an empty sequence
if the context node has no parent</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An attribute node may have an element node as its parent, even
though the attribute node is not a child of the element node.</p>
</div>
</li>
<li>
<p>the <code>ancestor</code> axis is defined as the transitive
closure of the parent axis; it contains the ancestors of the
context node (the parent, the parent of the parent, and so on)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ancestor axis includes the root node of the tree in which
the context node is found, unless the context node is the root
node.</p>
</div>
</li>
<li>
<p>the <code>following-sibling</code> axis contains the context
node's following siblings, those children of the context node's
parent that occur after the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute <span class="xpath">or
namespace</span> node, the <code>following-sibling</code> axis is
empty</p>
</li>
<li>
<p>the <code>preceding-sibling</code> axis contains the context
node's preceding siblings, those children of the context node's
parent that occur before the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute <span class="xpath">or
namespace</span> node, the <code>preceding-sibling</code> axis is
empty</p>
</li>
<li>
<p>the <code>following</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not descendants of the context node, and occur after the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>preceding</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not ancestors of the context node, and occur before the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>attribute</code> axis contains the attributes of the
context node, which are the nodes returned by the
<code>dm:attributes</code> accessor in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>;
the axis will be empty unless the context node is an element</p>
</li>
<li>
<p>the <code>self</code> axis contains just the context node
itself</p>
</li>
<li>
<p>the <code>descendant-or-self</code> axis contains the context
node and the descendants of the context node</p>
</li>
<li>
<p>the <code>ancestor-or-self</code> axis contains the context node
and the ancestors of the context node; thus, the ancestor-or-self
axis will always include the root node</p>
</li>
<li>
<p>the <code>namespace</code> axis contains the namespace nodes of
the context node, which are the nodes returned by the
<code>dm:namespace-nodes</code> accessor in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>;
this axis is empty unless the context node is an element node. The
<code>namespace</code> axis is deprecated as of XPath 2.0. If
<a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, the <code>namespace</code> axis must be
supported. If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code>, then support for the <code>namespace</code>
axis is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An
implementation that does not support the <code>namespace</code>
axis when <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code> must raise a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0010" title=
"err:XPST0010">err:XPST0010</a>] if it is used. Applications
needing information about the <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of an element
should use the functions <code>fn:in-scope-prefixes</code> and
<code>fn:namespace-uri-for-prefix</code> defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
</li>
</ul>
<p>Axes can be categorized as <b>forward axes</b> and <b>reverse
axes</b>. An axis that only ever contains the context node or nodes
that are after the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a forward axis. An axis
that only ever contains the context node or nodes that are before
the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a reverse axis.</p>
<p>The <code>parent</code>, <code>ancestor</code>,
<code>ancestor-or-self</code>, <code>preceding</code>, and
<code>preceding-sibling</code> axes are reverse axes; all other
axes are forward axes. The <code>ancestor</code>,
<code>descendant</code>, <code>following</code>,
<code>preceding</code> and <code>self</code> axes partition a
document (ignoring attribute <span class="xpath">and
namespace</span> nodes): they do not overlap and together they
contain all the nodes in the document.</p>
<p>[<a name="dt-principal-node-kind" id="dt-principal-node-kind"
title="principal node kind">Definition</a>: Every axis has a
<b>principal node kind</b>. If an axis can contain elements, then
the principal node kind is element; otherwise, it is the kind of
nodes that the axis can contain.] Thus:</p>
<ul>
<li>
<p>For the attribute axis, the principal node kind is
attribute.</p>
</li>
<li>
<p>For the namespace axis, the principal node kind is
namespace.</p>
</li>
<li>
<p>For all other axes, the principal node kind is element.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>3.3.2.2 Node
Tests</h5>
<p>[<a name="dt-node-test" id="dt-node-test" title=
"node test">Definition</a>: A <b>node test</b> is a condition on
the name, kind (element, attribute, text, document, comment, or
processing instruction), and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a> of a node. A node test
determines which nodes contained by an axis are selected by a
<a title="step" href="#dt-step">step</a>.]</p>
<h5><a name="d2e11029" id="d2e11029"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NodeTest" id=
"doc-xpath31-NodeTest"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-KindTest">KindTest</a> | <a href=
"#doc-xpath31-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NameTest" id=
"doc-xpath31-NameTest"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a> | <a href=
"#doc-xpath31-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-Wildcard" id=
"doc-xpath31-Wildcard"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath31-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath31-NCName">NCName</a>)<br />
| (<a href="#doc-xpath31-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e9948.doc-xpath31-EQName" id=
"noid_d3e9948.doc-xpath31-EQName"></a>[110]&#160;&#160;&#160;</td>
<td><code>EQName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-QName">QName</a> | <a href=
"#doc-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-name-test" id="dt-name-test" title=
"name test">Definition</a>: A node test that consists only of an
EQName or a Wildcard is called a <b>name test</b>.] A name test is
true if and only if the <b>kind</b> of the node is the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> for the step axis and the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the node is equal (as
defined by the <code>eq</code> operator) to the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a>
specified by the name test. For example, <code>child::para</code>
selects the <code>para</code> element children of the context node;
if the context node has no <code>para</code> children, it selects
an empty set of nodes. <code>attribute::abc:href</code> selects the
attribute of the context node with the QName <code>abc:href</code>;
if the context node has no such attribute, it selects an empty set
of nodes.</p>
<p>If the EQName is a <a title="lexical QName" href=
"#dt-qname">lexical QName</a>, it is resolved into an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> using
the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
expression context. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>] if the QName has a prefix that
does not correspond to any statically known namespace. An
unprefixed QName, when used as a name test on an axis whose
<a title="principal node kind" href=
"#dt-principal-node-kind">principal node kind</a> is element, has
the namespace URI of the <a title="default element/type namespace"
href="#dt-def-elemtype-ns">default element/type namespace</a> in
the expression context; otherwise, it has no namespace URI.</p>
<p>A name test is not satisfied by an element node whose name does
not match the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the name test, even if
it is in a <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> whose head is the
named element.</p>
<p>A node test <code>*</code> is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis. For example, <code>child::*</code> will
select all element children of the context node, and
<code>attribute::*</code> will select all attributes of the context
node.</p>
<p>A node test can have the form <code>NCName:*</code>. In this
case, the prefix is expanded in the same way as with a <a title=
"lexical QName" href="#dt-qname">lexical QName</a>, using the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
<a title="static context" href="#dt-static-context">static
context</a>. If the prefix is not found in the statically known
namespaces, a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>]. The node
test is true for any node of the <a title="principal node kind"
href="#dt-principal-node-kind">principal node kind</a> of the step
axis whose <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> has the namespace URI to
which the prefix is bound, regardless of the local part of the
name.</p>
<p>A node test can contain a BracedURILiteral, e.g.
<code>Q{http://example.com/msg}*</code> Such a node test is true
for any node of the principal node kind of the step axis whose
expanded QName has the namespace URI specified in the
BracedURILiteral, regardless of the local part of the name.</p>
<p>A node test can also have the form <code>*:NCName</code>. In
this case, the node test is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis whose local name matches the given
NCName, regardless of its namespace or lack of a namespace.</p>
<p>[<a name="dt-kind-test" id="dt-kind-test" title=
"kind test">Definition</a>: An alternative form of a node test
called a <b>kind test</b> can select nodes based on their kind,
name, and <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] The syntax and
semantics of a kind test are described in <a href=
"#id-sequencetype-syntax"><b>2.5.4 SequenceType Syntax</b></a> and
<a href="#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>. When a kind test is used in a <a title=
"node test" href="#dt-node-test">node test</a>, only those nodes on
the designated axis that match the kind test are selected. Shown
below are several examples of kind tests that might be used in path
expressions:</p>
<ul>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>element()</code> matches any element node.</p>
</li>
<li>
<p><code>schema-element(person)</code> matches any element node
whose name is <code>person</code> (or is in the <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> headed by <code>person</code>), and whose type annotation
is the same as (or is derived from) the declared type of the
<code>person</code> element in the <a title=
"in-scope element declarations" href="#dt-is-elems">in-scope
element declarations</a>.</p>
</li>
<li>
<p><code>element(person)</code> matches any element node whose name
is <code>person</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>element(person, surgeon)</code> matches any non-nilled
element node whose name is <code>person</code>, and whose type
annotation is <code>surgeon</code> or is derived from
<code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*, surgeon)</code> matches any non-nilled element
node whose type annotation is <code>surgeon</code> (or is derived
from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>attribute()</code> matches any attribute node.</p>
</li>
<li>
<p><code>attribute(price)</code> matches any attribute whose name
is <code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*, xs:decimal)</code> matches any attribute
whose type annotation is <code>xs:decimal</code> (or is derived
from <code>xs:decimal</code>), regardless of its name.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(element(book))</code> matches any document
node whose content consists of a single element node that satisfies
the <a title="kind test" href="#dt-kind-test">kind test</a>
<code>element(book)</code>, interleaved with zero or more comments
and processing instructions.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-predicate" id="id-predicate"></a>3.3.3 Predicates
within Steps</h4>
<h5><a name="d2e11365" id="d2e11365"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AxisStep" id=
"doc-xpath31-AxisStep"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath31-ReverseStep">ReverseStep</a> |
<a href="#doc-xpath31-ForwardStep">ForwardStep</a>) <a href=
"#doc-xpath31-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-PredicateList" id=
"doc-xpath31-PredicateList"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e10233.doc-xpath31-Predicate" id=
"noid_d3e10233.doc-xpath31-Predicate"></a>[51]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xpath31-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p id="dt-predicate">A predicate within a Step has similar syntax
and semantics to a predicate within a <a title="" href=
"#id-filter-expression">filter expression</a>. The only difference
is in the way the context position is set for evaluation of the
predicate.</p>
<p>For the purpose of evaluating the context position within a
predicate, the input sequence is considered to be sorted as
follows: into document order if the predicate is in a forward-axis
step, into reverse document order if the predicate is in a
reverse-axis step, or in its original order if the predicate is not
in a step.</p>
<p>Here are some examples of <a title="axis step" href=
"#dt-axis-step">axis steps</a> that contain predicates:</p>
<ul>
<li>
<p>This example selects the second <code>chapter</code> element
that is a child of the context node:</p>
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</li>
<li>
<p>This example selects all the descendants of the context node
that are elements named <code>"toy"</code> and whose
<code>color</code> attribute has the value <code>"red"</code>:</p>
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</li>
<li>
<p>This example selects all the <code>employee</code> children of
the context node that have both a <code>secretary</code> child
element and an <code>assistant</code> child element:</p>
<div class="exampleInner">
<pre>
child::employee[secretary][assistant]
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When using <a title="" href="#dt-predicate">predicates</a> with
a sequence of nodes selected using a <b>reverse axis</b>, it is
important to remember that the context positions for such a
sequence are assigned in <a title="reverse document order" href=
"#dt-reverse-document-order">reverse document order</a>. For
example, <code>preceding::foo[1]</code> returns the first
qualifying <code>foo</code> element in <a title=
"reverse document order" href="#dt-reverse-document-order">reverse
document order</a>, because the predicate is part of an <a title=
"axis step" href="#dt-axis-step">axis step</a> using a reverse
axis. By contrast, <code>(preceding::foo)[1]</code> returns the
first qualifying <code>foo</code> element in <a title=
"document order" href="#dt-document-order">document order</a>,
because the parentheses cause <code>(preceding::foo)</code> to be
parsed as a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a> in which context
positions are assigned in document order. Similarly,
<code>ancestor::*[1]</code> returns the nearest ancestor element,
because the <code>ancestor</code> axis is a reverse axis, whereas
<code>(ancestor::*)[1]</code> returns the root element (first
ancestor in document order).</p>
<p>The fact that a reverse-axis step assigns context positions in
reverse document order for the purpose of evaluating predicates
does not alter the fact that the final result of the step is always
in document order.</p>
</div>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>3.3.4 Unabbreviated
Syntax</h4>
<p>This section provides a number of examples of path expressions
in which the axis is explicitly specified in each <a title="step"
href="#dt-step">step</a>. The syntax used in these examples is
called the <b>unabbreviated syntax</b>. In many common cases, it is
possible to write path expressions more concisely using an
<b>abbreviated syntax</b>, as explained in <a href=
"#abbrev"><b>3.3.5 Abbreviated Syntax</b></a>.</p>
<ul>
<li>
<p><code>child::para</code> selects the <code>para</code> element
children of the context node</p>
</li>
<li>
<p><code>child::*</code> selects all element children of the
context node</p>
</li>
<li>
<p><code>child::text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>child::node()</code> selects all the children of the
context node. Note that no attribute nodes are returned, because
attributes are not children.</p>
</li>
<li>
<p><code>attribute::name</code> selects the <code>name</code>
attribute of the context node</p>
</li>
<li>
<p><code>attribute::*</code> selects all the attributes of the
context node</p>
</li>
<li>
<p><code>parent::node()</code> selects the parent of the context
node. If the context node is an attribute node, this expression
returns the element node (if any) to which the attribute node is
attached.</p>
</li>
<li>
<p><code>descendant::para</code> selects the <code>para</code>
element descendants of the context node</p>
</li>
<li>
<p><code>ancestor::div</code> selects all <code>div</code>
ancestors of the context node</p>
</li>
<li>
<p><code>ancestor-or-self::div</code> selects the <code>div</code>
ancestors of the context node and, if the context node is a
<code>div</code> element, the context node as well</p>
</li>
<li>
<p><code>descendant-or-self::para</code> selects the
<code>para</code> element descendants of the context node and, if
the context node is a <code>para</code> element, the context node
as well</p>
</li>
<li>
<p><code>self::para</code> selects the context node if it is a
<code>para</code> element, and otherwise returns an empty
sequence</p>
</li>
<li>
<p><code>child::chapter/descendant::para</code> selects the
<code>para</code> element descendants of the <code>chapter</code>
element children of the context node</p>
</li>
<li>
<p><code>child::*/child::para</code> selects all <code>para</code>
grandchildren of the context node</p>
</li>
<li>
<p><code>/</code> selects the root of the tree that contains the
context node, but raises a dynamic error if this root is not a
document node</p>
</li>
<li>
<p><code>/descendant::para</code> selects all the <code>para</code>
elements in the same document as the context node</p>
</li>
<li>
<p><code>/descendant::list/child::member</code> selects all the
<code>member</code> elements that have a <code>list</code> parent
and that are in the same document as the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = 1]</code> selects the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()]</code> selects the
last <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()-1]</code> selects
the last but one <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() &gt; 1]</code> selects all the
<code>para</code> children of the context node other than the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() = 1]</code>
selects the next <code>chapter</code> sibling of the context
node</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() = 1]</code>
selects the previous <code>chapter</code> sibling of the context
node</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() = 42]</code> selects the
forty-second <code>figure</code> element in the document containing
the context node</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() = 2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>child::para[attribute::type eq "warning"]</code> selects
all <code>para</code> children of the context node that have a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[attribute::type eq 'warning'][fn:position() =
5]</code> selects the fifth <code>para</code> child of the context
node that has a <code>type</code> attribute with value
<code>warning</code></p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type eq
"warning"]</code> selects the fifth <code>para</code> child of the
context node if that child has a <code>type</code> attribute with
value <code>warning</code></p>
</li>
<li>
<p><code>child::chapter[child::title = 'Introduction']</code>
selects the <code>chapter</code> children of the context node that
have one or more <code>title</code> children whose <a title=
"typed value" href="#dt-typed-value">typed value</a> is equal to
the string <code>Introduction</code></p>
</li>
<li>
<p><code>child::chapter[child::title]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix]</code> selects
the <code>chapter</code> and <code>appendix</code> children of the
context node</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code> selects the last <code>chapter</code> or
<code>appendix</code> child of the context node</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>3.3.5 Abbreviated Syntax</h4>
<h5><a name="d2e11848" id="d2e11848"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AbbrevForwardStep" id=
"doc-xpath31-AbbrevForwardStep"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#doc-xpath31-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AbbrevReverseStep" id=
"doc-xpath31-AbbrevReverseStep"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>The abbreviated syntax permits the following abbreviations:</p>
<ol class="enumar">
<li>
<p>The attribute axis <code>attribute::</code> can be abbreviated
by <code>@</code>. For example, a path expression
<code>para[@type="warning"]</code> is short for
<code>child::para[attribute::type="warning"]</code> and so selects
<code>para</code> children with a <code>type</code> attribute with
value equal to <code>warning</code>.</p>
</li>
<li>
<p>If the axis name is omitted from an <a title="axis step" href=
"#dt-axis-step">axis step</a>, the default axis is
<code>child</code>, with two exceptions: if the <a href=
"#doc-xpath31-NodeTest">NodeTest</a> in an axis step contains an
<a href="#doc-xpath31-AttributeTest">AttributeTest</a> or <a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a> then the
default axis is <code>attribute</code>; if the <a href=
"#doc-xpath31-NodeTest">NodeTest</a> in an axis step is a <a href=
"#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a> then a
static error is raised [<a href="#ERRXQST0134" title=
"err:XQST0134">err:XQST0134</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In an implementation that does not support the namespace axis,
an attempt to access it always raises an error. Thus, an XQuery
implementation will always raise an error in this case, since
XQuery does not support the namespace axis. The namespace axis is
deprecated as of XPath 2.0, but required in some languages that use
XPath, including XSLT.</p>
</div>
<p>For example, the path expression <code>section/para</code> is an
abbreviation for <code>child::section/child::para</code>, and the
path expression <code>section/@id</code> is an abbreviation for
<code>child::section/attribute::id</code>. Similarly,
<code>section/attribute(id)</code> is an abbreviation for
<code>child::section/attribute::attribute(id)</code>. Note that the
latter expression contains both an axis specification and a
<a title="node test" href="#dt-node-test">node test</a>.</p>
</li>
<li>
<p>Each non-initial occurrence of <code>//</code> is effectively
replaced by <code>/descendant-or-self::node()/</code> during
processing of a path expression. For example,
<code>div1//para</code> is short for
<code>child::div1/descendant-or-self::node()/child::para</code> and
so will select all <code>para</code> descendants of
<code>div1</code> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The path expression <code>//para[1]</code> does <em>not</em>
mean the same as the path expression
<code>/descendant::para[1]</code>. The latter selects the first
descendant <code>para</code> element; the former selects all
descendant <code>para</code> elements that are the first
<code>para</code> children of their respective parents.</p>
</div>
</li>
<li>
<p>A step consisting of <code>..</code> is short for
<code>parent::node()</code>. For example, <code>../title</code> is
short for <code>parent::node()/child::title</code> and so will
select the <code>title</code> children of the parent of the context
node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The expression <code>.</code>, known as a <b>context item
expression</b>, is a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a>, and is described
in <a href="#id-context-item-expression"><b>3.1.4 Context Item
Expression</b></a>.</p>
</div>
</li>
</ol>
<p>Here are some examples of path expressions that use the
abbreviated syntax:</p>
<ul>
<li>
<p><code>para</code> selects the <code>para</code> element children
of the context node</p>
</li>
<li>
<p><code>*</code> selects all element children of the context
node</p>
</li>
<li>
<p><code>text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>@name</code> selects the <code>name</code> attribute of
the context node</p>
</li>
<li>
<p><code>@*</code> selects all the attributes of the context
node</p>
</li>
<li>
<p><code>para[1]</code> selects the first <code>para</code> child
of the context node</p>
</li>
<li>
<p><code>para[fn:last()]</code> selects the last <code>para</code>
child of the context node</p>
</li>
<li>
<p><code>*/para</code> selects all <code>para</code> grandchildren
of the context node</p>
</li>
<li>
<p><code>/book/chapter[5]/section[2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>chapter//para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the
context node</p>
</li>
<li>
<p><code>//para</code> selects all the <code>para</code>
descendants of the root document node and thus selects all
<code>para</code> elements in the same document as the context
node</p>
</li>
<li>
<p><code>//@version</code> selects all the <code>version</code>
attribute nodes that are in the same document as the context
node</p>
</li>
<li>
<p><code>//list/member</code> selects all the <code>member</code>
elements in the same document as the context node that have a
<code>list</code> parent</p>
</li>
<li>
<p><code>.//para</code> selects the <code>para</code> element
descendants of the context node</p>
</li>
<li>
<p><code>..</code> selects the parent of the context node</p>
</li>
<li>
<p><code>../@lang</code> selects the <code>lang</code> attribute of
the parent of the context node</p>
</li>
<li>
<p><code>para[@type="warning"]</code> selects all <code>para</code>
children of the context node that have a <code>type</code>
attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[@type="warning"][5]</code> selects the fifth
<code>para</code> child of the context node that has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[5][@type="warning"]</code> selects the fifth
<code>para</code> child of the context node if that child has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>chapter[title="Introduction"]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <a title="typed value" href=
"#dt-typed-value">typed value</a> is equal to the string
<code>Introduction</code></p>
</li>
<li>
<p><code>chapter[title]</code> selects the <code>chapter</code>
children of the context node that have one or more
<code>title</code> children</p>
</li>
<li>
<p><code>employee[@secretary and @assistant]</code> selects all the
<code>employee</code> children of the context node that have both a
<code>secretary</code> attribute and an <code>assistant</code>
attribute</p>
</li>
<li>
<p><code>book/(chapter|appendix)/section</code> selects every
<code>section</code> element that has a parent that is either a
<code>chapter</code> or an <code>appendix</code> element, that in
turn is a child of a <code>book</code> element that is a child of
the context node.</p>
</li>
<li>
<p>If <code>E</code> is any expression that returns a sequence of
nodes, then the expression <code>E/.</code> returns the same nodes
in <a title="document order" href="#dt-document-order">document
order</a>, with duplicates eliminated based on node identity.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>3.4 Sequence Expressions</h3>
<p>XPath 3.1 supports operators to construct, filter, and combine
<a title="sequence" href="#dt-sequence">sequences</a> of <a title=
"item" href="#dt-item">items</a>. Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>,
and <code>( )</code> into a single sequence results in the sequence
<code>(1, 2, 3)</code>.</p>
<div class="div3">
<h4><a name="construct_seq" id="construct_seq"></a>3.4.1
Constructing Sequences</h4>
<h5><a name="d2e12323" id="d2e12323"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e11151.doc-xpath31-Expr" id=
"noid_d3e11151.doc-xpath31-Expr"></a>[6]&#160;&#160;&#160;</td>
<td><code>Expr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-RangeExpr" id=
"doc-xpath31-RangeExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#doc-xpath31-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-comma-operator" id="dt-comma-operator" title=
"comma operator">Definition</a>: One way to construct a sequence is
by using the <b>comma operator</b>, which evaluates each of its
operands and concatenates the resulting sequences, in order, into a
single result sequence.] Empty parentheses can be used to denote an
empty sequence.</p>
<p>A sequence may contain duplicate <a title="item" href=
"#dt-item">items</a>, but a sequence is never an item in another
sequence. When a new sequence is created by concatenating two or
more input sequences, the new sequence contains all the items of
the input sequences and its length is the sum of the lengths of the
input sequences.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In places where the grammar calls for <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a>, such as the arguments of
a function call, any expression that contains a top-level comma
operator must be enclosed in parentheses.</p>
</div>
<p>Here are some examples of expressions that construct
sequences:</p>
<ul>
<li>
<p>The result of this expression is a sequence of five
integers:</p>
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</li>
<li>
<p>This expression combines four sequences of length one, two,
zero, and two, respectively, into a single sequence of length five.
The result of this expression is the sequence <code>10, 1, 2, 3,
4</code>.</p>
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</li>
<li>
<p>The result of this expression is a sequence containing all
<code>salary</code> children of the context node followed by all
<code>bonus</code> children.</p>
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</li>
<li>
<p>Assuming that <code>$price</code> is bound to the value
<code>10.50</code>, the result of this expression is the sequence
<code>10.50, 10.50</code>.</p>
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</li>
</ul>
<p>A <b>range expression</b> can be used to construct a sequence of
consecutive integers. Each of the operands of the <code>to</code>
operator is converted as though it was an argument of a function
with the expected parameter type <code>xs:integer?</code>. If
either operand is an empty sequence, or if the integer derived from
the first operand is greater than the integer derived from the
second operand, the result of the range expression is an empty
sequence. If the two operands convert to the same integer, the
result of the range expression is that integer. Otherwise, the
result is a sequence containing the two integer operands and every
integer between the two operands, in increasing order.</p>
<ul>
<li>
<p>This example uses a range expression as one operand in
constructing a sequence. It evaluates to the sequence <code>10, 1,
2, 3, 4</code>.</p>
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</li>
<li>
<p>This example constructs a sequence of length one containing the
single integer <code>10</code>.</p>
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</li>
<li>
<p>The result of this example is a sequence of length zero.</p>
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</li>
<li>
<p>This example uses the <code>fn:reverse</code> function to
construct a sequence of six integers in decreasing order. It
evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p>
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="combining_seq" id="combining_seq"></a>3.4.2 Combining
Node Sequences</h4>
<h5><a name="d2e12454" id="d2e12454"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-UnionExpr" id=
"doc-xpath31-UnionExpr"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-IntersectExceptExpr" id=
"doc-xpath31-IntersectExceptExpr"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#doc-xpath31-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XPath 3.1 provides the following operators for combining
sequences of nodes:</p>
<ul>
<li>
<p>The <code>union</code> and <code>|</code> operators are
equivalent. They take two node sequences as operands and return a
sequence containing all the nodes that occur in either of the
operands.</p>
</li>
<li>
<p>The <code>intersect</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in both operands.</p>
</li>
<li>
<p>The <code>except</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in the first operand but not in the second operand.</p>
</li>
</ul>
<p>All these operators eliminate duplicate nodes from their result
sequences based on node identity. <span class="xpath">The resulting
sequence is returned in <a title="document order" href=
"#dt-document-order">document order</a>.</span></p>
<p>If an operand of <code>union</code>, <code>intersect</code>, or
<code>except</code> contains an item that is not a node, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<p>If an IntersectExceptExpr contains more than two
InstanceofExprs, they are grouped from left to right. With a
UnionExpr, it makes no difference how operands are grouped, the
results are the same.</p>
<div class="exampleOuter">
<p>Here are some examples of expressions that combine sequences.
Assume the existence of three element nodes that we will refer to
by symbolic names A, B, and C. Assume that the variables
<code>$seq1</code>, <code>$seq2</code> and <code>$seq3</code> are
bound to the following sequences of these nodes:</p>
<ul>
<li>
<p><code>$seq1</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq2</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq3</code> is bound to (B, C)</p>
</li>
</ul>
<p>Then:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B,
C).</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code> evaluates to the sequence
containing B only.</p>
</li>
<li>
<p><code>$seq1 except $seq2</code> evaluates to the empty
sequence.</p>
</li>
<li>
<p><code>$seq2 except $seq3</code> evaluates to the sequence
containing A only.</p>
</li>
</ul>
</div>
<p>In addition to the sequence operators described here, <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of
items in a sequence, and for removing duplicate items from a
sequence.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-arithmetic" id="id-arithmetic"></a>3.5 Arithmetic
Expressions</h3>
<p>XPath 3.1 provides arithmetic operators for addition,
subtraction, multiplication, division, and modulus, in their usual
binary and unary forms.</p>
<h5><a name="d2e12607" id="d2e12607"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AdditiveExpr" id=
"doc-xpath31-AdditiveExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MultiplicativeExpr" id=
"doc-xpath31-MultiplicativeExpr"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xpath31-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-UnaryExpr" id=
"doc-xpath31-UnaryExpr"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#doc-xpath31-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ValueExpr" id=
"doc-xpath31-ValueExpr"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
</table>
<p>A subtraction operator must be preceded by whitespace if it
could otherwise be interpreted as part of the previous token. For
example, <code>a-b</code> will be interpreted as a name, but
<code>a - b</code> and <code>a -b</code> will be interpreted as
arithmetic expressions. (See <a href="#whitespace-rules"><b>A.2.4
Whitespace Rules</b></a> for further details on whitespace
handling.)</p>
<p>If an AdditiveExpr contains more than two MultiplicativeExprs,
they are grouped from left to right. So, for instance,</p>
<div class="exampleInner">
<pre>
A - B + C - D
</pre></div>
<p>is equivalent to</p>
<div class="exampleInner">
<pre>
((A - B) + C) - D
</pre></div>
<p>Similarly, the operands of a MultiplicativeExpr are grouped from
left to right.</p>
<p>The first step in evaluating an arithmetic expression is to
evaluate its operands. The order in which the operands are
evaluated is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, each operand is evaluated by applying the
following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
arithmetic expression is the <code>xs:double</code> value
<code>NaN</code>, and the implementation need not evaluate the
other operand or apply the operator. However, an implementation may
choose to evaluate the other operand in order to determine whether
it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, any items after the first item in the sequence are
discarded.</p>
</li>
<li>
<p>If the atomized operand is now an instance of type
<code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>),
<code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it is
converted to the type <code>xs:double</code> by applying the
<code>fn:number</code> function. (Note that <code>fn:number</code>
returns the value <code>NaN</code> if its operand cannot be
converted to a number.)</p>
</li>
</ol>
<p><span class="xpath">If <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code>, each</span> operand is evaluated by applying
the following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
arithmetic expression is an empty sequence, and the implementation
need not evaluate the other operand or apply the operator. However,
an implementation may choose to evaluate the other operand in order
to determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:double</code>. If the cast fails, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised. [err:FORG0001]</p>
</li>
</ol>
<p>After evaluation of the operands, if the types of the operands
are a valid combination for the given arithmetic operator, the
operator is applied to the operands, resulting in an atomic value
or a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> (for example, an error might result from dividing by
zero.) The combinations of atomic types that are accepted by the
various arithmetic operators, and their respective result types,
are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination, including the
dynamic errors that can be raised by the operator. The definitions
of the operator functions are found in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>XPath 3.1 supports two division operators named <code>div</code>
and <code>idiv</code>. Each of these operators accepts two operands
of any <a title="numeric" href="#dt-numeric">numeric</a> type. As
described in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>, <code>$arg1 idiv $arg2</code> is
equivalent to <code>($arg1 div $arg2) cast as xs:integer?</code>
except for error cases.</p>
<p>Here are some examples of arithmetic expressions:</p>
<ul>
<li>
<p>The first expression below returns the <code>xs:decimal</code>
value <code>-1.5</code>, and the second expression returns the
<code>xs:integer</code> value <code>-1</code>:</p>
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</li>
<li>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
<p>Subtraction of two date values results in a value of type
<code>xs:dayTimeDuration</code>:</p>
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</li>
<li>
<p>This example illustrates the difference between a subtraction
operator and a hyphen:</p>
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</li>
<li>
<p>Unary operators have higher precedence than binary operators,
subject of course to the use of parentheses. Therefore, the
following two examples have different meanings:</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops">Multiple consecutive unary
arithmetic operators are permitted by XPath 3.1 for compatibility
with <a href="#xpath">[XML Path Language (XPath) Version
1.0]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-string-concat-expr" id=
"id-string-concat-expr"></a>3.6 String Concatenation
Expressions</h3>
<h5><a name="d2e12887" id="d2e12887"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-StringConcatExpr" id=
"doc-xpath31-StringConcatExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-StringConcatExpr">StringConcatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-RangeExpr">RangeExpr</a> ( "||"
<a href="#doc-xpath31-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>String concatenation expressions allow the string
representations of values to be concatenated. In XPath 3.1,
<code>$a || $b</code> is equivalent to <code>fn:concat($a,
$b)</code>. The following expression evaluates to the string
<code>concatenate</code>:</p>
<div class="exampleInner">
<pre>
"con" || "cat" || "enate"
</pre></div>
</div>
<div class="div2">
<h3><a name="id-comparisons" id="id-comparisons"></a>3.7 Comparison
Expressions</h3>
<p>Comparison expressions allow two values to be compared. XPath
3.1 provides three kinds of comparison expressions, called value
comparisons, general comparisons, and node comparisons.</p>
<h5><a name="d2e12918" id="d2e12918"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ComparisonExpr" id=
"doc-xpath31-ComparisonExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-StringConcatExpr">StringConcatExpr</a> ( (<a href=
"#doc-xpath31-ValueComp">ValueComp</a><br />
| <a href="#doc-xpath31-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xpath31-NodeComp">NodeComp</a>) <a href=
"#doc-xpath31-StringConcatExpr">StringConcatExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ValueComp" id=
"doc-xpath31-ValueComp"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-GeneralComp" id=
"doc-xpath31-GeneralComp"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-NodeComp" id=
"doc-xpath31-NodeComp"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p class="xpath">When an XPath expression is written within an XML
document, the XML escaping rules for special characters must be
followed; thus "<code>&lt;</code>" must be written as
"<code>&amp;lt;</code>".</p>
</div>
<div class="div3">
<h4><a name="id-value-comparisons" id=
"id-value-comparisons"></a>3.7.1 Value Comparisons</h4>
<p>The value comparison operators are <code>eq</code>,
<code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>,
and <code>ge</code>. Value comparisons are used for comparing
single values.</p>
<p>The first step in evaluating a value comparison is to evaluate
its operands. The order in which the operands are evaluated is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. Each
operand is evaluated by applying the following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
value comparison is an empty sequence, and the implementation need
not evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this rule is to make value comparisons
transitive. Users should be aware that the general comparison
operators have a different rule for casting of
<code>xs:untypedAtomic</code> operands. Users should also be aware
that transitivity of value comparisons may be compromised by loss
of precision during type conversion (for example, two
<code>xs:integer</code> values that differ slightly may both be
considered equal to the same <code>xs:float</code> value because
<code>xs:float</code> has less precision than
<code>xs:integer</code>).</p>
</div>
</li>
</ol>
<p>Next, if possible, the two operands are converted to their least
common type by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, if the operands are of type
<code>hatsize</code> (derived from <code>xs:integer</code>) and
<code>shoesize</code> (derived from <code>xs:float</code>), their
least common type is <code>xs:float</code>.</p>
<p>Finally, if the types of the operands are a valid combination
for the given operator, the operator is applied to the operands.
The combinations of atomic types that are accepted by the various
value comparison operators, and their respective result types, are
listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination. The
definitions of the operator functions are found in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
<p>Informally, if both atomized operands consist of exactly one
atomic value, then the result of the comparison is
<code>true</code> if the value of the first operand is (equal, not
equal, less than, less than or equal, greater than, greater than or
equal) to the value of the second operand; otherwise the result of
the comparison is <code>false</code>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Here are some examples of value comparisons:</p>
<ul>
<li>
<p>The following comparison atomizes the node(s) that are returned
by the expression <code>$book/author</code>. The comparison is true
only if the result of atomization is the value "Kennedy" as an
instance of <code>xs:string</code> or
<code>xs:untypedAtomic</code>. If the result of atomization is an
empty sequence, the result of the comparison is an empty sequence.
If the result of atomization is a sequence containing more than one
value, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</li>
<li>
<p>The following comparison is <code>true</code> because
atomization converts an array to its member sequence:</p>
<div class="exampleInner">
<pre>
[ "Kennedy" ] = "Kennedy"
</pre></div>
</li>
<li>
<p>The following <a title="path expression" href=
"#dt-path-expression">path expression</a> contains a predicate that
selects products whose weight is greater than 100. For any product
that does not have a <code>weight</code> subelement, the value of
the predicate is the empty sequence, and the product is not
selected. This example assumes that <code>weight</code> is a
validated element with a numeric type.</p>
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</li>
<li>
<p>The following comparison is true if <code>my:hatsize</code> and
<code>my:shoesize</code> are both user-defined types that are
derived by restriction from a primitive <a title="numeric" href=
"#dt-numeric">numeric</a> type:</p>
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</li>
<li>
<p>The following comparison is true. The <code>eq</code> operator
compares two QNames by performing codepoint-comparisons of their
namespace URIs and their local names, ignoring their namespace
prefixes.</p>
<div class="exampleInner">
<pre>
fn:QName("http://example.com/ns1", "this:color") eq fn:QName("http://example.com/ns1", "that:color")
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-general-comparisons" id=
"id-general-comparisons"></a>3.7.2 General Comparisons</h4>
<p>The general comparison operators are <code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, and <code>&gt;=</code>. General comparisons are
existentially quantified comparisons that may be applied to operand
sequences of any length. The result of a general comparison that
does not raise an error is always <code>true</code> or
<code>false</code>.</p>
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, a general comparison is evaluated by applying
the following rules, in order:</p>
<ol class="enumar">
<li>
<p>If either operand is a single atomic value that is an instance
of <code>xs:boolean</code>, then the other operand is converted to
<code>xs:boolean</code> by taking its <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a>.</p>
</li>
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to each operand. After atomization, each operand is a
sequence of atomic values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>If the comparison operator is <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then
each item in both of the operand sequences is converted to the type
<code>xs:double</code> by applying the <code>fn:number</code>
function. (Note that <code>fn:number</code> returns the value
<code>NaN</code> if its operand cannot be converted to a
number.)</p>
</li>
<li>
<p>The result of the comparison is <code>true</code> if and only if
there is a pair of atomic values, one in the first operand sequence
and the other in the second operand sequence, that have the
required <b>magnitude relationship</b>. Otherwise the result of the
comparison is <code>false</code>. The <b>magnitude relationship</b>
between two atomic values is determined by applying the following
rules. If a <code>cast</code> operation called for by these rules
is not successful, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised. [err:FORG0001]</p>
<ol class="enumla">
<li>
<p>If at least one of the two atomic values is an instance of a
<a title="numeric" href="#dt-numeric">numeric</a> type, then both
atomic values are converted to the type <code>xs:double</code> by
applying the <code>fn:number</code> function.</p>
</li>
<li>
<p>If at least one of the two atomic values is an instance of
<code>xs:string</code>, or if both atomic values are instances of
<code>xs:untypedAtomic</code>, then both atomic values are cast to
the type <code>xs:string</code>.</p>
</li>
<li>
<p>If one of the atomic values is an instance of
<code>xs:untypedAtomic</code> and the other is not an instance of
<code>xs:string</code>, <code>xs:untypedAtomic</code>, or any
<a title="numeric" href="#dt-numeric">numeric</a> type, then the
<code>xs:untypedAtomic</code> value is cast to the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of the
other value.</p>
</li>
<li>
<p>After performing the conversions described above, the atomic
values are compared using one of the value comparison operators
<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>,
<code>gt</code>, or <code>ge</code>, depending on whether the
general comparison operator was <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if and only if the result of this value comparison
is <code>true</code>.</p>
</li>
</ol>
</li>
</ol>
<p><span class="xpath">If <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code>, a</span> general comparison is evaluated by
applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to each operand. After atomization, each operand is a
sequence of atomic values.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Atomization converts arrays to sequences (see <a title=
"atomization" href="#dt-atomization">Atomization</a>).</p>
</div>
</li>
<li>
<p>The result of the comparison is <code>true</code> if and only if
there is a pair of atomic values, one in the first operand sequence
and the other in the second operand sequence, that have the
required <b>magnitude relationship</b>. Otherwise the result of the
comparison is <code>false</code>. The <b>magnitude relationship</b>
between two atomic values is determined by applying the following
rules. If a <code>cast</code> operation called for by these rules
is not successful, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised. [err:FORG0001]</p>
<ol class="enumla">
<li>
<p>If both atomic values are instances of
<code>xs:untypedAtomic</code>, then the values are cast to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>If exactly one of the atomic values is an instance of
<code>xs:untypedAtomic</code>, it is cast to a type depending on
the other value's dynamic type T according to the following rules,
in which V denotes the value to be cast:</p>
<ol class="enumlr">
<li>
<p>If T is a numeric type or is derived from a numeric type, then V
is cast to <code>xs:double</code>.</p>
</li>
<li>
<p>If T is <code>xs:dayTimeDuration</code> or is derived from
<code>xs:dayTimeDuration</code>, then V is cast to
<code>xs:dayTimeDuration</code>.</p>
</li>
<li>
<p>If T is <code>xs:yearMonthDuration</code> or is derived from
<code>xs:yearMonthDuration</code>, then V is cast to
<code>xs:yearMonthDuration</code>.</p>
</li>
<li>
<p>In all other cases, V is cast to the primitive base type of
T.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The special treatment of the duration types is required to avoid
errors that may arise when comparing the primitive type
<code>xs:duration</code> with any duration type.</p>
</div>
</li>
<li>
<p>After performing the conversions described above, the atomic
values are compared using one of the value comparison operators
<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>,
<code>gt</code>, or <code>ge</code>, depending on whether the
general comparison operator was <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if and only if the result of this value comparison
is <code>true</code>.</p>
</li>
</ol>
</li>
</ol>
<p>When evaluating a general comparison in which either operand is
a sequence of items, an implementation may return <code>true</code>
as soon as it finds an item in the first operand and an item in the
second operand that have the required <b>magnitude
relationship</b>. Similarly, a general comparison may raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
as soon as it encounters an error in evaluating either operand, or
in comparing a pair of items from the two operands. As a result of
these rules, the result of a general comparison is not
deterministic in the presence of errors.</p>
<p>Here are some examples of general comparisons:</p>
<ul>
<li>
<p>The following comparison is true if the <a title="typed value"
href="#dt-typed-value">typed value</a> of any <code>author</code>
subelement of <code>$book1</code> is "Kennedy" as an instance of
<code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</li>
<li>
<p>The following comparison is <code>true</code> because
atomization converts an array to its member sequence:</p>
<div class="exampleInner">
<pre>
[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"
</pre></div>
</li>
<li>
<p>The following example contains three general comparisons. The
value of the first two comparisons is <code>true</code>, and the
value of the third comparison is <code>false</code>. This example
illustrates the fact that general comparisons are not
transitive.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>The following example contains two general comparisons, both of
which are <code>true</code>. This example illustrates the fact that
the <code>=</code> and <code>!=</code> operators are not inverses
of each other.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p>Suppose that <code>$a</code>, <code>$b</code>, and
<code>$c</code> are bound to element nodes with type annotation
<code>xs:untypedAtomic</code>, with <a title="string value" href=
"#dt-string-value">string values</a> "<code>1</code>",
"<code>2</code>", and "<code>2.0</code>" respectively. Then
<code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>,
because <code>$b</code> and <code>$c</code> are compared as
strings. However, <code>($a, $b) = ($c, 2.0)</code> returns
<code>true</code>, because <code>$b</code> and <code>2.0</code> are
compared as numbers.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-node-comparisons" id=
"id-node-comparisons"></a>3.7.3 Node Comparisons</h4>
<p>Node comparisons are used to compare two nodes, by their
identity or by their <a title="document order" href=
"#dt-document-order">document order</a>. The result of a node
comparison is defined by the following rules:</p>
<ol class="enumar">
<li>
<p>The operands of a node comparison are evaluated in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</p>
</li>
<li>
<p>If either operand is an empty sequence, the result of the
comparison is an empty sequence, and the implementation need not
evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>Each operand must be either a single node or an empty sequence;
otherwise a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>A comparison with the <code>is</code> operator is
<code>true</code> if the two operand nodes have the same identity,
and are thus the same node; otherwise it is <code>false</code>. See
<a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM)
3.1]</a> for a definition of node identity.</p>
</li>
<li>
<p>A comparison with the <code>&lt;&lt;</code> operator returns
<code>true</code> if the left operand node precedes the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
<li>
<p>A comparison with the <code>&gt;&gt;</code> operator returns
<code>true</code> if the left operand node follows the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
</ol>
<p>Here are some examples of node comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if the left and right
sides each evaluate to exactly the same single node:</p>
<div class="exampleInner">
<pre>
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</pre></div>
</li>
<li>
<p>The following comparison is true only if the node identified by
the left side occurs before the node identified by the right side
in document order:</p>
<div class="exampleInner">
<pre>
/transactions/purchase[parcel="28-451"] &lt;&lt; /transactions/sale[parcel="33-870"]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>3.8 Logical Expressions</h3>
<p>A <b>logical expression</b> is either an <b>and-expression</b>
or an <b>or-expression</b>. If a logical expression does not raise
an error, its value is always one of the boolean values
<code>true</code> or <code>false</code>.</p>
<h5><a name="d2e13747" id="d2e13747"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-OrExpr" id=
"doc-xpath31-OrExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AndExpr">AndExpr</a> ( "or"
<a href="#doc-xpath31-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-AndExpr" id=
"doc-xpath31-AndExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#doc-xpath31-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p>The first step in evaluating a logical expression is to find the
<a title="effective boolean value" href="#dt-ebv">effective boolean
value</a> of each of its operands (see <a href="#id-ebv"><b>2.4.3
Effective Boolean Value</b></a>).</p>
<p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><span class="xpath">if <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, then <code>false</code>; otherwise either
<code>false</code> or error.</span></td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td>error</td>
<td><span class="xpath">if <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, then error; otherwise either <code>false</code>
or error.</span></td>
<td>error</td>
</tr>
</tbody>
</table>
<p>The value of an or-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><span class="xpath">if <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, then <code>true</code>; otherwise either
<code>true</code> or error.</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td><span class="xpath">if <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, then error; otherwise either <code>true</code>
or error.</span></td>
<td>error</td>
<td>error</td>
</tr>
</tbody>
</table>
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, the order in which the operands of a logical
expression are evaluated is effectively prescribed. Specifically,
it is defined that when there is no need to evaluate the second
operand in order to determine the result, then no error can occur
as a result of evaluating the second operand.</p>
<p><span class="xpath">If <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code>, the order in which the operands of a logical
expression are evaluated is <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>.
In this case,</span> an or-expression can return <code>true</code>
if the first expression evaluated is true, and it can raise an
error if evaluation of the first expression raises an error.
Similarly, an and-expression can return <code>false</code> if the
first expression evaluated is false, and it can raise an error if
evaluation of the first expression raises an error. As a result of
these rules, a logical expression is not deterministic in the
presence of errors, as illustrated in the examples below.</p>
<p>Here are some examples of logical expressions:</p>
<ul>
<li>
<p>The following expressions return <code>true</code>:</p>
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</li>
<li>
<p>The following expression may return either <code>false</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> <span class="xpath">(in <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a>, the result must be
<code>false</code>)</span>:</p>
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>The following expression may return either <code>true</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> <span class="xpath">(in <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a>, the result must be
<code>true</code>)</span>:</p>
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>The following expression must raise a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</li>
</ul>
<p>In addition to and- and or-expressions, XPath 3.1 provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value. The <code>fn:not</code>
function is defined in <a href="#xpath-functions-31">[XQuery and
XPath Functions and Operators 3.1]</a>. The <code>fn:not</code>
function reduces its parameter to an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a>. It then returns <code>true</code> if the effective
boolean value of its parameter is <code>false</code>, and
<code>false</code> if the effective boolean value of its parameter
is <code>true</code>. If an error is encountered in finding the
effective boolean value of its operand, <code>fn:not</code> raises
the same error.</p>
</div>
<div class="div2">
<h3><a name="id-for-expressions" id="id-for-expressions"></a>3.9
For Expressions</h3>
<p>XPath provides an iteration facility called a <b>for
expression</b>.</p>
<h5><a name="d2e14126" id="d2e14126"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ForExpr" id=
"doc-xpath31-ForExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ForExpr">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleForClause">SimpleForClause</a> "return"
<a href="#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SimpleForClause" id=
"doc-xpath31-SimpleForClause"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleForClause">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href=
"#doc-xpath31-SimpleForBinding">SimpleForBinding</a> ("," <a href=
"#doc-xpath31-SimpleForBinding">SimpleForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SimpleForBinding" id=
"doc-xpath31-SimpleForBinding"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleForBinding">SimpleForBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath31-VarName">VarName</a> "in"
<a href="#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <code>for</code> expression is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>for</code> expression uses multiple variables, it
is first expanded to a set of nested <code>for</code> expressions,
each of which uses only one variable. For example, the expression
<code>for $x in X, $y in Y return $x + $y</code> is expanded to
<code>for $x in X return for $y in Y return $x + $y</code>.</p>
</li>
<li>
<p>In a single-variable <code>for</code> expression, the variable
is called the <b>range variable</b>, the value of the expression
that follows the <code>in</code> keyword is called the <b>binding
sequence</b>, and the expression that follows the
<code>return</code> keyword is called the <b>return expression</b>.
The result of the <code>for</code> expression is obtained by
evaluating the <code>return</code> expression once for each item in
the binding sequence, with the range variable bound to that item.
The resulting sequences are concatenated (as if by the <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>) in
the order of the items in the binding sequence from which they were
derived.</p>
</li>
</ol>
<p class="xpath">The following example illustrates the use of a
<code>for</code> expression in restructuring an input document. The
example is based on the following input:</p>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>The following example transforms the input document into a list
in which each author's name appears only once, followed by a list
of titles of books written by that author. This example assumes
that the context item is the <code>bib</code> element in the input
document.</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $a in fn:distinct-values(book/author)
return ((book/author[. = $a])[1], book[author = $a]/title)</span>
</pre></div>
<p>The result of the above expression consists of the following
sequence of elements. The titles of books written by a given author
are listed after the name of the author. The ordering of
<code>author</code> elements in the result is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> due to
the semantics of the <code>fn:distinct-values</code> function.</p>
<div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt;
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre></div>
<p>The following example illustrates a <code>for</code> expression
containing more than one variable:</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span>
</pre></div>
<p>The result of the above expression, expressed as a sequence of
numbers, is as follows: <code>11, 12, 21, 22</code></p>
<p>The scope of a variable bound in a <code>for</code> expression
comprises all subexpressions of the <code>for</code> expression
that appear after the variable binding. The scope does not include
the expression to which the variable is bound. The following
example illustrates how a variable binding may reference another
variable bound earlier in the same <code>for</code> expression:</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span>
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The focus for evaluation of the <code>return</code> clause of a
<code>for</code> expression is the same as the focus for evaluation
of the <code>for</code> expression itself. The following example,
which attempts to find the total value of a set of order-items, is
therefore incorrect:</p>
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return @price * @qty)
</pre></div>
<p>Instead, the expression must be written to use the variable
bound in the <code>for</code> clause:</p>
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return $i/@price * $i/@qty)
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-let-expressions" id="id-let-expressions"></a>3.10
Let Expressions</h3>
<p>XPath allows a variable to be declared and bound to a value
using a <b>let expression</b>.</p>
<h5><a name="d2e14298" id="d2e14298"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-LetExpr" id=
"doc-xpath31-LetExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-LetExpr">LetExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleLetClause">SimpleLetClause</a> "return"
<a href="#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SimpleLetClause" id=
"doc-xpath31-SimpleLetClause"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleLetClause">SimpleLetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href=
"#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a> ("," <a href=
"#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SimpleLetBinding" id=
"doc-xpath31-SimpleLetBinding"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath31-VarName">VarName</a> ":="
<a href="#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A let expression is evaluated as follows:</p>
<ul>
<li>
<p>If the let expression uses multiple variables, it is first
expanded to a set of nested let expressions, each of which uses
only one variable. For example, the expression <code>let $x := 4,
$y := 3 return $x + $y</code> is expanded to <code>let $x := 4
return let $y := 3 return $x + $y</code>.</p>
</li>
<li>
<p>In a single-variable let expression, the variable is called the
range variable, the value of the expression that follows the
<code>:=</code> symbol is called the binding sequence, and the
expression that follows the return keyword is called the return
expression. The result of the let expression is obtained by
evaluating the return expression with the range variable bound to
the binding sequence.</p>
</li>
</ul>
<p>The scope of a variable bound in a let expression comprises all
subexpressions of the let expression that appear after the variable
binding. The scope does not include the expression to which the
variable is bound. The following example illustrates how a variable
binding may reference another variable bound earlier in the same
let expression:</p>
<div class="exampleInner">
<pre>
let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]
</pre></div>
</div>
<div class="div2">
<h3><a name="id-maps-and-arrays" id="id-maps-and-arrays"></a>3.11
Maps and Arrays</h3>
<p>Most modern programming languages have support for collections
of key/value pairs, which may be called maps, dictionaries,
associative arrays, hash tables, keyed lists, or objects (these are
not the same thing as objects in object-oriented systems). In XPath
3.1, we call these maps. Most modern programming languages also
support ordered lists of values, which may be called arrays,
vectors, or sequences. In XPath 3.1, we call these arrays. In
previous versions of the language, we have always had sequences,
but unlike arrays, sequences could not nest.</p>
<p>In previous versions of the language, element structures and
sequences were the only complex data structures. We are adding maps
and arrays to XPath 3.1 in order to provide lightweight data
structures that are easier to optimize and less complex to use for
intermediate processing and to allow programs to easily combine XML
processing with JSON processing.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The XPath 3.1 specification focuses on language features
provided for maps and arrays, especially constructors and
lookup.</p>
<p>Some of the functionality typically needed for maps and arrays
is provided in functions defined in described in <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#maps-and-arrays">Section
2.8.2.1 Maps and Arrays Not Yet Complete</a>
<sup><small>DM31</small></sup>, including functions used to read
JSON to create maps and arrays, serialize maps and arrays to JSON,
combine maps to create a new map, remove map entries to create a
new map, iterate over the keys of a map, convert an array to create
a sequence, combine arrays to form a new array, and iterate over
arrays in various ways.</p>
</div>
<div class="div3">
<h4><a name="id-maps" id="id-maps"></a>3.11.1 Maps</h4>
<p>[<a name="dt-map" id="dt-map" title="map">Definition</a>: A
<b>map</b> is a <span>function that associates a set of keys with
values, resulting in a</span> collection of key / value pairs.]
[<a name="dt-entry" id="dt-entry" title="entry">Definition</a>:
Each key / value pair in a map is called an <b>entry</b>.]
[<a name="dt-associated-value" id="dt-associated-value" title=
"associated value">Definition</a>: The value associated with a
given key is called the <b>associated value</b> of the key.]</p>
<div class="div4">
<h5><a name="id-map-constructors" id=
"id-map-constructors"></a>3.11.1.1 Map Constructors</h5>
<p>A Map is created using a <a href=
"#doc-xpath31-MapConstructor">MapConstructor</a>.</p>
<h5><a name="d2e14403" id="d2e14403"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapConstructor" id=
"doc-xpath31-MapConstructor"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapConstructor">MapConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map" "{" (<a href=
"#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a> (","
<a href=
"#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a>)*)?
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapConstructorEntry" id=
"doc-xpath31-MapConstructorEntry"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a> ":"
<a href="#doc-xpath31-MapValueExpr">MapValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapKeyExpr" id=
"doc-xpath31-MapKeyExpr"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapKeyExpr">MapKeyExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapValueExpr" id=
"doc-xpath31-MapValueExpr"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapValueExpr">MapValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some circumstances, it is necessary to include whitespace
before or after the colon to ensure that this grammar is correctly
parsed; this arises for example when the <a href=
"#doc-xpath31-MapKeyExpr">MapKeyExpr</a> ends with a name and the
<a href="#doc-xpath31-MapValueExpr">MapValueExpr</a> starts with a
name.</p>
</div>
<p>The value of the expression is a map whose entries correspond to
the key-value pairs obtained by evaluating the successive <a href=
"#doc-xpath31-MapKeyExpr">MapKeyExpr</a> and <a href=
"#doc-xpath31-MapValueExpr">MapValueExpr</a> expressions.</p>
<p>Each <a href="#doc-xpath31-MapKeyExpr">MapKeyExpr</a> expression
is evaluated and atomized; a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0136"
title="err:XQDY0136">err:XQDY0136</a>] occurs if the result is not
a single atomic value. If the key value is of type
<code>xs:untypedAtomic</code> it is converted to
<code>xs:string</code>. The associated value is the result of
evaluating the corresponding <a href=
"#doc-xpath31-MapValueExpr">MapValueExpr</a>. If two or more
entries have the <a title="same key" href="#dt-same-key">same key
value</a> then a dynamic error is raised [<a href="#ERRXQDY0137"
title="err:XQDY0137">err:XQDY0137</a>].</p>
<p>[<a name="dt-same-key" id="dt-same-key" title=
"same key">Definition</a>: Two atomic values K1 and K2 have the
<b>same key value</b> if the relation deep-equal(K1, K2, $UCC)
holds, where $UCC is the Unicode codepoint collation.]</p>
<p>Example:</p>
<p>The following expression constructs a map with seven
entries:</p>
<div class="exampleInner">
<pre>
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}
</pre></div>
<p>Maps can nest, and can contain any XDM value. Here is an example
of a nested map with values that can be string values, numeric
values, or arrays:</p>
<div class="exampleInner">
<pre>
map {
    "book": map {
        "title": "Data on the Web",
        "year": 2000,
        "author": [
            map {
                "last": "Abiteboul",
                "first": "Serge"
            },
            map {
                "last": "Buneman",
                "first": "Peter"
            },
            map {
                "last": "Suciu",
                "first": "Dan"
            }
        ],
        "publisher": "Morgan Kaufmann Publishers",
        "price": 39.95
    }
}
    
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Unlike the <code>map:new</code> function, the number of entries
in a map that is constructed using a map expression is known
statically.</p>
</div>
</div>
<div class="div4">
<h5><a name="id-map-lookup" id="id-map-lookup"></a>3.11.1.2 Map
Lookup</h5>
<p>Values in a map can be looked up using function call syntax, the
<a href="#doc-xpath31-MapLookup">MapLookup</a> operator (a <a href=
"#doc-xpath31-PostfixExpr">PostfixExpr</a>), or the <a href=
"#doc-xpath31-UnaryMapLookup">UnaryMapLookup</a> operator (a
<a href="#doc-xpath31-PrimaryExpr">PrimaryExp</a>).</p>
<h5><a name="d2e14527" id="d2e14527"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapLookup" id=
"doc-xpath31-MapLookup"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapLookup">MapLookup</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" <a href=
"#doc-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-UnaryMapLookup" id=
"doc-xpath31-UnaryMapLookup"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-UnaryMapLookup">UnaryMapLookup</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" <a href=
"#doc-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-MapKeySpecifier" id=
"doc-xpath31-MapKeySpecifier"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NCName">NCName</a> | <a href=
"#doc-xpath31-StringLiteral">StringLiteral</a> | <a href=
"#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
</tr>
</tbody>
</table>
<p>Maps are functions, and function call syntax can be used to look
up the value associated with a key in a map.</p>
<p>Examples:</p>
<ul>
<li>
<p><code>$weekdays("Su")</code> returns the <a title=
"associated value" href="#dt-associated-value">associated value</a>
of the key <code>Su</code>.</p>
</li>
<li>
<p><code>$books("Green Eggs &amp; Ham")</code> returns <a title=
"associated value" href="#dt-associated-value">associated value</a>
of the key <code>Green Eggs &amp; Ham</code>.</p>
</li>
</ul>
<p>Map lookups can be chained.</p>
<p>Examples: (These examples assume that <code>$b</code> is bound
to the books map from the previous section)</p>
<ul>
<li>
<p>The expression <code>$b("book")("title")</code> returns the
string <code>Data on the Web</code>.</p>
</li>
<li>
<p>The expression <code>$b("book")("author")</code> returns the
array of authors.</p>
</li>
<li>
<p>The expression <code>$b("book")("author")(1)("last")</code>
returns the string <code>Abiteboul</code>.</p>
<p>(This example combines an <a href="#id-array-lookup"><b>3.11.2.2
Array Lookup</b></a> with map lookups.)</p>
</li>
</ul>
<p>XPath 3.1 also provides the <a href=
"#doc-xpath31-MapLookup">MapLookup</a> and <a href=
"#doc-xpath31-UnaryMapLookup">UnaryMapLookup</a> operators for
convenience. When the expression on the left of the postfix map
lookup operator evaluates to a single map, it is equivalent to the
function call syntax.</p>
<p>Examples:</p>
<ul>
<li>
<p>The expression <code>$b?book?title</code> is equivalent to
<code>$b("book")("title")</code>.</p>
</li>
<li>
<p>The expression <code>$b?book?author(1)?last</code> is equivalent
to <code>$b("book")("author")(1)("last")</code>.</p>
<p>(The map lookup operator cannot be used to look up values in
arrays.)</p>
</li>
</ul>
<p>A <a href="#doc-xpath31-MapKeySpecifier">MapKeySpecifier</a> can
be a <a href="#doc-xpath31-StringLiteral">StringLiteral</a>, so
that an expression can to specify a key that contains any string
character. A <a href=
"#doc-xpath31-MapKeySpecifier">MapKeySpecifier</a> can be a
<a href="#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a>, so
that an expression can be computed dynamically.</p>
<p>Examples:</p>
<ul>
<li>
<p>The expression <code>$books?"Green Eggs &amp; Ham"</code> is
equivalent to <code>$books("Green Eggs &amp; Ham")</code>.</p>
</li>
<li>
<p>The expression <code>$books?(concat("Greek Eggs ","&amp;
Ham"))</code> is equivalent to <code>$books?"Green Eggs &amp;
Ham"</code>.</p>
</li>
</ul>
<p>If the expression on the left of the posfix map lookup operator
evaluates to an array of maps or a sequence of maps, it performs
implicit mapping. <code>$sequence-of-maps?key</code> is equivalent
to <code>$sequence-of-maps ! .("key")</code>.
<code>$array-of-maps?key</code> is equivalent to
<code>$array-of-maps=&gt;seq() ! .("key")</code>. If the expression
on the left of the postfix map lookup operator is not a map, a
sequence of maps, or an array of maps, a <a title="type error"
href="#dt-type-error">type error</a> is raised [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Examples:</p>
<ul>
<li>
<p>The following expression returns the sequence <code>( "W0342",
"M0535")</code>.</p>
<div class="exampleInner">
<pre>
let $maps := ( map { "id" : "W0342" }, map { "id" : "M0535" } )
return $maps?id
</pre></div>
</li>
<li>
<p>The following expression returns the sequence <code>( "W0342",
"M0535")</code>.</p>
<div class="exampleInner">
<pre>
let $maps := [ map { "id" : "W0342" }, map { "id" : "M0535" } ]
return $maps?id
</pre></div>
</li>
<li>
<p><code>"W0342"?id</code> raises a type error.</p>
</li>
</ul>
<p>The unary form operates on the context item, and is typically
used in predicates. The expression <code>expr[ ?key ]</code> is
equivalent to the expression <code>expr[ .("key") ]</code>. If the
context item is an array of maps, the unary map lookup operator
performs implicit mapping. If the expression on the left of the
postfix map lookup operator is not a map or an array of maps, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<p>Examples:</p>
<ul>
<li>
<p>The following expression returns the map <code>{ "id" : "W0342"
}</code>.</p>
<div class="exampleInner">
<pre>
let $maps := ( map { "id" : "W0342" }, map { "id" : "M0535" })
return $maps[ ?id = "W0342" ]
</pre></div>
</li>
<li>
<p>The following expression returns the string <code>What were you
thinking?</code></p>
<div class="exampleInner">
<pre>
let $errors := ( 
      map { "level" : 1, "text" : "Boys will be boys ..." },
      map { "level" : 2, "text" : "What were you thinking?" },
      map { "level" : 3, "text" : "Call the cops!" }
    )
return $errors[?level = 2]?text
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-arrays" id="id-arrays"></a>3.11.2 Arrays</h4>
<div class="div4">
<h5><a name="id-array-constructors" id=
"id-array-constructors"></a>3.11.2.1 Array Constructors</h5>
<p>[<a name="dt-array" id="dt-array" title="array">Definition</a>:
An <b>array</b> is a <span>function</span> that associates a set of
positions, represented as positive integer keys, with values.]
<span>The first position in an array is associated with the integer
1.</span> [<a name="dt-member" id="dt-member" title=
"member">Definition</a>: The values of an array are called its
<b>members</b>.] In the type hierarchy, array has a distinct type,
which is derived from function.</p>
<p>An array is created using an <a href=
"#doc-xpath31-ArrayConstructor">ArrayConstructor</a>.</p>
<h5><a name="d2e14800" id="d2e14800"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-ArrayConstructor" id=
"doc-xpath31-ArrayConstructor"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ArrayConstructor">ArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a> |
<a href=
"#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SquareArrayConstructor" id=
"doc-xpath31-SquareArrayConstructor"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SquareArrayConstructor">SquareArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" (<a href="#doc-xpath31-ExprSingle">ExprSingle</a>
("," <a href="#doc-xpath31-ExprSingle">ExprSingle</a>)*)?
"]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-CurlyArrayConstructor" id=
"doc-xpath31-CurlyArrayConstructor"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "{" <a href="#doc-xpath31-Expr">Expr</a>?
"}"</code></td>
</tr>
</tbody>
</table>
<p>The members of a <a href=
"#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a>
can be any value, separated by commas.</p>
<p>Examples:</p>
<ul>
<li>
<p><code>[ 1, 2, 5, 7 ]</code> creates an array with four members:
<code>1</code>, <code>2</code>, <code>5</code>, and
<code>7</code>.</p>
</li>
<li>
<p><code>[ (), (27, 17, 0)]</code> creates an array with two
members: <code>()</code> and the sequence <code>(27, 17,
0)</code>.</p>
</li>
<li>
<p><code>[ $x, local:items(), &lt;tautology&gt;It is what it
is.&lt;/tautology&gt; ]</code> creates an array with three members:
the value of $x, the result of evaluating the function call, and a
tautology element.</p>
</li>
</ul>
<p>A <a href=
"#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a> can
use any XQuery expression to create its members. It evaluates its
operand expression to obtain a sequence of items and creates an
array with these items as members. Unlike a SquareArrayConstructor,
a comma in a CurlyArrayConstructor is the XQuery comma operator,
not a delimiter.</p>
<p>Examples:</p>
<ul>
<li>
<p><code>array { $x }</code> creates an array with one member for
each item to which $x is bound.</p>
</li>
<li>
<p><code>array { local:items() }</code> creates an array with one
member for each item to which <code>local:items()</code>
evaluates.</p>
</li>
<li>
<p><code>array { 1, 2, 5, 7 }</code> creates an array with four
members: <code>1</code>, <code>2</code>, <code>5</code>, and
<code>7</code>.</p>
</li>
<li>
<p><code>array { (), (27, 17, 0) }</code> creates an array with
three members: <code>27</code>, <code>17</code>, and
<code>0</code>.</p>
</li>
<li>
<p><code>array{ $x, local:items(), &lt;tautology&gt;It is what it
is.&lt;/tautology&gt; }</code> creates an array with the following
members: the items to which <code>$x</code> is bound, followed by
the items to which <code>local:items()</code> evaluates, followed
by a tautology element.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XPath 3.1 does not provide explicit support for sparse arrays.
Use integer-valued maps to represent sparse arrays, e.g. <code>map
{ 27 : -1, 153 : 17 }</code> .</p>
</div>
</div>
<div class="div4">
<h5><a name="id-array-lookup" id="id-array-lookup"></a>3.11.2.2
Array Lookup</h5>
<p>Arrays are functions in XPath 3.1, and the function call
<code>$a(n)</code> returns the value associated with position
<code>n</code>, which must be a positive integer value [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If position
<code>n</code> does not exist in the array, a dynamic error is
raised [<a href="#ERRXQDY0138" title=
"err:XQDY0138">err:XQDY0138</a>].</p>
<p>Examples:</p>
<ul>
<li>
<p><code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.</p>
</li>
<li>
<p><code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt;
](3)</code> evaluates to <code>&lt;name&gt;Robert
Johnson&lt;/name&gt;</code>.</p>
</li>
<li>
<p><code>[ [1, 2, 3], [4, 5, 6]](2)</code> evaluates to <code>[4,
5, 6]</code>.</p>
</li>
<li>
<p><code>array { (), (27, 17, 0) }(1)</code> evaluates to
<code>()</code>.</p>
</li>
<li>
<p><code>array { (), (27, 17, 0) }(2)</code> evaluates to
<code>(27, 17, 0)</code>.</p>
</li>
<li>
<p><code>array { "licorice", "ginger" }(20)</code> raises a dynamic
error [<a href="#ERRXQDY0138" title=
"err:XQDY0138">err:XQDY0138</a>].</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="d2e15024" id="d2e15024"></a>3.11.2.3 Converting Arrays
to Sequences</h5>
<p>If <code>$a</code> is an array, <code>fn:seq($a)</code> returns
a sequence constructed by concatenating the members of the array,
in order, using the comma operator. The semantics of this function
are formally defined in <a href=
"http://www.w3.org/TR/xpath-functions-31/#func-ay-seq">Section
17.3.12 ay:seq</a> <sup><small>FO31</small></sup>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is often convenient to use the <a title="arrow operator"
href="#dt-arrow-operator">arrow operator</a> to call
<code>fn:seq()</code>. The following expressions are
equivalent.</p>
<ul>
<li>
<p><code>$a=&gt;seq()</code></p>
</li>
<li>
<p><code>seq($a)</code></p>
</li>
</ul>
</div>
<p>If every member of the array contains exactly one item, the
above expressions evaluate to the same result as
<code>$a[7]</code>, but if a member contains a null sequence or a
sequence with multiple items, this is no longer true. Consider the
following examples.</p>
<ul>
<li>
<p><code>[ (), (), 1, (2, 3, 4)](1)</code> evaluates to (), the
value of the first array member.</p>
</li>
<li>
<p><code>[ (), (), 1, (2, 3, 4)]=&gt;seq()[1]</code> evaluates to
1, the first item in the sequence created by concatenating the
values of the array.</p>
</li>
<li>
<p><code>[ (), (), 1, (2, 3, 4)](4)</code> evaluates to <code>(2,
3, 4)</code>, the value of the fourth member in the array.</p>
</li>
<li>
<p><code>[ (), (), 1, (2, 3, 4)]=&gt;seq()[4]</code> evaluates to
<code>4</code>, the value of the fourth item in the sequence
created by concatenating the values of the array.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-conditionals" id="id-conditionals"></a>3.12
Conditional Expressions</h3>
<p>XPath 3.1 supports a conditional expression based on the
keywords <code>if</code>, <code>then</code>, and
<code>else</code>.</p>
<h5><a name="d2e15109" id="d2e15109"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-IfExpr" id=
"doc-xpath31-IfExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xpath31-Expr">Expr</a> ")" "then"
<a href="#doc-xpath31-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The expression following the <code>if</code> keyword is called
the <b>test expression</b>, and the expressions following the
<code>then</code> and <code>else</code> keywords are called the
<b>then-expression</b> and <b>else-expression</b>,
respectively.</p>
<p>The first step in processing a conditional expression is to find
the <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of the test expression, as defined in <a href=
"#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.</p>
<p>The value of a conditional expression is defined as follows: If
the effective boolean value of the test expression is
<code>true</code>, the value of the then-expression is returned. If
the effective boolean value of the test expression is
<code>false</code>, the value of the else-expression is
returned.</p>
<p>Conditional expressions have a special rule for propagating
<a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a>. If the effective value of the test expression is
<code>true</code>, the conditional expression ignores (does not
raise) any dynamic errors encountered in the else-expression. In
this case, since the else-expression can have no observable effect,
it need not be evaluated. Similarly, if the effective value of the
test expression is <code>false</code>, the conditional expression
ignores any <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> encountered in the
then-expression, and the then-expression need not be evaluated.</p>
<p>Here are some examples of conditional expressions:</p>
<ul>
<li>
<p>In this example, the test expression is a comparison
expression:</p>
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost)
  then $widget1
  else $widget2
</pre></div>
</li>
<li>
<p>In this example, the test expression tests for the existence of
an attribute named <code>discounted</code>, independently of its
value:</p>
<div class="exampleInner">
<pre>
if ($part/@discounted)
  then $part/wholesale
  else $part/retail
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>3.13 Quantified Expressions</h3>
<p>Quantified expressions support existential and universal
quantification. The value of a quantified expression is always
<code>true</code> or <code>false</code>.</p>
<h5><a name="d2e15202" id="d2e15202"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-QuantifiedExpr" id=
"doc-xpath31-QuantifiedExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xpath31-VarName">VarName</a> "in" <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath31-VarName">VarName</a> "in" <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>quantified expression</b> begins with a <b>quantifier</b>,
which is the keyword <code>some</code> or <code>every</code>,
followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test
expression. Each in-clause associates a variable with an expression
that returns a sequence of items, called the binding sequence for
that variable. The in-clauses generate tuples of variable bindings,
including a tuple for each combination of items in the binding
sequences of the respective variables. Conceptually, the test
expression is evaluated for each tuple of variable bindings.
Results depend on the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of the test expressions, as
defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean
Value</b></a>. The value of the quantified expression is defined by
the following rules:</p>
<ol class="enumar">
<li>
<p>If the quantifier is <code>some</code>, the quantified
expression is <code>true</code> if at least one evaluation of the
test expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>false</code>.</p>
</li>
<li>
<p>If the quantifier is <code>every</code>, the quantified
expression is <code>true</code> if every evaluation of the test
expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>true</code>.</p>
</li>
</ol>
<p>The scope of a variable bound in a quantified expression
comprises all subexpressions of the quantified expression that
appear after the variable binding. The scope does not include the
expression to which the variable is bound.</p>
<p>The order in which test expressions are evaluated for the
various binding tuples is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. If the
quantifier is <code>some</code>, an implementation may return
<code>true</code> as soon as it finds one binding tuple for which
the test expression has an <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of <code>true</code>, and it
may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> as soon as it finds one
binding tuple for which the test expression raises an error.
Similarly, if the quantifier is <code>every</code>, an
implementation may return <code>false</code> as soon as it finds
one binding tuple for which the test expression has an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of <code>false</code>, and it may raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon
as it finds one binding tuple for which the test expression raises
an error. As a result of these rules, the value of a quantified
expression is not deterministic in the presence of errors, as
illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ul>
<li>
<p>This expression is <code>true</code> if every <code>part</code>
element has a <code>discounted</code> attribute (regardless of the
values of these attributes):</p>
<div class="exampleInner">
<pre>
every $part in /parts/part satisfies $part/@discounted
</pre></div>
</li>
<li>
<p>This expression is <code>true</code> if at least one
<code>employee</code> element satisfies the given comparison
expression:</p>
<div class="exampleInner">
<pre>
some $emp in /emps/employee satisfies
     ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</li>
<li>
<p>In the following examples, each quantified expression evaluates
its test expression over nine tuples of variable bindings, formed
from the Cartesian product of the sequences <code>(1, 2, 3)</code>
and <code>(2, 3, 4)</code>. The expression beginning with
<code>some</code> evaluates to <code>true</code>, and the
expression beginning with <code>every</code> evaluates to
<code>false</code>.</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4
</pre></div>
<div class="exampleInner">
<pre>
every $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4
</pre></div>
</li>
<li>
<p>This quantified expression may either return <code>true</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>true</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>This quantified expression may either return <code>false</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>false</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-expressions-on-datatypes" id=
"id-expressions-on-datatypes"></a>3.14 Expressions on
SequenceTypes</h3>
<p><a title="sequence type" href="#dt-sequence-type">sequence
types</a> are used in <code>instance of</code>, <code>cast</code>,
<code>castable</code>, and <code>treat</code> expressions.</p>
<div class="div3">
<h4><a name="id-instance-of" id="id-instance-of"></a>3.14.1
Instance Of</h4>
<h5><a name="d2e15441" id="d2e15441"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-InstanceofExpr" id=
"doc-xpath31-InstanceofExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#doc-xpath31-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p>The boolean operator <code>instance of</code> returns
<code>true</code> if the value of its first operand matches the
<a href="#doc-xpath31-SequenceType">SequenceType</a> in its second
operand, according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>; otherwise it
returns <code>false</code>. For example:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>This example returns <code>true</code> because the given value
is an instance of the given type.</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>This example returns <code>true</code> because the given value
is an integer literal, and <code>xs:integer</code> is derived by
restriction from <code>xs:decimal</code>.</p>
</li>
<li>
<p><code>(5, 6) instance of xs:integer+</code></p>
<p>This example returns <code>true</code> because the given
sequence contains two integers, and is a valid instance of the
specified type.</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>This example returns <code>true</code> if the context item is an
element node or <code>false</code> if the context item is defined
but is not an element node. If the context item is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>,
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-cast" id="id-cast"></a>3.14.2 Cast</h4>
<h5><a name="d2e15535" id="d2e15535"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-CastExpr" id=
"doc-xpath31-CastExpr"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xpath31-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SingleType" id=
"doc-xpath31-SingleType"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e14035.doc-xpath31-AtomicOrUnionType" id=
"noid_d3e14035.doc-xpath31-AtomicOrUnionType"></a>[82]&#160;&#160;&#160;</td>
<td><code>AtomicOrUnionType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
</table>
<p>Occasionally it is necessary to convert a value to a specific
datatype. For this purpose, XPath 3.1 provides a <code>cast</code>
expression that creates a new value of a specific type based on an
existing value. A <code>cast</code> expression takes two operands:
an <b>input expression</b> and a <b>target type</b>. The type of
the atomized value of the input expression is called the <b>input
type</b>. The SimpleTypeName must be the name of a type defined in
the <a title="in-scope schema type" href="#dt-is-types">in-scope
schema types</a>, and it must be a simple type [<a href=
"#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>]. In addition,
the target type cannot be <code>xs:NOTATION</code>,
<code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code>
[<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]. The
optional occurrence indicator "<code>?</code>" denotes that an
empty sequence is permitted. If the target type is a lexical QName
that has no namespace prefix, it is considered to be in the
<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>.</p>
<p>Casting a node to <code>xs:QName</code> can cause surprises
because it uses the static context of the cast expression to
provide the namespace bindings for this operation. Instead of
casting to <code>xs:QName</code>, it is generally preferable to use
the <code>fn:QName</code> function, which allows the namespace
context to be taken from the document containing the QName.</p>
<p>The semantics of the <code>cast</code> expression are as
follows:</p>
<ol class="enumar">
<li>
<p>The input expression is evaluated.</p>
</li>
<li>
<p>The result of the first step is <a title="atomization" href=
"#dt-atomization">atomized</a>.</p>
</li>
<li>
<p>If the result of atomization is a sequence of more than one
atomic value, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the result of atomization is an empty sequence:</p>
<ol class="enumla">
<li>
<p>If <code>?</code> is specified after the target type, the result
of the <code>cast</code> expression is an empty sequence.</p>
</li>
<li>
<p>If <code>?</code> is not specified after the target type, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is a single atomic value, the
result of the cast expression depends on the input type and the
target type. In general, the cast expression attempts to create a
new value of the target type based on the input value. Only certain
combinations of input type and target type are supported. A summary
of the rules are listed below—the normative definition of these
rules is given in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>. For the purpose of these rules,
an implementation may determine that one type is derived by
restriction from another type either by examining the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a> or by using an alternative, <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism such as a data dictionary.</p>
<ol class="enumla">
<li>
<p><code>cast</code> is supported for the combinations of input
type and target type listed in <a href=
"http://www.w3.org/TR/xpath-functions-31/#casting-from-primitive-to-primitive">
Section 19.1 Casting from primitive types to primitive types</a>
<sup><small>FO31</small></sup>. For each of these combinations,
both the input type and the target type are primitive <a title=
"schema type" href="#dt-schema-type">schema types</a>. For example,
a value of type <code>xs:string</code> can be cast into the schema
type <code>xs:decimal</code>. For each of these built-in
combinations, the semantics of casting are specified in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported if the input type is a
non-primitive atomic type that is derived by restriction from the
target type. In this case, the input value is mapped into the value
space of the target type, unchanged except for its type. For
example, if <code>shoesize</code> is derived by restriction from
<code>xs:integer</code>, a value of type <code>shoesize</code> can
be cast into the schema type <code>xs:integer</code>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type and the input type is
<code>xs:string</code> or <code>xs:untypedAtomic</code>. The input
value is first converted to a value in the lexical space of the
target type by applying the whitespace normalization rules for the
target type (as defined in <a href="#XMLSchema10">[XML Schema
1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>). The
lexical value is then converted to the value space of the target
type using the schema-defined rules for the target type. If the
input value fails to satisfy some facet of the target type, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
may be raised as specified in <a href="#xpath-functions-31">[XQuery
and XPath Functions and Operators 3.1]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported to any target type if the input
type is <code>xs:string</code> or <code>xs:untypedAtomic</code>.
The target type may be an atomic type, a union type, or a list
type. The semantics are based on the rules for validation in
<a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href=
"#XMLSchema11">[XML Schema 1.1]</a>.</p>
<p>The effect of casting a string <var>S</var> to a simple type
<var>T</var> is the same as constructing an element or attribute
node whose string value is <var>S</var>, validating it using
<var>T</var> as the governing type, and atomizing the resulting
node. The result may be a single atomic value or (if list types are
involved) a sequence of zero or more atomic values.</p>
<p>If the target type is <a title="namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, then the
namespace bindings in the static context will be used to resolve
any namespace prefix found in the supplied string.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type that is derived by restriction from the
input type. The input value must satisfy all the facets of the
target type (in the case of the pattern facet, this is checked by
generating a string representation of the input value, using the
rules for casting to <code>xs:string</code>). The resulting value
is the same as the input value, but with a different <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p>
</li>
<li>
<p>If a primitive type P1 can be cast into a primitive type P2,
then any type derived by restriction from P1 can be cast into any
type derived by restriction from P2, provided that the facets of
the target type are satisfied. First the input value is cast to P1
using rule (b) above. Next, the value of type P1 is cast to the
type P2, using rule (a) above. Finally, the value of type P2 is
cast to the target type, using rule (d) above.</p>
</li>
<li>
<p>For any combination of input type and target type that is not in
the above list, a <code>cast</code> expression raises a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
</ol>
<p>If casting from the input type to the target type is supported
but nevertheless it is not possible to cast the input value into
the value space of the target type, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> is raised.
[err:FORG0001] This includes the case when any facet of the target
type is not satisfied. For example, the expression
<code>"2003-02-31" cast as xs:date</code> would raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="div3">
<h4><a name="id-castable" id="id-castable"></a>3.14.3 Castable</h4>
<h5><a name="d2e15810" id="d2e15810"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-CastableExpr" id=
"doc-xpath31-CastableExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#doc-xpath31-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e14285.doc-xpath31-SingleType" id=
"noid_d3e14285.doc-xpath31-SingleType"></a>[77]&#160;&#160;&#160;</td>
<td><code>SingleType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>XPath 3.1 provides an expression that tests whether a given
value is castable into a given target type. The SimpleTypeName must
be the name of a type defined in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, and the type must be <code>simple</code> [<a href=
"#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>]. In addition,
the target type cannot be <code>xs:NOTATION</code>,
<code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code>
[<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]. The
optional occurrence indicator "<code>?</code>" denotes that an
empty sequence is permitted.</p>
<p>The expression <code>E castable as T</code> returns
<code>true</code> if the result of evaluating <code>E</code> can be
successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. If evaluation of <code>E</code> fails with a
dynamic error, the <code>castable</code> expression as a whole
fails. The <code>castable</code> expression can be used as a
<a title="" href="#dt-predicate">predicate</a> to avoid errors at
evaluation time. It can also be used to select an appropriate type
for processing of a given value, as illustrated in the following
example:</p>
<div class="exampleInner">
<pre>
if ($x castable as hatsize)
   then $x cast as hatsize
   else if ($x castable as IQ)
   then $x cast as IQ
   else $x cast as xs:string
</pre></div>
</div>
<div class="div3">
<h4><a name="id-constructor-functions" id=
"id-constructor-functions"></a>3.14.4 Constructor Functions</h4>
<p>For every <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a> in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> (except <code>xs:NOTATION</code> and
<code>xs:anyAtomicType</code>, which are not instantiable), a
<b>constructor function</b> is implicitly defined. In each case,
the name of the constructor function is the same as the name of its
target type (including namespace). The signature of the constructor
function for type <em>T</em> is as follows:</p>
<div class="exampleInner">
<pre>
T($arg as xs:anyAtomicType?) as T?
</pre></div>
<p>[<a name="dt-constructor-function" id="dt-constructor-function"
title="constructor function">Definition</a>: The <b>constructor
function</b> for a given type is used to convert instances of other
atomic types into the given type. The semantics of the constructor
function call <code>T($arg)</code> are defined to be equivalent to
the expression <code>(($arg) cast as T?)</code>.]</p>
<p>The following examples illustrate the use of constructor
functions:</p>
<ul>
<li>
<p>This example is equivalent to <code>("2000-01-01" cast as
xs:date?)</code>.</p>
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</li>
<li>
<p>This example is equivalent to <code>(($floatvalue * 0.2E-5) cast
as xs:decimal?)</code>.</p>
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</li>
<li>
<p>This example returns an <code>xs:dayTimeDuration</code> value
equal to 21 days. It is equivalent to <code>("P21D" cast as
xs:dayTimeDuration?)</code>.</p>
<div class="exampleInner">
<pre>
xs:dayTimeDuration("P21D")
</pre></div>
</li>
<li>
<p>If <code>usa:zipcode</code> is a user-defined atomic type in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, then the following expression is equivalent to the
expression <code>("12345" cast as usa:zipcode?)</code>.</p>
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An instance of an atomic type that is not in a namespace can be
constructed in either of the following ways:</p>
<ul>
<li>
<p>By using a <code>cast</code> expression, if the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</p>
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</li>
<li>
<p>By using a constructor function, if the <a title=
"default function namespace" href="#dt-def-fn-ns">default function
namespace</a> is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</p>
<div class="exampleInner">
<pre>
apple(17)
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-treat" id="id-treat"></a>3.14.5 Treat</h4>
<h5><a name="d2e16005" id="d2e16005"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-TreatExpr" id=
"doc-xpath31-TreatExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xpath31-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>XPath 3.1 provides an expression called <code>treat</code> that
can be used to modify the <a title="static type" href=
"#dt-static-type">static type</a> of its operand.</p>
<p>Like <code>cast</code>, the <code>treat</code> expression takes
two operands: an expression and a <a href=
"#doc-xpath31-SequenceType">SequenceType</a>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> or
value of its operand. Instead, the purpose of <code>treat</code> is
to ensure that an expression has an expected dynamic type at
evaluation time.</p>
<p>The semantics of <em><code>expr1</code></em> <code>treat
as</code> <em><code>type1</code></em> are as follows:</p>
<ul>
<li>
<p>During static analysis:</p>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of the <code>treat</code> expression is
<em><code>type1</code></em> . This enables the expression to be
used as an argument of a function that requires a parameter of
<em><code>type1</code></em> .</p>
</li>
<li>
<p>During expression evaluation:</p>
<p>If <em><code>expr1</code></em> matches
<em><code>type1</code></em> , using the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>, the
<code>treat</code> expression returns the value of
<em><code>expr1</code></em> ; otherwise, it raises a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>
[<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>]. If
the value of <em><code>expr1</code></em> is returned, its identity
is preserved. The <code>treat</code> expression ensures that the
value of its expression operand conforms to the expected type at
run-time.</p>
</li>
<li>
<p>Example:</p>
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of <code>$myaddress</code> may be <code>element(*,
Address)</code>, a less specific type than <code>element(*,
USAddress)</code>. However, at run-time, the value of
<code>$myaddress</code> must match the type <code>element(*,
USAddress)</code> using rules for <a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType matching</a>;
otherwise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-map-operator" id="id-map-operator"></a>3.15 Simple
map operator (<code>!</code>)</h3>
<h5><a name="d2e16176" id="d2e16176"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath31-SimpleMapExpr" id=
"doc-xpath31-SimpleMapExpr"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PathExpr">PathExpr</a> ("!"
<a href="#doc-xpath31-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>The simple map operator "<code>!</code>" is used for simple
mappings. Both its left-hand side expression and its
right-hand-side expression may return a mixed sequence of nodes and
non-nodes.</p>
<p>Each operation <code>E1!E2</code> is evaluated as follows:
Expression <code>E1</code> is evaluated to a sequence
<code>S</code>. Each item in <code>S</code> then serves in turn to
provide an inner focus (the item as the context item, its position
in <code>S</code> as the context position, the length of
<code>S</code> as the context size) for an evaluation of
<code>E2</code> in the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a>. The sequences resulting
from all the evaluations of <code>E2</code> are combined as
follows: Every evaluation of <code>E2</code> returns a (possibly
empty) sequence of items. These sequences are concatenated and
returned. If ordering mode is ordered, the returned sequence
preserves the orderings within and among the subsequences generated
by the evaluations of <code>E2</code>; otherwise the order of the
returned sequence is implementation-dependent.</p>
<p>Simple map operators have functionality similar to <a href=
"#id-path-operator"><b>3.3.1.1 Path operator (/)</b></a>. The
following table summarizes the differences between these two
operators</p>
<table border="1">
<thead>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Path operator (<code>E1 / E2</code>)</th>
<th colspan="1">Simple map operator (<code>E1 ! E2</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1">E1</th>
<td>Any sequence of nodes</td>
<td>Any sequence of items</td>
</tr>
<tr>
<th colspan="1">E2</th>
<td>Either a sequence of nodes or a sequence of non-node items</td>
<td>A sequence of items</td>
</tr>
<tr>
<th colspan="1">Additional processing</th>
<td>Duplicate elimination and document ordering</td>
<td>Simple sequence concatenation</td>
</tr>
</tbody>
</table>
<p>The following examples illustrate the use of simple map
operators combined with path expressions.</p>
<div class="exampleOuter">
<ul>
<li>
<p><code>child::div1 / child::para / string() ! concat("id-",
.)</code></p>
<p>Selects the <code>para</code> element children of the
<code>div1</code> element children of the context node; that is,
the <code>para</code> element grandchildren of the context node
that have <code>div1</code> parents. It then outputs the strings
obtained by prepending <code>"id-"</code> to each of the string
values of these grandchildren.</p>
</li>
<li>
<p><code>$emp ! (@first, @middle, @last)</code></p>
<p>Returns the values of the attributes <code>first</code>,
<code>middle</code>, and <code>last</code> for element
<code>$emp</code>, in the order given. (The <code>/</code> operator
here returns the attributes in an unpredictable order.)</p>
</li>
<li>
<p><code>$docs ! ( //employee)</code></p>
<p>Returns all the employees within all the documents identified by
the variable docs, in document order within each document, but
retaining the order of documents.</p>
</li>
<li>
<p><code>avg( //employee / salary ! translate(., '$', '') !
number(.))</code></p>
<p>Returns the average salary of the employees, having converted
the salary to a number by removing any <code>$</code> sign and then
converting to a number. (The second occurrence of <code>!</code>
could not be written as <code>/</code> because the left-hand
operand of <code>/</code> cannot be an atomic value.)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="nt-bnf" id="nt-bnf"></a>A XPath 3.1 Grammar</h2>
<div class="div2">
<h3><a name="id-grammar" id="id-grammar"></a>A.1 EBNF</h3>
<p>The grammar of XPath 3.1 uses the same simple Extended
Backus-Naur Form (EBNF) notation as <a href="#XML">[XML 1.0]</a>
with the following minor differences.</p>
<ul>
<li>
<p>All named symbols have a name that begins with an uppercase
letter.</p>
</li>
<li>
<p>It adds a notation for referring to productions in external
specs.</p>
</li>
<li>
<p>Comments or extra-grammatical constraints on grammar productions
are between '/*' and '*/' symbols.</p>
<ul>
<li>
<p>A 'xgc:' prefix is an extra-grammatical constraint, the details
of which are explained in <a href=
"#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical
Constraints</b></a></p>
</li>
<li>
<p>A 'ws:' prefix explains the whitespace rules for the production,
the details of which are explained in <a href=
"#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a></p>
</li>
<li>
<p>A 'gn:' prefix means a 'Grammar Note', and is meant as a
clarification for parsing rules, and is explained in <a href=
"#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>. These notes are
not normative.</p>
</li>
</ul>
</li>
</ul>
<p>The terminal symbols for this grammar include the quoted strings
used in the production rules below, and the terminal symbols
defined in section <a href="#terminal-symbols"><b>A.2.1 Terminal
Symbols</b></a>.</p>
<p>The EBNF notation is described in more detail in <a href=
"#EBNFNotation"><b>A.1.1 Notation</b></a>.</p>
<p>To increase readability, the EBNF in the main body of this
document omits some of these notational features. This appendix is
the normative version of the EBNF.</p>
<h5><a name="BNF-Grammar" id="BNF-Grammar"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-XPath" id=
"prod-xpath31-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ParamList" id=
"prod-xpath31-ParamList"></a>[2]&#160;&#160;&#160;</td>
<td><code>ParamList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Param">Param</a> ("," <a href=
"#prod-xpath31-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Param" id=
"prod-xpath31-Param"></a>[3]&#160;&#160;&#160;</td>
<td><code>Param</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath31-EQName">EQName</a> <a href=
"#prod-xpath31-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-FunctionBody" id=
"prod-xpath31-FunctionBody"></a>[4]&#160;&#160;&#160;</td>
<td><code>FunctionBody</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-EnclosedExpr" id=
"prod-xpath31-EnclosedExpr"></a>[5]&#160;&#160;&#160;</td>
<td><code>EnclosedExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#prod-xpath31-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Expr" id=
"prod-xpath31-Expr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ExprSingle">ExprSingle</a> (","
<a href="#prod-xpath31-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ExprSingle" id=
"prod-xpath31-ExprSingle"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath31-LetExpr">LetExpr</a><br />
| <a href="#prod-xpath31-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath31-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath31-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ForExpr" id=
"prod-xpath31-ForExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ForExpr">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleForClause">SimpleForClause</a> "return"
<a href="#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleForClause" id=
"prod-xpath31-SimpleForClause"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleForClause">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" <a href=
"#prod-xpath31-SimpleForBinding">SimpleForBinding</a> ("," <a href=
"#prod-xpath31-SimpleForBinding">SimpleForBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleForBinding" id=
"prod-xpath31-SimpleForBinding"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleForBinding">SimpleForBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath31-VarName">VarName</a> "in"
<a href="#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-LetExpr" id=
"prod-xpath31-LetExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-LetExpr">LetExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleLetClause">SimpleLetClause</a> "return"
<a href="#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleLetClause" id=
"prod-xpath31-SimpleLetClause"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleLetClause">SimpleLetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" <a href=
"#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a> ("," <a href=
"#prod-xpath31-SimpleLetBinding">SimpleLetBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleLetBinding" id=
"prod-xpath31-SimpleLetBinding"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleLetBinding">SimpleLetBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath31-VarName">VarName</a> ":="
<a href="#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-QuantifiedExpr" id=
"prod-xpath31-QuantifiedExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xpath31-VarName">VarName</a> "in" <a href=
"#prod-xpath31-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath31-VarName">VarName</a> "in" <a href=
"#prod-xpath31-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-IfExpr" id=
"prod-xpath31-IfExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xpath31-Expr">Expr</a> ")" "then"
<a href="#prod-xpath31-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-OrExpr" id=
"prod-xpath31-OrExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-AndExpr">AndExpr</a> ( "or"
<a href="#prod-xpath31-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AndExpr" id=
"prod-xpath31-AndExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#prod-xpath31-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ComparisonExpr" id=
"prod-xpath31-ComparisonExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-StringConcatExpr">StringConcatExpr</a> ( (<a href=
"#prod-xpath31-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath31-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath31-NodeComp">NodeComp</a>) <a href=
"#prod-xpath31-StringConcatExpr">StringConcatExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-StringConcatExpr" id=
"prod-xpath31-StringConcatExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-StringConcatExpr">StringConcatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-RangeExpr">RangeExpr</a> ( "||"
<a href="#prod-xpath31-RangeExpr">RangeExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-RangeExpr" id=
"prod-xpath31-RangeExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xpath31-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AdditiveExpr" id=
"prod-xpath31-AdditiveExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xpath31-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MultiplicativeExpr" id=
"prod-xpath31-MultiplicativeExpr"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xpath31-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-UnionExpr" id=
"prod-xpath31-UnionExpr"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xpath31-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-IntersectExceptExpr" id=
"prod-xpath31-IntersectExceptExpr"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#prod-xpath31-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-InstanceofExpr" id=
"prod-xpath31-InstanceofExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#prod-xpath31-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TreatExpr" id=
"prod-xpath31-TreatExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xpath31-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-CastableExpr" id=
"prod-xpath31-CastableExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-CastExpr">CastExpr</a> (
"castable" "as" <a href="#prod-xpath31-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-CastExpr" id=
"prod-xpath31-CastExpr"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xpath31-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-UnaryExpr" id=
"prod-xpath31-UnaryExpr"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xpath31-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ValueExpr" id=
"prod-xpath31-ValueExpr"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-GeneralComp" id=
"prod-xpath31-GeneralComp"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ValueComp" id=
"prod-xpath31-ValueComp"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NodeComp" id=
"prod-xpath31-NodeComp"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleMapExpr" id=
"prod-xpath31-SimpleMapExpr"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SimpleMapExpr">SimpleMapExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-PathExpr">PathExpr</a> ("!"
<a href="#prod-xpath31-PathExpr">PathExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-PathExpr" id=
"prod-xpath31-PathExpr"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xpath31-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xpath31-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">xgc:
leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-RelativePathExpr" id=
"prod-xpath31-RelativePathExpr"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-StepExpr">StepExpr</a> (("/" |
"//") <a href="#prod-xpath31-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-StepExpr" id=
"prod-xpath31-StepExpr"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-PostfixExpr">PostfixExpr</a> |
<a href="#prod-xpath31-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AxisStep" id=
"prod-xpath31-AxisStep"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath31-ReverseStep">ReverseStep</a> |
<a href="#prod-xpath31-ForwardStep">ForwardStep</a>) <a href=
"#prod-xpath31-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ForwardStep" id=
"prod-xpath31-ForwardStep"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath31-ForwardAxis">ForwardAxis</a>
<a href="#prod-xpath31-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ForwardAxis" id=
"prod-xpath31-ForwardAxis"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AbbrevForwardStep" id=
"prod-xpath31-AbbrevForwardStep"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xpath31-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ReverseStep" id=
"prod-xpath31-ReverseStep"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath31-ReverseAxis">ReverseAxis</a>
<a href="#prod-xpath31-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ReverseAxis" id=
"prod-xpath31-ReverseAxis"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AbbrevReverseStep" id=
"prod-xpath31-AbbrevReverseStep"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NodeTest" id=
"prod-xpath31-NodeTest"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-KindTest">KindTest</a> | <a href=
"#prod-xpath31-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NameTest" id=
"prod-xpath31-NameTest"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a> | <a href=
"#prod-xpath31-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Wildcard" id=
"prod-xpath31-Wildcard"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath31-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath31-NCName">NCName</a>)<br />
| (<a href="#prod-xpath31-BracedURILiteral">BracedURILiteral</a>
"*")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-PostfixExpr" id=
"prod-xpath31-PostfixExpr"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-PostfixExpr">PostfixExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-PrimaryExpr">PrimaryExpr</a>
(<a href="#prod-xpath31-Predicate">Predicate</a> | <a href=
"#prod-xpath31-ArgumentList">ArgumentList</a> | <a href=
"#prod-xpath31-MapLookup">MapLookup</a> | <a href=
"#prod-xpath31-ArrowPostfix">ArrowPostfix</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArgumentList" id=
"prod-xpath31-ArgumentList"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ArgumentList">ArgumentList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href="#prod-xpath31-Argument">Argument</a> (","
<a href="#prod-xpath31-Argument">Argument</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-PredicateList" id=
"prod-xpath31-PredicateList"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Predicate" id=
"prod-xpath31-Predicate"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xpath31-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapLookup" id=
"prod-xpath31-MapLookup"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapLookup">MapLookup</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" <a href=
"#prod-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapKeySpecifier" id=
"prod-xpath31-MapKeySpecifier"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NCName">NCName</a> | <a href=
"#prod-xpath31-StringLiteral">StringLiteral</a> | <a href=
"#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArrowPostfix" id=
"prod-xpath31-ArrowPostfix"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ArrowPostfix">ArrowPostfix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=&gt;" <a href=
"#prod-xpath31-ArrowFunctionSpecifier">ArrowFunctionSpecifier</a>
<a href="#prod-xpath31-ArgumentList">ArgumentList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArrowFunctionSpecifier" id=
"prod-xpath31-ArrowFunctionSpecifier"></a>[55]&#160;&#160;&#160;</td>
<td><code>ArrowFunctionSpecifier</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a> | <a href=
"#prod-xpath31-VarRef">VarRef</a> | <a href=
"#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-PrimaryExpr" id=
"prod-xpath31-PrimaryExpr"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Literal">Literal</a><br />
| <a href="#prod-xpath31-VarRef">VarRef</a><br />
| <a href=
"#prod-xpath31-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#prod-xpath31-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#prod-xpath31-FunctionCall">FunctionCall</a><br />
| <a href=
"#prod-xpath31-FunctionItemExpr">FunctionItemExpr</a><br />
| <a href="#prod-xpath31-MapConstructor">MapConstructor</a><br />
| <a href=
"#prod-xpath31-ArrayConstructor">ArrayConstructor</a><br />
| <a href=
"#prod-xpath31-UnaryMapLookup">UnaryMapLookup</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Literal" id=
"prod-xpath31-Literal"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-NumericLiteral">NumericLiteral</a>
| <a href=
"#prod-xpath31-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NumericLiteral" id=
"prod-xpath31-NumericLiteral"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-IntegerLiteral">IntegerLiteral</a>
| <a href="#prod-xpath31-DecimalLiteral">DecimalLiteral</a> |
<a href="#prod-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-VarRef" id=
"prod-xpath31-VarRef"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#prod-xpath31-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-VarName" id=
"prod-xpath31-VarName"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ParenthesizedExpr" id=
"prod-xpath31-ParenthesizedExpr"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath31-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ContextItemExpr" id=
"prod-xpath31-ContextItemExpr"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-FunctionCall" id=
"prod-xpath31-FunctionCall"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a> <a href=
"#prod-xpath31-ArgumentList">ArgumentList</a></code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgc:
reserved-function-names</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Argument" id=
"prod-xpath31-Argument"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Argument">Argument</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ExprSingle">ExprSingle</a> |
<a href=
"#prod-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArgumentPlaceholder" id=
"prod-xpath31-ArgumentPlaceholder"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-FunctionItemExpr" id=
"prod-xpath31-FunctionItemExpr"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-FunctionItemExpr">FunctionItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-NamedFunctionRef">NamedFunctionRef</a> | <a href=
"#prod-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NamedFunctionRef" id=
"prod-xpath31-NamedFunctionRef"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-NamedFunctionRef">NamedFunctionRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a> "#" <a href=
"#prod-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgc:
reserved-function-names</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-InlineFunctionExpr" id=
"prod-xpath31-InlineFunctionExpr"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-InlineFunctionExpr">InlineFunctionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" <a href=
"#prod-xpath31-ParamList">ParamList</a>? ")" ("as" <a href=
"#prod-xpath31-SequenceType">SequenceType</a>)? <a href=
"#prod-xpath31-FunctionBody">FunctionBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapConstructor" id=
"prod-xpath31-MapConstructor"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapConstructor">MapConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map" "{" (<a href=
"#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a> (","
<a href=
"#prod-xpath31-MapConstructorEntry">MapConstructorEntry</a>)*)?
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapConstructorEntry" id=
"prod-xpath31-MapConstructorEntry"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapConstructorEntry">MapConstructorEntry</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-MapKeyExpr">MapKeyExpr</a> ":"
<a href="#prod-xpath31-MapValueExpr">MapValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapKeyExpr" id=
"prod-xpath31-MapKeyExpr"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapKeyExpr">MapKeyExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapValueExpr" id=
"prod-xpath31-MapValueExpr"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-MapValueExpr">MapValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArrayConstructor" id=
"prod-xpath31-ArrayConstructor"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ArrayConstructor">ArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-SquareArrayConstructor">SquareArrayConstructor</a> |
<a href=
"#prod-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SquareArrayConstructor" id=
"prod-xpath31-SquareArrayConstructor"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SquareArrayConstructor">SquareArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" (<a href="#prod-xpath31-ExprSingle">ExprSingle</a>
("," <a href="#prod-xpath31-ExprSingle">ExprSingle</a>)*)?
"]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-CurlyArrayConstructor" id=
"prod-xpath31-CurlyArrayConstructor"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "{" <a href="#prod-xpath31-Expr">Expr</a>?
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-UnaryMapLookup" id=
"prod-xpath31-UnaryMapLookup"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-UnaryMapLookup">UnaryMapLookup</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" <a href=
"#prod-xpath31-MapKeySpecifier">MapKeySpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SingleType" id=
"prod-xpath31-SingleType"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-SimpleTypeName">SimpleTypeName</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TypeDeclaration" id=
"prod-xpath31-TypeDeclaration"></a>[78]&#160;&#160;&#160;</td>
<td><code>TypeDeclaration</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#prod-xpath31-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SequenceType" id=
"prod-xpath31-SequenceType"></a>[79]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xpath31-ItemType">ItemType</a> <a href=
"#prod-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-OccurrenceIndicator" id=
"prod-xpath31-OccurrenceIndicator"></a>[80]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <a href="#parse-note-occurrence-indicators">xgc:
occurrence-indicators</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ItemType" id=
"prod-xpath31-ItemType"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-KindTest">KindTest</a> | ("item"
"(" ")") | <a href="#prod-xpath31-FunctionTest">FunctionTest</a> |
<a href="#prod-xpath31-MapTest">MapTest</a> | <a href=
"#prod-xpath31-ArrayTest">ArrayTest</a> | <a href=
"#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> | <a href=
"#prod-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AtomicOrUnionType" id=
"prod-xpath31-AtomicOrUnionType"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-KindTest" id=
"prod-xpath31-KindTest"></a>[83]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath31-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath31-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xpath31-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xpath31-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xpath31-PITest">PITest</a><br />
| <a href="#prod-xpath31-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath31-TextTest">TextTest</a><br />
| <a href=
"#prod-xpath31-NamespaceNodeTest">NamespaceNodeTest</a><br />
| <a href="#prod-xpath31-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AnyKindTest" id=
"prod-xpath31-AnyKindTest"></a>[84]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-DocumentTest" id=
"prod-xpath31-DocumentTest"></a>[85]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xpath31-ElementTest">ElementTest</a> | <a href=
"#prod-xpath31-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TextTest" id=
"prod-xpath31-TextTest"></a>[86]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-CommentTest" id=
"prod-xpath31-CommentTest"></a>[87]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NamespaceNodeTest" id=
"prod-xpath31-NamespaceNodeTest"></a>[88]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-NamespaceNodeTest">NamespaceNodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace-node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-PITest" id=
"prod-xpath31-PITest"></a>[89]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath31-NCName">NCName</a> | <a href=
"#prod-xpath31-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AttributeTest" id=
"prod-xpath31-AttributeTest"></a>[90]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xpath31-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AttribNameOrWildcard" id=
"prod-xpath31-AttribNameOrWildcard"></a>[91]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SchemaAttributeTest" id=
"prod-xpath31-SchemaAttributeTest"></a>[92]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xpath31-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AttributeDeclaration" id=
"prod-xpath31-AttributeDeclaration"></a>[93]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ElementTest" id=
"prod-xpath31-ElementTest"></a>[94]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#prod-xpath31-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ElementNameOrWildcard" id=
"prod-xpath31-ElementNameOrWildcard"></a>[95]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SchemaElementTest" id=
"prod-xpath31-SchemaElementTest"></a>[96]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xpath31-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ElementDeclaration" id=
"prod-xpath31-ElementDeclaration"></a>[97]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AttributeName" id=
"prod-xpath31-AttributeName"></a>[98]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ElementName" id=
"prod-xpath31-ElementName"></a>[99]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-SimpleTypeName" id=
"prod-xpath31-SimpleTypeName"></a>[100]&#160;&#160;&#160;</td>
<td><code>SimpleTypeName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TypeName" id=
"prod-xpath31-TypeName"></a>[101]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-EQName">EQName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-FunctionTest" id=
"prod-xpath31-FunctionTest"></a>[102]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-FunctionTest">FunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-AnyFunctionTest">AnyFunctionTest</a><br />
| <a href=
"#prod-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-AnyFunctionTest" id=
"prod-xpath31-AnyFunctionTest"></a>[103]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-AnyFunctionTest">AnyFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TypedFunctionTest" id=
"prod-xpath31-TypedFunctionTest"></a>[104]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-TypedFunctionTest">TypedFunctionTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"function" "(" (<a href=
"#prod-xpath31-SequenceType">SequenceType</a> ("," <a href=
"#prod-xpath31-SequenceType">SequenceType</a>)*)? ")" "as" <a href=
"#prod-xpath31-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-MapTest" id=
"prod-xpath31-MapTest"></a>[105]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-MapTest">MapTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map" "(" ("*" | (<a href=
"#prod-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> ","
<a href="#prod-xpath31-SequenceType">SequenceType</a>))
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ArrayTest" id=
"prod-xpath31-ArrayTest"></a>[106]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ArrayTest">ArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-WildcardArrayTest">WildcardArrayTest</a> | <a href=
"#prod-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-WildcardArrayTest" id=
"prod-xpath31-WildcardArrayTest"></a>[107]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-WildcardArrayTest">WildcardArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "(" "*" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-TypedArrayTest" id=
"prod-xpath31-TypedArrayTest"></a>[108]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-TypedArrayTest">TypedArrayTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"array" "(" <a href=
"#prod-xpath31-SequenceType">SequenceType</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-ParenthesizedItemType" id=
"prod-xpath31-ParenthesizedItemType"></a>[109]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-ParenthesizedItemType">ParenthesizedItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath31-ItemType">ItemType</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-EQName" id=
"prod-xpath31-EQName"></a>[110]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-EQName">EQName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-QName">QName</a> | <a href=
"#prod-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="EBNFNotation" id="EBNFNotation"></a>A.1.1
Notation</h4>
<p>The following definitions will be helpful in defining precisely
this exposition.</p>
<p>[<a name="symbol" id="symbol" title="symbol">Definition</a>:
Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
<p>]</p>
<p>[<a name="terminal" id="terminal" title=
"terminal">Definition</a>: A <b>terminal</b> is a symbol or string
or pattern that can appear in the right-hand side of a rule, but
never appears on the left-hand side in the main grammar, although
it may appear on the left-hand side of a rule in the grammar for
terminals.] The following constructs are used to match strings of
one or more characters in a terminal:</p>
<dl>
<dt class="label">[a-zA-Z]</dt>
<dd>
<p>matches any <a href="#prod-xpath31-Char">Char</a> with a value
in the range(s) indicated (inclusive).</p>
</dd>
<dt class="label">[abc]</dt>
<dd>
<p>matches any <a href="#prod-xpath31-Char">Char</a> with a value
among the characters enumerated.</p>
</dd>
<dt class="label">[^abc]</dt>
<dd>
<p>matches any <a href="#prod-xpath31-Char">Char</a> with a value
not among the characters given.</p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>matches the sequence of characters that appear inside the double
quotes.</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>matches the sequence of characters that appear inside the single
quotes.</p>
</dd>
<dt class="label">
[http://www.w3.org/TR/REC-example/#NT-Example]</dt>
<dd>
<p>matches any string matched by the production defined in the
external specification as per the provided reference.</p>
</dd>
</dl>
<p>Patterns (including the above constructs) can be combined with
grammatical operators to form more complex patterns, matching more
complex sets of character strings. In the examples that follow, A
and B represent (sub-)patterns.</p>
<dl>
<dt class="label">(A)</dt>
<dd>
<p><code>A</code> is treated as a unit and may be combined as
described in this list.</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>matches <code>A</code> followed by <code>B</code>. This operator
has higher precedence than alternation; thus <code>A B | C D</code>
is identical to <code>(A B) | (C D)</code>.</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p>matches <code>A</code> or <code>B</code> but not both.</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p>matches any string that matches <code>A</code> but does not
match <code>B</code>.</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p>matches one or more occurrences of <code>A</code>. Concatenation
has higher precedence than alternation; thus <code>A+ | B+</code>
is identical to <code>(A+) | (B+)</code>.</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p>matches zero or more occurrences of <code>A</code>.
Concatenation has higher precedence than alternation; thus <code>A*
| B*</code> is identical to <code>(A*) | (B*)</code></p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="extra-grammatical-constraints" id=
"extra-grammatical-constraints"></a>A.1.2 Extra-grammatical
Constraints</h4>
<p>This section contains constraints on the EBNF productions, which
are required to parse syntactically valid sentences. The notes
below are referenced from the right side of the production, with
the notation: <em>/* xgc: &lt;id&gt; */</em>.</p>
<div class="constraint">
<p class="prefix"><a name="parse-note-leading-lone-slash" id=
"parse-note-leading-lone-slash"></a><b>Constraint:
leading-lone-slash</b></p>
<p>A single slash may appear either as a complete path expression
or as the first part of a path expression in which it is followed
by a <a href="#doc-xpath31-RelativePathExpr">RelativePathExpr</a>.
In some cases, the next token after the slash is insufficient to
allow a parser to distinguish these two possibilities: the
<code>*</code> token and keywords like <code>union</code> could be
either an operator or a <a href=
"#doc-xpath31-NameTest">NameTest</a> . For example, without
lookahead the first part of the expression <code>/ * 5</code> is
easily taken to be a complete expression, <code>/ *</code>, which
has a very different interpretation (the child nodes of
<code>/</code>).</p>
<p>Therefore to reduce the need for lookahead, if the token
immediately following a slash can form the start of a <a href=
"#doc-xpath31-RelativePathExpr">RelativePathExpr</a>, then the
slash must be the beginning of a <a href=
"#doc-xpath31-PathExpr">PathExpr</a>, not the entirety of it.</p>
<p>A single slash may be used as the left-hand argument of an
operator by parenthesizing it: <code>(/) * 5</code>. The expression
<code>5 * /</code>, on the other hand, is syntactically valid
without parentheses.</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-xml-version" id=
"parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
<p>The version of XML and XML Names (e.g. <a href="#XML">[XML
1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href=
"#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names
1.1]</a>) is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. It is
recommended that the latest applicable version be used (even if it
is published later than this specification). The EBNF in this
specification links only to the 1.0 versions. Note also that these
external productions follow the whitespace rules of their
respective specifications, and not the rules of this specification,
in particular <a href="#DefaultWhitespaceHandling"><b>A.2.4.1
Default Whitespace Handling</b></a>. Thus <code>prefix :
localname</code> is not a syntactically valid <a title=
"lexical QName" href="#dt-qname">lexical QName</a> for purposes of
this specification, just as it is not permitted in a XML document.
Also, comments are not permissible on either side of the colon.
Also extra-grammatical constraints such as well-formedness
constraints must be taken into account.</p>
<p class="xpath">XPath expressions allow any legal XML Unicode
character, subject only to constraints imposed by the host
language.</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-reserved-function-names" id=
"parse-note-reserved-function-names"></a><b>Constraint:
reserved-function-names</b></p>
<p>Unprefixed function names spelled the same way as language
keywords could make the language harder to recognize. For instance,
<code>if(foo)</code> could be taken either as a <a href=
"#doc-xpath31-FunctionCall">FunctionCall</a> or as the beginning of
an <a href="#doc-xpath31-IfExpr">IfExpr</a>. Therefore, an
unprefixed function name must not be any of the names in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<p>A function named "if" can be called by binding its namespace to
a prefix and using the prefixed form: "library:if(foo)" instead of
"if(foo)".</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-occurrence-indicators" id=
"parse-note-occurrence-indicators"></a><b>Constraint:
occurrence-indicators</b></p>
<p>As written, the grammar in <a href="#nt-bnf"><b>A XPath 3.1
Grammar</b></a> is ambiguous for some forms using the '+' and '*'
Kleene operators. The ambiguity is resolved as follows: these
operators are tightly bound to the <a href=
"#doc-xpath31-SequenceType">SequenceType</a> expression, and have
higher precedence than other uses of these symbols. Any occurrence
of '+' and '*', as well as '?', following a sequence type is
assumed to be an occurrence indicator, which binds to the last
<a href="#doc-xpath31-ItemType">ItemType</a> in the <a href=
"#doc-xpath31-SequenceType">SequenceType</a>.</p>
<p>Thus, <code>4 treat as item() + - 5</code> must be interpreted
as <code>(4 treat as item()+) - 5</code>, taking the '+' as an
OccurrenceIndicator and the '-' as a subtraction operator. To force
the interpretation of "+" as an addition operator (and the
corresponding interpretation of the "-" as a unary minus),
parentheses may be used: the form <code>(4 treat as item()) +
-5</code> surrounds the <a href=
"#doc-xpath31-SequenceType">SequenceType</a> expression with
parentheses and leads to the desired interpretation.</p>
<p><code>function () as xs:string *</code> is interpreted as
<code>function () as (xs:string *)</code>, not as <code>(function
() as xs:string) *</code>. Parentheses can be used as shown to
force the latter interpretation.</p>
<p>This rule has as a consequence that certain forms which would
otherwise be syntactically valid and unambiguous are not
recognized: in "4 treat as item() + 5", the "+" is taken as an
<a href="#doc-xpath31-OccurrenceIndicator">OccurrenceIndicator</a>,
and not as an operator, which means this is not a syntactically
valid expression.</p>
</div>
</div>
<div class="div3">
<h4><a name="notes-on-parsing" id="notes-on-parsing"></a>A.1.3
Grammar Notes</h4>
<p>This section contains general notes on the EBNF productions,
which may be helpful in understanding how to interpret and
implement the EBNF. These notes are not normative. The notes below
are referenced from the right side of the production, with the
notation: <em>/* gn: &lt;id&gt; */</em>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<dl>
<dt class="label"><a name="parse-note-parens" id=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p>Look-ahead is required to distinguish <a href=
"#doc-xpath31-FunctionCall">FunctionCall</a> from a EQName or
keyword followed by a <a href="#doc-xpath31-Comment">Comment</a>.
For example: <code>address (: this may be empty :)</code> may be
mistaken for a call to a function named "address" unless this
lookahead is employed. Another example is <code>for (: whom the
bell :) $tolls in 3 return $tolls</code>, where the keyword "for"
must not be mistaken for a function name.</p>
</dd>
<dt class="label"><a name="parse-note-comments" id=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>Comments are allowed everywhere that <a title=
"ignorable whitespace" href="#IgnorableWhitespace">ignorable
whitespace</a> is allowed, and the <a href=
"#doc-xpath31-Comment">Comment</a> symbol does not explicitly
appear on the right-hand side of the grammar (except in its own
production). See <a href="#DefaultWhitespaceHandling"><b>A.2.4.1
Default Whitespace Handling</b></a>.</p>
<p>A comment can contain nested comments, as long as all "(:" and
":)" patterns are balanced, no matter where they occur within the
outer comment.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Lexical analysis may typically handle nested comments by
incrementing a counter for each "(:" pattern, and decrementing the
counter for each ":)" pattern. The comment does not terminate until
the counter is back to zero.</p>
</div>
<p>Some illustrative examples:</p>
<ul>
<li>
<p><code>(: commenting out a (: comment :) may be confusing, but
often helpful :)</code> is a syntactically valid Comment, since
balanced nesting of comments is allowed.</p>
</li>
<li>
<p><code>"this is just a string :)"</code> is a syntactically valid
expression. However, <code>(: "this is just a string :)" :)</code>
will cause a syntax error. Likewise, <code>"this is another string
(:"</code> is a syntactically valid expression, but <code>(: "this
is another string (:" :)</code> will cause a syntax error. It is a
limitation of nested comments that literal content can cause
unbalanced nesting of comments.</p>
</li>
<li>
<p><code>for (: set up loop :) $i in $x return $i</code> is
syntactically valid, ignoring the comment.</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of
xs:integer</code> is also syntactically valid.</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="lexical-structure" id="lexical-structure"></a>A.2
Lexical structure</h3>
<p>The terminal symbols assumed by the grammar above are described
in this section.</p>
<p>Quoted strings appearing in production rules are terminal
symbols.</p>
<p>Other terminal symbols are defined in <a href=
"#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.</p>
<p>Some productions are defined by reference to the XML and XML
Names specifications (e.g. <a href="#XML">[XML 1.0]</a> and
<a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML
1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> .
<span class="xpath">A host language may choose</span> which version
of these specifications is used; it is recommended that the latest
applicable version be used (even if it is published later than this
specification).</p>
<p class="xpath">A <b>host language</b> may choose whether the
lexical rules of <a href="#XML">[XML 1.0]</a> and <a href=
"#XMLNAMES">[XML Names]</a> are followed, or alternatively, the
lexical rules of <a href="#XML1.1">[XML 1.1]</a> and <a href=
"#XMLNAMES11">[XML Names 1.1]</a> are followed.</p>
<p>When tokenizing, the longest possible match that is consistent
with the EBNF is used.</p>
<p>All keywords are case sensitive. Keywords are not reserved—that
is, any <a title="lexical QName" href="#dt-qname">lexical QName</a>
may duplicate a keyword except as noted in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<div class="div3">
<h4><a name="terminal-symbols" id="terminal-symbols"></a>A.2.1
Terminal Symbols</h4>
<h5><a name="d2e18124" id="d2e18124"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-IntegerLiteral" id=
"prod-xpath31-IntegerLiteral"></a>[111]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath31-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-DecimalLiteral" id=
"prod-xpath31-DecimalLiteral"></a>[112]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xpath31-Digits">Digits</a>) |
(<a href="#prod-xpath31-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-DoubleLiteral" id=
"prod-xpath31-DoubleLiteral"></a>[113]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xpath31-Digits">Digits</a>) |
(<a href="#prod-xpath31-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#prod-xpath31-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-StringLiteral" id=
"prod-xpath31-StringLiteral"></a>[114]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xpath31-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href=
"#prod-xpath31-EscapeApos">EscapeApos</a> | [^'])* "'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-URIQualifiedName" id=
"prod-xpath31-URIQualifiedName"></a>[115]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-URIQualifiedName">URIQualifiedName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath31-BracedURILiteral">BracedURILiteral</a> <a href=
"#prod-xpath31-NCName">NCName</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-BracedURILiteral" id=
"prod-xpath31-BracedURILiteral"></a>[116]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-BracedURILiteral">BracedURILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"Q" "{" [^{}]* "}"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-EscapeQuot" id=
"prod-xpath31-EscapeQuot"></a>[117]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-EscapeApos" id=
"prod-xpath31-EscapeApos"></a>[118]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Comment" id=
"prod-xpath31-Comment"></a>[119]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xpath31-CommentContents">CommentContents</a> | <a href=
"#prod-xpath31-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-QName" id=
"prod-xpath31-QName"></a>[120]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-QName">QName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-NCName" id=
"prod-xpath31-NCName"></a>[121]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Char" id=
"prod-xpath31-Char"></a>[122]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a>
*/</i></td>
</tr>
</tbody>
</table>
<p>The following symbols are used only in the definition of
terminal symbols; they are not terminal symbols in the grammar of
<a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
<h5><a name="d2e18286" id="d2e18286"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-Digits" id=
"prod-xpath31-Digits"></a>[123]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath31-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath31-CommentContents" id=
"prod-xpath31-CommentContents"></a>[124]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath31-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath31-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="id-terminal-delimitation" id=
"id-terminal-delimitation"></a>A.2.2 Terminal Delimitation</h4>
<p>XPath 3.1 expressions consist of <a href=
"#terminal-symbols">terminal symbols</a> and <a title=
"symbol separators" href="#symbolseparators">symbol
separators</a>.</p>
<p>Terminal symbols that are not used exclusively in <a href=
"#ws-explicit">/* ws: explicit */</a> productions are of two kinds:
delimiting and non-delimiting.</p>
<p>[<a name="delimiting-token" id="delimiting-token" title=
"delimiting terminal symbol">Definition</a>: The <b>delimiting
terminal symbols</b> are: "!", "!=", <a href=
"#prod-xpath31-StringLiteral">StringLiteral</a>, "#", "$", "(",
")", "*", "+", (comma), "-", (dot), "..", "/", "//", (colon), "::",
":=", "&lt;", "&lt;&lt;", "&lt;=", "=", "=&gt;", "&gt;", "&gt;=",
"&gt;&gt;", "?", "@", <a href=
"#prod-xpath31-BracedURILiteral">BracedURILiteral</a>, "[", "]",
"{", "|", "||", "}" ]</p>
<p>[<a name="non-delimiting-token" id="non-delimiting-token" title=
"non-delimiting terminal symbol">Definition</a>: The
<b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xpath31-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath31-URIQualifiedName">URIQualifiedName</a>, <a href=
"#prod-xpath31-NCName">NCName</a>, <a href=
"#prod-xpath31-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath31-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath31-QName">QName</a>, "ancestor", "ancestor-or-self",
"and", "array", "as", "attribute", "cast", "castable", "child",
"comment", "descendant", "descendant-or-self", "div",
"document-node", "element", "else", "empty-sequence", "eq",
"every", "except", "following", "following-sibling", "for",
"function", "ge", "gt", "idiv", "if", "in", "instance",
"intersect", "is", "item", "le", "let", "lt", "map", "mod",
"namespace", "namespace-node", "ne", "node", "of", "or", "parent",
"preceding", "preceding-sibling", "processing-instruction",
"return", "satisfies", "schema-attribute", "schema-element",
"self", "some", "text", "then", "to", "treat", "union" ]</p>
<p>[<a name="symbolseparators" id="symbolseparators" title=
"symbol separators">Definition</a>: <a title="whitespace" href=
"#Whitespace">Whitespace</a> and <a href=
"#doc-xpath31-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgc: xml-version */</a>
annotation.]</p>
<p>It is customary to separate consecutive terminal symbols by
<a title="whitespace" href="#Whitespace">whitespace</a> and
<a href="#doc-xpath31-Comment">Comments</a>, but this is required
only when otherwise two non-delimiting symbols would be adjacent to
each other. There are two exceptions to this, that of "." and "-",
which do require a <a title="symbol separators" href=
"#symbolseparators">symbol separator</a> if they follow a QName or
NCName. Also, "." requires a separator if it precedes or follows a
numeric literal.</p>
</div>
<div class="div3">
<h4><a name="id-eol-handling" id="id-eol-handling"></a>A.2.3
End-of-Line Handling</h4>
<p class="xpath">The host language must specify whether the XPath
3.1 processor normalizes all line breaks on input, before parsing,
and if it does so, whether it uses the rules of <a href="#XML">[XML
1.0]</a> or <a href="#XML1.1">[XML 1.1]</a>.</p>
<div class="div4">
<h5><a name="id-xml10-eol-handling" id=
"id-xml10-eol-handling"></a>A.2.3.1 XML 1.0 End-of-Line
Handling</h5>
<p>For <a href="#XML">[XML 1.0]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-xml11-eol-handling" id=
"id-xml11-eol-handling"></a>A.2.3.2 XML 1.1 End-of-Line
Handling</h5>
<p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>the two-character sequence #xD #x85</p>
</li>
<li>
<p>the single character #x85</p>
</li>
<li>
<p>the single character #x2028</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA or
#x85.</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="whitespace-rules" id="whitespace-rules"></a>A.2.4
Whitespace Rules</h4>
<div class="div4">
<h5><a name="DefaultWhitespaceHandling" id=
"DefaultWhitespaceHandling"></a>A.2.4.1 Default Whitespace
Handling</h5>
<p>[<a name="Whitespace" id="Whitespace" title=
"whitespace">Definition</a>: A <b>whitespace</b> character is any
of the characters defined by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.]</p>
<p>[<a name="IgnorableWhitespace" id="IgnorableWhitespace" title=
"ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b>
consists of any <a title="whitespace" href=
"#Whitespace">whitespace</a> characters that may occur between
<a title="terminal" href="#terminal">terminals</a>, unless these
characters occur in the context of a production marked with a
<a href="#ExplicitWhitespaceHandling">ws:explicit</a> annotation,
in which case they can occur only where explicitly specified (see
<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit
Whitespace Handling</b></a>).] Ignorable whitespace characters are
not significant to the semantics of an expression. Whitespace is
allowed before the first terminal and after the last terminal
<span class="xpath">of an XPath</span>. Whitespace is allowed
between any two <a title="terminal" href="#terminal">terminals</a>.
<a href="#doc-xpath31-Comment">Comments</a> may also act as
"whitespace" to prevent two adjacent terminals from being
recognized as one. Some illustrative examples are as follows:</p>
<ul>
<li>
<p><code>foo- foo</code> results in a syntax error. "foo-" would be
recognized as a QName.</p>
</li>
<li>
<p><code>foo -foo</code> is syntactically equivalent to <code>foo -
foo</code>, two QNames separated by a subtraction operator.</p>
</li>
<li>
<p><code>foo(: This is a comment :)- foo</code> is syntactically
equivalent to <code>foo - foo</code>. This is because the comment
prevents the two adjacent terminals from being recognized as
one.</p>
</li>
<li>
<p><code>foo-foo</code> is syntactically equivalent to single
QName. This is because "-" is a valid character in a QName. When
used as an operator after the characters of a name, the "-" must be
separated from the name, e.g. by using whitespace or
parentheses.</p>
</li>
<li>
<p><code>10div 3</code> results in a syntax error.</p>
</li>
<li>
<p><code>10 div3</code> also results in a syntax error.</p>
</li>
<li>
<p><code>10div3</code> also results in a syntax error.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="ExplicitWhitespaceHandling" id=
"ExplicitWhitespaceHandling"></a>A.2.4.2 Explicit Whitespace
Handling</h5>
<p>Explicit whitespace notation is specified with the EBNF
productions, when it is different from the default rules, using the
notation shown below. This notation is not inherited. In other
words, if an EBNF rule is marked as /* ws: explicit */, the
notation does not automatically apply to all the 'child' EBNF
productions of that rule.</p>
<dl>
<dt class="label"><a name="ws-explicit" id="ws-explicit"></a>ws:
explicit</dt>
<dd>
<p>/* ws: explicit */ means that the EBNF notation explicitly
notates, with <code>S</code> or otherwise, where <a title=
"whitespace" href="#Whitespace">whitespace characters</a> are
allowed. In productions with the /* ws: explicit */ annotation,
<a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace
Handling</b></a> does not apply. <a href=
"#doc-xpath31-Comment">Comments</a> are also not allowed in these
productions.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-reserved-fn-names" id=
"id-reserved-fn-names"></a>A.3 Reserved Function Names</h3>
<p>The following names are not allowed as function names in an
unprefixed form because expression syntax takes precedence.</p>
<ul>
<li>
<p><code>array</code></p>
</li>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty-sequence</code></p>
</li>
<li>
<p><code>function</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>map</code></p>
</li>
<li>
<p><code>namespace-node</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>schema-attribute</code></p>
</li>
<li>
<p><code>schema-element</code></p>
</li>
<li>
<p><code>switch</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the keywords <code>switch</code> and
<code>typeswitch</code> are not used in XPath, they are considered
reserved function names for compatibility with XQuery.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-precedence-order" id="id-precedence-order"></a>A.4
Precedence Order (Non-Normative)</h3>
<p>The grammar in <a href="#id-grammar"><b>A.1 EBNF</b></a>
normatively defines built-in precedence among the operators of
XQuery. These operators are summarized here to make clear the order
of their precedence from lowest to highest. The associativity
column indicates the order in which operators of equal precedence
in an expression are applied.</p>
<table border="1">
<tbody>
<tr>
<th colspan="1">#</th>
<th colspan="1">Operator</th>
<th colspan="1">Associativity</th>
</tr>
<tr>
<td>1</td>
<td><a href="#doc-xpath31-Expr">, (comma)</a></td>
<td>either</td>
</tr>
<tr>
<td>2</td>
<td><span class="xpath"><a href=
"#doc-xpath31-ForExpr">for</a>,</span> <span class="xpath"><a href=
"#doc-xpath31-LetExpr">let</a>,</span> <a href=
"#doc-xpath31-QuantifiedExpr">some, every</a>, <a href=
"#doc-xpath31-IfExpr">if</a></td>
<td>NA</td>
</tr>
<tr>
<td>3</td>
<td><a href="#doc-xpath31-OrExpr">or</a></td>
<td>either</td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xpath31-AndExpr">and</a></td>
<td>either</td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xpath31-ValueComp">eq, ne, lt, le, gt, ge</a>,
<a href="#doc-xpath31-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xpath31-NodeComp">is, &lt;&lt;,
&gt;&gt;</a></td>
<td>NA</td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xpath31-StringConcatExpr">||</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xpath31-RangeExpr">to</a></td>
<td>NA</td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xpath31-AdditiveExpr">+, - (binary)</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>9</td>
<td><a href="#doc-xpath31-MultiplicativeExpr">*, div, idiv,
mod</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xpath31-UnionExpr">union, |</a></td>
<td>either</td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xpath31-IntersectExceptExpr">intersect,
except</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xpath31-InstanceofExpr">instance of</a></td>
<td>NA</td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xpath31-TreatExpr">treat as</a></td>
<td>NA</td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xpath31-CastableExpr">castable as</a></td>
<td>NA</td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xpath31-CastExpr">cast as</a></td>
<td>NA</td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xpath31-UnaryExpr">-, + (unary)</a></td>
<td>right-to-left</td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xpath31-SimpleMapExpr">!</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>18</td>
<td><a href="#doc-xpath31-PathExpr">/, //</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>19</td>
<td><a href="#doc-xpath31-Predicate">[ ]</a></td>
<td>left-to-right</td>
</tr>
</tbody>
</table>
<p>In the "Associativity" column, "either" indicates that all the
operators at that level have the associative property (i.e.,
<code>(A op B) op C</code> is equivalent to <code>A op (B op
C)</code>), so their associativity is inconsequential. "NA" (not
applicable) indicates that the EBNF does not allow an expression
that directly contains multiple operators from that precedence
level, so the question of their associativity does not arise.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Parentheses can be used to override the operator precedence in
the usual way. Square brackets in an expression such as A[B] serve
two roles: they act as an operator causing B to be evaluated once
for each item in the value of A, and they act as parentheses
enclosing the expression B.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-type-promotion-and-operator-mapping" id=
"id-type-promotion-and-operator-mapping"></a>B Type Promotion and
Operator Mapping</h2>
<div class="div2">
<h3><a name="promotion" id="promotion"></a>B.1 Type Promotion</h3>
<p>[<a name="dt-type-promotion" id="dt-type-promotion" title=
"type promotion">Definition</a>: Under certain circumstances, an
atomic value can be promoted from one type to another. <b>Type
promotion</b> is used in evaluating function calls (see <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a>) and operators that accept numeric or string
operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).]
The following type promotions are permitted:</p>
<ol class="enumar">
<li>
<p>Numeric type promotion:</p>
<ol class="enumla">
<li>
<p>A value of type <code>xs:float</code> (or any type derived by
restriction from <code>xs:float</code>) can be promoted to the type
<code>xs:double</code>. The result is the <code>xs:double</code>
value that is the same as the original value.</p>
</li>
<li>
<p>A value of type <code>xs:decimal</code> (or any type derived by
restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>. The
result of this promotion is created by casting the original value
to the required type. This kind of promotion may cause loss of
precision.</p>
</li>
</ol>
</li>
<li>
<p>URI type promotion: A value of type <code>xs:anyURI</code> (or
any type derived by restriction from <code>xs:anyURI</code>) can be
promoted to the type <code>xs:string</code>. The result of this
promotion is created by casting the original value to the type
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since <code>xs:anyURI</code> values can be promoted to
<code>xs:string</code>, functions and operators that compare
strings using the <a title="default collation" href=
"#dt-def-collation">default collation</a> also compare
<code>xs:anyURI</code> values using the <a title=
"default collation" href="#dt-def-collation">default collation</a>.
This ensures that orderings that include strings,
<code>xs:anyURI</code> values, or any combination of the two types
are consistent and well-defined.</p>
</div>
</li>
</ol>
<p>Note that <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> is different from <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example:</p>
<ul>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:float</code> can be invoked with a value of type
<code>xs:decimal</code>. This is an example of <a title=
"type promotion" href="#dt-type-promotion">type promotion</a>. The
value is actually converted to the expected type. Within the body
of the function, <code>$p instance of xs:decimal</code> returns
<code>false</code>.</p>
</li>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:decimal</code> can be invoked with a value of type
<code>xs:integer</code>. This is an example of <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. The value retains its original type. Within the
body of the function, <code>$p instance of xs:integer</code>
returns <code>true</code>.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="mapping" id="mapping"></a>B.2 Operator Mapping</h3>
<p>The operator mapping tables in this section list the
combinations of types for which the various operators of XPath 3.1
are defined. [<a name="dt-operator-function" id=
"dt-operator-function" title="operator function">Definition</a>:
For each operator and valid combination of operand types, the
operator mapping tables specify a result type and an <b>operator
function</b> that implements the semantics of the operator for the
given types.] The definitions of the operator functions are given
in <a href="#xpath-functions-31">[XQuery and XPath Functions and
Operators 3.1]</a>. The result of an operator may be the raising of
an error by its operator function, as defined in <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>. In some cases, the operator function does not implement
the full semantics of a given operator. For the definition of each
operator (including its behavior for empty sequences or sequences
of length greater than one), see the descriptive material in the
main part of this document.</p>
<p>The <code>and</code> and <code>or</code> operators are defined
directly in the main body of this document, and do not occur in the
operator mapping tables.</p>
<p>If an operator in the operator mapping tables expects an operand
of type <em>ET</em>, that operator can be applied to an operand of
type <em>AT</em> if type <em>AT</em> can be converted to type
<em>ET</em> by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, a table entry indicates that the
<code>gt</code> operator may be applied to two <code>xs:date</code>
operands, returning <code>xs:boolean</code>. Therefore, the
<code>gt</code> operator may also be applied to two (possibly
different) subtypes of <code>xs:date</code>, also returning
<code>xs:boolean</code>.</p>
<p>[<a name="dt-numeric" id="dt-numeric" title=
"numeric">Definition</a>: When referring to a type, the term
<b>numeric</b> denotes the types <code>xs:integer</code>,
<code>xs:decimal</code>, <code>xs:float</code>, and
<code>xs:double</code>.] An operator whose operands and result are
designated as <a title="numeric" href="#dt-numeric">numeric</a>
might be thought of as representing four operators, one for each of
the numeric types. For example, the numeric <code>+</code> operator
might be thought of as representing the following four
operators:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">Operator</td>
<td align="center">First operand type</td>
<td align="center">Second operand type</td>
<td align="center">Result type</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p>A numeric operator may be validly applied to an operand of type
<em>AT</em> if type <em>AT</em> can be converted to any of the four
numeric types by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. If the result type of an operator is listed as
numeric, it means "the first type in the ordered list
<code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into
which all operands can be converted by <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a> and <a title="type promotion" href=
"#dt-type-promotion">type promotion</a>." As an example, suppose
that the type <code>hatsize</code> is derived from
<code>xs:integer</code> and the type <code>shoesize</code> is
derived from <code>xs:float</code>. Then if the <code>+</code>
operator is invoked with operands of type <code>hatsize</code> and
<code>shoesize</code>, it returns a result of type
<code>xs:float</code>. Similarly, if <code>+</code> is invoked with
two operands of type <code>hatsize</code> it returns a result of
type <code>xs:integer</code>.</p>
<p>[<a name="dt-gregorian" id="dt-gregorian" title=
"Gregorian">Definition</a>: In the operator mapping tables, the
term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.] For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>
<table border="1" summary="Binary operators" class="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Type(A)</th>
<th colspan="1">Type(B)</th>
<th colspan="1">Function</th>
<th colspan="1">Result type</th>
</tr>
<tr>
<td>A + B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-add(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:dateTime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dateTime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-subtract(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:subtract-dates(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:subtract-dateTimes(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-multiply(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-integer-divide(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-divide(A, B)</td>
<td>numeric; but xs:decimal if both operands are xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A mod B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-mod(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A eq B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>op:duration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hexBinary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64Binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hexBinary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:hexBinary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>fn:not(op:duration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hexBinary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64Binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hexBinary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64Binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hexBinary-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64Binary-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hexBinary-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64Binary-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hexBinary-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64Binary-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hexBinary-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64Binary-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer*</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
<tr>
<td>A || B</td>
<td>xs:anyAtomicType</td>
<td>xs:anyAtomicType</td>
<td>fn:concat(A, B)</td>
<td>xs:string</td>
</tr>
</tbody>
</table>
<table border="1" summary="Unary operators" class="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th colspan="1">Operator</th>
<th colspan="1">Operand type</th>
<th colspan="1">Function</th>
<th colspan="1">Result type</th>
</tr>
<tr>
<td>+ A</td>
<td>numeric</td>
<td>op:numeric-unary-plus(A)</td>
<td>numeric</td>
</tr>
<tr>
<td>- A</td>
<td>numeric</td>
<td>op:numeric-unary-minus(A)</td>
<td>numeric</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xp-context-components" id=
"id-xp-context-components"></a>C Context Components</h2>
<p>The tables in this section describe the scope (range of
applicability) of the various components in a module's static
context and dynamic context.</p>
<div class="div2">
<h3><a name="id-xp-static-context-components" id=
"id-xp-static-context-components"></a>C.1 Static Context
Components</h3>
<p>The following table describes the components of the <b>static
context</b>. For each component, "global" indicates that the value
of the component applies throughout an XPath expression, whereas
"lexical" indicates that the value of the component applies only
within the subexpression in which it is defined.</p>
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th colspan="1">Component</th>
<th colspan="1">Scope</th>
</tr>
<tr>
<td>XPath 1.0 Compatibility Mode</td>
<td>global</td>
</tr>
<tr>
<td>Statically known namespaces</td>
<td>global</td>
</tr>
<tr>
<td>Default element/type namespace</td>
<td>global</td>
</tr>
<tr>
<td>Default function namespace</td>
<td>global</td>
</tr>
<tr>
<td>In-scope schema types</td>
<td>global</td>
</tr>
<tr>
<td>In-scope element declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope attribute declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope variables</td>
<td>lexical; for-expressions, let-expressions, and quantified
expressions can bind new variables</td>
</tr>
<tr>
<td>Context item static type</td>
<td>lexical</td>
</tr>
<tr>
<td>Statically known function signatures</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collations</td>
<td>global</td>
</tr>
<tr>
<td>Default collation</td>
<td>global</td>
</tr>
<tr>
<td>Base URI</td>
<td>global</td>
</tr>
<tr>
<td>Statically known documents</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collections</td>
<td>global</td>
</tr>
<tr>
<td>Statically known default collection type</td>
<td>global</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="id-xp-evaluation-context-components" id=
"id-xp-evaluation-context-components"></a>C.2 Dynamic Context
Components</h3>
<p>The following table describes how values are assigned to the
various components of the <b>dynamic context</b>. All these
components are initialized by mechanisms defined by the host
language. For each component, "global" indicates that the value of
the component remains constant throughout evaluation of the XPath
expression, whereas "dynamic" indicates that the value of the
component can be modified by the evaluation of subexpressions.</p>
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th colspan="1">Component</th>
<th colspan="1">Scope</th>
</tr>
<tr>
<td>Context item</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Context position</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Context size</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Variable values</td>
<td>dynamic; for-expressions, let-expressions, and quantified
expressions can bind new variables</td>
</tr>
<tr>
<td>Current date and time</td>
<td>global; must be initialized</td>
</tr>
<tr>
<td>Implicit timezone</td>
<td>global; must be initialized</td>
</tr>
<tr>
<td>Available documents</td>
<td>global; must be initialized</td>
</tr>
<tr>
<td>Available node collections</td>
<td>global; must be initialized</td>
</tr>
<tr>
<td>Default node collection</td>
<td>global; overwriteable by implementation</td>
</tr>
<tr>
<td>Available resource collections</td>
<td>global; must be initialized</td>
</tr>
<tr>
<td>Default resource collection</td>
<td>global; overwriteable by implementation</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-impl-defined-items" id=
"id-impl-defined-items"></a>D Implementation-Defined Items</h2>
<p>The following items in this specification are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumar">
<li>
<p>The version of Unicode that is used to construct
expressions.</p>
</li>
<li>
<p>The <a title="statically known collations" href=
"#dt-static-collations">statically-known collations</a>.</p>
</li>
<li>
<p>The <a title="implicit timezone" href="#dt-timezone">implicit
timezone</a>.</p>
</li>
<li>
<p>The circumstances in which <a title="warning" href=
"#dt-warning">warnings</a> are raised, and the ways in which
warnings are handled.</p>
</li>
<li>
<p>The method by which errors are reported to the external
processing environment.</p>
</li>
<li>
<p>Which version of XML and XML Names (e.g. <a href="#XML">[XML
1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or <a href=
"#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names
1.1]</a>) and which version of XML Schema (e.g. <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a>) is used for the definitions of primitives such as
characters and names, and for the definitions of operations such as
normalization of line endings and normalization of whitespace in
attribute values. It is recommended that the latest applicable
version be used (even if it is published later than this
specification).</p>
</li>
<li>
<p>How XDM instances are created from sources other than an Infoset
or PSVI.</p>
</li>
<li>
<p>Whether the implementation supports the namespace axis.</p>
</li>
<li>
<p>Whether the type system is based on <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. An
implementation that has based its type system on XML Schema 1.0 is
not required to support the use of the xs:dateTimeStamp constructor
or the use of xs:dateTimeStamp as TypeName in any expression.</p>
</li>
<li>
<p>The signatures of functions provided by the implementation or
via an implementation-defined API (see <a href=
"#static_context"><b>2.1.1 Static Context</b></a>).</p>
</li>
<li>
<p>Any <a title="environment variables" href=
"#dt-environment-variables">environment variables</a> provided by
the implementation.</p>
</li>
<li>
<p>Any rules used for static typing (see <a href=
"#id-static-analysis"><b>2.2.3.1 Static Analysis
Phase</b></a>).</p>
</li>
<li>
<p>Any serialization parameters provided by the implementationn</p>
</li>
<li>
<p>What error, if any, is returned if an external function's
implementation does not return the declared result type (see
<a href="#id-consistency-constraints"><b>2.2.4 Consistency
Constraints</b></a>).</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Additional <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> items are
listed in <a href="#xpath-datamodel-31">[XQuery and XPath Data
Model (XDM) 3.1]</a> and <a href="#xpath-functions-31">[XQuery and
XPath Functions and Operators 3.1]</a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-references" id="id-references"></a>E
References</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 Normative References</h3>
<dl>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3986" id=
"RFC3986"></a>RFC3986</span></dt>
<dd>
<div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3987" id=
"RFC3987"></a>RFC3987</span></dt>
<dd>
<div>M. Duerst and M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
</dd>
<dt class="label"><span><a name="ISO10646" id=
"ISO10646"></a>ISO/IEC 10646</span></dt>
<dd>
<div>ISO (International Organization for Standardization).
<em>ISO/IEC 10646:2003. Information technology—Universal
Multiple-Octet Coded Character Set (UCS)</em>, as, from time to
time, amended, replaced by a new edition, or expanded by the
addition of new parts. [Geneva]: International Organization for
Standardization. (See <a href=
"http://www.iso.org">http://www.iso.org</a> for the latest
version.)</div>
</dd>
<dt class="label"><span><a name="Unicode" id=
"Unicode"></a>Unicode</span></dt>
<dd>
<div>The Unicode Consortium. <em>The Unicode Standard</em> Reading,
Mass.: Addison-Wesley, 2003, as updated from time to time by the
publication of new versions. See <a href=
"http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
for the latest version and additional information on versions of
the standard and of the Unicode Character Database. The version of
Unicode to be used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations are recommended to use the latest Unicode
version.</div>
</dd>
<dt class="label"><span><a name="XML" id="XML"></a>XML
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>.
The edition of XML 1.0 must be no earlier than the Third Edition;
the edition used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</div>
</dd>
<dt class="label"><span><a name="XML1.1" id="XML1.1"></a>XML
1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.1.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></div>
</dd>
<dt class="label"><span><a name="XMLBASE" id="XMLBASE"></a>XML
Base</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Base.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES" id="XMLNAMES"></a>XML
Names</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES11" id=
"XMLNAMES11"></a>XML Names 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div>
</dd>
<dt class="label"><span><a name="XMLID" id="XMLID"></a>XML
ID</span></dt>
<dd>
<div>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></div>
</dd>
<dt class="label"><span><a name="XMLSchema10" id=
"XMLSchema10"></a>XML Schema 1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2
(Second Edition)</em>. W3C Recommendation, 28 October 2004. See
<a href=
"http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
<a href=
"http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</div>
</dd>
<dt class="label"><span><a name="XMLSchema11" id=
"XMLSchema11"></a>XML Schema 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema, Parts 1, and
2</em>. W3C Recommendation 5 April 2012. See <a href=
"http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.</div>
</dd>
<dt class="label"><span><a name="xpath-datamodel-31" id=
"xpath-datamodel-31"></a>XQuery and XPath Data Model (XDM)
3.1</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-31/"><cite>XQuery and XPath
Data Model (XDM) 3.1</cite></a>, Norman Walsh, John Snelson,
Editors. World Wide Web Consortium, 24 April 2014. This version is
http://www.w3.org/TR/2014/WD-xpath-datamodel-31-20140424/. The
<a href="http://www.w3.org/TR/xpath-datamodel-31/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-31/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-31" id=
"xpath-functions-31"></a>XQuery and XPath Functions and Operators
3.1</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-31/"><cite>XQuery and XPath
Functions and Operators 3.1</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 24 April 2014. This version is
http://www.w3.org/TR/2014/WD-xpath-functions-31-20140424/. The
<a href="http://www.w3.org/TR/xpath-functions-31/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-31/.</div>
</dd>
<dt class="label"><span><a name="xslt-xquery-serialization-31" id=
"xslt-xquery-serialization-31"></a>XSLT and XQuery Serialization
3.1</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-31/"><cite>XSLT and
XQuery Serialization 3.1</cite></a>, Michael Spreberg-McQueen and
Andy Coleman, Editors. World Wide Web Consortium, 24 April 2014.
This version is
http://www.w3.org/TR/2014/WD-xslt-xquery-serialization-31-20140424/.
The <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-31/">latest
version</a> is available at
http://www.w3.org/TR/xslt-xquery-serialization-31/.</div>
</dd>
<dt class="label"><span><a name="xquery-update-30" id=
"xquery-update-30"></a>XQuery Update Facility 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-update-30/"><cite>XQuery
Update Facility 3.0</cite></a>, John Snelson, Editor. World Wide
Web Consortium, 08 January 2013. This version is
http://www.w3.org/TR/2013/WD-xquery-update-30-20130108/. The
<a href="http://www.w3.org/TR/xquery-update-30/">latest version</a>
is available at http://www.w3.org/TR/xquery-update-30/.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 Non-normative References</h3>
<dl>
<dt class="label"><span><a name="xquery-30" id=
"xquery-30"></a>XQuery 3.0: An XML Query Language</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-30/"><cite>XQuery 3.0: An
XML Query Language</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xquery-30-20140408/. The <a href=
"http://www.w3.org/TR/xquery-30/">latest version</a> is available
at http://www.w3.org/TR/xquery-30/.</div>
</dd>
<dt class="label"><span class="xpath"><a name="xquery-31" id=
"xquery-31"></a>XQuery 3.1: An XML Query Language</span></dt>
<dd>
<div class="xpath"><a href=
"http://www.w3.org/TR/xquery-31/"><cite>XQuery 3.1: An XML Query
Language</cite></a>, Jonathan Robie, Michael Dyck, John Snelson,
Editors. World Wide Web Consortium, 24 April 2014. This version is
http://www.w3.org/TR/2014/WD-xquery-31-20140424/. The <a href=
"http://www.w3.org/TR/xquery-31/">latest version</a> is available
at http://www.w3.org/TR/xquery-31/.</div>
</dd>
<dt class="label"><span><a name="xquery-semantics" id=
"xquery-semantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-semantics/"><cite>XQuery
1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>,
Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>,
Editors. World Wide Web Consortium, 14 December 2010. This version
is http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. The
<a href="http://www.w3.org/TR/xquery-semantics/">latest version</a>
is available at http://www.w3.org/TR/xquery-semantics/.</div>
</dd>
<dt class="label"><span><a name="xslt-30" id="xslt-30"></a>XSL
Transformations (XSLT) Version 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt-30/"><cite>XSL
Transformations (XSLT) Version 3.0</cite></a>, Michael Kay, Editor.
World Wide Web Consortium, 12 December 2013. This version is
http://www.w3.org/TR/2013/WD-xslt-30-20131212/. The <a href=
"http://www.w3.org/TR/xslt-30/">latest version</a> is available at
http://www.w3.org/TR/xslt-30/.</div>
</dd>
<dt class="label"><span><a name="DOM" id="DOM"></a>Document Object
Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Document Object Model (DOM)
Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004.
See <a href=
"http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</div>
</dd>
<dt class="label"><span><a name="XINFO" id="XINFO"></a>XML
Infoset</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></div>
</dd>
<dt class="label"><span><a name="xpath" id="xpath"></a>XML Path
Language (XPath) Version 1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath/"><cite>XML Path Language
(XPath) Version 1.0</cite></a>, James Clark and Steven DeRose,
Editors. World Wide Web Consortium, 16&#160;Nov&#160;1999. This
version is http://www.w3.org/TR/1999/REC-xpath-19991116. The
<a href="http://www.w3.org/TR/xpath/">latest version</a> is
available at http://www.w3.org/TR/xpath.</div>
</dd>
<dt class="label"><span><a name="xpath20" id="xpath20"></a>XML Path
Language (XPath) Version 2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath20/"><cite>XML Path
Language (XPath) 2.0 (Second Edition)</cite></a>, Don Chamberlin,
Anders Berglund, Scott Boag, <em>et. al.</em>, Editors. World Wide
Web Consortium, 14 December 2010. This version is
http://www.w3.org/TR/2010/REC-xpath20-20101214/. The <a href=
"http://www.w3.org/TR/xpath20/">latest version</a> is available at
http://www.w3.org/TR/xpath20/.</div>
</dd>
<dt class="label"><span><a name="xpath-30" id="xpath-30"></a>XML
Path Language (XPath) Version 3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-30/"><cite>XML Path
Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xpath-30-20140408/. The <a href=
"http://www.w3.org/TR/xpath-30/">latest version</a> is available at
http://www.w3.org/TR/xpath-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-31" id="xpath-31"></a>XML
Path Language (XPath) Version 3.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-31/"><cite>XML Path
Language (XPath) 3.1</cite></a>, Jonathan Robie, Michael Dyck, John
Snelson, Editors. World Wide Web Consortium, 24 April 2014. This
version is http://www.w3.org/TR/2014/WD-xpath-31-20140424/. The
<a href="http://www.w3.org/TR/xpath-31/">latest version</a> is
available at http://www.w3.org/TR/xpath-31/.</div>
</dd>
<dt class="label"><span><a name="XPTR" id=
"XPTR"></a>XPointer</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Pointer Language
(XPointer).</em> W3C Last Call Working Draft 8 January 2001. See
<a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-material" id=
"id-background-material"></a>E.3 Background Material</h3>
<dl>
<dt class="label"><span><a name="CHARMOD" id=
"CHARMOD"></a>Character Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Character Model for the World
Wide Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</div>
</dd>
<dt class="label"><span><a name="xslt" id="xslt"></a>XSL
Transformations (XSLT) Version 1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations
(XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web
Consortium, 16&#160;Nov&#160;1999. This version is
http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href=
"http://www.w3.org/TR/xslt">latest version</a> is available at
http://www.w3.org/TR/xslt.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="id-xpath-conformance" id="id-xpath-conformance"></a>F
Conformance</h2>
<p>XPath is intended primarily as a component that can be used by
other specifications. Therefore, XPath relies on specifications
that use it (such as <a href="#XPTR">[XPointer]</a> and <a href=
"#xslt-30">[XSL Transformations (XSLT) Version 3.0]</a>) to specify
conformance criteria for XPath in their respective environments.
Specifications that set conformance criteria for their use of XPath
must not change the syntactic or semantic definitions of XPath as
given in this specification, except by subsetting and/or compatible
extensions.</p>
<p>The specification of such a language may describe it as an
extension of XPath provided that every expression that conforms to
the XPath grammar behaves as described in this specification.</p>
<div class="div2">
<h3><a name="id-xpath-static-typing" id=
"id-xpath-static-typing"></a>F.1 Static Typing Feature</h3>
<p>[<a name="dt-xpath-static-typing-feature" id=
"dt-xpath-static-typing-feature" title=
"static typing feature">Definition</a>: The <b>Static Typing
Feature</b> is an optional feature of XPath that provides support
for static semantics, and requires implementations to detect and
report <a title="type error" href="#dt-type-error">type errors</a>
during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>.] Specifications
that use XPath may specify conformance criteria for use of the
Static Typing Feature.</p>
<p>If an implementation does not support the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a>, but
can nevertheless determine during the static analysis phase that
<span class="xpath">an XPath expression</span>, if evaluated, would
necessarily raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> or that an expression, if
evaluated, would necessarily raise a <a title="type error" href=
"#dt-type-error">type error</a>, the implementation may raise that
error during the static analysis phase. The choice of whether to
raise such an error at analysis time is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation dependent</a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>G Error Conditions</h2>
<dl>
<dt><a name="ERRXPST0001" id="ERRXPST0001"></a>err:XPST0001</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if analysis of an expression relies on some component of
the <a title="static context" href="#dt-static-context">static
context</a> that <span>is <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup></span>
.</p>
</dd>
<dt><a name="ERRXPDY0002" id="ERRXPDY0002"></a>err:XPDY0002</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if evaluation of an
expression relies on some part of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> that <span>is
<a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup></span>
.</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression is not a valid instance of the grammar
defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, an expression is
found to have a <a title="static type" href=
"#dt-static-type">static type</a> that is not appropriate for the
context in which the expression occurs, or during the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a value does not match a
required type as specified by the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.5 SequenceType
Matching</b></a>.</p>
</dd>
<dt><a name="ERRXPST0005" id="ERRXPST0005"></a>err:XPST0005</dt>
<dd>
<p>During the analysis phase, it is a <a title="static error" href=
"#dt-static-error">static error</a> if the <a title="static type"
href="#dt-static-type">static type</a> assigned to an expression
other than the expression <code>()</code> or <code>data(())</code>
is <code>empty-sequence()</code>.</p>
</dd>
<dt><a name="ERRXPST0008" id="ERRXPST0008"></a>err:XPST0008</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression refers to an element name, attribute
name, schema type name, namespace prefix, or variable name that is
not defined in the <a title="static context" href=
"#dt-static-context">static context</a>, except for an ElementName
in an <a href="#doc-xpath31-ElementTest">ElementTest</a> or an
AttributeName in an <a href=
"#doc-xpath31-AttributeTest">AttributeTest</a>.</p>
</dd>
<dt><a name="ERRXPST0010" id="ERRXPST0010"></a>err:XPST0010</dt>
<dd>
<p>An implementation that does not support the namespace axis must
raise a <a title="static error" href="#dt-static-error">static
error</a> if it encounters a reference to the namespace axis and
XPath 1.0 compatibility mode is false.</p>
</dd>
<dt><a name="ERRXPST0017" id="ERRXPST0017"></a>err:XPST0017</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and number of arguments in
a <span>static</span> function call do not match the name and arity
of a <a title="statically known function signatures" href=
"#dt-known-func-signatures">function signature</a> in the <a title=
"static context" href="#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXPTY0018" id="ERRXPTY0018"></a>err:XPTY0018</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the result of a path operator contains both nodes and
non-nodes.</p>
</dd>
<dt><a name="ERRXPTY0019" id="ERRXPTY0019"></a>err:XPTY0019</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if <code>E1</code> in a path expression
<code>E1/E2</code> does not evaluate to a sequence of nodes.</p>
</dd>
<dt><a name="ERRXPTY0020" id="ERRXPTY0020"></a>err:XPTY0020</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, in an axis step, the context item is not a node.</p>
</dd>
<dt><a name="ERRXQST0039" id="ERRXQST0039"></a>err:XQST0039</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> for <span>an inline function expression</span> to have
more than one parameter with the same name.</p>
</dd>
<dt><a name="ERRXQST0046" id="ERRXQST0046"></a>err:XQST0046</dt>
<dd>
<p>An implementation <span class="xpath">MAY</span> raise a
<a title="static error" href="#dt-static-error">static error</a> if
the value of a <a href=
"#doc-xpath31-BracedURILiteral">BracedURILiteral</a> is of nonzero
length and is <span>neither an absolute URI nor a relative
URI</span>.</p>
</dd>
<dt><a name="ERRXPDY0050" id="ERRXPDY0050"></a>err:XPDY0050</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of the
operand of a <code>treat</code> expression does not match the
<a title="sequence type" href="#dt-sequence-type">sequence type</a>
specified by the <code>treat</code> expression. This error might
also be raised by a path expression beginning with "<code>/</code>"
or "<code>//</code>" if the context node is not in a tree that is
rooted at a document node. This is because a leading
"<code>/</code>" or "<code>//</code>" in a path expression is an
abbreviation for an initial step that includes the clause
<code>treat as document-node()</code>.</p>
</dd>
<dt><a name="ERRXPST0051" id="ERRXPST0051"></a>err:XPST0051</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> for an <a href=
"#doc-xpath31-AtomicOrUnionType">AtomicOrUnionType</a> in a
<a href="#doc-xpath31-SequenceType">SequenceType</a> is not defined
in the <a title="in-scope schema type" href="#dt-is-types">in-scope
schema types</a> as a <a title="generalized atomic type" href=
"#dt-generalized-atomic-type">generalized atomic type</a>.</p>
</dd>
<dt><a name="ERRXQST0052" id="ERRXQST0052"></a>err:XQST0052</dt>
<dd>
<p>The type must be the name of a type defined in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, and the <code>{variety}</code> of the type must be
<code>simple</code>.</p>
</dd>
<dt><a name="ERRXQST0070" id="ERRXQST0070"></a>err:XQST0070</dt>
<dd>
<p>A <a title="static error" href="#dt-static-error">static
error</a> is raised if one of the predefined prefixes
<code>xml</code> or <code>xmlns</code> appears in a namespace
declaration <span>or a default namespace declaration,</span> or if
any of the following conditions is statically detected in any
expression or declaration:</p>
<ul>
<li>
<p>The prefix <code>xml</code> is bound to some namespace URI other
than <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>A prefix other than <code>xml</code> is bound to the namespace
URI <code>http://www.w3.org/XML/1998/namespace</code>.</p>
</li>
<li>
<p>The prefix <code>xmlns</code> is bound to any namespace URI.</p>
</li>
<li>
<p>A prefix other than <code>xmlns</code> is bound to the namespace
URI <code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
</ul>
</dd>
<dt><a name="ERRXPST0080" id="ERRXPST0080"></a>err:XPST0080</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the target type of a <code>cast</code> or
<code>castable</code> expression is <code>xs:NOTATION</code>
<span><code>xs:anySimpleType</code>,</span> or
<code>xs:anyAtomicType</code>.</p>
</dd>
<dt><a name="ERRXPST0081" id="ERRXPST0081"></a>err:XPST0081</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a QName used in <span class="xpath">an
expression</span> contains a namespace prefix that cannot be
expanded into a namespace URI by using the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
</dd>
<dt><a name="ERRXPTY0117" id="ERRXPTY0117"></a>err:XPTY0117</dt>
<dd>
<p>In a cast expression, if an item is of type
<code>xs:untypedAtomic</code> and the expected type is <a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">namespace-sensitive</a>, a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is
raised.</p>
</dd>
<dt><a name="ERRXPDY0130" id="ERRXPDY0130"></a>err:XPDY0130</dt>
<dd>
<p>An implementation-defined limit has been exceeded.</p>
</dd>
<dt><a name="ERRXPST0133" id="ERRXPST0133"></a>err:XPST0133</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> [<a href="#ERRXPST0133" title=
"err:XPST0133">err:XPST0133</a>] if the namespace URI for an EQName
is <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a name="ERRXQST0134" id="ERRXQST0134"></a>err:XQST0134</dt>
<dd>
<p>XQuery 3.0 does not support the namespace axis.</p>
</dd>
<dt><a name="ERRXQDY0136" id="ERRXQDY0136"></a>err:XQDY0136</dt>
<dd>
<p>A map key must be a single atomic value.</p>
</dd>
<dt><a name="ERRXQDY0137" id="ERRXQDY0137"></a>err:XQDY0137</dt>
<dd>
<p>No two keys in a map may have the <a title="same key" href=
"#dt-same-key">same key value</a>.</p>
</dd>
<dt><a name="ERRXQDY0138" id="ERRXQDY0138"></a>err:XQDY0138</dt>
<dd>
<p>Position <code>n</code> does not exist in this array.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-glossary" id="id-glossary"></a>H Glossary
(Non-Normative)</h2>
<dl>
<dt><a name="GLdt-gregorian" id="GLdt-gregorian"></a>Gregorian</dt>
<dd>
<p>In the operator mapping tables, the term <b>Gregorian</b> refers
to the types <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</p>
</dd>
<dt><a name="GLid-static-decimal-format-NaN" id=
"GLid-static-decimal-format-NaN"></a>NaN</dt>
<dd>
<p><b>NaN</b> specifies the string used for the NaN-symbol, which
is used to represent the value NaN (not-a-number); the default
value is the string "NaN"</p>
</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>
<p><b>SequenceType matching</b> compares the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
with an expected <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>.</p>
</dd>
<dt><a name="GLdt-static-base-uri" id=
"GLdt-static-base-uri"></a>Static Base URI</dt>
<dd>
<p><b>Static Base URI.</b> This is an absolute URI, used to resolve
<span class="xpath">relative URI references.</span></p>
</dd>
<dt><a name="GLdt-URI" id="GLdt-URI"></a>URI</dt>
<dd>
<p>Within this specification, the term <b>URI</b> refers to a
Universal Resource Identifier as defined in <a href=
"#RFC3986">[RFC3986]</a> and extended in <a href=
"#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p>
</dd>
<dt><a name="GLdt-data-model-instance" id=
"GLdt-data-model-instance"></a>XDM instance</dt>
<dd>
<p>The term <b>XDM instance</b> is used, synonymously with the term
<a title="value" href="#dt-value">value</a>, to denote an
unconstrained <a title="sequence" href="#dt-sequence">sequence</a>
of <a title="item" href="#dt-item">items</a> in the <a title=
"data model" href="#dt-datamodel">data model</a>.</p>
</dd>
<dt><a name="GLdt-xpath-10-processor" id=
"GLdt-xpath-10-processor"></a>XPath 1.0 Processor</dt>
<dd>
<p>An <b>XPath 1.0 Processor</b> processes a query according to the
XPath 1.0 specification.</p>
</dd>
<dt><a name="GLdt-xpath-compat-mode" id=
"GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd>
<p><b>XPath 1.0 compatibility mode.</b> <span class="xpath">This
value is <code>true</code> if rules for backward compatibility with
XPath Version 1.0 are in effect; otherwise it is
<code>false</code>.</span></p>
</dd>
<dt><a name="GLdt-xpath-20-processor" id=
"GLdt-xpath-20-processor"></a>XPath 2.0 Processor</dt>
<dd>
<p>An <b>XPath 2.0 Processor</b> processes a query according to the
XPath 2.0 specification.</p>
</dd>
<dt><a name="GLdt-xpath-30-processor" id=
"GLdt-xpath-30-processor"></a>XPath 3.0 Processor</dt>
<dd>
<p>An <b>XPath 3.0 Processor</b> processes a query according to the
XPath 3.0 specification.</p>
</dd>
<dt><a name="GLdt-arg-expr" id="GLdt-arg-expr"></a>argument
expression</dt>
<dd>
<p>An argument to a function call is either an <b>argument
expression</b> or an ArgumentPlaceholder ("?").</p>
</dd>
<dt><a name="GLdt-arg-value" id="GLdt-arg-value"></a>argument
value</dt>
<dd>
<p><a title="argument expression" href="#dt-arg-expr">Argument
expressions</a> are evaluated with respect to <var>DC</var>,
producing <b>argument values</b>.</p>
</dd>
<dt><a name="GLdt-argumentlist-arity" id=
"GLdt-argumentlist-arity"></a>arity</dt>
<dd>
<p>The number of <code>Argument</code>s in an
<code>ArgumentList</code> is its <b>arity</b>.</p>
</dd>
<dt><a name="GLdt-array" id="GLdt-array"></a>array</dt>
<dd>
<p>An <b>array</b> is a <span>function</span> that associates a set
of positions, represented as positive integer keys, with
values.</p>
</dd>
<dt><a name="GLdt-arrow-operator" id=
"GLdt-arrow-operator"></a>arrow operator</dt>
<dd>
<p>An <b>arrow operator</b> is a postfix operator that applies a
function to an item, using the item as the first argument to the
function.</p>
</dd>
<dt><a name="GLdt-associated-value" id=
"GLdt-associated-value"></a>associated value</dt>
<dd>
<p>The value associated with a given key is called the
<b>associated value</b> of the key.</p>
</dd>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic
value</dt>
<dd>
<p>An <b>atomic value</b> is a value in the value space of an
<b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML
Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p>
</dd>
<dt><a name="GLdt-atomization" id=
"GLdt-atomization"></a>atomization</dt>
<dd>
<p><b>Atomization</b> of a sequence is defined as the result of
invoking the <code>fn:data</code> function on the sequence, as
defined in <a href="#xpath-functions-31">[XQuery and XPath
Functions and Operators 3.1]</a>.</p>
</dd>
<dt><a name="GLdt-available-docs" id=
"GLdt-available-docs"></a>available documents</dt>
<dd>
<p><b>Available documents.</b> This is a mapping of strings to
document nodes. Each string represents the absolute URI of a
resource. The document node is the root of a tree that represents
that resource using the <a title="data model" href=
"#dt-datamodel">data model</a>. The document node is returned by
the <code>fn:doc</code> function when applied to that URI.</p>
</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available node collections</dt>
<dd>
<p><b>Available node collections.</b> This is a mapping of strings
to sequences of nodes. Each string represents the absolute URI of a
resource. The sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument.</p>
</dd>
<dt><a name="GLdt-available-resource-collections" id=
"GLdt-available-resource-collections"></a>available resource
collections</dt>
<dd>
<p><b>Available resource collections.</b> This is a mapping of
strings to sequences of URIs. The string represents the absolute
URI of a resource which can be interpreted as an aggregation of a
number of individual resources each of which has its own URI. The
sequence of URIs represents the result of the
<code>fn:uri-collection</code> function when that URI is supplied
as the argument.</p>
</dd>
<dt><a name="GLdt-available-text-resources" id=
"GLdt-available-text-resources"></a>available text resources</dt>
<dd>
<p><b>Available text resources</b>. This is a mapping of strings to
text resources. Each string represents the absolute URI of a
resource. The resource is returned by the
<code>fn:unparsed-text</code> function when applied to that
URI.</p>
</dd>
<dt><a name="GLdt-axis-step" id="GLdt-axis-step"></a>axis step</dt>
<dd>
<p>An <b>axis step</b> returns a sequence of nodes that are
reachable from the context node via a specified axis. Such a step
has two parts: an <b>axis</b>, which defines the "direction of
movement" for the step, and a <a title="node test" href=
"#dt-node-test">node test</a>, which selects nodes based on their
kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</dd>
<dt><a name="GLdt-built-in-function" id=
"GLdt-built-in-function"></a>built-in function</dt>
<dd>
<p>The <b>built-in functions</b> supported by XPath 3.1 are defined
in <a href="#xpath-functions-31">[XQuery and XPath Functions and
Operators 3.1]</a>.</p>
</dd>
<dt><a name="GLdt-collation" id="GLdt-collation"></a>collation</dt>
<dd>
<p>A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
</dd>
<dt><a name="GLdt-comma-operator" id=
"GLdt-comma-operator"></a>comma operator</dt>
<dd>
<p>One way to construct a sequence is by using the <b>comma
operator</b>, which evaluates each of its operands and concatenates
the resulting sequences, in order, into a single result
sequence.</p>
</dd>
<dt><a name="GLdt-constructor-function" id=
"GLdt-constructor-function"></a>constructor function</dt>
<dd>
<p>The <b>constructor function</b> for a given type is used to
convert instances of other atomic types into the given type. The
semantics of the constructor function call <code>T($arg)</code> are
defined to be equivalent to the expression <code>(($arg) cast as
T?)</code>.</p>
</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context
item</dt>
<dd>
<p>The <b>context item</b> is the <a title="item" href=
"#dt-item">item</a> currently being processed.</p>
</dd>
<dt><a name="GLdt-context-item-static-type" id=
"GLdt-context-item-static-type"></a>context item static type</dt>
<dd>
<p><b>Context item static type.</b> This component defines the
<a title="static type" href="#dt-static-type">static type</a> of
the context item within the scope of a given expression.</p>
</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context
node</dt>
<dd>
<p>When the context item is a node, it can also be referred to as
the <b>context node</b>.</p>
</dd>
<dt><a name="GLdt-context-position" id=
"GLdt-context-position"></a>context position</dt>
<dd>
<p>The <b>context position</b> is the position of the context item
within the sequence of items currently being processed.</p>
</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context
size</dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence
of items currently being processed.</p>
</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current
dateTime</dt>
<dd>
<p><b>Current dateTime.</b> This information represents an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xpath">an
expression</span>, and includes an explicit timezone. It can be
retrieved by the <code>fn:current-dateTime</code> function. If
invoked multiple times during the execution of <span class=
"xpath">an expression</span>, this function always returns the same
result.</p>
</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
model</dt>
<dd>
<p>XPath 3.1 operates on the abstract, logical structure of an XML
document, rather than its surface syntax. This logical structure,
known as the <b>data model</b>, is defined in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM)
3.1]</a>.</p>
</dd>
<dt><a name="GLid-static-decimal-separator" id=
"GLid-static-decimal-separator"></a>decimal-separator</dt>
<dd>
<p><b>decimal-separator</b> specifies the character used for the
decimal-separator-symbol; the default value is the period character
(.)</p>
</dd>
<dt><a name="GLdt-default-calendar" id=
"GLdt-default-calendar"></a>default calendar</dt>
<dd>
<p><b>Default calendar.</b> This is the calendar used when
formatting dates in human-readable output (for example, by the
functions <code>fn:format-date</code> and
<code>fn:format-dateTime</code>) if no other calendar is requested.
The value is a string.</p>
</dd>
<dt><a name="GLdt-def-collation" id=
"GLdt-def-collation"></a>default collation</dt>
<dd>
<p><b>Default collation.</b> This identifies one of the collations
in <a title="statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.</p>
</dd>
<dt><a name="GLdt-def-elemtype-ns" id=
"GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<p><b>Default element/type namespace.</b> This is a namespace URI
or <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where an element or type name is
expected.</p>
</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default
function namespace</dt>
<dd>
<p><b>Default function namespace.</b> This is a namespace URI or
<a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.
The namespace URI, if present, is used for any unprefixed QName
appearing in a position where a function name is expected.</p>
</dd>
<dt><a name="GLdt-default-language" id=
"GLdt-default-language"></a>default language</dt>
<dd>
<p><b>Default language.</b> This is the natural language used when
creating human-readable output (for example, by the functions
<code>fn:format-date</code> and <code>fn:format-integer</code>) if
no other language is requested. The value is a language code as
defined by the type <code>xs:language</code>.</p>
</dd>
<dt><a name="GLdt-default-collection" id=
"GLdt-default-collection"></a>default node collection</dt>
<dd>
<p><b>Default node collection.</b> This is the sequence of nodes
that would result from calling the <code>fn:collection</code>
function with no arguments.</p>
</dd>
<dt><a name="GLdt-default-place" id=
"GLdt-default-place"></a>default place</dt>
<dd>
<p><b>Default place.</b> This is a geographical location used to
identify the place where events happened (or will happen) when
formatting dates and times using functions such as
<code>fn:format-date</code> and <code>fn:format-dateTime</code>, if
no other place is specified. It is used when translating timezone
offsets to civil timezone names, and when using calendars where the
translation from ISO dates/times to a local representation is
dependent on geographical location. Possible representations of
this information are an ISO country code or an Olson timezone name,
but implementations are free to use other representations from
which the above information can be derived.</p>
</dd>
<dt><a name="GLdt-default-resource-collection" id=
"GLdt-default-resource-collection"></a>default resource
collection</dt>
<dd>
<p><b>Default resource collection.</b> This is the sequence of URIs
that would result from calling the <code>fn:uri-collection</code>
function with no arguments.</p>
</dd>
<dt><a name="GLdelimiting-token" id=
"GLdelimiting-token"></a>delimiting terminal symbol</dt>
<dd>
<p>The <b>delimiting terminal symbols</b> are: "!", "!=", <a href=
"#prod-xpath31-StringLiteral">StringLiteral</a>, "#", "$", "(",
")", "*", "+", (comma), "-", (dot), "..", "/", "//", (colon), "::",
":=", "&lt;", "&lt;&lt;", "&lt;=", "=", "=&gt;", "&gt;", "&gt;=",
"&gt;&gt;", "?", "@", <a href=
"#prod-xpath31-BracedURILiteral">BracedURILiteral</a>, "[", "]",
"{", "|", "||", "}"</p>
</dd>
<dt><a name="GLid-static-decimal-format-digit-sign" id=
"GLid-static-decimal-format-digit-sign"></a>digit-sign</dt>
<dd>
<p><b>digit-sign</b> specifies the character used for the
digit-sign in the picture string; the default value is the number
sign character (#)</p>
</dd>
<dt><a name="GLdt-document-order" id=
"GLdt-document-order"></a>document order</dt>
<dd>
<p>Informally, <b>document order</b> is the order in which nodes
appear in the XML serialization of a document.</p>
</dd>
<dt><a name="GLdt-dynamic-context" id=
"GLdt-dynamic-context"></a>dynamic context</dt>
<dd>
<p>The <b>dynamic context</b> of an expression is defined as
information that is available at the time the expression is
evaluated.</p>
</dd>
<dt><a name="GLdt-dynamic-error" id=
"GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<p>A <b>dynamic error</b> is an error that must be detected during
the dynamic evaluation phase and may be detected during the static
analysis phase. Numeric overflow is an example of a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> .</p>
</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd>
<p>The <b>dynamic evaluation phase</b> is the phase during which
the value of an expression is computed.</p>
</dd>
<dt><a name="GLdt-dynamic-function-invocation" id=
"GLdt-dynamic-function-invocation"></a>dynamic function call</dt>
<dd>
<p>A <b>dynamic function call</b> consists of a base expression
that returns the function and a parenthesized list of zero or more
arguments (<a title="argument expression" href=
"#dt-arg-expr">argument expressions</a> or
ArgumentPlaceholders).</p>
</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic
type</dt>
<dd>
<p>A <b>dynamic type</b> is associated with each value as it is
computed. The dynamic type of a value may be more specific than the
<a title="static type" href="#dt-static-type">static type</a> of
the expression that computed it (for example, the static type of an
expression might be <code>xs:integer*</code>, denoting a sequence
of zero or more integers, but at evaluation time its value may have
the dynamic type <code>xs:integer</code>, denoting exactly one
integer.)</p>
</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
value</dt>
<dd>
<p>The <b>effective boolean value</b> of a value is defined as the
result of applying the <code>fn:boolean</code> function to the
value, as defined in <a href="#xpath-functions-31">[XQuery and
XPath Functions and Operators 3.1]</a>.</p>
</dd>
<dt><a name="GLdt-empty-sequence" id=
"GLdt-empty-sequence"></a>empty sequence</dt>
<dd>
<p>A sequence containing zero items is called an <b>empty
sequence</b>.</p>
</dd>
<dt><a name="GLdt-entry" id="GLdt-entry"></a>entry</dt>
<dd>
<p>Each key / value pair in a map is called an <b>entry</b>.</p>
</dd>
<dt><a name="GLdt-environment-variables" id=
"GLdt-environment-variables"></a>environment variables</dt>
<dd>
<p><b>Environment variables.</b> This is a mapping from names to
values. Both the names and the values are strings. The names are
compared using an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> collation,
and are unique under this collation. The set of environment
variables is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> and
<strong>may</strong> be empty.</p>
</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error
value</dt>
<dd>
<p>In addition to its identifying QName, a dynamic error may also
carry a descriptive string and one or more additional values called
<b>error values</b>.</p>
</dd>
<dt><a name="GLdt-expanded-qname" id=
"GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<p>An <b>expanded QName</b> consists of an optional namespace URI
and a local name. An expanded QName also retains its original
namespace prefix (if any), to facilitate casting the expanded QName
into a string.</p>
</dd>
<dt><a name="GLid-static-decimal-format-exponent-separator" id=
"GLid-static-decimal-format-exponent-separator"></a>exponent-separator</dt>
<dd>
<p><b>exponent-separator</b> Defines the character used to separate
the mantissa from the exponent in scientific notation both in the
picture string and in the formatted number; the default value is
the character (e).</p>
</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>
<p>The <b>expression context</b> for a given expression consists of
all the information that can affect the result of the
expression.</p>
</dd>
<dt><a name="GLdt-filter-expression" id=
"GLdt-filter-expression"></a>filter expression</dt>
<dd>
<p>An expression followed by a predicate (that is,
<code>E1[E2]</code>) is referred to as a <b>filter expression</b>:
its effect is to return those items from the value of
<code>E1</code> that satisfy the predicate in E2.</p>
</dd>
<dt><a name="GLdt-fixed-position" id=
"GLdt-fixed-position"></a>fixed position</dt>
<dd>
<p>In a partial function application, a <b>fixed position</b> is an
argument/parameter position for which the <code>ArgumentList</code>
has an argument expression (as opposed to an
<code>ArgumentPlaceholder</code>).</p>
</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd>
<p>The first three components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> (context item,
context position, and context size) are called the <b>focus</b> of
the expression.</p>
</dd>
<dt><a name="GLdt-function-item-coercion" id=
"GLdt-function-item-coercion"></a>function coercion</dt>
<dd>
<p><b>Function coercion</b> wraps a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
in a new function with signature the same as the expected type.
This effectively delays the checking of the argument and return
types until the function is invoked.</p>
</dd>
<dt><a name="GLdt-function-conversion" id=
"GLdt-function-conversion"></a>function conversion rules</dt>
<dd>
<p>The <b>function conversion rules</b> are used to convert an
argument value to its expected type; that is, to the declared type
of the function <span class="xpath">parameter.</span></p>
</dd>
<dt><a name="GLdt-generalized-atomic-type" id=
"GLdt-generalized-atomic-type"></a>generalized atomic type</dt>
<dd>
<p>A <b>generalized atomic type</b> is a type which is either (a)
an atomic type or (b) a <a title="pure union type" href=
"#dt-pure-union-type">pure union type</a></p>
</dd>
<dt><a name="GLid-static-decimal-format-grouping-separator" id=
"GLid-static-decimal-format-grouping-separator"></a>grouping-separator</dt>
<dd>
<p><b>grouping-separator</b> specifies the character used for the
grouping-separator-symbol, which is typically used as a thousands
separator; the default value is the comma character (,)</p>
</dd>
<dt><a name="GLIgnorableWhitespace" id=
"GLIgnorableWhitespace"></a>ignorable whitespace</dt>
<dd>
<p><b>Ignorable whitespace</b> consists of any <a title=
"whitespace" href="#Whitespace">whitespace</a> characters that may
occur between <a title="terminal" href="#terminal">terminals</a>,
unless these characters occur in the context of a production marked
with a <a href="#ExplicitWhitespaceHandling">ws:explicit</a>
annotation, in which case they can occur only where explicitly
specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
Explicit Whitespace Handling</b></a>).</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may
differ between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.</p>
</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may
differ between implementations, but must be specified by the
implementor for each particular implementation.</p>
</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
timezone</dt>
<dd>
<p><b>Implicit timezone.</b> This is the timezone to be used when a
date, time, or dateTime value that does not have a timezone is used
in a comparison or arithmetic operation. The implicit timezone is
an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href=
"#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML
Schema 1.1]</a> for the range of valid values of a timezone.</p>
</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
attribute declarations</dt>
<dd>
<p><b>In-scope attribute declarations.</b> Each attribute
declaration is identified either by an <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> (for a top-level
attribute declaration) or by an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration).</p>
</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd>
<p><b>In-scope element declarations.</b> Each element declaration
is identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level element
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration).</p>
</dd>
<dt><a name="GLdt-in-scope-namespaces" id=
"GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
<p>The <b>in-scope namespaces</b> property of an element node is a
set of namespace bindings, each of which associates a namespace
prefix with a URI.</p>
</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
definitions</dt>
<dd>
<p><b>In-scope schema definitions.</b> This is a generic term for
all the element declarations, attribute declarations, and schema
type definitions that are in scope during static analysis of an
expression.</p>
</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope schema
type</dt>
<dd>
<p><b>In-scope schema types.</b> Each schema type definition is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>)
or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema
Types</b></a>.</p>
</dd>
<dt><a name="GLdt-in-scope-variables" id=
"GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd>
<p><b>In-scope variables.</b> This is a mapping from <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> to
type. It defines the set of variables that are available for
reference within an expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the
variable, and the type is the <a title="static type" href=
"#dt-static-type">static type</a> of the variable.</p>
</dd>
<dt><a name="GLid-static-decimal-format-infinity" id=
"GLid-static-decimal-format-infinity"></a>infinity</dt>
<dd>
<p><b>infinity</b> specifies the string used for the
infinity-symbol; the default value is the string "Infinity"</p>
</dd>
<dt><a name="GLdt-initial-context-item" id=
"GLdt-initial-context-item"></a>initial context item</dt>
<dd>
<p>The <b>initial context item</b> is a context item that an
implementation can set before processing a query begins. The query
body and the prolog of every module in a query share the same
initial context item.</p>
</dd>
<dt><a name="GLdt-inline-func" id="GLdt-inline-func"></a>inline
function expression</dt>
<dd>
<p>An <b>inline function expression</b> creates an anonymous
<a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>
defined directly in the inline function expression itself.</p>
</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd>
<p>An <b>item</b> is either an <a title="atomic value" href=
"#dt-atomic-value">atomic value</a>, a <a title="node" href=
"#dt-node">node</a>, or a <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.</p>
</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>
<p>An alternative form of a node test called a <b>kind test</b> can
select nodes based on their kind, name, and <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>lexical QName</dt>
<dd>
<p>A <b>lexical QName</b> is a name that conforms to the syntax of
<a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a>.</p>
</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd>
<p>A <b>literal</b> is a direct syntactic representation of an
atomic value.</p>
</dd>
<dt><a name="GLdt-map" id="GLdt-map"></a>map</dt>
<dd>
<p>A <b>map</b> is a <span>function that associates a set of keys
with values, resulting in a</span> collection of key / value
pairs.</p>
</dd>
<dt><a name="GLdt-member" id="GLdt-member"></a>member</dt>
<dd>
<p>The values of an array are called its <b>members</b>.</p>
</dd>
<dt><a name="GLid-static-decimal-format-minus-sign" id=
"GLid-static-decimal-format-minus-sign"></a>minus-sign</dt>
<dd>
<p><b>minus-sign</b> specifies the character used for the
minus-sign-symbol; the default value is the hyphen-minus character
(-, #x2D). The value must be a single character.</p>
</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>
<p>A node test that consists only of an EQName or a Wildcard is
called a <b>name test</b>.</p>
</dd>
<dt><a name="GLdt-named-func" id="GLdt-named-func"></a>named
function</dt>
<dd>
<p>A <b>named function</b> is a function defined in the static
context for the <span class="xpath">expression</span>. To uniquely
identify a particular named function, both its name as an expanded
QName and its arity are required.</p>
</dd>
<dt><a name="GLdt-named-function-ref" id=
"GLdt-named-function-ref"></a>named function reference</dt>
<dd>
<p>A <b>named function reference</b> denotes a <a title=
"named function" href="#dt-named-func">named function</a>.</p>
</dd>
<dt><a name="GLdt-named-functions" id=
"GLdt-named-functions"></a>named functions</dt>
<dd>
<p><b>Named functions</b>. This is a mapping from (expanded QName,
arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function</a><sup><small>DM31</small></sup>.</p>
</dd>
<dt><a name="GLdt-namespace-sensitive" id=
"GLdt-namespace-sensitive"></a>namespace-sensitive</dt>
<dd>
<p>The <b>namespace-sensitive</b> types are <code>xs:QName</code>,
<code>xs:NOTATION</code>, types derived by restriction from
<code>xs:QName</code> or <code>xs:NOTATION</code>, list types that
have a namespace-sensitive item type, and union types with a
namespace-sensitive type in their transitive membership.</p>
</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd>
<p>A <b>node</b> is an instance of one of the <b>node kinds</b>
defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data
Model (XDM) 3.1]</a>.</p>
</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd>
<p>A <b>node test</b> is a condition on the name, kind (element,
attribute, text, document, comment, or processing instruction),
and/or <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of a node. A node test determines which nodes
contained by an axis are selected by a <a title="step" href=
"#dt-step">step</a>.</p>
</dd>
<dt><a name="GLnon-delimiting-token" id=
"GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt>
<dd>
<p>The <b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xpath31-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath31-URIQualifiedName">URIQualifiedName</a>, <a href=
"#prod-xpath31-NCName">NCName</a>, <a href=
"#prod-xpath31-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath31-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath31-QName">QName</a>, "ancestor", "ancestor-or-self",
"and", "array", "as", "attribute", "cast", "castable", "child",
"comment", "descendant", "descendant-or-self", "div",
"document-node", "element", "else", "empty-sequence", "eq",
"every", "except", "following", "following-sibling", "for",
"function", "ge", "gt", "idiv", "if", "in", "instance",
"intersect", "is", "item", "le", "let", "lt", "map", "mod",
"namespace", "namespace-node", "ne", "node", "of", "or", "parent",
"preceding", "preceding-sibling", "processing-instruction",
"return", "satisfies", "schema-attribute", "schema-element",
"self", "some", "text", "then", "to", "treat", "union"</p>
</dd>
<dt><a name="GLdt-numeric" id="GLdt-numeric"></a>numeric</dt>
<dd>
<p>When referring to a type, the term <b>numeric</b> denotes the
types <code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</p>
</dd>
<dt><a name="GLdt-numeric-predicate" id=
"GLdt-numeric-predicate"></a>numeric predicate</dt>
<dd>
<p>A predicate whose predicate expression returns a numeric type is
called a <b>numeric predicate</b>.</p>
</dd>
<dt><a name="GLdt-operator-function" id=
"GLdt-operator-function"></a>operator function</dt>
<dd>
<p>For each operator and valid combination of operand types, the
operator mapping tables specify a result type and an <b>operator
function</b> that implements the semantics of the operator for the
given types.</p>
</dd>
<dt><a name="GLdt-partial-function-application" id=
"GLdt-partial-function-application"></a>partial function
application</dt>
<dd>
<p>A static or <a title="dynamic function call" href=
"#dt-dynamic-function-invocation">dynamic</a> function call is a
<b>partial function application</b> if one or more arguments is an
ArgumentPlaceholder.</p>
</dd>
<dt><a name="GLdt-path-expression" id=
"GLdt-path-expression"></a>path expression</dt>
<dd>
<p>A <b>path expression</b> can be used to locate nodes within
trees. A path expression consists of a series of one or more
<a title="step" href="#dt-step">steps</a>, separated by
"<code>/</code>" or "<code>//</code>", and optionally beginning
with "<code>/</code>" or "<code>//</code>".</p>
</dd>
<dt><a name="GLid-static-decimal-format-pattern-separator-sign" id=
"GLid-static-decimal-format-pattern-separator-sign"></a>pattern-separator-sign</dt>
<dd>
<p><b>pattern-separator</b> specifies the character used for the
pattern-separator-symbol, which separates positive and negative
sub-pictures in a picture string; the default value is the
semi-colon character (;)</p>
</dd>
<dt><a name="GLid-static-decimal-format-per-mille-sign" id=
"GLid-static-decimal-format-per-mille-sign"></a>per-mille-sign</dt>
<dd>
<p><b>per-mille</b> specifies the character used for the
per-mille-symbol; the default value is the Unicode per-mille
character (#x2030)</p>
</dd>
<dt><a name="GLid-static-decimal-format-percent-sign" id=
"GLid-static-decimal-format-percent-sign"></a>percent-sign</dt>
<dd>
<p><b>percent</b> specifies the character used for the
percent-symbol; the default value is the percent character (%)</p>
</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd>
<p><b>Primary expressions</b> are the basic primitives of the
language. They include literals, variable references, context item
expressions, and function calls. A primary expression may also be
created by enclosing any expression in parentheses, which is
sometimes helpful in controlling the precedence of operators.</p>
</dd>
<dt><a name="GLdt-principal-node-kind" id=
"GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
<p>Every axis has a <b>principal node kind</b>. If an axis can
contain elements, then the principal node kind is element;
otherwise, it is the kind of nodes that the axis can contain.</p>
</dd>
<dt><a name="GLdt-pure-union-type" id=
"GLdt-pure-union-type"></a>pure union type</dt>
<dd>
<p>A <b>pure union type</b> is an XML Schema union type that
satisfies the following constraints: (1) <code>{variety}</code> is
<code>union</code>, (2) the <code>{facets}</code> property is
empty, (3) no type in the transitive membership of the union type
has <code>{variety}</code> <code>list</code>, and (4) no type in
the transitive membership of the union type is a type with
<code>{variety}</code> <code>union</code> having a non-empty
<code>{facets}</code> property</p>
</dd>
<dt><a name="GLdt-resolve-relative-uri" id=
"GLdt-resolve-relative-uri"></a>resolve</dt>
<dd>
<p>To <b>resolve a relative URI</b> <code>$rel</code> against a
base URI <code>$base</code> is to expand it to an absolute URI, as
if by calling the function <code>fn:resolve-uri($rel,
$base)</code>.</p>
</dd>
<dt><a name="GLdt-reverse-document-order" id=
"GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>
<p>The node ordering that is the reverse of document order is
called <b>reverse document order</b>.</p>
</dd>
<dt><a name="GLdt-same-key" id="GLdt-same-key"></a>same key</dt>
<dd>
<p>Two atomic values K1 and K2 have the <b>same key value</b> if
the relation deep-equal(K1, K2, $UCC) holds, where $UCC is the
Unicode codepoint collation.</p>
</dd>
<dt><a name="GLdt-schema-type" id="GLdt-schema-type"></a>schema
type</dt>
<dd>
<p>A <b>schema type</b> is a type that is (or could be) defined
using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a>
or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the
built-in types of <a href="#XMLSchema10">[XML Schema 1.0]</a> or
<a href="#XMLSchema11">[XML Schema 1.1]</a>).</p>
</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd>
<p>A <b>sequence</b> is an ordered collection of zero or more
<a title="item" href="#dt-item">items</a>.</p>
</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>sequence type</dt>
<dd>
<p>A <b>sequence type</b> is a type that can be expressed using the
<a href="#doc-xpath31-SequenceType">SequenceType</a> syntax.
Sequence types are used whenever it is necessary to refer to a type
in an XPath 3.1 expression. The term <b>sequence type</b> suggests
that this syntax is used to describe the type of an XPath 3.1
value, which is always a sequence.</p>
</dd>
<dt><a name="GLdt-singleton" id="GLdt-singleton"></a>singleton</dt>
<dd>
<p>A sequence containing exactly one item is called a
<b>singleton</b>.</p>
</dd>
<dt><a name="GLdt-singleton-focus" id=
"GLdt-singleton-focus"></a>singleton focus</dt>
<dd>
<p>A <b>singleton focus</b> is a focus that refers to a single
item; in a singleton focus, context item is set to the item,
context position = 1 and context size = 1.</p>
</dd>
<dt><a name="GLstable" id="GLstable"></a>stable</dt>
<dd>
<p>Document order is <b>stable</b>, which means that the relative
order of two nodes will not change during the processing of a given
<span class="xpath">expression</span>, even if this order is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</dd>
<dt><a name="GLdt-static-analysis" id=
"GLdt-static-analysis"></a>static analysis phase</dt>
<dd>
<p>The <b>static analysis phase</b> depends on the expression
itself and on the <a title="static context" href=
"#dt-static-context">static context</a>. The <b>static analysis
phase</b> does not depend on input data (other than schemas).</p>
</dd>
<dt><a name="GLdt-static-context" id=
"GLdt-static-context"></a>static context</dt>
<dd>
<p>The <b>static context</b> of an expression is the information
that is available during static analysis of the expression, prior
to its evaluation.</p>
</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static
error</dt>
<dd>
<p>An error that can be detected during the static analysis phase,
and is not a type error, is a <b>static error</b>.</p>
</dd>
<dt><a name="GLdt-static-function-call" id=
"GLdt-static-function-call"></a>static function call</dt>
<dd>
<p>A <b>static function call</b> consists of an EQName followed by
a parenthesized list of zero or more arguments.</p>
</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static
type</dt>
<dd>
<p>The <b>static type</b> of an expression is the best inference
that the processor is able to make statically about the type of the
result of the expression.</p>
</dd>
<dt><a name="GLdt-xpath-static-typing-feature" id=
"GLdt-xpath-static-typing-feature"></a>static typing feature</dt>
<dd>
<p>The <b>Static Typing Feature</b> is an optional feature of XPath
that provides support for static semantics, and requires
implementations to detect and report <a title="type error" href=
"#dt-type-error">type errors</a> during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>.</p>
</dd>
<dt><a name="GLdt-static-decimal-formats" id=
"GLdt-static-decimal-formats"></a>statically known decimal
formats</dt>
<dd>
<p><b>Statically known decimal formats.</b> This is a mapping from
QName to decimal format, with one default format that has no
visible name. Each format is used for serializing decimal numbers
using <code>fn:format-number()</code>.</p>
</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically known collections</dt>
<dd>
<p><b>Statically known collections.</b> This is a mapping from
strings to types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:collection</code> function. The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</p>
</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically
known documents</dt>
<dd>
<p><b>Statically known documents.</b> This is a mapping from
strings to types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:doc</code> function. The type is the <a title=
"static type" href="#dt-static-type">static type</a> of a call to
<code>fn:doc</code> with the given URI as its literal argument.</p>
</dd>
<dt><a name="GLdt-static-collations" id=
"GLdt-static-collations"></a>statically known collations</dt>
<dd>
<p><b>Statically known collations.</b> This is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> mapping
from URI to collation. It defines the names of the collations that
are available for use in processing expressions.</p>
</dd>
<dt><a name="GLdt-known-default-collection" id=
"GLdt-known-default-collection"></a>statically known default
collection type</dt>
<dd>
<p><b>Statically known default collection type.</b> This is the
type of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.</p>
</dd>
<dt><a name="GLdt-known-func-signatures" id=
"GLdt-known-func-signatures"></a>statically known function
signatures</dt>
<dd>
<p><b>Statically known function signatures.</b> This is a mapping
from (expanded QName, arity) to <a href=
"http://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function
signature</a><sup><small>DM31</small></sup>.</p>
</dd>
<dt><a name="GLdt-static-namespaces" id=
"GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd>
<p><b>Statically known namespaces.</b> This is a mapping from
prefix to namespace URI that defines all the namespaces that are
known during static processing of a given expression.</p>
</dd>
<dt><a name="GLdt-step" id="GLdt-step"></a>step</dt>
<dd>
<p>A <b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=""
href="#dt-predicate">predicates</a>. The value of the step consists
of those items that satisfy the predicates, working from left to
right. A step may be either an <a title="axis step" href=
"#dt-axis-step">axis step</a> or a postfix expression.</p>
</dd>
<dt><a name="GLdt-string-value" id="GLdt-string-value"></a>string
value</dt>
<dd>
<p>The <b>string value</b> of a node is a string and can be
extracted by applying the <code>fn:string</code> function to the
node.</p>
</dd>
<dt><a name="GLdt-substitution-group" id=
"GLdt-substitution-group"></a>substitution group</dt>
<dd>
<p><b>Substitution groups</b> are defined in <a href=
"#XMLSchema10">[XML Schema 1.0]</a> and <a href="#XMLSchema11">[XML
Schema 1.1]</a> Part 1. Informally, the substitution group headed
by a given element (called the <b>head element</b>) consists of the
set of elements that can be substituted for the head element
without affecting the outcome of schema validation.</p>
</dd>
<dt><a name="GLdt-subtype" id="GLdt-subtype"></a>subtype</dt>
<dd>
<p>A <a title="sequence type" href="#dt-sequence-type">sequence
type</a> <code>A</code> is a <b>subtype</b> of a sequence type
<code>B</code> if the judgement <code>subtype(A, B)</code> is
true.</p>
</dd>
<dt><a name="GLdt-subtype-substitution" id=
"GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd>
<p>The use of a value whose <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> is derived from an expected
type is known as <b>subtype substitution</b>.</p>
</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>
<p>Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
</dd>
<dt><a name="GLsymbolseparators" id="GLsymbolseparators"></a>symbol
separators</dt>
<dd>
<p><a title="whitespace" href="#Whitespace">Whitespace</a> and
<a href="#doc-xpath31-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgc: xml-version */</a>
annotation.</p>
</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<p>A <b>terminal</b> is a symbol or string or pattern that can
appear in the right-hand side of a rule, but never appears on the
left-hand side in the main grammar, although it may appear on the
left-hand side of a rule in the grammar for terminals.</p>
</dd>
<dt><a name="GLdt-type-annotation" id=
"GLdt-type-annotation"></a>type annotation</dt>
<dd>
<p>Each element node and attribute node in an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> has
a <b>type annotation</b> (described in <a href=
"#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>).
The type annotation of a node is a reference to an XML Schema
type.</p>
</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
error</dt>
<dd>
<p>A <b>type error</b> may be raised during the static analysis
phase or the dynamic evaluation phase. During the static analysis
phase, a <a title="type error" href="#dt-type-error">type error</a>
occurs when the <a title="static type" href=
"#dt-static-type">static type</a> of an expression does not match
the expected type of the context in which the expression occurs.
During the dynamic evaluation phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
does not match the expected type of the context in which the value
occurs.</p>
</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type
promotion</dt>
<dd>
<p>Under certain circumstances, an atomic value can be promoted
from one type to another. <b>Type promotion</b> is used in
evaluating function calls (see <a href=
"#id-eval-function-call"><b>3.1.5.1 Evaluating Static and Dynamic
Function Calls</b></a>) and operators that accept numeric or string
operands (see <a href="#mapping"><b>B.2 Operator
Mapping</b></a>).</p>
</dd>
<dt><a name="GLdt-typed-value" id="GLdt-typed-value"></a>typed
value</dt>
<dd>
<p>The <b>typed value</b> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function
to the node.</p>
</dd>
<dt><a name="GLdt-value" id="GLdt-value"></a>value</dt>
<dd>
<p>In the <a title="data model" href="#dt-datamodel">data
model</a>, a <b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.</p>
</dd>
<dt><a name="GLdt-variable-reference" id=
"GLdt-variable-reference"></a>variable reference</dt>
<dd>
<p>A <b>variable reference</b> is an EQName preceded by a
$-sign.</p>
</dd>
<dt><a name="GLdt-variable-values" id=
"GLdt-variable-values"></a>variable values</dt>
<dd>
<p><b>Variable values</b>. This is a mapping from <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> to
value. It contains the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> as the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> for the expression. The
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> is the name of the variable and the value is the dynamic
value of the variable, which includes its <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a>.</p>
</dd>
<dt><a name="GLdt-warning" id="GLdt-warning"></a>warning</dt>
<dd>
<p>In addition to <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XPath 3.1
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>whitespace</dt>
<dd>
<p>A <b>whitespace</b> character is any of the characters defined
by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p>
</dd>
<dt><a name="GLdt-anyAtomicType" id=
"GLdt-anyAtomicType"></a>xs:anyAtomicType</dt>
<dd>
<p><code>xs:anyAtomicType</code> is an atomic type that includes
all atomic values (and no values that are not atomic). Its base
type is <code>xs:anySimpleType</code> from which all simple types,
including atomic, list, and union types, are derived. All primitive
atomic types, such as <code>xs:decimal</code> and
<code>xs:string</code>, have <code>xs:anyAtomicType</code> as their
base type.</p>
</dd>
<dt><a name="GLdt-dayTimeDuration" id=
"GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt>
<dd>
<p><code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.</p>
</dd>
<dt><a name="GLdt-xs-error" id="GLdt-xs-error"></a>xs:error</dt>
<dd>
<p><code>xs:error</code> is a simple type with no value space,
defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. In
implementations that support XML Schema 1.1, it can be used in the
<a href="#id-sequencetype-syntax"><b>2.5.4 SequenceType
Syntax</b></a> to raise errors.</p>
</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xs:untyped</dt>
<dd>
<p><code>xs:untyped</code> is used as the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> of
an element node that has not been validated, or has been validated
in <code>skip</code> mode.</p>
</dd>
<dt><a name="GLdt-untypedAtomic" id=
"GLdt-untypedAtomic"></a>xs:untypedAtomic</dt>
<dd>
<p><code>xs:untypedAtomic</code> is an atomic type that is used to
denote untyped atomic data, such as text that has not been assigned
a more specific type.</p>
</dd>
<dt><a name="GLdt-yearMonthDuration" id=
"GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt>
<dd>
<p><code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.</p>
</dd>
<dt><a name="GLid-static-decimal-format-zero-digit" id=
"GLid-static-decimal-format-zero-digit"></a>zero-digit</dt>
<dd>
<p><b>zero-digit</b> specifies the character used for the
zero-digit-symbol; the default value is the digit zero (0). This
character must be a digit (category Nd in the Unicode property
database), and it must have the numeric value zero. This attribute
implicitly defines the Unicode character that is used to represent
each of the values 0 to 9 in the final result string: Unicode is
organized so that each set of decimal digits forms a contiguous
block of characters in numerical sequence.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-backwards-compatibility" id=
"id-backwards-compatibility"></a>I Backwards Compatibility with
XPath 1.0 (Non-Normative)</h2>
<p>This appendix provides a summary of the areas of incompatibility
between XPath 3.0 and <a href="#xpath">[XML Path Language (XPath)
Version 1.0]</a>. In each of these cases, an XPath 3.0 processor is
compatible with an XPath 2.0 processor.</p>
<p>Three separate cases are considered:</p>
<ol class="enumar">
<li>
<p>Incompatibilities that exist when source documents have no
schema, and when running with XPath 1.0 compatibility mode set to
true. This specification has been designed to reduce the number of
incompatibilities in this situation to an absolute minimum, but
some differences remain and are listed individually.</p>
</li>
<li>
<p>Incompatibilities that arise when XPath 1.0 compatibility mode
is set to false. In this case, the number of expressions where
compatibility is lost is rather greater.</p>
</li>
<li>
<p>Incompatibilities that arise when the source document is
processed using a schema (whether or not XPath 1.0 compatibility
mode is set to true). Processing the document with a schema changes
the way that the values of nodes are interpreted, and this can
cause an XPath expression to return different results.</p>
</li>
</ol>
<div class="div2">
<h3><a name="id-incompat-in-true-mode" id=
"id-incompat-in-true-mode"></a>I.1 Incompatibilities when
Compatibility Mode is true</h3>
<p>The list below contains all known areas, within the scope of
this specification, where an XPath 3.0 processor running with
compatibility mode set to true will produce different results from
an XPath 1.0 processor evaluating the same expression, assuming
that the expression was valid in XPath 1.0, and that the nodes in
the source document have no type annotations other than
<code>xs:untyped</code> and <code>xs:untypedAtomic</code>.</p>
<p>Incompatibilities in the behavior of individual functions are
not listed here, but are included in an appendix of <a href=
"#xpath-functions-31">[XQuery and XPath Functions and Operators
3.1]</a>.</p>
<p>Since both XPath 1.0 and XPath 3.0 leave some aspects of the
specification implementation-defined, there may be
incompatibilities in the behavior of a particular implementation
that are outside the scope of this specification. Equally, some
aspects of the behavior of XPath are defined by the host
language.</p>
<ol class="enumar">
<li>
<p>Consecutive comparison operators such as <code>A &lt; B &lt;
C</code> were supported in XPath 1.0, but are not permitted by the
XPath 3.0 grammar. In most cases such comparisons in XPath 1.0 did
not have the intuitive meaning, so it is unlikely that they have
been widely used in practice. If such a construct is found, an
XPath 3.0 processor will report a syntax error, and the construct
can be rewritten as <code>(A &lt; B) &lt; C</code></p>
</li>
<li>
<p>When converting strings to numbers (either explicitly when using
the <code>number</code> function, or implicitly say on a function
call), certain strings that converted to the special value
<code>NaN</code> under XPath 1.0 will convert to values other than
<code>NaN</code> under XPath 3.0. These include any number written
with a leading <code>+</code> sign, any number in exponential
floating point notation (for example <code>1.0e+9</code>), and the
strings <code>INF</code> and <code>-INF</code>.</p>
<p>Furthermore, the strings <code>Infinity</code> and
<code>-Infinity</code>, which were accepted by XPath 1.0 as
representations of the floating-point values positive and negative
infinity, are no longer recognized. They are converted to
<code>NaN</code> when running under XPath 3.0 with compatibility
mode set to true, and cause a dynamic error when compatibility mode
is set to false.</p>
</li>
<li>
<p>XPath 3.0 does not allow a token starting with a letter to
follow immediately after a numeric literal, without intervening
whitespace. For example, <code>10div 3</code> was permitted in
XPath 1.0, but in XPath 3.0 must be written as <code>10 div
3</code>.</p>
</li>
<li>
<p>The namespace axis is deprecated as of XPath 2.0.
Implementations may support the namespace axis for backward
compatibility with XPath 1.0, but they are not required to do so.
(XSLT 2.0 requires that if XPath backwards compatibility mode is
supported, then the namespace axis must also be supported; but
other host languages may define the conformance rules
differently.)</p>
</li>
<li>
<p>In XPath 1.0, the expression <code>-x|y</code> parsed as
<code>-(x|y)</code>, and returned the negation of the numeric value
of the first node in the union of <code>x</code> and
<code>y</code>. In XPath 3.0, this expression parses as
<code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is true,
this will always cause a type error.</p>
</li>
<li>
<p>The rules for converting numbers to strings have changed. These
may affect the way numbers are displayed in the output of a
stylesheet. For numbers whose absolute value is in the range
<code>1E-6</code> to <code>1E+6</code>, the result should be the
same, but outside this range, scientific format is used for
non-integral <code>xs:float</code> and <code>xs:double</code>
values.</p>
</li>
<li>
<p>If one operand in a general comparison is a single atomic value
of type <code>xs:boolean</code>, the other operand is converted to
<code>xs:boolean</code> when XPath 1.0 compatibility mode is set to
true. In XPath 1.0, if neither operand of a comparison operation
using the &lt;, &lt;=, &gt; or &gt;= operator was a node set, both
operands were converted to numbers. The result of the expression
<code>true() &gt; number('0.5')</code> is therefore true in XPath
1.0, but is false in XPath 3.0 even when compatibility mode is set
to true.</p>
</li>
<li>
<p>In XPath 3.0, a type error is raised if the PITarget specified
in a SequenceType of form
<code>processing-instruction(PITarget)</code> is not a valid
NCName. In XPath 1.0, this condition was not treated as an
error.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-in-false-mode" id=
"id-incompat-in-false-mode"></a>I.2 Incompatibilities when
Compatibility Mode is false</h3>
<p>Even when the setting of the XPath 1.0 compatibility mode is
false, many XPath expressions will still produce the same results
under XPath 3.0 as under XPath 1.0. The exceptions are described in
this section.</p>
<p>In all cases it is assumed that the expression in question was
valid under XPath 1.0, that XPath 1.0 compatibility mode is false,
and that all elements and attributes are annotated with the types
<code>xs:untyped</code> and <code>xs:untypedAtomic</code>
respectively.</p>
<p>In the description below, the terms <em>node-set</em> and
<em>number</em> are used with their XPath 1.0 meanings, that is, to
describe expressions which according to the rules of XPath 1.0
would have generated a node-set or a number respectively.</p>
<ol class="enumar">
<li>
<p>When a node-set containing more than one node is supplied as an
argument to a function or operator that expects a single node or
value, the XPath 1.0 rule was that all nodes after the first were
discarded. Under XPath 3.0, a type error occurs if there is more
than one node. The XPath 1.0 behavior can always be restored by
using the predicate <code>[1]</code> to explicitly select the first
node in the node-set.</p>
</li>
<li>
<p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code>
operators, when applied to two strings, attempted to convert both
the strings to numbers and then made a numeric comparison between
the results. In XPath 3.0, these operators perform a string
comparison using the default collating sequence. (If either value
is numeric, however, the results are compatible with XPath 1.0)</p>
</li>
<li>
<p>When an empty node-set is supplied as an argument to a function
or operator that expects a number, the value is no longer converted
implicitly to NaN. The XPath 1.0 behavior can always be restored by
using the <code>number</code> function to perform an explicit
conversion.</p>
</li>
<li>
<p>More generally, the supplied arguments to a function or operator
are no longer implicitly converted to the required type, except in
the case where the supplied argument is of type
<code>xs:untypedAtomic</code> (which will commonly be the case when
a node in a schemaless document is supplied as the argument). For
example, the function call <code>substring-before(10 div 3,
".")</code> raises a type error under XPath 3.0, because the
arguments to the <code>substring-before</code> function must be
strings rather than numbers. The XPath 1.0 behavior can be restored
by performing an explicit conversion to the required type using a
constructor function or cast.</p>
</li>
<li>
<p>The rules for comparing a node-set to a boolean have changed. In
XPath 1.0, an expression such as <code>$node-set = true()</code>
was evaluated by converting the node-set to a boolean and then
performing a boolean comparison: so this expression would return
<code>true</code> if <code>$node-set</code> was non-empty. In XPath
3.0, this expression is handled in the same way as other
comparisons between a sequence and a singleton: it is
<code>true</code> if <code>$node-set</code> contains at least one
node whose value, after atomization and conversion to a boolean
using the casting rules, is <code>true</code>.</p>
<p>This means that if <code>$node-set</code> is empty, the result
under XPath 3.0 will be <code>false</code> regardless of the value
of the boolean operand, and regardless of which operator is used.
If <code>$node-set</code> is non-empty, then in most cases the
comparison with a boolean is likely to fail, giving a dynamic
error. But if a node has the value "0", "1", "true", or "false",
evaluation of the expression may succeed.</p>
</li>
<li>
<p>Comparisons of a number to a boolean, a number to a string, or a
string to a boolean are not allowed in XPath 3.0: they result in a
type error. In XPath 1.0 such comparisons were allowed, and were
handled by converting one of the operands to the type of the other.
So for example in XPath 1.0 <code>4 = true()</code> was true;
<code>4 = "+4"</code> was false (because the string <code>+4</code>
converts to <code>NaN</code>), and <code>false = "false"</code> was
false (because the string <code>"false"</code> converts to the
boolean <code>true</code>). In XPath 3.0 all these comparisons are
type errors.</p>
</li>
<li>
<p>Additional numeric types have been introduced, with the effect
that arithmetic may now be done as an integer, decimal, or single-
or double-precision floating point calculation where previously it
was always performed as double-precision floating point. The result
of the <code>div</code> operator when dividing two integers is now
a value of type decimal rather than double. The expression <code>10
div 0</code> raises an error rather than returning positive
infinity.</p>
</li>
<li>
<p>The rules for converting strings to numbers have changed. The
implicit conversion that occurs when passing an
<code>xs:untypedAtomic</code> value as an argument to a function
that expects a number no longer converts unrecognized strings to
the value <code>NaN</code>; instead, it reports a dynamic error.
This is in addition to the differences that apply when backwards
compatibility mode is set to true.</p>
</li>
<li>
<p>Many operations in XPath 3.0 produce an empty sequence as their
result when one of the arguments or operands is an empty sequence.
Where the operation expects a string, an empty sequence is usually
considered equivalent to a zero-length string, which is compatible
with the XPath 1.0 behavior. Where the operation expects a number,
however, the result is not the same. For example, if
<code>@width</code> returns an empty sequence, then in XPath 1.0
the result of <code>@width+1</code> was <code>NaN</code>, while
with XPath 3.0 it is <code>()</code>. This has the effect that a
filter expression such as <code>item[@width+1 != 2]</code> will
select items having no <code>width</code> attribute under XPath
1.0, and will not select them under XPath 3.0.</p>
</li>
<li>
<p>The typed value of a comment node, processing instruction node,
or namespace node under XPath 3.0 is of type
<code>xs:string</code>, not <code>xs:untypedAtomic</code>. This
means that no implicit conversions are applied if the value is used
in a context where a number is expected. If a
processing-instruction node is used as an operand of an arithmetic
operator, for example, XPath 1.0 would attempt to convert the
string value of the node to a number (and deliver <code>NaN</code>
if unsuccessful), while XPath 3.0 will report a type error.</p>
</li>
<li>
<p>In XPath 1.0, it was defined that with an expression of the form
<code>A and B</code>, B would not be evaluated if A was false.
Similarly in the case of <code>A or B</code>, B would not be
evaluated if A was true. This is no longer guaranteed with XPath
3.0: the implementation is free to evaluate the two operands in
either order or in parallel. This change has been made to give more
scope for optimization in situations where XPath expressions are
evaluated against large data collections supported by indexes.
Implementations may choose to retain backwards compatibility in
this area, but they are not obliged to do so.</p>
</li>
<li>
<p>In XPath 1.0, the expression <code>-x|y</code> parsed as
<code>-(x|y)</code>, and returned the negation of the numeric value
of the first node in the union of <code>x</code> and
<code>y</code>. In XPath 3.0, this expression parses as
<code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is false,
this will cause a type error, except in the situation where
<code>x</code> evaluates to an empty sequence. In that situation,
XPath 3.0 will return the value of <code>y</code>, whereas XPath
1.0 returned the negation of the numeric value of
<code>y</code>.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-when-using-schema" id=
"id-incompat-when-using-schema"></a>I.3 Incompatibilities when
using a Schema</h3>
<p>An XPath expression applied to a document that has been
processed against a schema will not always give the same results as
the same expression applied to the same document in the absence of
a schema. Since schema processing had no effect on the result of an
XPath 1.0 expression, this may give rise to further
incompatibilities. This section gives a few examples of the
differences that can arise.</p>
<p>Suppose that the context node is an element node derived from
the following markup: <code>&lt;background color="red green
blue"/&gt;</code>. In XPath 1.0, the predicate
<code>[@color="blue"]</code> would return <code>false</code>. In
XPath 3.0, if the <code>color</code> attribute is defined in a
schema to be of type <code>xs:NMTOKENS</code>, the same predicate
will return <code>true</code>.</p>
<p>Similarly, consider the expression <code>@birth &lt;
@death</code> applied to the element <code>&lt;person
birth="1901-06-06" death="1991-05-09"/&gt;</code>. With XPath 1.0,
this expression would return false, because both attributes are
converted to numbers, which returns <code>NaN</code> in each case.
With XPath 3.0, in the presence of a schema that annotates these
attributes as dates, the expression returns <code>true</code>.</p>
<p>Once schema validation is applied, elements and attributes
cannot be used as operands and arguments of expressions that expect
a different data type. For example, it is no longer possible to
apply the <code>substring</code> function to a date to extract the
year component, or to a number to extract the integer part.
Similarly, if an attribute is annotated as a boolean then it is not
possible to compare it with the strings <code>"true"</code> or
<code>"false"</code>. All such operations lead to type errors. The
remedy when such errors occur is to introduce an explicit
conversion, or to do the computation in a different way. For
example, <code>substring-after(@temperature, "-")</code> might be
rewritten as <code>abs(@temperature)</code>.</p>
<p>In the case of an XPath 3.0 implementation that provides the
static typing feature, many further type errors will be reported in
respect of expressions that worked under XPath 1.0. For example, an
expression such as <code>round(../@price)</code> might lead to a
static type error because the processor cannot infer statically
that <code>../@price</code> is guaranteed to be numeric.</p>
<p>Schema validation will in many cases perform whitespace
normalization on the contents of elements (depending on their
type). This will change the result of operations such as the
<code>string-length</code> function.</p>
<p>Schema validation augments the data model by adding default
values for omitted attributes and empty elements.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-revision-log" id="id-revision-log"></a>J Change Log
(Non-Normative)</h2>
<p class="xpath">This appendix lists the changes that have been
made to this specification since the publication of XPath 3.0
Recommendation.</p>
<div class="div2">
<h3><a name="id-incompatibilities" id=
"id-incompatibilities"></a>J.1 Incompatibilities</h3>
<p>The following names are now reserved, and cannot appear as
function names (see <a href="#id-reserved-fn-names"><b>A.3 Reserved
Function Names</b></a>):</p>
<ul>
<li>
<p><code>map</code></p>
</li>
<li>
<p><code>array</code></p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-changes-this-draft" id=
"id-changes-this-draft"></a>J.2 Changes introduced since XQuery
3.0</h3>
<div class="div3">
<h4><a name="id-changes-CR-substantive" id=
"id-changes-CR-substantive"></a>J.2.1 Substantive Changes</h4>
<p>The following substantive changes have been made.</p>
<ol class="enumar">
<li>
<p>Added <a href="#id-map-constructors"><b>3.11.1.1 Map
Constructors</b></a> and <a href="#id-map-lookup"><b>3.11.1.2 Map
Lookup</b></a>.</p>
</li>
<li>
<p>Added <a href="#id-array-constructors"><b>3.11.2.1 Array
Constructors</b></a> and <a href="#id-array-lookup"><b>3.11.2.2
Array Lookup</b></a>.</p>
</li>
<li>
<p>Defined <a href="#id-atomization"><b>2.4.2 Atomization</b></a>
of an array (atomization of a map is an error).</p>
</li>
<li>
<p>Added <a href="#id-map-test"><b>2.5.5.8 Map Test</b></a> and
<a href="#id-array-test"><b>2.5.5.9 Array Test</b></a> to test
whether an item is a map or an array respectively.</p>
</li>
<li>
<p>Added <code>exponent-separator</code> to the static context to
support <code>fn:format-number()</code>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="id-changes-prior-drafts" id=
"id-changes-prior-drafts"></a>J.3 Changes introduced in prior
Working Drafts</h3>
<p>There are no prior public Working Drafts of XPath 3.1</p>
</div>
</div>
</div>
</body>
</html>
