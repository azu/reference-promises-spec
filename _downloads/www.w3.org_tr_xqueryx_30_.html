<!-- http://www.w3.org/TR/xqueryx-30/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--{xml-fix} XSLT Processor: SAXON 9.3.0.5 from Saxonica SAXON EE 9.3.0.5--><!--This document was created at 20140407 1719-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQueryX 3.0</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"//www.w3.org/StyleSheets/TR/W3C-REC.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQueryX 3.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation
08 April 2014</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/REC-xqueryx-30-20140408/">http://www.w3.org/TR/2014/REC-xqueryx-30-20140408/</a></dd>
<dt>Latest version of XQueryX 3.0:</dt>
<dd><a href=
"http://www.w3.org/TR/xqueryx-30/">http://www.w3.org/TR/xqueryx-30/</a></dd>
<dt>Previous versions of XQueryX 3.0:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/PR-xqueryx-30-20140130/">http://www.w3.org/TR/2014/PR-xqueryx-30-20140130/</a>,
<a href=
"http://www.w3.org/TR/2013/WD-xqueryx-30-20131001/">http://www.w3.org/TR/2013/WD-xqueryx-30-20131001/</a>,
<a href=
"http://www.w3.org/TR/2013/CR-xqueryx-30-20130108/">http://www.w3.org/TR/2013/CR-xqueryx-30-20130108/</a>,
<a href=
"http://www.w3.org/TR/2011/WD-xqueryx-30-20111213/">http://www.w3.org/TR/2011/WD-xqueryx-30-20111213/</a>,
<a href=
"http://www.w3.org/TR/2011/WD-xqueryx-30-20110614/">http://www.w3.org/TR/2011/WD-xqueryx-30-20110614/</a>,
<a href=
"http://www.w3.org/TR/2010/WD-xqueryx-30-20101214/">http://www.w3.org/TR/2010/WD-xqueryx-30-20101214/</a>,
<a href=
"http://www.w3.org/TR/2009/WD-xqueryx-11-20091215/">http://www.w3.org/TR/2009/WD-xqueryx-11-20091215/</a>,
<a href=
"http://www.w3.org/TR/2008/WD-xqueryx-11-20081203/">http://www.w3.org/TR/2008/WD-xqueryx-11-20081203/</a></dd>
<dt>Most recent version of XQueryX 3:</dt>
<dd><a href=
"http://www.w3.org/TR/xqueryx-3/">http://www.w3.org/TR/xqueryx-3/</a></dd>
<dt>Most recent Recommendation of XQueryX:</dt>
<dd><a href=
"http://www.w3.org/TR/2010/REC-xqueryx-20101214/">http://www.w3.org/TR/2010/REC-xqueryx-20101214/</a></dd>
<dt>Editor:</dt>
<dd>Jim Melton, Oracle <a href=
"mailto:jim.melton@oracle.com">&lt;jim.melton@oracle.com&gt;</a></dd>
</dl>
<p>Please check the <a href=
"http://www.w3.org/XML/2014/qt-errata/xqueryx-30-errata.html"><strong>
errata</strong></a> for any errors or issues reported since
publication.</p>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xqueryx-30">
<strong>translations</strong></a>.</p>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2014/REC-xqueryx-30-20140408/xqueryx-30.xml">XML</a>,
<a href=
"http://www.w3.org/TR/2014/REC-xqueryx-30-20140408/xqueryx-30-diff.html">
Change markings relative to previous edition</a>, and&#160;<a href=
"http://www.w3.org/TR/2010/REC-xqueryx-20101214/">Most recent
XQueryX Recommendation</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2014&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href=
"http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document defines an XML Syntax for <span><a href=
"#xquery-30">[XQuery 3.0: An XML Query Language]</a></span> .</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is one document in a set of six documents that have been
progressed to Recommendation together (XQuery 3.0, XQueryX 3.0,
XPath 3.0, Data Model 3.0, Functions and Operators 3.0, and
Serialization 3.0).</p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
of the W3C. It was developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a>, which
is part of the <a href="http://www.w3.org/XML/Activity">XML
Activity</a>.</p>
<p>This Recommendation of XQueryX 3.0 represents the second version
of <a href="http://www.w3.org/TR/2010/REC-xqueryx-20101214/">a
previous W3C Recommendation</a>.</p>
<p>A Test Suite has been created for this document. Implementors
are encouraged to run this test suite and report their results. The
Test Suite can be found at <a href=
"http://dev.w3.org/2011/QT3-test-suite/">http://dev.w3.org/2011/QT3-test-suite/</a>.
An <a href=
"http://dev.w3.org/2011/QT3-test-suite/ReportingResults/">implementation
report</a> is available.</p>
<p>This document incorporates minor changes made against the
<a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsPR">Proposed
Recommendation</a> of 28 January 2014. Changes to this document
since the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsPR">Proposed
Recommendation</a> are detailed in <a href="#changelog"><b>D Change
log</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[XQX30]” in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from
another document. W3C's role in making the Recommendation is to
draw attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the group; that page also includes instructions for
disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#Introduction">Introduction</a><br />
2 <a href="#Mapping">Mapping the XQuery Syntax</a><br />
3 <a href="#Examples">Examples from the XML Query Use Cases in XML
Syntax</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#Example1">Example 1</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#Example1-XQuery">XQuery solution in XQuery Use Cases:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#Example1-XQueryX">A Solution in XQueryX:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
"#Example1-Transformation">Transformation of XQueryX Solution into
XQuery</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
"#Example1-Abstract">Corresponding Grammar Abstract Parse
Tree</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#Example2">Example 2</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#Example2-XQuery">XQuery solution in XQuery Use Cases:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#Example2-XQueryX">A solution in XQueryX:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#Example2-Transformation">Transformation of XQueryX Solution into
XQuery</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#Example3">Example 3</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
"#Example3-XQuery">XQuery solution in XQuery Use Cases:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
"#Example3-XQueryX">A solution in XQueryX:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.3 <a href=
"#Example3-Transformation">Transformation of XQueryX Solution into
XQuery</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#Example4">Example 4</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.1 <a href=
"#Example4-XQuery">XQuery solution in XQuery Use Cases:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.2 <a href=
"#Example4-XQueryX">A solution in XQueryX:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.3 <a href=
"#Example4-Transformation">Transformation of XQueryX Solution into
XQuery</a><br />
4 <a href="#Schema">An XML Schema for the XQuery XML
Syntax</a><br />
5 <a href="#xqx_conformance">Conformance</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#biblio">References</a><br />
B <a href="#Stylesheet">Transforming XQueryX to XQuery</a><br />
C <a href="#xqueryx-id-mime-type">The application/xquery+xml Media
Type</a><br />
&#160;&#160;&#160;&#160;C.1 <a href=
"#xqueryx-mime-introduction">Introduction</a><br />
&#160;&#160;&#160;&#160;C.2 <a href=
"#xqueryx-mime-registration">Registration of MIME Media Type
application/xquery+xml</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.1 <a href=
"#xqueryx-mime-encoding">Encoding Considerations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.2 <a href=
"#xqueryx-mime-security">Security Considerations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.3 <a href=
"#xqueryx-mime-interoperability">Interoperability
Considerations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.4 <a href=
"#xqueryx-mime-pubspec">Published specification</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.5 <a href=
"#xqueryx-mime-applications">Applications That Use This Media
Type</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.6 <a href=
"#xqueryx-mime-additional">Additional Information</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.6.1
<a href="#xqueryx-mime-recognizing">Recognizing XQuery Files
("Magic Numbers")</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.6.2
<a href="#xqueryx-mime-extensions">File Extensions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.6.3
<a href="#xqueryx-mime-macfiletype">Macintosh File Type
Code(s)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.7 <a href=
"#xqueryx-mime-author">Person and Email Address to Contact For
Further Information</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.8 <a href=
"#xqueryx-mime-intended-usage">Intended Usage</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.9 <a href=
"#xqueryx-mime-restrictions">Restrictions on usage</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.10 <a href=
"#xqueryx-mime-owner">Author/Change Controller</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C.2.11 <a href=
"#xqueryx-mime-fragments">Fragment Identifiers</a><br />
D <a href="#changelog">Change log</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;D.1 <a href=
"#changelog_substantive">Substantive changes</a><br />
&#160;&#160;&#160;&#160;D.2 <a href=
"#changelog_incompatibilities">Incompatibilities</a><br />
&#160;&#160;&#160;&#160;D.3 <a href=
"#changelog_editorial">Editorial changes</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="Introduction" id="Introduction"></a>1
Introduction</h2>
<p>The <span><a href="#xquery-30-requirements">[XQuery 3.0
Requirements]</a></span> states that "The XML Query Language MAY
have more than one syntax binding. One query language syntax MUST
be convenient for humans to read and write. One query language
syntax MUST be expressed in XML in a way that reflects the
underlying structure of the query."</p>
<p>XQueryX is an XML representation of an XQuery. It was created by
mapping the productions of the XQuery grammar into XML productions.
The result is not particularly convenient for humans to read and
write, but it is easy for programs to parse, and because XQueryX is
represented in XML, standard XML tools can be used to create,
interpret, or modify queries.</p>
<p>In this document, examples and material labeled as "Note" are
provided for explanatory purposes and are not normative.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because the two syntaxes are merely different grammars that
express the same query semantics, they share all aspects of an
XQuery processing system except for the component that recognizes
and translates the source representation of a query (that is, the
parser). The aspects that are shared include both the static
context and the dynamic context that are defined in <span><a href=
"#xquery-30">[XQuery 3.0: An XML Query Language]</a></span> .</p>
</div>
<p>There are several environments in which XQueryX may be
useful:</p>
<ul>
<li>
<p><em>Parser Reuse.</em> In heterogeneous environments, a variety
of systems may be used to execute a query. One parser can generate
XQueryX for all of these systems.</p>
</li>
<li>
<p><em>Queries on Queries.</em> Because XQueryX is represented in
XML, queries can be queried and can be transformed into new
queries. For instance, a query can be performed against a set of
XQueryX queries to determine which queries use FLWOR expressions to
range over a set of invoices.</p>
</li>
<li>
<p><em>Generating Queries.</em> In some XML-oriented programming
environments, it may be more convenient to build a query in its
XQueryX representation than in the corresponding XQuery
representation, since ordinary XML tools can be used.</p>
</li>
<li>
<p><em>Embedding Queries in XML.</em> XQueryX can be embedded
directly in an XML document.</p>
</li>
</ul>
<p>This version of XQueryX is fully compatible with <span><a href=
"#xqueryx">[XML Syntax for XQuery 1.0 (XQueryX)]</a></span> . It
differs from that earlier version of the language by the addition
of new XML Schema definitions and XSLT stylesheet templates. All
queries expressed in the syntax defined by <span><a href=
"#xqueryx">[XML Syntax for XQuery 1.0 (XQueryX)]</a></span>
continue to be valid, with the same meaning, when processed by an
implementation of this version of XQueryX.</p>
<p>The most recent versions of the XQueryX XML Schema and the
XQueryX XSLT stylesheet are available at <a href=
"http://www.w3.org/2014/04/XQueryX/xqueryx.xsd">http://www.w3.org/2014/04/XQueryX/xqueryx.xsd</a>
and <a href=
"http://www.w3.org/2014/04/XQueryX/xqueryx.xsl">http://www.w3.org/2014/04/XQueryX/xqueryx.xsl</a>,
respectively.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The locations at which the current versions of the XML Schema
and XSLT stylesheet are located during development of this
specification will vary with each Working Draft and Candidate
Recommendation of the spec that is published. The namespace target
URI is identical to that used for <span><a href="#xqueryx">[XML
Syntax for XQuery 1.0 (XQueryX)]</a></span> .</p>
</div>
</div>
<div class="div1">
<h2><a name="Mapping" id="Mapping"></a>2 Mapping the XQuery
Syntax</h2>
<p>XQueryX is an XML representation of the abstract syntax found in
Appendix A of <span><a href="#xquery-30">[XQuery 3.0: An XML Query
Language]</a></span> . The XQueryX syntax is defined by the XQueryX
Schema, which is specified in <a href="#Schema"><b>4 An XML Schema
for the XQuery XML Syntax</b></a>. The XQueryX semantics are
defined by a stylesheet that maps an instance of XQueryX to an
instance of XQuery; see <a href="#Stylesheet"><b>B Transforming
XQueryX to XQuery</b></a>.</p>
<p>The main data structure in the XQueryX Schema is the set of
types that describe expressions. We have chosen to model
expressions using substitution groups, with an "expr" abstract base
class and a number of intermediate abstract classes.</p>
<p>Consider the following productions from the abstract syntax:</p>
<div class="exampleInner">
<pre>
FLWORExpr          ::= InitialClause IntermediateClause* ReturnClause
InitialClause      ::= ForClause | LetClause | WindowClause
IntermediateClause ::= InitialClause | WhereClause | GroupByClause | OrderByClause | CountClause
<span>ForClause          ::= "for" "$" VarName TypeDeclaration? ("allowing" "empty")? PositionalVar? "in" ExprSingle</span>
                         ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
PositionalVar      ::= "at" "$" VarName
LetClause          ::= "let" "$" VarName TypeDeclaration? ":=" ExprSingle
                         ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
WhereClause        ::= "where" ExprSingle
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Those productions do not represent the entire FLWOR expression,
so some of the BNF non-terminal names are not resolved in the
example abstract syntax.</p>
</div>
<p>The following XQueryX Schema definitions reflect the structure
of those productions from that abstract syntax:</p>
<div class="exampleInner">
<pre>
  
&lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;
  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;

  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
            &lt;xsd:element ref="windowClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xsd:element ref="forClause"/&gt;
              &lt;xsd:element ref="letClause"/&gt;
              &lt;xsd:element ref="windowClause"/&gt;
              &lt;xsd:element ref="countClause"/&gt;
              &lt;xsd:element ref="whereClause"/&gt;
              &lt;xsd:element ref="groupByClause"/&gt;
              &lt;xsd:element ref="orderByClause"/&gt;
            &lt;/xsd:choice&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="forClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;

  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClause" type="forClause"/&gt;

  &lt;xsd:complexType name="forClauseItem"&gt;
    &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
<span>      &lt;xsd:element name="allowingEmpty" type="emptyContent"
                   minOccurs="0"/&gt;
</span>     &lt;xsd:element ref="positionalVariableBinding" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClauseItem" type="forClauseItem"/&gt;

  &lt;xsd:element name="forLetClauseItemExtensions" abstract="true"/&gt;

  &lt;xsd:complexType name="letClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClause" type="letClause"/&gt;

  &lt;xsd:complexType name="letClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
          &lt;xsd:element ref="forLetClauseItemExtensions"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:element ref="forLetClauseItemExtensions"
                     minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClauseItem" type="letClauseItem"/&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;
</pre></div>
<p>Since XQuery uses the expression production liberally to allow
expressions to be flexibly combined, XQueryX uses the exprWrapper
type in embedded contexts to allow all expression types to
occur.</p>
</div>
<div class="div1">
<h2><a name="Examples" id="Examples"></a>3 Examples from the XML
Query Use Cases in XML Syntax</h2>
<p>Three of following examples are based on the data and queries in
the XMP (Experiences and Exemplars) use case in <span><a href=
"#xquery-30-use-cases">[XQuery 3.0 Use Cases]</a></span> , while a
fourth example is based on the data and queries in the NS (Queries
Using Namespaces) use case. For each example, we show the English
description of the query, the XQuery solution given in
<span><a href="#xquery-30-use-cases">[XQuery 3.0 Use
Cases]</a></span> , an XQueryX solution, and the XQuery that
results from applying the XQueryX-to-XQuery transformation defined
by the stylesheet in <a href="#Stylesheet"><b>B Transforming
XQueryX to XQuery</b></a> to the XQueryX solution. That produced
XQuery is presented only as a sanity-check — the intent of the
stylesheet is not to create the identical XQuery expression given
in <span><a href="#xquery-30-use-cases">[XQuery 3.0 Use
Cases]</a></span> , but to produce <em>a</em> valid XQuery
expression with the same semantics. The semantics of the XQueryX
solution are determined by the semantics of the XQuery expression
that results from that transformation. The "correctness" of that
transformation is determined by asking the following the question:
Can some XQueryX processor QX process some XQueryX document D1 to
produce results R1, after which the stylesheet is used to translate
D1 into an XQuery expression E1 that, when processed by some XQuery
processor Q, produces results R2 that are equivalent (under some
meaningful definition of "equivalent") to results R1?</p>
<p>Comparison of the results of the XQueryX-to-XQuery
transformation given in this document with the XQuery solutions in
the <span><a href="#xquery-30-use-cases">[XQuery 3.0 Use
Cases]</a></span> may be helpful in evaluating the correctness of
the XQueryX solution in each example.</p>
<p>The XQuery Use Cases solution given for each example is provided
only to assist readers of this document in understanding the
XQueryX solution. There is no intent to imply that this document
specifies a "compilation" or "transformation" of XQuery syntax into
XQueryX syntax.</p>
<p>In the following examples, note that path expressions are
expanded to show their structure. Also, note that the prefix syntax
for binary operators like "and" makes the precedence explicit. In
general, humans find it easier to read an XML representation that
does not expand path expressions, but it is less convenient for
programmatic representation and manipulation. XQueryX is designed
as a language that is convenient for production and modification by
software, and not as a convenient syntax for humans to read and
write.</p>
<p>Finally, please note that white space, including new lines, have
been added to some of the XQueryX documents and XQuery expressions
for readability. That additional white space is not produced by the
XQueryX-to-XQuery transformation.</p>
<div class="div2">
<h3><a name="Example1" id="Example1"></a>3.1 Example 1</h3>
<p>Here is Q1 from the <span><a href="#xquery-30-use-cases">[XQuery
3.0 Use Cases]</a></span> , use case XMP (Experiences and
Exemplars): "List books published by Addison-Wesley after 1991,
including their year and title."</p>
<div class="div3">
<h4><a name="Example1-XQuery" id="Example1-XQuery"></a>3.1.1 XQuery
solution in XQuery Use Cases:</h4>
<div class="exampleInner">
<pre>
&lt;bib&gt;
 {
  for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
  where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
  return
    &lt;book year="{ $b/@year }"&gt;
     { $b/title }
    &lt;/book&gt;
 }
&lt;/bib&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example1-XQueryX" id="Example1-XQueryX"></a>3.1.2 A
Solution in XQueryX:</h4>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
                &lt;xqx:attributeList&gt;
                  &lt;xqx:attributeConstructor&gt;
                    &lt;xqx:attributeName&gt;year&lt;/xqx:attributeName&gt;
                    &lt;xqx:attributeValueExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:attributeValueExpr&gt;
                  &lt;/xqx:attributeConstructor&gt;
                &lt;/xqx:attributeList&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example1-Transformation" id=
"Example1-Transformation"></a>3.1.3 Transformation of XQueryX
Solution into XQuery</h4>
<p>Application of the stylesheet in <a href="#Stylesheet"><b>B
Transforming XQueryX to XQuery</b></a> to the XQueryX solution
results in:</p>
<div class="exampleInner">
<pre>
  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 return &lt;book year="{$b/attribute::year}"&gt;{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example1-Abstract" id="Example1-Abstract"></a>3.1.4
Corresponding Grammar Abstract Parse Tree</h4>
<p>For comparison, here is the abstract parse tree corresponding to
the XQuery for Example 1, as produced by the XQuery grammar applets
found at <a href=
"http://www.w3.org/2007/01/applets/">http://www.w3.org/2007/01/applets/</a>.</p>
<div class="exampleInner">
<pre>
XPath2
  QueryList
    Module
      MainModule
        Prolog
        QueryBody
          Expr
            PathExpr
              Constructor
                DirectConstructor
                  DirElemConstructor &gt;
                    LessThanOpOrTagO &lt;
                    TagQName bib
                    DirAttributeList
                    StartTagClose &gt;
                    DirElemContent
                      ElementContentChar 
                    DirElemContent
                      ElementContentChar  
                    DirElemContent
                      CommonContent
                        EnclosedExpr
                          Lbrace {
                          Expr
                            FLWORExpr
                              ForClause
                                VarName
                                  QName b
                                PathExpr
                                  FunctionCall
                                    FunctionQName doc
                                    PathExpr
                                      StringLiteral "http://bstore1.example.com/bib.xml"
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName bib
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName book
                              WhereClause
                                AndExpr and
                                  ComparisonExpr =
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep
                                          NodeTest
                                            NameTest
                                              QName publisher
                                    PathExpr
                                      StringLiteral "Addison-Wesley"
                                  ComparisonExpr &gt;
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep @
                                          NodeTest
                                            NameTest
                                              QName year
                                    PathExpr
                                      IntegerLiteral 1991
                              PathExpr
                                Constructor
                                  DirectConstructor
                                    DirElemConstructor &gt;
                                      LessThanOpOrTagO &lt;
                                      TagQName book
                                      DirAttributeList
                                        S  
                                        TagQName year
                                        ValueIndicator =
                                        DirAttributeValue
                                          OpenQuot "
                                          QuotAttrValueContent
                                            CommonContent
                                              EnclosedExpr
                                                Lbrace {
                                                Expr
                                                  PathExpr
                                                    VarName
                                                      QName b
                                                    StepExpr
                                                      AbbrevForwardStep @
                                                        NodeTest
                                                          NameTest
                                                            QName year
                                                Rbrace }
                                          CloseQuot "
                                      StartTagClose &gt;
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        CommonContent
                                          EnclosedExpr
                                            Lbrace {
                                            Expr
                                              PathExpr
                                                VarName
                                                  QName b
                                                StepExpr
                                                  AbbrevForwardStep
                                                    NodeTest
                                                      NameTest
                                                        QName title
                                            Rbrace }
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                          Rbrace }
                    DirElemContent
                      ElementContentChar 
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="Example2" id="Example2"></a>3.2 Example 2</h3>
<p>Here is Q4 from the <span><a href="#xquery-30-use-cases">[XQuery
3.0 Use Cases]</a></span> , use case XMP (Experiences and
Exemplars): "For each author in the bibliography, list the author's
name and the titles of all books by that author, grouped inside a
"result" element."</p>
<div class="div3">
<h4><a name="Example2-XQuery" id="Example2-XQuery"></a>3.2.1 XQuery
solution in XQuery Use Cases:</h4>
<div class="exampleInner">
<pre>
&lt;results&gt;
  {
    let $a := doc("http://bstore1.example.com/bib/bib.xml")//author
    for $last in distinct-values($a/last),
        $first in distinct-values($a[last=$last]/first)
    order by $last, $first
    return
        &lt;result&gt;
            &lt;author&gt;
               &lt;last&gt;{ $last }&lt;/last&gt;
               &lt;first&gt;{ $first }&lt;/first&gt;
            &lt;/author&gt;
            {
                for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
                where some $ba in $b/author 
                      satisfies ($ba/last = $last and $ba/first=$first)
                return $b/title
            }
        &lt;/result&gt;
  }
&lt;/results&gt; 
</pre></div>
</div>
<div class="div3">
<h4><a name="Example2-XQueryX" id="Example2-XQueryX"></a>3.2.2 A
solution in XQueryX:</h4>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;results&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:letClause&gt;
              &lt;xqx:letClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;a&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:letExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:functionCallExpr&gt;
                         &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                         &lt;xqx:arguments&gt;
                           &lt;xqx:stringConstantExpr&gt;
                             &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                           &lt;/xqx:stringConstantExpr&gt;
                         &lt;/xqx:arguments&gt;
                       &lt;/xqx:functionCallExpr&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:anyKindTest/&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                &lt;/xqx:letExpr&gt;
              &lt;/xqx:letClauseItem&gt;
            &lt;/xqx:letClause&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;last&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;first&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                          &lt;xqx:predicates&gt;
                            &lt;xqx:equalOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:pathExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:filterExpr&gt;
                                      &lt;xqx:contextItemExpr/&gt;
                                    &lt;/xqx:filterExpr&gt;
                                  &lt;/xqx:stepExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                    &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                  &lt;/xqx:stepExpr&gt;
                                &lt;/xqx:pathExpr&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:equalOp&gt;
                          &lt;/xqx:predicates&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;result&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;author&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;last&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;first&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                    &lt;xqx:flworExpr&gt;
                      &lt;xqx:forClause&gt;
                        &lt;xqx:forClauseItem&gt;
                          &lt;xqx:typedVariableBinding&gt;
                            &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                          &lt;/xqx:typedVariableBinding&gt;
                          &lt;xqx:forExpr&gt;
                            &lt;xqx:pathExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:filterExpr&gt;
                                  &lt;xqx:functionCallExpr&gt;
                                    &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                                    &lt;xqx:arguments&gt;
                                      &lt;xqx:stringConstantExpr&gt;
                                        &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                                      &lt;/xqx:stringConstantExpr&gt;
                                    &lt;/xqx:arguments&gt;
                                  &lt;/xqx:functionCallExpr&gt;
                                &lt;/xqx:filterExpr&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                            &lt;/xqx:pathExpr&gt;
                          &lt;/xqx:forExpr&gt;
                        &lt;/xqx:forClauseItem&gt;
                      &lt;/xqx:forClause&gt;
                      &lt;xqx:whereClause&gt;
                        &lt;xqx:quantifiedExpr&gt;
                          &lt;xqx:quantifier&gt;some&lt;/xqx:quantifier&gt;
                          &lt;xqx:quantifiedExprInClause&gt;
                            &lt;xqx:typedVariableBinding&gt;
                              &lt;xqx:varName&gt;ba&lt;/xqx:varName&gt;
                            &lt;/xqx:typedVariableBinding&gt;
                            &lt;xqx:sourceExpr&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:filterExpr&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:filterExpr&gt;
                                &lt;/xqx:stepExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:sourceExpr&gt;
                          &lt;/xqx:quantifiedExprInClause&gt;
                          &lt;xqx:predicateExpr&gt;
                            &lt;xqx:andOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:andOp&gt;
                          &lt;/xqx:predicateExpr&gt;
                        &lt;/xqx:quantifiedExpr&gt;
                      &lt;/xqx:whereClause&gt;
                      &lt;xqx:returnClause&gt;
                        &lt;xqx:pathExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:filterExpr&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:filterExpr&gt;
                          &lt;/xqx:stepExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                            &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                          &lt;/xqx:stepExpr&gt;
                        &lt;/xqx:pathExpr&gt;
                      &lt;/xqx:returnClause&gt;
                    &lt;/xqx:flworExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example2-Transformation" id=
"Example2-Transformation"></a>3.2.3 Transformation of XQueryX
Solution into XQuery</h4>
<p>Application of the stylesheet in <a href="#Stylesheet"><b>B
Transforming XQueryX to XQuery</b></a> to the XQueryX solution
results in:</p>
<div class="exampleInner">
<pre>
  
&lt;results&gt;{
 let $a:=doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::author
 for $last in distinct-values($a/child::last), $first in distinct-values($a[(./child::last = $last)]/child::first)
 order by $last , $first 
 return &lt;result&gt;&lt;author&gt;&lt;last&gt;{$last}&lt;/last&gt;&lt;first&gt;{$first}&lt;/first&gt;&lt;/author&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (some $ba in $b/child::author satisfies (($ba/child::last = $last) and ($ba/child::first = $first)))
 return $b/child::title
}&lt;/result&gt;
}&lt;/results&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="Example3" id="Example3"></a>3.3 Example 3</h3>
<p>Here is Q7 from the <span><a href="#xquery-30-use-cases">[XQuery
3.0 Use Cases]</a></span> , use case XMP (Experiences and
Exemplars): "List the titles and years of all books published by
Addison-Wesley after 1991, in alphabetic order."</p>
<div class="div3">
<h4><a name="Example3-XQuery" id="Example3-XQuery"></a>3.3.1 XQuery
solution in XQuery Use Cases:</h4>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  {
    for $b in doc("http://bstore1.example.com/bib.xml")//book
    where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
    order by $b/title
    return
        &lt;book&gt;
            { $b/@year }
            { $b/title }
        &lt;/book&gt;
  }
&lt;/bib&gt; 
</pre></div>
</div>
<div class="div3">
<h4><a name="Example3-XQueryX" id="Example3-XQueryX"></a>3.3.2 A
solution in XQueryX:</h4>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
             &lt;xqx:elementConstructor&gt;
               &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
               &lt;xqx:elementContent&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
               &lt;/xqx:elementContent&gt;
             &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example3-Transformation" id=
"Example3-Transformation"></a>3.3.3 Transformation of XQueryX
Solution into XQuery</h4>
<p>Application of the stylesheet in <a href="#Stylesheet"><b>B
Transforming XQueryX to XQuery</b></a> to the XQueryX solution
results in:</p>
<div class="exampleInner">
<pre>
  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 order by $b/child::title 
 return &lt;book&gt;{$b/attribute::year}{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="Example4" id="Example4"></a>3.4 Example 4</h3>
<p>Here is Q8 from the <span><a href="#xquery-30-use-cases">[XQuery
3.0 Use Cases]</a></span> , use case NS (Queries Using Namespaces):
"Select all traders (either seller or high bidder) without negative
comments."</p>
<div class="div3">
<h4><a name="Example4-XQuery" id="Example4-XQuery"></a>3.4.1 XQuery
solution in XQuery Use Cases:</h4>
<div class="exampleInner">
<pre>
declare namespace ma = "http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay" 
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  {
    for $s in doc("auction.xml")//ma:Trading_Partners/(ma:Seller | ma:High_Bidder)
    where $s/*:NegativeComments = 0
    return $s
  }
&lt;/Q8&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example4-XQueryX" id="Example4-XQueryX"></a>3.4.2 A
solution in XQueryX:</h4>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--    XQX.E2 - Editorial (Bugzilla Bug 4963)                                          --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:namespaceDecl&gt;
        &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
        &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
      &lt;/xqx:namespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;Q8&lt;/xqx:tagName&gt;
        &lt;xqx:attributeList&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;eachbay&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/auctioneers#eachbay&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;xlink&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.w3.org/1999/xlink&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
        &lt;/xqx:attributeList&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;s&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;auction.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest xqx:prefix="ma"&gt;Trading_Partners&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:sequenceExpr&gt;
                          &lt;xqx:unionOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;Seller&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;High_Bidder&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:unionOp&gt;
                        &lt;/xqx:sequenceExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:equalOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;s&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:Wildcard&gt;
                        &lt;xqx:star/&gt;
                        &lt;xqx:NCName&gt;NegativeComments&lt;/xqx:NCName&gt;
                      &lt;/xqx:Wildcard&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:integerConstantExpr&gt;
                    &lt;xqx:value&gt;0&lt;/xqx:value&gt;
                  &lt;/xqx:integerConstantExpr&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:equalOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;s&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="Example4-Transformation" id=
"Example4-Transformation"></a>3.4.3 Transformation of XQueryX
Solution into XQuery</h4>
<p>Application of the stylesheet in <a href="#Stylesheet"><b>B
Transforming XQueryX to XQuery</b></a> to the XQueryX solution
results in:</p>
<div class="exampleInner">
<pre>
  
declare namespace ma="http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay"
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;{
 for $s in fn:doc("auction.xml")/descendant-or-self::node()/
                                 child::ma:Trading_Partners/
                                 ((child::ma:Seller union child::ma:High_Bidder))
 where ($s/child::*:NegativeComments = 0)
 return $s
}&lt;/Q8&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Schema" id="Schema"></a>4 An XML Schema for the XQuery
XML Syntax</h2>
<p>Here is the XML Schema against which XQueryX documents must be
valid.</p>
<div class="exampleInner">
<pre>
<span>&lt;!--  ================================================================================  --&gt;
&lt;!--  NOTES TO READERS OF THIS SCHEMA:                                                  --&gt;
&lt;!--  The default value for both minOccurs and maxOccurs is "1".                        --&gt;
&lt;!--  The XQueryX schema has been designed to provide the ability to extend definitions --&gt;
&lt;!--    of top-level elements in extensions such as Full-Text and the Update Facility.  --&gt;
&lt;!--    The nature of the modification is to define named complex types and redefine    --&gt;
&lt;!--    those top-level elements in terms of the named complex types.                   --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Changes from Recommendation (edition 1):                                          --&gt;
&lt;!--  * Element defs using anon complex types changed to use named types (bug #4924)    --&gt;
&lt;!--  * In Example 4, replaced xqx:parentheziedExpr with xqx:sequenceExpr (bug #4963)   --&gt;
&lt;!--  * In XSLT stylesheet, deleted template for xqx:parenthesizedExpr (bug #4963)      --&gt;
&lt;!--  * Replaced link to grammar applet with correct link (bug #5323)                   --&gt;
&lt;!--  * In XSLT stylesheet, corrected template for xqx:namespaceDeclaration (bug #5343) --&gt;
&lt;!--  Changes from Recommendation (edition 2):                                          --&gt;
&lt;!--  * Added support for new Windowing clause in FLWOR expression                      --&gt;
&lt;!--  * Added support for new Group By Clause in FLWOR expression                       --&gt;
&lt;!--  * Added support for new Count Clause in FLWOR expression                          --&gt;
&lt;!--  * Added support for keyword "outer" on for expression                             --&gt;
&lt;!--  * Modified structure of FLWOR clause per "simplified FLWOR expressions"           --&gt;
&lt;!--  * Modified validation syntax per Bugzilla Bug 5472                                --&gt;
&lt;!--  * Modified function declaration so that external functions can be nondeterminstic --&gt;
&lt;!--  * Modified variable declaration so external variables can have an initial value   --&gt;
&lt;!--  * Added support for new try-catch expression                                      --&gt;
&lt;!--  * Added support for new decimal formatting declaration                            --&gt;
&lt;!--  * Added support for encoding in the version declaration                           --&gt;
&lt;!--  * Added support for new context item declaration                                  --&gt;
&lt;!--  * Added support for computed namespace constructor                                --&gt;
&lt;!--  * Made changes triggered by Bugzilla Bugs 6309, 6310, and 6311                    --&gt;
&lt;!--  * Modified errlist syntax per Bugzilla Bug 7053                                   --&gt;
&lt;!--  * Added support for public/private functions                                      --&gt;
&lt;!--  * Replaced "outer for" support with support for "allowing empty"                  --&gt;
&lt;!--  * Added support for higher-order functions                                        --&gt;
&lt;!--  * Added support for value-based "switch" expression                               --&gt;
&lt;!--  * Use pattern to prohibit "#)" in pragma contents per Bugzilla Bug 2711           --&gt;
&lt;!--  * Changed functionItemExpr child element QName to be functionName for consistency --&gt;
&lt;!--  * Replaced "public", "private", and "[non]deterministic" with %-annotations       --&gt;
&lt;!--  * Added EQName to permit "URI-literal":NCNAME as alternative to NCName:NCName     --&gt;
&lt;!--  * Changed type of atomicType to EQName, so it's really atomicOrUnionType          --&gt;
&lt;!--  * Added simpleMapExpr and removed mapStepExpr (see bug 16197)                     --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--    XQX.E1 - Editorial (Bugzilla Bug 4924)                                          --&gt;
&lt;!--    XQX.E7 - Substantive (Bugzilla Bug 2711)                                        --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Modifications:                                                                    --&gt;
&lt;!--    2008-07-30 - Add XQuery 1.1 grouping and windowing support                      --&gt;
&lt;!--    2008-09-18 - Add XQuery 1.1 count and outer-for support, simplified FLWOR       --&gt;
&lt;!--    2008-09-27 - Add validation type, nondeterministic function declarations,       --&gt;
&lt;!--                 initial values for external variables, try-catch expression        --&gt;
&lt;!--    2008-11-25 - Add support for number formatting, Snelson's version declaration   --&gt;
&lt;!--                 proposal, context item declaration, computed namespace constructor,--&gt;
&lt;!--                 fixes for validate expression, and change to allow the count       --&gt;
&lt;!--                 clause to only be an intermediate expression                       --&gt;
&lt;!--    2009-01-13 - Bugs 6309 and 6310 (fixes to details of certain windowing clauses  --&gt;
&lt;!--    2009-03-03 - tumblingWindowClause syntax now matches slidingWindowClause syntax --&gt;
&lt;!--    2009-09-06 - Modified errlist syntax per Bugzilla Bug 7053                      --&gt;
&lt;!--    2009-10-09 - Added support for private/public functions                         --&gt;
&lt;!--                 Replace "outer for" with "allowing empty"                          --&gt;
&lt;!--    2009-10-22 - Add support for higher-order functions &amp; switch expression         --&gt;
&lt;!--    2010-04-06 - Changed functionItemExpr child QName -&gt; functionName (consistency) --&gt;
&lt;!--    2010-05-10 - Added %-annotation support for varDecl and functionDecl            --&gt;
&lt;!--    2010-06-23 - Added support for partial function application                     --&gt;
&lt;!--    2011-02-02 - Added support for EQNames and atomicOrUnionType                    --&gt;
&lt;!--    2011-05-04 - Updated structure of catch component of try-catch expression       --&gt;
&lt;!--    2011-05-04 - Updated validationexpr, mode/type alternatives, type is EQName     --&gt;
&lt;!--    2011-07-08 - Added support for concatenation operator ||                        --&gt;
&lt;!--  * 2011-09-09 - Added support for simple mapping operator !                        --&gt;
&lt;!--  * 2011-09-09 - Added support for sequenceTypeUnion in typeswitch                  --&gt;
&lt;!--  * 2011-09-09 - Added support for annotations on inline functions                  --&gt;
&lt;!--    2011-09-14 - Added support for new group-by syntax                              --&gt;
&lt;!--    2011-11-21 - Jim changed "literalFunctionItemExpr" to "namedFunctionRef"        --&gt;
&lt;!--    2011-11-21 - Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"       --&gt;
&lt;!--    2012-06-15 - Added simpleMapExpr and removed mapStepExpr (see bug 16197)        --&gt;
&lt;!--    2012-09-07 - Added %-annotation support for function tests                      --&gt;
&lt;!--    2012-09-07 - Added %-annotation support for function tests                      --&gt;
&lt;!--    2012-09-25 - Either version, encoding, or both are now required in versionDecl  --&gt;
&lt;!--    2013-09-27 - Jim modified the definition of simpleMapExpr for multiple args     --&gt;
&lt;!--  ================================================================================  --&gt;
</span>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns="http://www.w3.org/2005/XQueryX"
            targetNamespace="http://www.w3.org/2005/XQueryX"
            elementFormDefault="qualified" attributeFormDefault="qualified"&gt;


&lt;!-- A few helper declarations                                                          --&gt;
  &lt;xsd:complexType name="emptyContent"/&gt;

  &lt;xsd:element name="NCName" type="xsd:NCName"/&gt;

  &lt;xsd:complexType name="QName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

<span>  &lt;xsd:complexType name="EQName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
        &lt;xsd:attribute name="URI" type="xsd:string" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

</span>&lt;!-- The base expression class                                                          --&gt;
  &lt;xsd:complexType name="expr"/&gt;

  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;


&lt;!-- A list of expressions                                                              --&gt;
  &lt;xsd:complexType name="exprList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

<span>&lt;!-- A list of expressions or placeholders                                              --&gt;
&lt;!-- 2010-06-23 - Added support for partial function application                        --&gt;
  &lt;xsd:complexType name="exprOrPlaceholderList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xsd:element ref="expr"/&gt;
        &lt;xsd:element name="argumentPlaceholder" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

</span>&lt;!-- A type to be used by elements that comprise an optional expr                       --&gt;
  &lt;xsd:complexType name="exprWrapperOptional"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- Simple wrapper class                                                               --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

<span>&lt;!-- A list of literals                                                                 --&gt;
&lt;!-- 2013-03-17 = Added new support for a list of literals, e.g., in annotations        --&gt;
  &lt;xsd:complexType name="literalList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="constantExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

</span>&lt;!-- constant expressions. We have 4 different subclasses for this                      --&gt;
  &lt;xsd:complexType name="constantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:anyType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constantExpr" type="constantExpr" abstract="true"
               substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="integerConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:integer"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="decimalConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:decimal"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalConstantExpr" type="decimalConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="doubleConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:double"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="doubleConstantExpr" type="doubleConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="stringConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stringConstantExpr" type="stringConstantExpr"
               substitutionGroup="constantExpr"/&gt;


&lt;!-- Variables                                                                          --&gt;
  &lt;xsd:complexType name="varRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
<span>          &lt;xsd:element name="name" type="EQName"/&gt;
</span>        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varRef" type="varRef" substitutionGroup="expr"/&gt;


&lt;!-- root and context-item expressions                                                  --&gt;
&lt;!-- rootExpr deleted per Bugzilla Bug #2523                                            --&gt;
  &lt;xsd:complexType name="contextItemExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemExpr" type="contextItemExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Pragmas and extension expressions                                                  --&gt;
&lt;!--   2010-01-01, JM replaced pragmaContents elem def'n with one that has a pattern    --&gt;
  &lt;xsd:complexType name="pragma"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="pragmaName" type="EQName"/&gt;
      &lt;xsd:element name="pragmaContents"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:string"&gt;
            &lt;xsd:pattern value="(([^#]|#+[^\)#])*#*)"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
</span>    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pragma" type="pragma"/&gt;


  &lt;xsd:complexType name="extensionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="pragma" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="extensionExpr" type="extensionExpr"
               substitutionGroup="expr"/&gt;


<span>&lt;!-- Simple map expressions                                                             --&gt;
&lt;!-- 2012-06-15 - Changed precedence and precise grammar for simple map operator        --&gt;
&lt;!-- 2013-09-27 - Changed definition of simpleMapExpr to allow multiple path expressions--&gt;
  &lt;xsd:complexType name="simpleMapExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence minOccurs="2" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="pathExpr"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="simpleMapExpr" type="simpleMapExpr"
               substitutionGroup="expr"/&gt;
</span>

&lt;!-- Function call expressions                                                          --&gt;
&lt;!-- 2010-06-23 - Added support for partial function application                        --&gt;
  &lt;xsd:complexType name="functionCallExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
<span>          &lt;xsd:element name="functionName" type="EQName"/&gt;
          &lt;xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/&gt;
</span>        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionCallExpr" type="functionCallExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Constructor functions                                                              --&gt;
  &lt;xsd:complexType name="constructorFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
<span>          &lt;xsd:element name="typeName" type="EQName"/&gt;
</span>          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constructorFunctionExpr" type="constructorFunctionExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Sequence expressions                                                               --&gt;
  &lt;xsd:complexType name="sequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="rangeSequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="startExpr" type="exprWrapper"/&gt;
          &lt;xsd:element name="endExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Builtin operator expressions                                                       --&gt;
  &lt;xsd:complexType name="operatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;xsd:complexType name="unaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="operand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;xsd:complexType name="binaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="firstOperand" type="exprWrapper"/&gt;
          &lt;xsd:element name="secondOperand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


&lt;!-- General operator expressions --&gt;
  &lt;xsd:element name="operatorExpr" type="operatorExpr"
               abstract="true" substitutionGroup="expr"/&gt;

&lt;!-- Arithmetic operator expressions --&gt;
  &lt;xsd:element name="arithmeticOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="addOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="subtractOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="multiplyOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="divOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="idivOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="modOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryMinusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryPlusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

<span>&lt;!-- String operator expressions --&gt;
  &lt;xsd:element name="stringOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="stringConcatenateOp" type="binaryOperatorExpr"
               substitutionGroup="stringOp"/&gt;

</span>&lt;!-- Comparison operator expressions --&gt;
  &lt;xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

&lt;!-- Value comparison operator expressions --&gt;
  &lt;xsd:element name="valueComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="eqOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="neOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="gtOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="geOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="ltOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="leOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

&lt;!-- General comparison operator expressions --&gt;
  &lt;xsd:element name="generalComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="equalOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="notEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

&lt;!-- Node comparison operator expressions --&gt;
  &lt;xsd:element name="nodeComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="isOp" type="binaryOperatorExpr"
               substitutionGroup="nodeComparisonOp"/&gt;

&lt;!-- Order comparison operator expressions --&gt;
  &lt;xsd:element name="orderComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="nodeBeforeOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="nodeAfterOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/&gt;

&lt;!-- Logical operator expressions --&gt;
  &lt;xsd:element name="logicalOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="andOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="orOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="setOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="unionOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="intersectOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="exceptOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;


&lt;!-- Basic typenames                                                                    --&gt;
<span>&lt;!-- By changing the type attribute from QName to EQName, this is now atomicOrUnionType --&gt;
&lt;!--   However, for backwards compatibility w/XQueryX 1.0, the name had to stay the same--&gt;
  &lt;xsd:element name="atomicType" type="EQName" substitutionGroup="itemType"/&gt;
</span>

&lt;!-- Used in castable expression and cast expression                                    --&gt;
  &lt;xsd:complexType name="singleType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="atomicType"/&gt;
      &lt;xsd:element name="optional" type="emptyContent" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="singleType" type="singleType"/&gt;


&lt;!-- Item type schema types and elements                                                --&gt;
  &lt;xsd:element name="itemType" abstract="true"/&gt;

<span>  &lt;xsd:complexType name="contextItemType"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="itemType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemType" type="contextItemType" substitutionGroup="itemType"/&gt;
</span>

  &lt;xsd:complexType name="emptyItemTypeContent"/&gt;

  &lt;xsd:element name="anyItemType" type="emptyItemTypeContent"
               substitutionGroup="itemType"/&gt;


  &lt;xsd:simpleType name="occurrenceIndicator"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="?"/&gt;
      &lt;xsd:enumeration value="*"/&gt;
      &lt;xsd:enumeration value="+"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


&lt;!-- Sequence type                                                                      --&gt;
  &lt;xsd:complexType name="sequenceType"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="voidSequenceType" type="emptyContent"/&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="itemType"/&gt;
        &lt;xsd:element name="occurrenceIndicator" type="occurrenceIndicator"
                     minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceType" type="sequenceType"/&gt;

  &lt;xsd:element name="typeDeclaration" type="sequenceType"/&gt;


<span>&lt;!-- Union of sequence types                                                           --&gt;
&lt;!-- 2011-09-09/JM - added a sequenceTypeUnion type                                    --&gt;
  &lt;xsd:complexType name="sequenceTypeUnion"&gt;
    &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="sequenceType"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceTypeUnion" type="sequenceTypeUnion"/&gt;
</span>


&lt;!-- Represents a "typed" variable (for clause, let clause etc)                         --&gt;
  &lt;xsd:complexType name="typedVariableBinding"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="varName" type="EQName"/&gt;
</span>      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedVariableBinding" type="typedVariableBinding"/&gt;


&lt;!-- Represents an untyped variable for the "at" clause in a for clause                 --&gt;
<span>  &lt;xsd:element name="positionalVariableBinding" type="EQName"/&gt;

  &lt;xsd:element name="variableBinding" type="EQName"/&gt;
</span>

&lt;!-- Represents all variable bindings in a for or let clause except typed and           --&gt;
&lt;!--   positional variable bindings                                                     --&gt;
  &lt;xsd:element name="forLetClauseItemExtensions" abstract="true"/&gt;


&lt;!-- Major syntax productions: FLWOR clause components                                  --&gt;
&lt;!-- for clause                                                                         --&gt;
  &lt;xsd:complexType name="forClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
<span>      &lt;xsd:element name="allowingEmpty" type="emptyContent"
                   minOccurs="0"/&gt;
</span>       &lt;xsd:element ref="positionalVariableBinding" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClauseItem" type="forClauseItem"/&gt;


  &lt;xsd:complexType name="forClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClause" type="forClause"/&gt;


&lt;!-- let clause                                                                         --&gt;
  &lt;xsd:complexType name="letClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
          &lt;xsd:element ref="forLetClauseItemExtensions"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:element ref="forLetClauseItemExtensions"
                     minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClauseItem" type="letClauseItem"/&gt;


  &lt;xsd:complexType name="letClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClause" type="letClause"/&gt;


<span>&lt;!-- This is the windowClause (part of FLWOR expression)                                --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!-- WindowClause ::= "for" (TumblingWindowClause | SlidingWindowClause)               --&gt;
  &lt;xsd:complexType name="windowClause"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="tumblingWindowClause"/&gt;
      &lt;xsd:element ref="slidingWindowClause"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowClause" type="windowClause"/&gt;


&lt;!-- This is the tumblingWindowClause                                                   --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!-- TumblingWindowClause ::= "tumbling" "window" "$" VarName TypeDeclaration?          --&gt;
&lt;!--                           "in" ExprSingle WindowStartCondition WindowEndCondition? --&gt;
  &lt;xsd:complexType name="tumblingWindowClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="bindingSequence" type="exprWrapper"/&gt;
      &lt;xsd:element ref="windowStartCondition"/&gt;
      &lt;xsd:element ref="windowEndCondition" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="tumblingWindowClause" type="tumblingWindowClause"/&gt;


&lt;!-- This is the slidingWindowClause                                                    --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!-- SlidingWindowClause ::= "sliding" "window" "$" VarName TypeDeclaration?            --&gt;
&lt;!--                         "in" ExprSingle WindowStartCondition WindowEndCondition    --&gt;
  &lt;xsd:complexType name="slidingWindowClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="bindingSequence" type="exprWrapper"/&gt;
      &lt;xsd:element ref="windowStartCondition"/&gt;
      &lt;xsd:element ref="windowEndCondition"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="slidingWindowClause" type="slidingWindowClause"/&gt;


&lt;!-- windowStartCondition                                                               --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowStartCondition ::= "start" WindowVars "when" ExprSingle                      --&gt;
  &lt;xsd:complexType name="windowStartCondition"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="windowVars" minOccurs="0"/&gt;
      &lt;xsd:element name="winStartExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowStartCondition" type="windowStartCondition"/&gt;


&lt;!-- windowEndCondition                                                                 --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowEndCondition         ::=          "only"? "end" WindowVars "when" ExprSingle        --&gt;
  &lt;xsd:complexType name="windowEndCondition"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="windowVars" minOccurs="0"/&gt;
      &lt;xsd:element name="winEndExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="onlyEnd" type="xsd:boolean" default="false"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowEndCondition" type="windowEndCondition"/&gt;


&lt;!-- windowVars                                                                         --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowVars ::= ("$" \)? PositionalVar? ("previous" "$" PreviousItem)?    --&gt;
&lt;!--                ("next" "$" NextItem)?                                              --&gt;
  &lt;xsd:complexType name="windowVars"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="currentItem" type="EQName" minOccurs="0"/&gt;
      &lt;xsd:element ref="positionalVariableBinding" minOccurs="0"/&gt;
      &lt;xsd:element name="previousItem" type="EQName" minOccurs="0"/&gt;
      &lt;xsd:element name="nextItem" type="EQName" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowVars" type="windowVars"/&gt;


&lt;!-- countClause (part of FLWOR expression)                                             --&gt;
  &lt;xsd:complexType name="countClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="varRef"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="countClause" type="countClause"/&gt;


</span>&lt;!-- whereClause (part of FLWOR expression)                                             --&gt;
  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;


<span>&lt;!-- groupByClause (part of FLWOR expression)                                           --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- GroupByClause ::= "group" "by" GroupingSpecList                                    --&gt;
&lt;!-- GroupingSpecList ::= GroupingSpec ("," GroupingSpec)*                              --&gt;
  &lt;xsd:complexType name="groupByClause"&gt;
    &lt;xsd:sequence maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="groupingSpec"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="groupByClause" type="groupByClause"/&gt;


&lt;!-- 2011-09-14/JM - added the ability to initialize a grouping variable, opt set type  --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- GroupingSpec ::=                                                                   --&gt;
&lt;!--     "$" VarName ( typeDeclaration? ":=" exprSingle )? ("collation" URILiteral)?    --&gt;
  &lt;xsd:complexType name="groupingSpec"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element name="groupVarInitialize" minOccurs="0"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
            &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="groupingSpec" type="groupingSpec"/&gt;


</span>&lt;!-- order by clause                                                                    --&gt;
  &lt;xsd:simpleType name="emptyOrderingMode"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="empty greatest"/&gt;
      &lt;xsd:enumeration value="empty least"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:simpleType name="orderingKind"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="ascending"/&gt;
      &lt;xsd:enumeration value="descending"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;xsd:complexType name="orderModifier"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="orderingKind" type="orderingKind" minOccurs="0"/&gt;
      &lt;xsd:element name="emptyOrderingMode" type="emptyOrderingMode" minOccurs="0"/&gt;
      &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderModifier" type="orderModifier"/&gt;


  &lt;xsd:complexType name="orderBySpec"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="orderByExpr" type="exprWrapper"/&gt;
      &lt;xsd:element ref="orderModifier" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderBySpec" type="orderBySpec"/&gt;


  &lt;xsd:complexType name="orderByClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="stable" type="emptyContent" minOccurs="0"/&gt;
      &lt;xsd:element ref="orderBySpec" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderByClause" type="orderByClause"/&gt;


&lt;!-- return clause                                                                      --&gt;
  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;


<span>&lt;!-- This is the XQuery 3.0 flwor expression                                            --&gt;
&lt;!-- Corresponds to the following XQuery syntax:                                        --&gt;
&lt;!-- 1.1 FLWORExpr ::= (ForClause | LetClause | WindowClause)                           --&gt;
&lt;!--                   (ForClause | LetClause | WindowClause | CountClause |            --&gt;
&lt;!--                    WhereClause | GroupByClause | OrderByClause)*                   --&gt;
&lt;!--                   ReturnClause                                                     --&gt;
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
            &lt;xsd:element ref="windowClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xsd:element ref="forClause"/&gt;
              &lt;xsd:element ref="letClause"/&gt;
              &lt;xsd:element ref="windowClause"/&gt;
              &lt;xsd:element ref="countClause"/&gt;
              &lt;xsd:element ref="whereClause"/&gt;
              &lt;xsd:element ref="groupByClause"/&gt;
              &lt;xsd:element ref="orderByClause"/&gt;
            &lt;/xsd:choice&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

</span>  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;


&lt;!-- conditional expressions                                                            --&gt;
  &lt;xsd:complexType name="ifThenElseExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ifClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="thenClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="elseClause" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ifThenElseExpr" type="ifThenElseExpr" 
               substitutionGroup="expr"/&gt;


&lt;!-- The following clauses describe quantified expressions                              --&gt;
  &lt;xsd:simpleType name="quantifier"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="some"/&gt;
      &lt;xsd:enumeration value="every"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;xsd:complexType name="quantifiedExprInClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="sourceExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExprInClause" type="quantifiedExprInClause"/&gt;


  &lt;xsd:complexType name="quantifiedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="quantifier" type="quantifier"/&gt;
          &lt;xsd:element ref="quantifiedExprInClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="predicateExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExpr" type="quantifiedExpr"
               substitutionGroup="expr"/&gt;


<span>&lt;!-- handle the switch expression                                                       --&gt;
&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within switch     --&gt;
  &lt;xsd:complexType name="switchExprCaseClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="switchCaseExpr" type="exprWrapper" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExprCaseClause"
               type="switchExprCaseClause"/&gt;


&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within switch     --&gt;
  &lt;xsd:complexType name="switchExprDefaultClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExprDefaultClause"
               type="switchExprDefaultClause"/&gt;


  &lt;xsd:complexType name="switchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="switchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="switchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExpr" type="switchExpr"
               substitutionGroup="expr"/&gt;


</span>&lt;!-- handle the typeswitch expression                                                   --&gt;
&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within typeswitch --&gt;
&lt;!-- 2011-09-09/JM - replaced sequenceType with sequenceTypeUnion                       --&gt;
  &lt;xsd:complexType name="typeswitchExprCaseClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
<span>          &lt;xsd:choice&gt;
            &lt;xsd:element ref="sequenceType"/&gt;
            &lt;xsd:element ref="sequenceTypeUnion"/&gt;
          &lt;/xsd:choice&gt;
</span>          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExprCaseClause"
               type="typeswitchExprCaseClause"/&gt;


&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within typeswitch --&gt;
  &lt;xsd:complexType name="typeswitchExprDefaultClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExprDefaultClause"
               type="typeswitchExprDefaultClause"/&gt;


  &lt;xsd:complexType name="typeswitchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="typeswitchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="typeswitchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExpr" type="typeswitchExpr"
               substitutionGroup="expr"/&gt;


<span>&lt;!-- TryCatchExpression                                                                 --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- TryCatchExpression ::= TryClause CatchClause+                                      --&gt;
&lt;!-- TryClause ::= "{" TryTargetExpr "}"                                                --&gt;
&lt;!-- TryTargetExpr ::= Expr                                                             --&gt;
  &lt;xsd:complexType name="tryCatchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tryClause" type="exprWrapper"/&gt;
          &lt;xsd:element ref="catchClause" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="tryCatchExpr" type="tryCatchExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- CatchClause (part of the TryCatchExpression)                                       --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- CatchClause ::= "catch" CatchErrorList "{" Expr "}"                                --&gt;
  &lt;xsd:complexType name="catchClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="catchErrorList"/&gt;
      &lt;xsd:element name="catchExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="catchClause" type="catchClause"/&gt;


&lt;!-- CatchErrorList (part of the TryCatchExpression)                                    --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- CatchErrorList ::= NameTest ( "|" NameTest )*                                      --&gt;
&lt;!-- (remembering that NameTest is either QName or Wildcard)                            --&gt;
  &lt;xsd:complexType name="catchErrorList"&gt;
    &lt;xsd:sequence maxOccurs="unbounded"&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element ref="nameTest"/&gt;
        &lt;xsd:element ref="Wildcard"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="catchErrorList" type="catchErrorList"/&gt;


</span>&lt;!-- instance-of expressions                                                            --&gt;
  &lt;xsd:complexType name="instanceOfExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="instanceOfExpr" type="instanceOfExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- treat-as expressions                                                               --&gt;
  &lt;xsd:complexType name="treatExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="treatExpr" type="treatExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- castable and cast expressions                                                      --&gt;
  &lt;xsd:complexType name="castableExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castableExpr" type="castableExpr"
               substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="castExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castExpr" type="castExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Validate expressions                                                               --&gt;
  &lt;xsd:simpleType name="validationMode"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="lax"/&gt;
      &lt;xsd:enumeration value="strict"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="validateExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
<span>          &lt;xsd:choice&gt;
            &lt;xsd:element name="validationMode" type="validationMode" minOccurs="0"/&gt;
            &lt;xsd:element name="typeName" type="EQName" minOccurs="0"/&gt;
          &lt;/xsd:choice&gt;
</span>          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="validateExpr" type="validateExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Direct constructors. Only elementConstructor for now                               --&gt;
&lt;!-- Note the absence of constructors corresponding to                                  --&gt;
&lt;!-- the directCommentConstructor and the directPIConstructor                           --&gt;
&lt;!-- productions in the XQuery grammar. This is because they are                        --&gt;
&lt;!-- trivially identical to the computed variants                                       --&gt;

&lt;!-- attributeConstructor is no longer a subclass of expr                               --&gt;
  &lt;xsd:complexType name="attributeConstructor"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="attributeName" type="QName"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="attributeValueExpr" type="exprList"/&gt;
        &lt;xsd:element name="attributeValue" type="xsd:string"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="namespaceDeclaration"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


&lt;!-- element constructors                                                               --&gt;
  &lt;xsd:complexType name="attributeList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice maxOccurs="unbounded"&gt;
        &lt;xsd:element name="attributeConstructor" type="attributeConstructor"/&gt;
        &lt;xsd:element name="namespaceDeclaration" type="namespaceDeclaration"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeList" type="attributeList"/&gt;


  &lt;xsd:element name="elementContent" type="exprList"/&gt;


  &lt;xsd:complexType name="elementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tagName" type="QName"/&gt;
          &lt;xsd:element ref="attributeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="elementContent" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementConstructor" type="elementConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed constructors                                                              --&gt;
&lt;!-- computed element constructor                                                       --&gt;
  &lt;xsd:complexType name="computedElementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
<span>            &lt;xsd:element name="tagName" type="EQName"/&gt;
</span>            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="contentExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedElementConstructor" type="computedElementConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed attribute constructor                                                     --&gt;
  &lt;xsd:complexType name="computedAttributeConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
<span>            &lt;xsd:element name="tagName" type="EQName"/&gt;
</span>            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="valueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedAttributeConstructor" type="computedAttributeConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed document constructor                                                      --&gt;
  &lt;xsd:complexType name="computedDocumentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedDocumentConstructor" type="computedDocumentConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed text constructor                                                          --&gt;
  &lt;xsd:complexType name="computedTextConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedTextConstructor" type="computedTextConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed comment constructor                                                       --&gt;
  &lt;xsd:complexType name="computedCommentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedCommentConstructor" type="computedCommentConstructor"
               substitutionGroup="expr"/&gt;


<span>&lt;!-- computed namespace constructor                                                     --&gt;
  &lt;xsd:complexType name="computedNamespaceConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
            &lt;xsd:element name="prefixExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="URIExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedNamespaceConstructor" type="computedNamespaceConstructor"
               substitutionGroup="expr"/&gt;


</span>&lt;!-- computed processing instruction constructor                                        --&gt;
  &lt;xsd:complexType name="computedPIConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName"/&gt;
            &lt;xsd:element name="piTargetExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="piValueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedPIConstructor" type="computedPIConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- ordered and unordered expressions                                                  --&gt;
  &lt;xsd:complexType name="unorderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="unorderedExpr" type="unorderedExpr" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="orderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderedExpr" type="orderedExpr" substitutionGroup="expr"/&gt;


<span>&lt;!-- function item expressions                                                          --&gt;
&lt;!-- literal function item expression                                                   --&gt;
&lt;!-- 2010-04-06: Jim changed child element QName to be functionName for consistency     --&gt;
&lt;!-- 2011-11-21: Jim changed "literalFunctionItemExpr" to "namedFunctionRef"            --&gt;
  &lt;xsd:complexType name="namedFunctionRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionName" type="EQName"/&gt;
          &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namedFunctionRef" type="namedFunctionRef" substitutionGroup="expr"/&gt;


&lt;!-- inline function item expression                                                    --&gt;
&lt;!-- 2011-09-09/JM - Added annotations to inline functions                              --&gt;
&lt;!-- 2011-11-21: Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"           --&gt;
  &lt;xsd:complexType name="inlineFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="paramList"/&gt;
          &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
          &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="inlineFunctionExpr" type="inlineFunctionExpr" substitutionGroup="expr"/&gt;


&lt;!-- dynamic function invocations                                                       --&gt;
&lt;!-- 2010-06-23 - Added support for partial function application                        --&gt;
  &lt;xsd:complexType name="dynamicFunctionInvocationExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionItem"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:group ref="filterExpr"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
          &lt;xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="dynamicFunctionInvocationExpr" type="dynamicFunctionInvocationExpr" substitutionGroup="expr"/&gt;


</span>&lt;!-- wildcards                                                                          --&gt;
  &lt;xsd:complexType name="simpleWildcard"&gt;
    &lt;xsd:choice&gt;
<span>      &lt;xsd:element name="QName" type="EQName"/&gt;
</span>      &lt;xsd:element name="star" type="emptyContent"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- 2011-06-10: Redesigned to allow "URliteral:*"                                                  --&gt;
&lt;!-- Corresponds to the following XQuery syntax:                                                    --&gt;
&lt;!--   [44] Wildcard ::= "*"                                                                        --&gt;
&lt;!--                  | (NCName ":" "*")                                                            --&gt;
&lt;!--                  | ("*" ":" NCName)                                                            --&gt;
&lt;!--                  | (URILiteral ":" "*")                                                        --&gt;

  &lt;xsd:complexType name="Wildcard"&gt;
<span>    &lt;xsd:choice minOccurs="0"&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
        &lt;xsd:element ref="NCName"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="NCName"/&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="uri" type="xsd:string"/&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
</span>  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="Wildcard" type="Wildcard"/&gt;


&lt;!-- tests (name and/or type)                                                           --&gt;
<span>  &lt;xsd:element name="schemaAttributeTest" type="EQName"
               substitutionGroup="kindTest"/&gt;
</span>

  &lt;xsd:complexType name="attributeTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence minOccurs="0"&gt;
          &lt;xsd:element name="attributeName" type="simpleWildcard"/&gt;
<span>          &lt;xsd:element name="typeName" type="EQName" minOccurs="0"/&gt;
</span>        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeTest" type="attributeTest"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="anyElementTest" abstract="true"
               substitutionGroup="kindTest"/&gt;


<span>  &lt;xsd:element name="schemaElementTest" type="EQName"
               substitutionGroup="anyElementTest"/&gt;
</span>

  &lt;xsd:complexType name="elementTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence minOccurs="0"&gt;
          &lt;xsd:element name="elementName" type="simpleWildcard"/&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
<span>            &lt;xsd:element name="typeName" type="EQName"/&gt;
</span>            &lt;xsd:element name="nillable" type="emptyContent" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementTest" type="elementTest"
               substitutionGroup="anyElementTest"/&gt;


  &lt;xsd:complexType name="documentTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
           &lt;xsd:element ref="anyElementTest" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="documentTest" type="documentTest"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:complexType name="piTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="piTarget" type="xsd:NCName" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="piTest" type="piTest" substitutionGroup="kindTest"/&gt;


<span>  &lt;xsd:element name="nameTest" type="EQName"/&gt;

</span>  &lt;xsd:element name="kindTest" substitutionGroup="itemType"/&gt;

  &lt;xsd:element name="textTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="commentTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

<span>  &lt;xsd:element name="namespaceTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

</span>  &lt;xsd:element name="anyKindTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;


<span>&lt;!-- functionTest variations --&gt;
&lt;!-- 2012-09-07: Jim added annotation support --&gt;
  &lt;xsd:complexType name="anyFunctionTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="anyFunctionTest" type="anyFunctionTest" substitutionGroup="itemType"/&gt;

&lt;!-- 2012-09-07: Jim added annotation support --&gt;
  &lt;xsd:complexType name="typedFunctionTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="paramTypeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedFunctionTest" type="typedFunctionTest" substitutionGroup="itemType"/&gt;


  &lt;xsd:complexType name="paramTypeList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="sequenceType" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="paramTypeList" type="paramTypeList"/&gt;


  &lt;xsd:complexType name="parenthesizedItemType"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="itemType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="parenthesizedItemType" type="parenthesizedItemType" substitutionGroup="itemType"/&gt;


</span>&lt;!-- XPath axes                                                                         --&gt;
  &lt;xsd:simpleType name="xpathAxis"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="child"/&gt;
      &lt;xsd:enumeration value="attribute"/&gt;
      &lt;xsd:enumeration value="self"/&gt;
      &lt;xsd:enumeration value="parent"/&gt;
      &lt;xsd:enumeration value="descendant-or-self"/&gt;
      &lt;xsd:enumeration value="descendant"/&gt;
      &lt;xsd:enumeration value="following"/&gt;
      &lt;xsd:enumeration value="following-sibling"/&gt;
      &lt;xsd:enumeration value="ancestor"/&gt;
      &lt;xsd:enumeration value="ancestor-or-self"/&gt;
      &lt;xsd:enumeration value="preceding"/&gt;
      &lt;xsd:enumeration value="preceding-sibling"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="xpathAxis" type="xpathAxis"/&gt;


&lt;!-- filter expressions                                                                 --&gt;
&lt;!-- added literalFunctionItemExpr, inlineFunctionItemExpr, and                         --&gt;
&lt;!--   dynamicFunctionInvocation for higher-order functions                             --&gt;
<span>&lt;!-- 2011-11-21: Jim changed "literalFunctionItemExpr" to "namedFunctionRef"            --&gt;
&lt;!-- 2011-11-21: Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"           --&gt;
</span>  &lt;xsd:group name="filterExpr"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="constantExpr"/&gt;
      &lt;xsd:element ref="varRef"/&gt;
      &lt;xsd:element ref="contextItemExpr"/&gt;
      &lt;xsd:element ref="functionCallExpr"/&gt;
      &lt;xsd:element ref="sequenceExpr"/&gt;
      &lt;xsd:element ref="elementConstructor"/&gt;
      &lt;xsd:element ref="computedElementConstructor"/&gt;
      &lt;xsd:element ref="computedAttributeConstructor"/&gt;
      &lt;xsd:element ref="computedDocumentConstructor"/&gt;
      &lt;xsd:element ref="computedTextConstructor"/&gt;
      &lt;xsd:element ref="computedCommentConstructor"/&gt;
      &lt;xsd:element ref="computedNamespaceConstructor"/&gt;
      &lt;xsd:element ref="computedPIConstructor"/&gt;
      &lt;xsd:element ref="orderedExpr"/&gt;
      &lt;xsd:element ref="unorderedExpr"/&gt;
<span>      &lt;xsd:element ref="namedFunctionRef"/&gt;
      &lt;xsd:element ref="inlineFunctionExpr"/&gt;
      &lt;xsd:element ref="dynamicFunctionInvocationExpr"/&gt;
</span>    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;


&lt;!-- step expression                                                                    --&gt;
&lt;!-- removed nameTest and Wildcard outer choices per Bugzilla Bug #2523                 --&gt;
&lt;!-- replaced element "predicates" with choice of "predicates" &amp; "dynamicfunctioninv'n" --&gt;
  &lt;xsd:complexType name="stepExpr"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="xpathAxis"/&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="kindTest"/&gt;
            &lt;xsd:element ref="nameTest"/&gt;
            &lt;xsd:element ref="Wildcard"/&gt;
          &lt;/xsd:choice&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:element name="filterExpr"&gt;
          &lt;xsd:complexType&gt;
            &lt;xsd:sequence&gt;
              &lt;xsd:group ref="filterExpr"/&gt;
            &lt;/xsd:sequence&gt;
          &lt;/xsd:complexType&gt;
        &lt;/xsd:element&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stepExpr" type="stepExpr"/&gt;


&lt;!-- path expression                                                                    --&gt;
&lt;!-- rewrote pathExpr definition per Bugzilla Bug #2523                                 --&gt;
  &lt;xsd:complexType name="pathExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="rootExpr" type="emptyContent"/&gt;
            &lt;xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element ref="stepExpr" maxOccurs="unbounded"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/&gt;


&lt;!-- The following constructs deal with the query prolog                                --&gt;
  &lt;xsd:complexType name="module"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="versionDecl" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element ref="mainModule"/&gt;
        &lt;xsd:element ref="libraryModule"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="module" type="module"/&gt;


  &lt;xsd:complexType name="mainModule"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
      &lt;xsd:element name="queryBody" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="mainModule" type="mainModule"/&gt;


  &lt;xsd:complexType name="libraryModule"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="moduleDecl"/&gt;
      &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="libraryModule" type="libraryModule"/&gt;


  &lt;xsd:complexType name="versionDecl"&gt;
<span>    &lt;xsd:choice&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="version" type="xsd:string"/&gt;
        &lt;xsd:element name="encoding" type="xsd:string" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:element name="encoding" type="xsd:string"/&gt;
    &lt;/xsd:choice&gt;
</span>  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="versionDecl" type="versionDecl"/&gt;


  &lt;xsd:complexType name="prolog"&gt;
    &lt;xsd:sequence&gt;
            &lt;xsd:element ref="prologPartOneItem" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xsd:element ref="prologPartTwoItem" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

  &lt;xsd:element name="prolog" type="prolog"/&gt;


  &lt;xsd:element name="prologPartOneItem" abstract="true"/&gt;


  &lt;xsd:element name="prologPartTwoItem" abstract="true"/&gt;


<span>  &lt;xsd:simpleType name="boundarySpaceDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="strip"/&gt;
      &lt;xsd:enumeration value="preserve"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="boundarySpaceDecl" type="boundarySpaceDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="defaultCollationDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="baseUriDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;


</span>  &lt;xsd:simpleType name="constructionDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="strip"/&gt;
      &lt;xsd:enumeration value="preserve"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="constructionDecl" type="constructionDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:simpleType name="orderingModeDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="ordered"/&gt;
      &lt;xsd:enumeration value="unordered"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="orderingModeDecl" type="orderingModeDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="emptyOrderingDecl" type="emptyOrderingMode"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="copyNamespacesDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="preserveMode"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
            &lt;xsd:enumeration value="preserve"/&gt;
            &lt;xsd:enumeration value="no-preserve"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="inheritMode"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
            &lt;xsd:enumeration value="inherit"/&gt;
            &lt;xsd:enumeration value="no-inherit"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="copyNamespacesDecl" type="copyNamespacesDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:simpleType name="defaultNamespaceCategory"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="function"/&gt;
      &lt;xsd:enumeration value="element"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="defaultNamespaceDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="defaultNamespaceCategory" type="defaultNamespaceCategory"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="defaultNamespaceDecl" type="defaultNamespaceDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="namespaceDeclType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namespaceDecl" type="namespaceDeclType"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="moduleDecl" type="namespaceDeclType"/&gt;


<span>  &lt;xsd:complexType name="decimalFormatDeclType"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="decimalFormatName" type="EQName" minOccurs="0"/&gt;
          &lt;xsd:element name="decimalFormatParam" minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="decimalFormatParamName"&gt;
                  &lt;xsd:simpleType&gt;
                    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
                      &lt;xsd:enumeration value="decimal-separator"/&gt;
                      &lt;xsd:enumeration value="grouping-separator"/&gt;
                      &lt;xsd:enumeration value="infinity"/&gt;
                      &lt;xsd:enumeration value="minus-sign"/&gt;
                      &lt;xsd:enumeration value="NaN"/&gt;
                      &lt;xsd:enumeration value="percent"/&gt;
                      &lt;xsd:enumeration value="per-mille"/&gt;
                      &lt;xsd:enumeration value="zero-digit"/&gt;
                      &lt;xsd:enumeration value="digit"/&gt;
                      &lt;xsd:enumeration value="pattern-separator"/&gt;
                    &lt;/xsd:restriction&gt;
                  &lt;/xsd:simpleType&gt;
                &lt;/xsd:element&gt;
                &lt;xsd:element name="decimalFormatParamValue" type="xsd:string"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalFormatDecl" type="decimalFormatDeclType"
               substitutionGroup="prologPartOneItem"/&gt;


</span>  &lt;xsd:complexType name="schemaImport"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice minOccurs="0"&gt;
        &lt;xsd:element name="namespacePrefix" type="xsd:NCName"/&gt;
        &lt;xsd:element name="defaultElementNamespace" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
      &lt;xsd:element name="targetLocation" type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="schemaImport" type="schemaImport"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="moduleImport"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="namespacePrefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
      &lt;xsd:element name="targetLocation" type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="moduleImport" type="moduleImport"
               substitutionGroup="prologPartOneItem"/&gt;


<span>  &lt;xsd:complexType name="contextItemDecl"&gt;
    &lt;xsd:sequence&gt;
</span><span>      &lt;xsd:element ref="contextItemType" minOccurs="0"/&gt;
</span><span>      &lt;xsd:choice&gt;
        &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="external"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="varValue" type="exprWrapper" minOccurs="0"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemDecl" type="contextItemDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


&lt;!-- For %-annotations                                                                  --&gt;
&lt;!-- 2013-03-17 - Added new support for a list of literals                              --&gt;
  &lt;xsd:complexType name="annotation"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="annotationName" type="EQName"/&gt;
      &lt;xsd:element name="arguments" type="literalList" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


</span>  &lt;xsd:complexType name="varDecl"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="annotation" type="annotation"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="external"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="varValue" type="exprWrapper" minOccurs="0"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:choice&gt;
</span>    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varDecl" type="varDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


  &lt;xsd:complexType name="optionDecl"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="optionName" type="EQName"/&gt;
</span>      &lt;xsd:element name="optionContents" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="optionDecl" type="optionDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


  &lt;xsd:complexType name="functionDecl"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="annotation" type="annotation"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="functionName" type="EQName"/&gt;
      &lt;xsd:element ref="paramList"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
        &lt;xsd:element name="externalDefinition" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
</span>  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionDecl" type="functionDecl"
               substitutionGroup="prologPartTwoItem"/&gt;

&lt;!-- there is a phrase with diff of chg after sequence and endphrase before typedeclaration --&gt;
  &lt;xsd:complexType name="param"&gt;
    &lt;xsd:sequence&gt;
<span>      &lt;xsd:element name="varName" type="EQName"/&gt;
</span>      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="param" type="param"/&gt;


  &lt;xsd:complexType name="paramList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="param" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="paramList" type="paramList"/&gt;


&lt;/xsd:schema&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="xqx_conformance" id="xqx_conformance"></a>5
Conformance</h2>
<p>This section defines the conformance criteria for an XQueryX
processor (see Figure 1, "Processing Model Overview", in
<span><a href="#xquery-30">[XQuery 3.0: An XML Query
Language]</a></span> , <a href=
"http://www.w3.org/TR/xquery-30/#id-processing-model">Section 2.2
Processing Model</a> <sup><small>XQ30</small></sup>.</p>
<p>In this section, the following terms are used to indicate the
requirement levels defined in <a href="#RFC2119">[RFC 2119]</a>.
[Definition: MUST means that the item is an absolute requirement of
the specification.] [Definition: SHOULD means that there may exist
valid reasons in particular circumstances to ignore a particular
item, but the full implications must be understood and carefully
weighed before choosing a different course.] [Definition: MAY means
that an item is truly optional.]</p>
<p>An XQueryX processor that claims to conform to this
specification MUST implement the XQueryX syntax as defined in
<a href="#Schema"><b>4 An XML Schema for the XQuery XML
Syntax</b></a> of this specification and include a claim of Minimal
Conformance as defined in <span><a href="#xquery-30">[XQuery 3.0:
An XML Query Language]</a></span> , <a href=
"http://www.w3.org/TR/xquery-30/#id-minimal-conformance">Section
5.1 Minimal Conformance</a> <sup><small>XQ30</small></sup>. In
addition to a claim of Minimal Conformance, it MAY claim
conformance to one or more optional features defined in
<span><a href="#xquery-30">[XQuery 3.0: An XML Query
Language]</a></span> , <a href=
"http://www.w3.org/TR/xquery-30/#id-conform-optional-features">Section
5.2 Optional Features</a> <sup><small>XQ30</small></sup>.</p>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="biblio" id="biblio"></a>A References</h2>
<dl>
<dt class="label"><span><a name="xqueryx" id="xqueryx"></a>XML
Syntax for XQuery 1.0 (XQueryX)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xqueryx/"><cite>XML Syntax for
XQuery 1.0 (XQueryX) (Second Edition)</cite></a>, Jim Melton and
Subramanian Muralidhar, Editors. World Wide Web Consortium, 14
December 2010. This version is
http://www.w3.org/TR/2010/REC-xqueryx-20101214/. The <a href=
"http://www.w3.org/TR/xqueryx/">latest version</a> is available at
http://www.w3.org/TR/xqueryx/.</div>
</dd>
<dt class="label"><span><a name="xquery-30-requirements" id=
"xquery-30-requirements"></a>XQuery 3.0 Requirements</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xquery-30-requirements/"><cite>XQuery 3.0
Requirements</cite></a>, Daniel Engovatov, Jonathan Robie, Editors.
World Wide Web Consortium, 08 April 2014. This version is
http://www.w3.org/TR/2014/NOTE-xquery-30-requirements-20140408/.
The <a href="http://www.w3.org/TR/xquery-30-requirements/">latest
version</a> is available at
http://www.w3.org/TR/xquery-30-requirements/.</div>
</dd>
<dt class="label"><span><a name="xquery-30" id=
"xquery-30"></a>XQuery 3.0: An XML Query Language</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-30/"><cite>XQuery 3.0: An
XML Query Language</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xquery-30-20140408/. The <a href=
"http://www.w3.org/TR/xquery-30/">latest version</a> is available
at http://www.w3.org/TR/xquery-30/.</div>
</dd>
<dt class="label"><span><a name="xquery-30-use-cases" id=
"xquery-30-use-cases"></a>XQuery 3.0 Use Cases</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xquery-30-use-cases/"><cite>XQuery 3.0 Use
Cases</cite></a>, Tim Kraska, Editor. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/NOTE-xquery-30-use-cases-20140408/. The
<a href="http://www.w3.org/TR/xquery-30-use-cases/">latest
version</a> is available at
http://www.w3.org/TR/xquery-30-use-cases/.</div>
</dd>
<dt class="label"><span><a name="xquery-semantics" id=
"xquery-semantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-semantics/"><cite>XQuery
1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>,
Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>,
Editors. World Wide Web Consortium, 14 December 2010. This version
is http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. The
<a href="http://www.w3.org/TR/xquery-semantics/">latest version</a>
is available at http://www.w3.org/TR/xquery-semantics/.</div>
</dd>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3023" id="RFC3023"></a>RFC
3023</span></dt>
<dd>
<div>M. Murata, S. St. Laurent, and D. Kohn. <em>XML Media
Types</em> IETF RFC 3023 or its successors. See <a href=
"http://www.ietf.org/rfc/rfc3023.txt">http://www.ietf.org/rfc/rfc3023.txt</a>.</div>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="Stylesheet" id="Stylesheet"></a>B Transforming XQueryX
to XQuery</h2>
<p>The following stylesheet converts from XQueryX syntax to XML
Query syntax. Note the intent of the stylesheet is to produce
<em>a</em> valid XQuery with the same semantics (see <a href=
"#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>) as the input XQueryX.</p>
<div class="exampleInner">
<pre>
<span>&lt;!--  ================================================================================  --&gt;
&lt;!--  Changes from Recommendation (edition 1):                                          --&gt;
&lt;!--  * In XSLT stylesheet, deleted template for xqx:parenthesizedExpr (bug #4963)      --&gt;
&lt;!--  * In XSLT stylesheet, corrected template for xqx:namespaceDeclaration (bug #5343) --&gt;
&lt;!--  Changes from Recommendation (edition 2):                                          --&gt;
&lt;!--  * Added support for new Windowing clause in FLWOR expression                      --&gt;
&lt;!--  * Added support for new Group By Clause in FLWOR expression                       --&gt;
&lt;!--  * Added support for new Count Clause in FLWOR expression                          --&gt;
&lt;!--  * Added support for keyword "outer" on for expression                             --&gt;
&lt;!--  * Modified structure of FLWOR clause per "simplified FLWOR expressions"           --&gt;
&lt;!--  * Modified validation syntax per Bugzilla Bug 5472                                --&gt;
&lt;!--  * Modified function declaration so that external functions can be nondeterminstic --&gt;
&lt;!--  * Modified variable declaration so external variables can have an initial value   --&gt;
&lt;!--  * Added support for new try-catch expression                                      --&gt;
&lt;!--  * Made changes triggered by Bugzilla Bugs 6309, 6310, and 6311                    --&gt;
&lt;!--  * Modified errlist syntax per Bugzilla Bug 7053                                   --&gt;
&lt;!--  * Added support for public/private functions                                      --&gt;
&lt;!--  * Replaced "outer for" support with support for "allowing empty"                  --&gt;
&lt;!--  * Added support for higher-order functions                                        --&gt;
&lt;!--  * Added support for value-based "switch" expression                               --&gt;
&lt;!--  * Changed functionItemExpr child element QName to be functionName for consistency --&gt;
&lt;!--  * Added simpleMapExpr and removed mapStepExpr (see bug 16197)                     --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--    XQX.E3  - Editorial (Bugzilla Bug 4963)                                         --&gt;
&lt;!--    XQX.E5  - Editorial (Bugzilla Bug 5343)                                         --&gt;
&lt;!--    XQX.E9  - Minor technical (Bugzilla Bug 6733)                                   --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Modifications:                                                                    --&gt;
&lt;!--    2008-07-30 - Add XQuery 1.1 grouping and windowing support                      --&gt;
&lt;!--    2008-09-18 - Add XQuery 1.1 count and outer-for support, simplified FLWOR       --&gt;
&lt;!--    2008-09-27 - Add validation type, nondeterministic function declarations,       --&gt;
&lt;!--                 initial values for external variables, try-catch expressions       --&gt;
&lt;!--    2008-11-14 - Add decimal formatting decl, encoding for version decl,            --&gt;
&lt;!--                 context item decl, computed namespace constructor                  --&gt;
&lt;!--    2008-11-25 - Add support for fixes for validate expression, and change to allow --&gt;
&lt;!--                 the count clause to only be an intermediate expression             --&gt;
&lt;!--    2009-01-13 - Bugs 6309 and 6310 (fixes to details of certain windowing clauses  --&gt;
&lt;!--    2009-03-03 - tumblingWindowClause syntax now matches slidingWindowClause syntax --&gt;
&lt;!--    2009-09-06 - Modified errlist syntax per Bugzilla Bug 7053                      --&gt;
&lt;!--    2009-10-09 - Added support for private/public functions                         --&gt;
&lt;!--                 Replace "outer for" with "allowing empty"                          --&gt;
&lt;!--    2009-10-22 - Add support for higher-order functions &amp; switch expression         --&gt;
&lt;!--    2010-01-06 - Omit parens when following-sibling of rootExpr is stepExpr         --&gt;
&lt;!--    2010-04-06 - Changed functionItemExpr child QName -&gt; functionName (consistency) --&gt;
&lt;!--    2010-06-23 - Added support for partial function application                     --&gt;
&lt;!--    2011-05-04 - Updated structure of catch component of try-catch expression       --&gt;
&lt;!--    2011-05-04 - Updated validationexpr, mode/type alternatives, type is EQName     --&gt;
&lt;!--    2011-05-31 - Fixed functionItemExpr and functionCallExpr re: unqualified names  --&gt;
&lt;!--    2011-07-08 - Added support for concatenation operator ||                        --&gt;
&lt;!--    2011-09-09 - Added support for simple mapping operator !                        --&gt;
&lt;!--    2011-09-09 - Added support for sequenceTypeUnion in typeswitch                  --&gt;
&lt;!--    2011-09-09 - Added support for annotations on inline functions                  --&gt;
&lt;!--    2011-09-14 - Added support for new group-by syntax                              --&gt;
&lt;!--    2011-11-21 - Jim changed "literalFunctionItemExpr" to "namedFunctionRef"        --&gt;
&lt;!--    2011-11-21 - Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"       --&gt;
&lt;!--    2012-02-24 - Jim updated EQname template to generate revised XQuery syntax      --&gt;
&lt;!--    2012-06-15 - Added simpleMapExpr and removed mapStepExpr (see bug 16197)        --&gt;
&lt;!--    2012-06-22 - Generate parentheses surrounding try-catch expressions (bug 17549) --&gt;
&lt;!--    2012-09-07 - Added %-annotation support for function tests                      --&gt;
&lt;!--    2012-09-25 - If encoding is specified in versionDecl, the generated XQ uses it  --&gt;
&lt;!--    2013-09-27 - Modified schema definition of simpleMapExpr for multiple arguments --&gt;
&lt;!--  ================================================================================  --&gt;
</span>&lt;xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Note that this stylesheet frequently invokes templates for
     specified elements, even when there are no templates in the
     stylesheet whose match="" attribute identifies those elements.
     In such case, the default template's element matching template
     is invoked, which merely invokes xsl:apply-templates --&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:preserve-space elements="xqx:value xqx:attributeValue xqx:pragmaContents
                                xqx:optionContents xqx:xquery"/&gt;

  &lt;xsl:variable name="DOT" select="'.'"/&gt;
  &lt;xsl:variable name="SPACE" select="' '"/&gt;
  &lt;xsl:variable name="SLASH" select="'/'"/&gt;
  &lt;xsl:variable name="SLASH_SLASH" select="'//'"/&gt;
  &lt;xsl:variable name="LESSTHAN" select="'&amp;lt;'"/&gt;
  &lt;xsl:variable name="GREATERTHAN" select="'&amp;gt;'"/&gt;
  &lt;xsl:variable name="LPAREN" select="'('"/&gt;
  &lt;xsl:variable name="RPAREN" select="')'"/&gt;
  &lt;xsl:variable name="NEWLINE"&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="COMMA" select="','"/&gt;
  &lt;xsl:variable name="COMMA_SPACE" select="', '"/&gt;
  &lt;xsl:variable name="COMMA_NEWLINE"&gt;&lt;xsl:text&gt;,
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="QUOTE"&gt;&lt;xsl:text&gt;'&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="DOUBLEQUOTE"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="TO" select="' to '"/&gt;
  &lt;xsl:variable name="LBRACE" select="'{'"/&gt;
  &lt;xsl:variable name="RBRACE" select="'}'"/&gt;
  &lt;xsl:variable name="LBRACKET" select="'['"/&gt;
  &lt;xsl:variable name="RBRACKET" select="']'"/&gt;
  &lt;xsl:variable name="DOLLAR" select="'$'"/&gt;
  &lt;xsl:variable name="MINUS" select="'-'"/&gt;
  &lt;xsl:variable name="PLUS" select="'+'"/&gt;
  &lt;xsl:variable name="EQUAL" select="'='"/&gt;
  &lt;xsl:variable name="COLON" select="':'"/&gt;
  &lt;xsl:variable name="DOUBLE_COLON" select="'::'"/&gt;
  &lt;xsl:variable name="SEMICOLON" select="';'"/&gt;
  &lt;xsl:variable name="AT" select="'@'"/&gt;
  &lt;xsl:variable name="STAR" select="'*'"/&gt;
  &lt;xsl:variable name="QUESTIONMARK" select="'?'"/&gt;
<span>  &lt;xsl:variable name="EXCLAMATIONMARK" select="'!'"/&gt;
  &lt;xsl:variable name="PERCENT" select="'%'"/&gt;
</span>  &lt;xsl:variable name="ASSIGN" select="':='"/&gt;
  &lt;xsl:variable name="SEPARATOR" select="';'"/&gt;
  &lt;xsl:variable name="PRAGMA_BEGIN" select="'(# '"/&gt;
  &lt;xsl:variable name="PRAGMA_END" select="' #)'"/&gt;
<span>  &lt;xsl:variable name="CONCATENATE" select="'||'"/&gt;


</span>  &lt;xsl:template name="delimitedList"&gt;
    &lt;xsl:param name="delimiter" /&gt;
    &lt;xsl:param name="leftEncloser"/&gt;
    &lt;xsl:param name="rightEncloser" /&gt;
    &lt;xsl:param name="selector"/&gt;

    &lt;xsl:value-of select="$leftEncloser"/&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not (position()=last())"&gt;        
        &lt;xsl:value-of select="$delimiter"/&gt;
      &lt;/xsl:if&gt;       
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$rightEncloser"/&gt;
  &lt;/xsl:template&gt;   


  &lt;xsl:template name="parenthesizedList"&gt;
    &lt;xsl:param name="delimiter" select="$COMMA_SPACE"/&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter" select="$delimiter" /&gt;
      &lt;xsl:with-param name="leftEncloser" select="$LPAREN"/&gt;
      &lt;xsl:with-param name="rightEncloser" select="$RPAREN"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="commaSeparatedList"&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter"&gt;
        &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;!-- To resolve Bugzilla bug #3446, we now escape CR (#xD), NEL (#x85),
       and LINE SEPARATOR (#x2028) characters in text nodes and attribute values.
         Note that this template is invoked for a number of other purposes (e.g.,
       xqx:collation, xqx:namespaceDeclaration) where the presence of such
       characters would be invalid and thus are highly unlikely to appear. 
       If they do, then this template will happily escape them, deferring the
       error until the resulting XQuery expression is processed. --&gt;
  &lt;xsl:template name="quote"&gt;
    &lt;xsl:param name="item"/&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
    &lt;xsl:call-template name="globalReplace"&gt;
      &lt;xsl:with-param name="stringToBeFixed"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="globalReplace"&gt;
                  &lt;xsl:with-param name="stringToBeFixed"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="$item"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&amp;amp;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&amp;amp;amp;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&amp;lt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&amp;amp;lt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                  &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x85;'"/&gt;
                  &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x85;&lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xD;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xD;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x2028;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x2028;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;""&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="globalReplace"&gt;
    &lt;xsl:param name="stringToBeFixed"/&gt;
    &lt;xsl:param name="toBeReplaced"/&gt;
    &lt;xsl:param name="replacement"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="contains($stringToBeFixed, $toBeReplaced)"&gt;
        &lt;xsl:value-of select="concat(substring-before($stringToBeFixed, $toBeReplaced), $replacement)"/&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed" select="substring-after($stringToBeFixed, $toBeReplaced)"/&gt;
          &lt;xsl:with-param name="toBeReplaced" select="$toBeReplaced"/&gt;
          &lt;xsl:with-param name="replacement" select="$replacement"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$stringToBeFixed"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template name="renderQName"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

</span>
<span>&lt;!-- 2012-02-24 - Changed output generated when URI is given instead of prefix --&gt;
  &lt;xsl:template name="renderEQName"
                match="xqx:QName | xqx:pragmaName | xqx:typeName | xqx:varName |
                       xqx:functionName | xqx:optionName | xqx:annotationName |
                       xqx:atomicType | xqx:tagName | xqx:name | xqx:decimalFormatName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:tagName/parent::xqx:elementConstructor"&gt;
        &lt;xsl:call-template name="renderQName"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="@xqx:prefix and @xqx:URI"&gt;
            &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Elements of type xqx:EQName must not have both 'prefix' and 'URI' attributes&lt;/xsl:message&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@xqx:prefix"&gt;
            &lt;xsl:value-of select="@xqx:prefix"/&gt;
            &lt;xsl:value-of select="$COLON"/&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@xqx:URI"&gt;
            &lt;xsl:text&gt;Q&lt;/xsl:text&gt;
            &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:value-of select="@xqx:URI"/&gt;
            &lt;xsl:value-of select="$RBRACE"/&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:attributeName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@xqx:prefix='xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to have prefix 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
<span>      &lt;xsl:when test=". = 'xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to be 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:call-template name="renderQName"/&gt;
      &lt;/xsl:otherwise&gt;
</span>    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:NCName"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rootExpr"&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
  &lt;/xsl:template&gt;


<span>&lt;!-- 2010-06-23 - Added support for partial function application                        --&gt;
  &lt;xsl:template match="xqx:argumentPlaceholder"&gt;
    &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- To resolve Bugzilla bug #6733, we now treat a
       rootExpr child of pathExpr distinctly from a
       rootExpr that occurs in other contexts,
       transforming it to "(/)" as proper
       XQuery grammar.  There is an additional consideration
       on this: If the immediately following sibling of
       rootExpr is a stepExpr, then the parens must be
       omitted. --&gt;
  &lt;xsl:template match="xqx:pathExpr/xqx:rootExpr"&gt;
    &lt;xsl:if test="not(following-sibling::xqx:stepExpr)"&gt;
      &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:if test="not(following-sibling::xqx:stepExpr)"&gt;
      &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:contextItemExpr"&gt;
    &lt;xsl:value-of select="$DOT"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stringConstantExpr"&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:value"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:integerConstantExpr |
                       xqx:decimalConstantExpr |
                       xqx:doubleConstantExpr"&gt;
    &lt;xsl:value-of select="xqx:value"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varRef"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
<span>    &lt;xsl:apply-templates select="xqx:name"/&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:pragma"&gt;
    &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
    &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
    &lt;xsl:value-of select="$PRAGMA_END"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:extensionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:pragma"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


<span>&lt;!-- 2012-06-15 - Jim added simpleMapExpr --&gt;
&lt;!-- 2013-09-27 - Jim modified definition of simpleMapExpr --&gt;
  &lt;xsl:template match="xqx:simpleMapExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:pathExpr[1]"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:for-each select="xqx:pathExpr[position() != 1]"&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
      &lt;xsl:value-of select="$EXCLAMATIONMARK"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$LPAREN"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
</span>


&lt;!-- Response to Bugzilla bug #2528 --&gt;
&lt;!-- Response to Bugzilla bug #12788 --&gt;
  &lt;xsl:template match="xqx:functionCallExpr"&gt;
<span>    &lt;xsl:if test="(xqx:functionName = 'node' or
                   xqx:functionName = 'document-node' or
                   xqx:functionName = 'element' or
                   xqx:functionName = 'attribute' or
                   xqx:functionName = 'schema-element' or
                   xqx:functionName = 'schema-attribute' or
                   xqx:functionName = 'processing-instruction' or
                   xqx:functionName = 'comment' or
                   xqx:functionName = 'text' or
                   xqx:functionName = 'function' or
                   xqx:functionName = 'namespace-node' or
                   xqx:functionName = 'item' or
                   xqx:functionName = 'if' or
                   xqx:functionName = 'switch' or
                   xqx:functionName = 'typeswitch' or
                   xqx:functionName = 'empty-sequence') and
                   ((not(xqx:functionName/@xqx:prefix) and not(xqx:functionName/@xqx:URI)) or
                    xqx:functionName/@xqx:prefix = '' or
                    xqx:functionName/@xqx:URI = '')"&gt;
      &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
      &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
</span>    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:arguments"&gt;
        &lt;xsl:for-each select="xqx:arguments"&gt;
          &lt;xsl:call-template name="parenthesizedList"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LPAREN"/&gt;
        &lt;xsl:value-of select="$RPAREN"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:constructorFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;xsl:for-each select="xqx:argExpr"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unaryMinusOp | xqx:unaryPlusOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unaryPlusOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:unaryMinusOp"&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:operand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:addOp | xqx:subtractOp | xqx:multiplyOp
                     | xqx:divOp | xqx:idivOp | xqx:modOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:addOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:subtractOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:multiplyOp"&gt;&lt;xsl:value-of select="$STAR"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:divOp"&gt;&lt;xsl:text&gt; div &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:idivOp"&gt;&lt;xsl:text&gt; idiv &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:modOp"&gt;&lt;xsl:text&gt; mod &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:stringConcatenateOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:value-of select="$CONCATENATE"/&gt;
     &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:eqOp | xqx:neOp | xqx:ltOp
                     | xqx:gtOp | xqx:leOp | xqx:geOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:eqOp"&gt;&lt;xsl:text&gt; eq &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:neOp"&gt;&lt;xsl:text&gt; ne &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:ltOp"&gt;&lt;xsl:text&gt; lt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:gtOp"&gt;&lt;xsl:text&gt; gt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:leOp"&gt;&lt;xsl:text&gt; le &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:geOp"&gt;&lt;xsl:text&gt; ge &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:equalOp | xqx:notEqualOp | xqx:lessThanOp
                     | xqx:greaterThanOp | xqx:lessThanOrEqualOp | xqx:greaterThanOrEqualOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:equalOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:notEqualOp"&gt;
         &lt;xsl:text&gt; !&lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:isOp | xqx:nodeBeforeOp | xqx:nodeAfterOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:isOp"&gt;&lt;xsl:text&gt; is &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeBeforeOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeAfterOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:andOp | xqx:orOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:andOp"&gt;&lt;xsl:text&gt; and &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:orOp"&gt;&lt;xsl:text&gt; or &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unionOp | xqx:intersectOp | xqx:exceptOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unionOp"&gt;&lt;xsl:text&gt; union &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:intersectOp"&gt;&lt;xsl:text&gt; intersect &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:exceptOp"&gt;&lt;xsl:text&gt; except &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceExpr"&gt;
    &lt;xsl:for-each select="."&gt;
      &lt;xsl:call-template name="parenthesizedList"&gt;
        &lt;xsl:with-param name="delimiter" select="$COMMA_NEWLINE"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rangeSequenceExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:startExpr"/&gt;
    &lt;xsl:value-of select="$TO"/&gt;
    &lt;xsl:apply-templates select="xqx:endExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:forClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:forClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

<span>  &lt;xsl:template match="xqx:allowingEmpty"&gt;
    &lt;xsl:text&gt; allowing empty &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;

</span>  &lt;xsl:template match="xqx:forExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;    in &lt;/xsl:text&gt;
        &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:letClause"&gt;
    &lt;xsl:text&gt; let &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letExpr"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:windowClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:tumblingWindowClause"&gt;
    &lt;xsl:text&gt;   tumbling window &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:bindingSequence"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowStartCondition"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowEndCondition"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:slidingWindowClause"&gt;
    &lt;xsl:text&gt;   sliding window &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:bindingSequence"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowStartCondition"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowEndCondition"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:bindingSequence"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowStartCondition"&gt;
    &lt;xsl:text&gt;start &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowVars"/&gt;
    &lt;xsl:text&gt; when &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:winStartExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowEndCondition"&gt;
    &lt;xsl:if test="@xqx:onlyEnd='true'"&gt;
      &lt;xsl:text&gt;only &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;end &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowVars"/&gt;
    &lt;xsl:text&gt; when &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:winEndExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowVars"&gt;
    &lt;xsl:apply-templates select="xqx:currentItem"/&gt;
    &lt;xsl:apply-templates select="xqx:positionalVariableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:previousItem"/&gt;
    &lt;xsl:apply-templates select="xqx:nextItem"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:currentItem"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:previousItem"&gt;
    &lt;xsl:text&gt; previous &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:nextItem"&gt;
    &lt;xsl:text&gt; next &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:countClause"&gt;
    &lt;xsl:text&gt; count &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:whereClause"&gt;
    &lt;xsl:text&gt; where &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:groupByClause"&gt;
    &lt;xsl:text&gt;  group by &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:groupingSpec"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2011-09-14/JM - added the ability to initialize a grouping variable, opt set type  --&gt;
  &lt;xsl:template match="xqx:groupVarInitialize"&gt;
    &lt;xsl:if test="xqx:typeDeclaration"&gt;
      &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:varValue"/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:collation"&gt;
    &lt;xsl:text&gt; collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingMode"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingKind"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderModifier"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderBySpec"&gt;
    &lt;xsl:apply-templates select="xqx:orderByExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:orderModifier"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderByClause"&gt;
    &lt;xsl:if test="xqx:stable"&gt;
      &lt;xsl:text&gt; stable&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt; order by &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:orderBySpec[1]"/&gt;
    &lt;xsl:for-each select="xqx:orderBySpec[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:returnClause"&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Surrounding FLWOR expressions with parentheses completes the set --&gt;
  &lt;xsl:template match="xqx:flworExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:ifThenElseExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; if &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:ifClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:text&gt; then &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:thenClause"/&gt;
    &lt;xsl:text&gt; else &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:elseClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:positionalVariableBinding"&gt;
    &lt;xsl:text&gt; at &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
<span>    &lt;xsl:call-template name="renderEQName"/&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:variableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
<span>    &lt;xsl:call-template name="renderEQName"/&gt;
</span>    &lt;xsl:if test="parent::xqx:typeswitchExprCaseClause"&gt;
      &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typedVariableBinding" name="typedVariableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExprInClause"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sourceExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="xqx:quantifier"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:quantifiedExprInClause[1]"/&gt;
    &lt;xsl:for-each select="xqx:quantifiedExprInClause[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:text&gt; satisfies &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:predicateExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:instanceOfExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; instance of &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; cast as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castableExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; castable as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:treatExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; treat as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:switchExprCaseClause"&gt;
    &lt;xsl:for-each select="xqx:switchCaseExpr"&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
      &lt;xsl:text&gt;   case (&lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:text&gt;) &lt;/xsl:text&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;     return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:switchExprDefaultClause"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;   default return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:switchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;switch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:switchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:switchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


</span>&lt;!-- 2011-09-09/JM - augmented sequenceType with sequenceTypeUnion                      --&gt;
  &lt;xsl:template match="xqx:typeswitchExprCaseClause"&gt;
    &lt;xsl:text&gt; case &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
<span>    &lt;xsl:apply-templates select="xqx:sequenceType | xqx:sequenceTypeUnion"/&gt;
</span>    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprDefaultClause"&gt;
    &lt;xsl:text&gt; default &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;typeswitch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:tryCatchExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;try &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tryClause"/&gt;
    &lt;xsl:apply-templates select="xqx:catchClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tryClause"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchClause"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;  catch &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:catchErrorList"/&gt;
    &lt;xsl:apply-templates select="xqx:catchExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchErrorList"&gt;
    &lt;xsl:for-each select="xqx:nameTest | xqx:Wildcard"&gt;
      &lt;xsl:if test="(position() mod 5) = 0"&gt;
        &lt;xsl:value-of select="$NEWLINE"/&gt;
        &lt;xsl:text&gt;      &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position() &gt; 1"&gt;
        &lt;xsl:text&gt;| &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:validateExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; validate &lt;/xsl:text&gt;
<span>    &lt;xsl:if test="xqx:validationMode"&gt;
      &lt;xsl:value-of select="xqx:validationMode"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:text&gt;type &lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
</span>    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:xpathAxis"&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$DOUBLE_COLON"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:predicates"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:value-of select="$LBRACKET"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$RBRACKET"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


<span>  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:dynamicFunctionInvocationExpr"&gt;
    &lt;xsl:apply-templates select="xqx:functionItem"/&gt;
    &lt;xsl:apply-templates select="xqx:predicates"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:arguments"&gt;
        &lt;xsl:for-each select="xqx:arguments"&gt;
          &lt;xsl:call-template name="parenthesizedList"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LPAREN"/&gt;
        &lt;xsl:value-of select="$RPAREN"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:functionItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:star"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[*]"&gt;
<span>    &lt;xsl:choose&gt;
      &lt;xsl:when test="local-name(./child::*[1])='star'"&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:apply-templates select="xqx:NCName"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="local-name(./child::*[1])='NCName'"&gt;
        &lt;xsl:apply-templates select="xqx:NCName"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="local-name(./child::*[1])='uri'"&gt;
        &lt;xsl:text&gt;Q&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
        &lt;xsl:value-of select="./xqx:uri"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[not(*)]"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- select="xqx:EQname" fixed to be select="xqx"QName"; bug 12674 --&gt;
  &lt;xsl:template name="simpleWildcard" match="xqx:simpleWildcard"&gt;
    &lt;xsl:apply-templates select="xqx:star"/&gt;
    &lt;xsl:apply-templates select="xqx:QName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:textTest"&gt;
    &lt;xsl:text&gt;text()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:commentTest"&gt;
    &lt;xsl:text&gt;comment()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:namespaceTest"&gt;
    &lt;xsl:text&gt;namespace-node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:anyKindTest"&gt;
    &lt;xsl:text&gt;node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTest"&gt;
    &lt;xsl:text&gt;processing-instruction&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:documentTest"&gt;
    &lt;xsl:text&gt;document-node&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;

&lt;!-- // THIS IS WRONG!! A nameText is a QName *OR* a Wildcard!!! --&gt;
  &lt;xsl:template match="xqx:nameTest"&gt;
<span>    &lt;xsl:call-template name="renderEQName"/&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeTest"&gt;
    &lt;xsl:text&gt;attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:attributeName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementTest"&gt;
    &lt;xsl:text&gt;element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:elementName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:nillable"&gt;
      &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaElementTest"&gt;
    &lt;xsl:text&gt;schema-element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
<span>    &lt;xsl:call-template name="renderEQName"/&gt;
</span>    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaAttributeTest"&gt;
    &lt;xsl:text&gt;schema-attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
<span>    &lt;xsl:call-template name="renderEQName"/&gt;
</span>    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;!-- anyFunctionTest, part of higher-order functions --&gt;
  &lt;!-- 2012-09-07: Jim added annotation support --&gt;
  &lt;xsl:template match="xqx:anyFunctionTest"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function(*)&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;!-- typedFunctionTest, part of higher-order functions --&gt;
  &lt;!-- 2012-09-07: Jim added annotation support --&gt;
  &lt;xsl:template match="xqx:typedFunctionTest"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:paramTypeList"/&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramTypeList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- parenthesizedItemType, part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:parenthesizedItemType"&gt;
    &lt;xsl:text&gt; ( &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:text&gt; ) &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


</span>  &lt;!-- rewrote test expression per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:stepExpr"&gt;
<span>    &lt;xsl:if test="preceding-sibling::xqx:stepExpr"&gt;
</span>      &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- deleted xqx:parenthesizedExpr per Bugzilla Bug #4963 --&gt;
  &lt;xsl:template match="xqx:filterExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;!-- part of higher-order functions --&gt;
  &lt;!-- Response to Bugzilla bug #12788 --&gt;
  &lt;!-- 2011-11-21 - Jim changed "literalFunctionItemExpr" to "namedFunctionRef"        --&gt;
  &lt;xsl:template match="xqx:namedFunctionRef"&gt;
    &lt;xsl:if test="(xqx:functionName = 'node' or
                   xqx:functionName = 'document-node' or
                   xqx:functionName = 'element' or
                   xqx:functionName = 'attribute' or
                   xqx:functionName = 'schema-element' or
                   xqx:functionName = 'schema-attribute' or
                   xqx:functionName = 'processing-instruction' or
                   xqx:functionName = 'comment' or
                   xqx:functionName = 'text' or
                   xqx:functionName = 'function' or
                   xqx:functionName = 'namespace-node' or
                   xqx:functionName = 'item' or
                   xqx:functionName = 'if' or
                   xqx:functionName = 'switch' or
                   xqx:functionName = 'typeswitch' or
                   xqx:functionName = 'empty-sequence') and
                   ((not(@xqx:prefix) and not(@xqx:URI)) or
                    (@xqx:prefix and @xqx:prefix = '') or
                    (@xqx:URI and @xqx:URI = ''))"&gt;
      &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
      &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:text&gt;#&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:integerConstantExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- part of higher-order functions --&gt;
  &lt;!-- 2011-09-09/JM - Added annotations to inline functions                              --&gt;
  &lt;!-- 2011-11-21 - Jim changed "inlineFunctionItemExpr" to "inlineFunctionExpr"          --&gt;
  &lt;xsl:template match="xqx:inlineFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
  &lt;/xsl:template&gt;

</span>  &lt;!-- rewrote pathExpr template per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:pathExpr"&gt;
    &lt;xsl:apply-templates select="xqx:rootExpr | xqx:stepExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- To resolve Bugzilla bug #3446, we now escape NL (#xA) and TAB (#x9)
       characters in attribute values --&gt;
  &lt;xsl:template match="xqx:attributeConstructor"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeName"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:attributeValue"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="quote"&gt;
                  &lt;xsl:with-param name="item"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="xqx:attributeValue"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;{{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;}}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xA;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xA;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x9;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x9;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
        &lt;xsl:for-each select="./xqx:attributeValueExpr/xqx:*"&gt;
          &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;!-- replaced xqx:namespaceDeclaration per Bugzilla Bug #5343 --&gt;
  &lt;xsl:template match="xqx:namespaceDeclaration"&gt;
    &lt;xsl:text&gt; xmlns&lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:prefix"&gt;
      &lt;xsl:text&gt;:&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
       &lt;xsl:with-param name="item"&gt;
         &lt;xsl:call-template name="globalReplace"&gt;
           &lt;xsl:with-param name="stringToBeFixed"&gt;
             &lt;xsl:call-template name="globalReplace"&gt;
               &lt;xsl:with-param name="stringToBeFixed"&gt;
                 &lt;xsl:value-of select="xqx:uri"/&gt;
               &lt;/xsl:with-param&gt;
               &lt;xsl:with-param name="toBeReplaced"&gt;
                 &lt;xsl:text&gt;{&lt;/xsl:text&gt;
               &lt;/xsl:with-param&gt;
               &lt;xsl:with-param name="replacement"&gt;
                 &lt;xsl:text&gt;{{&lt;/xsl:text&gt;
               &lt;/xsl:with-param&gt;
             &lt;/xsl:call-template&gt;
           &lt;/xsl:with-param&gt;
           &lt;xsl:with-param name="toBeReplaced"&gt;
             &lt;xsl:text&gt;}&lt;/xsl:text&gt;
           &lt;/xsl:with-param&gt;
           &lt;xsl:with-param name="replacement"&gt;
             &lt;xsl:text&gt;}}&lt;/xsl:text&gt;
           &lt;/xsl:with-param&gt;
         &lt;/xsl:call-template&gt;
       &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeList"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementContent"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
        &lt;xsl:value-of select="$SPACE"/&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
        &lt;xsl:value-of select="$SPACE"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementConstructor"&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeList"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:elementContent"/&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tagNameExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedElementConstructor"&gt;
    &lt;xsl:text&gt; element &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:contentExpr"/&gt;     
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:contentExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

</span>  &lt;xsl:template match="xqx:computedAttributeConstructor"&gt;
    &lt;xsl:text&gt; attribute &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:valueExpr"/&gt;     
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedDocumentConstructor"&gt;
    &lt;xsl:text&gt; document {&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; }&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedTextConstructor"&gt;
    &lt;xsl:text&gt; text&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedCommentConstructor"&gt;
    &lt;xsl:text&gt; comment&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:computedNamespaceConstructor"&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:prefix"&gt;
        &lt;xsl:value-of select="xqx:prefix"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
        &lt;xsl:apply-templates select="xqx:prefixExpr"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:URIExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:piTargetExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Move value braces into computedPIConstructor template from this template, Bugzilla bug #3442 --&gt;
  &lt;xsl:template match="xqx:piValueExpr"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Move value braces into this template from piValueExpr template, Bugzilla bug #3442 --&gt;
  &lt;xsl:template match="xqx:computedPIConstructor"&gt;
    &lt;xsl:text&gt; processing-instruction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:piTarget"/&gt;
    &lt;xsl:apply-templates select="xqx:piTargetExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:piValueExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unorderedExpr"&gt;
    &lt;xsl:text&gt; unordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderedExpr"&gt;
    &lt;xsl:text&gt; ordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:versionDecl"&gt;
    &lt;xsl:text&gt;xquery &lt;/xsl:text&gt;
<span>    &lt;xsl:if test="xqx:version"&gt;
      &lt;xsl:text&gt;version &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:version"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:encoding and xqx:version"&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:encoding"&gt;
      &lt;xsl:text&gt;encoding &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:encoding"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
</span>    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDecl"&gt;
    &lt;xsl:text&gt;declare namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultNamespaceDecl"&gt;
    &lt;xsl:text&gt;declare default &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:defaultNamespaceCategory"/&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:boundarySpaceDecl"&gt;
    &lt;xsl:text&gt;declare boundary-space &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:defaultCollationDecl"&gt;
    &lt;xsl:text&gt;declare default collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:baseUriDecl"&gt;
    &lt;xsl:text&gt;declare base-uri &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:constructionDecl"&gt;
    &lt;xsl:text&gt;declare construction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingModeDecl"&gt;
    &lt;xsl:text&gt;declare ordering &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingDecl"&gt;
    &lt;xsl:text&gt;declare default order &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:copyNamespacesDecl"&gt;
    &lt;xsl:text&gt;declare copy-namespaces &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:preserveMode"/&gt;
    &lt;xsl:value-of select="$COMMA"/&gt;
    &lt;xsl:value-of select="xqx:inheritMode"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:optionDecl"&gt;
    &lt;xsl:text&gt;declare option &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:optionName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:optionContents"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


<span>  &lt;xsl:template match="xqx:decimalFormatDecl"&gt;
    &lt;xsl:text&gt;declare &lt;/xsl:text&gt;
    &lt;xsl:if test="not(xqx:decimalFormatName)"&gt;
      &lt;xsl:text&gt;default &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;decimal-format &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:decimalFormatName"&gt;
      &lt;xsl:apply-templates select="xqx:decimalFormatName"/&gt;
      &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:decimalFormatParam"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:decimalFormatParam"&gt;
    &lt;xsl:value-of select="xqx:decimalFormatParamName"/&gt;
    &lt;xsl:text&gt; = &lt;/xsl:text&gt;

    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:decimalFormatParamValue"/&gt;
    &lt;/xsl:call-template&gt;

    &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:voidSequenceType"&gt;
    &lt;xsl:text&gt;empty-sequence()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:occurrenceIndicator"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyItemType"&gt;
    &lt;xsl:text&gt;item()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceType"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


<span>&lt;!-- 2011-09-09/JM - added a sequenceTypeUnion type                                    --&gt;
  &lt;xsl:template match="xqx:sequenceTypeUnion"&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType[1]"/&gt;
    &lt;xsl:if test="count(xqx:sequenceType) &gt; 1"&gt;
      &lt;xsl:for-each select="xqx:sequenceType[position() &gt; 1]"&gt;
        &lt;xsl:text&gt; | &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="."/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:singleType"&gt;
    &lt;xsl:apply-templates select="xqx:atomicType"/&gt;
    &lt;xsl:if test="xqx:optional"&gt;
      &lt;xsl:text&gt;?&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeDeclaration"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


<span>&lt;!-- contextItemDecl shouldn't have sequenceType, but itemType                         --&gt;
  &lt;xsl:template match="xqx:contextItemType"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:contextItemDecl"&gt;
    &lt;xsl:text&gt;declare context item &lt;/xsl:text&gt;
</span><span>    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:contextItemType"/&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
</span><span>      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;xsl:if test="xqx:external/xqx:varValue"&gt;
        &lt;xsl:text&gt;:= &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="xqx:external/xqx:varValue"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:annotation"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$PERCENT"/&gt;
    &lt;xsl:apply-templates select="xqx:annotationName"/&gt;
    &lt;xsl:if test="xqx:arguments"&gt;
      &lt;xsl:for-each select="xqx:arguments"&gt;
         &lt;xsl:call-template name="parenthesizedList"/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


</span>  &lt;xsl:template match="xqx:varDecl"&gt;
<span>    &lt;xsl:text&gt;declare&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; variable &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;xsl:if test="xqx:external/xqx:varValue"&gt;
        &lt;xsl:text&gt;:= &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="xqx:external/xqx:varValue"/&gt;
      &lt;/xsl:if&gt;
</span>    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


&lt;!-- Part of fix for Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:targetLocation"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="position()=1"&gt; at &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;,&amp;#xD;  &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


&lt;!-- Modified to fix Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:schemaImport"&gt;
    &lt;xsl:text&gt; import schema &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:defaultElementNamespace"&gt;
      &lt;xsl:text&gt; default element namespace &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Modified to fix Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:moduleImport"&gt;
    &lt;xsl:text&gt; import module &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:param"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionBody"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionDecl"&gt;
<span>    &lt;xsl:text&gt;declare&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:externalDefinition"&gt;
        &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:queryBody"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:moduleDecl"&gt;
    &lt;xsl:text&gt; module namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri" /&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:prolog"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SEPARATOR"/&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:libraryModule"&gt;
    &lt;xsl:apply-templates select="xqx:moduleDecl"/&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:mainModule"&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
    &lt;xsl:apply-templates select="xqx:queryBody"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:module" priority="2"&gt;
<span>    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:versionDecl/xqx:encoding"&gt;
        &lt;xsl:variable name="enc"&gt;
          &lt;xsl:value-of select='xqx:versionDecl/xqx:encoding'/&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:result-document encoding="{$enc}"&gt;
          &lt;xsl:apply-templates select="*"/&gt;
          &lt;xsl:fallback&gt;
            &lt;xsl:apply-templates select="*"/&gt;
          &lt;/xsl:fallback&gt;
        &lt;/xsl:result-document&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:apply-templates select="*"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
</span>  &lt;/xsl:template&gt;


  &lt;xsl:template match="/xqx:*"&gt;
   &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: The only top-level element permitted is xqx:module&lt;/xsl:message&gt;
  &lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="xqueryx-id-mime-type" id="xqueryx-id-mime-type"></a>C
The <code>application/xquery+xml</code> Media Type</h2>
<p>This Appendix specifies the media type for XQueryX Version 3.0.
XQueryX is the XML syntax of a language, XQuery, for querying over
data from XML data sources, as specified in <a href=
"#xquery-30">[XQuery 3.0: An XML Query Language]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Specification of media types is described in <a href=
"#RFC3023">[RFC 3023]</a>.</p>
</div>
<div class="div2">
<h3><a name="xqueryx-mime-introduction" id=
"xqueryx-mime-introduction"></a>C.1 Introduction</h3>
<p>This document, together with its normative references, defines
the XML syntax for the XML Query language XQuery Version 3.0. This
Appendix specifies the <code>application/xquery+xml</code> media
type, which is intended to be used for transmitting queries
expressed in the XQueryX syntax.</p>
<p>This media type is being submitted to the IESG for review,
approval, and registration with IANA.</p>
<p>This document was prepared by members of the W3C XML Query
Working Group. Please send comments to public-qt-comments@w3.org, a
public mailing list with archives at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</a>.</p>
</div>
<div class="div2">
<h3><a name="xqueryx-mime-registration" id=
"xqueryx-mime-registration"></a>C.2 Registration of MIME Media Type
<code>application/xquery+xml</code></h3>
<p>MIME media type name: <code>application</code></p>
<p>MIME subtype name: <code>xquery+xml</code></p>
<p>Required parameters: none</p>
<p>Optional parameters: <code>charset</code></p>
<p>This parameter has identical semantics to the
<code>charset</code> parameter of the <code>application/xml</code>
media type as specified in [RFC 3023].</p>
<div class="div3">
<h4><a name="xqueryx-mime-encoding" id=
"xqueryx-mime-encoding"></a>C.2.1 Encoding Considerations</h4>
<p>By virtue of XSLT content being XML, it has the same
considerations when sent as "<code>application/xquery+xml</code>"
as does XML. See [RFC 3023], section 3.2.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-security" id=
"xqueryx-mime-security"></a>C.2.2 Security Considerations</h4>
<p>Queries written in XQuery may cause arbitrary URIs or IRIs to be
dereferenced. Therefore, the security issues of [RFC3987] Section 8
should be considered. In addition, the contents of resources
identified by <code>file:</code> URIs can in some cases be
accessed, processed and returned as results. XQuery expressions can
invoke any of the functions defined in XQuery 1.0 and XPath 2.0
Functions and Operators, including <code>file-exists()</code>; a
<code>doc()</code> function also allows local filesystem probes as
well as access to any URI-defined resource accessible from the
system evaluating the XQuery expression.</p>
<p>XQuery is a full declarative programming language, and supports
user-defined functions, external function libraries (modules)
referenced by URI, and system-specific "native" functions.</p>
<p>Arbitrary recursion is possible, as is arbitrarily large memory
usage, and implementations may place limits on CPU and memory
usage, as well as restricting access to system-defined
functions.</p>
<p>The XML Query Working group is working on a facility to allow
XQuery expressions to be used to create and update persistent data.
Untrusted queries should not be given write access to data.</p>
<p>Furthermore, because the XQuery language permits extensions, it
is possible that application/xquery may describe content that has
security implications beyond those described here.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-interoperability" id=
"xqueryx-mime-interoperability"></a>C.2.3 Interoperability
Considerations</h4>
<p>See <a href=
"http://www.w3.org/TR/xquery-30/#id-xquery-conformance">Section 5
Conformance</a> <sup><small>XQ30</small></sup>.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-pubspec" id=
"xqueryx-mime-pubspec"></a>C.2.4 Published specification</h4>
<p>This media type registration is for XQueryX documents as
described by the XQueryX 3.0 specification, which is located at
<a href=
"http://www.w3.org/TR/xqueryx-30/">http://www.w3.org/TR/xqueryx-30/</a>.
It is also appropriate to use this media type with later versions
of the XQueryX language.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-applications" id=
"xqueryx-mime-applications"></a>C.2.5 Applications That Use This
Media Type</h4>
<p>The public <a href="http://www.w3.org/XML/Query/">XQuery Web
page</a> lists more than two dozen implementations of the XQuery
language, both proprietary and open source. Some of these are known
to support XQueryX.</p>
<p>This new media type is being registered to allow for deployment
of XQueryX on the World Wide Web.</p>
<p>There is no experimental, vendor specific, or personal tree
predecessor to "application/xquery+xml", reflecting the fact that
no applications currently recognize it. This new type is being
registered in order to allow for the expected deployment of XQueryX
3.0 on the World Wide Web, as a first class XML application.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-additional" id=
"xqueryx-mime-additional"></a>C.2.6 Additional Information</h4>
<div class="div4">
<h5><a name="xqueryx-mime-recognizing" id=
"xqueryx-mime-recognizing"></a>C.2.6.1 Recognizing XQuery Files
("Magic Numbers")</h5>
<p>Although no byte sequences can be counted on to consistently
identify XQueryX, XQueryX documents will have the sequence
"http://www.w3.org/2005/XQueryX" to identify the XQueryX namespace.
This sequence will normally be found in a namespace attribute of
the first element in the document.</p>
</div>
<div class="div4">
<h5><a name="xqueryx-mime-extensions" id=
"xqueryx-mime-extensions"></a>C.2.6.2 File Extensions</h5>
<p>The most common file extension in use for XQueryX is
<code>.xqx</code>.</p>
</div>
<div class="div4">
<h5><a name="xqueryx-mime-macfiletype" id=
"xqueryx-mime-macfiletype"></a>C.2.6.3 Macintosh File Type
Code(s)</h5>
<p>The appropriate Macintosh file type code is
<code>TEXT</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-author" id=
"xqueryx-mime-author"></a>C.2.7 Person and Email Address to Contact
For Further Information</h4>
<p>Jim Melton, Oracle Corp., <a href=
"mailto:jim.melton@oracle.com">jim.melton@oracle.com</a></p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-intended-usage" id=
"xqueryx-mime-intended-usage"></a>C.2.8 Intended Usage</h4>
<p>COMMON</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-restrictions" id=
"xqueryx-mime-restrictions"></a>C.2.9 Restrictions on usage</h4>
<p>The intended usage of this media type is for interchange of
XQueryX expressions.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-owner" id="xqueryx-mime-owner"></a>C.2.10
Author/Change Controller</h4>
<p>XQuery was produced by, and is maintained by, the World Wide Web
Consortium's XML Query Working Group. The W3C has change control
over this specification.</p>
</div>
<div class="div3">
<h4><a name="xqueryx-mime-fragments" id=
"xqueryx-mime-fragments"></a>C.2.11 Fragment Identifiers</h4>
<p>For documents labeled as "<code>application/xquery+xml</code>",
the fragment identifier notation is exactly that for
"<code>application/xml</code>", as specified in [RFC 3023].</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="changelog" id="changelog"></a>D Change log
(Non-Normative)</h2>
<p>This appendix lists the changes that have been made to this
specification since the publication of the XQueryX 1.0
Recommendation on 23 January 2007.</p>
<div class="div2">
<h3><a name="changelog_substantive" id=
"changelog_substantive"></a>D.1 Substantive changes</h3>
<p>In the Recommendation of 08 April 2014, the following
substantive changes have been made relative to XQueryX 1.0. The
changes made to this document are described below. The rationale
for each change is explained in the corresponding Bugzilla database
entry (if any). The following table summarizes the changes that
have been applied.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<td>Change</td>
<td>Bugzilla</td>
<td>Category</td>
<td>Description</td>
</tr>
</thead>
<tbody>
<tr>
<td>Group By clause in FLWOR expression.</td>
<td>None.</td>
<td>Substantive.</td>
<td>A new clause was added to the FLWOR expression to allow query
writers to cause groups of tuples to be created based on the values
of some expression.</td>
</tr>
<tr>
<td>Window clause in FLWOR expression.</td>
<td>None.</td>
<td>Substantive.</td>
<td>A new clause was added to the FLWOR expression to allow query
writers to create sliding and tumbling windows of tuples based on a
number of criteria.</td>
</tr>
<tr>
<td>Simplification of FLWOR expression.</td>
<td>None.</td>
<td>Substantive.</td>
<td>The syntax of the FLWOR expression was considerably relaxed,
permitting most clauses (other than the return clause) to be used
at almost any position (only a few clauses are allowed to be the
first clause) within a FLWOR expression.</td>
</tr>
<tr>
<td>Outer for supported in FLWOR expressions.</td>
<td>None.</td>
<td>Substantive.</td>
<td>The syntax of the for clause in FLWOR expressions was extended
to allow the use of "outer for".</td>
</tr>
<tr>
<td>Count clause in FLWOR expression.</td>
<td>None.</td>
<td>Substantive.</td>
<td>A new clause was added to the FLWOR expression to allow query
writers to capture the total number of items that are returned by a
(portion of a) FLWOR expression.</td>
</tr>
<tr>
<td>Declaration of decimal number formats.</td>
<td>None.</td>
<td>Substantive.</td>
<td>A new option was added to the query prologue, allowing query
authors to specify a named (or an unnamed default) format for
decimal numbers. This allows the specification of such items as the
decimal separator, the minus sign, the percent and per mille signs,
and even the class of Unicode digits.</td>
</tr>
<tr>
<td>Query version and encoding declaration.</td>
<td>None.</td>
<td>Substantive.</td>
<td>Allows specification of either or both of the version of XQuery
to which a query adheres and the encoding of the query (e.g., UTF8,
ISO8859-1).</td>
</tr>
<tr>
<td>Enhanced validation expression.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=5472">[XQuery 1.1]
Requirement: validation by type</a></td>
<td>Substantive.</td>
<td>Permits query authors to validate an expression against a
specified XML Schema type.</td>
</tr>
<tr>
<td>Nondeterministic external functions.</td>
<td>None.</td>
<td>Substantive.</td>
<td>Functions declared to be external functions can also be
specified to be deterministic or nondeterministic.</td>
</tr>
<tr>
<td>Syntax used to provide default value for external
variables.</td>
<td>None.</td>
<td>Minor.</td>
<td>The declaration of external variables now uses ":=" to indicate
the default value given to such variables, instead of the keyword
"default".</td>
</tr>
<tr>
<td>Try/catch for error handling.</td>
<td>None.</td>
<td>Substantive.</td>
<td>A try/catch facility is provided that allows query authors to
control how errors are handled when raised by evaluation of
queries.</td>
</tr>
<tr>
<td>Context item declaration.</td>
<td>None.</td>
<td>Substantive.</td>
<td>It is now possible to declare both the type of and the default
initial value of the context item of a query, and to specify
whether its value may be provided by the external environment.</td>
</tr>
<tr>
<td>Computed namespace constructor.</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added new complex type and element to XQueryX schema, and new
template to XQueryX stylesheet, in support of computed namespace
constructors in XQuery 1.1.</td>
</tr>
<tr>
<td>Generate proper syntax for variable names in positional
variable bindings.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6309">[XQX30]
template for positionalVariableBinding</a></td>
<td>Substantive.</td>
<td>Modified XQueryX stylesheet template to correctly generate a
"$" preceding the variable name.</td>
</tr>
<tr>
<td>Allow positional variable bindings to be optional in window
variables.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6310">[XQX30]
positionalVariableBinding should be optional in windowVars</a></td>
<td>Substantive.</td>
<td>Modified XQueryX schema to add minOccurs="0" on element
positionalVariableBinding in windowVars complex type
definition.</td>
</tr>
<tr>
<td>XQueryX syntax must allow wildcards in the try/catch error
list.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7053">[XQX30]
cannot represent a catchErrorList wildcard in XQueryX</a></td>
<td>Substantive.</td>
<td>In XQueryX schema, modified catchErrorList complex type
definition to allow a choice between a nameText (essentially a
QName) and a Wildcard. In XQueryX stylesheet, modified
catchErrorList template to support Wildcard as well as
nameText.</td>
</tr>
<tr>
<td>Private functions.</td>
<td>None.</td>
<td>Substantive.</td>
<td>In XQueryX schema, added new attribute "private" in
functionDecl complex type. In XQUeryX stylesheet, template for
functionDecl, added support for @private (generate "private" for
private functions and "public" for others)</td>
</tr>
<tr>
<td>Replace "outer for" with "allowing empty".</td>
<td>None.</td>
<td>Substantive.</td>
<td>In XQueryX schema, forClause complex type, delete attribute
"outer"; in forClauseItem complex type, add new element
allowingEmpty. In XQueryX stylesheet template for forClause, remove
generation of "outer"; in template for forClauseItem, generate
"allowing empty".</td>
</tr>
<tr>
<td>Higher-order functions.</td>
<td>None.</td>
<td>Substantive.</td>
<td>Made changes to XQueryX schema and stylesheet corresponding to
new higher-order function syntax in XQuery 1.1.</td>
</tr>
<tr>
<td>New "switch" expression ("value switch", analogous to
typeswitch).</td>
<td>None.</td>
<td>Substantive.</td>
<td>Made changes to XQueryX schema and stylesheet corresponding to
new switch syntax in XQuery 3.0.</td>
</tr>
<tr>
<td>Support for partial function application.</td>
<td>None.</td>
<td>Substantive.</td>
<td>Made changes to XQueryX schema and stylesheet to support the
partial function application capability of XQuery 3.0.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=11792#c3">lack of
syntactic symmetry between the control flow expressions</a></td>
<td>Substantive.</td>
<td>Eliminated the possibility of defining three "error variables"
as part of the catch clause; those variables (and others) are now
implicitly defined, and may be used without explicit definition. At
the same time, fixed a bug in the schema and stylesheet that
recognized and produced invalid syntax for the validation
expression.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added support for the string concatenation operator
("||").</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added support for the simple mapping operator ("!").</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added support for the sequenceTypeUnion in the typeswitch
expression.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added support for the annotations on inline functions.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Added support for new group-by syntax.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td>None.</td>
<td>Substantive.</td>
<td>Replaced the element named "literalFunctionItemExpr" with an
identical element named "namedFunctionRef"; Replaced the element
named "inlineFunctionItemExpr" with an identical element named
"inlineFunctionExpr"</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=16197">Precedence
of the Simple Map Operator</a></td>
<td>Substantive</td>
<td>Removed the element mapStepExpr and added an element
simpleMapExpr, thus changing the precedence of the simple map
operator (!).</td>
</tr>
<tr>
<td>XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=17549">missing
parens for try/catch expression</a></td>
<td>Substantive</td>
<td>Generate parentheses that surround the XQuery code generated
for a tryCatchExpr.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://lists.w3.org/Archives/Member/w3c-xsl-query/2012Sep/0003.html">
Annotation in FunctionTest in XQueryX (member-only
message)</a></td>
<td>Substantive</td>
<td>Provide support for (annotation) assertions in function
tests.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=18838">[APPLET]
encoding becomes version in version declaration</a></td>
<td>Substantive</td>
<td>Require that a &lt;versionDecl&gt; element contain a
&lt;version&gt; element, an &lt;encoding&gt; element, or both. Use
the &lt;encoding&gt; element to determine the actual encoding of
the generated XQuery output.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20864">Annotation
arguments</a></td>
<td>Substantive</td>
<td>Align with XQuery by restricting the operands of annotations to
be literals, not expressions</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20876">decimalFormatDecl</a></td>
<td>Substantive</td>
<td>Modify the manner in which XQueryX indicates that a declared
decimal format is determined to be the default decimal format
declaration.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20877">contextItemDecl</a></td>
<td>Substantive</td>
<td>Restrict the declared type of the context item to items,
instead of sequence types in general</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=20878">functionDecl</a></td>
<td>Substantive</td>
<td>XQuery no longer has the ability to declare functions to be
deterministic/non-deterministic, nor to declare them to be
public/private by the use of ordinary keyword syntax (instead,
annotations are used for declaring them public/private)</td>
</tr>
</tbody>
</table>
<p>In the Recommendation of 08 April 2014, the following
substantive changes have been made relative to the preceding stage
of this document, the Candidate Recommendation of 08 January 2013.
The changes made to this document are described below. The
rationale for each change is explained in the corresponding
Bugzilla database entry (if any). The following table summarizes
the changes that have been applied.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<td>Change</td>
<td>Bugzilla</td>
<td>Category</td>
<td>Description</td>
</tr>
</thead>
<tbody>
<tr>
<td>XML Schema and XSLT Stylesheet<sup>[<a name="FN-ANCH-d2e1473"
id="FN-ANCH-d2e1473" href="#d2e1473">1</a>]</sup></td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=22851">[XQX30]
simpleMapExpr</a></td>
<td>Substantive</td>
<td>The schema definition of simpleMapExpr has been extended to
permit a string of simpleMapExprs that cascade on one another.
Although this was possible with the previous definition of
simpleMapExpr, the XQueryX syntax to do so was lengthy, tedious,
and not altogether intuitive. The stylesheet rendering of
simpleMapExpr into XQuery syntax has been correspondingly modified
as well.</td>
</tr>
</tbody>
<tbody>
<tr>
<td>
<p class="table.footnote"><sup><a name="d2e1473" id="d2e1473" href=
"#FN-ANCH-d2e1473">1.</a></sup> This row and all following rows
were added after the previously-published draft.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="changelog_incompatibilities" id=
"changelog_incompatibilities"></a>D.2 Incompatibilities</h3>
<p>The Recommendation of 08 April 2014, contains the following
incompatibilities with XQueryX 1.0. The changes made to this
document are described below. The rationale for each change is
explained in the corresponding Bugzilla database entry (if any).
The following table summarizes the changes that have been
applied.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<td>Change</td>
<td>Bugzilla</td>
<td>Category</td>
<td>Description</td>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="changelog_editorial" id="changelog_editorial"></a>D.3
Editorial changes</h3>
<p>In the Recommendation of 08 April 2014, the following editorial
changes have been made relative to XQueryX 1.0. The changes made to
this document are described below. The rationale for each change is
explained in the corresponding Bugzilla database entry (if any).
The following table summarizes the changes that have been
applied.</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<td>Change</td>
<td>Bugzilla</td>
<td>Category</td>
<td>Description</td>
</tr>
</thead>
<tbody>
<tr>
<td>Erratum XQX.E1</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=4924">Arguably
incorrect element definition in XQueryX's Schema.</a></td>
<td>Editorial.</td>
<td>The published XQueryX 1.0 schema defined many elements using
anonymous complex types. That made it infeasible to extend the
content model of those elements in other specifications that define
XQueryX extensions corresponding perhaps to XQuery extensions.
While conceptually simple, a number of changes were required to
ensure that all elements are defined using named complex
types.</td>
</tr>
<tr>
<td>Erratum XQX.E2 and Erratum XQX.E3</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=4963">Removed
element xqx:parenthesizedExpr used in example.</a></td>
<td>Editorial.</td>
<td>The XQueryX solution to Example 4 incorrectly contained an
&lt;xqx:parenthesizedExpr&gt; element. That element was changed to
an &lt;xqx:sequenceExpr&gt; element. The XSLT stylesheet in
Appendix B contained a template for the transformation of
&lt;xqx:parenthesizedExpr&gt; elements that was unnecessary and
confusing; that template was deleted.</td>
</tr>
<tr>
<td>Erratum XQX.E4</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=5323">Bug in
XQueryX applet</a></td>
<td>Editorial.</td>
<td>The XQueryX 1.0 Recommendation linked to an obsolete version of
the XQuery 1.0 grammar applet. The proper link has now been
used.</td>
</tr>
<tr>
<td>Erratum XQX.E5</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=5343">Problem with
{{ and }} in a Namespace Declaration Attribute</a></td>
<td>Editorial.</td>
<td>The XSLT stylsheet in Appendix B contained a template for the
transformation of &lt;xqx:namespaceDeclaration&gt; elements that
failed to correctly "escape" curly braces in the same manner as
does the template for the transformation of
&lt;xqx:attributeConstructor&gt; elements. That template has been
corrected.</td>
</tr>
<tr>
<td>Introduction.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6377">[XQX]
non-normative notes</a></td>
<td>Editorial.</td>
<td>Added text in <a href="#Introduction"><b>1 Introduction</b></a>
to clarify that Notes are non-normative.</td>
</tr>
<tr>
<td>This appendix.</td>
<td>None.</td>
<td>Editorial.</td>
<td>Reorganized this appendix to more clearly distinguish between
substantive and editorial changes and to clearly identify
incompatibilities with the previous Recommendation.</td>
</tr>
<tr>
<td>Version number.</td>
<td>None.</td>
<td>Editorial.</td>
<td>Changed the version number of the spec from 1.1 to 3.0.</td>
</tr>
<tr>
<td>Introduction.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14045">section 1:
schema and stylesheet URLs</a></td>
<td>Editorial.</td>
<td>Corrected the URI of the XQueryX schema document and
stylesheet.</td>
</tr>
<tr>
<td>Introduction.</td>
<td><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=14044">section 1:
version typo</a></td>
<td>Editorial.</td>
<td>Corrected the version number of the previous version of
XQueryX. Also removed normative reference to "this" document and
replaced it with a reference to the XQueryX 1.0 document.</td>
</tr>
<tr>
<td>XML Schema and XSLT Stylesheet</td>
<td><a href=
"https://lists.w3.org/Archives/Member/w3c-xsl-query/2012Oct/0000.html">
(W3C confidential email)</a></td>
<td>Editorial.</td>
<td>Changed the stylesheet XSLT version number to 2.0, reflecting
the new use of the xsl:result-document element to control the
character encoding of the generated XQuery query.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
