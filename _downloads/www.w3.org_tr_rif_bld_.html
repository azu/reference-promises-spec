<!-- http://www.w3.org/TR/rif-bld/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>RIF Basic Logic Dialect (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="tr.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both"><span id="short-title">RIF Basic Logic Dialect (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 5 February 2013</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/" id="this-version-url">http://www.w3.org/TR/2013/REC-rif-bld-20130205/</a></dd>

<dt>Latest version:</dt>
<dd><a href="http://www.w3.org/TR/rif-bld/">http://www.w3.org/TR/rif-bld/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-rif-bld-20121211/">http://www.w3.org/TR/2012/PER-rif-bld-20121211/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd>Harold Boley, National Research Council Canada</dd>
<dd>Michael Kifer, State University of New York at Stony Brook, USA</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2010/rif/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/diff-from-20121211">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2013/pdf/REC-rif-bld-20130205.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2010/rif/translation/rif-bld">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2013 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>This document, developed by the <a href="http://www.w3.org/2005/rules/wiki/RIF_Working_Group" title="RIF Working Group">Rule Interchange Format (RIF) Working Group</a>, specifies the Basic Logic Dialect, RIF-BLD, a format that allows logic rules to be exchanged between rule systems. The RIF-BLD presentation syntax and semantics are specified both directly and as specializations of the <i>RIF Framework for Logic Dialects</i>, or RIF-FLD. The XML serialization syntax of RIF-BLD is specified via a mapping from the presentation syntax. A normative XML schema is also provided.</p> </div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>


<h4 class="no-toc no-num" id="related">Set of Documents</h4>

<p>This document is being published as one of a set of 13 documents: </p>
<ol>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-overview-20130205/">RIF Overview (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">RIF Use Cases and Requirements (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">RIF Core Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-bld-20130205/">RIF Basic Logic Dialect (Second Edition)</a>  (this document)</li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">RIF Production Rule Dialect (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">RIF Framework for Logic Dialects (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">RIF Datatypes and Built-Ins 1.0 (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">RIF RDF and OWL Compatibility (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-owl-rl-20130205/">OWL 2 RL in RIF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-xml-data-20130205/">RIF Combination with XML data (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-in-rdf-20130205/">RIF In RDF (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-test-20130205/">RIF Test Cases (Second Edition)</a></li>
<li><a href="http://www.w3.org/TR/2013/NOTE-rif-primer-20130205/">RIF Primer (Second Edition)</a></li>
</ol>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Document Unchanged</h4>

<p>There have been no changes to the body of this document since the <a href="http://www.w3.org/TR/2012/PER-rif-bld-20121211/">previous version</a>.   For details on earlier changes, see the <a href="#changelog">change log</a>.</p>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-rif-comments@w3.org">public-rif-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2005/rules/wg.html">Rule Interchange Format (RIF) Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2010/rif/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-rif-dev@w3.org">public-rif-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-rif-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38457/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />


<table class="toc" id="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1"><a href="#Direct_Specification_of_RIF-BLD_Presentation_Syntax"><span class="tocnumber">2</span> <span class="toctext">Direct Specification of RIF-BLD Presentation Syntax</span></a>
<ul>
<li class="toclevel-2"><a href="#Alphabet_of_RIF-BLD"><span class="tocnumber">2.1</span> <span class="toctext">Alphabet of RIF-BLD</span></a></li>
<li class="toclevel-2"><a href="#Terms"><span class="tocnumber">2.2</span> <span class="toctext">Terms</span></a></li>
<li class="toclevel-2"><a href="#Formulas"><span class="tocnumber">2.3</span> <span class="toctext">Formulas</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Annotations_in_the_Presentation_Syntax"><span class="tocnumber">2.4</span> <span class="toctext">RIF-BLD Annotations in the Presentation Syntax</span></a></li>
<li class="toclevel-2"><a href="#Well-formed_Formulas"><span class="tocnumber">2.5</span> <span class="toctext">Well-formed Formulas</span></a></li>
<li class="toclevel-2"><a href="#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29"><span class="tocnumber">2.6</span> <span class="toctext">EBNF Grammar for the Presentation Syntax of RIF-BLD (Informative)</span></a>
<ul>
<li class="toclevel-3"><a href="#EBNF_for_the_Condition_Language"><span class="tocnumber">2.6.1</span> <span class="toctext">EBNF for the Condition Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_the_Rule_Language"><span class="tocnumber">2.6.2</span> <span class="toctext">EBNF for the Rule Language</span></a></li>
<li class="toclevel-3"><a href="#EBNF_for_Annotations"><span class="tocnumber">2.6.3</span> <span class="toctext">EBNF for Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Direct_Specification_of_RIF-BLD_Semantics"><span class="tocnumber">3</span> <span class="toctext">Direct Specification of RIF-BLD Semantics</span></a>
<ul>
<li class="toclevel-2"><a href="#Truth_Values"><span class="tocnumber">3.1</span> <span class="toctext">Truth Values</span></a></li>
<li class="toclevel-2"><a href="#Semantic_Structures"><span class="tocnumber">3.2</span> <span class="toctext">Semantic Structures</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Annotations_in_the_Semantics"><span class="tocnumber">3.3</span> <span class="toctext">RIF-BLD Annotations in the Semantics</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Non-document_Formulas"><span class="tocnumber">3.4</span> <span class="toctext">Interpretation of Non-document Formulas</span></a></li>
<li class="toclevel-2"><a href="#Interpretation_of_Documents"><span class="tocnumber">3.5</span> <span class="toctext">Interpretation of Documents</span></a></li>
<li class="toclevel-2"><a href="#Logical_Entailment"><span class="tocnumber">3.6</span> <span class="toctext">Logical Entailment</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#XML_Serialization_Syntax_for_RIF-BLD"><span class="tocnumber">4</span> <span class="toctext">XML Serialization Syntax for RIF-BLD</span></a>
<ul>
<li class="toclevel-2"><a href="#XML_for_the_Condition_Language"><span class="tocnumber">4.1</span> <span class="toctext">XML for the Condition Language</span></a></li>
<li class="toclevel-2"><a href="#XML_for_the_Rule_Language"><span class="tocnumber">4.2</span> <span class="toctext">XML for the Rule Language</span></a></li>
<li class="toclevel-2"><a href="#Mapping_from_the_Presentation_Syntax_to_the_XML_Syntax"><span class="tocnumber">4.3</span> <span class="toctext">Mapping from the Presentation Syntax to the XML Syntax</span></a>
<ul>
<li class="toclevel-3"><a href="#Mapping_of_the_Condition_Language"><span class="tocnumber">4.3.1</span> <span class="toctext">Mapping of the Condition Language</span></a></li>
<li class="toclevel-3"><a href="#Mapping_of_the_Rule_Language"><span class="tocnumber">4.3.2</span> <span class="toctext">Mapping of the Rule Language</span></a></li>
<li class="toclevel-3"><a href="#Mapping_of_Annotations"><span class="tocnumber">4.3.3</span> <span class="toctext">Mapping of Annotations</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Conformance_Clauses"><span class="tocnumber">5</span> <span class="toctext">Conformance Clauses</span></a></li>
<li class="toclevel-1"><a href="#RIF-BLD_as_a_Specialization_of_the_RIF_Framework_for_Logic_Dialects_.5BRIF-FLD.5D"><span class="tocnumber">6</span> <span class="toctext">RIF-BLD as a Specialization of the RIF Framework for Logic Dialects [RIF-FLD]</span></a>
<ul>
<li class="toclevel-2"><a href="#The_Presentation_Syntax_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.1</span> <span class="toctext">The Presentation Syntax of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#The_Semantics_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.2</span> <span class="toctext">The Semantics of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#The_XML_Serialization_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.3</span> <span class="toctext">The XML Serialization of RIF-BLD as a Specialization of RIF-FLD</span></a></li>
<li class="toclevel-2"><a href="#RIF-BLD_Conformance_as_a_Specialization_of_RIF-FLD"><span class="tocnumber">6.4</span> <span class="toctext">RIF-BLD Conformance as a Specialization of RIF-FLD</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgements"><span class="tocnumber">7</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a>
<ul>
<li class="toclevel-2"><a href="#Normative_References"><span class="tocnumber">8.1</span> <span class="toctext">Normative References</span></a></li>
<li class="toclevel-2"><a href="#Informational_References"><span class="tocnumber">8.2</span> <span class="toctext">Informational References</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_XML_Schema_for_RIF-BLD"><span class="tocnumber">9</span> <span class="toctext">Appendix: XML Schema for RIF-BLD</span></a>
<ul>
<li class="toclevel-2"><a href="#Condition_Language"><span class="tocnumber">9.1</span> <span class="toctext">Condition Language</span></a></li>
<li class="toclevel-2"><a href="#Rule_Language"><span class="tocnumber">9.2</span> <span class="toctext">Rule Language</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">10</span> <span class="toctext">Appendix: Change Log (Informative)</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a id="Overview" name="Overview"></a><h2> <span class="mw-headline">1  Overview </span></h2>
<p><span class="anchor" id="overview"></span> This specification develops <i><b>RIF-BLD</b></i> (the <b>B</b>asic <b>L</b>ogic <b>D</b>ialect of the <b>R</b>ule <b>I</b>nterchange <b>F</b>ormat). From a theoretical perspective, RIF-BLD corresponds to the language of definite Horn rules with equality and a standard first-order semantics [<a href="#ref-chang-lee" title="">CL73</a>]. Syntactically, RIF-BLD has a number of extensions to support features such as objects and frames as in F-logic [<a href="#ref-flogic-95" title="">KLW95</a>], internationalized resource identifiers (or IRIs, defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>]) as identifiers for concepts, and XML Schema datatypes [<a href="#ref-xml-schema2" title="">XML-SCHEMA2</a>]. In addition, RIF RDF and OWL Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] defines semantics for the integrated RIF-BLD/RDF and RIF-BLD/OWL languages. These features make RIF-BLD a Web-aware language. However, it should be kept in mind that RIF is designed to enable interoperability among rule languages in general, and its uses are not limited to the Web. 
</p><p>While rule interchange (and not, e.g., execution) is the principle design goal for RIF-BLD, the design clearly indicates a decision to avoid solving the (probably impossible) problem of rule interchange in general.  Instead, the design of RIF reflects the rationale of identifying specific kinds of rules within existing rule systems, called <i>RIF dialects</i>, that can be translated into other rule systems without changing their meaning. RIF-BLD is just the first in a series of such dialects. In particular, RIF-BLD has the RIF-Core dialect [<a href="#ref-rif-core" title="">RIF-Core</a>] as a subset. It is <i>not expected</i> that most rule systems will be able to translate all their rules into RIF-BLD, rather it is expected that only certain kinds of rules will be translatable.  Since there are many existing rule languages with useful features that are not supported in RIF-BLD, it is expected that RIF-BLD translators will not translate rules that use such features.  This could drive the design of "BLD-specific" rule sets in which rules are specifically written by the implementor to be within the BLD dialect and thus be portable between many rule system implementations.  
</p><p>Among its many influences, RIF shares certain characteristics with ISO Common Logic (CL) [<a href="#ref-common-logic" title="">ISO-CL</a>], itself an evolution of KIF [<a href="#ref-kif" title="">KIF</a>] and Conceptual Graphs [<a href="#ref-cg" title="">CG</a>]. Like CL, RIF employs XML as its primary normative syntax, uses IRIs as identifiers, specifies integrated RIF-BLD/RDF and RIF-BLD/OWL languages for Semantic Web Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>], and provides a rich set of datatypes and built-ins that are designed to be well aligned with Web-aware rule system implementations [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Unlike CL, RIF-BLD was designed to be a <i>simple</i> dialect with limited expressiveness that lies within the intersection of first-order and logic-programming systems. This is why RIF-BLD does not support negation. More generally, RIF-BLD is part of a coherent array of RIF rule dialects, which encompasses both logic rules -- through the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>] also including a variety of rule languages based on non-monotonic theories -- and production rules, as defined in [<a href="#ref-rif-prd" title="">RIF-PRD</a>]. CL, on the other hand, is strictly first-order; it does not account for non-monotonic semantics (e.g. negation as failure, defaults, priorities, etc.). For rule interchange between CL and RIF dialects, it is expected that partial RIF-CL mappings will be defined.
</p><p>RIF-BLD also bears some similarity to SPARQL, in particular with respect to RDF Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].  As with the well-known correspondence between a fragment of SQL and Datalog, SPARQL can be partially mapped to Datalog (and thus to the RIF-Core subset of RIF-BLD), see [<a href="#ref-sparql-rules" title="">AP07</a>] and [<a href="#ref-sparql-expr" title="">AG08</a>] for details. A full mapping of SPARQL would need constructs beyond RIF-BLD, such as non-monotonic negation. Likewise, not all of SPARQL's FILTER functions are expressible in RIF-DTB built-in predicates. Not all of RIF-BLD is expressible in SPARQL either, for instance recursive rules over RDF Data are not expressible as SPARQL CONSTRUCT statements.
</p><p>RIF-BLD is defined in two different ways -- <i>both normative</i>:
</p>
<ul>
  <li>
    As a direct specification, independently of the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>], for the benefit of those who desire a direct path to RIF-BLD, e.g., as prospective implementers, and are not interested in extensibility issues. This version of the RIF-BLD specification is given first.
  </li>
  <li>
    As a specialization of the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>], which is part of the RIF extensibility framework.

    Building on RIF-FLD, this version of the RIF-BLD specification is comparatively short and is presented in Section <a href="#sec-bld-fld-spec" title="">RIF-BLD as a Specialization of the RIF Framework</a> at the end of this document. This is intended for the reader who is already familiar with RIF-FLD and does not need to go through the much longer direct specification of RIF-BLD. This section is also useful for dialect designers, as it is a concrete example of how a non-trivial RIF dialect can be derived from the RIF framework for logic dialects.
  </li>
</ul>
<p>Logic-based RIF dialects that specialize or extend RIF-BLD in accordance with the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>] include RIF-Core as a specialization of RIF-BLD. It is expected that other specifications will develop further logic dialects based on RIF-BLD such as a RIF-BLD extension capturing uncertainty [<a href="#ref-rif-urd" title="">URD08</a>].
</p><p>As a preview, here is a simple complete RIF-BLD example deriving a ternary relation from its inverse.
</p><p><b>Example 1</b> (An introductory RIF-BLD example).
</p><p>A rule can be written in English to derive the <tt>buy</tt> relationships
(rather than store them) from the <tt>sell</tt> relationships that are
stored as facts (e.g., as exemplified by the English statement below):
</p>
<ul>
  <li>
   <em>
     A buyer buys an item from a seller
     if the seller sells the item to the buyer.
   </em>
  </li>
  <li>
   <em>
     John sells LeRif to Mary.
   </em>
  </li>
</ul>
<p>Intuitively, the fact <i>Mary buys LeRif from John</i> should be logically derivable from the above premises.
Assuming Web IRIs for the predicates <tt>buy</tt> and <tt>sell</tt>, as well as for the individuals
<tt>John</tt>, <tt>Mary</tt>, and <tt>LeRif</tt>, the above English text can be represented in the <a href="#sec-bld-direct-syntax" title="">RIF-BLD Presentation Syntax</a> as follows.
</p>
<pre>Document(
  Base(&lt;http://example.com/people#&gt;)
  Prefix(cpt &lt;http://example.com/concepts#&gt;)
  Prefix(bks &lt;http://example.com/books#&gt;)

  Group
  (
    Forall&nbsp;?Buyer&nbsp;?Item&nbsp;?Seller (
        cpt:buy(?Buyer&nbsp;?Item&nbsp;?Seller)&nbsp;:- cpt:sell(?Seller&nbsp;?Item&nbsp;?Buyer)
    )
 
    cpt:sell(&lt;John&gt; bks:LeRif "Mary"^^rif:iri)
  )
)
</pre>
<p>Note that IRIs are represented in several different ways in this example. First,
the [<a href="#ref-curie" title="">CURIE</a>] notation <tt>prefix:suffix</tt> is used to shorten IRI representation. For instance, <tt>cpt:buy</tt> via a <tt>Prefix</tt> directive represents the <tt>rif:iri</tt> constant <tt>"http://example.com/concepts#buy"^^rif:iri</tt>.
Another way to shorten this IRI constant is to use the angle-bracketed notation <tt>&lt;http://example.com/concepts#buy&gt;</tt>. The <tt>Base</tt> directive provides yet another shortcut: it applies to all relative IRIs, such as
<tt>"Mary"^^rif:iri</tt> and <tt>&lt;John&gt;</tt>. The <tt>Base</tt> directive expands these relative IRIs to <tt>"http://example.com/people#Mary"^^rif:iri</tt> and <tt>"http://example.com/people#John"^^rif:iri</tt>, respectively.
</p><p><br />
Whenever a RIF-BLD document falls into the Core subset or can be translated to it, the document should be produced in RIF-Core to allow its interchange with a maximum number of RIF consumers.
For instance, the Datalog-like RIF document in Example 1 is also a RIF-Core example.
</p><p>For the interchange of documents containing RIF-BLD rules (and facts), a concrete <a href="#sec-xml-bld" title="">RIF-BLD XML Syntax</a> is given in this specification. To formalize their meaning, a model-theoretic <a href="#sec-bld-direct-semantics" title="">RIF-BLD Semantics</a> is specified.
</p><p><span class="anchor" id="sec-bld-direct-syntax"></span>
</p>
<a id="Direct_Specification_of_RIF-BLD_Presentation_Syntax" name="Direct_Specification_of_RIF-BLD_Presentation_Syntax"></a><h2> <span class="mw-headline">2  Direct Specification of RIF-BLD Presentation Syntax </span></h2>
<p>This section specifies the <i><b>presentation syntax</b></i> of RIF-BLD directly, without relying on [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. In the first five (normative) subsections, the presentation syntax is
defined using "mathematical English," a special form of English for communicating mathematical definitions, examples, etc.
In the non-normative subsection <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-BLD</a>, a grammar for a superset of the presentation syntax is given using Extended Backus&ndash;Naur Form (EBNF).
Neither the mathematical English nor the EBNF is intended to be a concrete syntax for RIF-BLD.  The mathematical English deliberately leaves out details such as the delimiters of the various syntactic components, escape symbols, parenthesizing, precedence of operators, and the like. The EBNF does not specify context-sensitive syntactic constraints.
Since RIF is an interchange format, it uses <i><b>XML as the only concrete syntax</b></i>,
which will be defined in <a href="#sec-xml-bld" title="">XML Serialization Syntax for RIF-BLD</a>. Hence <a href="#sec-conformance" title="">RIF-BLD conformance</a> is described in terms of <a href="#def-conformance" title="">semantics-preserving transformations</a>.
</p><p>Note to the reader: this section depends on Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p><br />
<span class="anchor" id="sec-alphabet"></span> 
</p>
<a id="Alphabet_of_RIF-BLD" name="Alphabet_of_RIF-BLD"></a><h4> <span class="mw-headline">2.1  Alphabet of RIF-BLD </span></h4>
<p><span class="anchor" id="def-bld-alphabet"></span> 
<b>Definition (Alphabet)</b>.
The <i><b>alphabet</b></i> of the presentation language of RIF-BLD consists of 
</p>
<ul><li> a countably infinite set of <i><b>constant symbols</b></i> <tt>Const</tt>
</li><li> a countably infinite set of <i><b>variable symbols</b></i> <tt>Var</tt> (disjoint from <tt>Const</tt>)
</li><li> a countably infinite set of argument names, <tt>ArgNames</tt> (disjoint from <tt>Const</tt> and <tt>Var</tt>)
</li><li> connective symbols <tt>And</tt>, <tt>Or</tt>, and <tt>:-</tt>
</li><li> quantifiers <tt>Exists</tt> and <tt>Forall</tt>
</li><li> the symbols <tt>=</tt>, <tt>#</tt>, <tt>##</tt>, <tt>-&gt;</tt>, <tt>External</tt>, <tt>Import</tt>, <tt>Prefix</tt>, and <tt>Base</tt> 
</li><li> the symbols <tt>Group</tt> and <tt>Document</tt>
</li><li> the symbols for representing lists: <tt>List</tt> and <tt>OpenList</tt>.  
</li><li> the auxiliary symbols <tt>(</tt>, <tt>)</tt>, <tt>[</tt>, <tt>]</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, and <tt>^^</tt>
</li></ul>
<p>The set of connective symbols, quantifiers, <tt>=</tt>, etc., is disjoint from <tt>Const</tt> and <tt>Var</tt>. The argument names in <tt>ArgNames</tt> are written as Unicode strings that must not start with a question mark, "<tt>?</tt>". Variables are written as Unicode strings preceded with the symbol "<tt>?</tt>". 
</p><p>Constants are written as <tt>"literal"^^symspace</tt>, where <tt>literal</tt> is a sequence of Unicode characters and
<tt>symspace</tt> is an identifier for a symbol space. Symbol spaces are defined in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p>The symbols <tt>=</tt>, <tt>#</tt>, and <tt>##</tt> are used in formulas that define equality, class membership, and subclass relationships. The symbol <tt>-&gt;</tt> is used in terms that have named arguments and in frame formulas. The symbol <tt>External</tt> indicates that an atomic formula or a function term is defined externally (e.g., a built-in)  and the symbols <tt>Prefix</tt> and <tt>Base</tt> enable compact representations of IRIs [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</p><p>The symbol <tt>Document</tt> is used to specify RIF-BLD documents, the symbol <tt>Import</tt> is an import directive, and the symbol <tt>Group</tt> is used to organize RIF-BLD formulas into collections. &nbsp;&nbsp;☐
</p><p>The language of RIF-BLD is the set of formulas constructed using the above alphabet according to the rules given below. 
</p><p><br />
<span class="anchor" id="sec-terms"></span>
</p>
<a id="Terms" name="Terms"></a><h4> <span class="mw-headline">2.2  Terms </span></h4>
<p>RIF-BLD defines several kinds of terms: <i>constants</i> and <i>variables</i>,
<i>positional</i> terms, terms with <i>named arguments</i>, plus <i>equality</i>,
<i>membership</i>, <i>subclass</i>, <i>frame</i>, and <i>external</i> terms. The word "<i>term</i>" will be used to refer to any of these constructs.
</p><p>To simplify the next definition, we will use the phrase <i>base term</i> to refer to simple, positional, or named-argument terms, or to terms of the form <tt>External(t)</tt>, where <tt>t</tt> is a positional or a named-argument term.
</p><p><span class="anchor" id="def-bld-term"></span> 
<b>Definition (Term)</b>.
</p>
<ol>
  <li><i>Constants and variables</i>. If <tt>t</tt> &isin; <tt>Const</tt> or <tt>t</tt> &isin; <tt>Var</tt> then <tt>t</tt> is a <i><b>simple term</b></i>. </li>
  <li><i>Positional terms</i>. If <tt>t</tt> &isin; <tt>Const</tt> and <tt>t<sub>1</sub></tt>, ..., <tt>t<sub>n</sub></tt>, <tt>n&ge;0</tt>, are base terms then <tt>t(t<sub>1</sub> ... t<sub>n</sub>)</tt> is a <i><b>positional term</b></i>. 
  <p>
  Positional terms correspond to the usual terms and atomic formulas of
classical first-order logic [<a href="#ref-enderton01" title="">Enderton01</a>, <a href="#ref-mendelson97" title="">Mendelson97</a>].
  </p></li>
  <li><i>Terms with named arguments</i>. A <i><b>term with named arguments</b></i> is of the form <tt>t(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>, where <tt>n&ge;0</tt>, <tt>t</tt> &isin; <tt>Const</tt> and <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> are  base terms and <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> are pairwise distinct symbols from the set <tt>ArgNames</tt>.
    <p>The constant <tt>t</tt> here represents a predicate or a function; <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt> represent argument names; and <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt> represent argument values. The argument names, <tt>s<sub>1</sub></tt>, ..., <tt>s<sub>n</sub></tt>, are required to be pairwise distinct. Terms with named arguments are like positional terms except that the arguments are named and their order is immaterial. Note that a term of the form <tt>f()</tt> is, trivially, both a positional term and a term with named arguments. </p>
    <p>
Terms with named arguments are introduced to support exchange of languages
that permit argument positions of predicates and functions to be named
(in which case the order of the arguments does not matter).
    </p>
  </li>
  <li>  
     <i>List terms</i>. There are two kinds of list terms: <em>open</em> and <em>closed</em>.  
     <ul>     
       <li>
	 A <i><b>closed list</b></i> has the form <tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub><tt>)</tt>, where <tt>m&ge;0</tt> and <tt>t</tt><sub>1</sub>, ..., <tt>t</tt><sub>m</sub> are terms.  
       </li>
       <li>       
	  An <i><b>open list</b></i> (or a list with a tail) has the form
	  <tt>OpenList(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> <tt>t)</tt>, where <tt>m&gt;0</tt> and <tt>t</tt><sub>1</sub>, ..., <tt>t</tt><sub>m</sub>, <tt>t</tt> are terms. Open lists are usually written using the following: <tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>m</sub> <tt>|</tt> <tt>t)</tt>.
	  <p>
	     The last argument, <tt>t</tt>, represents the tail of the list and so it is normally a list as well. However, the syntax does not restrict <tt>t</tt> in any way: it could be an integer, a variable, another list, or, in fact, any term. An example is <tt>List(1 2 | 3)</tt>. This is not an ordinary list, where the last argument, <tt>3</tt>, would represent the tail of a list (and thus would also be a list, which <tt>3</tt> is not). Such general open lists correspond to Lisp's dotted lists [<a href="#ref-steele90" title="">Steele90</a>]. Note that they can be the result of instantiating an open list with a variable in the tail, hence are hard to avoid. For instance, <tt>List(1 2 | 3)</tt> is <tt>List(1 2 |&nbsp;?X)</tt>, where the variable <tt>?X</tt> is replaced with <tt>3</tt>.
	  </p>
       </li>
     </ul>
     <p>
        A closed list of the form <tt>List()</tt> (i.e., a list in which <tt>m=0</tt>, corresponding to Lisp's <tt>nil</tt>) is called the <i><b>empty list</b></i>. 
     </p>
     <p>
     </p>
  </li>
  <li><i>Equality terms</i>.  <tt>t&nbsp;=&nbsp;s</tt> is an <i><b>equality term</b></i>, if <tt>t</tt> and <tt>s</tt> are base terms. </li>
  <li><i>Class membership terms</i> (or just <i>membership terms</i>). <tt>t#s</tt> is a <i><b>membership term</b></i> if <tt>t</tt> and <tt>s</tt> are base terms. </li>
  <li><i>Subclass terms</i>. <tt>t##s</tt> is a <i><b>subclass term</b></i> if <tt>t</tt> and <tt>s</tt> are base terms.
  </li>
  <li><i>Frame terms</i>. <tt>t[p<sub>1</sub>-&gt;v<sub>1</sub> ... p<sub>n</sub>-&gt;v<sub>n</sub>]</tt> is a <i><b>frame term</b></i> (or simply a <i><b>frame</b></i>) if <tt>t</tt>, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, <tt>v<sub>1</sub></tt>, ..., <tt>v<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are base terms.
    <p>
    Membership, subclass, and frame terms are used to describe objects and class hierarchies.
    </p>
  </li>
  <li>  
    <i>Externally defined terms.</i> If <tt>t</tt> is a positional or a named-argument term then <tt>External(t)</tt> is an <i><b>externally defined term</b></i>.
  <p>
     External terms are used for representing built-in functions and predicates as well as "procedurally attached" terms or predicates, which might exist in various rule-based systems, but are not specified by RIF. &nbsp;&nbsp;☐
  </p>
  </li>
</ol>
<p>Observe that the argument names of frame terms, <tt>p<sub>1</sub></tt>, ..., <tt>p<sub>n</sub></tt>, are base terms and so, as a special case, can be variables. In contrast, terms with named arguments can use only the symbols from <tt>ArgNames</tt> to represent their argument names. They cannot be constants from <tt>Const</tt> or variables from <tt>Var</tt>. The reason for not allowing variables for those is to control the complexity of unification, which is used by several inference mechanisms of first-order logic.
</p><p><br />
<b>Example 2</b> (Terms)
</p><p>a. Positional term:   <tt>"http://example.com/ex1"^^rif:iri(1 "http://example.com/ex2"^^rif:iri(?X 5) "abc")</tt>  
</p><p>b. Term with named arguments: <tt>"http://example.com/Person"^^rif:iri(id-&gt;"http://example.com/John"^^rif:iri "age"^^rif:local-&gt;?X "spouse"^^rif:local-&gt;?Y)</tt>
</p><p>c. Frame term: <tt>"http://example.com/John"^^rif:iri["age"^^rif:local-&gt;?X "spouse"^^rif:local-&gt;?Y]</tt>
</p><p>d. Lists
</p><p>- Empty list:  <tt>List()</tt> 
</p><p>- Closed list with variable inside:  <tt>List("a"^^xs:string&nbsp;?Y "c"^^xs:string)</tt>  
</p><p>- Open list with variables:  <tt>List("a"^^xs:string&nbsp;?Y "c"^^xs:string |&nbsp;?Z)</tt>  
</p><p>- Equality term with lists inside:  <tt>List(Head | Tail) = List("a"^^xs:string&nbsp;?Y "c"^^xs:string)</tt>  
</p><p>- Nested list:  <tt>List("a"^^xs:string List(?X "b"^^xs:string) "c"^^xs:string)</tt>  
</p><p><br /> 
e. Classification terms
</p><p>- Membership: <tt>?X #&nbsp;?Y</tt>
</p><p>- Subclass:   <tt>?X ## "http://example.com/ex1"^^rif:iri(?Y)</tt>
</p><p>- Membership: <tt>"http://example.com/John"^^rif:iri # "http://example.com/Person"^^rif:iri</tt>
</p><p>- Subclass:   <tt>"http://example.com/Student"^^rif:iri ## "http://example.com/Person"^^rif:iri</tt>
</p><p><br /> 
f. External term:  <tt>External(pred:numeric-greater-than(?diffdays 10)))</tt>
</p><p><br />
<span class="anchor" id="sec-formulas"></span>
</p>
<a id="Formulas" name="Formulas"></a><h4> <span class="mw-headline">2.3  Formulas </span></h4>
<p>RIF-BLD distinguishes certain subsets of the set <tt>Const</tt> of symbols, including subsets of <i>predicate symbols</i> and <i>function symbols</i>. Section <a href="#sec-well-formed" title="">Well-formed Formulas</a> gives more details, but we do not need those details yet.
</p><p><span class="anchor" id="def-bld-atomic-formula"></span> 
<b>Definition (Atomic Formula)</b>.
Any term (positional or with named arguments) of the form <tt>p(...)</tt>, where <tt>p</tt> is a predicate symbol, is also an <i><b>atomic formula</b></i>. Equality, membership, subclass, and frame terms are also atomic formulas. An externally defined term of the form <tt>External(&phi;)</tt>, where <tt>&phi;</tt> is an atomic formula, is also an atomic formula, called an <i><b>externally defined</b></i> atomic formula.
&nbsp;&nbsp;☐
</p><p>Note that simple terms (constants and variables) are <i>not</i> formulas.
</p><p>More general formulas are constructed from atomic formulas with the help of logical connectives.
</p><p><span class="anchor" id="def-bld-formula"></span> 
<b>Definition (Formula)</b>.
A <i><b>formula</b></i> can have several different forms and is defined as follows:
</p>
<ol>
  <li>
    <i>Atomic</i>: If <tt>&phi;</tt>  is an atomic formula then it is also a formula.
  </li>
  <li>
    <i><span id="def-bld-condition">Condition formula</span></i>: A <i><b>condition formula</b></i> is either an atomic formula or a formula that has one of the following forms:
    <ul>
      <li>
        <i>Conjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>,  <tt>n &ge; 0</tt>, are condition formulas then so is <tt>And(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>, called a <i>conjunctive</i> formula. As a special case, <tt>And()</tt> is allowed and is treated as a tautology, i.e., a formula that is always true. 
      </li>
      <li>
        <i>Disjunction</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt>, <tt>n &ge; 0</tt>, are condition formulas then so is <tt>Or(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt>, called a <i>disjunctive</i> formula. As a special case, <tt>Or()</tt> is permitted and is treated as a contradiction, i.e., a formula that is always false. 
      </li>
      <li>
        <i>Existentials</i>: If <tt>&phi;</tt>  is a condition formula and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then <tt>Exists&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> is an <i>existential</i> formula. 
      </li>
    </ul> 
    <p>
      Condition formulas are intended to be used inside the premises of rules. Next we define the notions of rule implications, universal rules, universal facts, groups (i.e., sets of rules and facts), and documents.
    </p>
  </li>
  <li>
    <i>Rule implication</i>: <tt>&phi;&nbsp;:- &psi;</tt> is a formula, called <i>rule implication</i>, if:
    <ul>    
      <li>
        <tt>&phi;</tt>  is an atomic formula or a <i>conjunction</i> of atomic formulas,
      </li>
      <li>
	<tt>&psi;</tt>  is a condition formula, and
      </li>
      <li>      
	none of the atomic formulas in <tt>&phi;</tt>  is an externally defined term (i.e., a term of the form <tt>External(...)</tt>). Note: external terms <i>can</i> occur in the <i>arguments</i> of atomic formulas in the rule conclusion. For instance, <tt>p(func:numeric-add(?X "2"^^xs:integer))&nbsp;:- q(?X)</tt>.
      </li>
    </ul>
  </li>
  <li>
    <i>Universal rule</i>: If <tt>&phi;</tt>  is a rule implication and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> is a formula, called a <i>universal rule</i>. It is required that all the <i>free</i> variables in <tt>&phi;</tt>  occur among the variables <tt>?V<sub>1</sub> ...&nbsp;?V<sub>n</sub></tt> in the quantification part. An occurrence of a variable <tt>?v</tt> is <i>free</i> in <tt>&phi;</tt> if it is not inside a subformula of <tt>&phi;</tt> of the form <tt>Exists&nbsp;?v (&psi;)</tt> and <tt>&psi;</tt> is a formula.  Universal rules will also be referred to as <i><b><span class="anchor" id="def-rif-bld-rule">RIF-BLD rules</span></b></i>.
  </li>
  <li>
    <i>Universal fact</i>: If <tt>&phi;</tt>  is an atomic formula and <tt>?V<sub>1</sub></tt>, ..., <tt>?V<sub>n</sub></tt>, <tt>n&gt;0</tt>, are distinct variables then
     <tt>Forall&nbsp;?V<sub>1</sub> ...&nbsp;?V<sub>n</sub>(&phi;)</tt> is a formula, called a <i>universal fact</i>, provided that all the free variables in  <tt>&phi;</tt>  occur among the variables <tt>?V<sub>1</sub> ...&nbsp;?V<sub>n</sub></tt>.
    <p>
      Universal facts are often considered to be rules without premises.
    </p>
  </li>
  <li>
    <i>Group</i>: If <tt>&phi;<sub>1</sub></tt>, ..., <tt>&phi;<sub>n</sub></tt> are RIF-BLD rules, universal facts, variable-free rule implications, variable-free atomic formulas, <i>or</i> group formulas then <tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt> is a <i>group formula</i>. As a special case, the empty group formula, <tt>Group()</tt>, is allowed and is treated as a tautology, i.e., a formula that is always true.
    <p>
       Non-empty group formulas are used to represent sets of rules and facts. Note that some of the <tt>&phi;<sub>i</sub></tt>'s can be group formulas themselves, which means that groups can be nested. 
    </p>
  </li>
  <li>  
    <i>Document</i>: An expression of the form <tt>Document(<em>directive<sub>1</sub></em> ... <em>directive<sub>n</sub></em> &Gamma;)</tt> is a <i>RIF-BLD document formula</i> (or simply a <i>document formula</i>), if
    <ul>    
      <li>      
	<tt>&Gamma;</tt> is an optional group formula; it is called the group formula <span id="def-associated-group"><i>associated</i></span> with the document.
      </li>
      <li>
	<tt><em>directive<sub>1</sub></em></tt>, ..., <tt><em>directive<sub>n</sub></em></tt> is an optional sequence of <span id="def-directives"><em>directives</em></span>. A directive can be a <i>base directive</i>, a <i>prefix directive</i> or an <i>import directive</i>. 
      <ul>
	<li>	
	  A <i><b>base directive</b></i> has the form <tt>Base(&lt;iri&gt;)</tt>, where <tt>iri</tt> is a Unicode string in the form of an absolute IRI [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
	  <p>
	    The <tt>Base</tt> directive defines a syntactic shortcut for expanding relative IRIs into full IRIs, as described in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].   This applies to relative IRIs that appear anywhere, including as constants, symbol spaces, locators, and profiles.
	  </p>
	</li>
	<li>	
	   A <i><b>prefix directive</b></i> has the form <tt>Prefix(p &lt;v&gt;)</tt>, where <tt>p</tt> is an alphanumeric string that serves as the prefix name and <tt>v</tt> is an expansion for <tt>p</tt> -- a Unicode sequence of characters that forms an IRI.
	   (An alphanumeric string is a sequence of ASCII characters, where each character is a letter, a digit, or an underscore "_", and the first character is a letter.)
	   <p>
	      Like the <tt>Base</tt> directive, the <tt>Prefix</tt> directives can be used to define shorthands to allow more concise representation of constants that come from the symbol space <tt>rif:iri</tt> (we will call such constants <tt>rif:iri</tt> <i><b>constants</b></i>). This mechanism is explained in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>.
	   </p>
	</li>
	<li>      
	  An <i><b>import directive</b></i> can have one of these two forms: <tt>Import(&lt;loc&gt;)</tt> or <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt>. Here <tt>loc</tt> is a Unicode sequence of characters that forms an IRI and <tt>p</tt> is another Unicode sequence of characters. The constant <tt>loc</tt> represents the location of another document to be imported; it is called the <span class="anchor" id="ref-locator"><i><b>locator</b></i></span> of the imported document. The argument <tt>p</tt> is called the <i>profile of import</i>; it has the form of a Unicode character sequence in the form of an IRI -- see [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
	  <p>
	    Section <a href="#sec-bld-direct-semantics" title="">Direct Specification of RIF-BLD Semantics</a> of this document defines the semantics for the directive <tt>Import(&lt;loc&gt;)</tt> only. The two-argument directive, <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt>, is intended for importing non-RIF-BLD documents, such as rules from other RIF dialects, RDF data, or OWL ontologies. The profile, <tt>p</tt>, indicates what kind of entity is being imported and under what semantics (for instance, the various RDF entailment regimes have different profiles). The semantics of <tt>Import(&lt;loc&gt; &lt;p&gt;)</tt> (for various <tt>p</tt>) are expected to be given by other specifications on a case-by-case basis. For instance, [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>] defines the semantics for the profiles that are recommended for importing RDF and OWL.
	  </p>
	</li>
      </ul>
      <p>
        Note that although <tt>Base</tt>, <tt>Prefix</tt>, and <tt>Import</tt> all use symbols of the form &lt;iri&gt; to indicate the connection of these symbols to IRIs, these symbols are <em>not</em> <tt>rif:iri</tt> constants, as semantically they are interpreted in a way that is quite different from constants.
      </p>
      <p>
        A document formula can contain at most one <tt>Base</tt> directive. The <tt>Base</tt> directive, if present, must be first, followed by any number of <tt>Prefix</tt> directives, followed by any number of <tt>Import</tt> directives.
      </p>
      </li>
    </ul>
  </li>
</ol>
<p>
  In the definition of a formula, the component formulas <tt>&phi;</tt>, <tt>&phi;<sub>i</sub></tt>, <tt>&psi;<sub>i</sub></tt>, and <tt>&Gamma;</tt>  are said to be <span class="anchor" id="def-subformula"><i><b>subformulas</b></i></span> of the respective formulas (condition, rule, group, etc.) that are built using these components. &nbsp;&nbsp;☐
</p>
<p><br />
</p><p><span class="anchor" id="sec-formal-syntax-metadata"></span>
</p>
<a id="RIF-BLD_Annotations_in_the_Presentation_Syntax" name="RIF-BLD_Annotations_in_the_Presentation_Syntax"></a><h4> <span class="mw-headline">2.4  RIF-BLD Annotations in the Presentation Syntax </span></h4>
<p>RIF-BLD allows every term and formula (including terms and formulas that occur inside other terms and formulas) to be optionally preceded by <i>one</i> <i><b>annotation</b></i> of the form <tt>(* id &phi; *)</tt>, where <tt>id</tt> is a <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-iri-space" title="DTB">rif:iri</a></tt> constant and <tt>&phi;</tt> is a frame formula or a conjunction of frame formulas. Both items inside the annotation are optional. The <tt>id</tt> part represents the identifier of the term or formula to which the annotation is attached and <tt>&phi;</tt> is the metadata part of the annotation. RIF-BLD does not impose any restrictions on <tt>&phi;</tt> apart from what is stated above. This means that it may include variables, function symbols, constants from the symbol space <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> (often referred to as <i><b>local</b></i> or <tt>rif:local</tt> <i><b>constants</b></i>), and so on.   
</p><p>Document formulas with and without annotations will be referred to as <i><b><span id="def-rif-bld-document">RIF-BLD documents</span></b></i>.
</p><p>The following convention is used to avoid a syntactic ambiguity with respect to annotations. The annotation scoping convention associates each annotation to the largest term or formula it precedes. For instance, in <tt>(* id &phi; *) t[w -&gt; v]</tt> the metadata annotation could be attributed to the term <tt>t</tt> or to the entire frame <tt>t[w -&gt; v]</tt>. The convention specifies that the above annotation is considered to be syntactically attached to the entire frame. Yet, since <tt>&phi;</tt> can be a conjunction, some conjuncts can be used to provide metadata targeted to the object part, <tt>t</tt>, of the frame. For instance, <tt>(* And(_foo[meta_for_frame-&gt;"this is an annotation for the entire frame"] _bar[meta_for_object-&gt;"this is an annotation for t" meta_for_property-&gt;"this is an annotation for w"]) *) t[w -&gt; v]</tt>. 
</p><p><br />
We suggest to use Dublin Core, RDFS, and OWL properties for metadata, along the lines of <a class="external text" href="http://www.w3.org/TR/owl-ref/#Annotations" rel="nofollow" title="http://www.w3.org/TR/owl-ref/#Annotations">Section 7.1</a> of [<a href="#ref-owl-reference" title="">OWL-Reference</a>]-- specifically <tt>owl:versionInfo</tt>, <tt>rdfs:label</tt>, <tt>rdfs:comment</tt>, <tt>rdfs:seeAlso</tt>, <tt>rdfs:isDefinedBy</tt>, <tt>dc:creator</tt>, <tt>dc:description</tt>, <tt>dc:date</tt>, and <tt>foaf:maker</tt>.
</p><p><span class="anchor" id="sec-well-formed"></span>
</p>
<a id="Well-formed_Formulas" name="Well-formed_Formulas"></a><h4> <span class="mw-headline">2.5  Well-formed Formulas </span></h4>
<p>Not all formulas and thus not all documents are well-formed in RIF-BLD:
it is required that no constant appear in more than one context. What this means precisely is explained below. Informally, this means that each constant symbol in RIF-BLD can be either an individual, a plain function, a plain predicate, an externally defined function, or an externally defined predicate. However, symbols can be <i>polyadic</i>: the same function or predicate symbol (normal or external) can occur with different numbers of arguments in different places. Note that polyadic symbols could be replaced by non-polyadic symbols with the arity information encoded in the function or predicate names. For instance, the polyadic terms <tt>p(?X)</tt>  and <tt>p(?X,?Y)</tt>  could be represented as <tt>p_1(?X)</tt>  and <tt>p_2(?X,?Y)</tt>,  respectively.
</p><p>The set of all constant symbols, <tt>Const</tt>, is partitioned into the following subsets:
</p>
<ul>
  <li>A subset of individuals.
    <p>The symbols in <tt>Const</tt> that belong to the symbol spaces of <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> are required to be individuals.</p>
  </li>
  <li>A subset of plain (i.e., non-external) function symbols.
  </li>
  <li>A subset for external function symbols.
  </li>
  <li>A subset of plain predicate symbols.
  </li>
  <li>A subset for external predicate symbols.
  </li>
</ul>
<p>The above subsets do not differentiate between positional and named argument symbols. Also, as seen from the following definitions, these subsets are not specified explicitly but, rather, are inferred from the occurrences of the symbols.
</p><p><br />
<span class="anchor" id="def-bld-context"></span> 
<b>Definition (Context of a symbol)</b>.
The <i><b>context of an occurrence</b></i> of a symbol, <tt>s&isin;Const</tt>, in a formula, <tt>&phi;</tt>,  is determined as follows:
</p>
<ul>
  <li>
     If <tt>s</tt> occurs as a predicate of the form <tt>s(...)</tt> (positional or named-argument) in an atomic <a href="#def-subformula" title="">subformula</a> of <tt>&phi;</tt> then <tt>s</tt> occurs in the <i>context of a (plain) predicate symbol</i>.     
  </li>
  <li>
     If <tt>s</tt> occurs as a function symbol in a non-subformula term of the form <tt>s(...)</tt> then <tt>s</tt> occurs in the <i>context of a (plain) function symbol</i>.
  </li>
  <li>  
    If <tt>s</tt> occurs as a predicate in an atomic subformula <tt>External(s(...))</tt> then <tt>s</tt> occurs in the <i>context of an external predicate symbol</i>.
  </li>
  <li>  
    If <tt>s</tt> occurs as a function in a non-subformula term <tt>External(s(...))</tt> then <tt>s</tt> occurs in the <i>context of an external function symbol</i>.
  </li>
  <li>  
     If <tt>s</tt> occurs in any other context (in a frame: <tt>s[...]</tt>, <tt>...[s-&gt;...]</tt>, or <tt>...[...-&gt;s]</tt>; or in a positional/named-argument term: <tt>p(...s...)</tt>, <tt>q(...-&gt;s...)</tt>), it is said to occur as an <i>individual</i>. &nbsp;&nbsp;☐
  </li>
</ul>
<p><span class="anchor" id="def-bld-imported-doc"></span> 
<b>Definition (Imported document).</b>
Let <tt>&Delta;</tt> be a document formula and <tt>Import(<i>loc</i>)</tt> be one of its import directives, where <i>loc</i> is a <a href="#ref-locator" title="">locator</a> of another document formula, <tt>&Delta;'</tt>.  We say that <tt>&Delta;'</tt> is <i><b>directly imported</b></i> into <tt>&Delta;</tt>.
</p><p>A document formula <tt>&Delta;'</tt> is said to be <i><b>imported</b></i> into
<tt>&Delta;</tt> if it is either directly imported into <tt>&Delta;</tt> or it is imported (directly or not) into some other formula that is directly imported into <tt>&Delta;</tt>. &nbsp; &nbsp; ☐  
</p><p>The above definition deals only with one-argument import directives, since 
only such directives can be used to import other RIF-BLD documents.
Two-argument import directives are provided to enable import of other types of documents, and their semantics are supposed to be covered by other specifications, such as [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p><br />
<span class="anchor" id="def-bld-wff"></span> 
<b>Definition (Well-formed formula)</b>.
A formula <tt>&phi;</tt>  is <i><b>well-formed</b></i> iff:
</p>
<ul>
  <li>
    every constant symbol (whether coming from the symbol space <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> or not) mentioned in <tt>&phi;</tt> occurs in exactly one <a href="#def-bld-context" title="">context</a>.
  </li>
  <li>  
    if <tt>&phi;</tt> is a document formula and <tt>&Delta;'<sub>1</sub></tt>, ..., <tt>&Delta;'<sub>k</sub></tt> are all of its imported documents, then every non-<tt>rif:local</tt> constant symbol mentioned in <tt>&phi;</tt> or any of the imported <tt>&Delta;'<sub>i</sub></tt>s must occur in exactly one context (in all of the <tt>&Delta;'<sub>i</sub></tt>s).
  </li>
  <li>
    whenever a formula contains a term or a subformula of the form <tt>External(t)</tt>, <tt>t</tt> must be an instantiation of a schema in the coherent set of external schemas (Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#app-external-schema" title="DTB">Schemas for Externally Defined Terms</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) associated with the <a href="#def-bld-lang" title="">language of RIF-BLD</a>.
  </li>
  <li>
    if <tt>t</tt> is an instantiation of a schema in the coherent set of external schemas associated with the language then <tt>t</tt> can occur only as <tt>External(t)</tt>, i.e., as an external term or atomic formula. &nbsp;&nbsp;☐
  </li>
</ul>
<p><br />
<span class="anchor" id="def-bld-lang"></span> 
<b>Definition (Language of RIF-BLD)</b>.
The <i><b>language of RIF-BLD</b></i> consists of the set of all well-formed formulas and is determined by:
</p>
<ul><li> the alphabet of the language and
</li><li> a  set of <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">coherent external schemas</a>, which determine the available built-ins and other externally defined predicates and functions. &nbsp;&nbsp;☐
</li></ul>
<p><br />
<span class="anchor" id="sec-concrete-syntax"></span>
</p>
<a id="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29" name="EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29"></a><h4> <span class="mw-headline">2.6  EBNF Grammar for the Presentation Syntax of RIF-BLD (Informative) </span></h4>
<p>Until now, we have been using mathematical English to specify the syntax of RIF-BLD. Tool developers, however, may prefer EBNF notation, which provides a more succinct view of the syntax. Several points should be kept in mind regarding this notation. 
</p>
<ul><li> The syntax of first-order logic is not context-free, so EBNF cannot capture the syntax of RIF-BLD precisely. For instance, it cannot capture some <a href="#sec-well-formed" title="">well-formedness conditions</a>, such as the requirement that external terms must be instances of external schemas. As a result, the EBNF grammar defines a strict <i>superset</i> of RIF-BLD: not all formulas that are derivable using the EBNF grammar are well-formed formulas in RIF-BLD. 
</li><li> The EBNF grammar does not address all details of how constants (defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]) and variables are represented, and it is not sufficiently precise about the delimiters and escape symbols. White space is informally used as a delimiter, and is implied in productions that use Kleene star. For instance, <tt>TERM*</tt> is to be understood as <tt>TERM&nbsp;TERM&nbsp;...&nbsp;TERM</tt>, where each space abstracts from one or more blanks, tabs, newlines, etc. This is so because RIF's presentation syntax is a tool for specifying the semantics and for illustration of the main RIF concepts through examples. It is <i>not</i> intended as a concrete syntax for a rule language. RIF defines a concrete syntax only for <i>exchanging</i> rules, and that syntax is XML-based, obtained as a refinement and serialization of the presentation syntax.
</li><li> For all the above reasons, the EBNF grammar is <i>not normative</i>. Recall from the <a href="#sec-bld-direct-syntax" title="">opening paragraph</a>, however, that the RIF-BLD presentation syntax as specified in mathematical English is normative.
</li></ul>
<p>The EBNF for the RIF-BLD presentation syntax is given as follows, showing the entire (top-down) context of its three parts for rules, conditions, and annotations.
</p><p><span class="anchor" id="part-rule-language"></span>
<b>Rule Language:</b>
</p>
<pre>  Document      &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base          &nbsp;::= 'Base' '(' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'
  Prefix        &nbsp;::= 'Prefix' '(' <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> ')'
  Import        &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group         &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE          &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE        &nbsp;::= Implies | ATOMIC
  Implies       &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR       &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a>
  PROFILE       &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a>
</pre>
<p><span class="anchor" id="part-condition-language"></span>
<b>Condition Language:</b>
</p>
<pre>  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Subclass      &nbsp;::= TERM '##' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  Const         &nbsp;::= '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"^^' SYMSPACE | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CONSTSHORT</a>
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= <a class="external text" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-NCName">NCName</a> | '"' <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">UNICODESTRING</a> '"'
  SYMSPACE      &nbsp;::= <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">ANGLEBRACKIRI</a> | <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">CURIE</a>
</pre>
<p><span class="anchor" id="part-annotations"></span>
<b>Annotations:</b>
</p>
<pre>  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
</pre>
<p>The following subsections explain and exemplify these parts, starting with the basic language of positive conditions.
</p><p><br />
<span class="anchor" id="sec-ebnf-condition-language"></span> 
</p>
<a id="EBNF_for_the_Condition_Language" name="EBNF_for_the_Condition_Language"></a><h5> <span class="mw-headline">2.6.1  EBNF for the Condition Language </span></h5>
<p>The Condition Language represents formulas that can be used in the premises of RIF-BLD rules (also called rule bodies). The EBNF grammar for a superset of the RIF-BLD condition language is shown in the above <a href="#part-condition-language" title="">conditions part</a>.
</p><p>The production rule for the non-terminal <tt>FORMULA</tt> represents <i>RIF condition formulas</i> (defined earlier). The connectives <tt>And</tt> and <tt>Or</tt> define conjunctions and disjunctions of conditions, respectively. <tt>Exists</tt> introduces existentially quantified variables. Here <tt>Var+</tt> stands for the list of variables that are free in <tt>FORMULA</tt>.  A RIF-BLD <tt>FORMULA</tt> can also be an <tt>ATOMIC</tt> term, i.e. an <tt>Atom</tt>, <tt>External</tt> <tt>Atom</tt>, <tt>Equal</tt>, <tt>Member</tt>, <tt>Subclass</tt>, or <tt>Frame</tt>. A <tt>TERM</tt> can be a constant, variable, <tt>Expr</tt>, <tt>List</tt>, or <tt>External</tt> <tt>Expr</tt>.
</p><p>The RIF-BLD presentation syntax does not commit to any particular vocabulary and permits arbitrary Unicode strings in constant symbols, argument names, and variables. Constant symbols can have this form: <tt>"UNICODESTRING"^^SYMSPACE</tt>, where <tt>SYMSPACE</tt> is an <tt>ANGLEBRACKIRI</tt> or <tt>CURIE</tt> that represents the identifier of the symbol space of the constant. <tt>UNICODESTRING</tt>, <tt>ANGLEBRACKIRI</tt>, and <tt>CURIE</tt> are defined in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-shortcuts-constants" title="DTB">Shortcuts for Constants in RIF's Presentation Syntax</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. Constant symbols can also have several shortcut forms, which are represented by the non-terminal <tt>CONSTSHORT</tt>. These shortcuts are also defined in the same section of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. One of them is the <tt>CURIE</tt> shortcut, which is extensively used in the examples in this document.
Names are Unicode character sequences. Variables are composed of <tt>UNICODESTRING</tt> symbols prefixed with a <tt>?</tt>-sign.
</p><p>Equality, membership, and subclass terms are self-explanatory. An <tt>Atom</tt> and <tt>Expr</tt> (expression) can either be positional or have named arguments. A frame term is a term composed of an object identifier and a collection of attribute-value pairs. The term <tt>External</tt>(<tt>Atom</tt>) is a call to an externally defined predicate. Likewise, <tt>External</tt>(<tt>Expr</tt>) is a call to an externally defined function.
</p><p><br />
<span class="anchor" id="ex-rif-bld-cond-pres-syntax">
<b>Example 3</b> (RIF-BLD conditions).
</span>
</p><p>This example shows conditions that are composed of atoms, expressions, equalities with lists, frames, and existentials. In frame formulas, variables are shown in the positions of object identifiers, object properties, and property values. For brevity, we use the shortcut CURIE notation <tt>prefix:suffix</tt> for constant symbols defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. This is understood as a shorthand for an IRI obtained by concatenation of the <tt>prefix</tt>  definition and <tt>suffix</tt>. Thus, if <tt>bks</tt> is a prefix that expands into <tt>http://example.com/books#</tt> then <tt>bks:LeRif</tt> is an abbreviation for <tt>"http://example.com/books#LeRif"^^rif:iri</tt>. 
</p>
<pre>Prefix(bks  &lt;http://example.com/books#&gt;)
Prefix(auth &lt;http://example.com/authors#&gt;)
Prefix(cpt  &lt;http://example.com/concepts#&gt;)

</pre>
<p>Positional terms:
</p>
<pre>  cpt:book(auth:rifwg bks:LeRif)
  Exists&nbsp;?X (cpt:book(?X bks:LeRif))

</pre>
<p>Terms with named arguments:
</p>
<pre>  cpt:book(cpt:author-&gt;auth:rifwg  cpt:title-&gt;bks:LeRif)
  Exists&nbsp;?X (cpt:book(cpt:author-&gt;?X cpt:title-&gt;bks:LeRif))

</pre>
<p>Equalities with list terms:
</p>
<pre> &nbsp;?L = List(?X&nbsp;?Y&nbsp;?X)
  List(?Head |&nbsp;?Tail) = List("a"^^rif:local&nbsp;?Y "c"^^rif:local)

</pre>
<p>Frames:
</p>
<pre>  bks:wd1[cpt:author-&gt;auth:rifwg cpt:title-&gt;bks:LeRif]
  Exists&nbsp;?X (bks:wd2[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif])
  Exists&nbsp;?X (And (bks:wd2#cpt:book  bks:wd2[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif]))
  Exists&nbsp;?I&nbsp;?X (?I[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif])
  Exists&nbsp;?I&nbsp;?X (And (?I#cpt:book&nbsp;?I[cpt:author-&gt;?X  cpt:title-&gt;bks:LeRif]))
  Exists&nbsp;?S (bks:wd2[cpt:author-&gt;auth:rifwg&nbsp;?S-&gt;bks:LeRif])
  Exists&nbsp;?X&nbsp;?S (bks:wd2[cpt:author-&gt;?X&nbsp;?S-&gt;bks:LeRif])
  Exists&nbsp;?I&nbsp;?X&nbsp;?S (And (?I#cpt:book &nbsp;?I[author-&gt;?X&nbsp;?S-&gt;bks:LeRif]))
</pre>
<p><br />
</p><p><span class="anchor" id="sec-ebnf-rule-language"></span>
</p>
<a id="EBNF_for_the_Rule_Language" name="EBNF_for_the_Rule_Language"></a><h5> <span class="mw-headline">2.6.2  EBNF for the Rule Language </span></h5>
<p>The presentation syntax for RIF-BLD rules is based on the syntax in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a> with the productions shown in the above <a href="#part-rule-language" title="">rules part</a>.
</p><p><span class="anchor" id="document-preamble"></span>
A RIF-BLD <tt>Document</tt> consists of an optional <tt>Base</tt>, followed by any number of <tt>Prefix</tt>es, followed by any number of <tt>Import</tt>s, followed by an optional <tt>Group</tt>.
<tt>Base</tt> and <tt>Prefix</tt> serve as shortcut mechanisms for IRIs.
<tt>IRI</tt> has the form of an internationalized resource identifier as defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
An <tt>Import</tt> indicates the location of a document to be imported and an optional profile.
A RIF-BLD <tt>Group</tt> is a collection of
any number of <tt>RULE</tt> elements along with any number of nested <tt>Group</tt>s.
</p><p>Rules are generated using <tt>CLAUSE</tt> elements. The <tt>RULE</tt>  production has two alternatives:
</p>
<ul><li> In the first, a <tt>CLAUSE</tt>  is in the scope of the <tt>Forall</tt> quantifier. In that case, all variables mentioned in  <tt>CLAUSE</tt> are required to also appear among the variables in the <tt>Var+</tt> sequence.
</li><li> In the second alternative, <tt>CLAUSE</tt> appears on its own. In that case, <tt>CLAUSE</tt> cannot have variables. 
</li></ul>
<p><tt>Var</tt>, <tt>ATOMIC</tt>, and <tt>FORMULA</tt> were defined as part of the syntax for positive conditions in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a>. In the <tt>CLAUSE</tt> production, an <tt>ATOMIC</tt> is what is usually called a <i>fact</i>. An <tt>Implies</tt> <i>rule</i> can have an <tt>ATOMIC</tt> or a conjunction of <tt>ATOMIC</tt> elements as its conclusion; it has a <tt>FORMULA</tt> as its premise. Note that, by the <a href="#def-bld-formula" title="">definition of formulas</a>, externally defined atoms (i.e., formulas of the form <tt>External(Atom)</tt>) are not allowed in the conclusion part of a rule (<tt>ATOMIC</tt> does not expand to <tt>External</tt>).
</p><p><br />
</p><p><span class="anchor" id="ex-rif-bld-rule-pres-syntax">
<b>Example 4</b> (RIF-BLD rules).
</span>
</p><p>This example shows a business rule borrowed from the document <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/" title="UCR">RIF Use Cases and Requirements</a>:
</p>
<ul>
  <li>
    <em>
      If an item is perishable and it is delivered to John more than 10 days
      after the scheduled delivery date then the item will be rejected by him.
    </em>
  </li>
</ul>
<p>As before, for better readability we use the compact URI notation, the angle-bracket notation, and the <tt>Base</tt> directive defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>. Again, directives are assumed in the preamble to the document.
Then, two versions of the main part of the document are given.
</p>
<pre>Base(&lt;http://example.com/people#&gt;)
Prefix(cpt  &lt;http://example.com/concepts#&gt;)
Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)

</pre>
<p>a. Universal form:
</p>
<pre>   Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(&lt;John&gt;&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate &lt;John&gt;)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
   )

</pre>
<p>b. Universal-existential form:
</p>
<pre>   Forall&nbsp;?item (
        cpt:reject(&lt;John&gt;&nbsp;?item )&nbsp;:-
            Exists&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
                 And(cpt:perishable(?item)
                     cpt:delivered(?item&nbsp;?deliverydate &lt;John&gt;)
                     cpt:scheduled(?item&nbsp;?scheduledate)
                    &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
                    &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                     External(pred:numeric-greater-than(?diffdays 10)))
            )
   )
</pre>
<p><br />
</p><p><span class="anchor" id="sec-ebnf-annotations"></span>
</p>
<a id="EBNF_for_Annotations" name="EBNF_for_Annotations"></a><h5> <span class="mw-headline">2.6.3  EBNF for Annotations </span></h5>
<p>The EBNF grammar production for RIF-BLD annotations is shown in the above <a href="#part-annotations" title="">annotations part</a>.
</p><p>As explained in Section <a href="#sec-formal-syntax-metadata" title="">RIF-BLD Annotations in the Presentation Syntax</a>, each RIF-BLD formula and term can be preceded by one optional annotation, <tt>IRIMETA</tt>, for identification and metadata.
<tt>IRIMETA</tt> is represented using <tt>(*...*)</tt>-brackets
that contain an optional <tt>rif:iri</tt> constant, <tt>IRICONST</tt>, as identifier followed by
an optional <tt>Frame</tt> or conjunction of <tt>Frame</tt>s as metadata.
</p><p>An <tt>IRICONST</tt> is <tt>rif:iri</tt> constant,
again permitting the shortcut forms defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
One such specialization is <tt>'"' IRI '"^^' 'rif:iri'</tt> from the <tt>Const</tt> production, where <tt>IRI</tt> is a sequence of Unicode characters that forms an internationalized resource identifier as defined by [<a href="#ref-rfc-3987" title="">RFC-3987</a>].
</p><p><br />
</p><p><span class="anchor" id="ex-rif-bld-annotatedgroup-pres-syntax">
<b>Example 5</b> (A RIF-BLD document containing an annotated group).
</span>
</p><p>This example shows a complete document containing a group formula that consists of two RIF-BLD rules. The first of these rules is copied from Example 4a. The group is annotated with an IRI identifier and metadata represented using Dublin Core vocabulary.
</p>
<pre>Document(
  Base(&lt;http://example.com/people#&gt;)
  Prefix(cpt  &lt;http://example.com/concepts#&gt;)
  Prefix(dc   &lt;http://purl.org/dc/terms/&gt;)
  Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
  Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)
  Prefix(xs   &lt;http://www.w3.org/2001/XMLSchema#&gt;)
  
  (* "http://sample.org"^^rif:iri _pd[dc:publisher -&gt; "http://www.w3.org/"^^rif:iri
                                      dc:date -&gt; "2008-04-04"^^xs:date] *)
  Group
  (
    Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(&lt;John&gt;&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate &lt;John&gt;)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
    )
 
    Forall&nbsp;?item (
        cpt:reject(&lt;Fred&gt;&nbsp;?item)&nbsp;:- cpt:unsolicited(?item)
    )
  )
)
</pre>
<p><br />
</p><p><br />
<span class="anchor" id="sec-bld-direct-semantics"></span>
</p>
<a id="Direct_Specification_of_RIF-BLD_Semantics" name="Direct_Specification_of_RIF-BLD_Semantics"></a><h2> <span class="mw-headline">3  Direct Specification of RIF-BLD Semantics </span></h2>
<p>This normative section specifies the semantics of RIF-BLD directly, without
relying on [<a href="#ref-rif-fld" title="">RIF-FLD</a>].
</p><p>Recall that the presentation syntax of RIF-BLD allows shorthand notation,
which is specified via the <tt>Prefix</tt>  and <tt>Base</tt> directives, and various shortcuts for integers, strings, and <tt>rif:local</tt> symbols.
The semantics, below, is described using the full syntax, i.e., we
assume that all shortcuts have already been expanded as defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a>.
</p><p><span class="anchor" id="sec-truth-values"></span> 
</p>
<a id="Truth_Values" name="Truth_Values"></a><h4> <span class="mw-headline">3.1  Truth Values </span></h4>
<p>The set <i><b>TV</b></i> of truth values in RIF-BLD consists of two values, <b>t</b> and <b>f</b>.
</p><p><span class="anchor" id="sec-model-theory"></span>
</p>
<a id="Semantic_Structures" name="Semantic_Structures"></a><h4> <span class="mw-headline">3.2  Semantic Structures </span></h4>
<p>The key concept in a model-theoretic semantics for a logic language is the notion of a <i>semantic structure</i> [<a href="#ref-enderton01" title="">Enderton01</a>, <a href="#ref-mendelson97" title="">Mendelson97</a>]. The definition is slightly more general than what is strictly necessary for RIF-BLD alone. This lays the groundwork for extensions to RIF-BLD and makes the connection with the <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-fld-semantic-framework" title="FLD">semantics of the RIF framework for logic-based dialects</a> [<a href="#ref-rif-fld" title="">RIF-FLD</a>] more obvious.
</p><p><span class="anchor" id="def-bld-sem-struct"></span> 
<b>Definition (Semantic structure)</b>.
A <i><b>semantic structure</b></i>, <i><b>I</b></i>, is a tuple of the form
&lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>,
<i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i><sub>V</sub>,
<i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>,
<i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>,
<i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;. Here <i><b>D</b></i> is a non-empty set of elements called the <i><b>domain</b></i> of <i><b>I</b></i>, and <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub> are nonempty subsets of <i><b>D</b></i>. <i><b>D</b></i><sub>ind</sub> is used to interpret the elements of <tt>Const</tt> that <a href="#def-bld-context" title="">occur as</a> individuals and <i><b>D</b></i><sub>func</sub> is used to interpret the elements of <tt>Const</tt> that <a href="#def-bld-context" title="">occur in the context of</a> function symbols. As before, <tt>Const</tt> denotes the set of all constant symbols and <tt>Var</tt> the set of all variable symbols. <i><b>DTS</b></i> denotes a set of identifiers for datatypes (please refer to Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] for the semantics of datatypes). 
</p><p>The other components of <i><b>I</b></i> are <i>total</i> mappings defined as follows: 
</p>
<ol>
  <li>
    <i><b>I</b></i><sub>C</sub> maps <tt>Const</tt> to <i><b>D</b></i>.
    <p>
      This mapping interprets constant symbols. In addition:
    </p>
    <ul>
      <li>
	If a constant, <tt>c</tt>&nbsp;&isin;&nbsp;<tt>Const</tt>,
	is an <i>individual</i> then it is required that
	<i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;&isin;&nbsp;<i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>
	If <tt>c</tt>&nbsp;&isin;&nbsp;<tt>Const</tt>, is a <i>function symbol</i> (positional or with named arguments) then it is required that <i><b>I</b></i><sub>C</sub>(<tt>c</tt>)&nbsp;&isin;&nbsp;<i><b>D</b></i><sub>func</sub>.
      </li>
    </ul>
  </li>
  <li>
    <i><b>I</b></i><sub>V</sub> maps <tt>Var</tt> to <i><b>D</b></i><sub>ind</sub>.
    <p>This mapping interprets variable symbols.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>F</sub> maps <i><b>D</b></i> to total functions <i><b>D*</b></i><sub>ind</sub> &rarr; <i><b>D</b></i> (here <i><b>D*</b></i><sub>ind</sub> is a set of all finite sequences over the domain <i><b>D</b></i><sub>ind</sub>).
    <p>This mapping interprets positional terms. In addition: </p>
    <ul>
      <li>If <tt>d</tt> &isin; <i><b>D</b></i><sub>func</sub> then <i><b>I</b></i><sub>F</sub>(<tt>d</tt>) must be a function <i><b>D*</b></i><sub>ind</sub> &rarr; <i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>This means that when a function symbol is applied to arguments that are individual objects then the result is also an individual object.
      </li>
    </ul>
  </li>
  <li><i><b>I</b></i><sub>NF</sub> maps <i><b>D</b></i> to the set of total functions of the form <tt>SetOfFiniteSets</tt>(<tt>ArgNames</tt> &times; <i><b>D</b></i><sub>ind</sub>) &rarr; <i><b>D</b></i>.
    <p>This mapping interprets function symbols with named arguments. In addition:</p>
    <ul>
      <li>If <tt>d</tt> &isin; <i><b>D</b></i><sub>func</sub> then <i><b>I</b></i><sub>NF</sub>(<tt>d</tt>) must be a function <tt>SetOfFiniteSets</tt>(<tt>ArgNames</tt> &times; <i><b>D</b></i><sub>ind</sub>) &rarr; <i><b>D</b></i><sub>ind</sub>.
      </li>
      <li>This is analogous to the interpretation of positional terms with two differences:
        <ul>
          <li>Each pair &lt;<tt>s,v</tt>&gt; &isin; <tt>ArgNames</tt> &times; <i><b>D</b></i><sub>ind</sub> represents an argument/value pair instead of just a value in the case of a positional term. </li>
          <li>The arguments of a term with named arguments constitute a finite set of argument/value pairs rather than a finite ordered sequence of simple elements.  So, the order of the arguments does not matter.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>  
     <i><b>I</b></i><sub>list</sub> and <i><b>I</b></i><sub>tail</sub> are used to interpret lists. They are mappings of the following form:
     <ul>     
       <li>
	 <i><b>I</b></i><sub>list</sub>&nbsp;: <i><b>D</b></i><sub>ind</sub><sup>*</sup> &rarr; <i><b>D</b></i><sub>ind</sub> 
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>&nbsp;: <i><b>D</b></i><sub>ind</sub><sup>+</sup>&times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i><sub>ind</sub> 
       </li>
     </ul>
     <p>
        In addition, these mappings are required to satisfy the following conditions:
     </p>
     <ul>     
       <li>
	The function <i><b>I</b></i><sub>list</sub> is injective (one-to-one).
       </li>
       <li>
	 The set <i><b>I</b></i><sub>list</sub>(<i><b>D</b></i><sub>ind</sub><sup>*</sup>), henceforth denoted <span class="anchor" id="def-Dlist"><i><b>D</b></i><sub>list</sub></span>, is disjoint from the value spaces of all data types in <i><b>DTS</b></i>.
       </li>
       <li>
	 <i><b>I</b></i><sub>tail</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>)) = <i><b>I</b></i><sub>list</sub>(<tt>a</tt><sub>1</sub>, ..., <tt>a</tt><sub>k</sub>, <tt>a</tt><sub>k+1</sub>, ..., <tt>a</tt><sub>k+m</sub>). 
       </li>
     </ul>
     <p>
       Note that the last condition above restricts <i><b>I</b></i><sub>tail</sub> only when its last argument is in <i><b>D</b></i><sub>list</sub>. If the last argument of <i><b>I</b></i><sub>tail</sub> is not in <i><b>D</b></i><sub>list</sub>, then the list is a general open one and there are no restrictions on the value of <i><b>I</b></i><sub>tail</sub> except that it must be in <i><b>D</b></i><sub>ind</sub>.
     </p>
  </li>
  <li><i><b>I</b></i><sub>frame</sub> maps <i><b>D</b></i><sub>ind</sub> to total functions of the form <tt>SetOfFiniteBags</tt>(<i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub>) &rarr; <i><b>D</b></i>.
    <p>This mapping interprets frame terms. An argument, <tt>d</tt> &isin; <i><b>D</b></i><sub>ind</sub>, to <i><b>I</b></i><sub>frame</sub> represents an object and the finite bag {&lt;<tt>a1,v1</tt>&gt;, ..., &lt;<tt>ak,vk</tt>&gt;} represents a bag of attribute-value pairs for <tt>d</tt>. We will see shortly how <i><b>I</b></i><sub>frame</sub> is used to determine the truth valuation of frame terms. </p>
    <p>Bags (multi-sets) are used here because the order of the attribute/value pairs in a frame is immaterial and pairs may repeat. Such repetitions arise naturally when variables are instantiated with constants. For instance, <tt>o[?A-&gt;?B&nbsp;?C-&gt;?D]</tt> becomes <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> if variables <tt>?A</tt> and <tt>?C</tt> are instantiated with the symbol <tt>a</tt> while <tt>?B</tt> and <tt>?D</tt> are instantiated with <tt>b</tt>. (We shall see later that <tt>o[a-&gt;b&nbsp;a-&gt;b]</tt> is equivalent to <tt>o[a-&gt;b]</tt>.)
    </p>
  </li>
  <li><i><b>I</b></i><sub>sub</sub> gives meaning to the subclass relationship. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>
    <i><b>I</b></i><sub>sub</sub> will be further restricted in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a> to ensure that
    the operator <tt>##</tt> is transitive, i.e., that <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>isa</sub> gives meaning to class membership. It is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>
    <i><b>I</b></i><sub>isa</sub> will be further restricted in Section <a href="#sec-interpretation-of-formulas" title="">Interpretation of Formulas</a> to ensure that
    the relationships <tt>#</tt> and <tt>##</tt> have the usual property that all members of a subclass are also members of the superclass, i.e., that <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> imply <tt>o&nbsp;#&nbsp;scl</tt>.
    </p>
  </li>
  <li><i><b>I</b></i><sub>=</sub> is a mapping of the form <i><b>D</b></i><sub>ind</sub> &times; <i><b>D</b></i><sub>ind</sub> &rarr; <i><b>D</b></i>.
    <p>It gives meaning to the equality operator.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>truth</sub> is a mapping of the form <i><b>D</b></i> &rarr; <i><b>TV</b></i>.
     <p>It is used to define truth valuation for formulas.</p>
  </li>
  <li>
    <i><b>I</b></i><sub>external</sub> is a mapping from the coherent set of schemas for externally defined functions to total functions <i><b>D</b></i>* &rarr; <i><b>D</b></i>. For each external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;)</tt> in the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">coherent set of external schemas</a> associated with the <a href="#def-bld-lang" title="">language</a>, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is a function of the form <i><b>D</b></i><sup>n</sup> &rarr; <i><b>D</b></i>.
    <p>
      For every external schema, <tt>&sigma;</tt>,  associated with the language, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is assumed to be specified externally in some document (hence the name <i>external schema</i>). In particular, if <tt>&sigma;</tt> is a schema of a RIF built-in predicate or function, <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) is specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] so that:
    </p>
      <ul>
        <li>
          If <tt>&sigma;</tt> is a schema of a built-in function then <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>) must be the function defined in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
        </li>
        <li>
          If <tt>&sigma;</tt> is a schema of a built-in predicate then 
          <i><b>I</b></i><sub>truth</sub><tt> &omicron; </tt>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)) (the composition of <i><b>I</b></i><sub>truth</sub> and <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>), a truth-valued function) must be as specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
        </li>
      </ul>
  </li>
</ol>
<p>
  We also define the following mapping from terms to <i><b>D</b></i>, which we denote using the same symbol <i><b>I</b></i> as the one used for semantic structures. This overloading is convenient and creates no ambiguity.
</p>
<ul>
  <li>
    <i><b>I</b></i>(<tt>k</tt>) = <i><b>I</b></i><sub>C</sub>(<tt>k</tt>), if <tt>k</tt> is a symbol in <tt>Const</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>?v</tt>) = <i><b>I</b></i><sub>V</sub>(<tt>?v</tt>), if <tt>?v</tt> is a variable in <tt>Var</tt>
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>F</sub>(<i><b>I</b></i>(<tt>f</tt>))(<i><b>I</b></i>(<tt>t<sub>1</sub></tt>),...,<i><b>I</b></i>(<tt>t<sub>n</sub></tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>f(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>n</sub>-&gt;v<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>NF</sub>(<i><b>I</b></i>(<tt>f</tt>))({&lt;<tt>s<sub>1</sub></tt>,<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;,...,&lt;<tt>s<sub>n</sub></tt>,<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
  <p>
    Here we use {...} to denote a set of argument/value pairs. 
  </p>
  </li>
  <li>  
     For list terms, the mapping is defined as follows:
     <ul>     
       <li>
	 <i><b>I</b></i>(<tt>List()</tt>) = <i><b>I</b></i><sub>list</sub>(<tt>&lt;&gt;</tt>). 
	 <p>
	   Here <tt>&lt;&gt;</tt> denotes an empty list of elements of <i><b>D</b></i><sub>ind</sub>. (Note that the domain of <i><b>I</b></i><sub>list</sub> is <i><b>D</b></i><sub>ind</sub><sup>*</sup>, so <i><b>D</b></i><sub>ind</sub><sup>0</sup> is an empty list of elements of <i><b>D</b></i><sub>ind</sub>.)
	 </p>
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>n</sub>)) = <i><b>I</b></i><sub>list</sub>(<i><b>I</b></i>(<tt>t</tt><sub>1</sub>), ..., <i><b>I</b></i>(<tt>t</tt><sub>n</sub>)), if <tt>n&gt;0</tt>. 
       </li>
       <li>
	 <i><b>I</b></i>(<tt>List(t</tt><sub>1</sub> ... <tt>t</tt><sub>n</sub> | <tt>t</tt>)) = <i><b>I</b></i><sub>tail</sub>(<i><b>I</b></i>(<tt>t</tt><sub>1</sub>), ..., <i><b>I</b></i>(<tt>t</tt><sub>n</sub>), <i><b>I</b></i>(<tt>t</tt>)), if <tt>n&gt;0</tt>. 
       </li>
     </ul>
  </li>
  <li>
    <i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>frame</sub>(<i><b>I</b></i>(<tt>o</tt>))({&lt;<i><b>I</b></i>(<tt>a<sub>1</sub></tt>),<i><b>I</b></i>(<tt>v<sub>1</sub></tt>)&gt;, ..., &lt;<i><b>I</b></i>(<tt>a<sub>n</sub></tt>),<i><b>I</b></i>(<tt>v<sub>n</sub></tt>)&gt;})
  <p>
    Here {...} denotes a bag of attribute/value pairs. Jumping ahead, we note that duplicate elements in such a bag do not affect the truth value of a frame formula. Thus, for instance, <tt>o[a-&gt;b a-&gt;b]</tt> and <tt>o[a-&gt;b]</tt> always have the same truth value.
  </p>
  </li>
  <li>
    <i><b>I</b></i>(<tt>c1##c2</tt>) = <i><b>I</b></i><sub>sub</sub>(<i><b>I</b></i>(<tt>c1</tt>), <i><b>I</b></i>(<tt>c2</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>o#c</tt>) = <i><b>I</b></i><sub>isa</sub>(<i><b>I</b></i>(<tt>o</tt>), <i><b>I</b></i>(<tt>c</tt>))
  </li>
  <li>
    <i><b>I</b></i>(<tt>x=y</tt>) = <i><b>I</b></i><sub>=</sub>(<i><b>I</b></i>(x), <i><b>I</b></i>(y))
  </li>
  <li>
    <i><b>I</b></i>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>)), if <tt>t</tt> is an instantiation of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>;&nbsp;&tau;)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instantiation of an external schema. Furthermore, by the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">definition of coherent sets of external schemas</a>, <tt>t</tt> can be an instantiation of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined.
    </p>
  </li>
</ul>
<p>Note that the definitions of <i><b>I</b></i><sub>NF</sub> and <i><b>I</b></i>(<tt>x=y</tt>) imply that the terms with named arguments that differ only in the order of their arguments are mapped by <i><b>I</b></i> to the same element in the domain. This implies that the equalities like <tt>t(a-&gt;1 b-&gt;2 c-&gt;3) = t(c-&gt;3 a-&gt;1 b-&gt;2)</tt> are tautologies in RIF-BLD.
</p><p><i><b>The effect of datatypes.</b></i> The set <i><b>DTS</b></i> must include the datatypes described in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
</p><p><br />
The datatype identifiers in <i><b>DTS</b></i> impose the following restrictions. Given <tt>dt</tt> &isin; <i><b>DTS</b></i>, let <i><b>LS</b></i><sub>dt</sub> denote the lexical space of <tt>dt</tt>, <i><b>VS</b></i><sub>dt</sub> denote its value space, and <i><b>L</b></i><sub>dt</sub>: <i><b>LS</b></i><sub>dt</sub> &rarr; <i><b>VS</b></i><sub>dt</sub> the lexical-to-value-space mapping (for the definitions of these concepts, see Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]). Then the following must hold: 
</p>
<ul><li> <i><b>VS</b></i><sub>dt</sub> &sube; <i><b>D</b></i><sub>ind</sub>; and
</li><li> For each constant <tt>"lit"^^dt</tt> such that <tt>lit</tt> &isin; <i><b>LS</b></i><sub>dt</sub>, <i><b>I</b></i><sub>C</sub>(<tt>"lit"^^dt</tt>) = <i><b>L</b></i><sub>dt</sub>(<tt>lit</tt>). 
</li></ul>
<p>That is, <i><b>I</b></i><sub>C</sub> must map the constants of a datatype <tt>dt</tt> in accordance with <i><b>L</b></i><sub>dt</sub>. 
</p><p>RIF-BLD does not impose restrictions on <i><b>I</b></i><sub>C</sub> for constants in symbol spaces that are not datatypes included in <i><b>DTS</b></i>.  &nbsp;&nbsp;☐
</p><p><br />
</p><p><span class="anchor" id="sec-semantics-metadata"></span>
</p>
<a id="RIF-BLD_Annotations_in_the_Semantics" name="RIF-BLD_Annotations_in_the_Semantics"></a><h4> <span class="mw-headline">3.3  RIF-BLD Annotations in the Semantics </span></h4>
<p>RIF-BLD annotations are stripped before the mappings that constitute RIF-BLD semantic structures are applied. Likewise, they are stripped before applying the truth valuation, <i>TVal</i><sub>I</sub>, defined in the next section. Thus, identifiers and metadata have no effect on the formal semantics.
</p><p>Note that although identifiers and metadata associated with RIF-BLD formulas are ignored by the semantics, they can be extracted by XML tools. The frame terms used to represent RIF-BLD metadata can then be fed to other RIF-BLD rules, thus enabling reasoning about metadata. RIF-BLD does not define any particular semantics for metadata, however.
</p><p><br />
</p><p><span class="anchor" id="sec-interpretation-of-formulas"></span>
</p>
<a id="Interpretation_of_Non-document_Formulas" name="Interpretation_of_Non-document_Formulas"></a><h4> <span class="mw-headline">3.4  Interpretation of Non-document Formulas </span></h4>
<p>This section defines how a semantic structure, <i><b>I</b></i>, determines
the truth value <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>)  of a RIF-BLD formula, <tt>&phi;</tt>, where <tt>&phi;</tt> is any formula other than a document formula. Truth valuation of document formulas is defined in the next section.
</p><p>We define a mapping, <i>TVal</i><sub>I</sub>, from the set of all non-document formulas to <i><b>TV</b></i>. Note that the definition implies that <i>TVal</i><sub>I</sub>(<tt>&phi;</tt>) is defined <em>only if</em> the set <i><b>DTS</b></i> of the datatypes of <i><b>I</b></i> includes all the datatypes mentioned in <tt>&phi;</tt> and <i><b>I</b></i><sub>external</sub> is defined on all externally defined functions and predicates in <tt>&phi;</tt>. 
</p><p><br />
</p><p><span class="anchor" id="def-bld-truth"></span> 
<b>Definition (Truth valuation)</b>.
<i><b>Truth valuation</b></i> for well-formed formulas in RIF-BLD is determined using the following function, denoted <i>TVal</i><sub>I</sub>:
</p>
<ol>
  <li><i>Positional atomic formulas</i>: <i>TVal</i><sub>I</sub>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>r(t<sub>1</sub> ... t<sub>n</sub>)</tt>)) </li>
  <li><i>Atomic formulas with named arguments</i>: <i>TVal</i><sub>I</sub>(<tt>p(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>p(s<sub>1</sub>-&gt;v<sub>1</sub> ... s<sub>k</sub>-&gt;v<sub>k</sub>)</tt>)). </li>
  <li><i>Equality</i>: <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)).
    <ul>
      <li>To ensure that equality has precisely the expected properties, it is required that:
        <ul>
	  <li>
	    <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>t</b> if <i><b>I</b></i>(<tt>x</tt>) = <i><b>I</b></i>(<tt>y</tt>) and  <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>x&nbsp;=&nbsp;y</tt>)) = <b>f</b> otherwise.
	  </li>
        </ul>
      </li>
      <li>This is tantamount to saying that <i>TVal</i><sub>I</sub>(<tt>x&nbsp;=&nbsp;y</tt>) = <b>t</b> if and only if  <i><b>I</b></i>(x) = <i><b>I</b></i>(y).</li>
    </ul>
  </li>
  <li><i>Subclass</i>: <i>TVal</i><sub>I</sub>(<tt>sc&nbsp;##&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>sc&nbsp;##&nbsp;cl</tt>)).
    <p>To ensure that the operator <tt>##</tt> is transitive, i.e., <tt>c1&nbsp;##&nbsp;c2</tt> and <tt>c2&nbsp;##&nbsp;c3</tt> imply <tt>c1&nbsp;##&nbsp;c3</tt>, the following is required:
    </p>
      <ul>
	<li>
          For all well-formed terms <tt>c1</tt>, <tt>c2</tt>, <tt>c3</tt>:  &nbsp; if <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c2</tt>) = <i>TVal</i><sub>I</sub>(<tt>c2&nbsp;##&nbsp;c3</tt>) = <b>t</b> &nbsp; then <i>TVal</i><sub>I</sub>(<tt>c1&nbsp;##&nbsp;c3</tt>) = <b>t</b>.
	</li>
      </ul>
  </li>
  <li><i>Membership</i>: <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o&nbsp;#&nbsp;cl</tt>)).
    <p>To ensure that all members of a subclass are also members of the superclass, i.e., <tt>o&nbsp;#&nbsp;cl</tt> and <tt>cl&nbsp;##&nbsp;scl</tt> imply <tt>o&nbsp;#&nbsp;scl</tt>, the following is required:
    </p>
      <ul>
	<li>
        For all well-formed terms <tt>o</tt>, <tt>cl</tt>, <tt>scl</tt>: &nbsp; if <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;cl</tt>) = <i>TVal</i><sub>I</sub>(<tt>cl&nbsp;##&nbsp;scl</tt>) = <b>t</b> &nbsp; then &nbsp; <i>TVal</i><sub>I</sub>(<tt>o&nbsp;#&nbsp;scl</tt>) = <b>t</b>. 
	</li>
      </ul>
  </li>
  <li><i>Frame</i>: <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>)).
    <p>
      Since the bag of attribute/value pairs associated with an object <tt>o</tt> represents the conjunction of assertions represented by these pairs, the following is required, if <tt>k &gt; 0</tt>: 
    </p>
      <ul>
	<li>
        <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub> ... a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b> if and only if  <i>TVal</i><sub>I</sub>(<tt>o[a<sub>1</sub>-&gt;v<sub>1</sub>]</tt>) = ... = <i>TVal</i><sub>I</sub>(<tt>o[a<sub>k</sub>-&gt;v<sub>k</sub>]</tt>) = <b>t</b>. 
	</li>
      </ul>
  </li>
  <li>
    <i>Externally defined atomic formula</i>: <i>TVal</i><sub>I</sub>(<tt>External(t)</tt>) = <i><b>I</b></i><sub>truth</sub>(<i><b>I</b></i><sub>external</sub>(<tt>&sigma;</tt>)(<i><b>I</b></i>(<tt>s<sub>1</sub></tt>), ..., <i><b>I</b></i>(<tt>s<sub>n</sub></tt>))), if <tt>t</tt> is an atomic formula that is an instantiation of the external schema <tt>&sigma; = (?X<sub>1</sub> ...&nbsp;?X<sub>n</sub>; &tau;)</tt> by substitution <tt>?X<sub>1</sub>/s<sub>1</sub> ...&nbsp;?X<sub>n</sub>/s<sub>1</sub></tt>.
    <p>
      Note that, by definition, <tt>External(t)</tt> is well-formed only if <tt>t</tt> is an instantiation of an external schema. Furthermore, by the <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">definition of coherent sets of external schemas</a>, <tt>t</tt> can be an instantiation of at most one such schema, so <i><b>I</b></i>(<tt>External(t)</tt>) is well-defined.
    </p>
  </li>
  <li><i>Conjunction</i>: <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>t</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>And(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b>.
  <p>
  The empty conjunction is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>And()</tt>) = <b>t</b>.
  </p>
  </li>
  <li><i>Disjunction</i>: <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>f</b> if and only if  <i>TVal</i><sub>I</sub>(c<sub>1</sub>) = ... = <i>TVal</i><sub>I</sub>(c<sub>n</sub>) = <b>f</b>. Otherwise, <i>TVal</i><sub>I</sub>(<tt>Or(</tt>c<sub>1</sub> ... c<sub>n</sub><tt>)</tt>) = <b>t</b>.
  <p>
  The empty disjunction is treated as a contradiction, so <i>TVal</i><sub>I</sub>(<tt>Or()</tt>) = <b>f</b>.
  </p>
  </li>
  <li><i>Quantification</i>:
    <ul>
      <li><i>TVal</i><sub>I</sub>(<tt>Exists&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (&phi;)</tt>) = <b>t</b> if and only if for some <i><b>I</b></i>*, described below,  <i>TVal</i><sub>I*</sub>(<tt>&phi;</tt>) = <b>t</b>.</li>
      <li><i>TVal</i><sub>I</sub>(<tt>Forall&nbsp;?v<sub>1</sub> ...&nbsp;?v<sub>n</sub> (&phi;))</tt> = <b>t</b> if and only if for every <i><b>I</b></i>*, described below,  <i>TVal</i><sub>I*</sub>(<tt>&phi;</tt>) = <b>t</b>.</li>
    </ul>
    <p>
      Here <i><b>I</b></i>* is a semantic structure of the form &lt;<i><b>TV</b></i>, <i><b>DTS</b></i>, <i><b>D</b></i>, <i><b>D</b></i><sub>ind</sub>, <i><b>D</b></i><sub>func</sub>, <i><b>I</b></i><sub>C</sub>, <i><b>I</b></i>*<sub>V</sub>, <i><b>I</b></i><sub>F</sub>, <i><b>I</b></i><sub>NF</sub>, <i><b>I</b></i><sub>list</sub>, <i><b>I</b></i><sub>tail</sub>, <i><b>I</b></i><sub>frame</sub>, <i><b>I</b></i><sub>sub</sub>, <i><b>I</b></i><sub>isa</sub>, <i><b>I</b></i><sub>=</sub>, <i><b>I</b></i><sub>external</sub>, <i><b>I</b></i><sub>truth</sub>&gt;, which is exactly like <i><b>I</b></i>, except that the mapping <i><b>I</b></i>*<sub>V</sub>, is used instead of <i><b>I</b></i><sub>V</sub>. &nbsp; <i><b>I</b></i>*<sub>V</sub> is defined to coincide with <i><b>I</b></i><sub>V</sub> on all variables except, possibly, on <tt>?v<sub>1</sub></tt>,...,<tt>?v<sub>n</sub></tt>.
    </p>
  </li>
  <li><i>Rule implication</i>:
    <ul>
      <li>
        <i>TVal</i><sub>I</sub>(<i>conclusion</i>&nbsp;:- <i>condition</i>) = <b>t</b>, if either <i>TVal</i><sub>I</sub>(<i>conclusion</i>)=<b>t</b> or  <i>TVal</i><sub>I</sub>(<i>condition</i>)=<b>f</b>.
      </li>
      <li>
        <i>TVal</i><sub>I</sub>(<i>conclusion</i>&nbsp;:- <i>condition</i>) = <b>f</b> &nbsp; otherwise.
      </li>
    </ul>
  </li>
  <li><i>Groups of rules</i>:
    <p>
       If <tt>&Gamma;</tt> is a group formula of the form  <tt>Group(&phi;<sub>1</sub> ... &phi;<sub>n</sub>)</tt> then
    </p>
    <ul>       
      <li>
       <i>TVal</i><sub>I</sub>(<tt>&Gamma;</tt>) = <b>t</b> if and only if <i>TVal</i><sub>I</sub>(<tt>&phi;<sub>1</sub></tt>) = <b>t</b>, ..., <i>TVal</i><sub>I</sub>(<tt>&phi;<sub>n</sub></tt>) = <b>t</b>.
      </li>
      <li>
          <i>TVal</i><sub>I</sub>(<tt>&Gamma;</tt>) = <b>f</b> &nbsp; otherwise.
      </li>
    </ul>
    <p>
       This means that a group of rules is treated as a conjunction. In particular, the empty group is treated as a tautology, so <i>TVal</i><sub>I</sub>(<tt>Group()</tt>) = <b>t</b>.&nbsp;&nbsp;☐
    </p>
  </li>
</ol>
<p><br />
</p><p><span class="anchor" id="sec-interpretation-of-documents"></span>
</p>
<a id="Interpretation_of_Documents" name="Interpretation_of_Documents"></a><h4> <span class="mw-headline">3.5  Interpretation of Documents </span></h4>
<p>Document formulas are interpreted using the usual semantic structures with two caveats: <tt>rif:local</tt> must be renamed apart and imported documents must be taken into account. 
</p><p><span class="anchor" id="def-bld-renaming-apart"></span> 
<b>Definition (Renaming of local constants).</b>
A <i><b>renaming mapping</b></i>, &rho;, is a function that maps document formulas to document formulas subject to the following restriction:
</p>
<ul>
  <li>
    If &rho;(<tt>&Delta;</tt>) = <tt>&Delta;'</tt> then <tt>&Delta;'</tt> is exactly like <tt>&Delta;</tt> except that all occurrences of some <tt>rif:local</tt> constants in <tt>&Delta;</tt> may be consistently renamed into other <tt>rif:local</tt> constants.
   <br />
   By consistent renaming here we mean that different occurrences of the same  <tt>rif:local</tt> constant in <tt>&Delta;</tt> are renamed identically. 
&nbsp; &nbsp; &nbsp; &nbsp; ☐ 
  </li>
</ul>
<p><span class="anchor" id="def-bld-semantic-multistruct"></span> 
<b>Definition (Semantic multi-structure).</b>
A <i><b>semantic multi-structure</b></i> <b>&Icirc;</b> is a pair (<b>&Icirc;</b><sub>ren</sub>,<i><b>I</b></i>), where
</p>
<ul>
  <li>  
     <b>&Icirc;</b><sub>ren</sub> is a renaming mapping; and
  </li>
  <li>  
     <i><b>I</b></i> is a semantic structure.
&nbsp; &nbsp; &nbsp; &nbsp; ☐ 
  </li>
</ul>
<p><br />
The semantics of RIF documents is now defined as follows.
</p><p><b>Definition (Truth valuation of document formulas).</b>
Let <tt>&Delta;</tt> be a document formula and let 
<tt>&Delta;</tt><sub>1</sub>, ..., <tt>&Delta;</tt><sub>n</sub> be all the RIF-BLD document formulas that are <i>imported</i> into <tt>&Delta;</tt> (directly or indirectly, according to Definition <a href="#def-bld-imported-doc" title="">Imported document</a>).
Let <tt>&Gamma;</tt>, <tt>&Gamma;<sub>1</sub></tt>, ..., <tt>&Gamma;<sub>n</sub></tt> denote the respective group formulas <a href="#def-associated-group" title="">associated</a> with these documents. If <b>&Icirc;</b> = (<b>&Icirc;</b><sub>ren</sub>,<i><b>I</b></i>)  is a semantic multi-structure, then we define:
</p>
<ul>       
  <li>
   <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&Delta;</tt>) =  <b>t</b>  if and only if <i>TVal</i><sub><i><b>I</b></i></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;</tt>)) =  <i>TVal</i><sub><i><b>I</b></i></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;<sub>1</sub></tt>)) =  ... = <i>TVal</i><sub><i><b>I</b></i></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&Gamma;<sub>n</sub></tt>)) = <b>t</b>.
  </li>
</ul>
<p>That is, <tt>&Delta;</tt> evaluates to <b>t</b> iff, after possible renaming of <tt>rif:local</tt> constants, its associated group formula as well as the group formulas of all the imported documents evaluate to <b>t</b>. 
</p><p>For non-document formulas, we define <i>TVal</i><sub><b>&Icirc;</b></sub>(<tt>&phi;</tt>) = <i>TVal</i><sub><i><b>I</b></i></sub>(<b>&Icirc;</b><sub>ren</sub>(<tt>&phi;</tt>)).
&nbsp; &nbsp; &nbsp; &nbsp; ☐  
</p><p>Note that this definition takes into account only those imported document formulas that are reachable via the one-argument import directives. Two argument import directives are not covered here. Their semantics is defined by the document RIF RDF and OWL Compatibility [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p>Also note that some of the <tt>&Gamma;<sub>i</sub></tt> above may be missing since all parts in a document formula are optional. In this case, we assume that <tt>&Gamma;<sub>i</sub></tt> is a tautology, such as <tt>And()</tt>, and every  <i>TVal</i> function maps such a <tt>&Gamma;<sub>i</sub></tt> to the truth value <b>t</b>.
</p><p>The above definitions make the intent behind the <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> constants clear: due to renaming, occurrences of such constants in different documents can be interpreted differently even if they have the same name. Therefore, each document can choose the names for the <tt>rif:local</tt> constants freely and without regard to the names of such constants used in the imported documents.
</p><p>For the relationship between <tt>rif:local</tt> and RDF blank nodes readers are referred to Section <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/#sec-swc-symbols-rdf-owl" title="SWC">Symbols in RIF Versus RDF/OWL (Informative)</a> of [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>].
</p><p><br />
</p><p><span class="anchor" id="sec-logical-entailment"></span>
</p>
<a id="Logical_Entailment" name="Logical_Entailment"></a><h4> <span class="mw-headline">3.6  Logical Entailment </span></h4>
<p>We now define what it means for a set of RIF-BLD rules (embedded in a group or a document formula) to entail another RIF-BLD formula.  In RIF-BLD we are mostly interested in entailment of RIF condition formulas, which can be viewed as queries to RIF-BLD groups or documents. Entailment of condition formulas provides formal underpinning to RIF-BLD queries.
</p><p><br />
<span class="anchor" id="def-bld-model-formula"></span> 
<b>Definition (Models).</b>
A multi-structure <b>&Icirc;</b> is a <i><b>model</b></i> of a formula, <tt>&phi;</tt>, written as <b>&Icirc;</b><tt>&nbsp;|=&nbsp;&phi;</tt>, iff <i>TVal</i><sub>&Icirc;</sub>(<tt>&phi;</tt>) = <b>t</b>. Here <tt>&phi;</tt> can be a document or a non-document formula. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-bld-entail"></span> 
<b>Definition (Logical entailment).</b>
Let <tt>&phi;</tt> and <tt>&psi;</tt> be (document or non-document) formulas. We say that <tt>&phi;</tt> <i><b>entails</b></i> <tt>&psi;</tt>,  written as <tt>&phi;&nbsp;|=&nbsp;&psi;</tt>, if and only if for every multi-structure, <b>&Icirc;</b>, <b>&Icirc;</b><tt>&nbsp;|=&nbsp;&phi;</tt> implies <b>&Icirc;</b><tt>&nbsp;|=&nbsp;&psi;</tt>. &nbsp;&nbsp;☐
</p><p><br />
Note that one consequence of the multi-document semantics of RIF-BLD is that local constants specified in one document cannot be queried from another document. For instance, if one document, <tt>&Delta;'</tt>, has the fact <tt>"http://example.com/ppp"^^rif:iri("abc"^^rif:local)</tt> while another document formula, <tt>&Delta;</tt>, imports <tt>&Delta;'</tt> and has the rule <tt>"http://example.com/qqq"^^rif:iri(?X)&nbsp;:- "http://example.com/ppp"^^rif:iri(?X)</tt>, then <tt>&Delta; |= "http://example.com/qqq"^^rif:iri("abc"^^rif:local)</tt> does <em>not</em> hold. This is because the symbol <tt>"abc"^^rif:local</tt> in <tt>&Delta;'</tt> and <tt>&Delta;</tt> is treated as different constants by semantic multi-structures. 
</p><p>This behavior of local symbols should be contrasted with the behavior of <tt>rif:iri</tt> symbols. Suppose, in the above scenario, <tt>&Delta;'</tt> also has the fact  <tt>"http://example.com/ppp"^^rif:iri("http://cde.example.org"^^rif:iri)</tt>. Then <tt>&Delta; |= "http://example.com/qqq"^^rif:iri("http://cde.example.org"^^rif:iri)</tt> <em>does</em> hold.
</p><p><br />
<span class="anchor" id="sec-xml-bld"></span>
</p>
<a id="XML_Serialization_Syntax_for_RIF-BLD" name="XML_Serialization_Syntax_for_RIF-BLD"></a><h2> <span class="mw-headline">4  XML Serialization Syntax for RIF-BLD </span></h2>
<p>The RIF-BLD XML serialization defines
</p>
<ul><li> a <i>normative</i> mapping from the RIF-BLD presentation syntax to XML (Section <a href="#sec-translation" title="">Mapping from the Presentation Syntax to the XML Syntax</a>), and
</li><li> a <i>normative</i> XML schema for the XML syntax (Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>).
</li></ul>
<p>Recall that the syntax of RIF-BLD is not context-free and thus cannot be fully captured by EBNF or XML Schema. Still, validity with respect to XML Schema can be a useful test. To reflect this state of affairs, we define two notions of syntactic correctness. The weaker notion checks correctness only with respect to XML Schema, while the stricter notion represents "true" syntactic correctness.
</p><p><span class="anchor" id="def-bld-valid-xml"></span> 
<b>Definition (Valid BLD document in XML syntax).</b>
A <i><b>valid</b></i> BLD document in the XML syntax is an XML document that is valid with respect to the XML schema in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. &nbsp;&nbsp;☐
</p><p><span class="anchor" id="def-bld-admissible-xml"></span> 
<b>Definition (Admissible BLD document in XML syntax).</b>
An <i><b>admissible</b></i> BLD document in the XML syntax is a valid BLD document in XML syntax that is the image of a well-formed RIF-BLD document in the presentation syntax (see Definition <a href="#def-bld-wff" title="">Well-formed formula</a> in Section <a href="#sec-formulas" title="">Formulas</a>) under the presentation-to-XML syntax mapping <tt>&chi;<sub>bld</sub></tt> defined in Section <a href="#sec-translation" title="">Mapping from the Presentation Syntax to the XML Syntax</a>. &nbsp;&nbsp;☐
</p><p>The XML serialization for RIF-BLD is based on an <i>alternating</i> or <i>striped</i> syntax [<a href="#ref-alternating-normal-form" title="">ANF01</a>]. A striped serialization views XML documents as objects and divides all XML tags into class descriptors, called <i>type tags</i>, and property descriptors, called <i>role tags</i> [<a href="#ref-type-and-role-tags" title="">TRT03</a>]. We follow the tradition of using capitalized names for type tags and lowercase names for role tags.
</p><p>The all-uppercase classes in the presentation syntax, such as <tt>FORMULA</tt>, become XML Schema groups in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. They are not visible in instance markup. The other classes as well as non-terminals and symbols (such as <tt>Exists</tt> or <tt>=</tt>) become XML elements with optional attributes, as shown below.
</p><p>RIF-BLD uses [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] for its XML syntax.
</p><p><br />
<span class="anchor" id="sec-xml-condition-language"></span> 
</p>
<a id="XML_for_the_Condition_Language" name="XML_for_the_Condition_Language"></a><h3> <span class="mw-headline">4.1  XML for the Condition Language </span></h3>
<p>XML serialization of RIF-BLD in Section <a href="#sec-ebnf-condition-language" title="">EBNF for RIF-BLD Condition Language</a> uses the following elements.
</p>
<pre>- And       (conjunction)
- Or        (disjunction)
- Exists    (quantified formula for 'Exists', containing declare and formula roles)
- declare   (declare role, containing a Var)
- formula   (formula role, containing a FORMULA)
- Atom      (atom formula, positional or with named arguments)
- External  (external call, containing a content role)
- content   (content role, containing an Atom, for predicates, or Expr, for functions)
- Member    (member formula)
- Subclass  (subclass formula)
- Frame     (Frame formula)
- object    (Member/Frame role, containing a TERM or an object description)
- op        (Atom/Expr role for predicates/functions as operations)
- args      (Atom/Expr positional arguments role, with ordered="yes" attribute, containing n TERMs)
- instance  (Member instance role)
- class     (Member class role)
- sub       (Subclass sub-class role)
- super     (Subclass super-class role)
- slot      (Atom/Expr or Frame slot role, with ordered="yes" attribute, containing a Name or TERM followed by a TERM)
- Equal     (prefix version of term equation '=')
- left      (Equal left-hand side role)
- right     (Equal right-hand side role)
- Expr      (expression formula, positional or with named arguments)
- List      (list term, closed or open)
- items     (list items role, with ordered="yes" attribute, containing n TERMs)
- rest      (list rest role, corresponding to '|')
- Const     (individual, function, or predicate symbol, with 'type' attribute)
- Name      (name of named argument)
- Var       (logic variable)
   
- id        (identifier role, containing IRICONST)
- meta      (meta role, containing metadata as a Frame or Frame conjunction)
</pre>
<p>The name of a base or prefix is not associated with a RIF/XML element, since it is handled via preprocessing as discussed in Section <a href="#sec-translation-rule-language" title="">Mapping of the Rule Language</a>.
</p><p>The <tt>id</tt> and <tt>meta</tt> elements, which are expansions of the <tt>IRIMETA</tt> element, can occur optionally as the initial children of any Class element.
</p><p>For the XML Schema definition of the RIF-BLD condition language see Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>. 
</p><p>The XML syntax for symbol spaces uses the <tt>type</tt> attribute associated with the XML element <tt>Const</tt>. For instance, a literal in the <tt>xs:dateTime</tt> datatype is represented as follows:
</p><p><tt>&lt;Const&nbsp;type="&amp;xs;dateTime"&gt;2007-11-23T03:55:44-02:30&lt;/Const&gt;</tt>
</p><p>The <tt>xml:lang</tt> attribute, as defined by <a class="external text" href="http://www.w3.org/TR/REC-xml/#sec-lang-tag" rel="nofollow" title="http://www.w3.org/TR/REC-xml/#sec-lang-tag">2.12 Language Identification</a> of <a class="external text" href="http://www.w3.org/TR/2000/REC-xml-20001006" rel="nofollow" title="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0</a> or its successor specifications in the W3C recommendation track, is optionally used to identify the language for the presentation of the <tt>Const</tt> to the user. It is allowed only in association with constants of the type <tt>rdf:plainLiteral</tt>. A compliant implementation MUST ignore the <tt>xml:lang</tt> attribute if the type of the <tt>Const</tt> is not <tt>rdf:plainLiteral</tt>.
</p><p>RIF-BLD also uses the <tt>ordered="yes"</tt> attribute to indicate that the children of 
<tt>args</tt> and <tt>slot</tt> elements are ordered.
</p><p><br />
<span class="anchor" id="ex-RIF-condition-serialization">
<b>Example 6</b> (A RIF condition and its XML serialization).
</span> 
</p><p>This example illustrates XML serialization for RIF conditions. As before, the compact URI notation is used for better readability. Assume that the following prefix directives are found in the preamble to the document, whose XML form will be illustrated in Example 8:
</p>
<pre>Prefix(bks    &lt;http://example.com/books#&gt;)
Prefix(cpt    &lt;http://example.com/concepts#&gt;)
Prefix(curr   &lt;http://example.com/currencies#&gt;)
Prefix(rif    &lt;http://www.w3.org/2007/rif#&gt;)
Prefix(xs     &lt;http://www.w3.org/2001/XMLSchema#&gt;)
</pre>
<p>RIF condition:
</p>
<pre>   And (Exists&nbsp;?Buyer (cpt:purchase(?Buyer&nbsp;?Seller
                                    cpt:book(?Author bks:LeRif)
                                    curr:USD(49)))
       &nbsp;?Seller=?Author )

</pre>
<p>XML serialization:
</p>
<pre>   &lt;And&gt;
     &lt;formula&gt;
       &lt;Exists&gt;
         &lt;declare&gt;&lt;Var&gt;Buyer&lt;/Var&gt;&lt;/declare&gt;
         &lt;formula&gt;
           &lt;Atom&gt;
             &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;purchase&lt;/Const&gt;&lt;/op&gt;
             &lt;args ordered="yes"&gt;
               &lt;Var&gt;Buyer&lt;/Var&gt;
               &lt;Var&gt;Seller&lt;/Var&gt;
               &lt;Expr&gt;
                 &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;book&lt;/Const&gt;&lt;/op&gt;
                 &lt;args ordered="yes"&gt;
                   &lt;Var&gt;Author&lt;/Var&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;bks;LeRif&lt;/Const&gt;
                 &lt;/args&gt;
               &lt;/Expr&gt;
               &lt;Expr&gt;
                 &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;curr;USD&lt;/Const&gt;&lt;/op&gt;
                 &lt;args ordered="yes"&gt;&lt;Const type="&amp;xs;integer"&gt;49&lt;/Const&gt;&lt;/args&gt;
               &lt;/Expr&gt;
             &lt;/args&gt;
           &lt;/Atom&gt;
         &lt;/formula&gt;
       &lt;/Exists&gt;
     &lt;/formula&gt;
     &lt;formula&gt;
       &lt;Equal&gt;
         &lt;left&gt;&lt;Var&gt;Seller&lt;/Var&gt;&lt;/left&gt;
         &lt;right&gt;&lt;Var&gt;Author&lt;/Var&gt;&lt;/right&gt;
       &lt;/Equal&gt;
     &lt;/formula&gt;
   &lt;/And&gt;
</pre>
<p><br />
<span class="anchor" id="ex-rif-bld-namedargs-pres-syntax">
<b>Example 7</b> (An XML serialization of a RIF condition with a frame and a named-argument term).
</span>
</p><p>This example illustrates XML serialization of RIF conditions that involve terms with named arguments. As in Example 6, we assume the following prefix directives, whose XML form will be illustrated in Example 8:
</p>
<pre>Prefix(bks    &lt;http://example.com/books#&gt;)
Prefix(cpt    &lt;http://example.com/concepts#&gt;)
Prefix(curr   &lt;http://example.com/currencies#&gt;)
Prefix(rif    &lt;http://www.w3.org/2007/rif#&gt;)
Prefix(xs     &lt;http://www.w3.org/2001/XMLSchema#&gt;)
</pre>
<p>RIF condition:
</p>
<pre>   And (Exists&nbsp;?Buyer&nbsp;?P (
                 And (?P#cpt:purchase
                     &nbsp;?P[cpt:buyer-&gt;?Buyer
                         cpt:seller-&gt;?Seller
                         cpt:item-&gt;cpt:book(cpt:author-&gt;?Author cpt:title-&gt;bks:LeRif)
                         cpt:price-&gt;49
                         cpt:currency-&gt;curr:USD]))
       &nbsp;?Seller=?Author)


</pre>
<p>XML serialization:
</p>
<pre>   &lt;And&gt;
     &lt;formula&gt;
       &lt;Exists&gt;
         &lt;declare&gt;&lt;Var&gt;Buyer&lt;/Var&gt;&lt;/declare&gt;
         &lt;declare&gt;&lt;Var&gt;P&lt;/Var&gt;&lt;/declare&gt;
         &lt;formula&gt;
           &lt;And&gt;
             &lt;formula&gt;
               &lt;Member&gt;
                 &lt;instance&gt;&lt;Var&gt;P&lt;/Var&gt;&lt;/instance&gt;
                 &lt;class&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;purchase&lt;/Const&gt;&lt;/class&gt;
               &lt;/Member&gt;
             &lt;/formula&gt;
             &lt;formula&gt;
               &lt;Frame&gt;
                 &lt;object&gt;
                   &lt;Var&gt;P&lt;/Var&gt;
                 &lt;/object&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;buyer&lt;/Const&gt;
                   &lt;Var&gt;Buyer&lt;/Var&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;seller&lt;/Const&gt;
                   &lt;Var&gt;Seller&lt;/Var&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;item&lt;/Const&gt;
                   &lt;Expr&gt;
                     &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;book&lt;/Const&gt;&lt;/op&gt;
                     &lt;slot ordered="yes"&gt;
                       &lt;Name&gt;&amp;cpt;author&lt;/Name&gt;
                       &lt;Var&gt;Author&lt;/Var&gt;
                     &lt;/slot&gt;
                     &lt;slot ordered="yes"&gt;
                       &lt;Name&gt;&amp;cpt;title&lt;/Name&gt;
                       &lt;Const type="&amp;rif;iri"&gt;&amp;bks;LeRif&lt;/Const&gt;
                     &lt;/slot&gt;
                   &lt;/Expr&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;price&lt;/Const&gt;
                   &lt;Const type="&amp;xs;integer"&gt;49&lt;/Const&gt;
                 &lt;/slot&gt;
                 &lt;slot ordered="yes"&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;cpt;currency&lt;/Const&gt;
                   &lt;Const type="&amp;rif;iri"&gt;&amp;curr;USD&lt;/Const&gt;
                 &lt;/slot&gt;
               &lt;/Frame&gt;
             &lt;/formula&gt;
           &lt;/And&gt;
         &lt;/formula&gt;
       &lt;/Exists&gt;
     &lt;/formula&gt;
     &lt;formula&gt;
       &lt;Equal&gt;
         &lt;left&gt;&lt;Var&gt;Seller&lt;/Var&gt;&lt;/left&gt;
         &lt;right&gt;&lt;Var&gt;Author&lt;/Var&gt;&lt;/right&gt;
       &lt;/Equal&gt;
     &lt;/formula&gt;
   &lt;/And&gt;
</pre>
<p><br />
</p><p><span class="anchor" id="sec-xml-rule-language"></span>
</p>
<a id="XML_for_the_Rule_Language" name="XML_for_the_Rule_Language"></a><h3> <span class="mw-headline">4.2  XML for the Rule Language </span></h3>
<p>We now extend the set of RIF-BLD serialization elements from Section <a href="#sec-xml-condition-language" title="">XML for RIF-BLD Condition Language</a> by including rules, along with their enclosing groups and documents, as described in Section <a href="#sec-ebnf-rule-language" title="">EBNF for RIF-BLD Rule Language</a>. The extended set includes the tags listed below.
</p>
<pre>- Document  (document, containing optional directive and payload roles)
- directive (directive role, containing Import)
- payload   (payload role, containing Group)
- Import    (importation, containing location and optional profile)
- location  (location role, containing ANYURICONST)
- profile   (profile role, containing PROFILE)
- Group     (nested collection of sentences)
- sentence  (sentence role, containing RULE or Group)
- Forall    (quantified formula for 'Forall', containing declare and formula roles)
- Implies   (implication, containing if and then roles)
- if        (antecedent role, containing FORMULA)
- then      (consequent role, containing ATOMIC or conjunction of ATOMICs)
</pre>
<p>The XML Schema Definition of RIF-BLD is given in Appendix <a href="#sec-xsd-bld" title="">XML Schema for BLD</a>.
</p><p>While there is a RIF-BLD element tag for the <tt>Import</tt> directive, the <tt>Base</tt> and <tt>Prefix</tt> directives are not represented by RIF/XML tags: they are handled as follows (see also Section <a href="#sec-translation-rule-language" title="">Mapping of the Rule Language</a>).
A <tt>Base</tt> directive in the presentation syntax becomes an <tt>xml:base</tt> attribute [<a href="#ref-xml-base" title="">XML-Base</a>] in the XML <tt>Document</tt> tag.
The base IRI specified as the value of that attribute applies to content of the RIF/XML element that deals with <tt>rif:iri</tt> constants, namely to relative-IRI content of the <tt>&lt;Const type="&amp;rif;iri"&gt;</tt> element as well as symbol spaces, loation, and profile.
A collection of <tt>Prefix</tt> directives in the presentation syntax becomes a <tt>DOCTYPE</tt> DTD [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] preceding the RIF-BLD <tt>Document</tt> and containing a declaration of an <tt>ENTITY</tt> for each <tt>Prefix</tt> directive.
</p><p><br />
<span class="anchor" id="ex-RIF-doc-with-annotation-serialization">
<b>Example 8</b> (Serializing a RIF-BLD document containing an annotated group).
</span> 
</p><p>This example shows a serialization for the document from Example 5. For convenience, the presentation syntax is reproduced at the top, and is followed by its serialization.
The base IRI <tt>http://example.com/people#</tt> applies to the relative <tt>rif:iri</tt> constants with content <tt>John</tt> (twice) and <tt>Fred</tt> (once).
</p><p>Presentation syntax:
</p>
<pre>Document(
  Base(&lt;http://example.com/people#&gt;)
  Prefix(cpt  &lt;http://example.com/concepts#&gt;)
  Prefix(dc   &lt;http://purl.org/dc/terms/&gt;)
  Prefix(rif  &lt;http://www.w3.org/2007/rif#&gt;)
  Prefix(func &lt;http://www.w3.org/2007/rif-builtin-function#&gt;)
  Prefix(pred &lt;http://www.w3.org/2007/rif-builtin-predicate#&gt;)
  Prefix(xs   &lt;http://www.w3.org/2001/XMLSchema#&gt;)
  
  (* "http://sample.org"^^rif:iri _pd[dc:publisher -&gt; "http://www.w3.org/"^^rif:iri
                                      dc:date -&gt; "2008-04-04"^^xs:date] *)
  Group
  (
    Forall&nbsp;?item&nbsp;?deliverydate&nbsp;?scheduledate&nbsp;?diffduration&nbsp;?diffdays (
        cpt:reject(&lt;John&gt;&nbsp;?item)&nbsp;:-
            And(cpt:perishable(?item)
                cpt:delivered(?item&nbsp;?deliverydate &lt;John&gt;)
                cpt:scheduled(?item&nbsp;?scheduledate)
               &nbsp;?diffduration = External(func:subtract-dateTimes(?deliverydate&nbsp;?scheduledate))
               &nbsp;?diffdays = External(func:days-from-duration(?diffduration))
                External(pred:numeric-greater-than(?diffdays 10)))
    )
 
    Forall&nbsp;?item (
        cpt:reject(&lt;Fred&gt;&nbsp;?item)&nbsp;:- cpt:unsolicited(?item)
    )
  )
)


</pre>
<p>XML syntax:
</p>
<pre>&lt;!DOCTYPE Document [
  &lt;!ENTITY cpt  "http://example.com/concepts#"&gt;
  &lt;!ENTITY dc   "http://purl.org/dc/terms/"&gt;
  &lt;!ENTITY rif  "http://www.w3.org/2007/rif#"&gt;
  &lt;!ENTITY func "http://www.w3.org/2007/rif-builtin-function#"&gt;
  &lt;!ENTITY pred "http://www.w3.org/2007/rif-builtin-predicate#"&gt;
  &lt;!ENTITY xs   "http://www.w3.org/2001/XMLSchema#"&gt;
]&gt;

&lt;Document
    xml:base="http://example.com/people#"
    xmlns="http://www.w3.org/2007/rif#"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xs="http://www.w3.org/2001/XMLSchema#"&gt;
  &lt;payload&gt;
   &lt;Group&gt;
    &lt;id&gt;
      &lt;Const type="&amp;rif;iri"&gt;http://sample.org&lt;/Const&gt;
    &lt;/id&gt;
    &lt;meta&gt;
      &lt;Frame&gt;
        &lt;object&gt;
          &lt;Const type="&amp;rif;local"&gt;pd&lt;/Const&gt;
        &lt;/object&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;publisher&lt;/Const&gt;
          &lt;Const type="&amp;rif;iri"&gt;http://www.w3.org/&lt;/Const&gt;
        &lt;/slot&gt;
        &lt;slot ordered="yes"&gt;
          &lt;Const type="&amp;rif;iri"&gt;&amp;dc;date&lt;/Const&gt;
          &lt;Const type="&amp;xs;date"&gt;2008-04-04&lt;/Const&gt;
        &lt;/slot&gt;
      &lt;/Frame&gt;
    &lt;/meta&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;deliverydate&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;scheduledate&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;diffduration&lt;/Var&gt;&lt;/declare&gt;
       &lt;declare&gt;&lt;Var&gt;diffdays&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Implies&gt;
           &lt;if&gt;
             &lt;And&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;perishable&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;delivered&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;
                     &lt;Var&gt;item&lt;/Var&gt;
                     &lt;Var&gt;deliverydate&lt;/Var&gt;
                     &lt;Const type="&amp;rif;iri"&gt;John&lt;/Const&gt;
                   &lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Atom&gt;
                   &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;scheduled&lt;/Const&gt;&lt;/op&gt;
                   &lt;args ordered="yes"&gt;
                     &lt;Var&gt;item&lt;/Var&gt;
                     &lt;Var&gt;scheduledate&lt;/Var&gt;
                   &lt;/args&gt;
                 &lt;/Atom&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Equal&gt;
                   &lt;left&gt;&lt;Var&gt;diffduration&lt;/Var&gt;&lt;/left&gt;
                   &lt;right&gt;
                     &lt;External&gt;
                       &lt;content&gt;
                         &lt;Expr&gt;
                           &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;func;subtract-dateTimes&lt;/Const&gt;&lt;/op&gt;
                           &lt;args ordered="yes"&gt;
                             &lt;Var&gt;deliverydate&lt;/Var&gt;
                             &lt;Var&gt;scheduledate&lt;/Var&gt;
                           &lt;/args&gt;
                         &lt;/Expr&gt;
                       &lt;/content&gt;
                     &lt;/External&gt;
                   &lt;/right&gt;
                 &lt;/Equal&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;Equal&gt;
                   &lt;left&gt;&lt;Var&gt;diffdays&lt;/Var&gt;&lt;/left&gt;
                   &lt;right&gt;
                     &lt;External&gt;
                       &lt;content&gt;
                         &lt;Expr&gt;
                           &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;func;days-from-duration&lt;/Const&gt;&lt;/op&gt;
                           &lt;args ordered="yes"&gt;
                             &lt;Var&gt;diffduration&lt;/Var&gt;
                           &lt;/args&gt;
                         &lt;/Expr&gt;
                       &lt;/content&gt;
                     &lt;/External&gt;
                   &lt;/right&gt;
                 &lt;/Equal&gt;
               &lt;/formula&gt;
               &lt;formula&gt;
                 &lt;External&gt;
                   &lt;content&gt;
                     &lt;Atom&gt;
                       &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;pred;numeric-greater-than&lt;/Const&gt;&lt;/op&gt;
                       &lt;args ordered="yes"&gt;
                         &lt;Var&gt;diffdays&lt;/Var&gt;
                         &lt;Const type="&amp;xs;integer"&gt;10&lt;/Const&gt;
                       &lt;/args&gt;
                     &lt;/Atom&gt;
                   &lt;/content&gt;
                 &lt;/External&gt;
               &lt;/formula&gt;
             &lt;/And&gt;
           &lt;/if&gt;
           &lt;then&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;reject&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;
                 &lt;Const type="&amp;rif;iri"&gt;John&lt;/Const&gt;
                 &lt;Var&gt;item&lt;/Var&gt;
               &lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/then&gt;
         &lt;/Implies&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
    &lt;/sentence&gt;
    &lt;sentence&gt;
     &lt;Forall&gt;
       &lt;declare&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/declare&gt;
       &lt;formula&gt;
         &lt;Implies&gt;
           &lt;if&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;unsolicited&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;&lt;Var&gt;item&lt;/Var&gt;&lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/if&gt;
           &lt;then&gt;
             &lt;Atom&gt;
               &lt;op&gt;&lt;Const type="&amp;rif;iri"&gt;&amp;cpt;reject&lt;/Const&gt;&lt;/op&gt;
               &lt;args ordered="yes"&gt;
                 &lt;Const type="&amp;rif;iri"&gt;Fred&lt;/Const&gt;
                 &lt;Var&gt;item&lt;/Var&gt;
               &lt;/args&gt;
             &lt;/Atom&gt;
           &lt;/then&gt;
         &lt;/Implies&gt;
       &lt;/formula&gt;
     &lt;/Forall&gt;
    &lt;/sentence&gt;
   &lt;/Group&gt;
  &lt;/payload&gt;
 &lt;/Document&gt;
</pre>
<p><br />
</p><p><span class="anchor" id="sec-translation"></span>
</p>
<a id="Mapping_from_the_Presentation_Syntax_to_the_XML_Syntax" name="Mapping_from_the_Presentation_Syntax_to_the_XML_Syntax"></a><h3> <span class="mw-headline">4.3  Mapping from the Presentation Syntax to the XML Syntax </span></h3>
<p>This section defines a normative mapping, <tt>&chi;<sub>bld</sub></tt>, from the presentation syntax to the XML syntax of RIF-BLD.
The mapping is given via tables where each row specifies the mapping of a particular syntactic pattern in the presentation syntax. These patterns appear in the first column of the tables and the <i><b>bold-italic</b></i> symbols represent metavariables. The second column represents the corresponding XML patterns, which may contain applications of the mapping <tt>&chi;<sub>bld</sub></tt> to these metavariables. When an expression <tt>&chi;<sub>bld</sub></tt><tt>(<b><i>metavar</i></b>)</tt> occurs in an XML pattern in the right column of a translation table, it should be understood as a recursive application of <tt>&chi;<sub>bld</sub></tt> to the presentation syntax represented by the metavariable. The XML syntax result of such an application is substituted for the expression <tt>&chi;<sub>bld</sub></tt><tt>(<b><i>metavar</i></b>)</tt>. 
A sequence of terms containing metavariables with subscripts is indicated by an ellipsis.
For the subscript <tt>m</tt> it is understood that
<tt>m&ge;1</tt>, i.e. the ellipsis indicates at least one term.
For the subscript <tt>n</tt> it is understood that
<tt>n&ge;0</tt>, i.e. the ellipsis indicates zero or more terms.
A metavariable or a well-formed XML subelement is marked as optional by appending a bold-italic question mark, <i><b>?</b></i>, on its right.
</p><p><br />
<span class="anchor" id="sec-translation-condition-language"></span> 
</p>
<a id="Mapping_of_the_Condition_Language" name="Mapping_of_the_Condition_Language"></a><h4> <span class="mw-headline">4.3.1  Mapping of the Condition Language </span></h4>
<p>The <tt>&chi;<sub>bld</sub></tt> mapping from the presentation syntax to the XML syntax of the RIF-BLD Condition Language is specified by the table below. 
Each row indicates a translation
<tt>&chi;<sub>bld</sub></tt>(<tt>Presentation</tt>) = <tt>XML</tt>. The function <tt><i>remove-outer-quotes</i></tt> used in the translation removes enclosing double quotes from a string and leaves unquoted strings untouched. 
Since the presentation syntax of RIF-BLD is context sensitive, the mapping must differentiate between the terms that occur in the position of individuals and the terms that occur as atomic formulas. To this end, in the translation table, the positional and named-argument terms that occur in the context of atomic formulas are denoted by expressions of the form <i><b>pred</b></i>(...) and the terms that occur as individuals are denoted by expressions of the form <i><b>func</b></i>(...).
In the table, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>name<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>. Regarding the last but first row, we assume that shortcuts for constants [<a href="#ref-rif-dtb" title="">RIF-DTB</a>] have already been expanded to their full form (<tt>"..."^^</tt><i><b>symspace</b></i>).
</p>
<table class="syntax-translation-table">
<tr>
<th colspan="1" rowspan="1"> Presentation Syntax
</th><th colspan="1" rowspan="1"> XML Syntax
</th></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>And (
  <i><b>conjunct<sub>1</sub></b></i>
  . . .
  <i><b>conjunct<sub>n</sub></b></i>
    )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;And&gt;
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>conjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>conjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/And&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Or (
  <i><b>disjunct<sub>1</sub></b></i>
  . . .
  <i><b>disjunct<sub>n</sub></b></i>
   )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Or&gt;
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>disjunct<sub>1</sub></b></i>)&lt;/formula&gt;
   . . .
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>disjunct<sub>n</sub></b></i>)&lt;/formula&gt;
&lt;/Or&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Exists
  <i><b>variable<sub>1</sub></b></i>
  . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>premise</b></i>
            )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Exists&gt;
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>premise</b></i>)&lt;/formula&gt;
&lt;/Exists&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>External (
  <i><b>atomexpr</b></i>
         )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;External&gt;
  &lt;content&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>atomexpr</b></i>)&lt;/content&gt;
&lt;/External&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>m</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>m</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>m</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>m</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
    )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
  |
  <i><b>remainder</b></i>
    )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
  &lt;rest&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>remainder</b></i>)&lt;/rest&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>pred</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>func</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Frame&gt;
  &lt;object&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>

<tr>
<td colspan="1" rowspan="1">
<pre><i><b>inst</b></i> # <i><b>class</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Member&gt;
  &lt;instance&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/instance&gt;
  &lt;class&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>class</b></i>)&lt;/class&gt;
&lt;/Member&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>sub</b></i> ## <i><b>super</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Subclass&gt;
  &lt;sub&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>sub</b></i>)&lt;/sub&gt;
  &lt;super&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>super</b></i>)&lt;/super&gt;
&lt;/Subclass&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>left</b></i> = <i><b>right</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Equal&gt;
  &lt;left&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>left</b></i>)&lt;/left&gt;
  &lt;right&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>right</b></i>)&lt;/right&gt;
&lt;/Equal&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>"<i><b>unicodestring</b></i>"^^<i><b>symspace</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Const type="<i><b>symspace</b></i>"&gt;<i><b>unicodestring</b></i>&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>?<i><b>name<sub>1</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Var&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Var&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>name<sub>i</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre> <i>remove-outer-quotes</i>(<i><b>name<sub>i</sub></b></i>)
</pre>
</td></tr></table>
<p><br />
<span class="anchor" id="sec-translation-rule-language"></span>
</p>
<a id="Mapping_of_the_Rule_Language" name="Mapping_of_the_Rule_Language"></a><h4> <span class="mw-headline">4.3.2  Mapping of the Rule Language </span></h4>
<p>The <tt>&chi;<sub>bld</sub></tt> mapping from the presentation syntax to the XML syntax of the RIF-BLD Rule Language is specified by the table below. It extends the translation table of Section <a href="#sec-translation-condition-language" title="">Mapping of the Condition Language</a>. While the <tt>Import</tt> directive is handled by the presentation-to-XML syntax mapping, the <tt>Prefix</tt> and <tt>Base</tt> directives are not. Instead, these directives should be handled by expanding the associated shortcuts (compact URIs).
Namely, a prefix name declared in a <tt>Prefix</tt> directive is expanded into the associated IRI, while relative IRIs are completed using the IRI declared in the <tt>Base</tt> directive. The mapping <tt>&chi;<sub>bld</sub></tt> applies only to such expanded documents.
RIF-BLD also allows other treatments of <tt>Prefix</tt> and <tt>Base</tt> provided that they produce equivalent XML documents. One such treatment is employed in the examples in this document, especially Example 8. It replaces prefix names with definitions of XML entities as follows.
Each <tt>Prefix</tt> declaration becomes an <tt>ENTITY</tt> declaration [<a href="#ref-xml-1-point-0" title="">XML1.0</a>] within a <tt>DOCTYPE</tt> DTD attached to the RIF-BLD <tt>Document</tt>. The <tt>Base</tt> directive is mapped to the <tt>xml:base</tt> attribute [<a href="#ref-xml-base" title="">XML-Base</a>] in the XML <tt>Document</tt> tag.
Compact URIs of the form <tt>prefix:suffix</tt> are then mapped to <tt>&amp;prefix;suffix</tt>.
</p>
<table class="syntax-translation-table">
<tr>
<th colspan="1" rowspan="1"> Presentation Syntax
</th><th colspan="1" rowspan="1"> XML Syntax
</th></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Document(
  Import(<i><b>loc<sub>1</sub></b></i> <i><b>prfl<sub>1</sub>?</b></i>)
   . . .
  Import(<i><b>loc<sub>n</sub></b></i> <i><b>prfl<sub>n</sub>?</b></i>)
  <i><b>group?</b></i>
        )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Document&gt;
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>loc<sub>1</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>prfl<sub>1</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
   . . .
  &lt;directive&gt;
    &lt;Import&gt;
      &lt;location&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>loc<sub>n</sub></b></i>)&lt;/location&gt;
      &lt;profile&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>prfl<sub>n</sub></b></i>)&lt;/profile&gt;<i><b>?</b></i>
    &lt;/Import&gt;
  &lt;/directive&gt;
  &lt;payload&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>group</b></i>)&lt;/payload&gt;<i><b>?</b></i>
&lt;/Document&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Group(
  <i><b>clause<sub>1</sub></b></i>
   . . .
  <i><b>clause<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Group&gt;
  &lt;sentence&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>clause<sub>1</sub></b></i>)&lt;/sentence&gt;
   . . .
  &lt;sentence&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>clause<sub>n</sub></b></i>)&lt;/sentence&gt;
&lt;/Group&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>Forall
  <i><b>variable<sub>1</sub></b></i>
   . . .
  <i><b>variable<sub>n</sub></b></i> (
             <i><b>rule</b></i>
            )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Forall&gt;
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
   . . .
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>rule</b></i>)&lt;/formula&gt;
&lt;/Forall&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre><i><b>conclusion</b></i>&nbsp;:- <i><b>condition</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Implies&gt;
  &lt;if&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>condition</b></i>)&lt;/if&gt;
  &lt;then&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>conclusion</b></i>)&lt;/then&gt;
&lt;/Implies&gt;
</pre>
</td></tr></table>
<a id="Mapping_of_Annotations" name="Mapping_of_Annotations"></a><h4> <span class="mw-headline">4.3.3  Mapping of Annotations </span></h4>
<p>The <tt>&chi;<sub>bld</sub></tt> mapping from RIF-BLD annotations in the presentation syntax to the XML syntax is specified by the table below.
It extends the translation tables of Sections <a href="#sec-translation-condition-language" title="">Mapping of the Condition Language</a> and <a href="#sec-translation-rule-language" title="">Mapping of the Rule Language</a>.
The metavariable <i><b>Typetag</b></i> in the presentation and XML syntaxes stands for any of the class names <tt>And</tt>, <tt>Or</tt>, <tt>External</tt>, <tt>Document</tt>, or <tt>Group</tt>, and <i><b>Quantifier</b></i> for <tt>Exists</tt> or <tt>Forall</tt>. The dollar sign, <b>$</b>, stands for any of the binary infix operator names <tt>#</tt>, <tt>##</tt>, <tt>=</tt>, or <tt>:-</tt>, while <i><b>Binop</b></i> stands for their respective class names <tt>Member</tt>, <tt>Subclass</tt>, <tt>Equal</tt>, or <tt>Implies</tt>.
Again, each metavariable for an (unnamed) positional <i><b>argument<sub>i</sub></b></i> is assumed to be instantiated to values unequal to the instantiations of named arguments <i><b>name<sub>j</sub></b></i> <tt>-&gt;</tt> <i><b>filler<sub>j</sub></b></i>.
</p>
<table class="syntax-translation-table">
<tr>
<th colspan="1" rowspan="1"> Presentation Syntax
</th><th colspan="1" rowspan="1"> XML Syntax
</th></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Typetag</b></i> ( <i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i> )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Typetag</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>
&lt;/<i><b>Typetag</b></i>&gt;

<tt>where <i><b>e<sub>1</sub>'</b></i>, . . ., <i><b>e<sub>n</sub>'</b></i> are defined by the equation</tt>
<tt>&chi;<sub>bld</sub></tt><tt>(<i><b>Typetag</b></i>(<i><b>e<sub>1</sub></b></i> . . . <i><b>e<sub>n</sub></b></i>)) = &lt;<i><b>Typetag</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> . . . <i><b>e<sub>n</sub>'</b></i>&lt;/<i><b>Typetag</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>Quantifier</b></i> <i><b>variable<sub>1</sub></b></i> . . . <i><b>variable<sub>n</sub></b></i> ( <i><b>formula</b></i> )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Quantifier</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>1</sub></b></i>)&lt;/declare&gt;
  . . .
  &lt;declare&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>variable<sub>n</sub></b></i>)&lt;/declare&gt;
  &lt;formula&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>formula</b></i>)&lt;/formula&gt;
&lt;/<i><b>Quantifier</b></i>&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>argument<sub>1</sub></b></i>
  . . .
  <i><b>argument<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;args ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>argument<sub>n</sub></b></i>)
  &lt;/args&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
    )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
List (
  <i><b>element<sub>1</sub></b></i>
  . . .
  <i><b>element<sub>n</sub></b></i>
  |
  <i><b>remainder</b></i>
    )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;List&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;items ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>1</sub></b></i>)
    . . .
    <tt>&chi;<sub>bld</sub></tt>(<i><b>element<sub>n</sub></b></i>)
  &lt;/items&gt;
  &lt;rest&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>remainder</b></i>)&lt;/rest&gt;
&lt;/List&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>pred</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Atom&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>pred</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Atom&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>func</b></i> (
  <i><b>name<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>name<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     )
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Expr&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;op&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>func</b></i>)&lt;/op&gt;
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    &lt;Name&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>n</sub></b></i>)&lt;/Name&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Expr&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>inst</b></i> [
  <i><b>key<sub>1</sub></b></i> -&gt; <i><b>filler<sub>1</sub></b></i>
  . . .
  <i><b>key<sub>n</sub></b></i> -&gt; <i><b>filler<sub>n</sub></b></i>
     ]
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Frame&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  &lt;object&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>inst</b></i>)&lt;/object&gt;
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>key<sub>1</sub></b></i>)
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>1</sub></b></i>)
  &lt;/slot&gt;
   . . .
  &lt;slot ordered="yes"&gt;
    <tt>&chi;<sub>bld</sub></tt>(<i><b>key<sub>n</sub></b></i>)
    <tt>&chi;<sub>bld</sub></tt>(<i><b>filler<sub>n</sub></b></i>)
  &lt;/slot&gt;
&lt;/Frame&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;<i><b>Binop</b></i>&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>
&lt;/<i><b>Binop</b></i>&gt;

<tt>where <i><b>Binop</b></i>, <i><b>e<sub>1</sub>'</b></i>, <i><b>e<sub>2</sub>'</b></i> are defined by the equation</tt>
<tt>&chi;<sub>bld</sub></tt><tt>(<i><b>e<sub>1</sub></b></i> <b>$</b> <i><b>e<sub>2</sub></b></i>) = &lt;<i><b>Binop</b></i>&gt;<i><b>e<sub>1</sub>'</b></i> <i><b>e<sub>2</sub>'</b></i>&lt;/<i><b>Binop</b></i>&gt;</tt>
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
<i><b>unicodestring</b></i>^^<i><b>symspace</b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Const type="<i><b>symspace</b></i>"&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
  <i><b>unicodestring</b></i>
&lt;/Const&gt;
</pre>
</td></tr>
<tr>
<td colspan="1" rowspan="1">
<pre>(* <i><b>iriconst?</b></i> <i><b>frameconj?</b></i> *)
?<i><b>name<sub>1</sub></b></i>
</pre>
</td><td colspan="1" rowspan="1">
<pre>&lt;Var&gt;
  &lt;id&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>iriconst</b></i>)&lt;/id&gt;<i><b>?</b></i>
  &lt;meta&gt;<tt>&chi;<sub>bld</sub></tt>(<i><b>frameconj</b></i>)&lt;/meta&gt;<i><b>?</b></i>
    <tt>&chi;<sub>bld</sub></tt>(<i><b>name<sub>1</sub></b></i>)
&lt;/Var&gt;
</pre>
</td></tr></table>
<p><br />
<span class="anchor" id="sec-conformance"></span>
</p>
<a id="Conformance_Clauses" name="Conformance_Clauses"></a><h2> <span class="mw-headline">5  Conformance Clauses </span></h2>
<p>RIF-BLD does not require or expect conformant systems to implement the RIF-BLD presentation syntax. Instead, conformance is described in terms of semantics-preserving transformations between the native syntax of a compliant system and the XML syntax of RIF-BLD.
</p><p>Let &Tau; be a set of datatypes and symbol spaces that includes the datatypes specified in
[<a href="#ref-rif-dtb" title="">RIF-DTB</a>], and the symbol spaces <tt>rif:iri</tt>, and <tt>rif:local</tt>. Suppose &Epsilon; is a <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">coherent set of external schemas</a> that includes the built-ins listed in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>]. We say that a formula &phi; is a <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formula iff 
</p>
<ul>
  <li>
    it is a well-formed BLD formula,
  </li>
  <li>
    all datatypes and symbol spaces used in &phi; are in &Tau;, and
  </li>
  <li>
    all externally defined terms used in &phi; are instantiations of external schemas from &Epsilon;.
  </li>
</ul>
<p><span class="anchor" id="def-conformance"></span>
A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>&Tau;,&Epsilon;</sub> <i><b>consumer</b></i> iff it implements a <span class="anchor" id="def-sem-preserving-map-to"><i>semantics-preserving mapping</i></span>, &mu;, from the set of all <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formulas to the language <i>L</i> of the processor (&mu; does not need to be an "onto" mapping).
</p><p>Formally, this means that for any pair &phi;, &psi; of <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formulas for which &phi; |=<sub><tt><i>BLD</i></tt></sub> &psi; is defined, &phi; |=<sub><tt><i>BLD</i></tt></sub> &psi; iff  &mu;(&phi;) |=<sub><tt><i>L</i></tt></sub> &mu;(&psi;). Here |=<sub><tt><i>BLD</i></tt></sub> denotes the logical entailment in RIF-BLD and |=<sub><tt><i>L</i></tt></sub> is the logical entailment in the language <i>L</i> of the RIF processor.
</p><p>A RIF processor is a <i><b>conformant</b></i> <i>BLD</i><sub>&Tau;,&Epsilon;</sub> <i><b>producer</b></i> iff it implements a <span class="anchor" id="def-sem-preserving-map-from"><i>semantics-preserving mapping</i></span>, &nu;, from the language <i>L</i> of the processor to the set of all <i>BLD</i><sub>&Tau;,&Epsilon;</sub> formulas (&nu; does not need to be an "onto" mapping).
</p><p>Formally, this means that for any pair &phi;, &psi; of formulas in <i>L</i> for which &phi; |=<sub><tt><i>L</i></tt></sub> &psi; is defined, &phi; |=<sub><tt><i>L</i></tt></sub> &psi; iff  &nu;(&phi;) |=<sub><tt><i>BLD</i></tt></sub> &nu;(&psi;).
</p><p>An <i><b>admissible document</b></i> is one which conforms to all the syntactic constraints of RIF-BLD, including ones that cannot be checked by an XML Schema validator (cf. Definition <a href="#def-bld-admissible-xml" title="">Admissible BLD document in XML syntax</a>).
</p><p>The above definitions are specializations to BLD of the general conformance clauses defined in the RIF framework for logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. The following clauses are further restrictions that are specific to RIF-BLD.
</p><p><b>RIF-BLD specific clauses</b>
</p>
<ul><li> Conformant BLD producers and consumers are required to support only the entailments of the form &phi; |=<sub><tt><i>BLD</i></tt></sub> &psi;, where &psi; is a <span class="anchor" id="ptr-closed-rif-condform"><i>closed RIF condition formula</i></span>, i.e., a RIF condition in which every variable, <tt>?V</tt>, is in the scope of a quantifier of the form <tt>Exists&nbsp;?V</tt>.  In addition, conformant BLD producers and consumers <i>should</i> preserve all annotations where possible.
</li></ul>
<ul><li> A <i><b>conformant BLD consumer</b></i> must reject any document containing features it does not support.
</li></ul>
<ul><li> A <i><b>conformant BLD producer</b></i> is a conformant BLD<sub>&Tau;,&Epsilon;</sub> producer, which produces documents that include only the datatypes and externals that are required by BLD.
</li></ul>
<p>RIF-BLD supports a wide variety of syntactic forms for terms and formulas, which creates infrastructure for exchanging syntactically diverse rule languages. It is important to realize, however, that the above conformance statements make it possible for systems that do not support some of the syntax directly to still support it through syntactic transformations. For instance, disjunctions in rule premises can be eliminated through a standard transformation, such as replacing <tt>p&nbsp;:- Or(q r)</tt> with a pair of rules <tt>p&nbsp;:- q, &nbsp; p&nbsp;:- r</tt>. Terms with named arguments can be reduced to positional terms by ordering the arguments by their names and incorporating the ordered argument names into the predicate name. For instance, <tt>p(bb-&gt;1 aa-&gt;2)</tt> can be represented as <tt>p_aa_bb(2 1)</tt>.
</p><p><br />
<span class="anchor" id="sec-bld-fld-spec"></span>
</p>
<a id="RIF-BLD_as_a_Specialization_of_the_RIF_Framework_for_Logic_Dialects_.5BRIF-FLD.5D" name="RIF-BLD_as_a_Specialization_of_the_RIF_Framework_for_Logic_Dialects_.5BRIF-FLD.5D"></a><h2> <span class="mw-headline">6  RIF-BLD as a Specialization of the RIF Framework for Logic Dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>] </span></h2>
<p>This normative section describes RIF-BLD by specializing RIF-FLD. The reader is
assumed to be familiar with RIF-FLD as described in RIF framework for
logic dialects [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. The reader who is not interested in how RIF-BLD is
derived from the framework can skip this section.
</p><p><br />
</p>
<a id="The_Presentation_Syntax_of_RIF-BLD_as_a_Specialization_of_RIF-FLD" name="The_Presentation_Syntax_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.1  The Presentation Syntax of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>This section defines the precise relationship between the presentation syntax of RIF-BLD and the syntactic framework of RIF-FLD.
</p><p>The presentation syntax of the RIF Basic Logic Dialect is defined by specialization from the presentation syntax of the <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-syntactic-framework" title="FLD">RIF Syntactic Framework for Logic Dialects</a> described in [<a href="#ref-rif-fld" title="">RIF-FLD</a>]. Section <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-dialect-syntax" title="FLD">Syntax of a RIF Dialect as a Specialization of the RIF Framework</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>] lists the parameters of the syntactic framework in mathematical English, which we will now specialize for RIF-BLD. 
</p>
<ol>
  <li>
      <i>Extension points</i>.
      <p>
          All extension points of RIF-FLD are removed (specialized by replacing them with zero objects).
      </p>
  </li>
  <li> <i>Alphabet</i>. 
    <p>
      The alphabet of the RIF-BLD presentation syntax is the alphabet of RIF-FLD with the symbols <tt>Dialect</tt>, <tt>Neg</tt>, and <tt>Naf</tt> excluded.
    </p>
  </li>
  <li> <i>Assignment of signatures to each constant and variable symbol</i>.
    <p>
      The signature set of RIF-BLD contains the following signatures:
    </p>
    <ol style="list-style-type:lower-alpha">
      <li>Basic
	<ul>
	  <li><tt>individual{&nbsp;}</tt></li>
	  <li><tt>atomic{&nbsp;}</tt></li>
	</ul>
	<p>
	  The signature <tt>individual{&nbsp;}</tt> represents the context in which individual objects (but not atomic formulas) can appear.
	  <br />
	  The signature <tt>atomic{&nbsp;}</tt> represents the context where atomic formulas can occur. 
	</p>
      </li>
      <li>      
	 Signatures for lists
	 <ul>	 
	   <li>
	      The signature <tt>list</tt> for closed lists. It has the following arrow expressions: <tt>() &rArr; individual</tt>, <tt>(individual) &rArr; individual</tt>, <tt>(individual individual) &rArr; individual</tt>, ...
	   </li>
	   <li>	   
	      The signature <tt>openlist</tt> for open lists (that have tails). It has the following arrow expressions: <tt>(individual individual) &rArr; individual</tt>, <tt>(individual individual individual) &rArr; individual</tt>, ... 
	   </li>
	 </ul>
      </li>
      <li>Signatures for functions, predicates, and external functions and predicates
	<ul>
	  <li>
	    Function signature <tt>f</tt>. This signature has the arrow expressions for positional functions: <tt>() &rArr; individual</tt>, <tt>(individual) &rArr; individual</tt>, <tt>(individual individual) &rArr; individual</tt>, ..., plus the arrow expressions for functions with named arguments: <tt>(s1-&gt;individual ... sk-&gt;individual) &rArr; individual}</tt>, for all k&gt;0 and all <tt>s1, ..., sk</tt> &isin; <tt>ArgNames</tt>. 
	  </li>
	  <li>
	    Predicate signature <tt>p</tt>. This signature has the arrow expressions for positional predicates: <tt>() &rArr; atomic</tt>, <tt>(individual) &rArr; atomic</tt>, <tt>(individual individual) &rArr; atomic</tt>, ..., plus the arrow expressions for predicates with named arguments: <tt>(s1-&gt;individual ... sk-&gt;individual) &rArr; atomic}</tt>, for all k&gt;0 and all <tt>s1, ..., sk</tt> &isin; <tt>ArgNames</tt>.  
	  </li>
	</ul>
	<p>
	  In the RIF-BLD specialization of RIF-FLD, the argument names <tt>s1</tt>, ..., <tt>sk</tt> must be pairwise distinct.
	</p>
      </li>
      <li>Every symbol in <tt>Const</tt> has exactly one signature: <tt>individual</tt>, <tt>f</tt>, or <tt>p</tt>.
	<p>
	  A constant cannot have the signature <tt>atomic</tt> -- only complex terms can have such signatures. Thus, by itself a symbol, <tt>s</tt>,  cannot be a proposition in RIF-BLD, but a term of the form <tt>s()</tt> can.
	</p>
	<p>
	  According to the above, each constant symbol in RIF-BLD can be either an individual, a function, or a predicate. However, the same function or predicate symbol (normal or external) can occur with different numbers of arguments in different places. Also, the <a href="#cond-specialization-external" title="">additional restrictions spelled out below</a> ensure that the same symbol cannot represent both an externally defined predicate or function and a regular predicate or function.
	</p>
      </li>
      <li>The constant symbols that correspond to RIF datatypes (XML Schema datatypes, <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-xmlliteral-space" title="DTB">rdf:XMLLiteral</a></tt>, <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rdf-PlainLiteral-space" title="DTB">rdf:PlainLiteral</a></tt>, etc.) all have the signature <tt>individual</tt> in RIF-BLD.
      </li>
      <li>The symbols of type <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-iri-space" title="DTB">rif:iri</a></tt> and <tt><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#rif-local-space" title="DTB">rif:local</a></tt> can have the following signatures in RIF-BLD: <tt>individual</tt>, <tt>f</tt>, or <tt>p</tt>.
      </li>
      <li>All variables are associated with signature <tt>individual</tt>, so they can range only over individuals.
      </li>
      <li>The signature for equality is <tt>={(individual&nbsp;individual)</tt> &rArr; <tt>atomic}</tt>.
	<p>
          This means that equality can compare only those terms whose signature is <tt>individual</tt>; it cannot compare predicate or function symbols. Equality terms are also not allowed to occur inside other terms, since the above signature implies that any term of the form <tt>t = s</tt> has signature <tt>atomic</tt> and not <tt>individual</tt>.
	</p>
      </li>
      <li>The frame signature, <tt>-&gt;</tt>, is <tt>-&gt;{(individual&nbsp;individual&nbsp;individual)</tt> &rArr; <tt>atomic}</tt>.
	<p>
          Note that this precludes the possibility that a frame term might occur as an argument to a predicate, a function, or inside some other term.
	</p>
      </li>
      <li>The membership signature, <tt>#</tt>, is <tt>#{(individual&nbsp;individual) &rArr; atomic}</tt>.
	<p>
          Note that this precludes the possibility that a membership term might occur as an argument to a predicate, a function, or inside some other term.
	</p>
      </li>
      <li>The signature for the subclass relationship is <tt>##{(individual&nbsp;individual)</tt> &rArr; <tt>atomic}</tt>.
	<p>
          As with frames and membership terms, this precludes the possibility that a subclass term might occur inside some other term.
	</p>
      </li>
    </ol>
    <p>
      RIF-BLD uses no special syntax for declaring signatures. Instead, the rule author specifies signatures <i>contextually</i>. That is, since RIF-BLD requires that each symbol is associated with a unique signature, the signature is determined from the context in which the symbol is used. If a symbol is used in more than one context, the parser must treat this as a syntax error. If no errors are found, all terms and atomic formulas are guaranteed to be well-formed. Thus, signatures are <i>not</i> part of the RIF-BLD language, and <tt>individual</tt>, <tt>atomic</tt>, <tt>list</tt>, etc., are not reserved keywords.
    </p>
  </li>
  <li><i>Supported types of terms</i>.
    <ul>
      <li>
	RIF-BLD supports the following types of terms defined by the syntactic framework (see the Section <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-terms" title="FLD">Terms</a> of [<a href="#ref-rif-fld" title="">RIF-FLD</a>]):
	<ol style="list-style-type:lower-alpha">
	  <li>constants</li>
	  <li>variables</li>
	  <li>positional</li>
	  <li>with named arguments</li>
	  <li>equality</li>
	  <li>frame</li>
	  <li>membership</li>
	  <li>subclass</li>
          <li>list</li>
	  <li>external</li>
	  <li>formula</li>
	</ol>
      </li>
      <li>Compared to RIF-FLD, terms (both positional and with named arguments) have significant restrictions, which are intended to keep BLD relatively simple.
	<ul>
	  <li><i>Variables</i>: The signature for the variable symbols does not permit them to occur in the context of predicates, functions, or formulas. In particular, in the RIF-BLD specialization of RIF-FLD, a variable is not an atomic formula. </li>
	  <li><i>Symbols as atomic formulas</i>: A symbol cannot be an atomic formula by itself. That is, if <tt>s</tt> &isin; <tt>Const</tt> then <tt>s</tt> is not a well-formed atomic formula. However, <tt>s()</tt> can be an atomic formula. Note that Propositional Logic can thus be expressed in RIF-BLD using zero-argument predicate formulas.</li>
	  <li><i>Functions and predicates</i>: Signatures permit only constant symbols to occur in the context of functions or predicate. Indeed, RIF-BLD signatures ensure that all variables have the signature <tt>individual{&nbsp;}</tt> and all other terms, except for the constants from <tt>Const</tt>, can have either the signature <tt>individual{&nbsp;}</tt> or <tt>atomic{&nbsp;}</tt>. Therefore, if <tt>t</tt> is a (non-<tt>Const</tt>) term then <tt>t(...)</tt> is not a well-formed term.
	  </li>
	  <li><i>External</i>:     
	    <ul>	    
	      <li>
		<span class="anchor" id="cond-specialization-external">
		  A term, <tt>t</tt>, may appear as an external term or an external atomic formula (i.e., in the context <tt>External(t)</tt>) <i>if and only if</i> <tt>t</tt> is an instantiation of an externally defined schema from <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">the coherent set of external schemas associated with the language</a>.
		</span>
		<p>
		  It thus follows that a predicate or a function symbol, <tt>s</tt>, that occurs in an external term <tt>External(s(...))</tt> cannot also occur as a non-external symbol.
		</p>
	      </li>
	      <li>
		In an externally defined term, <tt>External(t)</tt>, the subterm <tt>t</tt> can be only a positional or a named-argument term of the form <tt>s(...)</tt> where <tt>s</tt> has the signature <tt>f</tt> or <tt>p</tt>. Compared to RIF-FLD, this restricts <tt>t</tt> so that it cannot be a constant, a frame, an equality, or a classification term. RIF-FLD's two-argument form of <tt>External</tt> is not supported in RIF-BLD either.
	      </li>
	    </ul>
	  </li>
	  <li>	  
	     <i>Formula</i>: The formula terms are restricted, as specified in <a href="#supported-formulas" title="">Supported formulas</a> below. In particular, they cannot appear as arguments to predicates, functions, etc.
	  </li>
	</ul>
      </li>
    </ul> 
  </li>
  <li>  
     No <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#ref-aggregate-term" title="FLD">aggregate terms</a> or <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#ref-module-term" title="FLD">module terms</a> are allowed. (In RIF-FLD, formula terms correspond to compound formulas that involve logical connectives and quantifiers.)
  </li>
  <li><i>Required symbol spaces</i>.
    <p>RIF-BLD requires the symbol spaces defined in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-constants" title="DTB">Constants, Symbol Spaces, and Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
    </p>
  </li> 
  <li>
    <span class="anchor" id="supported-formulas">
    <i>Supported formulas</i>.
    </span>
    <p>RIF-BLD supports the following types of formulas (see <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-fld-wff" title="FLD">Well-formed Terms and Formulas</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>] for the definitions): </p>
    <ul>
      <li><i><b>RIF-BLD condition</b></i>
	<p>
          A RIF-BLD condition is an atomic formula, and external atomic formula, or a conjunctive or disjunctive combination  of such atomic formulas. All these formulas and their combinations can be optionally preceded with existential quantifiers.
	</p>
      </li>
      <li><i><b>RIF-BLD rule</b></i>
	<p>A RIF-BLD rule is a universally quantified RIF-FLD rule with the following restrictions: </p>
	<ul>
	  <li>The conclusion of the rule is an atomic formula or a conjunction of atomic formulas.
	  </li>
	  <li>      
	    None of the atomic formulas mentioned in the rule conclusion is externally defined (i.e., cannot have the form <tt>External(...)</tt>).
	  </li>
	  <li>The premise of the rule is a RIF-BLD condition. </li>
	  <li>All free (non-quantified) variables in the rule must be quantified with <tt>Forall</tt> outside of the rule (i.e., <tt>Forall&nbsp;?vars&nbsp;(conclusion&nbsp;:-&nbsp;premise)</tt>). </li>
	</ul>
      </li>
      <li>    
	<i><b>Universal fact</b></i>
	<p>
	  A universal fact is a universally quantified atomic formula with no free variables.
	</p>
      </li>
      <li>
	<i><b>RIF-BLD group</b></i>
	<p>
          A RIF-BLD group is a RIF-FLD group that contains only RIF-BLD rules,
	  universal facts, variable-free rule implications, variable-free atomic formulas, and RIF-BLD groups.
	</p>
      </li>
      <li>    
	<i><b>RIF-BLD document</b></i>
	<p>
          A RIF-BLD document is a RIF-FLD document that consists of directives and a RIF-BLD group formula. There is no <tt>Dialect</tt> or <tt>Module</tt> directives, and the <tt>Import(&lt;loc&gt;)</tt> directive (with one argument) can import RIF-BLD documents only. Here <tt>loc</tt> must be a Unicode character sequence that forms an IRI. There are no BLD-specific restrictions on the two-argument directive <tt>Import</tt> except that the second argument must be a Unicode sequence of characters of the form <tt>&lt;loc&gt;</tt>, where <tt>loc</tt> is an IRI.
	</p>
      </li>
    </ul>
    <p>
      Negation (<tt>Neg</tt> and <tt>Naf</tt>) is not allowed in RIF-BLD rules: neither in rule conclusions nor in premises.
    </p>
  </li>
</ol>
<p><br />
</p><p><br />
<span class="anchor" id="sec-bld-specialization-semantics"></span>
</p>
<a id="The_Semantics_of_RIF-BLD_as_a_Specialization_of_RIF-FLD" name="The_Semantics_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.2  The Semantics of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>This normative section defines the precise relationship between the semantics
of RIF-BLD and the semantic framework of RIF-FLD. Specification of the
semantics that does not rely on RIF-FLD is given in Section <a href="#sec-bld-direct-semantics" title="">Direct Specification of RIF-BLD Semantics</a>.
</p><p>The semantics of the RIF Basic Logic Dialect is defined by specialization from the semantics of the <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-fld-semantic-framework" title="FLD">semantic framework for logic dialects</a> of RIF. Section <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-rif-dialect-semantics" title="FLD">Semantics of a RIF Dialect as a Specialization of the RIF Framework</a> in [<a href="#ref-rif-fld" title="">RIF-FLD</a>] lists the parameters of the semantic framework that can be specialized. Thus, for RIF-BLD, we need to look at the following parameters:
</p>
<ul>
  <li><i>The effect of the syntax</i>.
    <p>
      RIF-BLD does not support negation. This is the only obvious simplification with respect to RIF-FLD as far as the semantics is concerned.  The restrictions on the signatures of symbols in RIF-BLD do not affect the semantics in a significant way.
    </p>
  </li>
  <li><i>Truth values</i>.
    <p>
      The set <i><b>TV</b></i> of truth values in RIF-BLD consists of two values, <b>t</b> and <b>f</b>, such that <b>f</b> &lt;<sub>t</sub> <b>t</b>.
    </p>
  </li>
  <li><i>Datatypes</i>.
    <p>
      RIF-BLD supports the datatypes listed in Section <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#sec-data-types" title="DTB">Datatypes</a> of [<a href="#ref-rif-dtb" title="">RIF-DTB</a>].
    </p>
  </li>
  <li><i>Logical entailment</i>.
    <p>
      Recall that logical entailment in RIF-FLD is defined with respect to an unspecified set of intended semantic structures and that dialects of RIF must make this notion concrete. For RIF-BLD, this set is defined as the set of all models.
    </p>
  </li>
  <li>  
     <i>Semantic multi-structures</i>.
     <p>
        Since RIF-BLD has no modules (i.e., all formulas are in the same single module), a semantic multi-structure <b>&Icirc;</b> has the form (<b>&Icirc;</b><sub>ren</sub>, {<i><b>I</b></i>}), i.e., <b>&Icirc;</b><sub>set</sub> (in RIF-BLD multistructures) has only one semantic structure; the modularization mapping <b>&Icirc;</b><sub>map</sub> plays no role and can be omitted.
     </p>
  </li>
  <li>
    <i>Import directive</i>.
    <p>
      The semantics of the two-argument <tt>Import</tt> directive is given in [<a href="#ref-rif-swc" title="">RIF-RDF+OWL</a>]. The semantics of the one-argument directive is the same as in RIF-FLD.
    </p>
  </li>
</ul>
<p><span class="anchor" id="sec-bld-specialization-xml"></span>
</p>
<a id="The_XML_Serialization_of_RIF-BLD_as_a_Specialization_of_RIF-FLD" name="The_XML_Serialization_of_RIF-BLD_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.3  The XML Serialization of RIF-BLD as a Specialization of RIF-FLD </span></h4>
<p>Section <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-translate-fld-to-xml" title="FLD">Mapping from the RIF-FLD
Presentation Syntax to the XML Syntax</a> of
[<a href="#ref-rif-fld" title="">RIF-FLD</a>]
defines a mapping, <tt>&chi;<sub>fld</sub></tt>, from the presentation syntax of
RIF-FLD to its XML serialization. When restricted to well-formed
RIF-BLD formulas, <tt>&chi;<sub>fld</sub></tt> coincides with the
<a href="#sec-translation" title="">BLD-to-XML mapping</a> <tt>&chi;<sub>bld</sub></tt>.
In this way, the XML serialization of RIF-BLD is a specialization of the
<a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-fld-specialization-framework" title="FLD">RIF-FLD XML Serialization Framework</a>
defined in [<a href="#ref-rif-fld" title="">RIF-FLD</a>].
</p><p><br />
</p>
<a id="RIF-BLD_Conformance_as_a_Specialization_of_RIF-FLD" name="RIF-BLD_Conformance_as_a_Specialization_of_RIF-FLD"></a><h4> <span class="mw-headline">6.4  RIF-BLD Conformance as a Specialization of RIF-FLD </span></h4>
<p>If T is a set of datatypes and symbol spaces and E a <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/#def-external-schema-set" title="DTB">coherent set of external schemas</a> for functions and predicates, then the general definition of <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/#sec-conformance" title="FLD">conformance in RIF-FLD</a> yields the notion of conformant BLD<sub>T,E</sub> producers and consumers.
</p><p>BLD further requires <i>strictness</i>, i.e., that a conformant producer produces only the documents where T are precisely the datatypes/symbol spaces and E are the external schemas specified in [<a href="#ref-rif-dtb" title="">RIF-DTB</a>], and that a conformant consumer consumes only such documents.
</p>
<a id="Acknowledgements" name="Acknowledgements"></a><h2> <span class="mw-headline">7  Acknowledgements </span></h2>
<p>This document is the product of the Rules Interchange Format (RIF) Working Group (see below) whose 
members deserve recognition for their time and commitment.  The editors extend special thanks to:
Jos de Bruijn, Gary Hallmark, Stella Mitchell, Leora Morgenstern, Adrian Paschke, Axel Polleres, and Dave Reynolds, 
for their thorough reviews and insightful discussions; the working group chairs, Chris Welty and Christian de Sainte-Marie, for their invaluable technical help and inspirational leadership; and W3C staff contact Sandro Hawke, a constant source of ideas, help, and feedback.
</p><p><br />
The regular attendees at meetings of the Rule Interchange Format (RIF) Working Group at the time of the publication were:
Adrian Paschke (Freie Universitaet Berlin), 
Axel Polleres (DERI),
Chris Welty (IBM), 
Christian de Sainte Marie (IBM), 
Dave Reynolds (HP), 
Gary Hallmark (ORACLE), 
Harold Boley (NRC), 
Jos de Bruijn (FUB),
Leora Morgenstern (IBM), 
Michael Kifer (Stony Brook), 
Mike Dean (BBN), 
Sandro Hawke (W3C/MIT), and
Stella Mitchell (IBM).
We would also like to thank past members of the working group, Allen Ginsberg, David Hirtle, Igor Mozetic, and Paula-Lavinia Patranjan.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">8  References </span></h2>
<a id="Normative_References" name="Normative_References"></a><h3> <span class="mw-headline">8.1  Normative References </span></h3>
<p><span class="anchor" id="ref-rdf-concepts"></span> 
</p>
<dl><dt> [RDF-CONCEPTS]
</dt><dd> <i>Resource Description Framework (RDF): Concepts and Abstract Syntax</i>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-concepts/" rel="nofollow" title="http://www.w3.org/TR/rdf-concepts/">http://www.w3.org/TR/rdf-concepts/</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rfc-3066"></span> 
</p>
<dl><dt> [RFC-3066]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3066" title="http://tools.ietf.org/html/rfc3066">RFC 3066</a> - Tags for the Identification of Languages</i>, H. Alvestrand, IETF, January 2001. This document is at <a class="external free" href="http://www.ietf.org/rfc/rfc3066" rel="nofollow" title="http://www.ietf.org/rfc/rfc3066">http://www.ietf.org/rfc/rfc3066</a>. 
</dd></dl>
<p><span class="anchor" id="ref-rfc-3987"></span> 
</p>
<dl><dt> [RFC-3987]
</dt><dd> <i><a class="external" href="http://tools.ietf.org/html/rfc3987" title="http://tools.ietf.org/html/rfc3987">RFC 3987</a> - Internationalized Resource Identifiers (IRIs)</i>, M. Duerst and M. Suignard, IETF, January 2005. This document is <a class="external free" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-core"></span> 
</p>
<dl><dt> [RIF-Core]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/"><span>RIF Core Dialect (Second Edition)</span></a></cite> Harold Boley, Gary Hallmark, Michael Kifer, Adrian Paschke, Axel Polleres, Dave Reynolds, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-core-20130205/">http://www.w3.org/TR/2013/REC-rif-core-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-core/">http://www.w3.org/TR/rif-core/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-dtb"></span>
</p>
<dl><dt> [RIF-DTB]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/"><span>RIF Datatypes and Built-Ins 1.0 (Second Edition)</span></a></cite> Axel Polleres, Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-dtb-20130205/">http://www.w3.org/TR/2013/REC-rif-dtb-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-dtb/">http://www.w3.org/TR/rif-dtb/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-fld"></span>
</p>
<dl><dt> [RIF-FLD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/"><span>RIF Framework for Logic Dialects (Second Edition)</span></a></cite> Harold Boley, Michael Kifer, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-fld-20130205/">http://www.w3.org/TR/2013/REC-rif-fld-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-fld/">http://www.w3.org/TR/rif-fld/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-prd"></span>
</p>
<dl><dt> [RIF-PRD]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/"><span>RIF Production Rule Dialect (Second Edition)</span></a></cite> Christian de Sainte Marie, Gary Hallmark, Adrian Paschke, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-prd-20130205/">http://www.w3.org/TR/2013/REC-rif-prd-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-prd/">http://www.w3.org/TR/rif-prd/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-rif-swc"></span>
</p>
<dl><dt> [RIF-RDF+OWL]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/"><span>RIF RDF and OWL Compatibility (Second Edition)</span></a></cite> Jos de Bruijn, Chris Welty, eds. W3C Recommendation, 5 February 2013, <a href="http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/">http://www.w3.org/TR/2013/REC-rif-rdf-owl-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-rdf-owl/">http://www.w3.org/TR/rif-rdf-owl/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-xml-1-point-0"></span> 
</p>
<dl><dt> [XML1.0]
</dt><dd> <i>Extensible Markup Language (XML) 1.0 (Fourth Edition)</i>, W3C Recommendation, World Wide Web Consortium, 16 August 2006, edited in place 29 September 2006. This version is <a class="external free" href="http://www.w3.org/TR/2006/REC-xml-20060816/" rel="nofollow" title="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</a>.
</dd></dl>
<p><span class="anchor" id="ref-xml-base"></span> 
</p>
<dl><dt> [XML-Base]
</dt><dd> <i>XML Base</i>, W3C Recommendation, World Wide Web Consortium, 27 June 2001. This version is <a class="external free" href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/" rel="nofollow" title="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">http://www.w3.org/TR/2001/REC-xmlbase-20010627/</a>. The latest version is available at <a class="external free" href="http://www.w3.org/TR/xmlbase/" rel="nofollow" title="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>.
</dd></dl>
<p>
</p>
<dl><dt> <span id="ref-xml-schema2">[XML Schema Datatypes]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>. David Peterson, Shudi Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and Henry S. Thompson, eds.  W3C Recommendation, 5 April 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/</a>.  Latest version available as <a class="external free" href="http://www.w3.org/TR/xmlschema11-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
</dd></dl>
<a id="Informational_References" name="Informational_References"></a><h3> <span class="mw-headline">8.2  Informational References </span></h3>
<p><span class="anchor" id="ref-alternating-normal-form"></span> 
</p>
<dl><dt> [ANF01]
</dt><dd> <i>Normal Form Conventions for XML Representations of Structured Data</i>, Henry S. Thompson. October 2001. Available at <a class="external free" href="http://www.ltg.ed.ac.uk/~ht/normalForms.html" rel="nofollow" title="http://www.ltg.ed.ac.uk/~ht/normalForms.html">http://www.ltg.ed.ac.uk/~ht/normalForms.html</a>.
</dd></dl>
<p><span class="anchor" id="ref-sparql-expr"></span>
</p>
<dl><dt> [AG08]
</dt><dd> The Expressive Power of SPARQL, Renzo Angles and Claudio Gutierrez. <i>International Semantic Web Conference 2008</i>: 114-129
</dd></dl>
<p><span class="anchor" id="ref-sparql-rules"></span>
</p>
<dl><dt> [AP07]
</dt><dd> From SPARQL to rules (and back), Axel Polleres. <i>WWW 2007</i>: 787-796 
</dd></dl>
<p><span class="anchor" id="ref-cg"></span> 
</p>
<dl><dt> [CG]
</dt><dd> Information Processing, John Sowa, in <i>Mind and Machine.</i> JReading, MA: Addison-Wesley Publ., 1984.
</dd></dl>
<p><span class="anchor" id="ref-chang-lee"></span> 
</p>
<dl><dt> [CL73]
</dt><dd> <i>Symbolic Logic and Mechanical Theorem Proving</i>, C.L. Chang and R.C.T. Lee. Academic Press, 1973.
</dd></dl>
<p><span class="anchor" id="ref-common-logic"></span> 
</p>
<dl><dt> [CL07]
</dt><dd> <i>ISO/IEC 24707:2007</i>.  The ISO Common Logic Standard.  Available through <a class="external free" href="http://common-logic.org" rel="nofollow" title="http://common-logic.org">http://common-logic.org</a>
</dd></dl>
<p><span class="anchor" id="ref-curie"></span> 
</p>
<dl><dt> [CURIE]
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">CURIE Syntax 1.0</a></cite>, S. McCarron, M. Birbeck,  Editors, W3C Working Group Note, 16 December 2010, <a class="external free" href="http://www.w3.org/TR/2010/NOTE-curie-20101216" rel="nofollow" title="http://www.w3.org/TR/2010/NOTE-curie-20101216">http://www.w3.org/TR/2010/NOTE-curie-20101216</a> . Latest version available at <a class="external free" href="http://www.w3.org/TR/curie" rel="nofollow" title="http://www.w3.org/TR/curie">http://www.w3.org/TR/curie</a>.
</dd></dl>
<p><span class="anchor" id="ref-enderton01"></span> 
</p>
<dl><dt> [Enderton01]
</dt><dd> <i>A Mathematical Introduction to Logic, Second Edition</i>, H. B. Enderton. Academic Press, 2001.
</dd></dl>
<p><span class="anchor" id="ref-kif"></span> 
</p>
<dl><dt> [KIF]
</dt><dd> <i>Knowledge Interchange Format,</i> M. Genesereth, et al. 1998.  Available at <a class="external free" href="http://logic.stanford.edu/kif/dpans.html" rel="nofollow" title="http://logic.stanford.edu/kif/dpans.html">http://logic.stanford.edu/kif/dpans.html</a>
</dd></dl>
<p><span class="anchor" id="ref-flogic-95"></span> 
</p>
<dl><dt> [KLW95]
</dt><dd> <i>Logical foundations of object-oriented and frame-based languages,</i> M. Kifer, G. Lausen, J. Wu. Journal of ACM, July 1995, pp. 741--843.
</dd></dl>
<p><span class="anchor" id="ref-mendelson97"></span> 
</p>
<dl><dt> [Mendelson97]
</dt><dd> <i>Introduction to Mathematical Logic, Fourth Edition</i>, E. Mendelson. Chapman &amp; Hall, 1997.
</dd></dl>
<dl><dt><span id="ref-owl-reference">[OWL-Reference]</span>
</dt><dd> <i><a class="external text" href="http://www.w3.org/TR/2004/REC-owl-ref-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web Ontology Language Reference</a></i>, M. Dean, G. Schreiber, Editors, W3C Recommendation, 10 February 2004. Latest version available at <a class="external free" href="http://www.w3.org/TR/owl-ref/" rel="nofollow" title="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rdf-syntax"></span> 
</p>
<dl><dt> [RDFSYN04]
</dt><dd> <i>RDF/XML Syntax Specification (Revised)</i>, Dave Beckett, Editor, W3C Recommendation, 10 February 2004, <a class="external free" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/</a>. Latest version available at <a class="external free" href="http://www.w3.org/TR/rdf-syntax-grammar/" rel="nofollow" title="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-ucr"></span>
</p>
<dl><dt> [RIF-UCR]
</dt><dd><span><cite><a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/"><span>RIF Use Cases and Requirements (Second Edition)</span></a></cite> Adrian Paschke, Leora Morgenstern, David Hirtle, Allen Ginsberg, Paula-Lavinia Patranjan, Frank McCabe, eds. W3C Working Group Note, 5 February 2013, <a href="http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/">http://www.w3.org/TR/2013/NOTE-rif-ucr-20130205/</a>.  Latest version available at <a href="http://www.w3.org/TR/rif-ucr/">http://www.w3.org/TR/rif-ucr/</a>.</span></dd></dl>
<p><span class="anchor" id="ref-steele90"></span> 
</p>
<dl><dt> [Steele90]
</dt><dd> <i>Common LISP: The Language, Second Edition</i>, G. L. Steele Jr. Digital Press, 1990.
</dd></dl>
<p><span class="anchor" id="ref-type-and-role-tags"></span> 
</p>
<dl><dt> [TRT03]
</dt><dd> <i>Object-Oriented RuleML: User-Level Roles, URI-Grounded Clauses, and Order-Sorted Terms</i>, H. Boley.  Springer LNCS 2876, Oct. 2003, pp. 1-16.  Available at <a class="external free" href="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf" rel="nofollow" title="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf">http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=rtdoc&amp;an=5764336&amp;article=19&amp;fd=pdf</a>.
</dd></dl>
<p><span class="anchor" id="ref-rif-urd"></span> 
</p>
<dl><dt> [URD08]
</dt><dd> <i>Uncertainty Treatment in the Rule Interchange Format: From Encoding to Extension</i>, J. Zhao, H. Boley.  4th Int&rsquo;l Workshop on Uncertainty Reasoning for the Semantic Web (URSW 2008). Available at <a class="external free" href="http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf" rel="nofollow" title="http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf">http://c4i.gmu.edu/ursw/2008/papers/URSW2008_F9_ZhaoBoley.pdf</a>.
</dd></dl>
<p><span class="anchor" id="ref-vanemden-kowalski"></span> 
</p>
<dl><dt> [vEK76]
</dt><dd> <i>The semantics of predicate logic as a programming language</i>, M. van Emden and R. Kowalski. Journal of the ACM 23 (1976), pp. 733-742.
</dd></dl>
<p><br />
</p><p><span class="anchor" id="sec-xsd-bld"></span>
</p>
<a id="Appendix:_XML_Schema_for_RIF-BLD" name="Appendix:_XML_Schema_for_RIF-BLD"></a><h2> <span class="mw-headline">9  Appendix: XML Schema for RIF-BLD </span></h2>
<p>The <b>namespace</b> of RIF is "<a class="external free" href="http://www.w3.org/2007/rif" rel="nofollow" title="http://www.w3.org/2007/rif#">http://www.w3.org/2007/rif#</a>". 
</p><p>XML schemas for the RIF-BLD sublanguages are defined below and are also available at <a class="external free" href="http://www.w3.org/2010/rif-schema/bld/" rel="nofollow" title="http://www.w3.org/2010/rif-schema/bld/">http://www.w3.org/2010/rif-schema/bld/</a> with additional examples. 
</p><p><br />
</p>
<a id="Condition_Language" name="Condition_Language"></a><h3> <span class="mw-headline">9.1  Condition Language </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: BLDCond.xsd, v. 1.6, 2010-05-08, dhirtle/hboley"&gt;

 &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
            schemaLocation='http://www.w3.org/2001/xml.xsd'/&gt; 
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Condition Language as defined by
    the Last Call Draft of the RIF Basic Logic Dialect.
    
    The schema is based on the following EBNF for the RIF-BLD Condition Language:
 
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
  Atom          &nbsp;::= UNITERM
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
  Equal         &nbsp;::= TERM '=' TERM
  Member        &nbsp;::= TERM '#' TERM
  Subclass      &nbsp;::= TERM '##' TERM
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
  Expr          &nbsp;::= UNITERM
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
  Var           &nbsp;::= '?' Name
  Name          &nbsp;::= NCName | '"' UNICODESTRING '"'
  SYMSPACE      &nbsp;::= ANGLEBRACKIRI | CURIE
 
  IRIMETA       &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
 
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  
  &lt;xs:group name="FORMULA"&gt;  
    &lt;!--
  FORMULA       &nbsp;::= IRIMETA? 'And' '(' FORMULA* ')' |
                     IRIMETA? 'Or' '(' FORMULA* ')' |
                     IRIMETA? 'Exists' Var+ '(' FORMULA ')' |
                     ATOMIC |
                     IRIMETA? 'External' '(' Atom ')'
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="And"/&gt;
      &lt;xs:element ref="Or"/&gt;
      &lt;xs:element ref="Exists"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
      &lt;xs:element name="External" type="External-FORMULA.type"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:complexType name="External-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-FORMULA.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-FORMULA.type"&gt;
    &lt;!-- sensitive to FORMULA (Atom) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Atom"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="And"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Or"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="formula" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Exists"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="formula"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="formula"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="declare"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Var"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="ATOMIC"&gt;
    &lt;!--
  ATOMIC        &nbsp;::= IRIMETA? (Atom | Equal | Member | Subclass | Frame)
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Atom"/&gt;
      &lt;xs:element ref="Equal"/&gt;
      &lt;xs:element ref="Member"/&gt;
      &lt;xs:element ref="Subclass"/&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Atom"&gt;
    &lt;!--
  Atom          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  
  &lt;xs:group name="UNITERM"&gt;
    &lt;!--
  UNITERM       &nbsp;::= Const '(' (TERM* | (Name '-&gt;' TERM)*) ')'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="op"/&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="args" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element name="slot" type="slot-UNITERM.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="op"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Const"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="args"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-UNITERM.type"&gt;
    &lt;!-- sensitive to UNITERM (Name) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Name"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="Equal"&gt;
    &lt;!--
  Equal         &nbsp;::= TERM '=' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="left"/&gt;
        &lt;xs:element ref="right"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="left"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="right"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Member"&gt;
    &lt;!--
  Member        &nbsp;::= TERM '#' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="instance"/&gt;
        &lt;xs:element ref="class"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Subclass"&gt;
    &lt;!--
  Subclass      &nbsp;::= TERM '##' TERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sub"/&gt;
        &lt;xs:element ref="super"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="instance"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="class"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sub"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="super"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="Frame"&gt;
    &lt;!--
  Frame         &nbsp;::= TERM '[' (TERM '-&gt;' TERM)* ']'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="object"/&gt;
        &lt;xs:element name="slot" type="slot-Frame.type" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="object"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="slot-Frame.type"&gt;
    &lt;!-- sensitive to Frame (TERM) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="TERM"/&gt;
      &lt;xs:group ref="TERM"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:group name="TERM"&gt;  
    &lt;!--
  TERM          &nbsp;::= IRIMETA? (Const | Var | Expr | List | 'External' '(' Expr ')')
    --&gt;
      &lt;xs:choice&gt;
         &lt;xs:element ref="Const"/&gt;
         &lt;xs:element ref="Var"/&gt;
         &lt;xs:element ref="Expr"/&gt;
         &lt;xs:element ref="List"/&gt;
         &lt;xs:element name="External" type="External-TERM.type"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="List"&gt;  
    &lt;!--
  List          &nbsp;::= 'List' '(' TERM* ')' | 'List' '(' TERM+ '|' TERM ')'
             rewritten as
  List          &nbsp;::= 'List' '(' LISTELEMENTS? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:group ref="LISTELEMENTS" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:group name="LISTELEMENTS"&gt;
    &lt;!--
  LISTELEMENTS  &nbsp;::= TERM+ ('|' TERM)?
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="items"/&gt;
      &lt;xs:element ref="rest" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="items"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="ordered" type="xs:string" fixed="yes"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="rest"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="TERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="External-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="content" type="content-TERM.type"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="content-TERM.type"&gt;
    &lt;!-- sensitive to TERM (Expr) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Expr"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:element name="Expr"&gt;
    &lt;!--
  Expr          &nbsp;::= UNITERM
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="UNITERM"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Const"&gt;
    &lt;!--
  Const         &nbsp;::= '"' UNICODESTRING '"^^' SYMSPACE | CONSTSHORT
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" type="xs:anyURI" use="required"/&gt; 
      &lt;xs:attribute ref="xml:lang"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Name" type="xs:string"&gt;
    &lt;!--
  Name          &nbsp;::= NCName | '"' UNICODESTRING '"'   
  ... i.e., 'Name' stands for either the NCName string or the UNICODESTRING with the outer quotes stripped off.
    --&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="Var"&gt;
    &lt;!--
  Var           &nbsp;::= '?' Name
    --&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="IRIMETA"&gt;
    &lt;!--
  IRIMETA  &nbsp;::= '(*' IRICONST? (Frame | 'And' '(' Frame* ')')? '*)'
    --&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="id" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="meta" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="id"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="Const" type="IRICONST.type"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="meta"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:element ref="Frame"/&gt;
       &lt;xs:element name="And" type="And-meta.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:complexType name="And-meta.type"&gt;
  &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-meta.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-meta.type"&gt;
    &lt;!-- sensitive to meta (Frame) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="Frame"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="IRICONST.type" mixed="true"&gt;
    &lt;!-- sensitive to location/id context--&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="type" type="xs:anyURI" use="required" fixed="http://www.w3.org/2007/rif#iri"/&gt;
  &lt;/xs:complexType&gt;
  
 &lt;/xs:schema&gt;
</pre>
<a id="Rule_Language" name="Rule_Language"></a><h3> <span class="mw-headline">9.2  Rule Language </span></h3>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 
 &lt;xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns="http://www.w3.org/2007/rif#"
  targetNamespace="http://www.w3.org/2007/rif#"
  elementFormDefault="qualified"
  version="Id: BLDRule.xsd, v. 1.6, 2010-02-02, dhirtle/hboley"&gt;
 
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    This is the XML schema for the Rule Language as defined by
    the Last Call Draft of the RIF Basic Logic Dialect.
    
    The schema is based on the following EBNF for the RIF-BLD Rule Language:
  
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
  Base     &nbsp;::= 'Base' '(' ANGLEBRACKIRI ')'
  Prefix   &nbsp;::= 'Prefix' '(' NCName ANGLEBRACKIRI ')'
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  Group    &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
  RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
  CLAUSE   &nbsp;::= Implies | ATOMIC
  Implies  &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
      
    Note that this is an extension of the syntax for the RIF-BLD Condition Language (BLDCond.xsd).
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
 
  &lt;!-- The Rule Language includes the Condition Language from the same directory --&gt;
  &lt;xs:include schemaLocation="BLDCond.xsd"/&gt;
 
  &lt;xs:element name="Document"&gt;
    &lt;!--
  Document &nbsp;::= IRIMETA? 'Document' '(' Base? Prefix* Import* Group? ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="directive" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="payload" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="directive"&gt;
    &lt;!--
  Base and Prefix represented directly in XML
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Import"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="payload"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Group"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="Import"&gt;
    &lt;!--
  Import   &nbsp;::= IRIMETA? 'Import' '(' LOCATOR PROFILE? ')'
  LOCATOR  &nbsp;::= ANGLEBRACKIRI
  PROFILE  &nbsp;::= ANGLEBRACKIRI
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt; 
        &lt;xs:element ref="location"/&gt;
        &lt;xs:element ref="profile" minOccurs="0" maxOccurs="1"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="location" type="xs:anyURI"/&gt;
 
  &lt;xs:element name="profile" type="xs:anyURI"/&gt;
  
  &lt;xs:element name="Group"&gt;
    &lt;!--
  Group    &nbsp;::= IRIMETA? 'Group' '(' (RULE | Group)* ')'
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="sentence" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="sentence"&gt;
   &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="RULE"/&gt;
       &lt;xs:element ref="Group"/&gt;
     &lt;/xs:choice&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;
  
  &lt;xs:group name="RULE"&gt;
    &lt;!--
  RULE     &nbsp;::= (IRIMETA? 'Forall' Var+ '(' CLAUSE ')') | CLAUSE
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Forall"/&gt;
      &lt;xs:group ref="CLAUSE"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
 
  &lt;xs:element name="Forall"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="declare" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;!-- different from formula in And, Or and Exists --&gt;
        &lt;xs:element name="formula"&gt;
          &lt;xs:complexType&gt;
            &lt;xs:group ref="CLAUSE"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:group name="CLAUSE"&gt;  
    &lt;!--
  CLAUSE  &nbsp;::= Implies | ATOMIC
    --&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="Implies"/&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  
  &lt;xs:element name="Implies"&gt;
    &lt;!--
  Implies  &nbsp;::= IRIMETA? (ATOMIC | 'And' '(' ATOMIC* ')') ':-' FORMULA
    --&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="IRIMETA" minOccurs="0" maxOccurs="1"/&gt;
        &lt;xs:element ref="if"/&gt;
        &lt;xs:element ref="then"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:element name="if"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:group ref="FORMULA"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="then"&gt;
    &lt;xs:complexType&gt;
     &lt;xs:choice&gt;
       &lt;xs:group ref="ATOMIC"/&gt;
       &lt;xs:element name="And" type="And-then.type"/&gt;
     &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
 
  &lt;xs:complexType name="And-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="formula" type="formula-then.type" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="formula-then.type"&gt;
    &lt;!-- sensitive to then (ATOMIC) context--&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="ATOMIC"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
   
 &lt;/xs:schema&gt;
</pre>
<p><br />
</p><p><span class="anchor" id="sec-changelog"></span>
</p>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">10  Appendix: Change Log (Informative) </span></h2>
<p>This appendix summarizes the main changes to this document.
</p><p>Changes since the <a class="external text" href="http://www.w3.org/TR/2008/WD-rif-bld-20080730/" rel="nofollow" title="http://www.w3.org/TR/2008/WD-rif-bld-20080730/">draft of July 30, 2008</a>.
</p>
<ul><li> The definition of entailment in Section <a href="#sec-logical-entailment" title="">Logical Entailment</a> relied on the notion of a "query document," which was not defined. The definitions in Sections <a href="#sec-interpretation-of-documents" title="">Interpretation of Documents</a> and <a href="#sec-logical-entailment" title="">Logical Entailment</a> has been changed to eliminate this and related problems.
</li><li> Section <a href="#sec-concrete-syntax" title="">EBNF Grammar for the Presentation Syntax of RIF-BLD</a> now presents the EBNF of the entire language in one place. Previously the EBNF was given forst for the condition sublanguage and then repeated again when the entire rule language is defined.
</li><li> Symbols can now have many different arities.
</li><li> Lists have been added.
</li><li> Import: the first argument is now a character sequence that forms and IRI.
</li><li> Base, Prefix, Import: IRIs are now delimited with angle brackets.
</li><li> Numerous clarifications and explanations were added in response to the public comments.
</li><li> A number of typos were found and fixed.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/WD-rif-bld-20090703/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-rif-bld-20090703/">draft of July 3, 2009</a>.
</p>
<ul><li> A definedness condition was added to the definition of logical entailment.
</li><li> The bag of attribute/value pairs example was better explained.
</li><li> IRICONST was replaced with ANYURICONST in BLDRule.xsd, v. 1.5.
</li><li> A number of typos were found and fixed.
</li><li> "instance" of an external schema was replaced with "instantiation" of an external schema.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/2009/CR-rif-bld-20091001/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-rif-bld-20091001/">Candidate Recommendation of October 1, 2009</a>.
</p>
<ul><li> Import's anyURIs were moved directly into location and profile.
</li><li> A number of typos was fixed and various clarifications added.
</li><li> Simplified notion of conformant BLD consumer.
</li><li> Fixed List by permitting IRIMETA and aligning syntax to Expr and Atom.
</li></ul>
<p>Changes since the <a class="external text" href="http://www.w3.org/TR/rif-bld" rel="nofollow" title="http://www.w3.org/TR/rif-bld">Recommendation of June 22 2010</a>.
</p>
<ul><li> Definitions in Section <a href="#sec-interpretation-of-documents" title="">Interpretation of Documents</a> have been rewritten and significantly simplified.
</li><li> In Section<a href="#sec-bld-specialization-semantics" title="">The Semantics of RIF-BLD as a Specialization of RIF-FLD</a>, a paragraph added about specialization from RIF-FLD semantic multi-structures.
</li><li> Other minor corrections (see <a class="external text" href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;diff=14354&amp;oldid=12716" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;diff=14354&amp;oldid=12716">here</a> and <a class="external text" href="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;diff=14586&amp;oldid=14582" rel="nofollow" title="http://www.w3.org/2005/rules/wiki/index.php?title=BLD&amp;diff=14586&amp;oldid=14582">here</a>).
</li><li> Two new rows added in the table of Section <a href="#Mapping_of_the_Condition_Language" title="">Mapping of the Condition Language</a> for empty args in Atom and Expr; restriction of earlier Atom and Expr rows to non-empty args (replaced n with m).
</li></ul>
</div>


</body>
</html>