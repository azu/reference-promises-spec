<!-- http://www.w3.org/TR/prov-constraints/ -->
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head> 
    <title>Constraints of the PROV Data Model</title> 
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<link rel="http://www.w3.org/ns/prov#has_provenance" href="http://www.w3.org/2011/prov/provenance/prov-constraints">

    <!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
<!-- PM -->
    <style type="text/css">
      .note { font-size:small; margin-left:50px }


/* --- EDITORIAL NOTES --- */
.pending {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #BFEFFF;
}

.pending::before {
    content:    "Pending Review";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}




.resolved {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #9BCD9B;
}

.resolved::before {
    content:    "Resolved";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}


.inference {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #fff;
}


.inference-example {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #fff;
}

/* .inference[id]::before { */
/*     content:    "Inference: " attr(id); */
/*     width:  380px;  /\* How can we compute the length of "Constraint: " attr(id) *\/ */
/* } */


/* .inference::before { */
/*     content:    "Inference"; */
/*     display:    block; */
/*     width:  150px; */
/*     margin: -1.5em 0 0.5em 0; */
/*     font-weight:    bold; */
/*     border: 1px solid #f00; */
/*     background: #fff; */
/*     padding:    3px 1em; */
/* } */

.syntax {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #fff;
}

.syntax[id]::before {
    content:    "Syntax: " attr(id);
    width:  380px;  /* How can we compute the length of "Constraint: " attr(id) */
}


.syntax::before {
    content:    "Syntax";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

.unamedconstraint {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #00f;
    background: #fff;
}


.unamedconstraint::before {
    content:    "Constraint";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #00f;
    background: #fff;
    padding:    3px 1em;
}



.constraint {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #00f;
    background: #fff;
}

.constraint-example {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #00f;
    background: #fff;
}

/* .constraint[id]::before { */
/*     content:    "Constraint: " attr(id); */
/*     width:  380px;  /\* How can we compute the length of "Constraint: " attr(id) *\/ */
/* } */


/* .constraint::before { */
/*     content:    "Constraint"; */
/*     display:    block; */
/*     width:  150px; */
/*     margin: -1.5em 0 0.5em 0; */
/*     font-weight:    bold; */
/*     border: 1px solid #00f; */
/*     background: #fff; */
/*     padding:    3px 1em; */
/* } */



.interpretation {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #00f;
    background: #fff;
}

.interpretation[id]::before {
    content:    "Interpretation: " attr(id);
    width:  380px;  /* How can we compute the length of "Interpretation: " attr(id) */
}


.interpretation::before {
    content:    "Interpretation";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #00f;
    background: #fff;
    padding:    3px 1em;
}

.definition {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #777;
    background: #fff;
}

.definition-example {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #777;
    background: #fff;
}

/* .definition[id]::before { */
/*     content:    "Definition: " attr(id); */
/*     width:  380px;  */
/* } */


/* .definition::before { */
/*     content:    "Definition"; */
/*     display:    block; */
/*     width:  150px; */
/*     margin: -1.5em 0 0.5em 0; */
/*     font-weight:    bold; */
/*     border: 1px solid #000; */
/*     background: #fff; */
/*     padding:    3px 1em; */
/* } */


.deprecatedconstraint {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #00f;
    background: #fff;
}

.deprecatedconstraint[id]::before {
    content:    "Deprecated: " attr(id);
    width:  380px;  /* How can we compute the length of "Deprecatedconstraint: " attr(id) */
}


.deprecatedconstraint::before {
    content:    "Deprecated";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #00f;
    background: #fff;
    padding:    3px 1em;
}

.glossary-ref {
    font-style:    italic;
}

.dfn {
    font-weight:    bold;
}


.attribute {
    font-style: italic;
}


.conditional {
    color: blue;
}

.grammar {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    font-size: 95%;
}
.nonterminal {
    font-weight: bold;
    font-family: sans-serif;
    font-size: 95%;
}

.name {
    font-family: monospace;
}

.math {
    font-family: roman;
    font-style:italic;
}


.xmpl {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px solid #f00;
    background: #fff;
}

.xmpl::before {
    content:    "Example";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

/*
.anexample[count]::before {
    content: "Example " attr(count) ;
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

.anexample:before {
    content: "Example:";
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}

*/

.anexample {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    background-color: #f9f9f9;
}
.anexample table {
    background-color: #f9f9f9;
}

.conceptexample:before {
    content: "Example:";
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}
.conceptexample {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    background-color: #f9f9f9;
}

.pnExpression {
    font-weight: normal;
    font-size:120%;
    font-family: monospace;
}


div[class="grammar"] span[class="name"]:before {
    content: "'";
}

div[class="grammar"] span[class="name"]:after {
    content: "'";
}


div[class="grammar"] span[class="optional"]:before {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: "(";
}

div[class="grammar"] span[class="optional"]:after {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: ")?";
}


div[class="grammar"] span[class="plus"]:before {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: "(";
}

div[class="grammar"] span[class="plus"]:after {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: ")+";
}


div[class="grammar"] span[class="star"]:before {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: "(";
}

div[class="grammar"] span[class="star"]:after {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: ")*";
}

div[class="grammar"] span[class="choice"]:before {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: "(";
}

div[class="grammar"] span[class="choice"]:after {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: ")";
}

div[class="grammar"] span[class="group"]:before {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: "(";
}

div[class="grammar"] span[class="group"]:after {
    font-weight: normal;
    font-size:130%;
    font-family: monospace;
    content: ")";
}

table {
    background-color: #f9f9f9;
}

.component1-color {
 background-color: rgba(255,42,42,0.2);
}

.component2-color {
 background-color: rgba(0,68,170,0.2);
}

.component3-color {
 background-color: rgba(0,170,0,0.2);
}
.component4-color {
 background-color: rgba(204,255,0,0.2);
}

.component5-color {
 background-color: rgba(11,40,40,0.2);
}

.component6-color {
 background-color: rgba(244,105,14,0.2);
}

.interpretation-forward::before {
    content:    "Interpretation: ";
    font-weight:    bold;
}

.structural-forward::before {
    content:    "Structural constraint: ";
    font-weight:    bold;
}


code {
    color:  black;
}

.ruleTitle {
    font-family: sans-serif;
    font-size: 1.6ex;
    font-weight: bold;
}




.remark {
    padding:    1em;
    margin: 1em 0em 0em;
    border: 1px dashed #000;
    background: #F0F0F0;
}

.remark::before {
    content:    "Remark";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #000;
    background: #fff;
    padding:    3px 1em;
}

table.thinborder {
	border-width: 1px;
	border-spacing: 0px;
	border-style: none;
	border-color: gray;
	border-collapse: collapse;
}
table.thinborder th {
	border-width: 1px;
	padding: 0px;
	border-style: solid;
	border-color: gray;
}
table.thinborder td {
	border-width: 1px;
	padding: 2px;
	border-style: solid;
	border-color: gray;
}


     </style>


     

     

    

    

    
    

     
  <style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}
</style><link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-REC"><!--[if lt IE 9]><script src='http://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]--></head> 
  <body><div class="head">
  <p>
    
      <a href="http://www.w3.org/"><img width="72" height="48" src="http://www.w3.org/Icons/w3c_home" alt="W3C"></a>
    
  </p>
  <h1 class="title" id="title">Constraints of the PROV Data Model</h1>
  
  <h2 id="w3c-recommendation-30-april-2013"><abbr title="World Wide Web Consortium">W3C</abbr> Recommendation 30 April 2013</h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a href="http://www.w3.org/TR/2013/REC-prov-constraints-20130430/">http://www.w3.org/TR/2013/REC-prov-constraints-20130430/</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="http://www.w3.org/TR/prov-constraints/">http://www.w3.org/TR/prov-constraints/</a></dd>
    
    
    
      <dt>Test suite:</dt>
      <dd><a href="http://dvcs.w3.org/hg/prov/raw-file/default/testcases/process.html">http://dvcs.w3.org/hg/prov/raw-file/default/testcases/process.html</a></dd>
    
    
      <dt>Implementation report:</dt>
      <dd><a href="http://www.w3.org/TR/2013/NOTE-prov-implementations-20130430/">http://www.w3.org/TR/2013/NOTE-prov-implementations-20130430/</a></dd>
    
    
    
      <dt>Previous version:</dt>
      <dd><a href="http://www.w3.org/TR/2013/PR-prov-constraints-20130312/">http://www.w3.org/TR/2013/PR-prov-constraints-20130312/</a> <a href="diff-c.html">(color-coded diff)</a></dd>
    
    
    <dt>Editors:</dt>
    <dd><a href="http://homepages.inf.ed.ac.uk/jcheney">James Cheney</a>, University of Edinburgh</dd>
<dd><a href="http://www.cs.ncl.ac.uk/people/Paolo.Missier">Paolo Missier</a>, Newcastle University</dd>
<dd><a href="http://www.ecs.soton.ac.uk/~lavm/">Luc Moreau</a>, University of Southampton</dd>

    
      <dt>Author:</dt>
      <dd><a href="http://users.ugent.be/~tdenies/">Tom De Nies</a>, iMinds - Ghent University</dd>

    
  </dl>
  
    <p>
      Please refer to the <a href="http://www.w3.org/2011/prov/errata.html"><strong>errata</strong></a> for this document, which may include some normative corrections.
    </p>
  
  
  
    <p>
      The English version of this specification is the only normative version. Non-normative 
      <a href="http://www.w3.org/Consortium/Translation/">translations</a> may also be available.
    </p>
  
  
    
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 
        2012-2013
        
        <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> 
        (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
        <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved.
        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
        <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
      </p>
    
  
  <hr>
</div> 

    <section id="abstract" class="introductory"><h2>Abstract</h2>
<p>
Provenance is information about entities, activities, and people
involved in producing a piece of data or thing, which can be used to
form assessments about its quality, reliability or
trustworthiness. PROV-DM is the conceptual data model that forms a
basis for the <abbr title="World Wide Web Consortium">W3C</abbr> provenance (PROV) family of specifications.
<!--
PROV-DM
distinguishes core structures, forming the essence of provenance
information, from extended structures catering for more specific uses
of provenance. PROV-DM is organized in six components, respectively
dealing with: (1) entities and activities, and the time at which they
were created, used, or ended; (2) derivations of entities from
entities; (3) agents bearing responsibility for entities that were
generated and activities that happened; (4) a notion of bundle, a
mechanism to support provenance of provenance; (5) properties to link
entities that refer to the same thing; and, (6) collections forming a
logical structure for its members.
-->
</p>


<p> This document defines a subset of PROV instances called
<i><a href="#dfn-valid" class="internalDFN">valid</a></i> PROV instances, by analogy with notions of
validity for other Web standards.
The intent of validation is to ensure that a PROV instance represents a
consistent history of objects and their interactions that is safe to
use for the purpose of logical reasoning and other kinds of analysis.
Valid PROV instances satisfy
certain <a title="definition" href="#dfn-definition" class="internalDFN">definitions</a>, <a title="inference" href="#inference" class="internalDFN">inferences</a>, and
<a title="constraint">constraints</a>. These definitions, inferences, and constraints
provide a measure of consistency checking for provenance and reasoning
over provenance.  They can also be used to <a title="normal
form" href="#dfn-normal-form" class="internalDFN">normalize</a> PROV instances to forms that can easily be
compared in order to determine whether two PROV instances are
<a title="equivalence">equivalent</a>.  Validity and equivalence are also defined for PROV
bundles (that is, named instances) and documents (that is, a toplevel
instance together with zero or more bundles).</p>
<p>The <a href="http://www.w3.org/TR/2013/NOTE-prov-overview-20130430/">PROV Document Overview</a> describes the overall state of PROV, and should be read before other PROV documents.</p>
</section><section id="sotd" class="introductory"><h2>Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication. Other
          documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision
          of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports
          index</a> at http://www.w3.org/TR/.</em>
        </p>
        
<h4 id="prov-family-of-documents">PROV Family of Documents</h4>
This document is part of the PROV family of documents, a set of documents defining various aspects that are necessary to achieve the vision of inter-operable
interchange of provenance information in heterogeneous environments such as the Web.  These documents are listed below. Please consult the [<cite><a class="bibref" href="#bib-PROV-OVERVIEW">PROV-OVERVIEW</a></cite>] for a guide to reading these documents. 
<ul>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-overview-20130430/">PROV-OVERVIEW</a> (Note), an overview of the PROV family of documents [<cite><a class="bibref" href="#bib-PROV-OVERVIEW">PROV-OVERVIEW</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-primer-20130430/">PROV-PRIMER</a> (Note), a primer for the PROV data model [<cite><a class="bibref" href="#bib-PROV-PRIMER">PROV-PRIMER</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/REC-prov-o-20130430/">PROV-O</a> (Recommendation), the PROV ontology, an OWL2 ontology allowing the mapping of the PROV data model to RDF [<cite><a class="bibref" href="#bib-PROV-O">PROV-O</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/">PROV-DM</a> (Recommendation), the PROV data model for provenance [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/REC-prov-n-20130430/">PROV-N</a> (Recommendation), a notation for provenance aimed at human consumption [<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/REC-prov-constraints-20130430/">PROV-CONSTRAINTS</a> (Recommendation), a set of constraints applying to the PROV data model (this document);</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-xml-20130430/">PROV-XML</a> (Note),  an XML schema for the PROV data model [<cite><a class="bibref" href="#bib-PROV-XML">PROV-XML</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-aq-20130430/">PROV-AQ</a> (Note), mechanisms for accessing and querying provenance [<cite><a class="bibref" href="#bib-PROV-AQ">PROV-AQ</a></cite>]; </li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-dictionary-20130430/">PROV-DICTIONARY</a> (Note) introduces a specific type of collection, consisting of key-entity pairs [<cite><a class="bibref" href="#bib-PROV-DICTIONARY">PROV-DICTIONARY</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-dc-20130430/">PROV-DC</a> (Note) provides a mapping between PROV-O and Dublin Core Terms [<cite><a class="bibref" href="#bib-PROV-DC">PROV-DC</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-sem-20130430/">PROV-SEM</a> (Note), a declarative specification in terms of first-order logic of the PROV data model [<cite><a class="bibref" href="#bib-PROV-SEM">PROV-SEM</a></cite>];</li>
<li> <a href="http://www.w3.org/TR/2013/NOTE-prov-links-20130430/">PROV-LINKS</a> (Note) introduces a mechanism to link across bundles [<cite><a class="bibref" href="#bib-PROV-LINKS">PROV-LINKS</a></cite>].</li>
</ul>

<h4 id="endorsed-by-w3c">Endorsed By <abbr title="World Wide Web Consortium">W3C</abbr></h4>

<p>This document has been reviewed by <abbr title="World Wide Web Consortium">W3C</abbr> Members, by software developers, and by other <abbr title="World Wide Web Consortium">W3C</abbr> groups and interested parties, and is endorsed by the Director as a <abbr title="World Wide Web Consortium">W3C</abbr> Recommendation. It is a stable document and may be used as reference material or cited from another document. <abbr title="World Wide Web Consortium">W3C</abbr>'s role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>

<h4 id="please-send-comments">Please Send Comments</h4>

        <p>
          This document was published by the <a href="http://www.w3.org/2011/prov/">Provenance Working Group</a> as a Recommendation.
          
          
          If you wish to make comments regarding this document, please send them to 
          <a href="mailto:public-prov-comments@w3.org">public-prov-comments@w3.org</a> 
          (<a href="mailto:public-prov-comments-request@w3.org?subject=subscribe">subscribe</a>,
          <a href="http://lists.w3.org/Archives/Public/public-prov-comments/">archives</a>).
          
          
          
          
        All comments are welcome.
        
        
        
        </p><p>
          
            This document was produced by a group operating under the 
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
          
          
          
            
              <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/46974/status" rel="disclosure">public list of any patent disclosures</a> 
            
            made in connection with the deliverables of the group; that page also includes instructions for 
            disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
            information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
          
          
        </p>
        
      
    
  
</section><section id="toc"><h2 class="introductory">Table of Contents</h2><ul class="toc"><li class="tocline"><a href="#introduction" class="tocxref"><span class="secno">1. </span>Introduction<br>
</a><ul class="toc"><li class="tocline"><a href="#conventions" class="tocxref"><span class="secno">1.1 </span>Conventions</a></li><li class="tocline"><a href="#purpose" class="tocxref"><span class="secno">1.2 </span>Purpose of this document</a></li><li class="tocline"><a href="#structure-of-this-document" class="tocxref"><span class="secno">1.3 </span>Structure of this document</a></li><li class="tocline"><a href="#audience" class="tocxref"><span class="secno">1.4 </span> Audience </a></li></ul></li><li class="tocline"><a href="#rationale" class="tocxref"><span class="secno">2. </span>Rationale (Informative)</a><ul class="toc"><li class="tocline"><a href="#entities-activities-and-agents" class="tocxref"><span class="secno">2.1 </span>Entities, Activities and Agents</a></li><li class="tocline"><a href="#events" class="tocxref"><span class="secno">2.2 </span>Events</a></li><li class="tocline"><a href="#typing-section" class="tocxref"><span class="secno">2.3 </span>Types</a></li><li class="tocline"><a href="#overview" class="tocxref"><span class="secno">2.4 </span>Validation Process Overview</a></li><li class="tocline"><a href="#summary-of-inferences-and-constraints" class="tocxref"><span class="secno">2.5 </span>Summary of inferences and constraints</a></li></ul></li><li class="tocline"><a href="#compliance" class="tocxref"><span class="secno">3. </span>Compliance with this document</a></li><li class="tocline"><a href="#concepts" class="tocxref"><span class="secno">4. </span>Basic concepts</a></li><li class="tocline"><a href="#inferences" class="tocxref"><span class="secno">5. </span>Definitions and Inferences</a><ul class="toc"><li class="tocline"><a href="#optional-identifiers-and-attributes" class="tocxref"><span class="secno">5.1 </span>Optional Identifiers and Attributes</a></li><li class="tocline"><a href="#entities-and-activities" class="tocxref"><span class="secno">5.2 </span>Entities and Activities</a></li><li class="tocline"><a href="#derivations" class="tocxref"><span class="secno">5.3 </span>Derivations</a></li><li class="tocline"><a href="#agents" class="tocxref"><span class="secno">5.4 </span>Agents</a></li><li class="tocline"><a href="#alternate-and-specialized-entities" class="tocxref"><span class="secno">5.5 </span>Alternate and Specialized Entities</a></li></ul></li><li class="tocline"><a href="#constraints" class="tocxref"><span class="secno">6. </span>Constraints</a><ul class="toc"><li class="tocline"><a href="#uniqueness-constraints" class="tocxref"><span class="secno">6.1 </span>Uniqueness Constraints</a></li><li class="tocline"><a href="#event-ordering-constraints" class="tocxref"><span class="secno">6.2 </span>Event Ordering Constraints</a><ul class="toc"><li class="tocline"><a href="#activity-constraints" class="tocxref"><span class="secno">6.2.1 </span>Activity constraints</a></li><li class="tocline"><a href="#entity-constraints" class="tocxref"><span class="secno">6.2.2 </span> Entity constraints</a></li><li class="tocline"><a href="#agent-constraints" class="tocxref"><span class="secno">6.2.3 </span> Agent constraints</a></li></ul></li><li class="tocline"><a href="#type-constraints" class="tocxref"><span class="secno">6.3 </span>Type Constraints</a></li><li class="tocline"><a href="#impossibility-constraints" class="tocxref"><span class="secno">6.4 </span>Impossibility constraints</a></li></ul></li><li class="tocline"><a href="#normalization-validity-equivalence" class="tocxref"><span class="secno">7. </span>Normalization, Validity, and Equivalence</a><ul class="toc"><li class="tocline"><a href="#instances" class="tocxref"><span class="secno">7.1 </span>Instances</a></li><li class="tocline"><a href="#bundle-constraints" class="tocxref"><span class="secno">7.2 </span>Bundles and Documents</a></li></ul></li><li class="tocline"><a href="#glossary" class="tocxref"><span class="secno">8. </span>Glossary</a></li><li class="tocline"><a href="#termination" class="tocxref"><span class="secno">A. </span>Termination of normalization</a></li><li class="tocline"><a href="#change-log" class="tocxref"><span class="secno">B. </span>Change Log</a><ul class="toc"><li class="tocline"><a href="#changes-since-proposed-recommendation" class="tocxref"><span class="secno">B.1 </span>Changes since Proposed Recommendation</a></li><li class="tocline"><a href="#changes-from-candidate-recommendation-to-proposed-recommendation" class="tocxref"><span class="secno">B.2 </span>Changes from Candidate Recommendation to Proposed Recommendation</a></li><li class="tocline"><a href="#changes-from-last-call-working-draft-to-candidate-recommendation" class="tocxref"><span class="secno">B.3 </span>Changes from Last Call Working Draft to Candidate Recommendation</a></li></ul></li><li class="tocline"><a href="#acknowledgements" class="tocxref"><span class="secno">C. </span>Acknowledgements</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">D. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">D.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">D.2 </span>Informative references</a></li></ul></li></ul></section>





    <section id="introduction"> 
      <!--OddPage--><h2><span class="secno">1. </span>Introduction<br>
</h2> 

<p>
Provenance is a record that describes the people, institutions, entities, and activities involved in producing, influencing, or delivering a piece of data or a thing.
This document complements
  the PROV-DM specification [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>] that defines a data model for
  provenance on the Web. This document defines a form of validation for provenance. </p>



    <section id="conventions"> 
<h3><span class="secno">1.1 </span>Conventions</h3>



<p>The key words "<em class="rfc2119" title="MUST">MUST</em>", "<em class="rfc2119" title="MUST NOT">MUST NOT</em>", "<em class="rfc2119" title="REQUIRED">REQUIRED</em>", "<em class="rfc2119" title="SHALL">SHALL</em>", "<em class="rfc2119" title="SHALL
      NOT">SHALL
      NOT</em>", "<em class="rfc2119" title="SHOULD">SHOULD</em>", "<em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em>", "<em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em>",  "<em class="rfc2119" title="MAY">MAY</em>", and
      "<em class="rfc2119" title="OPTIONAL">OPTIONAL</em>" in this document are to be interpreted as described in
      [<cite><a class="bibref" href="#bib-RFC2119">RFC2119</a></cite>].</p>

<p>In this document, logical formulas contain variables written as
    lower-case identifiers.  Some of these variables are written
    beginning with the underscore character <span class="name">_</span>, by convention, to indicate that they
    appear only once in the formula.  Such variables are
    provided merely as an aid to the reader.  </p>

</section>


<section id="purpose">

<h3><span class="secno">1.2 </span>Purpose of this document</h3>

<p>The PROV Data Model, PROV-DM, is a conceptual data model for provenance, which is
realizable using different representations such as PROV-N and PROV-O.
A <dfn id="dfn-prov-instance">PROV instance</dfn> is a set of PROV statements.
A <dfn id="dfn-prov-document">PROV document</dfn> consists of an anonymous instance, called the <dfn id="dfn-toplevel-instance">toplevel instance</dfn>, 
together with zero or more named instances, called <dfn title="bundle" id="dfn-bundle">bundles</dfn>.  For
example, a PROV document could be a .provn document, the result
of a query, a triple store containing PROV statements in RDF, etc.
The
PROV-DM specification [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>] imposes minimal requirements upon
PROV instances. A <a href="#dfn-valid" class="internalDFN">valid</a> PROV instance corresponds to a
consistent history of objects and interactions to which logical
reasoning can be safely applied. PROV instances need not
be <a href="#dfn-valid" class="internalDFN">valid</a>.
The term <a href="#dfn-valid" class="internalDFN">valid</a> is chosen by analogy with
notions of validity in other <abbr title="World Wide Web Consortium">W3C</abbr> specifications. This
terminology differs from the usual meaning of "validity" in logic;
our notion of validity of a PROV instance/document is closer to
logical "consistency".
</p>

<p> This document specifies <em>definitions</em> of some
provenance statements in terms of others, <em>inferences</em> over PROV instances
that applications <em class="rfc2119" title="MAY">MAY</em> employ, and also defines a class of
<a href="#dfn-valid" class="internalDFN">valid</a> PROV instances by specifying <em>constraints</em> that
<a href="#dfn-valid" class="internalDFN">valid</a> PROV instances must satisfy. There are four kinds of
constraints: <em>uniqueness constraints</em>, <em>event ordering
constraints</em>, <em>impossibility constraints</em>, and <em>type
constraints</em>.
Further discussion
of the semantics of PROV statements, which justifies the definitions, inferences
and constraints, and relates the procedural specification approach
taken here to a declarative specification, can be found in the formal semantics [<cite><a class="bibref" href="#bib-PROV-SEM">PROV-SEM</a></cite>].
</p>

<p>We define validity and equivalence in terms of a
concept called <a title="normal form" href="#dfn-normal-form" class="internalDFN">normalization</a>.  Definitions, inferences,
and uniqueness constraints can be applied to <a title="normal
form" href="#dfn-normal-form" class="internalDFN">normalize</a> PROV instances, and event ordering, typing, and
impossibility constraints can be checked on the normal form to determine
<a title="valid" href="#dfn-valid" class="internalDFN">validity</a>.  Equivalence of two PROV 
instances can be determined by comparing their normal forms.  For PROV
documents, validity and equivalence amount to checking the validity or
pairwise equivalence of their respective instances.
</p>
<p>
This specification defines
validity and equivalence procedurally, via an algorithm based on
<a title="normal form" href="#dfn-normal-form" class="internalDFN">normalization</a>.  Applications <em class="rfc2119" title="MAY">MAY</em> implement
validity and equivalence checking using normalization, as outlined
here.  Applications <em class="rfc2119" title="MAY">MAY</em> also implement validation and equivalence
checking in
any other way as long as the same instances or documents are considered valid or
equivalent, respectively.
</p>

<p> Checking validity or equivalence are <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em>, but not required, for
applications compliant with PROV.  
Applications producing provenance <em class="rfc2119" title="SHOULD">SHOULD</em> ensure that it is
<a href="#dfn-valid" class="internalDFN">valid</a>, and similarly applications consuming provenance <em class="rfc2119" title="MAY">MAY</em> reject provenance that is not <a href="#dfn-valid" class="internalDFN">valid</a>.  Applications
that are determining whether PROV instances or documents convey the same
information <em class="rfc2119" title="SHOULD">SHOULD</em> check equivalence as specified here.  As a
guideline, applications should 
treat equivalent instances or documents in the same way.  This is a
guideline only, because meaning of "in the same way" is
application-specific.  For example, applications that manipulate the syntax of
PROV instances in particular representations, such as pretty-printing
or digital signing, have good reasons to treat syntactically
different, but equivalent, documents differently.
</p>
</section>
<section id="structure-of-this-document">
<h3><span class="secno">1.3 </span>Structure of this document</h3>

<p><a href="#rationale">Section 2</a> gives a brief rationale
for the definitions, inferences and constraints.
</p>
<p>
<a href="#compliance">Section 3</a> summarizes the
requirements for compliance with this document, which are specified in
detail in the rest of the document.  </p>
<p>
<a href="#concepts">Section 4</a> defines basic concepts used in the
rest of the specification.  </p>

<p> <a href="#inferences">Section 5</a> presents definitions and inferences.  Definitions allow replacing shorthand notation in [<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>]
with more explicit and complete statements; inferences allow adding
new facts representing implicit knowledge about the structure of
provenance.  </p>

<p><a href="#constraints">Section 6</a> presents four kinds of constraints,
<em>uniqueness</em> constraints that prescribe that certain statements
must be unique within <a title="PROV instance" href="#instance" class="internalDFN">PROV instances</a>,
<em>event ordering</em> constraints that require that the records in a
<a href="#instance" class="internalDFN">PROV instance</a> are consistent with a sensible ordering of events
relating the activities, entities and agents involved, 
<em>impossibility</em> constraints that forbid certain patterns of
statements in valid PROV instances, and <em>type</em> constraints that
classify the types of identifiers in valid PROV instances.
</p>

<p><a href="#normalization-validity-equivalence">Section 7</a> defines the notions
of <a title="valid" href="#dfn-valid" class="internalDFN">validity</a>, <a title="equivalent" href="#dfn-equivalent" class="internalDFN">equivalence</a> and <a title="normal form" href="#dfn-normal-form" class="internalDFN">normalization</a>.
</p>



</section>
<section id="audience">
<h3><span class="secno">1.4 </span> Audience </h3>

<p> The audience for this document is the same as for [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>]: developers
and users who wish to create, process, share or integrate provenance
records on the (Semantic) Web.  Not all PROV-compliant applications
need to perform inferences or check validity when processing provenance.
However, applications that create or transform provenance <em class="rfc2119" title="SHOULD">SHOULD</em>
attempt to produce valid provenance, to make it more useful to other
applications by ruling out nonsensical or inconsistent information.
</p>

<p>This document assumes familiarity with [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>] and employs the
[<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>] notation.
</p>

</section>
</section>

<section id="rationale" class="informative">
<!--OddPage--><h2><span class="secno">2. </span>Rationale (Informative)</h2><p><em>This section is non-normative.</em></p>
<p> This section gives a high-level rationale that provides some
  further background for the constraints, but does not affect the
technical content of the rest of the specification.</p>

<section class="informative" id="entities-activities-and-agents">
<h3><span class="secno">2.1 </span>Entities, Activities and Agents</h3><p><em>This section is non-normative.</em></p>
<p>
One of the central challenges in representing provenance information
is how to deal with change.  Real-world objects, information objects
and Web resources change over time, and the characteristics that make
them identifiable in a given situation are sometimes subject to change
as well.  PROV allows for things to be described
in different ways, with different descriptions of their 
state.  
</p>

<p>
An entity is a thing one wants to provide provenance for
and whose situation in the world is described by some fixed
attributes. An entity has a <dfn id="dfn-lifetime">lifetime</dfn>,
defined as the period
between its <a title="entity generation event" href="#dfn-generation-event" class="internalDFN">generation event</a>
and its <a title="entity invalidation event" href="#dfn-invalidation-event" class="internalDFN">invalidation event</a>.
An entity's attributes are established when the entity is
created and (partially) describe the entity's situation and state
during the entirety of the entity's lifetime.</p>

<p>
A different entity (perhaps representing a different user or
system perspective) may fix other aspects of the same thing, and its provenance
may be different.  Different entities that fix aspects of the same
thing are called <em>alternates</em>, and the PROV relations of
<span class="name">specializationOf</span> and <span class="name">alternateOf</span> can be used to link such entities.</p>

<p>Besides entities, a variety of other PROV objects and relationships carry
attributes, including activity, generation, usage, invalidation, start, end,
communication, attribution, association, delegation, and
derivation. Each object has an associated duration interval (which may
be a single time point), and attribute-value pairs for a given object
are expected to be descriptions that hold for the object's duration.
</p>
<p>
However, the attributes of entities have special meaning because they
are considered to be fixed aspects
of underlying, changing things.  This motivates constraints on
<span class="name">alternateOf</span> and <span class="name">specializationOf</span> relating the attribute values of
different entities.
</p>

<p>
In order to describe the provenance of something during an interval
  over which relevant attributes of the thing are not fixed, a PROV
  instance would describe multiple entities, each with its own
  identifier, <a href="#dfn-lifetime" class="internalDFN">lifetime</a>, and fixed attributes, and express dependencies between
  the various entities using <i><a title="instantaneous event" href="#dfn-event" class="internalDFN">events</a></i>.  For example, in order to
  describe the provenance of several versions of a document, involving
  attributes such as authorship that change over time, one can use
  different entities for the versions linked by appropriate
  generation, usage, revision, and invalidation events. 
</p>

<p>There is no assumption that the set of attributes listed in an
<span class="name">entity</span> statement is complete, nor
that the attributes are independent or orthogonal of each
other. Similarly, there is no assumption that the attributes of an
entity uniquely identify it.  Two different entities that present the
same aspects of possibly different things can have the same
attributes; this leads to potential ambiguity, which is mitigated through the
use of identifiers.</p>

<p>An activity's lifetime is delimited by its <a title="activity start
event" href="#dfn-start-event" class="internalDFN">start</a> and its <a title="activity end event" href="#dfn-end-event" class="internalDFN">end</a>
events.  It occurs over
an interval delimited by two <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous
events</a>. However, an activity statement need not mention start or end time information, because they may not be known.
An activity's attribute-value pairs are expected to describe the activity's situation during its lifetime.
</p>



<p>An activity is not an entity.  Indeed, an entity exists in full at
any point in its lifetime, persists during this interval, and
preserves the characteristics provided.  In
contrast, an activity is something that occurs, happens, unfolds, or
develops through time.  This
distinction is similar to the distinction between 'continuant' and
'occurrent' in logic [<cite><a class="bibref" href="#bib-Logic">Logic</a></cite>].</p>


</section>
<section class="informative" id="events">
<h3><span class="secno">2.2 </span>Events</h3><p><em>This section is non-normative.</em></p>

<p> Although time is important for provenance, provenance can be used
in many different contexts within individual systems and across the
Web. Different systems may use different clocks which may not be
precisely synchronized, so when provenance statements are combined by
different systems, an application may not be able to align the times involved to a
single global timeline.  Hence, PROV is designed to minimize
assumptions about time.  Instead, PROV talks about (identified)
events. </p>

<p>The PROV data model is implicitly based on a notion of <dfn id="dfn-event">instantaneous event</dfn>s (or just <a title="instantaneous event" href="#dfn-event" class="internalDFN">event</a>s), that mark
transitions in the world.  Events include generation, usage, or
invalidation of entities, as well as start or end of activities.  This
notion of event is not first-class in the data model, but it is useful
for explaining its other concepts and its semantics [<cite><a class="bibref" href="#bib-PROV-SEM">PROV-SEM</a></cite>].
Thus, events help justify  <i>inferences</i> on provenance as well as
<i>validity</i> constraints indicating when provenance is
  self-consistent.



</p><p>Five kinds of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous
events</a> are used in PROV. The <strong>activity start</strong>
and <strong>activity end</strong> events delimit the beginning and the
end of activities, respectively. The 
<strong>entity generation</strong>, <strong>entity usage</strong>, and <strong>entity
invalidation</strong> events apply to entities, and the generation and
invalidation events delimit the <a href="#dfn-lifetime" class="internalDFN">lifetime</a> of an entity. More
precisely:
</p>

<p>An <dfn id="dfn-start-event">activity start event</dfn> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the instant an activity starts.</p>

<p>An <dfn id="dfn-end-event">activity end event</dfn> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the instant an activity ends.</p>

<p>An <dfn id="dfn-generation-event">entity generation event</dfn> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the  final instant of an entity's creation timespan, after which
it is available for use.  The entity did not exist before this event.</p>


<p>An <dfn id="dfn-usage-event">entity usage event</dfn> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the first instant of
an entity's consumption timespan by an activity.  The described usage
had not started before this instant, although the activity could
potentially have used the same entity at a different time.</p>


<p>An <dfn id="dfn-invalidation-event">entity invalidation event</dfn>
is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that
marks the  initial instant of the destruction, invalidation, or
cessation of an entity, after which the entity is  no longer available
for use.  The entity no longer exists after this event.</p>

</section>

<section id="typing-section" class="informative">
<h3><span class="secno">2.3 </span>Types</h3><p><em>This section is non-normative.</em></p>

<p> As set out in other specifications, the identifiers used in PROV
documents have associated type information.  An identifier can have
more than one type, reflecting subtyping or allowed overlap between
types, and so we define a set of types of each identifier, <span class="name">typeOf(id)</span>.  Some types are, however,
required not to overlap (for example, no identifier can describe both
an entity and an activity).
In addition, an identifier cannot be used to identify both an object
(that is, an entity, activity or agent) and a property (that is, a
named event such as usage, generation, or a relationship such as
attribution.)
This specification includes <a href="#type-constraints">disjointness and typing constraints</a> that
check these requirements.  Here, we 
summarize the type constraints in <a href="#typing-table">Table 1</a>.
</p>

<div id="typing-table-fig">
    <table id="typing-table" border="1" class="thinborder" style="margin-left: auto; margin-right: auto; border-color: black;">
<caption id="typing-table-caption">Table 1: Summary of Typing Constraints</caption>
      <tbody><tr>
	<th>In relation...</th>
	<th>identifier</th>
	<th>has type(s)...</th>
      </tr>

<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>

      <tr style="text-align: center; ">
	<td class="name">entity(e,attrs)</td>
	<td class="name" style="text-align: center; ">e</td>
	<td class="name">'entity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">activity(a,t1,t2,attrs)</td>
	<td class="name">a</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">agent(ag,attrs)</td>
	<td class="name">ag</td>
	<td class="name">'agent'</td>
      </tr>
      <tr style="text-align: center; ">
	<td rowspan="2" class="name">used(id; a,e,t,attrs)</td>
	<td class="name">e</td>
	<td class="name">'entity'</td>
     </tr>
     <tr style="text-align: center; ">
	<td class="name">a</td>
	<td class="name">'activity'</td>
      </tr>
     <tr style="text-align: center; ">
	<td rowspan="2" class="name">wasGeneratedBy(id; e,a,t,attrs)</td>
	<td class="name">e</td>
	<td class="name">'entity'</td>
      </tr>
     <tr style="text-align: center; ">
	<td class="name">a</td>
	<td class="name">'activity'</td>
    </tr>
      <tr style="text-align: center; ">
	<td rowspan="2" class="name">wasInformedBy(id; a2,a1,attrs)</td>
	<td class="name">a2</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">a1</td>
	<td class="name">'activity'</td>
      </tr>
    <tr style="text-align: center; ">
	<td rowspan="3" class="name">wasStartedBy(id; a2,e,a1,t,attrs)</td>
	<td class="name">a2</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">e</td>
	<td class="name">'entity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">a1</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td rowspan="3" class="name">wasEndedBy(id; a2,e,a1,t,attrs)</td>
	<td class="name">a2</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">e</td>
	<td class="name">'entity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">a1</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td rowspan="2" class="name">wasInvalidatedBy(id; e,a,t,attrs)</td>
	<td class="name">e</td>
	<td class="name">'entity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td class="name">a</td>
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td rowspan="3" class="name">wasDerivedFrom(id; e2,e1,a,g,u,attrs)</td>
	<td class="name">e2</td>
	<td class="name">'entity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">e1</td>
	<td class="name">'entity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">a</td>
	<td class="name">'activity'</td>
     </tr>
     <tr style="text-align: center; ">
	<td rowspan="2" class="name">wasAttributedTo(id; e,ag,attr)</td>
	<td class="name">e</td>
	<td class="name">'entity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">ag</td>
	<td class="name">'agent'</td>
     </tr>
     <tr style="text-align: center; ">
	<td rowspan="3" class="name">wasAssociatedWith(id; a,ag,pl,attrs)</td>
	<td class="name">a</td> 
	<td class="name">'activity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">ag</td> 
	<td class="name">'agent'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">pl</td> 
	<td class="name">'entity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td rowspan="3" class="name">actedOnBehalfOf(id; ag2,ag1,a,attrs)</td>
    	<td class="name">ag2</td> 
	<td class="name">'agent'</td>
     </tr>
     <tr style="text-align: center; ">
       <td class="name">ag1</td> 
       <td class="name">'agent'</td>
     </tr>
      <tr style="text-align: center; ">
	<td class="name">a</td> 
	<td class="name">'activity'</td>
      </tr>
      <tr style="text-align: center; ">
	<td rowspan="2" class="name">alternateOf(e1,e2)</td>
    	<td class="name">e1</td> 
	<td class="name">'entity'</td>
     </tr>
     <tr style="text-align: center; ">
       <td class="name">e2</td> 
       <td class="name">'entity'</td>
     </tr>
      <tr style="text-align: center; ">
	<td rowspan="2" class="name">specializationOf(e1,e2)</td>
    	<td class="name">e1</td> 
	<td class="name">'entity'</td>
     </tr>
     <tr style="text-align: center; ">
       <td class="name">e2</td> 
       <td class="name">'entity'</td>
     </tr>
<!--
      <tr style="text-align: center; ">
	<td  rowspan="3" class="name">mentionOf(e1,e2,b)</td>
    	<td class="name">e1</td> 
	<td class="name">'entity'</td>
     </tr>
    <tr style="text-align: center; ">
       <td class="name">e2</td> 
       <td class="name">'entity'</td>
     </tr>
    <tr style="text-align: center; ">
       <td class="name">b</td> 
       <td class="name">'entity'</td>
     </tr>
-->
           <tr style="text-align: center; ">
	<td rowspan="2" class="name">hadMember(c,e)</td>
    	<td class="name">c</td> 
	<td class="name">'entity'<br> 'prov:Collection'</td>
     </tr>
     <tr style="text-align: center; ">
       <td class="name">e</td> 
       <td class="name">'entity'</td>
     </tr>
     <tr style="text-align: center; ">
	<td class="name">entity(c,[prov:type='prov:EmptyCollection,...])</td>
    	<td class="name">c</td> 
	<td class="name">'entity'<br> 'prov:Collection' <br> 'prov:EmptyCollection'</td>
     </tr>
 </tbody></table>
    </div>

</section>
<section id="overview" class="informative">
<h3><span class="secno">2.4 </span>Validation Process Overview</h3><p><em>This section is non-normative.</em></p>


    <p>
  This section collects common concepts and operations that are used
  throughout the specification, and relates them to background
  terminology and ideas from logic [<cite><a class="bibref" href="#bib-Logic">Logic</a></cite>], constraint programming
  [<cite><a class="bibref" href="#bib-CHR">CHR</a></cite>], and database constraints [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>].  This section
  does not attempt to provide a complete introduction to these topics,
  but it is provided in order to aid readers familiar with one or more
  of these topics in understanding the specification, and to clarify
  some of the motivations for choices in the specification to all
  readers.
  </p>

    <p>As discussed below, the definitions, inferences and constraints
can be viewed as pure logical assertions that could be checked in a
variety of ways.  The rest of this document specifies validity and
equivalence procedurally, that is, in terms of a reference
implementation based on normalization.  Although both declarative and
procedural specification techniques have advantages, a purely
declarative specification offers much less guidance for
implementers, while the procedural approach adopted here immediately demonstrates
implementability and provides an adequate (polynomial-time) default implementation.  In
this section we relate the declarative meaning of formulas to their
procedural meaning.  [<cite><a class="bibref" href="#bib-PROV-SEM">PROV-SEM</a></cite>] provides an alternative,
declarative characterization of validity which could
be used as a starting point for other implementation strategies.  </p>


 
 <h3 id="constants-variables-and-placeholders">Constants, Variables and Placeholders</h3>
  <p>
  PROV statements involve identifiers, literals, 
 placeholders, and attribute lists.  Identifiers are, according to PROV-N, expressed as <a href="http://www.w3.org/TR/2013/REC-prov-n-20130430/#prod-QUALIFIED_NAME">qualified names</a> which can be mapped to URIs [<cite><a class="bibref" href="#bib-RFC3987">RFC3987</a></cite>].
 However, in order to specify
  constraints over PROV instances, we also need <em>variables</em>
  that represent unknown identifiers, literals, or placeholders.
  These variables are similar to those in first-order
  logic [<cite><a class="bibref" href="#bib-Logic">Logic</a></cite>].  A variable is a symbol that can be replaced by
  other symbols, including either other variables or constant
  identifiers, literals, or placeholders.  In a few special cases, we
  also use variables for unknown attribute lists. 
  To help distinguish identifiers and variables, we also term the former 'constant identifiers' to highlight their non-variable nature.
  </p>
  
  <p>Several definitions and inferences conclude by saying that some
  objects exist such that some other formulas hold.  Such an inference
  introduces fresh <a href="#dfn-existential-variable" class="internalDFN">existential variable</a>s into the instance.  An
  existential variable denotes a fixed object that exists, but its
  exact identity is unknown.  Existential variables can stand for
  unknown identifiers or literal values only; we do not allow
  existential variables that stand for unknown attribute lists.  </p>

  <p>In particular, many
  occurrences of the placeholder symbol <span class="name">-</span> stand for unknown
  objects; these are handled by expanding them to existential
  variables. Some placeholders, however, indicate the absence of an
  object, rather than an unknown object.  In other words, the
  placeholder is overloaded, with different meanings in different
  places.
  </p>
  <p>An expression is called a <em>term</em> if it is either a
  constant identifier, literal, placeholder, or variable.  We write
  <span class="math">t</span> to denote an arbitrary term.
</p>

  
 <h3 id="substitution-1">Substitution</h3>
<p>A <em>substitution</em> is a function that maps variables to terms. Concretely, since we only
  need to consider substitutions of finite sets of variables, we can
  write substitutions as <span class="math">[x<sub>1</sub> = t<sub>1</sub>,...,x<sub>n</sub>=t<sub>n</sub>]</span>.  A substitution
  <span class="math">S = [x<sub>1</sub> = t<sub>1</sub>,...,x<sub>n</sub>=t<sub>n</sub>]</span> 
  can be <em>applied</em> to a term by replacing occurrences of
<span class="math">x_i</span> with <span class="math">t_i</span>.
</p>
<!--
as follows.
<ol><li>
  If the term is a variable <span class="math">x<sub>i</sub></span>, one of the variables in the
  domain of <span class="math">S</span>, then <span class="math">S(x<sub>i</sub>) = t<sub>i</sub></span>.
  </li>
  <li>If the term is a constant identifier or literal <span
  class="math">c</span>, then <span class="math">S(c) = c</span>.
  </li>
  </ol>
-->
  <p>
  In addition, a substitution can be applied to an atomic formula
  (PROV statement) <span class="math">p(t<sub>1</sub>,...,t<sub>n</sub>)</span> by applying it to each term,
  that is, <span class="math">S(p(t<sub>1</sub>,...,t<sub>n</sub>)) = p(S(t<sub>1</sub>),...,S(t<sub>n</sub>))</span>.  Likewise, a
  substitution <span class="math">S</span> can be applied to an instance <span class="math">I</span> by applying
  it to each atomic formula (PROV statement) in <span class="math">I</span>, that is, <span class="math">S(I)
  = {S(A) | A ∈ I}</span>.
</p>


  
 

 <h3 id="formulas">Formulas</h3>
  <p>
  For the purpose of constraint checking, we view PROV statements
  (possibly involving existential variables) as
  <dfn id="formula">formulas</dfn>.  An instance is analogous to a "theory" in
  logic, that is, a set of formulas all thought to describe the same
  situation.  The set can also be thought of a single, large formula:
  the conjunction of all of the atomic formulas.
  </p>
<p>The atomic constraints considered in this specification can be
  viewed as atomic formulas:</p>
<ul>
  <li>Uniqueness constraints employ atomic equational formulas <span class="math">t =
  t'</span>.</li>
  <li>Ordering constraints employ atomic precedence relations that can
  be thought of as binary formulas <span class="math">precedes(t,t')</span> or <span class="math">strictlyPrecedes(t,t')</span>
  </li>
  <li>Typing constraints <span class="name">'type' ∈ typeOf(id)</span>
  can be represented as a atomic formulas <span class="name">typeOf(id,'type')</span>.
  </li>
  <li>Impossibility constraints employ the conclusion <span class="name">INVALID</span>,
  which is equivalent to the logical constant <span class="math">False</span>. </li>
  </ul>
  <p> Similarly, the definitions, inferences, and constraint rules in this
  specification can also be viewed as logical formulas, built up out
  of atomic formulas, logical connectives "and" (∧), "implies" (⇒),
  and quantifiers "for all" (∀) and "there exists" (∃).  For more
  background on logical formulas, see a logic textbook such as [<cite><a class="bibref" href="#bib-Logic">Logic</a></cite>].</p>
<ul>
  <li>
  A definition of the form "<span class="name">A</span> <span class="conditional">IF AND ONLY IF</span> there
  exists <span class="name">y<sub>1</sub></span>...<span class="name">y<sub>m</sub></span> such that <span class="name">B<sub>1</sub></span> and ... and <span class="name">B<sub>k</sub></span>"
  can be thought of as a formula <span class="math">∀ x<sub>1</sub>,....,x<sub>n</sub>. A ⇔ ∃ y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧ ... ∧ B<sub>k</sub></span>, where <span class="math">x<sub>1</sub></span>...<span class="math">x<sub>n</sub></span> are the
  free variables of the definition.  
</li>
<li>An inference of the form "<span class="conditional">IF</span> <span class="name">A<sub>1</sub></span> and ... and <span class="name">A<sub>p</sub></span>  <span class="conditional">THEN</span>  there
  exists <span class="name">y<sub>1</sub></span>...<span class="name">y<sub>m</sub></span> such that <span class="name">B<sub>1</sub></span> and ... and <span class="name">B<sub>k</sub></span>" can
  be thought of as a formula <span class="math">∀ x<sub>1</sub>,....,x<sub>n</sub>.  A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ ∃ y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧ ... ∧ B<sub>k</sub></span>, where <span class="math">x<sub>1</sub></span>...<span class="math">x<sub>n</sub></span> are the
  free variables of the inference.  
</li>
<li>A uniqueness, ordering, or typing constraint of the form "<span class="conditional">IF</span> <span class="name">A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> <span class="conditional">THEN</span> <span class="name">C</span>" can be viewed as a formula
  <span class="math">∀ x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ C</span>.  </li>
<li>A constraint of the form "<span class="conditional">IF</span> <span class="name">A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> <span class="conditional">THEN INVALID</span>" can be viewed as a formula
  <span class="math">∀ x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ False</span>.  </li>
  </ul>


 <h3 id="satisfying-definitions-inferences-and-constraints">Satisfying definitions, inferences, and constraints</h3>
  <p>
  In logic, a formula's meaning is defined by saying when it is
  <em>satisfied</em>.  We can view
  definitions, inferences, and constraints as being satisfied or not
  satisfied in a PROV instance, augmented with information about the constraints.
  </p>
  <ol>
    <li>A logical equivalence as used in a definition is satisfied
  when the formula <span class="math">∀
  x<sub>1</sub>,....,x<sub>n</sub>. A ⇔ ∃
  y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧ ... ∧
  B<sub>k</sub></span> holds, that is, for any substitution of the
  variables <span class="math">x<sub>1</sub>,....,x<sub>n</sub></span>, formula <span class="math">A</span> and
  formula <span class="math">∃
  y<sub>1</sub>...y<sub>m</sub>. B<sub>1</sub> ∧ ... ∧
  B<sub>k</sub></span> are either both true or both false.
    </li>
  <li>A logical implication as used in an inference is
   satisfied when the formula  <span class="math">∀
  x<sub>1</sub>,....,x<sub>n</sub>.  A<sub>1</sub> ∧ ... ∧
  A<sub>p</sub> ⇒ ∃ y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧
  ... ∧ B<sub>k</sub></span> holds, that is, for any substitution of
  the variables <span class="math">x<sub>1</sub>,....,x<sub>n</sub></span>, if  <span class="math">A<sub>1</sub> ∧ ... ∧
  A<sub>p</sub></span> is true, then 
 for some further substitution of terms for variables <span class="math">
  y<sub>1</sub>...y<sub>m</sub></span>, formula <span class="math">B<sub>1</sub> ∧ ... ∧
  B<sub>k</sub></span> is also true.</li>
  <li>A uniqueness, ordering, or typing constraint is satisfied when
  its associated formula <span class="math">∀ x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ C</span> holds, that is, for any substitution of
  the variables <span class="math">x<sub>1</sub>,....,x<sub>n</sub></span>, if  <span class="math">A<sub>1</sub> ∧ ... ∧
  A<sub>p</sub></span> is true, then <span class="math">C</span> is
  also true.</li>
  <li>An impossibility constraint is satisfied when the formula
  <span class="math">∀ x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒
  False</span> holds.  This is logically equivalent to <span class="math">∄
  x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span>, that is, there exists no
  substitution for <span class="math">x<sub>1</sub>...x<sub>n</sub></span> making <span class="math">A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> true.
</li></ol>  

<h3 id="unification-and-merging">Unification and Merging</h3>

  <p><em>Unification</em> is an operation that takes two terms and compares them to
  determine whether they can be made equal by substituting an
  existential variable with another term.  If so, the result is such a
  substitution; otherwise, the result is failure.  Unification is an
  essential concept in logic programming and automated reasoning,
where terms can involve variables, constants and function symbols.  In PROV,
  by comparison, unification only needs to deal with variables,
  constants and literals.
</p>
<p>
Unifying two terms <span class="math">t,t'</span> results in either substitution <span class="math">S</span>
  such that <span class="math">S(t) = S(t')</span>, or failure indicating that there is no
  substitution that can be applied to both <span class="math">t</span> and <span class="math">t'</span> to make
  them equal.  Unification is also used to define an operation on PROV
  statements called <em>merging</em>.  Merging takes two statements
  that have equal identifiers, unifies their corresponding term
  arguments, and combines their attribute lists.  
</p>

  

 <h3 id="applying-definitions-inferences-and-constraints">Applying definitions, inferences, and constraints</h3>
<p>Formulas can also be interpreted as having computational
  content.  That is, if an instance does not satisfy a formula, we can
  often <em>apply</em> the formula to the instance to produce another
  instance that does satisfy the formula.  Definitions, inferences,
  and uniqueness constraints can be applied to instances:
</p>
  <ul>
  <li>
  A definition of the form <span class="math">∀
  x<sub>1</sub>,....,x<sub>n</sub>. A ⇔ ∃
  y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧ ... ∧
  B<sub>k</sub></span>
  can be applied by searching for any occurrences of <span class="math">A</span> in the instance  and adding <span class="math"> B<sub>1</sub>, ..., B<sub>k</sub></span>, generating fresh existential
  variables <span class="math">y<sub>1</sub>,...,y<sub>m</sub></span>, and conversely, whenever there is an
    occurrence of <span class="math"> B<sub>1</sub>, ..., B<sub>k</sub></span>, adding
    <span class="math">A</span>.
    In our setting, the defined formulas <span class="math">A</span> are never used in other
    formulas, so it is sufficient to replace all occurrences of
    <span class="math">A</span> with their definitions.  The formula <span class="math">A</span> is then redundant, and can be
  removed from the instance.
</li>
<li>An inference of the form <span class="math">∀
  x<sub>1</sub>,....,x<sub>n</sub>.  A<sub>1</sub> ∧ ... ∧
  A<sub>p</sub> ⇒ ∃ y<sub>1</sub>...y<sub>m</sub> . B<sub>1</sub> ∧
  ... ∧ B<sub>k</sub></span> can be applied by searching for  any occurrences of <span class="math"> A<sub>1</sub> ∧ ... ∧
  A<sub>p</sub></span> in the instance and, for each such match
for which the entire conclusion does not already hold (for some <span class="math">y<sub>1</sub>,...,y<sub>m</sub></span>),
adding <span class="math">B<sub>1</sub> ∧
  ... ∧ B<sub>k</sub></span> to the instance, generating fresh existential
  variables <span class="math">y<sub>1</sub>,...,y<sub>m</sub></span>.
</li>
<li>A uniqueness  constraint of the form <span class="math">∀
x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ t
= t'</span> can be
  applied by searching for an occurrence <span class="math">A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> in the instance, and
  if one is found, unifying the terms <span class="math">t</span> and
<span class="math">t'</span>. If successful, the resulting
substitution is applied to the instance; otherwise, the application
of the uniqueness constraint fails.  </li>
<li>A key constraint can similarly be applied by searching for
different occurrences of a statement with the same identifier, unifying the
corresponding parameters of the statements, and concatenating their
attribute lists, to form a single statement.  The substitutions obtained by unification are applied to
the merged statement and the rest of the instance.
</li>
  </ul>
  
 <p>As noted above, uniqueness or key constraint
  application can <em>fail</em>, if a required unification or merging step fails.  Failure of constraint
  application means that there is no way to add information to the
  instance to satisfy the constraint, which in turn implies that the
  instance is <em>invalid</em>.
  </p>
  <p>
  The process of applying definitions, inferences, and constraints
  to a PROV instance until all of them are satisfied is similar to
  what is sometimes 
  called <em>chasing</em> [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>] or <em>saturation</em>
  [<cite><a class="bibref" href="#bib-CHR">CHR</a></cite>].  We call this process <em>normalization</em>.
  </p>
  <p>
  Although this specification outlines one particular way of
  performing inferences and checking constraints, based on
  normalization, implementations can use any other equivalent
  algorithm.  The logical formulas corresponding to the definitions,
  inferences, and constraints outlined above (and further elaborated
  in [<cite><a class="bibref" href="#bib-PROV-SEM">PROV-SEM</a></cite>]) provides an equivalent specification, and any
  implementation that correctly checks validity and equivalence (whether it performs normalization or not) complies
  with this specification.
  </p>

 
 <h3 id="termination-1">Termination</h3>
  <p>
 In general, applying sets of logical formulas of the above
  definition, inference, and constraint forms is not guaranteed to
  terminate.  A simple example is the inference <span class="math">R(x,y) ⇒ ∃z. R(x,z)
  ∧R(z,y)</span>, which can be applied to <span class="math">{R(a,b)}</span> to generate an
  infinite sequence of larger and larger instances.  To ensure that
  normalization, validity, and equivalence are decidable, we require
  that normalization terminates.  There is a great deal of work on termination of the chase in
  databases, or of sets of constraint handling rules.  The termination
  of the notion of normalization defined in this specification is
  guaranteed because the definitions, inferences and uniqueness/key
  constraints correspond to a <em>weakly acyclic</em> set of
  tuple-generating and equality-generating dependencies, in the
  terminology of [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>].  The termination of the remaining
  ordering, typing, and impossibility constraints is easy to show.  <a href="#termination">Appendix
  A</a> gives a proof that the definitions, inferences, and uniqueness
  and key constraints are weakly acyclic and therefore terminating.
  </p>
  <p>
  There is an important subtlety that is essential to guarantee
  termination.  This specification draws a distinction between knowing
  that an identifier has type <span class="name">'entity'</span>, <span class="name">'activity'</span>, or <span class="name">'agent'</span>, and having
  an explicit <span class="name">entity(id)</span>, <span class="name">activity(id)</span>, or <span class="name">agent(id)</span> statement in the instance.
  For example, focusing on entity statements, we can infer <span class="name">'entity' ∈ typeOf(id)</span> if  <span class="name">entity(id)</span> holds in the instance.  In contrast, if we only know
  that <span class="name">'entity' ∈ typeOf(id)</span>, this does not imply that <span class="name">entity(id)</span>
  holds.
  </p>
  <p>
  This distinction (for both entities and activities) is essential to
  ensure termination of the inferences, because we allow inferring
  that a declared <span class="name">entity(id,attrs)</span> has a generation
  and invalidation event, using
  <a class="rule-text" href="#entity-generation-invalidation-inference_text"><span>Inference 7 (entity-generation-invalidation-inference)</span></a>.
  Likewise, for activities, we allow inferring that a declared <span class="name">activity(id,t1,t2,attrs)</span> has a generation
  and invalidation event, using
  <a class="rule-text" href="#activity-start-end-inference_text"><span>Inference 8 (activity-start-end-inference)</span></a>.  These
  inferences do not apply to identifiers whose types are known, but for
  which there is not an explicit entity or activity statement.
If we strengthened the type
  inference constraints to add new entity or activity statements for
  the entities and activities involved in generating or starting other
  declared entities or activities, then we could keep generating new entities and
  activities in an unbounded chain into the past (as in the "chicken
  and egg" paradox).  The
  design adopted here requires that instances explicitly declare the
  entities and activities that are relevant for validity checking, and only
  these can be inferred to have invalidation/generation and start/end events.  This inference
  is not supported for identifiers
that are indirectly referenced in other relations and therefore have
  type <span class="name">'entity'</span> or <span class="name">'activity'</span>.  
  </p>


<div style="text-align: center;">
<span class="figure" id="fig-figure-1-overview-of-the-validation-process">
<img src="images/constraints/overview.svg" alt="validation process overview">
<br>
<span class="figcaption" id="validation-process-overview">Figure 1<sup><a class="internalDFN" href="#validation-process-overview"><span class="diamond"> ◊:</span></a></sup> Overview of the Validation Process</span>
</span> <!-- <b>new Figure 1:</b>  -->
</div>


 <h3 id="checking-ordering-typing-and-impossibility-constraints">Checking ordering, typing, and impossibility constraints</h3>
  <p>
  The ordering, typing, and impossibility constraints are checked
  rather than applied.  This means that they do not generate new
  formulas expressible in PROV, but they do generate basic constraints
  that might or might not be consistent with each other.  Checking
  such constraints follows a saturation strategy similar to that for normalization:
  </p>
  <ol>
  <li><p>
    For ordering constraints, we check by generating all of the
  precedes and strictly-precedes relationships specified by the rules.  These can be thought
  of as a directed graph whose nodes are terms, and whose edges are
  precedes or strictly-precedes relationships.  
    An ordering constraint  of the form <span class="math">∀
x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒
precedes(t,t')</span> can be applied by searching for occurrences of
<span class="math"> A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> and for each such match
adding the atomic formula <span class="math">precedes(t,t')</span> to
  the instance, and similarly for strictly-precedes constraints.  After all such constraints have been checked, and the
  resulting edges added to the graph, the ordering constraints are
  violated if there is a cycle in the graph that includes a
  strictly-precedes edge, and satisfied otherwise.
    </p>
</li>
<li><p>For typing constraints, we check by constructing a function
  <span class="math">typeOf(id)</span> mapping identifiers to sets of possible types.  We
  start with a function mapping each identifier to the empty set,
  reflecting no constraints on the identifiers' types.  A typing
  constraint of the form <span class="math">∀
x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒ 'type' ∈ typeOf(id)
</span> is checked  by adjusting the
  function by adding <span class="name">'type'</span> to <span class="math">typeOf(id)</span> for each conclusion
  <span class="name">'type' ∈ typeOf(id)</span> of the rule.  Typing constraints with
  multiple conclusions are handled analogously.  Once all constraints
  have been checked in all possible ways, we check that the
  disjointness constraints hold of the resulting <span class="math">typeOf</span> function.
  (These are essentially impossibility constraints).
</p>
  </li>
  <li><p>For impossibility constraints, we check by searching for the
  forbidden pattern that the impossibility constraint describes. Any
  match of this pattern leads to failure of the constraint checking process.
An impossibility constraint of the form <span class="math">∀
x<sub>1</sub>...x<sub>n</sub>. A<sub>1</sub> ∧ ... ∧ A<sub>p</sub> ⇒
False</span> can be applied by  searching for occurrences of
<span class="math">A<sub>1</sub> ∧ ... ∧ A<sub>p</sub></span> in the instance, and if any
such occurrence is found, signaling failure.</p>
  </li>
  </ol>
  <p>
  A normalized instance that passes all of the ordering, typing,
  and impossibility constraint checks 
  is called <a href="#dfn-valid" class="internalDFN">valid</a>.  Validity can be, but is not required to be,
  checked by normalizing and then checking constraints.  Any other
  algorithm that provides equivalent behavior (that is, accepts the
  same valid instances and rejects the same invalid instances) is allowed.
  In particular, the checked constraints and the
  applied definitions, inferences and uniqueness constraints do not
  interfere with one another, so it is also possible to mix checking
  and application.  This may be desirable in order to detect
  invalidity more quickly.
  </p>



 <h3 id="equivalence-and-isomorphism">Equivalence and Isomorphism</h3>
  <p> Given two normal forms, a natural question is whether they contain
  the same information, that is, whether they are equivalent (if so,
  then the original instances are also equivalent.)  By analogy with
  logic, if we consider normalized PROV instances with existential
  variables to represent sets of possible situations, then two normal
  forms may describe the same situation but differ in inessential
  details such as the order of statements or of elements of
  attribute-value lists.  To remedy this, we can easily consider
  instances to be equivalent up to reordering of attributes.  However,
  instances can also be equivalent if they differ only in choice of
  names of existential variables. Because of this, the appropriate
  notion of equivalence of normal forms is <em>isomorphism</em>.  Two
  instances <span class="math">I<sub>1</sub></span> and <span class="math">I<sub>2</sub></span> are <em>isomorphic</em> if there is an invertible
  substitution <span class="math">S</span> mapping existential variables to existential variables such that <span class="math">S(I<sub>1</sub>) = I<sub>2</sub></span>.
<!--
  This is similar to the notion of equivalence used in [[RDF]], where
  blank nodes play an analogous role to existential variables.
  -->
  </p>
 
<p>Equivalence can be checked by normalizing instances, checking that
  both instances are valid, then
  testing whether the two normal forms are isomorphic.  (It is
  technically possible for two invalid normal forms to be isomorphic,
  but to be considered equivalent, the two instances must also be
  valid.)
As with validity, the algorithm suggested by this specification is
  just one of many possible ways to implement equivalence checking; it
  is not required that implementations compute normal forms
  explicitly, only that their determinations of equivalence match
  those obtained by the algorithm in this specification.
  </p>

<p>Equivalence is only explicitly specified for
valid instances (whose normal forms exist and are unique up to
isomorphism).  Implementations may test equivalences involving valid
and invalid documents.  This specification does not constrain the
behavior of equivalence checking involving invalid instances, provided
that:
</p>
<ul>
  <li>instance equivalence is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>, <a href="#dfn-symmetric" class="internalDFN">symmetric</a> and
  <a href="#dfn-transitive" class="internalDFN">transitive</a> on all instances</li>
  <li> no valid instance is equivalent to an invalid instance.</li>
  </ul>
<p>
Because of the second constraint, equivalence is essentially the union
  of two equivalence relations on the disjoint sets of valid and
  invalid instances.
  There are two simple implementations of equivalence for invalid
  documents that are correct:</p>
  <ol>
    <li>each invalid instance is equivalent only to itself</li>
    <li>every pair of invalid instances are equivalent</li>
  </ol>
  
<h3 id="from-instances-to-bundles-and-documents">From Instances to Bundles and Documents</h3>

<p>PROV documents can contain multiple instances: a <a href="#dfn-toplevel-instance" class="internalDFN">toplevel
instance</a>, and
zero or more additional, named instances called <a title="bundle" href="#dfn-bundle" class="internalDFN">bundles</a>.  For the purpose
of inference and constraint checking, these instances are treated independently. That is,
a PROV document is valid provided that each instance in it is valid
and the names of its bundles are distinct.  In other words, there are
no validity constraints that need to be checked across the different
instances in a PROV document; the contents of one instance in a
multi-instance PROV document cannot affect the validity of another instance.
Similarly, a PROV document is
equivalent to another if their toplevel instances are equivalent, they
have the same number of bundles with the same names, and the instances
of their corresponding bundles are equivalent.
<!--Analogously to blank nodes in
[[RDF]],-->
The scope of an existential variable in PROV is delimited at the instance
level.  This means that occurrences of existential variables with the
  same name appearing in different statements within the same
  instance stand for a common, unknown term.  However, existential variables with the same name occurring in
different instances do not necessarily denote the same term.  This
is a consequence of the fact that the instances of two equivalent
documents only need to be  pairwise isomorphic; this is a weaker
property than requiring that there be a single isomorphism that works
for all of the corresponding instances.
</p>
</section>

<section class="informative" id="summary-of-inferences-and-constraints">
<h3><span class="secno">2.5 </span>Summary of inferences and constraints</h3><p><em>This section is non-normative.</em></p>

<p><a href="">Table 2</a> summarizes the inferences, and
constraints specified in this document, broken down by component and
type or relation involved.
</p>

<!--
<div class="note">Table: work in progress; these entries might change when the document is updated.</div>
-->

<div id="prov-constraints-fig" style="text-align: left;">
<table class="thinborder" style="margin-left: auto; margin-right: auto; border-color: black;">
<caption id="prov-constraints">Table 2: Summary of inferences and constraints for PROV Types and Relations</caption>
<tbody><tr><td><b>Type or Relation Name</b></td><td><b>
  Inferences and Constraints</b></td><td><b>Component</b></td></tr>
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>


<tr class="component1-color">
	<td class="essential">Entity</td>
	<td><a class="rule-text" href="#entity-generation-invalidation-inference_text"><span>Inference 7 (entity-generation-invalidation-inference)</span></a><br>
		<a class="rule-text" href="#specialization-attributes-inference_text"><span>Inference 21 (specialization-attributes-inference)</span></a><br>
		<a class="rule-text" href="#key-object_text"><span>Constraint 22 (key-object)</span></a><br>
		<a class="rule-text" href="#impossible-object-property-overlap_text"><span>Constraint 54 (impossible-object-property-overlap)</span></a><br>
		<a class="rule-text" href="#entity-activity-disjoint_text"><span>Constraint 55 (entity-activity-disjoint)</span></a><br>
	</td>
	<td rowspan="8" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component1" title="Component 1: Entities/Activities">1</a></td>
</tr>
<tr class="component1-color">
	<td class="essential">Activity</td>
	<td><a class="rule-text" href="#activity-start-end-inference_text"><span>Inference 8 (activity-start-end-inference)</span></a><br>
		<a class="rule-text" href="#key-object_text"><span>Constraint 22 (key-object)</span></a><br>
		<a class="rule-text" href="#unique-startTime_text"><span>Constraint 28 (unique-startTime)</span></a><br>
		<a class="rule-text" href="#unique-endTime_text"><span>Constraint 29 (unique-endTime)</span></a><br>
		<a class="rule-text" href="#impossible-object-property-overlap_text"><span>Constraint 54 (impossible-object-property-overlap)</span></a><br>
		<a class="rule-text" href="#entity-activity-disjoint_text"><span>Constraint 55 (entity-activity-disjoint)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">Generation</td>
	<td><a class="rule-text" href="#generation-use-communication-inference_text"><span>Inference 6 (generation-use-communication-inference)</span></a><br>
<!--		<a class="rule-text" href="#derivation-use-inference"><span>TBD</span></a><br>-->
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#unique-generation_text"><span>Constraint 24 (unique-generation)</span></a><br>
		<a class="rule-text" href="#generation-within-activity_text"><span>Constraint 34 (generation-within-activity)</span></a><br>
		<a class="rule-text" href="#generation-precedes-invalidation_text"><span>Constraint 36 (generation-precedes-invalidation)</span></a><br>
		<a class="rule-text" href="#generation-precedes-usage_text"><span>Constraint 37 (generation-precedes-usage)</span></a><br>
		<a class="rule-text" href="#generation-generation-ordering_text"><span>Constraint 39 (generation-generation-ordering)</span></a><br>
		<a class="rule-text" href="#derivation-usage-generation-ordering_text"><span>Constraint 41 (derivation-usage-generation-ordering)</span></a><br>
		<a class="rule-text" href="#derivation-generation-generation-ordering_text"><span>Constraint 42 (derivation-generation-generation-ordering)</span></a><br>
		<a class="rule-text" href="#wasStartedBy-ordering_text"><span>Constraint 43 (wasStartedBy-ordering)</span></a><br>
		<a class="rule-text" href="#wasEndedBy-ordering_text"><span>Constraint 44 (wasEndedBy-ordering)</span></a><br>
		<a class="rule-text" href="#specialization-generation-ordering_text"><span>Constraint 45 (specialization-generation-ordering)</span></a><br>
		<a class="rule-text" href="#wasAssociatedWith-ordering_text"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a><br>
		<a class="rule-text" href="#wasAttributedTo-ordering_text"><span>Constraint 48 (wasAttributedTo-ordering)</span></a><br>
		<a class="rule-text" href="#actedOnBehalfOf-ordering_text"><span>Constraint 49 (actedOnBehalfOf-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">Usage</td>
	<td><a class="rule-text" href="#generation-use-communication-inference_text"><span>Inference 6 (generation-use-communication-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#usage-within-activity_text"><span>Constraint 33 (usage-within-activity)</span></a><br>
		<a class="rule-text" href="#generation-precedes-usage_text"><span>Constraint 37 (generation-precedes-usage)</span></a><br>
		<a class="rule-text" href="#usage-precedes-invalidation_text"><span>Constraint 38 (usage-precedes-invalidation)</span></a><br>
		<a class="rule-text" href="#derivation-usage-generation-ordering_text"><span>Constraint 41 (derivation-usage-generation-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">Communication</td>
	<td><a class="rule-text" href="#communication-generation-use-inference_text"><span>Inference 5 (communication-generation-use-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#wasInformedBy-ordering_text"><span>Constraint 35 (wasInformedBy-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">Start</td>
	<td><a class="rule-text" href="#wasStartedBy-inference_text"><span>Inference 9 (wasStartedBy-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#unique-wasStartedBy_text"><span>Constraint 26 (unique-wasStartedBy)</span></a><br>
		<a class="rule-text" href="#unique-startTime_text"><span>Constraint 28 (unique-startTime)</span></a><br>
		<a class="rule-text" href="#start-precedes-end_text"><span>Constraint 30 (start-precedes-end)</span></a><br>
		<a class="rule-text" href="#usage-within-activity_text"><span>Constraint 33 (usage-within-activity)</span></a><br>
		<a class="rule-text" href="#generation-within-activity_text"><span>Constraint 34 (generation-within-activity)</span></a><br>
		<a class="rule-text" href="#wasInformedBy-ordering_text"><span>Constraint 35 (wasInformedBy-ordering)</span></a><br>
		<a class="rule-text" href="#start-start-ordering_text"><span>Constraint 31 (start-start-ordering)</span></a><br>
		<a class="rule-text" href="#wasStartedBy-ordering_text"><span>Constraint 43 (wasStartedBy-ordering)</span></a><br>
		<a class="rule-text" href="#wasAssociatedWith-ordering_text"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">End</td>
	<td><a class="rule-text" href="#wasEndedBy-inference_text"><span>Inference 10 (wasEndedBy-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#unique-wasEndedBy_text"><span>Constraint 27 (unique-wasEndedBy)</span></a><br>
		<a class="rule-text" href="#unique-endTime_text"><span>Constraint 29 (unique-endTime)</span></a><br>
		<a class="rule-text" href="#start-precedes-end_text"><span>Constraint 30 (start-precedes-end)</span></a><br>
		<a class="rule-text" href="#usage-within-activity_text"><span>Constraint 33 (usage-within-activity)</span></a><br>
		<a class="rule-text" href="#generation-within-activity_text"><span>Constraint 34 (generation-within-activity)</span></a><br>
		<a class="rule-text" href="#wasInformedBy-ordering_text"><span>Constraint 35 (wasInformedBy-ordering)</span></a><br>
		<a class="rule-text" href="#end-end-ordering_text"><span>Constraint 32 (end-end-ordering)</span></a><br>
		<a class="rule-text" href="#wasEndedBy-ordering_text"><span>Constraint 44 (wasEndedBy-ordering)</span></a><br>
		<a class="rule-text" href="#wasAssociatedWith-ordering_text"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component1-color">
	<td class="essential">Invalidation</td>
	<td><a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#unique-invalidation_text"><span>Constraint 25 (unique-invalidation)</span></a><br>
		<a class="rule-text" href="#generation-precedes-invalidation_text"><span>Constraint 36 (generation-precedes-invalidation)</span></a><br>
		<a class="rule-text" href="#usage-precedes-invalidation_text"><span>Constraint 38 (usage-precedes-invalidation)</span></a><br>
		<a class="rule-text" href="#invalidation-invalidation-ordering_text"><span>Constraint 40 (invalidation-invalidation-ordering)</span></a><br>
		<a class="rule-text" href="#wasStartedBy-ordering_text"><span>Constraint 43 (wasStartedBy-ordering)</span></a><br>
		<a class="rule-text" href="#wasEndedBy-ordering_text"><span>Constraint 44 (wasEndedBy-ordering)</span></a><br>
		<a class="rule-text" href="#specialization-invalidation-ordering_text"><span>Constraint 46 (specialization-invalidation-ordering)</span></a><br>
		<a class="rule-text" href="#wasAssociatedWith-ordering_text"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a><br>
		<a class="rule-text" href="#wasAttributedTo-ordering_text"><span>Constraint 48 (wasAttributedTo-ordering)</span></a><br>
		<a class="rule-text" href="#actedOnBehalfOf-ordering_text"><span>Constraint 49 (actedOnBehalfOf-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>


<tr class="component2-color">
	<td class="essential">Derivation</td>
	<td><a class="rule-text" href="#derivation-generation-use-inference_text"><span>Inference 11 (derivation-generation-use-inference)</span></a><br>
<!--		<a class="rule-text" href="#derivation-use-inference"><span>TBD</span></a><br>-->
<!--		<a class="rule-text" href="#specific-derivation-inference"><span>TBD</span></a><br>-->
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#derivation-usage-generation-ordering_text"><span>Constraint 41 (derivation-usage-generation-ordering)</span></a><br>
		<a class="rule-text" href="#derivation-generation-generation-ordering_text"><span>Constraint 42 (derivation-generation-generation-ordering)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
	<td rowspan="5" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component2" title="Component 2: Derivations">2</a></td>
</tr>
<tr class="component2-color">
	<td class="provType">Revision</td>
	<td><a class="rule-text" href="#revision-is-alternate-inference_text"><span>Inference 12 (revision-is-alternate-inference)</span></a><br></td>
</tr>
<tr class="component2-color">
	<td class="provType">Quotation</td>
	<td>No specific constraints</td>
</tr>
<tr class="component2-color">
	<td class="provType">Primary Source</td>
	<td>No specific constraints</td>
</tr>
<tr class="component2-color">
	<td class="essential">Influence</td>
	<td>No specific constraints</td>
</tr>
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>

<tr class="component3-color" style="border-collapse: collapse; ">
	<td class="essential">Agent</td>
	<td><a class="rule-text" href="#key-object_text"><span>Constraint 22 (key-object)</span></a><br>
		<a class="rule-text" href="#impossible-object-property-overlap_text"><span>Constraint 54 (impossible-object-property-overlap)</span></a><br>
	</td>
	<td rowspan="5" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component3" title="Component 3: Agents/Responsibility">3</a></td>
</tr>
<tr class="component3-color">
	<td class="essential">Attribution</td>
	<td><a class="rule-text" href="#attribution-inference_text"><span>Inference 13 (attribution-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#wasAttributedTo-ordering_text"><span>Constraint 48 (wasAttributedTo-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component3-color">
	<td class="essential">Association</td>
	<td><a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#wasAssociatedWith-ordering_text"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component3-color">
	<td class="essential">Delegation</td>
	<td><a class="rule-text" href="#delegation-inference_text"><span>Inference 14 (delegation-inference)</span></a><br>
		<a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
		<a class="rule-text" href="#actedOnBehalfOf-ordering_text"><span>Constraint 49 (actedOnBehalfOf-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-property-overlap_text"><span>Constraint 53 (impossible-property-overlap)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<tr class="component3-color">
	<td class="essential">Influence</td>
	<td><a class="rule-text" href="#influence-inference_text"><span>Inference 15 (influence-inference)</span></a><br>
		<a class="rule-text" href="#key-properties_text"><span>Constraint 23 (key-properties)</span></a><br>
	</td>
</tr>
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>

<tr class="component4-color">
	<td><a title="bundle" href="#dfn-bundle" class="internalDFN">Bundle constructor</a></td>
	<td>No specific constraints; see <a href="#bundle-constraints" class="sectionRef sec-ref">section 7.2 Bundles and Documents</a></td>
	<td rowspan="2" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component4" title="Component 4: Bundles">4</a></td>
</tr>
<tr class="component4-color">
	<td class="provType"><a title="bundle" href="#dfn-bundle" class="internalDFN">Bundle type</a></td>
	<td> No specific constraints; see <a href="#bundle-constraints" class="sectionRef sec-ref">section 7.2 Bundles and Documents</a>
        </td>
</tr>
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>

<tr class="component5-color">
	<td>Alternate</td>
	<td><a class="rule-text" href="#alternate-reflexive_text"><span>Inference 16 (alternate-reflexive)</span></a><br>
		<a class="rule-text" href="#alternate-transitive_text"><span>Inference 17 (alternate-transitive)</span></a><br>
		<a class="rule-text" href="#alternate-symmetric_text"><span>Inference 18 (alternate-symmetric)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
	<td rowspan="3" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component5" title="Component 5: Alternate Entities">5</a></td>
</tr>
<tr class="component5-color">
	<td>Specialization</td>
	<td><a class="rule-text" href="#specialization-transitive_text"><span>Inference 19 (specialization-transitive)</span></a><br>
		<a class="rule-text" href="#specialization-alternate-inference_text"><span>Inference 20 (specialization-alternate-inference)</span></a><br>
		<a class="rule-text" href="#specialization-attributes-inference_text"><span>Inference 21 (specialization-attributes-inference)</span></a><br>
		<a class="rule-text" href="#specialization-generation-ordering_text"><span>Constraint 45 (specialization-generation-ordering)</span></a><br>
		<a class="rule-text" href="#specialization-invalidation-ordering_text"><span>Constraint 46 (specialization-invalidation-ordering)</span></a><br>
		<a class="rule-text" href="#impossible-specialization-reflexive_text"><span>Constraint 52 (impossible-specialization-reflexive)</span></a><br>
		<a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
	</td>
</tr>
<!--
<tr class="component5-color">
	<td><a>Mention</a></td>
	<td><a class="rule-text" href="#mention-specialization-inference"><span>TBD</span></a><br>
		<a class="rule-text" href="#unique-mention"><span>TBD</span></a><br>
		<a class="rule-text" href="#typing"><span>TBD</span></a><br>
	</td>
</tr>
-->
<tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>

<tr class="component6-color">
	<td>Collection</td>
	<td> No specific constraints </td>
	<td rowspan="2" style="text-align: center; "><a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#component6" title="Component 6: Collections">6</a></td>
</tr>
<tr class="component6-color">
	<td>Membership</td>
	<td> <a class="rule-text" href="#membership-empty-collection_text"><span>Constraint 56 (membership-empty-collection)</span></a><br>
             <a class="rule-text" href="#typing_text"><span>Constraint 50 (typing)</span></a><br>
        </td>
</tr>
</tbody></table>
</div>

  
</section>

</section>

<section id="compliance">
<!--OddPage--><h2><span class="secno">3. </span>Compliance with this document</h2>

<p>
  For the purpose of compliance, the normative sections of this document
  are <a href="#compliance" class="sectionRef sec-ref">section 3. Compliance with this document</a>,
<a href="#concepts" class="sectionRef sec-ref">section 4. Basic concepts</a>,
<a href="#inferences" class="sectionRef sec-ref">section 5. Definitions and Inferences</a>,
<a href="#constraints" class="sectionRef sec-ref">section 6. Constraints</a>, and
<a href="#normalization-validity-equivalence" class="sectionRef sec-ref">section 7. Normalization, Validity, and Equivalence</a>.  


 To be compliant:
  </p><ol><li>When processing provenance, an
    application <em class="rfc2119" title="MAY">MAY</em> apply the inferences and definitions in <a href="#inferences" class="sectionRef sec-ref">section 5. Definitions and Inferences</a>.</li>
   <li>If determining whether a PROV instance or document is <a href="#dfn-valid" class="internalDFN">valid</a>, an
    application <em class="rfc2119" title="MUST">MUST</em> determine whether all of the
    constraints of <a href="#constraints" class="sectionRef sec-ref">section 6. Constraints</a> are
  satisfied on
  the <a href="#dfn-normal-form" class="internalDFN">normal form</a> of the instance or document.  </li>
   <li> If producing provenance meant for other applications to
    use, the application <em class="rfc2119" title="SHOULD">SHOULD</em> produce <a href="#dfn-valid" class="internalDFN">valid</a> provenance, as specified in <a href="#normalization-validity-equivalence" class="sectionRef sec-ref">section 7. Normalization, Validity, and Equivalence</a>. </li>
    <li>If determining whether two PROV instances or documents are
  <a href="#dfn-equivalent" class="internalDFN">equivalent</a>, an application <em class="rfc2119" title="MUST">MUST</em> determine whether their
  normal forms are equal, as specified in <a href="#normalization-validity-equivalence" class="sectionRef sec-ref">section 7. Normalization, Validity, and Equivalence</a>.
  </li></ol>

  <p>This specification defines validity and equivalence procedurally
  via reduction to normal forms.  If checking validity or equivalence, the
  results <em class="rfc2119" title="MUST">MUST</em> be the same as would be obtained by computing normal
  forms as defined in this specification.  Applications that explicitly compute
  normal forms, following the implementation strategy suggested by
  this specification, are by definition compliant.  However,
  applications can also comply by checking validity and equivalence in any
  other way that yields the same answers without explicitly applying
  definitions, inferences, and constraints or constructing normal forms.</p>

  <p>
  All figures are for illustration purposes
  only.  Information in tables is normative if it appears in a
  normative section; specifically, <a href="#expandable-parameters-fig">Table 3</a> is normative.  Text in appendices and
in boxes labeled "Remark" is informative.  Where there is any apparent
  ambiguity between the descriptive text and the formal text in a
  "definition", "inference" or "constraint" box, the formal text takes
priority.  
  </p>



</section>

 <section id="concepts">
  <!--OddPage--><h2><span class="secno">4. </span>Basic concepts</h2>

  <p>This section specifies the key concepts of terms, statements, instances, substitution,
  satisfaction, and unification, which have already been discussed in
  <a href="#rationale">Section 2</a>.  
  </p>

  <p>Many PROV relation statements have an identifier, identifying a
  link between two or more related objects.  Identifiers can sometimes
  be omitted in [<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>] notation.  For the purpose of inference and
  validity checking, we generate special identifiers called
  <dfn id="dfn-variables">variables</dfn> denoting the unknown values.
  Generally, identifiers occurring in constraints and inferences are
  variables.  Variables that are generated during inferences and
  appear inside an instance are often called <dfn title="existential variable" id="dfn-existential-variable">existential
  variables</dfn>, because they are implicitly existentially quantified.
</p>


  
  <p> A <dfn title="term" id="dfn-term">PROV term</dfn> is a constant identifier
  <span class="math">c</span>, a placeholder <span class="name">-</span>, a literal value, 
  or an existential variable <span class="math">x</span>.  An
  arbitrary PROV term is written  <span class="math">t</span>.</p>
  
  <p> A <dfn id="statement">PROV statement</dfn> is an expression of
  the form <span class="math">p(t<sub>1</sub>,...,t<sub>n</sub>)</span> or <span class="math">p(id;t<sub>1</sub>,...,t<sub>n</sub>)</span> where
  <span class="math">id,t<sub>1</sub>,...,t<sub>n</sub></span> are
  PROV <a href="#dfn-term" class="internalDFN">term</a>s and <span class="math">p</span> is one of the
  basic PROV relations. An arbitrary PROV statement is written  <span class="math">A</span>.</p>
  
<p>  A <dfn id="instance">PROV instance</dfn> is a set of PROV
  statements.  Two instances are considered to be the same if they
  contain the same statements, without regard to order or repetition.
  An arbitrary PROV instance is written <span class="math">I</span>.
</p>

  <p>A <dfn id="substitution">substitution</dfn> <span class="math">S</span> is a mapping <span class="math">
  [x<sub>1</sub>=t<sub>1</sub>,...,x<sub>n</sub>=t<sub>n</sub>]</span> associating existential variables
  with terms.  A substitution is <em>applied</em> to a term, statement
  or instance by replacing all occurrences of each of the variables
  <span class="math">x<sub>i</sub></span> with the corresponding <span class="math">t<sub>i</sub></span>.  Specifically, if <span class="math">S =
  [x<sub>1</sub>=t<sub>1</sub>,...,x<sub>n</sub>=t<sub>n</sub>]</span>
  then the application of <span class="math">S</span> to a term, statement or instance, written <span class="math">S(t)</span>, <span class="math">S(A)</span> and
  <span class="math">S(I)</span> respectively, is defined as follows:</p>
<ul><li><span class="math">S(c) = c</span> if <span class="math">c</span> is a constant identifier.</li>
<li><span class="math">S(x<sub>i</sub>) = t<sub>i</sub></span> if <span class="math">x<sub>i</sub></span> is one of the variables bound to a
  term <span class="math">t<sub>i</sub></span> in <span class="math">S</span>.</li>
<li><span class="math">S(x) = x</span> if <span class="math">x</span> is a variable not bound in <span class="math">S</span>.</li>
<li><span class="math">S(p(t<sub>1</sub>,...,t<sub>n</sub>)) = p(S(t<sub>1</sub>),...,S(t<sub>n</sub>))</span>.</li>
<li><span class="math">S(p(id;t<sub>1</sub>,...,t<sub>n</sub>)) = p(S(id);S(t<sub>1</sub>),...,S(t<sub>n</sub>))</span>.</li>
<li><span class="math">S(I) = { S(A) | A ∈ I } </span> if <span class="math">I</span> is an instance.</li>
</ul>

  <p>Suppose <span class="math">A</span> is a statement and <span class="math">I</span> is an
  instance and <span class="math">S</span> a substitution.  We say that <span class="math">A</span> is
  <dfn id="dfn-satisfied">satisfied</dfn> in <span class="math">I</span> by <span class="math">S</span> if <span class="math">S(A) ∈ I</span>.  Likewise,
  we say that a set of statements <span class="math">{A<sub>1</sub>,...,A<sub>n</sub>}</span> is satisfied in
  <span class="math">I</span> if each <span class="math">A<sub>i</sub></span> is satisfied in <span class="math">I</span> by <span class="math">S</span>. Finally, we
  say that a set of statements is <dfn id="dfn-satisfiable">satisfiable</dfn>
  in <span class="math">I</span> if there is some substitution <span class="math">S</span> that satisfies the
  statements in <span class="math">I</span>.
</p>
 
    <p> <dfn title="unification" id="dfn-unification">Unification</dfn> is an operation that can be applied
   to a pair of terms.
   The result of unification is either a <dfn id="dfn-unifier">unifier</dfn>, that is, a substitution <span class="math">S</span> such that <span class="math">S(t)
   = S(t')</span>, or failure, indicating
   that there is no <a href="#dfn-unifier" class="internalDFN">unifier</a>. Unification of pairs of terms is defined as follows.</p>

    <ul>
      <li> If <span class="math">t</span> and <span class="math">t'</span> are constant identifiers or literal values
      (including the placeholder <span class="name">-</span>), then
      there are two cases.  If <span class="math">t = t'</span> then their <a href="#dfn-unifier" class="internalDFN">unifier</a> is the
      empty substitution, otherwise unification
fails.  </li>
   <li> If <span class="math">x</span> is an existential variable
      and 
   <span class="math">t'</span> is any term (identifier, constant,
      placeholder <span class="name">-</span>, or
      existential variable), then their
   <a href="#dfn-unifier" class="internalDFN">unifier</a> is
      <span class="math">[x=t']</span>.  In the special case where
      <span class="math">t'=x</span>, the  <a href="#dfn-unifier" class="internalDFN">unifier</a> is the empty substitution.</li>
         <li> If <span class="math">t</span> is any term (identifier, constant,
      placeholder <span class="name">-</span>, or
      existential variable) and
   <span class="math">x'</span> is an existential variable, then their
      <a href="#dfn-unifier" class="internalDFN">unifier</a> is the same as the <a href="#dfn-unifier" class="internalDFN">unifier</a> of <span class="math">x</span>
      and <span class="math">t</span>.</li>
      </ul>
      


<div class="remark">Unification is analogous to unification in
  logic programming and theorem proving, restricted to flat terms with
constants and variables but   no function symbols.  No "occurs check" is needed because there are no
  function symbols.</div>

    <p>Two PROV instances <span class="math">I</span> and <span class="math">I'</span> are <dfn id="dfn-isomorphic">isomorphic</dfn> if
  there exists an invertible substitution <span class="math">S</span> that maps each
  variable of <span class="math">I</span> to a distinct variable of <span class="math">I'</span> and such that
  <span class="math">S(I) = I'</span>.</p>


<div class="remark">The scope of an existential variable is at the
    instance level.  When we obtain information about an existential
    variable, for example through unification or merging during
    uniqueness constraint application, we substitute all other
    occurrences of that variable occurring in the same instance.
    Occurrences in other instances are not affected.  </div>
  
</section>
<section id="inferences">
<!--OddPage--><h2><span class="secno">5. </span>Definitions and Inferences</h2>
<p>
This section  describes <a title="definition" href="#dfn-definition" class="internalDFN">definitions</a> and <a title="inference" href="#inference" class="internalDFN">inferences</a> that <em class="rfc2119" title="MAY">MAY</em> be used on
  provenance data, and that preserve <a title="equivalent" href="#dfn-equivalent" class="internalDFN">equivalence</a> on <a href="#dfn-valid" class="internalDFN">valid</a>
PROV instances (as detailed in <a href="#normalization-validity-equivalence" class="sectionRef sec-ref">section 7. Normalization, Validity, and Equivalence</a>).
A <dfn id="dfn-definition">definition</dfn> is a rule that can be applied to
  PROV instances to replace defined statements with other statements. An  <dfn id="inference">inference</dfn> is a rule that can be applied
  to PROV instances to add new PROV statements.  A definition states that a
  provenance statement is equivalent to some other statements, whereas
  an inference only states one direction of an implication.
</p>


<p> Definitions have the following general form:</p>

<div class="definition-example" id="definition-example"><div class="ruleTitle"><a class="internalDFN" href="#definition-example">Definition-example NNN (definition-example)</a></div>
<p>
  <span class="name">defined_stmt</span> <span class="conditional">IF AND ONLY IF</span>
  there exists <span class="name">a<sub>1</sub></span>,..., <span class="name">a<sub>m</sub></span> such that <span class="name">defining_stmt<sub>1</sub></span> and  ... and <span class="name">defining_stmt<sub>n</sub></span>.</p>
  </div>
 
  <p>
  A definition can be applied to a PROV instance, since its <span class="name">defined_stmt</span> is defined in
  terms of other statements.  Applying a
  definition to an instance means that if an occurrence of a defined
  provenance statement  <span class="name">defined_stmt</span>
  can be found in a PROV instance, then we can remove it and add all of the statements
<span class="name">defining_stmt<sub>1</sub></span> ... <span class="name">defining_stmt<sub>n</sub></span> to the instance, possibly after generating fresh
  identifiers <span class="name">a<sub>1</sub></span>,...,<span class="name">a<sub>m</sub></span> for existential variables.  In
  other words, it is safe to replace
  a defined statement with
  its definition.  
</p>

  <div class="remark">
    We use definitions primarily to expand the compact, concrete
    PROV-N syntax, including short forms and optional parameters, to the abstract syntax
    implicitly used in PROV-DM.
  </div>

  <p> Inferences have the following general form:</p>
<div class="inference-example" id="inference-example"><div class="ruleTitle"><a class="internalDFN" href="#inference-example">Inference-example NNN (inference-example)</a></div>
<p>
  <span class="conditional">IF</span> <span class="name">hyp<sub>1</sub></span> and ... and
<span class="name">hyp<sub>k</sub></span> <span class="conditional">THEN</span>
  there exists <span class="name">a<sub>1</sub></span> and ... and <span class="name">a<sub>m</sub></span> such that <span class="name">concl<sub>1</sub></span> and ... and <span class="name">concl<sub>n</sub></span>.</p>
  </div>
 
<p> Inferences can be applied to PROV instances.  Applying an inference to an instance means that if all of the provenance statements matching
  <span class="name">hyp<sub>1</sub></span>... <span class="name">hyp<sub>k</sub></span>
  can be found in the instance, then we check whether the conclusion 
  <span class="name">concl<sub>1</sub></span> ... <span class="name">concl<sub>n</sub></span> is <a href="#dfn-satisfied" class="internalDFN">satisfied</a> for some values
  of existential variables.  If so, application of the inference has
  no effect on the instance.  If not, then a copy the
  conclusion should be added to the instance, after
  generating fresh identifiers <span class="name">a<sub>1</sub></span>,...,<span class="name">a<sub>m</sub></span> for the existential variables.  These fresh
  identifiers might later be found to be equal to known identifiers;
  they play a similar role in PROV constraints to existential
  variables in logic [<cite><a class="bibref" href="#bib-Logic">Logic</a></cite>] or database theory
  [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>].
  <!--,  or to blank nodes in [[!RDF]].-->
  In general, omitted optional parameters to
  [<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>] statements, or explicit <span class="name">-</span>
  markers, are placeholders for existentially quantified variables;
  that is, they denote unknown values.  There are a few exceptions to
  this general rule, which are specified in <a class="rule-ref" href="#optional-placeholders"><span>Definition 4 (optional-placeholders)</span></a>.</p>

<p> Definitions and inferences can be viewed as logical formulas;
  similar formalisms are often used in rule-based reasoning [<cite><a class="bibref" href="#bib-CHR">CHR</a></cite>]
  and in databases [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>].  In particular, the identifiers
  <span class="name">a<sub>1</sub></span> ...  <span class="name">a<sub>n</sub></span>
  should be viewed as existentially quantified variables, meaning that
  through subsequent reasoning steps they may turn out to be equal to
  other identifiers that are already known, or to other existentially
  quantified variables.
  <!--
  Their treatment is analogous to that of blank
  nodes in RDF.-->
  In contrast, distinct URIs or literal values in PROV
  are assumed to be distinct for the purpose of checking validity or
  inferences.  This issue is discussed in more detail under <a href="#uniqueness-constraints">Uniqueness Constraints</a>.
  </p>
  
<p>In a definition or inference, term symbols such as <span class="name">id</span>, 
	<span class="name">start</span>, <span class="name">end</span>, <span class="name">e</span>, 
	<span class="name">a</span>, <span class="name">attrs</span>,
	are assumed to be variables unless otherwise specified.  These variables are scoped at 
	the definition, inference, or constraint level, so the rule is equivalent to any one-for-one 
	renaming of the variable names.  When several rules are
	collected within a definition or inference 
	as an ordered list, the scope of the variables in each rule is at the level of list elements, and so reuse of 
	variable names in different rules does not affect the meaning.
</p>
<section id="optional-identifiers-and-attributes">
  <h3><span class="secno">5.1 </span>Optional Identifiers and Attributes</h3>



<p>
<a class="rule-ref" href="#optional-identifiers"><span>Definition 1 (optional-identifiers)</span></a>,
<a class="rule-ref" href="#optional-attributes"><span>Definition 2 (optional-attributes)</span></a>, and
<a class="rule-ref" href="#definition-short-forms"><span>Definition 3 (definition-short-forms)</span></a>,
 explain how to expand the compact forms of PROV-N notation into a
  normal form.  <a class="rule-ref" href="#optional-placeholders"><span>Definition 4 (optional-placeholders)</span></a> indicates when
  other optional parameters can be replaced by <a title="existential variable" href="#dfn-existential-variable" class="internalDFN">existential
  variables</a>.  
</p>

  <div class="definition" id="optional-identifiers"><div class="ruleTitle"><a id="1"></a><a class="internalDFN" href="#optional-identifiers">Definition 1 (optional-identifiers)</a></div>
<p>For each  <span class="name">r</span> in { 
<span class="name">used</span>,
<span class="name">wasGeneratedBy</span>,
<span class="name">wasInvalidatedBy</span>,
<span class="name">wasInfluencedBy</span>,
<span class="name">wasStartedBy</span>,
<span class="name">wasEndedBy</span>,
<span class="name">wasInformedBy</span>,
<span class="name">wasDerivedFrom</span>,
<span class="name">wasAttributedTo</span>,
<span class="name">wasAssociatedWith</span>,
<span class="name">actedOnBehalfOf</span>}, the following
    definitional rules hold:</p>
    <ol>     <li>
    <span class="name">r(a<sub>1</sub>,...,a<sub>n</sub>) </span> <span class="conditional">IF AND ONLY IF</span>
  there exists <span class="name">id</span> such that  <span class="name">r(id; a<sub>1</sub>,...,a<sub>n</sub>)</span>.</li>
     <li> <span class="name">r(-; a<sub>1</sub>,...,a<sub>n</sub>) </span> <span class="conditional">IF AND ONLY IF</span>
  there exists <span class="name">id</span> such that  <span class="name">r(id; a<sub>1</sub>,...,a<sub>n</sub>)</span>.</li>
     </ol>
    </div>

    <p>Likewise, many PROV-N statements allow for an optional attribute
   list.  If it is omitted, this is the same as specifying an empty
   attribute list:</p>
   <div class="definition" id="optional-attributes"><div class="ruleTitle"><a id="2"></a><a class="internalDFN" href="#optional-attributes">Definition 2 (optional-attributes)</a></div>
<ol>
  <li>
<!--  For each  <span class="name">p</span> in {<span
   class="name">entity</span>, <span class="name">activity</span>,
   <span class="name">agent</span>}, if <span class="name">a<sub>n</sub></span> is not an attribute
   list parameter then the following definitional rule holds:
  <p><span class="name">p(a<sub>1</sub>,...,a<sub>n</sub>)</span> 
   <span  class="conditional">IF AND ONLY IF</span>   <span
   class="name">p(a<sub>1</sub>,...,a<sub>n</sub>,[])</span>.
  -->
<p>  The following definitional rules hold:</p>
    <ul><li><span class="name">entity(id)</span> 
   <span class="conditional">IF AND ONLY IF</span>   <span class="name">entity(id,[])</span>.
    </li>
    <li><span class="name">activity(id)</span> 
   <span class="conditional">IF AND ONLY IF</span>   <span class="name">activity(id,[])</span>.
    </li>
   <li><span class="name">activity(id,t1,t2)</span> 
   <span class="conditional">IF AND ONLY IF</span>   <span class="name">activity(id,t1,t2,[])</span>.
    </li>
    <li><span class="name">agent(id)</span> 
   <span class="conditional">IF AND ONLY IF</span>   <span class="name">agent(id,[])</span>.
    </li>
    </ul>
    <br>
  </li>
  <li>
     For each <span class="name">r</span> in { 
<span class="name">used</span>,
<span class="name">wasGeneratedBy</span>,
<span class="name">wasInvalidated</span>,
<span class="name">wasInfluencedBy</span>,
<span class="name">wasStartedBy</span>,
<span class="name">wasEndedBy</span>,
<span class="name">wasInformedBy</span>,
<span class="name">wasDerivedFrom</span>,
<span class="name">wasAttributedTo</span>,
<span class="name">wasAssociatedWith</span>,
<span class="name">actedOnBehalfOf</span>}, if <span class="name">a<sub>n</sub></span> is not an
   attribute list parameter then the following definition holds:
   
  <p> <span class="name">r(id; a<sub>1</sub>,...,a<sub>n</sub>)</span> 
   <span class="conditional">IF AND ONLY IF</span>   <span class="name">r(id; a<sub>1</sub>,...,a<sub>n</sub>,[])</span>.</p></li></ol>
    </div>   


 <div class="remark">
  <p>Definitions  <a class="rule-ref" href="#optional-identifiers"><span>Definition 1 (optional-identifiers)</span></a> and <a class="rule-ref" href="#optional-attributes"><span>Definition 2 (optional-attributes)</span></a>
do not apply to <span class="name">alternateOf</span> and <span class="name">specializationOf</span>, which do not have identifiers and attributes.
</p>
 </div>


    <p>  Finally, many PROV
  statements have other optional arguments or short forms that can be
  used if none of the optional arguments is present.  These are
  handled by specific rules listed below.  </p>

<div class="definition" id="definition-short-forms"><div class="ruleTitle"><a id="3"></a><a class="internalDFN" href="#definition-short-forms">Definition 3 (definition-short-forms)</a></div>
 <p>
  
  </p><ol>
    <li> <span class="name">activity(id,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">activity(id,-,-,attrs)</span>.
    </li>
    <li><span class="name">wasGeneratedBy(id; e,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasGeneratedBy(id; e,-,-,attrs)</span>.
    </li>
    <li><span class="name">used(id; a,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">used(id; a,-,-,attrs)</span>.
   </li>
   <li><span class="name">wasStartedBy(id; a,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasStartedBy(id; a,-,-,-,attrs)</span>.
   </li>
    <li><span class="name">wasEndedBy(id; a,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasEndedBy(id; a,-,-,-,attrs)</span>.
   </li>
    <li><span class="name">wasInvalidatedBy(id; e,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasInvalidatedBy(id; e,-,-,attrs)</span>.
   </li>
    <li><span class="name">wasDerivedFrom(id; e2,e1,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasDerivedFrom(id; e2,e1,-,-,-,attrs)</span>.
   </li>
    <li><span class="name">wasAssociatedWith(id; e,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">wasAssociatedWith(id; e,-,-,attrs)</span>.
   </li>
    <li><span class="name">actedOnBehalfOf(id; a2,a1,attrs)</span> <span class="conditional">IF AND ONLY IF</span> <span class="name">actedOnBehalfOf(id; a2,a1,-,attrs)</span>.
   </li>
  </ol>
 </div>

 <div class="remark">
<!--<p>
   Note that there is no expansion rule for <span class="name">wasDerivedFrom</span>.    In a derivation of the form
  <span class="name">wasDerivedFrom(id; e1,e2,attr)</span>, the
  absence of the optional activity, generation and use identifiers
  means that the derivation relationship may encompass multiple activities,
generations, and uses.  Thus, it is not equivalent to <span
  class="name">wasDerivedFrom(id; e1,e2,a,g,u,attr)</span> where some
  activity, generation and use are given explicitly.
 The short
   form is not defined in terms of the long form in this case.</p>-->

  <p>
There are no expansion rules for entity, agent, communication,
 attribution, influence, alternate, or specialization 
   relations, because these
 have no optional parameters aside from the identifier and attributes,
 which are expanded by the rules in <a class="rule-ref" href="#optional-identifiers"><span>Definition 1 (optional-identifiers)</span></a> and <a class="rule-ref" href="#optional-attributes"><span>Definition 2 (optional-attributes)</span></a>.  </p>
   </div>

<!--<div id="optional-attributes1"> -->
<p id="optional-placeholders_text">Finally,  most optional parameters (written <span class="name">-</span>) are, for the purpose of this document,
  considered to be distinct, fresh existential variables.  Optional parameters are defined in  [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>] and in [<cite><a class="bibref" href="#bib-PROV-N">PROV-N</a></cite>] for each type of PROV statement.
  Thus,
  before proceeding to apply other definitions or inferences, most
  occurrences of <span class="name">-</span> are to be replaced
 by fresh existential variables, distinct from any others occurring in
  the instance.
  The only exceptions to this general rule, where  <span class="name">-</span> are to be left
  in place, are the <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#derivation.activity">activity</a>, <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#derivation.generation">generation</a>, and <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#derivation.usage">usage</a> parameters in <span class="name">wasDerivedFrom</span> and
  the <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#association.plan">plan</a>
  parameter in <span class="name">wasAssociatedWith</span>.  This is
  further explained in remarks below.
  </p>

   <p>The treatment of optional parameters is specified formally using
   the auxiliary concept of <dfn id="dfn-expandable-parameter">expandable parameter</dfn>.  An
   expandable parameter is one that can be omitted using the
   placeholder <span class="name">-</span>, and if so, it is
   to be replaced by a fresh existential identifier.
  <a href="#expandable-parameters-fig">Table 3</a> defines the <a href="#dfn-expandable-parameter" class="internalDFN">expandable
    parameter</a>s of the properties of PROV, needed in <a class="rule-ref" href="#optional-placeholders"><span>Definition 4 (optional-placeholders)</span></a>.  For emphasis, the four optional parameters
    that are not <a title="expandable parameter" href="#dfn-expandable-parameter" class="internalDFN">expandable</a> are
    also listed.  Parameters that cannot have value <span class="name">-</span>, and identifiers that are 
   expanded by <a class="rule-ref" href="#optional-identifiers"><span>Definition 1 (optional-identifiers)</span></a>, are not listed.</p>
  <div id="expandable-parameters-fig">
    <table id="expandable-parameters_table" border="1" class="thinborder" style="margin-left: auto; margin-right: auto; border-color: black;">
<caption id="expandable-parameters">Table 3: Expandable and
    Non-Expandable Parameters</caption>
<tbody><tr><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td><td style="border-width: 0px; "></td></tr>
      <tr>
	<th>Relation</th>
	<th>Expandable </th>
	<th>Non-expandable</th>
      </tr>
     <tr>
	<td class="name">used(id; a,e,t,attrs)</td>
	<td class="name">e,t</td>
	<td></td>
      </tr>
      <tr>
	<td class="name">wasGeneratedBy(id; e,a,t,attrs)</td>
	<td class="name">a,t</td>
	<td></td>
    </tr>
<!--      <tr>
	<td class="name">wasInformedBy(id; a2,a1,attrs)</td>
	<td class="name"></td>
	<td></td>
      </tr>
      -->
      <tr>
	<td class="name">wasStartedBy(id; a2,e,a1,t,attrs)</td>
	<td class="name">e,a1,t</td>
	<td></td>
      </tr>
      <tr>
	<td class="name">wasEndedBy(id; a2,e,a1,t,attrs)</td>
	<td class="name">e,a1,t</td>
	<td></td>
      </tr>
      <tr>
	<td class="name">wasInvalidatedBy(id; e,a,t,attrs)</td>
	<td class="name">a,t</td>
	<td></td>
      </tr>
      <tr>
	<td class="name">wasDerivedFrom(id; e2,e1,-,g,u,attrs)</td>
	<td class="name"></td>
	<td class="name">g,u</td>
      </tr>      <tr>
	<td class="name">wasDerivedFrom(id; e2,e1,a,g,u,attrs)<br>(where <span class="name">a</span> is not placeholder <span class="name">-</span>)</td>
	<td class="name">g,u</td>
	<td class="name">a</td>
      </tr>
      
<!--
      <tr>
	<td class="name">wasDerivedFrom(id; e2,e1,attrs)</td>
	<td class="name"></td> 
	<td></td>
     </tr>
     -->
<!--      <tr>
	<td class="name">wasAttributedTo(id; e,ag,attr)</td>
	<td class="name"></td> 
	<td></td>
     </tr>
     -->
      <tr>
	<td class="name">wasAssociatedWith(id; a,ag,pl,attrs)</td>
	<td class="name">ag</td> 
	<td class="name">pl</td>
     </tr>
      <tr>
	<td class="name">actedOnBehalfOf(id; ag2,ag1,a,attrs)</td>
	<td class="name">a</td> 
	<td></td>
     </tr>
<!--      <tr>
	<td class="name">wasInfluencedBy(id; o2,o1,attrs)</td>
	<td class="name"></td> 
	<td></td>
     </tr>
   -->
   </tbody></table>
    </div>

<p> <a class="rule-ref" href="#optional-placeholders"><span>Definition 4 (optional-placeholders)</span></a> states how parameters are to be expanded,
    using the expandable parameters defined in   <a href="#expandable-parameters-fig">Table 3</a>.  The last two parts, 4 and 5,
  indicate how to handle expansion of parameters for
  <span class="name">wasDerivedFrom</span> expansion, which is only allowed for the
  generation and use parameters when the activity is specified.
  Essentially, the definitions state that parameters  
<span class="name">g,u</span> are expandable only if the activity is specified, i.e., if parameter <span class="name">a</span> is provided.

The rationale for this is that when <span class="name">a</span> is provided, then there have to be two events, namely <span class="name">u</span> and <span class="name">g</span>, which account for the usage of <span class="name">e1</span> and the generation of <span class="name">e2</span>, respectively, by <span class="name">a</span>. Conversely, if <span class="name">a</span> is not provided, then one cannot tell whether one or more activities are involved in the derivation, and the explicit introduction of such events, which correspond to a single activity, would therefore not be justified.  </p>


<p>  A  later constraint, <a class="rule-ref" href="#impossible-unspecified-derivation-generation-use"><span>Constraint 51 (impossible-unspecified-derivation-generation-use)</span></a>,
  forbids specifying generation and use parameters when the activity
  is unspecified.</p>
    
  <div class="definition" id="optional-placeholders"><div class="ruleTitle"><a id="4"></a><a class="internalDFN" href="#optional-placeholders">Definition 4 (optional-placeholders)</a></div>
    <ol><li>
      <span class="name">activity(id,-,t2,attrs)</span> <span class="conditional">IF AND ONLY
   IF</span> there exists <span class="name">t1</span> such that <span class="name">activity(id,t1,t2,attrs)</span>. Here, <span class="name">t2</span> <em class="rfc2119" title="MAY">MAY</em> be a placeholder.
  </li>
<li>  <span class="name">activity(id,t1,-,attrs)</span> <span class="conditional">IF AND ONLY
   IF</span> there exists <span class="name">t2</span> such that <span class="name">activity(id,t1,t2,attrs)</span>. Here, <span class="name">t1</span> <em class="rfc2119" title="MAY">MAY</em> be a placeholder.
</li>
<!--
<li>For each <span class="name">r</span> in {<span
    class="name">entity</span>, <span class="name">activity</span>,
    <span class="name">agent</span>}, the following definition
    holds:
      <p>
      <span class="name">r(a<sub>0</sub>,...,a<sub>i-1</sub>, -, a<sub>i+1</sub>, ...,a<sub>n</sub>) </span> <span class="conditional">IF AND ONLY IF</span> there exists <span class="name">a'</span>
    such that <span class="name">r(a<sub>0</sub>,...,a<sub>i-1</sub>,a',a<sub>i+1</sub>,...,a<sub>n</sub>)</span>.
    </li>
    -->
    <li>For each  <span class="name">r</span> in { 
<span class="name">used</span>,
<span class="name">wasGeneratedBy</span>,
<!--<span class="name">wasInformedBy</span>,-->
<span class="name">wasStartedBy</span>,
<span class="name">wasEndedBy</span>,
<span class="name">wasInvalidatedBy</span>,
<!--<span class="name">wasDerivedFrom</span>,-->
<!--<span class="name">wasAttributedTo</span>,-->
<span class="name">wasAssociatedWith</span>,
<span class="name">actedOnBehalfOf</span>
   <!--<span class="name">wasInfluencedBy</span>
    -->
    }, if the <span class="name">i</span>th parameter
    of <span class="name">r</span> is an <a href="#dfn-expandable-parameter" class="internalDFN">expandable parameter</a>
    of <span class="name">r</span>
    as specified in <a href="#expandable-parameters-fig">Table 3</a>
then the following definition holds:
    <p> <span class="name">r(a<sub>0</sub>;...,a<sub>i-1</sub>, -, a<sub>i+1</sub>, ...,a<sub>n</sub>) </span> <span class="conditional">IF AND ONLY IF</span> there exists <span class="name">a'</span>
    such that <span class="name">r(a<sub>0</sub>;...,a<sub>i-1</sub>,a',a<sub>i+1</sub>,...,a<sub>n</sub>)</span>.
    </p></li>
  <li>If <span class="name">a</span> is not the placeholder <span class="name">-</span>, and <span class="name">u</span> is any term, then the following definition holds:
   <p> <span class="name">wasDerivedFrom(id; e2,e1,a,-,u,attrs)</span> <span class="conditional">IF AND ONLY IF</span> there exists <span class="name">g</span>
    such that <span class="name">wasDerivedFrom(id; e2,e1,a,g,u,attrs)</span>.</p></li>
  <li>If <span class="name">a</span> is not the placeholder <span class="name">-</span>, and <span class="name">g</span> is any term,
    then the following definition holds:
   <p> <span class="name">wasDerivedFrom(id; e2,e1,a,g,-,attrs)</span> <span class="conditional">IF AND ONLY IF</span> there exists <span class="name">u</span>
    such that <span class="name">wasDerivedFrom(id; e2,e1,a,g,u,attrs)</span>.</p></li></ol>
    </div>

  <div class="remark">
<p>In an association of the form
  <span class="name">wasAssociatedWith(id; a,ag,-,attr)</span>, the
  absence of a plan means: either no plan exists, or a plan exists but
  it is not identified.  Thus, it is not equivalent to <span class="name">wasAssociatedWith(id; a,ag,p,attr)</span> where a
  plan <span class="name">p</span> is given.</p>
</div>
  <div class="remark">
<p> A derivation  <span class="name">wasDerivedFrom(id; e2,e1,a,gen,use,attrs)</span> that
  specifies an activity explicitly indicates that  this activity achieved the derivation, with a usage <span class="name">use</span> of entity <span class="name">e1</span>, and a generation <span class="name">gen</span> of entity <span class="name">e2</span>.
  It differs from a derivation of the form
   <span class="name">wasDerivedFrom(id; e2,e1,-,-,-,attrs)</span> with 
  missing activity, generation, and usage. In the latter form, it is not specified
  if one or more activities are involved in the derivation. </p>

 <p>Let us consider a system, in which a derivation is underpinned by multiple activities. Conceptually, one could also model such a system with a new activity that encompasses the two original activities and underpins the derivation.   The inferences defined in this specification do not allow the latter modeling to be inferred from the former. Hence, the two  modeling of the same system are regarded as different in the context of this specification.</p>
    </div>
</section>
    
<section id="entities-and-activities">
  <h3><span class="secno">5.2 </span>Entities and Activities</h3>


  

<p id="communication-generation-use-inference_text">Communication between activities <a title="definition" href="#dfn-definition" class="internalDFN">implies</a> the existence of an underlying
entity generated by one activity and used by the other, and vice versa.</p>

<div class="inference" id="communication-generation-use-inference"><div class="ruleTitle"><a id="5"></a><a class="internalDFN" href="#communication-generation-use-inference">Inference 5 (communication-generation-use-inference)</a></div>
<p>
<span class="conditional">IF</span> 
<span class="name">wasInformedBy(_id; a2,a1,_attrs)</span>
<span class="conditional">THEN</span>
 there exist <span class="name">e</span>,  <span class="name">_gen</span>, <span class="name">_t1</span>, <span class="name">_use</span>, and <span class="name">_t2</span>, 
such that <span class="name">wasGeneratedBy(_gen; e,a1,_t1,[])</span> and <span class="name">used(_use; a2,e,_t2,[])</span> hold.</p>
</div>


<p id="generation-use-communication-inference_text">

 </p><div class="inference" id="generation-use-communication-inference"><div class="ruleTitle"><a id="6"></a><a class="internalDFN" href="#generation-use-communication-inference">Inference 6 (generation-use-communication-inference)</a></div>
<p>
<span class="conditional">IF</span>  <span class="name">wasGeneratedBy(_gen; e,a1,_t1,_attrs1)</span>
   and <span class="name">used(_use; a2,e,_t2,_attrs2)</span> hold
   <span class="conditional">THEN</span>
 there exists <span class="name">_id</span>
such that <span class="name">wasInformedBy(_id; a2,a1,[])</span>
</p></div>
 

  <div class="remark">
<p>The relationship <span class="name">wasInformedBy</span> is not
<a href="#dfn-transitive" class="internalDFN">transitive</a>. Indeed, consider the following statements.</p>
<pre class="codeexample">wasInformedBy(a2,a1)
wasInformedBy(a3,a2)
</pre>
<p> We cannot infer <span class="name">wasInformedBy(a3,a1)</span>
    from these statements alone. Indeed, 
from 
<span class="name">wasInformedBy(a2,a1)</span>, we know that there exists <span class="name">e1</span> such that <span class="name">e1</span> was generated by <span class="name">a1</span>
and used by <span class="name">a2</span>. Likewise, from <span class="name">wasInformedBy(a3,a2)</span>, we know that there exists  <span class="name">e2</span> such that <span class="name">e2</span> was generated by <span class="name">a2</span>
and used by <span class="name">a3</span>. The following illustration
shows a counterexample to  transitivity. The
horizontal axis represents the event line. We see that <span class="name">e1</span> was generated after <span class="name">e2</span> was used. Furthermore, the illustration also shows that
<span class="name">a3</span> completes before <span class="name">a1</span> started.  So in this example (with no other
    information) it is impossible for <span class="name">a3</span> to have used an entity generated by <span class="name">a1</span>. This is illustrated in <a href="#counterexample-wasInformedBy">Figure 2</a>.</p>

<div style="text-align: center;">
<span class="figure" id="fig-figure-2-counter-example-for-transitivity-of-wasinformedby">
<img src="images/constraints/informedByNonTransitive.png" alt="non transitivity of wasInformedBy">
<br>
<span class="figcaption" id="counterexample-wasInformedBy">Figure 2<sup><a class="internalDFN" href="#counterexample-wasInformedBy"><span class="diamond"> ◊:</span></a></sup> Counter-example for transitivity of wasInformedBy</span>
</span> <!-- <b>Figure 2:</b>  -->
</div>
</div>

<!--
<div class="note">
  The following two inferences could interact with type inference to produce
  nontermination.  For example, once we have an activity we can use
  activity-start-end-inference and start-type-inference forever to
  infer an infinite chain of activities, each starting the next.
  Similarly, we can use inference-activity-start-end,
start-type-inference, entity-generation-invalidation-inference,
  and generation-type-inference forever to infer an infinite chain of
  entities generated by activities that were started by entities that
  were generated by activities ...

  We must break this recursion somewhere in order to ensure
  implementability.  I propose to drop both of the following
  inferences, since they seem less necessary than the type inferences.
  </div>
-->
 
<hr>

<!--
  <div class="note">
    The following inference is a  "<a
href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">feature at
risk</a>" and may be dropped if it leads to
  implementation difficulties.
    </div>
-->

<p id="entity-generation-invalidation-inference_text">
From an entity statement, we can infer the existence of
generation and invalidation events.
</p>
<div class="inference" id="entity-generation-invalidation-inference"><div class="ruleTitle"><a id="7"></a><a class="internalDFN" href="#entity-generation-invalidation-inference">Inference 7 (entity-generation-invalidation-inference)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">entity(e,_attrs)</span> <span class="conditional">THEN</span> there exist 
<span class="name">_gen</span>, <span class="name">_a1</span>, <span class="name">_t1</span>,
<span class="name">_inv</span>, <span class="name">_a2</span>, and <span class="name">_t2</span> such that
  <span class="name">wasGeneratedBy(_gen; e,_a1,_t1,[])</span> and <span class="name">wasInvalidatedBy(_inv; e,_a2,_t2,[])</span>.
</p></div> 


<hr>
<!--
  <div class="note">
    The following inference is a  "<a
href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">feature at
risk</a>" and may be dropped if it leads to
  implementation difficulties.
    </div>-->

<p id="activity-start-end-inference_text">
From an activity statement, we can infer 
start and end events whose times match the start and end times of
the activity, respectively.
</p>
<div class="inference" id="activity-start-end-inference"><div class="ruleTitle"><a id="8"></a><a class="internalDFN" href="#activity-start-end-inference">Inference 8 (activity-start-end-inference)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">activity(a,t1,t2,_attrs)</span> <span class="conditional">THEN</span> there exist <span class="name">_start</span>, <span class="name">_e1</span>, <span class="name">_a1</span>, <span class="name">_end</span>, <span class="name">_a2</span>, 
  and <span class="name">_e2</span> such that
  <span class="name">wasStartedBy(_start; a,_e1,_a1,t1,[])</span> and <span class="name">wasEndedBy(_end; a,_e2,_a2,t2,[])</span>.
</p></div> 


<hr>

  
<p id="wasStartedBy-inference_text">The start of an activity <span class="name">a</span> triggered by entity <span class="name">e1</span>
implies that 
<span class="name">e1</span> was generated by the starting activity <span class="name">a1</span>.</p>

<div class="inference" id="wasStartedBy-inference"><div class="ruleTitle"><a id="9"></a><a class="internalDFN" href="#wasStartedBy-inference">Inference 9 (wasStartedBy-inference)</a></div>
<p><span class="conditional">IF</span>
 <span class="name">wasStartedBy(_id; _a,e1,a1,_t,_attrs)</span>,
<span class="conditional">THEN</span> there exist <span class="name">_gen</span> and  <span class="name">_t1</span>
such that 
 <span class="name">wasGeneratedBy(_gen; e1,a1,_t1,[])</span>.</p>
</div>
<p>

</p><hr>

<p id="wasEndedBy-inference_text">Likewise,
the ending of activity <span class="name">a</span> by triggering entity <span class="name">e1</span> implies that 
<span class="name">e1</span> was generated by the ending activity <span class="name">a1</span>.
</p>

<div class="inference" id="wasEndedBy-inference"><div class="ruleTitle"><a id="10"></a><a class="internalDFN" href="#wasEndedBy-inference">Inference 10 (wasEndedBy-inference)</a></div>
<p><span class="conditional">IF</span>
 <span class="name">wasEndedBy(_id; _a,e1,a1,_t,_attrs)</span>,
<span class="conditional">THEN</span> there exist <span class="name">_gen</span> and <span class="name">_t1</span> such that 
 <span class="name">wasGeneratedBy(_gen; e1,a1,_t1,[])</span>.</p>
</div>




</section>

 <section id="derivations"> 
<h3><span class="secno">5.3 </span>Derivations</h3>


<hr>
<p id="derivation-generation-use-inference_text">Derivations with explicit
activity, generation, and usage admit the  following inference: </p>

<div class="inference" id="derivation-generation-use-inference"><div class="ruleTitle"><a id="11"></a><a class="internalDFN" href="#derivation-generation-use-inference">Inference 11 (derivation-generation-use-inference)</a></div>
<p> In this inference, none of <span class="name">a</span>, <span class="name">gen2</span> or <span class="name">use1</span> can be
  placeholders <span class="name">-</span>.
  </p><p>
<span class="conditional">IF</span> <span class="name">wasDerivedFrom(_id; e2,e1,a,gen2,use1,_attrs)</span>,
  <span class="conditional">THEN</span> there exists  <span class="name">_t1</span> and <span class="name">_t2</span> such that  <span class="name">used(use1; a,e1,_t1,[])</span> and <span class="name">wasGeneratedBy(gen2; e2,a,_t2,[])</span>.
</p>
</div>
<p>
<!--
<hr>

<p id='derivation-use-inference_text'>According to <a class="rule-text"
href="#optional-placeholders"><span>TBD</span></a>, optional generation and usage in a derivation are not expandable. However,  derivations with an explicit activity and
no specified generation and usage admit the  following inference: </p>


<div class="note">
  derivation-use-inference is problematic because the inferred
  derivation may violate the key constraint on derivations.  We could
conditionally allow expansion of gen and use when the activity is
  specified (non-placeholder).
</div>
<div class='inference' id='derivation-use-inference'>
<p>
  In this inference, <span class="name">a</span> cannot  be
  a placeholder <span class="name">-</span>.
  </p>
  <p>
<span class='conditional'>IF</span> <span class="name">wasDerivedFrom(id; e2,e1,a,-,-,attrs)</span> and <span class="name">wasGeneratedBy(gen; e2,a,_t2,_attrs2)</span> hold, <span
class='conditional'>THEN</span> there exist <span
  class="name">_t1</span> and <span class="name">use</span> such
  that <span class="name">used(use; a,e1,_t1,[])</span> and <span
  class="name">wasDerivedFrom(id; e2,e1,a,gen,use,attrs)</span>.
</div>
<p>This inference is justified by the fact that the entity denoted by
  <span class="name">e2</span> has a unique generation event
  representing its generation by activity <span class="name">a</span>
(see <a class="rule-text" href="#unique-generation"><span>TBD</span></a>). Hence,  this activity is also the one referred to by the usage of <span class="name">e1</span>. 
</p>

<div class="remark" id="derivation-generation-use-inference-remark">
  <p>
 <a class="rule-text" href="#derivation-use-inference"><span>TBD</span></a> allows "-" to be replaced by existential variables in a <span
  class="name">wasDerivedFrom</span>, when an activity is explicit, and a generation known.</p>

<p> However, a derivation without explicit generation and usage cannot be normalized even when a generation and usage hold.   
if <span class="name">wasDerivedFrom(id; e2,e1,a,-,-,attrs)</span>,
<span class="name">wasGeneratedBy(gen; e2,a,_t2,_attrs2)</span>,
and <span class="name">used(use; a,e1,_t1,[])</span>, it is not
  necessarily the case that
<span
  class="name">wasDerivedFrom(id; e2,e1,a,gen,use,attrs)</span>.
Indeed,
<span
class="name">e1</span> may be used multiple times by 
 <span class="name">a</span>, usage  <span class="name">use</span>
may not be involved in the derivation  (for example, it may well have taken place after 
the generation of <span class="name">e2</span>).</p>
 </div>
-->
 
<!--
 <hr />
 <div class="note">
   Likely to delete specific-derivation-inference
   </div>
<p id="specific-derivation-inference_text">A derivation
  specifying activity, generation and use events is a special case of
  a derivation that leaves these unspecified.  The converse is not
  the case because the activity parameter of derivations is
 non-expandable in <a class="rule-ref"
href="#optional-placeholders"><span>TBD</span></a>. </p>

<div class='inference' id='specific-derivation-inference'>
<p>In this inference,  <span class="name">_act</span>, <span class="name">_gen</span>, and <span class="name">_use</span> MUST NOT
  be placeholders.
  </p>
  <p><span class='conditional'>IF</span> <span
  class="name">wasDerivedFrom(id; e2,e1,_act,_gen,_use,attrs)</span>, 
<span class='conditional'>THEN</span> <span 
  class="name">wasDerivedFrom(id; e2,e1,-,-,-,attrs)</span>.
</p>
</div>
-->
  
</p><hr>
<p id="revision-is-alternate-inference_text">A revision admits the following inference, stating that  the two entities
linked  by a revision are also alternates.</p>
 
<div class="inference" id="revision-is-alternate-inference"><div class="ruleTitle"><a id="12"></a><a class="internalDFN" href="#revision-is-alternate-inference">Inference 12 (revision-is-alternate-inference)</a></div>
  <p>In this inference, any of <span class="name">_a</span>, <span class="name">_g</span> or <span class="name">_u</span> <em class="rfc2119" title="MAY">MAY</em> be placeholders.</p>
<p>
  <span class="conditional">IF</span> <span class="name">wasDerivedFrom(_id; e2,e1,_a,_g,_u,[prov:type='prov:Revision'])</span>, <span class="conditional">THEN</span> <span class="name">alternateOf(e2,e1)</span>.  
</p>
<!--
<li><span class='conditional'>IF</span> <span
  class="name">wasDerivedFrom(_id; e2,e1,_act,_gen,_use,[prov:type='prov:Revision'])</span>, <span class='conditional'>THEN</span> <span
  class="name">alternateOf(e2,e1)</span>.
</li>
-->
</div>


<!--
<div class="note">
  The following doesn't make sense because wasRevisionOf and
  wasDerivedFrom have different types.
  </div>
<p><span class="name">wasRevisionOf</span> is a strict sub-relation
 of <span class="name">wasDerivedFrom</span> since two entities <span class="name">e2</span> and <span class="name">e1</span>
 may satisfy <span class="name">wasDerivedFrom(e2,e1)</span> without being a variant of
 each other.
</p>


  <div class="note">
  Motivation for quotation inference
  </div>
<div class='inference' id='quotation-implication'>
<span class='conditional'>IF</span>
<span class="name">wasQuotedFrom(e2,e1,ag2,ag1,attrs)</span>
  for some identifiers
<span class="name">e2</span>, <span class="name">e1</span>, <span class="name">ag2</span>, <span class="name">ag1</span>,
<span class='conditional'>THEN</span> 
<pre
wasDerivedFrom(e2,e1)
wasAttributedTo(e2,ag2)
wasAttributedTo(e1,ag1)
</pre>
</div>

<p>

-->

<div class="remark">
  There is no inference stating that <span class="name">wasDerivedFrom</span> is
  transitive.  
  </div>
</section>


<section id="agents">
<h3><span class="secno">5.4 </span>Agents</h3>

<p id="attribution-inference_text"> Attribution is the ascribing of an entity to an agent.  An
entity can only be ascribed to an agent if the agent was associated with
an activity that generated the entity.  If the activity, generation 
and association events are not explicit in the instance, they can
be inferred.</p>

<div class="inference" id="attribution-inference"><div class="ruleTitle"><a id="13"></a><a class="internalDFN" href="#attribution-inference">Inference 13 (attribution-inference)</a></div>
<p>
<span class="conditional">IF</span>
<span class="name">wasAttributedTo(_att; e,ag,_attrs)</span>
  <!--holds for some identifiers
<span class="name">e</span> and <span class="name">ag</span>,  -->
<span class="conditional">THEN</span> there exist
  <span class="name">a</span>,
 <span class="name">_t</span>,
<span class="name">_gen</span>,
<span class="name">_assoc</span>,
  <span class="name">_pl</span>,
such that 
<span class="name">wasGeneratedBy(_gen; e,a,_t,[])</span> and 
<span class="name">wasAssociatedWith(_assoc; a,ag,_pl,[])</span>.
</p>
</div>

<div class="remark">
  In the above inference, <span class="name">_pl</span> is an
  existential variable, so it can be unified
with a constant identifier, another existential variable, or a
  placeholder <span class="name">-</span>, as explained
  in the definition of <a href="#dfn-unification" class="internalDFN">unification</a>.
  </div>
<hr>
<p id="delegation-inference_text"> Delegation relates agents where one agent acts on behalf of
another, in the context of some activity.  The supervising agent
delegates some responsibility for part of the activity to the
subordinate agent, while retaining some responsibility for the overall
activity.  Both agents are associated with this activity.</p>


<div class="inference" id="delegation-inference"><div class="ruleTitle"><a id="14"></a><a class="internalDFN" href="#delegation-inference">Inference 14 (delegation-inference)</a></div>
<p>
<span class="conditional">IF</span>
<span class="name">actedOnBehalfOf(_id; ag1, ag2, a, _attrs)</span>
<span class="conditional">THEN</span> there exist  <span class="name">_id1</span>, <span class="name">_pl1</span>, <span class="name">_id2</span>, and  <span class="name">_pl2</span> such that <span class="name">wasAssociatedWith(_id1; a, ag1, _pl1, [])</span>
  and <span class="name">wasAssociatedWith(_id2; a, ag2, _pl2,
  [])</span>.
</p>
</div>


<div class="remark">
  The two associations between the agents and the activity
  may have different identifiers, different plans, and different
  attributes.  In particular, the plans of the two agents need not be
  the same, and one, both, or neither can be the placeholder <span class="name">-</span>
  indicating that there is no plan, because the existential variables
  <span class="name">_pl1</span> and <span class="name">_pl2</span>
  can be replaced with constant identifiers, existential variables, or
  placeholders <span class="name">-</span> independently, as explained
  in the definition of <a href="#dfn-unification" class="internalDFN">unification</a>.
  </div>

<hr>
<p id="influence-inference_text">
The <span class="name">wasInfluencedBy</span> relation is implied by other relations, including
usage, start, end, generation, invalidation, communication,
derivation, attribution, association, and delegation.  To capture this
explicitly, we allow the following inferences:
</p>
<div class="inference" id="influence-inference"><div class="ruleTitle"><a id="15"></a><a class="internalDFN" href="#influence-inference">Inference 15 (influence-inference)</a></div>
<p>
  </p><ol>
  <li>
    <span class="conditional">IF</span> <span class="name">wasGeneratedBy(id; e,a,_t,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  e, a, attrs)</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">used(id; a,e,_t,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  a, e, attrs)</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">wasInformedBy(id; a2,a1,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  a2, a1, attrs)</span>.
  </li>
 <li>
    <span class="conditional">IF</span> <span class="name">wasStartedBy(id; a2,e,_a1,_t,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  a2, e, attrs)</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">wasEndedBy(id; a2,e,_a1,_t,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  a2, e, attrs)</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">wasInvalidatedBy(id; e,a,_t,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  e, a, attrs)</span>.
  </li>
 <li>
    <span class="conditional">IF</span> <span class="name">wasDerivedFrom(id;  e2, e1, _a, _g, _u, attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  e2, e1, attrs)</span>.  Here,
  <span class="name">_a</span>, <span class="name">_g</span>, <span class="name">_u</span> <em class="rfc2119" title="MAY">MAY</em> be placeholders <span class="name">-</span>.
  </li>
<li>
    <span class="conditional">IF</span> <span class="name">wasAttributedTo(id; e,ag,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id; e, ag, attrs)</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">wasAssociatedWith(id; a,ag,_pl,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  a, ag, attrs)</span>.  Here,
  <span class="name">_pl</span> <em class="rfc2119" title="MAY">MAY</em> be a placeholder <span class="name">-</span>.
  </li>
  <li>
    <span class="conditional">IF</span> <span class="name">actedOnBehalfOf(id; ag2,ag1,_a,attrs)</span> <span class="conditional">THEN</span> <span class="name">wasInfluencedBy(id;  ag2, ag1, attrs)</span>.
  </li>
</ol>
</div>

<div class="remark">
  The inferences above permit the use of  same identifier for an
  influence relationship and a more
  specific relationship.
</div>

</section>



 <section id="alternate-and-specialized-entities"> 
<h3><span class="secno">5.5 </span>Alternate and Specialized Entities</h3>



  
<hr>
  <p id="alternate-reflexive_text">The relation <span class="name">alternateOf</span> is an <a href="#dfn-equivalence-relation" class="internalDFN">equivalence relation</a> on
  entities: that is,
  it is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>,
  <a href="#dfn-transitive" class="internalDFN">transitive</a> and <a href="#dfn-symmetric" class="internalDFN">symmetric</a>.  As a consequence, the
  following inferences can be applied:</p>

 
<div class="inference" id="alternate-reflexive"><div class="ruleTitle"><a id="16"></a><a class="internalDFN" href="#alternate-reflexive">Inference 16 (alternate-reflexive)</a></div>
<p>
<span class="conditional">IF</span>  <span class="name">entity(e)</span> <span class="conditional">THEN</span>
<span class="name">alternateOf(e,e)</span>.
</p>
    </div>

<p>

</p><hr>
  <p id="alternate-transitive_text">

       </p><div class="inference" id="alternate-transitive"><div class="ruleTitle"><a id="17"></a><a class="internalDFN" href="#alternate-transitive">Inference 17 (alternate-transitive)</a></div>
<p><!-- For any entities <span class='name'>e1</span>, <span class='name'>e2</span>, <span class='name'>e3</span>,  -->
<span class="conditional">IF</span> <span class="name">alternateOf(e1,e2)</span> and
   <span class="name">alternateOf(e2,e3)</span> <span class="conditional">THEN</span> <span class="name">alternateOf(e1,e3)</span>.</p>
    </div>

<p>

</p><hr>
  <p id="alternate-symmetric_text">

   </p><div class="inference" id="alternate-symmetric"><div class="ruleTitle"><a id="18"></a><a class="internalDFN" href="#alternate-symmetric">Inference 18 (alternate-symmetric)</a></div>
<p><!-- For any entity <span class='name'>e1</span>, <span class='name'>e2</span>, -->
<span class="conditional">IF</span>  <span class="name">alternateOf(e1,e2)</span> <span class="conditional">THEN</span> <span class="name">alternateOf(e2,e1)</span>.</p>
    </div>

<p>


</p><hr>
<p id="specialization-transitive_text">
Similarly, specialization is a
    <a href="#dfn-strict-partial-order" class="internalDFN">strict partial order</a>: it is <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a> and
    <a href="#dfn-transitive" class="internalDFN">transitive</a>.  Irreflexivity is handled later as <a class="rule-ref" href="#impossible-specialization-reflexive"><span>Constraint 52 (impossible-specialization-reflexive)</span></a>
    </p>
       <div class="inference" id="specialization-transitive"><div class="ruleTitle"><a id="19"></a><a class="internalDFN" href="#specialization-transitive">Inference 19 (specialization-transitive)</a></div>
<p>
<!--    For any   entities <span class='name'>e1</span>, <span class='name'>e2</span>, <span class='name'>e3</span>, -->
<span class="conditional">IF</span> <span class="name">specializationOf(e1,e2)</span>
    and
	 <span class="name">specializationOf(e2,e3)</span> <span class="conditional">THEN</span> <span class="name">specializationOf(e1,e3)</span>.</p>
    </div> 

<p>

</p><hr>

    <p id="specialization-alternate-inference_text">If one entity specializes another, then they are also
    alternates:</p>
    
       <div class="inference" id="specialization-alternate-inference"><div class="ruleTitle"><a id="20"></a><a class="internalDFN" href="#specialization-alternate-inference">Inference 20 (specialization-alternate-inference)</a></div>
<p>
<!--    For any entities  <span class='name'>e1</span>, <span class='name'>e2</span>, -->
<span class="conditional">IF</span> <span class="name">specializationOf(e1,e2)</span> <span class="conditional">THEN</span> <span class="name">alternateOf(e1,e2)</span>.</p>
    </div> 

<hr>
<p id="specialization-attributes-inference_text">
    If one entity specializes another then all attributes of the more
    general entity are also attributes of the more specific one.
    </p>
<div class="inference" id="specialization-attributes-inference"><div class="ruleTitle"><a id="21"></a><a class="internalDFN" href="#specialization-attributes-inference">Inference 21 (specialization-attributes-inference)</a></div>
  <p>
<!--  For any entities <span class='name'>e1</span>, <span class='name'>e2</span>,-->
<span class="conditional">IF</span> <span class="name">entity(e1, attrs)</span> <!--holds for some
  attributes <span class='name'>attrs</span>
  --> and <span class="name">specializationOf(e2,e1)</span>, <span class="conditional">THEN </span>
  <span class="name">entity(e2, attrs)</span>.</p>
  </div>


  
<!--
  <hr />

  <div class="note">
<p>Note: The following inference is associated with a feature "<a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">at risk</a>" and may be removed from this specification based on feedback. Please send feedback to public-prov-comments@w3.org.</p>
</div>


    <p id="mention-specialization-inference_text">If one entity is a mention of another in a bundle, then the former is also a specialization of the latter:</p>
    
       <div class='inference' id="mention-specialization-inference">
<p>
<span class='conditional'>IF</span> <span class='name'>mentionOf(e2,e1,b)</span> <span class='conditional'>THEN</span> <span class='name'>specializationOf(e2,e1)</span>.</p>
    </div> 

-->
</section>





</section>



<section id="constraints">
<!--OddPage--><h2><span class="secno">6. </span>Constraints</h2>




<p>
This section defines a collection of constraints on PROV instances.
There are three kinds of constraints:
  </p><ul><li><em>uniqueness constraints</em> that say that a <a href="#instance" class="internalDFN">PROV
  instance</a> can contain at most one statement of each kind with a
    given identifier. For
  example, if we describe the same generation event twice, then the
  two statements should have the same times;
    </li>
    <li> <em>event ordering constraints</em> that say that it
  should be possible to arrange the 
  events (generation, usage, invalidation, start, end) described in a
  PROV instance into a <a href="#dfn-preorder" class="internalDFN">preorder</a> that corresponds to a sensible
  "history" (for example, an entity should not be generated after it
  is used); and
    </li>
    <li><em>impossibility constraints</em>, which forbid certain
    patterns of statements in <a href="#dfn-valid" class="internalDFN">valid</a> PROV instances.
    </li></ul>
  
  <p>As in a definition or inference, term symbols such as <span class="name">id</span>, 
	<span class="name">start</span>, <span class="name">end</span>, <span class="name">e</span>, 
	<span class="name">a</span>, <span class="name">attrs</span> in a constraint,
	are assumed to be variables unless otherwise specified.  These variables are scoped at 
	the constraint level, so the rule is equivalent to any one-for-one 
	renaming of the variable names.  When several rules are collected within a constraint
	as an ordered list, the scope of the variables in each rule is at the level of list elements, and so reuse of 
	variable names in different rules does not affect the meaning.
</p>
  <section id="uniqueness-constraints">


 
  <h3><span class="secno">6.1 </span>Uniqueness Constraints</h3>


    
   <p> In the absence of existential variables, uniqueness constraints
    could be checked directly by checking that no identifier appears
    more than once for a given statement.  However, in the presence of
    existential variables, we need to be more careful to combine
    partial information that might be present in multiple compatible
    statements, due to inferences.  Uniqueness constraints are
    enforced through <a href="#dfn-merging" class="internalDFN">merging</a> pairs of statements subject to
    equalities.  For example, suppose we have two activity statements
    <span class="name">activity(a,2011-11-16T16:00:00,_t1,[a=1])</span> and <span class="name">activity(a,_t2,2011-11-16T18:00:00,[b=2])</span>, with existential variables <span class="name">_t1</span> and <span class="name">_t2</span>.  The <dfn id="dfn-merge">merge</dfn> of
    these two statements (describing the same activity <span class="name">a</span>) is <span class="name">activity(a,2011-11-16T16:00:00,2011-11-16T18:00:00,[a=1,b=2])</span>.  </p>


  <p>
A typical uniqueness constraint is as follows:
  </p>
  <div class="constraint-example" id="uniqueness-example"><div class="ruleTitle"><a class="internalDFN" href="#uniqueness-example">Constraint-example NNN (uniqueness-example)</a></div>
<p>    <span class="conditional">IF</span> <span class="name">hyp<sub>1</sub></span> and ... and <span class="name">hyp<sub>n</sub></span> <span class="conditional">THEN</span> <span class="name">t<sub>1</sub></span> = <span class="name">u<sub>1</sub></span> and ... and <span class="name">t<sub>n</sub></span> = <span class="name">u<sub>n</sub></span>.</p>
  </div>

  <p> Such a constraint is enforced as follows:</p>
  <ol> <li>Suppose PROV instance <span class="math">I</span> contains all of the hypotheses
  <span class="name">hyp<sub>1</sub></span> and ... and <span class="name">hyp<sub>n</sub></span>.
    </li>
    <li>Attempt to unify all of the equated terms in the conclusion
  <span class="name">t<sub>1</sub></span> = <span class="name">u<sub>1</sub></span> and ... and <span class="name">t<sub>n</sub></span> = <span class="name">u<sub>n</sub></span>.
    </li>
    <li>If unification fails, then the constraint
  is unsatisfiable, so application of the constraint to <span class="math">I</span>
  fails. If this failure occurs during <a title="normal form" href="#dfn-normal-form" class="internalDFN">normalization</a> prior to
validation, then <span class="math">I</span> is invalid, as explained in <a href="#normalization-validity-equivalence">Section 6</a>.
    </li>
  <li>If unification succeeds with a substitution <span class="math">S</span>, then
  <span class="math">S</span> is applied to the instance <span class="math">I</span>, yielding result <span class="math">S(I)</span>.</li>
  </ol>
  
<p>  <em><dfn id="dfn-key-constraints">Key constraints</dfn></em> are uniqueness constraints
  that specify that a particular key field of a relation uniquely
  determines the other parameters.  Key constraints are written as follows:
  </p>

  <div class="constraint-example" id="key-example"><div class="ruleTitle"><a class="internalDFN" href="#key-example">Constraint-example NNN (key-example)</a></div>
    <p>The <span class="name">a<sub>k</sub></span> field is a <span class="conditional">KEY</span> for relation <span class="name">r(a<sub>0</sub>; a<sub>1</sub>,...,a<sub>n</sub>)</span>.  </p></div>

 <p> Because of the presence of attributes, key constraints do not
  reduce directly to uniqueness constraints.  Instead, we enforce key
  constraints using the following <dfn id="dfn-merging">merging</dfn> process.  </p>
  <ol>
    <li> Suppose <span class="name">r(a<sub>0</sub>; a<sub>1</sub>,...a<sub>n</sub>,attrs1)</span> and <span class="name">r(b<sub>0</sub>; b<sub>1</sub>,...b<sub>n</sub>,attrs2)</span> hold in PROV instance <span class="math">I</span>, where the key fields <span class="name">a<sub>k</sub> = b<sub>k</sub></span> are equal.</li>
  <li> Attempt to unify all of the corresponding parameters  <span class="name">a<sub>0</sub> = b<sub>0</sub> </span> and ... and  <span class="name">a<sub>n</sub> = b<sub>n</sub></span>.
  </li>
  <li>If unification fails, then the constraint is unsatisfiable, so
  application of the key constraint to <span class="math">I</span> fails.
  </li>
  <li>If unification succeeds with substitution <span class="math">S</span>, then we remove <span class="name">r(a<sub>0</sub>; a<sub>1</sub>,...a<sub>n</sub>,attrs1)</span> and <span class="name">r(b<sub>0</sub>; b<sub>1</sub>,...b<sub>n</sub>,attrs2)</span> from <span class="math">I</span>, obtaining
  instance <span class="math">I'</span>, and return instance  <span class="name">{r(S(a<sub>0</sub>); S(a<sub>1</sub>),...S(a<sub>n</sub>),attrs1 ∪
  attrs2)}</span>  ∪ <span class="math">S(I')</span>.
    </li></ol>


    
<p>Thus, if a PROV instance contains an apparent violation of a uniqueness
  constraint or key constraint, unification or merging can be used to determine
  whether the constraint can be satisfied by instantiating some existential
  variables with other terms.  For key constraints, this is the same
  as merging pairs of statements whose keys are equal and whose
  corresponding arguments are compatible, because after
  unifying respective arguments and combining attribute lists, the two statements
  become equal and one can be omitted. </p>
  



  

<p>
</p><hr>

  <p id="key-object_text">The various identified objects of PROV <em class="rfc2119" title="MUST">MUST</em> have
  unique statements describing them within a valid PROV instance.
  This is enforced through
  the following key constraints:
  </p>
  <div class="constraint" id="key-object"><div class="ruleTitle"><a id="22"></a><a class="internalDFN" href="#key-object">Constraint 22 (key-object)</a></div>
<p></p><ol>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#entity.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">entity(id,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#activity.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the  <span class="name">activity(id,t1,t2,attrs)</span> statement.
   </li>
<li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#agent.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the  <span class="name">agent(id,attrs)</span> statement.
  </li>
  </ol>
   </div>

   <hr>
   <p id="key-properties_text"> Likewise, the statements
in a valid PROV instance must provide consistent information about
   each identified object or relationship. The following key
   constraints require that all of the information about each identified
   statement can be merged into a single, consistent statement:
  </p>
  <div class="constraint" id="key-properties"><div class="ruleTitle"><a id="23"></a><a class="internalDFN" href="#key-properties">Constraint 23 (key-properties)</a></div>
<p></p><ol>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#generation.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasGeneratedBy(id; e,a,t,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#usage.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">used(id; a,e,t,attrs)</span> statement.
  </li>
 <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#communication.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasInformedBy(id; a2,a1,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#start.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasStartedBy(id; a2,e,a1,t,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#end.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasEndedBy(id; a2,e,a1,t,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#invalidation.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasInvalidatedBy(id; e,a,t,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#derivation.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasDerivedFrom(id;  e2, e1, a, g2, u1, attrs)</span> statement.
  </li>
 <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#attribution.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasAttributedTo(id; e,ag,attr)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#association.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasAssociatedWith(id; a,ag,pl,attrs)</span> statement.
 </li>
<!--
 <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#association.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasAssociatedWith(id; a,ag,-,attrs)</span> statement.
  </li>
-->
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#delegation.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">actedOnBehalfOf(id; ag2,ag1,a,attrs)</span> statement.
  </li>
  <li>The identifier field <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/#influence.id"><span class="name">id</span></a> is a <span class="conditional">KEY</span> for
  the <span class="name">wasInfluencedBy(id; o2,o1,attrs)</span> statement.
  </li>
</ol>
   </div>



<hr>


<div id="unique-generation_text">
<p> Entities may have multiple generation or invalidation events
  (either or both may, however, be left implicit).  An entity can be
  generated by more than one activity, with one generation event per
  each entity-activity pair.  These events must be simultaneous, as required by <a class="rule-ref" href="#generation-generation-ordering"><span>Constraint 39 (generation-generation-ordering)</span></a>
  and <a class="rule-ref" href="#invalidation-invalidation-ordering"><span>Constraint 40 (invalidation-invalidation-ordering)</span></a>.
<!--  Together with the key constraints above, this implies that
  <span class="name">e</span> is also a key for generation and
  invalidation statements.
  -->
</p>
</div>


<div class="constraint" id="unique-generation"><div class="ruleTitle"><a id="24"></a><a class="internalDFN" href="#unique-generation">Constraint 24 (unique-generation)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">wasGeneratedBy(gen1; e,a,_t1,_attrs1)</span> and <span class="name">wasGeneratedBy(gen2; e,a,_t2,_attrs2)</span>,
<span class="conditional">THEN</span> <span class="name">gen1</span> = <span class="name">gen2</span>.</p>
</div> 

<p>

</p><hr>
<p id="unique-invalidation_text">

</p><div class="constraint" id="unique-invalidation"><div class="ruleTitle"><a id="25"></a><a class="internalDFN" href="#unique-invalidation">Constraint 25 (unique-invalidation)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">wasInvalidatedBy(inv1; e,a,_t1,_attrs1)</span> and <span class="name">wasInvalidatedBy(inv2; e,a,_t2,_attrs2)</span>,
<span class="conditional">THEN</span> <span class="name">inv1</span> = <span class="name">inv2</span>.</p>
</div> 


<div class="remark"> <p> It follows from the above uniqueness and key
  constraints that the generation and invalidation events linking an
  entity and activity are unique, if specified.  However, because we
  apply the constraints by merging, it is possible for a valid PROV instance
to contain multiple statements about the same generation or
  invalidation event, for example:</p>
  <pre>wasGeneratedBy(id1; e,a,-,[prov:location="Paris"])
wasGeneratedBy(-; e,a,-,[color="Red"])
</pre>
<p>  When the uniqueness and key constraints are applied, the instance is
  <a title="normal form" href="#dfn-normal-form" class="internalDFN">normalized</a> to the following form:</p>
  <pre>wasGeneratedBy(id1; e,a,_t,[prov:location="Paris",color="Red"])
</pre>
<p>
  where <span class="name">_t</span> is a new existential variable.
  </p>
</div>


<hr>
<p id="unique-wasStartedBy_text">
An activity may have more than one start and
end event, each having a different activity (either or both may,
however, be left implicit).  However,
the triggering entity linking any two activities in a start or end event is unique.
That is, an activity may be started by
several other activities, with shared or separate triggering
entities.  If an activity is started or ended by multiple events, they must all
be simultaneous, as specified in <a class="rule-ref" href="#start-start-ordering"><span>Constraint 31 (start-start-ordering)</span></a>
and <a class="rule-ref" href="#end-end-ordering"><span>Constraint 32 (end-end-ordering)</span></a>.
</p>

<div class="constraint" id="unique-wasStartedBy"><div class="ruleTitle"><a id="26"></a><a class="internalDFN" href="#unique-wasStartedBy">Constraint 26 (unique-wasStartedBy)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">wasStartedBy(start1; a,_e1,a0,_t1,_attrs1)</span> and <span class="name">wasStartedBy(start2; a,_e2,a0,_t2,_attrs2)</span>,  <span class="conditional">THEN</span> <span class="name">start1</span> = <span class="name">start2</span>.</p>
</div> 

<p id="unique-wasEndedBy_text">

</p><div class="constraint" id="unique-wasEndedBy"><div class="ruleTitle"><a id="27"></a><a class="internalDFN" href="#unique-wasEndedBy">Constraint 27 (unique-wasEndedBy)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">wasEndedBy(end1; a,_e1,a0,_t1,_attrs1)</span> and <span class="name">wasEndedBy(end2; a,_e2,a0,_t2,_attrs2)</span>,  <span class="conditional">THEN</span> <span class="name">end1</span> = <span class="name">end2</span>.</p>
</div> 


<hr>





 <p id="unique-startTime_text">An <a href="#dfn-start-event" class="internalDFN">activity start event</a> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the instant an activity starts. It allows for an optional time attribute.  <span id="optional-start-time">Activities also allow for an optional start time attribute.  If both are specified, they <em class="rfc2119" title="MUST">MUST</em> be the same, as expressed by the following constraint.</span>
</p>

<div class="constraint" id="unique-startTime"><div class="ruleTitle"><a id="28"></a><a class="internalDFN" href="#unique-startTime">Constraint 28 (unique-startTime)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">activity(a2,t1,_t2,_attrs)</span> and <span class="name">wasStartedBy(_start; a2,_e,_a1,t,_attrs)</span>,  <span class="conditional">THEN</span> <span class="name">t1</span>=<span class="name">t</span>.</p>
</div> 

<hr>

<p id="unique-endTime_text">An <a href="#dfn-end-event" class="internalDFN">activity end event</a> is the <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> that marks the instant an activity ends. It allows for an optional time attribute.  <span id="optional-end-time">Activities also allow for an optional end time attribute.  If both are specified, they <em class="rfc2119" title="MUST">MUST</em> be the same, as expressed by the following constraint.</span>
</p>

<div class="constraint" id="unique-endTime"><div class="ruleTitle"><a id="29"></a><a class="internalDFN" href="#unique-endTime">Constraint 29 (unique-endTime)</a></div>
<p>
<span class="conditional">IF</span> <span class="name">activity(a2,_t1,t2,_attrs)</span> and <span class="name">wasEndedBy(_end; a2,_e,_a1,t,_attrs1)</span>,  <span class="conditional">THEN</span> <span class="name">t2</span> = <span class="name">t</span>.</p>
</div> 

<p>


</p><hr>


<!--
<div class="note">
<p>Note: The following constraint is associated with a feature "<a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">at risk</a>" and may be removed from this specification based on feedback. Please send feedback to public-prov-comments@w3.org.</p>
</div>
  

<div id='unique-mention_text'>
<p>An entity can be the subject of at most one mention relation.</p>
</div>


<div class='constraint' id='unique-mention'>
<p>
<span class='conditional'>IF</span> <span class="name">mentionOf(e, e1, b1)</span> and <span class="name">mentionOf(e, e2, b2)</span>,
<span class='conditional'>THEN</span>  <span class="name">e1</span>=<span class="name">e2</span> and <span class="name">b1</span>=<span class="name">b2</span>.</p>
</div> 

-->



</section> <!-- uniqueness-constraints--> 

<section id="event-ordering-constraints">
<h3><span class="secno">6.2 </span>Event Ordering Constraints</h3>


<p>Given that provenance consists of a description of past entities
and activities, <a href="#dfn-valid" class="internalDFN">valid</a> provenance instances <em class="rfc2119" title="MUST">MUST</em>
satisfy <em>ordering constraints</em> between instantaneous events, which are introduced in
this section.  For instance, an entity can only be used after it was
generated; in other words, an entity's <a title="entity generation
event" href="#dfn-generation-event" class="internalDFN">generation event</a> precedes any of this
entity's <a title="entity usage event" href="#dfn-usage-event" class="internalDFN">usage events</a>.  Should this
ordering constraint be violated, the associated generation and
usage would not be credible.  The rest of this section defines
the <dfn id="dfn-temporal-interpretation">temporal interpretation</dfn> of provenance instances as a
set of instantaneous event ordering constraints. </p>


<p>To allow for minimalistic clock assumptions, like Lamport
[<cite><a class="bibref" href="#bib-CLOCK">CLOCK</a></cite>], PROV relies on a notion of relative ordering of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous events</a>,
without using physical clocks. This specification assumes that a <a href="#dfn-preorder" class="internalDFN">preorder</a> exists between <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous events</a>.
</p>


<p>Specifically, <dfn id="dfn-precedes">precedes</dfn> is a <a href="#dfn-preorder" class="internalDFN">preorder</a>
between <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous events</a>.  A
constraint of the form
<span class="name">e1</span> <a href="#dfn-precedes" class="internalDFN">precedes</a> <span class="name">e2</span> means that <span class="name">e1</span>
happened at the same time as or before <span class="name">e2</span>.
For symmetry, <dfn id="dfn-follows">follows</dfn> is defined as the
inverse of <a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>; that is, a constraint of
the form 
<span class="name">e1</span> follows <span class="name">e2</span> means that <span class="name">e1</span> happened at the same time
as or after <span class="name">e2</span>. Both relations are
<a href="#dfn-preorder" class="internalDFN">preorder</a>s, meaning that they are <a href="#dfn-reflexive" class="internalDFN">reflexive</a> and
<a href="#dfn-transitive" class="internalDFN">transitive</a>.  Moreover, we sometimes consider <em>strict</em> forms of these
orders: we say <span class="name">e1</span> <dfn id="dfn-strictly-precedes">strictly precedes</dfn> <span class="name">e2</span> to indicate that <span class="name">e1</span>
happened before <span class="name">e2</span>, but not at the same time.  This is a
<a href="#dfn-transitive" class="internalDFN">transitive</a>, <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a> relation. </p>


<p>PROV also allows for time observations to be inserted in
specific provenance statements, for each of the five kinds of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous events</a> introduced in
this specification.  Times in provenance records arising from
different sources might be with respect to different timelines
(e.g. different time zones) leading to apparent inconsistencies.  For
the purpose of checking ordering constraints, the times associated
with events are irrelevant; thus, there is no inference that time ordering
implies event ordering, or vice versa.  However, an application <em class="rfc2119" title="MAY">MAY</em> flag time values
that appear inconsistent with the event ordering as possible
inconsistencies.  When generating provenance, an application <em class="rfc2119" title="SHOULD">SHOULD</em>
use a consistent timeline for related PROV statements within an
instance.</p>


<p>  A typical ordering constraint is as follows.</p>

  <div class="constraint-example" id="ordering-example"><div class="ruleTitle"><a class="internalDFN" href="#ordering-example">Constraint-example NNN (ordering-example)</a></div>
    <p><span class="conditional">IF</span> <span class="name">hyp<sub>1</sub></span> and ... and <span class="name">hyp<sub>n</sub></span> <span class="conditional">THEN</span> <span class="name">evt1</span> <a href="#dfn-precedes" class="internalDFN">precedes</a>/<a href="#dfn-strictly-precedes" class="internalDFN">strictly precedes</a> <span class="name">evt2</span>.  </p></div>
  <p>
  The conclusion of an ordering constraint is either <a href="#dfn-precedes" class="internalDFN">precedes</a>
  or <a href="#dfn-strictly-precedes" class="internalDFN">strictly precedes</a>.  One way to check
  ordering constraints is to 
  generate all <a href="#dfn-precedes" class="internalDFN">precedes</a> and <a title="precedes" href="#dfn-precedes" class="internalDFN">strictly
  precedes</a> 
  relationships arising from the ordering constraints to form a directed graph, with edges marked <a href="#dfn-precedes" class="internalDFN">precedes</a> or
  <a href="#dfn-strictly-precedes" class="internalDFN">strictly precedes</a>, and check that there is no cycle
  containing a <a href="#dfn-strictly-precedes" class="internalDFN">strictly precedes</a> edge.
  </p>

  

<!-- Constraint template: 
<span class="conditional">IF</span>
<span class="name">blah</span> 
and
<span class="name">blah</span> 
<span class="conditional">THEN</span>
<span class="name">XX</span> 
<a>precedes</a>
<span class="name">YY</span>.
-->

<section id="activity-constraints">
<h4><span class="secno">6.2.1 </span>Activity constraints</h4>

<p>
This section specifies ordering constraints from the perspective of
the <a href="#dfn-lifetime" class="internalDFN">lifetime</a> of an activity.  An activity starts, then during
its lifetime can use, generate or invalidate entities, communicate
  with, start, or end
other
activities, or be associated with agents, and finally it ends.  The following constraints amount to
checking that all of the events associated with an activity take place
within the activity's lifetime, and the start and end events mark the
start and endpoints of its lifetime.
</p>

<p><a href="#ordering-activity" class="fig-ref">Figure 3</a> summarizes the ordering
  constraints on activities in a
graphical manner. For this and subsequent figures, an event time line points to the
right. Activities are represented by rectangles, whereas entities are
represented by circles. Usage, generation and invalidation are
represented by the corresponding edges between entities and
activities.  The five kinds of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous events</a> are represented by vertical
dotted lines (adjacent to the vertical sides of an activity's
rectangle, or intersecting usage and generation edges).  The ordering
constraints are represented by triangles: an occurrence of a triangle between two <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> vertical dotted lines represents that the event denoted by the left
line precedes the event denoted by the right line.</p>

<!--
<div class="note"> Miscellaneous suggestions about figures
  (originally from Tim Lebo):  NOW ADDRESSED
<ul>
  <li>
    I think it would help if the "corresponding edges between entities and activities" where the same visual style as the vertical line marking the time the Usage, generation and derivation occurred. A matching visual style provides a Gestalt that matches the concept. I am looking at subfigures b and c in 5.2. </ul>
  </div>

  -->
  
  <div style="text-align: center;">

<span class="figure" id="ordering-activity">
<img src="images/constraints/ordering-activity.png" alt="constraints between events">
<br>
<span class="figcaption" id="ordering-activity-fig">Figure 3<sup><a class="internalDFN" href="#ordering-activity-fig"><span class="diamond"> ◊:</span></a></sup> Summary of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> ordering constraints for activities</span> <!-- <b>Figure 3:</b>  -->
</span>
</div>


 
<hr>

<p id="start-precedes-end_text">
The existence of an activity implies that the <a href="#dfn-start-event" class="internalDFN">activity start
event</a> always <a href="#dfn-precedes" class="internalDFN">precedes</a> the corresponding <a href="#dfn-end-event" class="internalDFN">activity end
event</a>.  This is illustrated by
<a href="#ordering-activity" class="fig-ref">Figure 3</a>
(a) and expressed by <a class="rule-ref" href="#start-precedes-end"><span>Constraint 30 (start-precedes-end)</span></a>.</p>

<div class="constraint" id="start-precedes-end"><div class="ruleTitle"><a id="30"></a><a class="internalDFN" href="#start-precedes-end">Constraint 30 (start-precedes-end)</a></div>
<p>
<span class="conditional">IF</span>
<span class="name">wasStartedBy(start; a,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end</span>.
</p>
</div>
<p>

</p><hr>

<p id="start-start-ordering_text">
If an activity is started by more than one activity, the events must all
be simultaneous.  The following constraint requires that if there are two start
events that start the same activity, then one <a href="#dfn-precedes" class="internalDFN">precedes</a> the
other.  Using this constraint in both directions means that each event
<a href="#dfn-precedes" class="internalDFN">precedes</a> the other.
</p>
<div class="constraint" id="start-start-ordering"><div class="ruleTitle"><a id="31"></a><a class="internalDFN" href="#start-start-ordering">Constraint 31 (start-start-ordering)</a></div>
 <p>
    <span class="conditional">IF</span>
<span class="name">wasStartedBy(start1; a,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasStartedBy(start2; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">start2</span>.
  </p>
</div>

<hr>

<p id="end-end-ordering_text">
If an activity is ended by more than one activity, the events must all
be simultaneous.  The following constraint requires that if there are two end
events that end the same activity, then one <a href="#dfn-precedes" class="internalDFN">precedes</a> the
other.  Using this constraint in both directions means that each event
<a href="#dfn-precedes" class="internalDFN">precedes</a> the other, that is, they are simultaneous.
</p>
<div class="constraint" id="end-end-ordering"><div class="ruleTitle"><a id="32"></a><a class="internalDFN" href="#end-end-ordering">Constraint 32 (end-end-ordering)</a></div>
 <p>
    <span class="conditional">IF</span>
<span class="name">wasEndedBy(end1; a,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end2; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">end1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end2</span>.
  </p>
</div>

<hr>

<p id="usage-within-activity_text">A usage implies ordering of <a title="instantaneous event" href="#dfn-event" class="internalDFN">events</a>, since the <a title="entity usage event" href="#dfn-usage-event" class="internalDFN">usage event</a> had to occur during the associated activity. This is
illustrated by <a href="#ordering-activity" class="fig-ref">Figure 3</a> (b) and  expressed by <a class="rule-ref" href="#usage-within-activity"><span>Constraint 33 (usage-within-activity)</span></a>.</p>

<div class="constraint" id="usage-within-activity"><div class="ruleTitle"><a id="33"></a><a class="internalDFN" href="#usage-within-activity">Constraint 33 (usage-within-activity)</a></div>
<ol>
    <li>
  <span class="conditional">IF</span>
<span class="name">wasStartedBy(start; a,_e1,_a1,_t1,_attrs1)</span> 
 and
<span class="name">used(use; a,_e2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">use</span>.
  </li>
  <li>
  <span class="conditional">IF</span>
<span class="name">used(use; a,_e1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">use</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end</span>.
  </li>
  </ol>
</div>

<p>

</p><hr>


<p id="generation-within-activity_text">A generation implies ordering of <a title="instantaneous event" href="#dfn-event" class="internalDFN">events</a>, since the <a title="entity generation event" href="#dfn-generation-event" class="internalDFN">generation event</a> had to occur during the associated activity. This is
illustrated by <a href="#ordering-activity" class="fig-ref">Figure 3</a> (c) and  expressed by <a class="rule-ref" href="#generation-within-activity"><span>Constraint 34 (generation-within-activity)</span></a>.</p> 

<div class="constraint" id="generation-within-activity"><div class="ruleTitle"><a id="34"></a><a class="internalDFN" href="#generation-within-activity">Constraint 34 (generation-within-activity)</a></div>
   <ol>
    <li>
  <span class="conditional">IF</span>
<span class="name">wasStartedBy(start; a,_e1,_a1,_t1,_attrs1)</span> 
 and
<span class="name">wasGeneratedBy(gen; _e2,a,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">gen</span>.
  </li>
  <li>
  <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen; _e,a,_t,_attrs)</span> 
and
<span class="name">wasEndedBy(end; a,_e1,_a1,_t1,_attrs1)</span> 
<span class="conditional">THEN</span>
<span class="name">gen</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end</span>.
  </li>
  </ol>
</div> 

<p>

</p><hr>
<p id="wasInformedBy-ordering_text">
Communication between two activities <span class="name">a1</span>
and <span class="name">a2</span> also implies ordering
of <a title="instantaneous event" href="#dfn-event" class="internalDFN">events</a>, since some entity must
have been generated by the former and used by the latter, which
implies that the start event of <span class="name">a1</span> cannot
follow the end event of <span class="name">a2</span>. This is
illustrated by
<a href="#ordering-activity" class="fig-ref">Figure 3</a>
(d) and expressed by <a class="rule-ref" href="#wasInformedBy-ordering"><span>Constraint 35 (wasInformedBy-ordering)</span></a>.</p>

<div class="constraint" id="wasInformedBy-ordering"><div class="ruleTitle"><a id="35"></a><a class="internalDFN" href="#wasInformedBy-ordering">Constraint 35 (wasInformedBy-ordering)</a></div>
<p>
  <span class="conditional">IF</span>
<span class="name">wasInformedBy(_id; a2,a1,_attrs)</span> 
and
<span class="name">wasStartedBy(start; a1,_e1,_a1',_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end; a2,_e2,_a2',_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end</span>.
</p>
</div>
<p>

<!-- OLD; delete
<hr />

<p id='wasStartedByActivity-ordering_text'>Start
of <span class="name">a2</span> by
activity <span class="name">a1</span> also implies ordering
of <a title="instantaneous event">events</a>,
since <span class="name">a1</span> must have been active
before <span class="name">a2</span> started. This is illustrated by
<a href="#ordering-activity">Figure 3</a>
(e) and expressed by <a class="rule-ref"
href="#wasStartedByActivity-ordering"><span>TBD</span></a>.</p>


<div class='constraint' id='wasStartedByActivity-ordering'>
   <span class="conditional">IF</span>
<span class="name">wasStartedBy(start2; a2,-,a1,-)</span> 
and
<span class="name">wasStartedBy(start1; a1,-,-,-)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a>strictly precedes</a>
<span class="name">start2</span>.
</div>
-->

</p></section>

<section id="entity-constraints">
<h4><span class="secno">6.2.2 </span> Entity constraints</h4>


<!--
<div class="note">The figure(s) in this section should have vertical lines with visual styles that match the diagonal arrow that they go with. </div>
-->

<p>
As with activities, entities have lifetimes: they are generated, then
can be used, other entities can be derived from them, and finally they
can be invalidated. The constraints on these events are
illustrated graphically in <a href="#ordering-entity" class="fig-ref">Figure 4</a> and
<a href="#ordering-entity-trigger" class="fig-ref">Figure 5</a>.
</p>


  
<div style="text-align: center;">
<span class="figure" id="ordering-entity">
<img src="images/constraints/ordering-entity.png" alt="ordering constraints for entities">
<br>
<span class="figcaption" id="ordering-entity-fig">Figure 4<sup><a class="internalDFN" href="#ordering-entity-fig"><span class="diamond"> ◊:</span></a></sup> Summary of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> ordering constraints for entities</span></span>  <!-- <b>Figure 4:</b>  -->
</div>

<p>

</p><hr>

<p id="generation-precedes-invalidation_text">
Generation of an entity precedes its invalidation. (This
follows from other constraints if the entity is used, but it is stated
explicitly here to cover the case of an entity that is generated and
invalidated without being used.)</p>

<div class="constraint" id="generation-precedes-invalidation"><div class="ruleTitle"><a id="36"></a><a class="internalDFN" href="#generation-precedes-invalidation">Constraint 36 (generation-precedes-invalidation)</a></div>
<p>
 <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen; e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv</span>. 
</p>
</div>




<hr>

<p id="generation-precedes-usage_text"> 
A usage and a generation for a given entity implies ordering of <a title="instantaneous event" href="#dfn-event" class="internalDFN">events</a>, since the <a title="entity generation
event" href="#dfn-generation-event" class="internalDFN">generation event</a> had to precede the <a title="entity usage event" href="#dfn-usage-event" class="internalDFN">usage event</a>. This is
illustrated by <a href="#ordering-entity" class="fig-ref">Figure 4</a>(a) and  expressed by <a class="rule-ref" href="#generation-precedes-usage"><span>Constraint 37 (generation-precedes-usage)</span></a>.</p>

<div class="constraint" id="generation-precedes-usage"><div class="ruleTitle"><a id="37"></a><a class="internalDFN" href="#generation-precedes-usage">Constraint 37 (generation-precedes-usage)</a></div>
<p>  <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen; e,_a1,_t1,_attrs1)</span> 
and
<span class="name">used(use; _a2,e,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">use</span>.  
</p>
</div>


<hr>

<p id="usage-precedes-invalidation_text">All usages of an entity precede its invalidation, which is captured by <a class="rule-ref" href="#usage-precedes-invalidation"><span>Constraint 38 (usage-precedes-invalidation)</span></a> (without any explicit graphical representation).</p> 

<div class="constraint" id="usage-precedes-invalidation"><div class="ruleTitle"><a id="38"></a><a class="internalDFN" href="#usage-precedes-invalidation">Constraint 38 (usage-precedes-invalidation)</a></div>
<p>
<span class="conditional">IF</span>
<span class="name">used(use; _a1,e,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">use</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv</span>.</p>
</div>


<hr>

<p id="generation-generation-ordering_text">
If an entity is generated by more than one activity, the events must all
be simultaneous.  The following constraint requires that if there are two generation
events that generate the same entity, then one <a href="#dfn-precedes" class="internalDFN">precedes</a> the
other.  Using this constraint in both directions means that each event
<a href="#dfn-precedes" class="internalDFN">precedes</a> the other.
</p>
<div class="constraint" id="generation-generation-ordering"><div class="ruleTitle"><a id="39"></a><a class="internalDFN" href="#generation-generation-ordering">Constraint 39 (generation-generation-ordering)</a></div>
 <p>
    <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen1; e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasGeneratedBy(gen2; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">gen2</span>.
  </p>
</div>

<hr>

<p id="invalidation-invalidation-ordering_text">
If an entity is invalidated by more than one activity, the events must all
be simultaneous.  The following constraint requires that if there are two invalidation
events that invalidate the same entity, then one <a href="#dfn-precedes" class="internalDFN">precedes</a> the
other.  Using this constraint in both directions means that each event
<a href="#dfn-precedes" class="internalDFN">precedes</a> the other, that is, they are simultaneous.
</p>
<div class="constraint" id="invalidation-invalidation-ordering"><div class="ruleTitle"><a id="40"></a><a class="internalDFN" href="#invalidation-invalidation-ordering">Constraint 40 (invalidation-invalidation-ordering)</a></div>
 <p>
    <span class="conditional">IF</span>
<span class="name">wasInvalidatedBy(inv1; e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv2; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">inv1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv2</span>.
  </p>
</div>



<p id="derivation-usage-generation-ordering_text">If there is a
derivation relationship linking <span class="name">e2</span> and <span class="name">e1</span>, then 
this means that the entity <span class="name">e1</span> had some influence on the entity <span class="name">e2</span>; for this to be possible, some event ordering must be satisfied.
First, we consider derivations, where the activity and usage are known. In that case, the <a title="entity usage event" href="#dfn-usage-event" class="internalDFN">usage</a> of <span class="name">e1</span> has to precede the <a title="entity generation
event" href="#dfn-generation-event" class="internalDFN">generation</a> of <span class="name">e2</span>.
This is
illustrated by <a href="#ordering-entity-fig">Figure 4</a> (b) and  expressed by  <a class="rule-ref" href="#derivation-usage-generation-ordering"><span>Constraint 41 (derivation-usage-generation-ordering)</span></a>.</p>


<div class="constraint" id="derivation-usage-generation-ordering"><div class="ruleTitle"><a id="41"></a><a class="internalDFN" href="#derivation-usage-generation-ordering">Constraint 41 (derivation-usage-generation-ordering)</a></div>
  <p>
  In this constraint, <span class="name">_a</span>, <span class="name">gen2</span>, <span class="name">use1</span> <em class="rfc2119" title="MUST NOT">MUST NOT</em> be placeholders.</p>
<p>
      <span class="conditional">IF</span>
<span class="name">wasDerivedFrom(_d; _e2,_e1,_a,gen2,use1,_attrs)</span> 
<span class="conditional">THEN</span>
<span class="name">use1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">gen2</span>.  
</p>
</div>
<p>
</p><hr>

<p id="derivation-generation-generation-ordering_text">
When the activity, generation or usage is unknown, a similar constraint exists, except that the constraint refers to its
generation event, as
illustrated by <a href="#ordering-entity-fig">Figure 4</a> (c) and  expressed by <a class="rule-ref" href="#derivation-generation-generation-ordering"><span>Constraint 42 (derivation-generation-generation-ordering)</span></a>.</p>

<div class="constraint" id="derivation-generation-generation-ordering"><div class="ruleTitle"><a id="42"></a><a class="internalDFN" href="#derivation-generation-generation-ordering">Constraint 42 (derivation-generation-generation-ordering)</a></div>
  <p>
In this constraint, any of <span class="name">_a</span>, <span class="name">_g</span>, <span class="name">_u</span> <em class="rfc2119" title="MAY">MAY</em> be placeholders.</p>
<p>
 <span class="conditional">IF</span>
<span class="name">wasDerivedFrom(_d; e2,e1,_a,_g,_u,attrs)</span>
  and
<span class="name">wasGeneratedBy(gen1; e1,_a1,_t1,_attrs1)</span>
  and
<span class="name">wasGeneratedBy(gen2; e2,_a2,_t2,_attrs2)</span>
<span class="conditional">THEN</span>
<span class="name">gen1</span> 
<a href="#dfn-strictly-precedes" class="internalDFN">strictly precedes</a>
<span class="name">gen2</span>.  
</p>
  </div>

<div class="remark">
  <p>This constraint requires the derived
    entity to be generated strictly following the generation of the
    original entity. This follows from the [<cite><a class="bibref" href="#bib-PROV-DM">PROV-DM</a></cite>] definition of
    derivation: <em>A derivation is a transformation of an entity into
    another, an update of an entity resulting in a new one, or the
    construction of a new entity based on a pre-existing entity</em>, thus
    the derived entity must be newer than the original entity.</p>
  <p>The event ordering is between generations of <span class="name">e1</span>
and <span class="name">e2</span>, as opposed to derivation where usage is known,
which implies ordering between the usage of <span class="name">e1</span> and
generation of <span class="name">e2</span>.  </p>
</div>

<hr>

<p id="wasStartedBy-ordering_text">
The entity that triggered the start of an activity must exist before the activity starts.
This is
illustrated by <a href="#ordering-entity-trigger" class="fig-ref">Figure 5</a>(a) and  expressed by <a class="rule-ref" href="#wasStartedBy-ordering"><span>Constraint 43 (wasStartedBy-ordering)</span></a>.</p>


<div class="constraint" id="wasStartedBy-ordering"><div class="ruleTitle"><a id="43"></a><a class="internalDFN" href="#wasStartedBy-ordering">Constraint 43 (wasStartedBy-ordering)</a></div>
 <ol>
    <li>
    <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen; e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasStartedBy(start; _a,e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">start</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasStartedBy(start; _a,e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv</span>.
  </li>
  </ol>
</div>

<hr>

<p id="wasEndedBy-ordering_text"> Similarly, the entity that triggered
the end of an activity must exist before the activity ends, as
illustrated by
<a href="#ordering-entity-trigger" class="fig-ref">Figure 5</a>(b).</p>


<div class="constraint" id="wasEndedBy-ordering"><div class="ruleTitle"><a id="44"></a><a class="internalDFN" href="#wasEndedBy-ordering">Constraint 44 (wasEndedBy-ordering)</a></div>
 <ol>
      <li>
    <span class="conditional">IF</span>
<span class="name">wasGeneratedBy(gen; e,_a1,_t1,_attrs1)</span> 
and
   <span class="name">wasEndedBy(end; _a,e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasEndedBy(end; _a,e,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">end</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv</span>.
  </li>
  </ol>
</div>

<div style="text-align: center; ">
<span class="figure" id="ordering-entity-trigger">
<img src="images/constraints/ordering-entity-trigger.png" alt="ordering constraints for trigger entities">
<br>
<span class="figcaption" id="ordering-entity-trigger-fig">Figure 5<sup><a class="internalDFN" href="#ordering-entity-trigger-fig"><span class="diamond"> ◊:</span></a></sup> Summary of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> ordering constraints for trigger entities</span>  <!-- <b>Figure 5:</b> -->
</span>
</div>

<hr>
<p id="specialization-generation-ordering_text">
If an entity is a specialization of another, then the more
specific entity must have been generated after the
less specific entity was generated.
</p>
<div class="constraint" id="specialization-generation-ordering"><div class="ruleTitle"><a id="45"></a><a class="internalDFN" href="#specialization-generation-ordering">Constraint 45 (specialization-generation-ordering)</a></div>
  <p>
<span class="conditional">IF</span> <span class="name">specializationOf(e2,e1)</span> and <span class="name">wasGeneratedBy(gen1; e1,_a1,_t1,_attrs1)</span> and
  <span class="name">wasGeneratedBy(gen2; e2,_a2,_t2,_attrs2)</span>
  <span class="conditional">THEN</span> <span class="name">gen1</span> <a href="#dfn-precedes" class="internalDFN">precedes</a> <span class="name">gen2</span>.  
</p></div>

<p>

</p><hr>
<p id="specialization-invalidation-ordering_text">
Similarly, if an entity is a specialization of another entity, and
then
the invalidation event of the more specific entity precedes that of
the less specific entity.
</p><div class="constraint" id="specialization-invalidation-ordering"><div class="ruleTitle"><a id="46"></a><a class="internalDFN" href="#specialization-invalidation-ordering">Constraint 46 (specialization-invalidation-ordering)</a></div>
  <p>
<span class="conditional">IF</span> <span class="name">specializationOf(e1,e2)</span> and
 <span class="name">wasInvalidatedBy(inv1; e1,_a1,_t1,_attrs1)</span> and 
 <span class="name">wasInvalidatedBy(inv2; e2,_a2,_t2,_attrs2)</span>
  <span class="conditional">THEN</span> <span class="name">inv1</span> <a href="#dfn-precedes" class="internalDFN">precedes</a> <span class="name">inv2</span>.
</p>
  </div>

</section>

<section id="agent-constraints">
<h4><span class="secno">6.2.3 </span> Agent constraints</h4>

<p> Like entities and activities, agents have lifetimes that follow a
familiar pattern.  An agent that is also an entity can be generated
and invalidated; an agent that is also an activity can be started or
ended.  During its lifetime, an agent can participate in interactions
such as starting or ending other activities, association with an
activity, attribution, or delegation.
  
</p> <p>Further constraints associated with agents appear in <a href="#ordering-agents">Figure 6</a> and are discussed below.</p>

<div style="text-align: center;">
<span class="figure" id="ordering-agents-fig">
<img src="images/constraints/ordering-agents.png" alt="ordering constraints for agents">
<br>
<span class="figcaption" id="ordering-agents">Figure 6<sup><a class="internalDFN" href="#ordering-agents"><span class="diamond"> ◊:</span></a></sup> Summary of <a title="instantaneous event" href="#dfn-event" class="internalDFN">instantaneous event</a> ordering
  constraints for agents</span> <!--<b>Figure 6:</b> -->
</span>
</div>

<hr>


<p id="wasAssociatedWith-ordering_text">An activity that was
associated with an agent must have some overlap with the agent. The
agent <em class="rfc2119" title="MUST">MUST</em> have been generated (or started), or <em class="rfc2119" title="MUST">MUST</em> have become
associated with the activity, after the activity start: so, the agent <em class="rfc2119" title="MUST">MUST</em> exist before the activity end. Likewise, the agent may be destructed (or ended), or may terminate its association with the activity, before the activity end: hence, the agent invalidation (or end) is required to happen after the activity start.
This is illustrated by <a href="#ordering-agents">Figure 6</a> (a) and  expressed by <a class="rule-ref" href="#wasAssociatedWith-ordering"><span>Constraint 47 (wasAssociatedWith-ordering)</span></a>.</p>



<div class="constraint" id="wasAssociatedWith-ordering"><div class="ruleTitle"><a id="47"></a><a class="internalDFN" href="#wasAssociatedWith-ordering">Constraint 47 (wasAssociatedWith-ordering)</a></div>
  <p>
In the following inferences, <span class="name">_pl</span> <em class="rfc2119" title="MAY">MAY</em> be
 a placeholder <span class="name">-</span>.
  </p><ol>    <li>
    <span class="conditional">IF</span>
<span class="name">wasAssociatedWith(_assoc; a,ag,_pl,_attrs)</span> 
and
<span class="name">wasStartedBy(start1; a,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv2; ag,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv2</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasAssociatedWith(_assoc; a,ag,_pl,_attrs)</span> 
and
<span class="name">wasGeneratedBy(gen1; ag,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end2; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end2</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasAssociatedWith(_assoc; a,ag,_pl,_attrs)</span> 
and
<span class="name">wasStartedBy(start1; a,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end2; ag,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end2</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasAssociatedWith(_assoc; a,ag,_pl,_attrs)</span> 
and
<span class="name">wasStartedBy(start1; ag,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end2; a,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end2</span>.
  </li>
  </ol>
</div>

<div class="remark"> <p> Case 3 of the above constraint says that the
agent <span class="name">ag</span> 
must have ended after the start of the activity <span class="name">a</span>,
ensuring some overlap between the two.   Since <span class="name">ag</span> is the subject of a
<span class="name">wasEndedBy</span> statement, it is an activity according to the <a href="#typing">typing constraints</a>.  Case 4 handles the symmetric
  case, ensuring that the start of an agent-activity precedes the
  start of an associated activity. </p> </div>

<p>

</p><hr>

<p id="wasAttributedTo-ordering_text">An agent to which an entity was attributed, <em class="rfc2119" title="MUST">MUST</em> exist before this entity was generated.
This is
illustrated by <a href="#ordering-agents">Figure 6</a> (b) and  expressed by  <a class="rule-ref" href="#wasAttributedTo-ordering"><span>Constraint 48 (wasAttributedTo-ordering)</span></a>.</p>



 
<div class="constraint" id="wasAttributedTo-ordering"><div class="ruleTitle"><a id="48"></a><a class="internalDFN" href="#wasAttributedTo-ordering">Constraint 48 (wasAttributedTo-ordering)</a></div>
      <ol> <li>
    <span class="conditional">IF</span>
<span class="name">wasAttributedTo(_at; e,ag,_attrs)</span> 
and
<span class="name">wasGeneratedBy(gen1; ag,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasGeneratedBy(gen2; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">gen2</span>.
  </li><li>
    <span class="conditional">IF</span>
<span class="name">wasAttributedTo(_at; e,ag,_attrs)</span> 
and
<span class="name">wasStartedBy(start1; ag,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasGeneratedBy(gen2; e,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">gen2</span>.
  </li>
  </ol>
</div>

<p>
</p><hr>

<p id="actedOnBehalfOf-ordering_text">For delegation, the responsible agent has to precede or have some overlap with the subordinate agent.</p>


<div class="constraint" id="actedOnBehalfOf-ordering"><div class="ruleTitle"><a id="49"></a><a class="internalDFN" href="#actedOnBehalfOf-ordering">Constraint 49 (actedOnBehalfOf-ordering)</a></div>
 <ol> <li>
	 <span class="conditional">IF</span>
<span class="name">actedOnBehalfOf(_del; ag2,ag1,_a,_attrs)</span> 
and
<span class="name">wasGeneratedBy(gen1; ag1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasInvalidatedBy(inv2; ag2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">gen1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">inv2</span>.
  </li><li>
	 <span class="conditional">IF</span>
<span class="name">actedOnBehalfOf(_del; ag2,ag1,_a,_attrs)</span> 
and
<span class="name">wasStartedBy(start1; ag1,_e1,_a1,_t1,_attrs1)</span> 
and
<span class="name">wasEndedBy(end2; ag2,_e2,_a2,_t2,_attrs2)</span> 
<span class="conditional">THEN</span>
<span class="name">start1</span> 
<a title="precedes" href="#dfn-precedes" class="internalDFN">precedes</a>
<span class="name">end2</span>.
  </li>
  </ol>

</div>

</section>

</section> <!--event-ordering-constraints--> 



<section id="type-constraints">
<h3><span class="secno">6.3 </span>Type Constraints</h3>

<p id="typing_text">The following rules assign types to identifiers
based on their use within statements. 
The function <span class="name">typeOf</span> gives the set of types denoted by an identifier.
That is,  <span class="name">typeOf(e)</span> returns the set of types
associated with identifier  <span class="name">e</span>. The function
<span class="name">typeOf</span> is not a PROV statement, but a
construct used only during validation, similar to <a href="#dfn-precedes" class="internalDFN">precedes</a>.
</p>




<p>
 For any identifier  <span class="name">id</span>,  <span class="name">typeOf(id)</span>  is a subset of {<span class="name">'entity'</span>, <span class="name">'activity'</span>, <span class="name">'agent'</span>, <span class="name">'prov:Collection'</span>, <span class="name">'prov:EmptyCollection'</span>}.
For identifiers that do not have a type,  <span class="name">typeOf</span> gives the empty set.
  Identifiers can have more than one type, because of subtyping
 (e.g. <span class="name">'prov:EmptyCollection'</span> is a subtype of <span class="name">'prov:Collection'</span>) or because certain types are not
 disjoint (such as <span class="name">'agent'</span> and <span class="name">'entity'</span>). The set of types
 does not reflect all of the distinctions among objects, only those
 relevant for checking validity.  In particular, a subtype such as <span class="name">'plan'</span> is omitted, and statements such as <span class="name">wasAssociatedWith</span> that have plan parameters only check that these parameters are entities.
</p>

<p>To check if a PROV instance satisfies type constraints, one obtains the types of identifiers by application of
<a class="rule-ref" href="#typing"><span>Constraint 50 (typing)</span></a>
and check that none of the impossibility constraints 
<a class="rule-ref" href="#entity-activity-disjoint"><span>Constraint 55 (entity-activity-disjoint)</span></a> and
<a class="rule-ref" href="#membership-empty-collection"><span>Constraint 56 (membership-empty-collection)</span></a> are
  violated as a result.</p>


<div class="constraint" id="typing"><div class="ruleTitle"><a id="50"></a><a class="internalDFN" href="#typing">Constraint 50 (typing)</a></div>


<ol>
<li>
<span class="conditional">IF</span> 
   <span class="name">entity(e,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e)</span>.
</li><li>
<span class="conditional">IF</span> 
   <span class="name">agent(ag,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'agent' ∈ typeOf(ag)</span>.
</li><li>
<span class="conditional">IF</span> 
   <span class="name">activity(a,t1,t2,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a)</span>.


</li><li>

<span class="conditional">IF</span> 
   <span class="name">used(u; a,e,t,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a)</span> AND
<span class="name">'entity' ∈ typeOf(e)</span>.

</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasGeneratedBy(gen; e,a,t,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e)</span> AND
<span class="name">'activity' ∈ typeOf(a)</span>.

</li><li>

<span class="conditional">IF</span> 
   <span class="name">wasInformedBy(id; a2,a1,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a2)</span> AND
<span class="name">'activity' ∈ typeOf(a1)</span>.

</li><li>

<span class="conditional">IF</span> 
   <span class="name">wasStartedBy(id; a2,e,a1,t,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a2)</span> AND
<span class="name">'entity' ∈ typeOf(e)</span> AND
<span class="name">'activity' ∈ typeOf(a1)</span>.



</li><li>


<span class="conditional">IF</span> 
   <span class="name">wasEndedBy(id; a2,e,a1,t,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a2)</span> AND
<span class="name">'entity' ∈ typeOf(e)</span> AND
<span class="name">'activity' ∈ typeOf(a1)</span>.



</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasInvalidatedBy(id; e,a,t,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e)</span> AND
<span class="name">'activity' ∈ typeOf(a)</span>.




</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasDerivedFrom(id;  e2, e1, a, g2, u1, attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e2)</span> AND
<span class="name">'entity' ∈ typeOf(e1)</span> AND
<span class="name">'activity' ∈ typeOf(a)</span>.
   In this constraint, <span class="name">a</span>, <span class="name">g2</span>, and <span class="name">u1</span> <em class="rfc2119" title="MUST NOT">MUST NOT</em> be placeholders.

</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasDerivedFrom(id;  e2, e1, -, -, -, attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e2)</span> AND
<span class="name">'entity' ∈ typeOf(e1)</span>.

</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasAttributedTo(id; e,ag,attr)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e)</span> AND
<span class="name">'agent' ∈ typeOf(ag)</span>.


</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasAssociatedWith(id; a,ag,pl,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a)</span> AND
<span class="name">'agent' ∈ typeOf(ag)</span> AND
<span class="name">'entity' ∈ typeOf(pl)</span>.  In this
constraint, <span class="name">pl</span> <em class="rfc2119" title="MUST NOT">MUST NOT</em> be a placeholder.

</li><li>
<span class="conditional">IF</span> 
   <span class="name">wasAssociatedWith(id; a,ag,-,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'activity' ∈ typeOf(a)</span> AND
<span class="name">'agent' ∈ typeOf(ag)</span>.




</li><li>
<span class="conditional">IF</span> 
   <span class="name">actedOnBehalfOf(id; ag2,ag1,a,attrs)</span>  
<span class="conditional">THEN</span> 
<span class="name">'agent' ∈ typeOf(ag2)</span> AND
<span class="name">'agent' ∈ typeOf(ag1)</span> AND
<span class="name">'activity' ∈ typeOf(a)</span>.




</li><li>
<span class="conditional">IF</span> 
   <span class="name">alternateOf(e2, e1)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e2)</span> AND
<span class="name">'entity' ∈ typeOf(e1)</span>.


</li><li>
<span class="conditional">IF</span> 
   <span class="name">specializationOf(e2, e1)</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(e2)</span> AND
<span class="name">'entity' ∈ typeOf(e1)</span>.


<!--
<li>
<span class='conditional'>IF</span> 
   <span class='name'>mentionOf(e2,e1,b)</span>  
<span class='conditional'>THEN</span> 
<span class="name">'entity' &isin; typeOf(e2)</span> AND
<span class="name">'entity' &isin; typeOf(e1)</span> AND
<span class="name">'entity' &isin; typeOf(b)</span>.
-->

</li><li>

<span class="conditional">IF</span> 
   <span class="name">hadMember(c,e)</span>  
<span class="conditional">THEN</span> 
<span class="name">'prov:Collection' ∈ typeOf(c)</span> AND
<span class="name">'entity' ∈ typeOf(c)</span> AND
<span class="name">'entity' ∈ typeOf(e)</span>.


</li><li>

<span class="conditional">IF</span> 
   <span class="name">entity(c,[prov:type='prov:EmptyCollection'])</span>  
<span class="conditional">THEN</span> 
<span class="name">'entity' ∈ typeOf(c)</span>  AND
<span class="name">'prov:Collection' ∈ typeOf(c)</span> AND
<span class="name">'prov:EmptyCollection' ∈ typeOf(c)</span>.

</li></ol>
</div>

</section> <!--type-constraints-->

<section id="impossibility-constraints">
<h3><span class="secno">6.4 </span>Impossibility constraints</h3>

<p> Impossibility constraints require that certain patterns of
statements never appear in <a href="#dfn-valid" class="internalDFN">valid</a> PROV instances.  Impossibility
constraints have the following general form:
</p>

<div class="constraint-example" id="impossible-example"><div class="ruleTitle"><a class="internalDFN" href="#impossible-example">Constraint-example NNN (impossible-example)</a></div>
  <p><span class="conditional">IF</span> <span class="name">hyp<sub>1</sub></span> and ... and  <span class="name">hyp<sub>n</sub></span> <span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</p>
  </div>

<p> Checking an impossibility constraint on instance <span class="math">I</span> means  checking whether there is
any way of matching the pattern <span class="name">hyp<sub>1</sub></span>, ..., <span class="name">hyp<sub>n</sub></span>.  If there
is, then checking the constraint on <span class="math">I</span> fails (which implies that
<span class="math">I</span> is invalid).


</p><hr>

<p id="impossible-unspecified-derivation-generation-use_text">
A derivation with unspecified activity <span class="name">wasDerivedFrom(id;e1,e2,-,g,u,attrs)</span> represents a derivation that
    takes one or more steps, whose activity, generation and use events
    are unspecified.  It is forbidden to specify a generation or use
    event without specifying the activity.</p>

        <div class="constraint" id="impossible-unspecified-derivation-generation-use"><div class="ruleTitle"><a id="51"></a><a class="internalDFN" href="#impossible-unspecified-derivation-generation-use">Constraint 51 (impossible-unspecified-derivation-generation-use)</a></div>
<p> In the following rules, <span class="name">g</span> and <span class="name">u</span> <em class="rfc2119" title="MUST NOT">MUST NOT</em> be <span class="name">-</span>.</p>
	  <ol>
  <li> <span class="conditional">IF</span>
	    <span class="name">wasDerivedFrom(_id;_e2,_e1,-,g,-,attrs)</span>
	    <span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</li>  <li> <span class="conditional">IF</span>
	    <span class="name">wasDerivedFrom(_id;_e2,_e1,-,-,u,attrs)</span>
	    <span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</li>
	      <li> <span class="conditional">IF</span>
	    <span class="name">wasDerivedFrom(_id;_e2,_e1,-,g,u,attrs)</span>
	    <span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</li>
	    </ol>
    </div>   
<hr>

<p id="impossible-specialization-reflexive_text">As noted previously, specialization is a
    <a href="#dfn-strict-partial-order" class="internalDFN">strict partial order</a>: it is <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a> and
    <a href="#dfn-transitive" class="internalDFN">transitive</a>.</p>

        <div class="constraint" id="impossible-specialization-reflexive"><div class="ruleTitle"><a id="52"></a><a class="internalDFN" href="#impossible-specialization-reflexive">Constraint 52 (impossible-specialization-reflexive)</a></div>
<!--<p>
    For any entity <span class='name'>e</span>, it is not the case that
<span class='name'>specializationOf(e,e)</span> holds.</p>-->
	  <p> <span class="conditional">IF</span> <span class="name">specializationOf(e,e)</span> <span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</p>
    </div>


    <!--
<hr>
<div class="note"> This is also a constraint, but follows from
  irreflexivity and transitivity so it may be omitted.</div>

    <p id="specialization-asymmetric_text"/>

<div class='constraint' id="impossible-specialization-symmetric">
<p>  For any
    entities <span class='name'>e1</span>, <span
  class='name'>e2</span>,
it is not the case that 
  <span class='name'>specializationOf(e1,e2)</span>
    and
	 <span class='name'>specializationOf(e2,e1)</span>.</p>
</div> 
-->


  <hr>


   <p id="impossible-property-overlap_text"> Furthermore,  identifiers
   of basic relationships are disjoint.
  </p>
  <div class="constraint" id="impossible-property-overlap"><div class="ruleTitle"><a id="53"></a><a class="internalDFN" href="#impossible-property-overlap">Constraint 53 (impossible-property-overlap)</a></div>
  <p>
For each <span class="name">r</span> and <span class="name">s</span>
   in { 
<span class="name">used</span>,
<span class="name">wasGeneratedBy</span>,
<span class="name">wasInvalidatedBy</span>,
<span class="name">wasStartedBy</span>,
<span class="name">wasEndedBy</span>,
<span class="name">wasInformedBy</span>,
<span class="name">wasAttributedTo</span>,
<span class="name">wasAssociatedWith</span>,
<span class="name">actedOnBehalfOf</span>} such that <span class="name">r</span> and <span class="name">s</span>
   are different relation names, the
  following constraint holds:
</p>
    <p>
    <span class="conditional">IF</span> <span class="name">r(id; a<sub>1</sub>,...,a<sub>m</sub>)</span> and <span class="name">s(id; b<sub>1</sub>,...,b<sub>n</sub>)</span> <span class="conditional">THEN INVALID</span>.
  </p>
  </div>

  <div class="remark">
    <p>Since <span class="name">wasInfluencedBy</span> is a superproperty of many other
    properties, it is excluded from the set of properties whose
    identifiers are required to be pairwise disjoint.  The following
    example illustrates this observation:
    </p><pre>wasInfluencedBy(id;e2,e1)
wasDerivedFrom(id;e2,e1)
</pre>
<p>    This satisfies the disjointness constraint.
    </p>
    <p>There is, however, no
    constraint requiring that every influence relationship is
    accompanied by a more specific relationship having the same
    identifier.  The following valid example illustrates this observation:
    </p><pre>wasInfluencedBy(id; e2,e1)
</pre>
<p>    This is valid; there is no inferrable information about what kind
    of influence relates <span class="name">e2</span> and <span class="name">e1</span>, other than its identity.
    </p>
  </div>

   <p id="impossible-object-property-overlap_text"> Identifiers of entities,
  agents and activities cannot also be identifiers of properties.
  </p>
  <div class="constraint" id="impossible-object-property-overlap"><div class="ruleTitle"><a id="54"></a><a class="internalDFN" href="#impossible-object-property-overlap">Constraint 54 (impossible-object-property-overlap)</a></div>
  <p>
For each <span class="name">p</span> in {<span class="name">entity</span>, <span class="name">activity</span>
   or <span class="name">agent</span>} and for each  <span class="name">r</span> in { 
<span class="name">used</span>,
<span class="name">wasGeneratedBy</span>,
<span class="name">wasInvalidatedBy</span>,
<span class="name">wasInfluencedBy</span>,
<span class="name">wasStartedBy</span>,
<span class="name">wasEndedBy</span>,
<span class="name">wasInformedBy</span>,
<span class="name">wasDerivedFrom</span>,
<span class="name">wasAttributedTo</span>,
<span class="name">wasAssociatedWith</span>,
<span class="name">actedOnBehalfOf</span>}, the following
  impossibility constraint holds:</p>

<p>    <span class="conditional">IF</span> <span class="name">p(id,a<sub>1</sub>,...,a<sub>m</sub>)</span> and
  <span class="name">r(id; b<sub>1</sub>,...,b<sub>n</sub>)</span> <span class="conditional">THEN INVALID</span>.
  </p>
  </div>

  


   <hr>
   <p id="entity-activity-disjoint_text">   The set of entities and activities are disjoint, expressed by 
  the following constraint:
  </p>
  <div class="constraint" id="entity-activity-disjoint"><div class="ruleTitle"><a id="55"></a><a class="internalDFN" href="#entity-activity-disjoint">Constraint 55 (entity-activity-disjoint)</a></div>
<!--    <p>It is not the case that <span  class="name">entity(id,_attrs1)</span> and
<span  class="name">activity(id,_t1,_t2,_attrs2)</span>.
</p>-->
    
<p>
 <span class="conditional">IF</span>
<span class="name">'entity' ∈ typeOf(id)</span>  AND
<span class="name">'activity' ∈ typeOf(id)</span>
<span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</p>
 </div>
	<div class="remark">
	There is no disjointness between entities and agents. This is because one might want to make statements about the provenance of an agent, by making it an entity. 
	For example, one can assert both <span class="name">entity(a1)</span> and <span class="name">agent(a1)</span> in a valid PROV instance.
	  Similarly, there is no disjointness between activities and
 agents, and one can assert both <span class="name">activity(a1)</span> and <span class="name">agent(a1)</span> in a valid PROV instance. 
 However, one should keep in mind that some specific types of agents may not be suitable as activities. 
 For example, asserting statements such as <span class="name">agent(Bob, [type=prov:Person])</span> and <span class="name">activity(Bob)</span> is discouraged. In these cases, disjointness can be ensured by explicitly asserting the agent as both agent and entity, and applying <a class="rule-ref" href="#entity-activity-disjoint"><span>Constraint 55 (entity-activity-disjoint)</span></a>.
  </div>


   <hr>
   <p id="membership-empty-collection_text"> An empty collection cannot contain any member, expressed by
  the following constraint:
  </p>
  <div class="constraint" id="membership-empty-collection"><div class="ruleTitle"><a id="56"></a><a class="internalDFN" href="#membership-empty-collection">Constraint 56 (membership-empty-collection)</a></div>
<p> <span class="conditional">IF</span> 
 <span class="name">hadMember(c,e)</span> and
<span class="name">'prov:EmptyCollection' ∈ typeOf(c)</span>
<span class="conditional">THEN</span> <span class="conditional">INVALID</span>.</p>
  </div>


 
</section> <!--impossibility-constraints -->


</section> <!-- constraints -->

  <section id="normalization-validity-equivalence">
<!--OddPage--><h2><span class="secno">7. </span>Normalization, Validity, and Equivalence</h2>


  <p>We define the notions of <a title="normal form" href="#dfn-normal-form" class="internalDFN">normalization</a>, <a title="valid" href="#dfn-valid" class="internalDFN">validity</a> and
<a title="equivalence">equivalence</a> of PROV documents and instances.  We first define these concepts
for PROV instances and then extend them to PROV documents.</p>

<div class="remark">
  Implementations should expand
  namespace prefixes and  perform any appropriate reasoning about
  co-reference of identifiers, and rewrite the instance (by
  replacing co-referent identifiers with a single common identifier) to
  make this explicit, before doing validation, equivalence checking,
  or normalization.
  All of the following definitions assume that the application has
  already determined which URIs in the PROV instance are co-referent
  (e.g. <span class="name">owl:sameAs</span> as a result of OWL
  reasoning).
  </div>

  <section id="instances">
  <h3><span class="secno">7.1 </span>Instances</h3>
  

<p> We define the <dfn id="dfn-normal-form">normal form</dfn> of a PROV instance as the set
of provenance statements resulting from applying all definitions,
  inferences, and uniqueness constraints, obtained as follows:</p>



  <ol>
    <li>
    Apply all definitions to <span class="math">I</span> by replacing each defined statement by its
    definition (possibly introducing fresh existential variables in
    the process), yielding an instance <span class="math">I<sub>1</sub></span>.
    </li>
  <li>
    Apply all inferences to <span class="math">I<sub>1</sub></span> by adding the conclusion of each inference
    whose hypotheses are satisfied and whose entire conclusion does not
    already hold (again, possibly introducing fresh existential
    variables), yielding an instance <span class="math">I<sub>2</sub></span>.
    </li>
  <li>
    Apply all uniqueness constraints to <span class="math">I<sub>2</sub></span> by unifying terms or merging statements
    and applying the resulting substitution to the instance, yielding
    an instance <span class="math">I<sub>3</sub></span>.  If some uniqueness constraint cannot be
    applied, then normalization fails.
    </li>
    <li>If no definitions, inferences, or uniqueness constraints can be applied to instance <span class="math">I<sub>3</sub></span>, then <span class="math">I<sub>3</sub></span> is the
    normal form of <span class="math">I</span>.</li>
    <li>Otherwise, the normal form of <span class="math">I</span> is the same as the normal form
    of <span class="math">I<sub>3</sub></span> (that is, proceed by
    normalizing <span class="math">I<sub>3</sub></span> at step 1).
 </li></ol>
 
<p>Because of the potential interaction among definitions, inferences, and
  constraints, the above algorithm is iterative.  Nevertheless,
  all of our constraints fall into a class of <em>tuple-generating
  dependencies</em> and <em>equality-generating dependencies</em> that
  satisfy a termination condition called <em>weak acyclicity</em> that
  has been studied in the context of relational databases
  [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>].  Therefore, the above algorithm terminates, independently
  of the order in which inferences and constraints are applied.
  <a href="#termination">Appendix A</a> gives a proof that normalization terminates and produces
  a unique (up to isomorphism) normal form.
</p>
  
 <p>
 A PROV instance is <dfn id="dfn-valid">valid</dfn>
if its normal form exists and all of
  the validity constraints succeed on the normal form.
  The following algorithm can be used to test
  validity:</p>

<ol>
  <li>Normalize the instance <span class="math">I</span>, obtaining
  normal form <span class="math">I'</span>.  If
  normalization fails, then <span class="math">I</span> is not <a href="#dfn-valid" class="internalDFN">valid</a>.
  </li>
  <li>Apply all event ordering constraints to <span class="math">I'</span> to build a graph <span class="math">G</span> whose nodes
  are event identifiers and edges
  are labeled by "precedes" 
  and "strictly precedes" relationships among events induced by the constraints.</li>
  <li> Determine whether there is a cycle in <span class="math">G</span> that contains a
  "strictly precedes" edge.  If so, then <span class="math">I</span> is not <a href="#dfn-valid" class="internalDFN">valid</a>.  
  </li>
  <li>Apply the type constraints <a href="#type-constraints">(section
  5.3)</a> to determine whether there are any violations of
  disjointness.  If so, then <span class="math">I</span> is not <a href="#dfn-valid" class="internalDFN">valid</a>.  
  </li><li>
  Check that none of the impossibility constraints <a href="#impossibility-constraints">(section 5.4)</a>  are
  violated.  If any are violated, then <span class="math">I</span> is
  not <a href="#dfn-valid" class="internalDFN">valid</a>.  Otherwise, <span class="math">I</span> is <a href="#dfn-valid" class="internalDFN">valid</a>.
  </li>
  </ol>

<p>A normal form of a PROV instance does not exist when a uniqueness
  constraint fails due to unification or merging failure. </p>



<p>  Two <a href="#dfn-valid" class="internalDFN">valid</a> PROV instances are <dfn title="equivalent" id="dfn-equivalent">equivalent</dfn> if they
  have <a href="#dfn-isomorphic" class="internalDFN">isomorphic</a> normal forms.  That is, after applying all possible inference
rules, the two instances produce the same set of PROV statements,
up to reordering of statements and attributes within attribute lists,
  and renaming of existential variables.  
</p>
  <p>Equivalence can also be checked over pairs of PROV instances that
  are not necessarily valid, subject to the following rules:
  </p><ul>
    <li>If both are valid, then equivalence is
  defined above.</li>
    <li>If both are invalid, then equivalence can be
  implemented in any way provided it is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>, <a href="#dfn-symmetric" class="internalDFN">symmetric</a>, and <a href="#dfn-transitive" class="internalDFN">transitive</a>.
  </li>
  <li>If one instance is valid and the other is invalid, then the two
  instances are not equivalent.</li>
  </ul>
  <p>
Equivalence has the following characteristics over valid instances: </p>

<ul>
  <li>
  The order of provenance statements is irrelevant to the meaning of
  a PROV instance.  That is, a
  PROV instance is equivalent to any other instance obtained by
reordering its statements.
  </li>
  <li>The order of attribute-value pairs in attribute lists is
  irrelevant to the meaning of a PROV statement.  That is, a PROV
  statement carrying attributes is equivalent to any other statement
  obtained by reordering attribute-value pairs and eliminating
  duplicate pairs.
  </li>
  <li>The particular choices of names of existential variables are irrelevant to the meaning
  of an instance; that is, the names can be renamed without changing
  the meaning, as long as different names are always replaced with
  different names.  (Replacing two different names with equal names,
  however, can
  change the meaning, so does not preserve equivalence.)</li>
  <li>
  Applying inference rules, definitions, and uniqueness constraints preserves equivalence.  That is, a <a href="#instance" class="internalDFN">PROV
  instance</a> is equivalent to the instance obtained by applying any
  inference rule or definition, or by <a title="unification" href="#dfn-unification" class="internalDFN">unifying</a> two terms or <a href="#dfn-merging" class="internalDFN">merging</a> two statements to
  enforce a uniqueness constraint.
  </li>
  <li>Equivalence is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>, <a href="#dfn-symmetric" class="internalDFN">symmetric</a>, and
  <a href="#dfn-transitive" class="internalDFN">transitive</a>.  (This is because a valid instance has a unique
  normal form up to isomorphism [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>]). </li>
</ul>

<p> An application that processes PROV data <em class="rfc2119" title="SHOULD">SHOULD</em> handle
equivalent instances in the same way.  This guideline is necessarily
imprecise because "in the same way" is application-specific.
Common exceptions to this guideline
include, for example, applications that pretty-print or digitally sign
provenance, where the order and syntactic form of statements matters.  </p>

</section>

<section id="bundle-constraints">
<h3><span class="secno">7.2 </span>Bundles and Documents</h3>


<p>The definitions, inferences, and constraints, and
the resulting notions of normalization, validity and equivalence,
work on a single PROV instance.  In this
section, we describe how to deal with general PROV
documents, possibly including multiple named <a title="bundle" href="#dfn-bundle" class="internalDFN">bundles</a> as well as a
<a href="#dfn-toplevel-instance" class="internalDFN">toplevel instance</a>.  Briefly, each bundle is
handled independently; there is no interaction between bundles from
the perspective of applying definitions, inferences, or constraints,
computing normal forms, or checking validity or equivalence.</p>

<p> We model a general PROV document, containing <span class="name">n</span> named bundles
<span class="name">b<sub>1</sub>...b<sub>n</sub></span>, as a tuple
<span class="name">(I<sub>0</sub>,[b<sub>1</sub>=I<sub>1</sub>,...,b<sub>n</sub>=I<sub>n</sub>])</span>
where <span class="name">I<sub>0</sub></span> is the toplevel
instance, and for each <span class="name">i</span>, <span class="name">I<sub>i</sub></span> is the instance associated with
bundle <span class="name">b<sub>i</sub></span>.   This notation is shorthand for the
following PROV-N syntax:</p>

<div class="name">
document<br>
&nbsp;&nbsp;&nbsp;I<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;bundle b<sub>1</sub><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I<sub>1</sub><br>
&nbsp;&nbsp;&nbsp;endBundle<br>
&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;bundle b<sub>n</sub><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I<sub>n</sub><br>
&nbsp;&nbsp;&nbsp;endBundle<br>
endDocument
</div>

<p> The <a href="#dfn-normal-form" class="internalDFN">normal form</a> of a PROV document
<span class="name">(I<sub>0</sub>,[b<sub>1</sub>=I<sub>1</sub>,...,[b<sub>n</sub>=I<sub>n</sub>])</span> is <span class="name">(I'<sub>0</sub>,[b<sub>1</sub>=I'<sub>1</sub>,...,b<sub>n</sub>=I'<sub>n</sub>])</span>
where <span class="name">I'<sub>i</sub></span> is the normal
form of <span class="name">I<sub>i</sub></span> for each <span class="name">i</span> between 0 and <span class="name">n</span>.  </p>

<p>A PROV document is <a href="#dfn-valid" class="internalDFN">valid</a> if each of the bundles <span class="name">I<sub>0</sub></span>,
..., <span class="name">I<sub>n</sub></span> are valid and none of the bundle identifiers <span class="name">b<sub>i</sub></span> are repeated.</p>

<p>Two (valid) PROV documents <span class="name">(I<sub>0</sub>,[b<sub>1</sub>=I<sub>1</sub>,...,b<sub>n</sub>=I<sub>n</sub>])</span> and
<span class="name">(I'<sub>0</sub>,[b<sub>1</sub>'=I'<sub>1</sub>,...,b'<sub>m</sub>=I'<sub>m</sub>])</span> are <a href="#dfn-equivalent" class="internalDFN">equivalent</a> if <span class="name">I<sub>0</sub></span> is
equivalent to <span class="name">I'<sub>0</sub></span> and <span class="name">n = m</span> and
there exists a permutation <span class="name">P : {1..n} -&gt; {1..n}</span> such that for each <span class="name">i</span>, <span class="name">b<sub>i</sub> =
b'<sub>P(i)</sub></span> and <span class="name">I<sub>i</sub></span> is equivalent to <span class="name">I'<sub>P(i)</sub></span>.
</p>

</section> <!-- bundle-constraints-->


</section> <!-- normalization, validity, and equivalence -->











<section class="glossary" id="glossary"> 
      <!--OddPage--><h2><span class="secno">8. </span>Glossary</h2>

      <ul> 
       <li> <dfn id="dfn-antisymmetric">antisymmetric</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-antisymmetric" class="internalDFN">antisymmetric</a> if
      for any elements <span class="math">x</span>, <span class="math">y</span> of <span class="math">X</span>, if <span class="math">x R y</span> and <span class="math">y R x</span> then <span class="math">x = y</span>.</li>
       <li> <dfn id="dfn-asymmetric">asymmetric</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-asymmetric" class="internalDFN">asymmetric</a> if
      <span class="math">x R y</span> and <span class="math">y R x</span> do not hold for any elements <span class="math">x</span>, <span class="math">y</span> of <span class="math">X</span>.</li>
        <li><dfn id="dfn-equivalence-relation">equivalence relation</dfn>: An equivalence relation is a relation
      that is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>, <a href="#dfn-symmetric" class="internalDFN">symmetric</a>, and
       <a href="#dfn-transitive" class="internalDFN">transitive</a>.</li>
       <li> <dfn id="dfn-irreflexive">irreflexive</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a> if
      for <span class="math">x R x</span> does not hold for any element <span class="math">x</span> of <span class="math">X</span>.</li>
     <li><dfn id="dfn-partial-order">partial order</dfn>: A partial order is a relation
      that is <a href="#dfn-reflexive" class="internalDFN">reflexive</a>, <a href="#dfn-antisymmetric" class="internalDFN">antisymmetric</a>, and <a href="#dfn-transitive" class="internalDFN">transitive</a>.</li>
      <li><dfn id="dfn-preorder">preorder</dfn>: A preorder is a relation that is
      <a href="#dfn-reflexive" class="internalDFN">reflexive</a> and <a href="#dfn-transitive" class="internalDFN">transitive</a>.  (It is not necessarily antisymmetric,
      meaning there can be cycles of distinct elements <span class="math">x<sub>1</sub> R x<sub>2</sub> R ... R
      x<sub>n</sub> R x<sub>1</sub>.</span></li>
        <li> <dfn id="dfn-reflexive">reflexive</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-reflexive" class="internalDFN">reflexive</a> if
      for any element <span class="math">x</span> of <span class="math">X</span>, we have <span class="math">x R x</span>.</li>
    <li><dfn id="dfn-strict-partial-order">strict partial order</dfn>: A strict partial order is a
      relation that is <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a>, <a href="#dfn-asymmetric" class="internalDFN">asymmetric</a> and <a href="#dfn-transitive" class="internalDFN">transitive</a>.</li>
      <li><dfn id="dfn-strict-preorder">strict preorder</dfn>: A strict preorder is a relation
      that is <a href="#dfn-irreflexive" class="internalDFN">irreflexive</a> and <a href="#dfn-transitive" class="internalDFN">transitive</a>.</li>
       <li> <dfn id="dfn-symmetric">symmetric</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-symmetric" class="internalDFN">symmetric</a> if
      for any elements <span class="math">x</span>, <span class="math">y</span> of <span class="math">X</span>, if <span class="math">x R y</span> then <span class="math">y R x</span>.</li>
        <li> <dfn id="dfn-transitive">transitive</dfn>: A relation <span class="math">R</span> over <span class="math">X</span> is <a href="#dfn-transitive" class="internalDFN">transitive</a> if
      for any elements <span class="math">x</span>, <span class="math">y</span>, <span class="math">z</span> of <span class="math">X</span>, if <span class="math">x R y</span> and <span class="math">y R z</span> then <span class="math">x R z</span>.</li>
     
     
      </ul> 
    </section> 


      <section class="appendix informative" id="termination">
      <!--OddPage--><h2><span class="secno">A. </span>Termination of normalization</h2><p><em>This section is non-normative.</em></p>

      <p>
      We will show that normalization terminates, that is, that
      applying definitions, inferences and uniqueness/key constraints
      eventually either fails (due to constraint violation) or
      terminates with a normal form.
      </p>
      <p>
      First, since the inferences and constraints never introduce new
      defined statements, for the purpose of termination we always expand
      the definitions first and then consider only normalization of
      instances in which there are no remaining defined statements.
      </p>
      <p>We will prove termination for the simple case where there are no
      attributes.  For the general case, we will show that any
      nontermination arising from an instance that does involve
      attributes would also arise from one with no attributes.
      </p>

      <p><b>Termination for instances without attributes.</b>  
      As shown in [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>], termination of normalization can be
      shown by checking that the inference rules are <em>weakly
      acyclic</em>.  In addition, weak acyclicity can be checked
      in a modular fashion for our system, because there are only a few possible
      cycles among statements.  The following table summarizes seven
      <em>stages</em> of the inference rules; because there are no
      cycles among stages, it is sufficient to check weak acyclicity
      of each stage independently.
      </p>
      
      <table border="1">
	<tbody><tr>
	  <th>Stage #</th>
	  <th>Inference</th>
	  <th>Hypotheses</th>
	  <th>Conclusions</th>
	</tr>
	<tr>
	  <td>1</td>
	  <td>19, 20, 21</td>
	  <td class="name">specializationOf</td>  <!-- TODO remove mention -->
	  <td class="name">specializationOf, entity</td>
	</tr>
	<tr>
	  <td>2</td>
	  <td>7, 8, 13, 14</td>
	  <td class="name">entity, activity, wasAttributedTo, actedOnBehalfOf</td>
	  <td class="name">wasInvalidatedBy, wasStartedBy, wasEndedBy,
	wasAssociatedWith</td>
	</tr>	
	<tr>
	  <td>3</td>
	  <td>9, 10</td>
	  <td class="name">wasStartedBy, wasEndedBy</td>
	  <td class="name">wasGeneratedBy</td>
	</tr>	
	<tr>
	  <td>4</td>
	  <td>11, 12</td>
	  <td class="name">wasDerivedFrom</td>
	  <td class="name">wasGeneratedBy, used, alternateOf</td>
	</tr>	
	<tr>
	  <td>5</td>
	  <td>16, 17, 18</td>
	  <td class="name">alternateOf, entity</td>
	  <td class="name">alternateOf</td>
	</tr>	
	<tr>
	  <td>6</td>
	  <td>5, 6</td>
	  <td class="name">wasInformedBy, generated, used</td>
	  <td class="name">wasInformedBy, generated, used</td>
	</tr>
	<tr>
	  <td>7</td>
	  <td>15</td>
	  <td>many</td>
	  <td class="name">wasInfluencedBy</td>
	</tr>	

     </tbody></table>
      <p>
      For each stage, we show that the stage is weakly acyclic.
     </p><ul><li>Stages 1 and 5 have no rules with existential quantifiers,
      so they are weakly acyclic.
       </li>
       <li>Stages 2, 3, 4, and 7 have no cycles among the formulas
      involved, so they are weakly acyclic.
       </li>
       <li>For stage 6, we check weak acyclicity using the algorithm
      in       [<cite><a class="bibref" href="#bib-DBCONSTRAINTS">DBCONSTRAINTS</a></cite>], namely:
       <ul><li> Given a formula <span class="math">φ(x<sub>1</sub>,...,x<sub>n</sub>) ⇒
      ∃y<sub>1</sub>,...,y<sub>m</sub>. ψ(x<sub>1</sub>,...,x<sub>n</sub>,y<sub>1</sub>,...,y<sub>m</sub>)</span></li>
      <li>For every <span class="math">x</span> that occurs in  <span class="math">ψ</span>, and for every
      occurrence of <span class="math">x</span> in <span class="math">φ</span> in position <span class="math">r.i</span>:
      <ol><li>For every occurrence of <span class="math">x</span> in position <span class="math">s.j</span>, add
      an edge from <span class="math">r.i</span> to <span class="math">s.j</span> (if it does
      not already exist).  </li>
    <li>In addition, for every existentially quantified variable <span class="math">y</span>
      and for every occurrence of <span class="math">y</span> in <span class="math">ψ</span> in position
      <span class="math">t.k</span>, add a special edge from <span class="math">r.i</span> to <span class="math">t.k</span> (if it does
      not already exist).
      </li>
      </ol>
      </li>
      </ul>
      Weak
      acyclicity means that there is no cycle involving a special
      edge in the resulting graph.  For the two inferences in stage 6,
      the following dependency graph witnesses weak
      acyclicity.  The nodes <span class="name">wasGeneratedBy.i</span>,
      <span class="name">wasInformedBy.i</span>, and <span class="name">used.i</span> denote the <span class="math">i</span>th arguments
      of the corresponding predicates.  The solid edges are ordinary
      edges, and the dashed edges are <em>special</em> edges.  
       </li>
       </ul>

       
       <img src="images/constraints/weak-acyclic-6.svg" alt="Graph illustrating weak
       acyclicity of stage 6">
       
      <p><b>Termination for instances with attributes.</b>
       We can translate an instance with attributes to an alternative,
       purely relational language by introducing a relation
       <span class="name">attribute(id,a,v)</span> and replacing every statement of the form
       <span class="name">r(id;a1,...,a<sub>n</sub>,[(k<sub>1</sub>,v<sub>1</sub>),...,(k<sub>m</sub>,v<sub>m</sub>)])</span> with
       <span class="name">r(id;a1,...,a<sub>n</sub>),attribute(id,k<sub>1</sub>,v<sub>1</sub>),...,attribute(id,k<sub>m</sub>,v<sub>m</sub>)</span>,
       and similarly for <span class="name">entity</span>, <span class="name">activity</span> and <span class="name">agent</span>
       attributes.  The inference rules can also be translated so as
       to work on these instances, and a similar argument to
       the above shows that inference is terminating on instances with
       explicit attributes.  Any infinite
       sequence of normalization steps on the original instance would
       lead to an infinite sequence of translated normalization steps
       on instances with explicit attributes.
       </p>
</section>

<section class="appendix" id="change-log">
       <!--OddPage--><h2><span class="secno">B. </span>Change Log</h2>

<section id="changes-since-proposed-recommendation">
      <h3><span class="secno">B.1 </span>Changes since Proposed Recommendation</h3> 
<ul>
<li> Changed the status of this document section.
</li><li> Changed all URLs to  PROV documents.
  </li><li> Fixed some minor typos in section 2.4.
  </li><li> Fixed typo in remark after definition 2.
  </li><li> Fixed typo in paragraph after table 2.
  </li><li> Fixed typo in sec. 6.3.
  </li><li> Fixed wording in remark in sec. 7.1, and moved it before
      section heading.
  </li><li> Fixed typo in appendix A.
</li></ul>

</section>


<section class="appendix" id="changes-from-candidate-recommendation-to-proposed-recommendation"> 
      <h3><span class="secno">B.2 </span>Changes from Candidate Recommendation to Proposed Recommendation</h3> 
    <p>   Please see the <a href="http://www.w3.org/2011/prov/wiki/ResponsesToPublicCommentsCR">
      Responses to Public Comments on the Candidate Recommendation</a>
      for more details about the justification of these changes.</p>
<ul>
  <li> Reworded description of toplevel instance and
      bundles to provide a clearer restatement in one place (<a href="#purpose">Sec. 1.2</a>)</li>
  <li>Fixed a number of broken links from definition references to definitions</li>
  <li>Updated the <a href="#sotd">Status of This Document</a> to describe proposed recommendation
      status and updated references to other PR-stage PROV documents</li>
  <li>Added clarification concerning constraint
      <a href="#wasAssociatedWith-ordering">wasAssociatedWith-ordering</a> (issue-615).</li>
      <li>Added underscores to some variables in inferences <a href="#wasStartedBy-inference">9</a>, <a href="#wasEndedBy-inference">10</a>,
      <a href="#influence-inference">15</a> (issue-611).</li>
      <li>Corrected a typo in the name <span class="name">hadMember</span> in <a href="">constraint 56</a>
      (issue-611).
      </li>
      <li>Clarified that existential variables are scoped at the
      instance level, not statement level, thus it is correct to apply
      uniqueness constraints by substituting variables through an
      instance (issue-611).  (Remark at the end of <a href="#concepts">section
      4. Basic concepts</a>, and clarified discussion in <a href="#overview">Validation Process Overview</a>)</li>
      <li>Gave equivalent form of <a href="#optional-attributes">Definition 2</a> (issue-611).</li>
</ul>
</section>

       <section id="changes-from-last-call-working-draft-to-candidate-recommendation">
      <h3><span class="secno">B.3 </span>Changes from Last Call Working Draft to Candidate Recommendation</h3> 
    <p>   Please see the <a href="http://www.w3.org/2011/prov/wiki/ResponsesToPublicComments">
      Responses to Public Comments on the Last Call Working Draft</a>
      for more details about the justification of these changes.</p>
       
<ul>
  <li>Abstract: clarified that term "validity" is analogous to other
  notions of validity in Web standards. </li>
  <li>Added bullet point linking to PROV-SEM under "How to read the
  PROV family of specifications"</li>
  <li>Revised sec. 1.2 to clarify terminology (validity), emphasize
  that any implementation equivalent to the procedural specification
  is compliant, and clarify that treating "equivalent instances in the
  same way" is a guideline.</li>
  <li>Added paragraph to sec 2.4 to clarify the purpose of the section.</li>
  <li>Sec 2.4 Unification and Merging: changed "merging" to "unification" for terms</li>
  <li>Sec. 2.4 "Applying definitions, inferences and constraints":
  Updated merging to unification and added paragraph reinforcing that
  compliance is algorithm independent</li>
  <li>Sec. 2.4 "Checking ordering, typing and impossibility
  constraints": Avoided use of the term "satisfies".</li>
  <li>Sec. 2.4 "Equivalence and Isomorphism": Extended equivalence to
  be defined on all instances, valid or not.  Removed analogy to RDF.</li>
  <li>Sec. 2.4 "From Instances to Bundles and Documents": Revised to
  avoid giving the impression that toplevel instances must be disjoint
  from bundles; removed reference to RDF.</li>
  <li>Sec. 3. Clarified and reinforced algorithm independence.</li>
  <li>Sec. 4.  Added clarifying remark about role of definitions.</li>
  <li>Sec. 4. Avoided reference to RDF, minor clarifications to
  discussion of existential variables. </li>
  <li>Sec. 4.1. Spelling correction.</li>
  <li>Sec. 4.4. Merging -&gt; unification</li>
  <li>Sec. 5. Merging -&gt; unification terminology change.  Added
  declarative definition of unification.  Clarified
  procedural definition.  Removed definition of merging of attribute
  lists.  Updated descriptions of uniqueness and key constraint application.</li>
  <li>Constraint 23.  Renamed e, a, ag to id.</li>
  <li>Sec. 5.2.  Explicitly stated that strictly-precedes is irreflexive.</li>
  <li>Sec. 5.2. Spelling</li>
  <li>Sec. 5.2, just before constraint 51: updated text to accurately
  describe constraint.</li>
  <li>Sec. 6.  Merging -&gt; unification.  Updated definition of validity
  to avoid referring to "satisfies".  Explicitly defined isomorphism
  of instances.  Broadened the definition of equivalence so that it is
  allowed to test arbitrary instances for equivalence.  Reinforce the
  intention of the guideline that applications treat equivalent
  instances "in the same way".</li>
  <li>Dropped RDF as a normative reference.</li>
  <li>Made PROV-DM and PROV-N into normative references.</li>
  <li>Added "document" and "endDocument" to sec. 6.2.</li>
  <li>Added sentence of explanation of purpose to beginning.</li>
  <li>Moved "mention" to a separate note. </li>
  <li>Added <a href="#concepts">Section 4: Basic Concepts</a>.</li>
  <li>Miscellaneous final cleanup prior to CR staging.</li>
  <li> Added html link to provenance.</li>
</ul>

</section>

</section>


<section class="appendix" id="acknowledgements"> 
      <!--OddPage--><h2><span class="secno">C. </span>Acknowledgements</h2> 
      <p> 

This  document has been produced by the Provenance Working Group, and its contents reflect extensive discussion within the Working Group as a whole. The editors extend special thanks to Ivan Herman (<abbr title="World Wide Web Consortium">W3C</abbr>/<abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr>), Paul Groth, Tim Lebo, Simon Miles, Stian Soiland-Reyes,  for their thorough reviews.
      </p> 

<p>
The editors acknowledge valuable contributions from the following:
Tom Baker,
David Booth,
Robert Freimuth,
Satrajit Ghosh,
Ralph Hodgson,
Renato Iannella,
Jacek Kopecky,
James Leigh,
Jacco van Ossenbruggen,
Héctor Pérez-Urbina,
Alan Ruttenberg,
Reza Samavi,
Evren Sirin, 
Antoine Zimmermann.
</p>

<p>
Members of the Provenance Working Group at the time of publication of this document were:

Ilkay Altintas (Invited expert),
Reza B'Far (Oracle Corporation),
Khalid Belhajjame (University of Manchester),
James Cheney (University of Edinburgh, School of Informatics),
Sam Coppens (iMinds - Ghent University),
David Corsar (University of Aberdeen, Computing Science),
Stephen Cresswell (The National Archives),
Tom De Nies (iMinds - Ghent University),
Helena Deus (DERI Galway at the National University of Ireland, Galway, Ireland),
Simon Dobson (Invited expert),
Martin Doerr (Foundation for Research and Technology - Hellas(FORTH)),
Kai Eckert (Invited expert),
Jean-Pierre EVAIN (European Broadcasting Union, EBU-UER),
James Frew (Invited expert),
Irini Fundulaki (Foundation for Research and Technology - Hellas(FORTH)),
Daniel Garijo (Universidad Politécnica de Madrid),
Yolanda Gil (Invited expert),
Ryan Golden (Oracle Corporation),
Paul Groth (Vrije Universiteit),
Olaf Hartig (Invited expert),
David Hau (National Cancer Institute, NCI),
Sandro Hawke (<abbr title="World Wide Web Consortium">W3C</abbr>/<abbr title="Massachusetts Institute of Technology">MIT</abbr>),
Jörn Hees (German Research Center for Artificial Intelligence (DFKI) Gmbh),
Ivan Herman, (<abbr title="World Wide Web Consortium">W3C</abbr>/<abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr>),
Ralph Hodgson (TopQuadrant),
Hook Hua (Invited expert),
Trung Dong Huynh (University of Southampton),
Graham Klyne (University of Oxford),
Michael Lang (Revelytix, Inc.),
Timothy Lebo (Rensselaer Polytechnic Institute),
James McCusker (Rensselaer Polytechnic Institute),
Deborah McGuinness (Rensselaer Polytechnic Institute),
Simon Miles (Invited expert),
Paolo Missier (School of Computing Science, Newcastle university),
Luc Moreau (University of Southampton),
James Myers (Rensselaer Polytechnic Institute),
Vinh Nguyen (Wright State University),
Edoardo Pignotti (University of Aberdeen, Computing Science),
Paulo da Silva Pinheiro (Rensselaer Polytechnic Institute),
Carl Reed (Open Geospatial Consortium),
Adam Retter (Invited Expert),
Christine Runnegar (Invited expert),
Satya Sahoo (Invited expert),
David Schaengold (Revelytix, Inc.),
Daniel Schutzer (FSTC, Financial Services Technology Consortium),
Yogesh Simmhan (Invited expert),
Stian Soiland-Reyes (University of Manchester),
Eric Stephan (Pacific Northwest National Laboratory),
Linda Stewart (The National Archives),
Ed Summers (Library of Congress),
Maria Theodoridou (Foundation for Research and Technology - Hellas(FORTH)),
Ted Thibodeau (OpenLink Software Inc.),
Curt Tilmes (National Aeronautics and Space Administration),
Craig Trim (IBM Corporation),
Stephan Zednik (Rensselaer Polytechnic Institute),
Jun Zhao (University of Oxford),
Yuting Zhao (University of Aberdeen, Computing Science).
</p>
    </section> 

 

<!--  LocalWords:  px DM RL RDF AQ SEM SOTD Definitional wasInformedBy attrs ag
 -->
<!--  LocalWords:  wasGeneratedBy wasStartedBy gAttr sAttr wasAttributedTo attr
 -->
<!--  LocalWords:  wasAssociatedWith dAttrs gAttrs wasDerivedFrom uAttrs eAttrs
 -->
<!--  LocalWords:  wasRevisionOf specializationOf wasQuotedFrom Traceability WD
 -->
<!--  LocalWords:  tracedTo aAttr actedOnBehalfOf rAttr traceability TODO xsd
 -->
<!--  LocalWords:  alternateOf wasEndedBy Lamport's timeline subfigure memberOf
 -->
<!--  LocalWords:  wasStartedByAgent wasAttributedWith derivedByInsertionFrom
 -->
<!--  LocalWords:  QName derivedByRemovalFrom EmptyCollection wasVersionOf dm
 -->
<!--  LocalWords:  RecsWD formedness workflow ness operability CSP versa hyp YY
 -->
<!--  LocalWords:  disambiguating lifecycle conformant minimalistic Lamport fo
 -->
<!--  LocalWords:  reflexivity antisymmetry timelines timespan WG concl inv TBD
 -->
<!--  LocalWords:  continuant occurrent modalities toyota womanInRedDress provn
 -->
<!--  LocalWords:  customerInChairAt manWithGlasses customerInChair irreflexive
 -->
<!--  LocalWords:  wasStartedByActivity antisymmetric wasInvalidatedBy stmt CHR
 -->
<!--  LocalWords:  DBCONSTRAINTS formalisms URIs wasInfluencedBy definitional
 -->
<!--  LocalWords:  wasInvalidated th  nontermination  implementability att evt
 -->
<!--  LocalWords:  Irreflexivity mentionOf preorder equalities unsatisfiable De
 -->
<!--  LocalWords:  Lebo subfigures pre del irreflexivity superproperty typeOf
 -->
<!--  LocalWords:  disjointness inferrable subtyping subtype subtypes hadMember
 -->
<!--  LocalWords: toplevel sameAs tuple acyclicity isomorphism IRI fff dfn xmpl
 -->
<!--  LocalWords:  endBundle typeof equational acyclic invertible procedurally
 -->
<!--  LocalWords:  implementers multi unifier ERCIM Groth Stian Soiland Ilkay
 -->
<!--  LocalWords:  Altintas Reza B'Far Belhajjame Informatics Coppens IBBT Nies
 -->
<!--  LocalWords:  Corsar Cresswell Deus DERI Galway satisfiable namespace Kai
 -->
<!--  LocalWords:  endDocument Dobson Doerr Hellas Eckert EVAIN EBU UER Frew de
 -->
<!--  LocalWords:  Irini Fundulaki Garijo Universidad Politécnica Vrije Hartig
 -->
<!--  LocalWords:  Universiteit Hau NCI Sandro Hawke Jörn Hees DFKI Gmbh Hua da
 -->
<!--  LocalWords:  Hodgson TopQuadrant Trung Huynh Klyne Revelytix Rensselaer
 -->
<!--  LocalWords:  McCusker McGuinness Paolo Missier Luc Moreau Vinh Edoardo pl
 -->
<!--  LocalWords:  Pignotti Paulo Pinheiro Geospatial Retter Runnegar Satya gen
 -->
<!--  LocalWords:  Sahoo Schaengold Schutzer FSTC Yogesh Simmhan Theodoridou
 -->
<!--  LocalWords:  Thibodeau OpenLink Tilmes Zednik Zhao Yuting anexample rgba
 -->
<!--  LocalWords:  unamedconstraint deprecatedconstraint conceptexample prov
 -->
<!--  LocalWords:  pnExpression table.thinborder assoc Freimuth Satrajit Jacek
 -->
<!--  LocalWords:  Iannella Kopecky Jacco Ossenbruggen Ruttenberg Samavi
 -->
<section id="references" class="appendix"><!--OddPage--><h2><span class="secno">D. </span>References</h2><section id="normative-references"><h3><span class="secno">D.1 </span>Normative references</h3><dl class="bibliography"><dt id="bib-PROV-DM">[PROV-DM]</dt><dd>Luc Moreau; Paolo Missier; eds. <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/"><cite>PROV-DM: The PROV Data Model</cite></a>. 30 April 2013, W3C Recommendation. URL: <a href="http://www.w3.org/TR/2013/REC-prov-dm-20130430/">http://www.w3.org/TR/2013/REC-prov-dm-20130430/</a>
</dd><dt id="bib-PROV-N">[PROV-N]</dt><dd>Luc Moreau; Paolo Missier; eds. <a href="http://www.w3.org/TR/2013/REC-prov-n-20130430/"><cite>PROV-N: The Provenance Notation</cite></a>. 30 April 2013, W3C Recommendation. URL: <a href="http://www.w3.org/TR/2013/REC-prov-n-20130430/">http://www.w3.org/TR/2013/REC-prov-n-20130430/</a>
</dd><dt id="bib-PROV-O">[PROV-O]</dt><dd>Timothy Lebo; Satya Sahoo; Deborah McGuinness; eds. <a href="http://www.w3.org/TR/2013/REC-prov-o-20130430/"><cite>PROV-O: The PROV Ontology</cite></a>. 30 April 2013, W3C Recommendation. URL: <a href="http://www.w3.org/TR/2013/REC-prov-o-20130430/">http://www.w3.org/TR/2013/REC-prov-o-20130430/</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd>S. Bradner. <a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>Key words for use in RFCs to Indicate Requirement Levels.</cite></a> March 1997. Internet RFC 2119.  URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a> 
</dd><dt id="bib-RFC3987">[RFC3987]</dt><dd>M. Dürst; M. Suignard. <a href="http://www.ietf.org/rfc/rfc3987.txt"><cite>Internationalized Resource Identifiers (IRIs) (RFC 3987)</cite></a>. January 2005. RFC. URL: <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>
</dd></dl></section><section id="informative-references"><h3><span class="secno">D.2 </span>Informative references</h3><dl class="bibliography"><dt id="bib-CHR">[CHR]</dt><dd>Thom Frühwirth. <a href="http://constraint-handling-rules.org/"><cite>Constraint        Handling Rules</cite></a>. Cambridge University Press  URL: <a href="http://constraint-handling-rules.org/">http://constraint-handling-rules.org/</a>
</dd><dt id="bib-CLOCK">[CLOCK]</dt><dd>L. Lamport. <a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf"><cite>Time, clocks, and the ordering of events in a distributed system</cite></a>. Communications of the ACM 21 (7): 558–565. 1978. URL: <a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf</a> DOI: doi:10.1145/359545.359563.
</dd><dt id="bib-DBCONSTRAINTS">[DBCONSTRAINTS]</dt><dd> Ronald Fagin; Phokion G. Kolaitis; Renée J. Miller; Lucian Popa.  <a href="http://dx.doi.org/10.1016/j.tcs.2004.10.033"><cite>Data        exchange: Semantics and query answering</cite></a>.  Theoretical computer science 336(1):89-124   Elsevier  URL: <a href="http://dx.doi.org/10.1016/j.tcs.2004.10.033">http://dx.doi.org/10.1016/j.tcs.2004.10.033</a>
</dd><dt id="bib-Logic">[Logic]</dt><dd>W. E. Johnson. <a href="http://www.ditext.com/johnson/intro-3.html"><cite>Logic: Part III</cite></a>.1924. URL: <a href="http://www.ditext.com/johnson/intro-3.html">http://www.ditext.com/johnson/intro-3.html</a>
</dd><dt id="bib-PROV-AQ">[PROV-AQ]</dt><dd>Graham Klyne; Paul Groth; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-aq-20130430/"><cite>Provenance Access and Query</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-aq-20130430/">http://www.w3.org/TR/2013/NOTE-prov-aq-20130430/</a>
</dd><dt id="bib-PROV-DC">[PROV-DC]</dt><dd>Daniel Garijo; Kai Eckert; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-dc-20130430/"><cite>Dublin Core to PROV Mapping</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-dc-20130430/">http://www.w3.org/TR/2013/NOTE-prov-dc-20130430/</a>
</dd><dt id="bib-PROV-DICTIONARY">[PROV-DICTIONARY]</dt><dd>Tom De Nies; Sam Coppens; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-dictionary-20130430/"><cite>PROV Dictionary: Modeling Provenance for Dictionary Data Structures</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-dictionary-20130430/">http://www.w3.org/TR/2013/NOTE-prov-dictionary-20130430/</a>
</dd><dt id="bib-PROV-LINKS">[PROV-LINKS]</dt><dd>Luc Moreau; Timothy Lebo; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-links-20130430/"><cite>Linking Across Provenance Bundles</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-links-20130430/">http://www.w3.org/TR/2013/NOTE-prov-links-20130430/</a>
</dd><dt id="bib-PROV-OVERVIEW">[PROV-OVERVIEW]</dt><dd>Paul Groth; Luc Moreau; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-overview-20130430/"><cite>PROV-OVERVIEW: An Overview of the PROV Family of Documents</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-overview-20130430/">http://www.w3.org/TR/2013/NOTE-prov-overview-20130430/</a>
</dd><dt id="bib-PROV-PRIMER">[PROV-PRIMER]</dt><dd>Yolanda Gil; Simon Miles; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-primer-20130430/"><cite>PROV Model Primer</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-primer-20130430/">http://www.w3.org/TR/2013/NOTE-prov-primer-20130430/</a>
</dd><dt id="bib-PROV-SEM">[PROV-SEM]</dt><dd>James Cheney; ed. <a href="http://www.w3.org/TR/2013/NOTE-prov-sem-20130430"><cite>Semantics of the PROV Data Model</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-sem-20130430">http://www.w3.org/TR/2013/NOTE-prov-sem-20130430</a>.
</dd><dt id="bib-PROV-XML">[PROV-XML]</dt><dd>Hook Hua; Curt Tilmes; Stephan Zednik; eds. <a href="http://www.w3.org/TR/2013/NOTE-prov-xml-20130430/"><cite>PROV-XML: The PROV XML Schema</cite></a>. 30 April 2013, W3C Note. URL: <a href="http://www.w3.org/TR/2013/NOTE-prov-xml-20130430/">http://www.w3.org/TR/2013/NOTE-prov-xml-20130430/</a>
</dd></dl></section></section></body></html>
