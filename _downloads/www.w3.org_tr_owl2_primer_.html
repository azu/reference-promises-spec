<!-- http://www.w3.org/TR/owl2-primer/ -->
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>OWL 2 Web Ontology Language Primer (Second Edition)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="owl.css" rel="stylesheet" type="text/css" />
<link href="Primer.css" rel="stylesheet" type="text/css" />
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css" />

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72" /></a><h1 id="title" style="clear:both">OWL 2 Web Ontology Language <br /><span id="short-title">Primer (Second Edition)</span></h1>

<h2 id="W3C-doctype">W3C Recommendation 11 December 2012</h2>

<!-- no inplace warning -->
<dl>
<dt>This version:</dt>
<dd><a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/" id="this-version-url">http://www.w3.org/TR/2012/REC-owl2-primer-20121211/</a></dd>

<dt>Latest version (series 2):</dt>
<dd><a href="http://www.w3.org/TR/owl2-primer/">http://www.w3.org/TR/owl2-primer/</a></dd>

<dt>Latest Recommendation:</dt>
<dd><a href="http://www.w3.org/TR/owl-primer">http://www.w3.org/TR/owl-primer</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-owl2-primer-20121018/">http://www.w3.org/TR/2012/PER-owl2-primer-20121018/</a></dd>
</dl>

<dl><dt>Editors:</dt><dd><a href="http://www.pascal-hitzler.de/">Pascal Hitzler</a>, Wright State University</dd>
<dd><a href="http://korrekt.org">Markus Kr&ouml;tzsch</a>, University of Oxford</dd>
<dd><a href="http://www.cs.man.ac.uk/~bparsia/">Bijan Parsia</a>, University of Manchester</dd>
<dd>Peter F. Patel-Schneider, Nuance Communications</dd>
<dd><a href="http://www.sebastian-rudolph.de">Sebastian Rudolph</a>, FZI Research Center for Information Technology</dd>
</dl>

<p>Please refer to the <a href="http://www.w3.org/2007/OWL/errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>A <a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/diff-from-20121018">color-coded version of this document showing changes made since the previous version</a> is also available.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/2012/pdf/REC-owl2-primer-20121211.pdf">PDF version</a>.</p>

<p>See also <a href="http://www.w3.org/2007/OWL/translation/owl2-primer">translations</a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2012 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>
<hr />
<h2><a id="abstract" name="abstract">Abstract</a></h2>

<div>
<div><p>The OWL 2 Web Ontology Language, informally OWL 2, is an ontology language for the Semantic Web with formally defined meaning.  OWL 2 ontologies provide classes, properties, individuals, and data values and are stored as Semantic Web documents.  OWL 2 ontologies can be used along with information written in RDF, and OWL 2 ontologies themselves are primarily exchanged as RDF documents.  The OWL 2 <a href="http://www.w3.org/TR/2012/REC-owl2-overview-20121211/" title="Document Overview">Document Overview</a> describes the overall state of OWL 2, and should be read before other OWL 2 documents.</p><p>This primer provides an approachable introduction to OWL 2, including orientation for those coming from other disciplines, a running example showing how OWL 2 can be used to represent first simple information and then more complex information, how OWL 2 manages ontologies, and finally the distinctions between the various sublanguages of OWL 2.</p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">Status of this Document</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">May Be Superseded</h4>
    
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>



           <h4 class="no-toc no-num" id="status-changes">Summary of Changes</h4>

            <div>There have been no <a href="http://www.w3.org/2005/10/Process-20051014/tr#substantive-change">substantive</a> changes since the <a href="http://www.w3.org/TR/2012/PER-owl2-primer-20121018/">previous version</a>.   For details on the minor changes see the <a href="#changelog">change log</a> and <a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/diff-from-20121018">color-coded diff</a>.</div>



<h4 class="no-toc no-num" id="please">Please Send Comments</h4><p>Please send any comments to <a class="mailto" href="mailto:public-owl-comments@w3.org">public-owl-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-comments/">public
    archive</a>).  Although work on this document by the <a href="http://www.w3.org/2007/OWL/">OWL Working Group</a> is complete, comments may be addressed in the <a href="http://www.w3.org/2007/OWL/errata">errata</a> or in future revisions.  Open discussion among developers is welcome at <a class="mailto" href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-dev/">public archive</a>).</p>
    
<h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    
<p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>


<h4 class="no-toc no-num" id="patents">Patents</h4>
    
<p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. This document is informative only.  W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/41712/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.</em></p>

<hr title="Separator After Status Section" />

<script type="text/javascript">/*<![CDATA[*/
/*
	Written by Jonathan Snook, http://www.snook.ca/jonathan
	Add-ons by Robert Nyman, http://www.robertnyman.com
	Author says "The credit comment is all it takes, no license. Go crazy with it!:-)"
	From http://www.robertnyman.com/2005/11/07/the-ultimate-getelementsbyclassname/
*/

var displayed = [];
displayed["fssyntax"] = 1;
displayed["rdfxml"] = 0;
displayed["turtle"] = 0;
displayed["manchester"] = 0;
displayed["owlxml"] = 0;

function primerOnLoad() {
  display('rdfxml', 'none');      set_display_by_id('hide-rs', 'none');       set_display_by_id('show-rs', '');
  display('turtle', 'none');      set_display_by_id('hide-ts', 'none');       set_display_by_id('show-ts', '');
  display('manchester', 'none');  set_display_by_id('hide-ms', 'none');       set_display_by_id('show-ms', '');
  display('owlxml', 'none');      set_display_by_id('hide-xs', 'none');       set_display_by_id('show-xs', '');
}

function display(syntax,status) {
  var howmany = 0;
  if (status=='none') {
    displayed[syntax] = 0; 
  } else { 
    displayed[syntax] = 1;
  }
  for ( i in displayed ) {
       howmany = howmany + displayed[i];
  }
  set_display_by_class('div',syntax,status);
  if ( howmany == 1 ) {
      set_display_by_class('b','syntax-head','none');
  } else {
      set_display_by_class('b','syntax-head','');
  }
}

function getElementsByClassName(oElm, strTagName, oClassNames){
	var arrElements = (! (! (strTagName == "*") || ! (oElm.all)))? oElm.all : oElm.getElementsByTagName(strTagName);
	var arrReturnElements = new Array();
	var arrRegExpClassNames = new Array();
	if(typeof oClassNames == "object"){
		for(var i=0; !(i>=oClassNames.length); i++){ /*>*/
			arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames[i].replace(/\-/g, "\\-") + "(\\s|$)"));
		}
	}
	else{
		arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames.replace(/\-/g, "\\-") + "(\\s|$)"));
	}
	var oElement;
	var bMatchesAll;
	for(var j=0; !(j>=arrElements.length); j++){ /*>*/
		oElement = arrElements[j];
		bMatchesAll = true;
		for(var k=0; !(k>=arrRegExpClassNames.length); k++){ /*>*/
			if(!arrRegExpClassNames[k].test(oElement.className)){
				bMatchesAll = false;
				break;
			}
		}
		if(bMatchesAll){
			arrReturnElements.push(oElement);
		}
	}
	return (arrReturnElements)
}

function set_display_by_class(el, cls, newValue) {
   var e = getElementsByClassName(document, el, cls);
   if (e != null) {
      for (var i=0; !(i>=e.length); i++) {
        e[i].style.display = newValue;
      }
   }
}

function set_display_by_id(id, newValue) {
   var e = document.getElementById(id);
   if (e != null) {
     e.style.display = newValue;
   }
}
/*]]>*/
</script>


<table class="toc" id="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>Table of Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2"><a href="#Guide_to_this_Document"><span class="tocnumber">1.1</span> <span class="toctext">Guide to this Document</span></a></li>
<li class="toclevel-2"><a href="#OWL_Syntaxes"><span class="tocnumber">1.2</span> <span class="toctext">OWL Syntaxes</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#What_is_OWL_2.3F"><span class="tocnumber">2</span> <span class="toctext">What is OWL 2?</span></a></li>
<li class="toclevel-1"><a href="#Modeling_Knowledge:_Basic_Notions"><span class="tocnumber">3</span> <span class="toctext">Modeling Knowledge: Basic Notions</span></a></li>
<li class="toclevel-1"><a href="#Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them"><span class="tocnumber">4</span> <span class="toctext">Classes, Properties, and Individuals &ndash; And Basic Modeling With Them</span></a>
<ul>
<li class="toclevel-2"><a href="#Classes_and_Instances"><span class="tocnumber">4.1</span> <span class="toctext">Classes and Instances</span></a></li>
<li class="toclevel-2"><a href="#Class_Hierarchies"><span class="tocnumber">4.2</span> <span class="toctext">Class Hierarchies</span></a></li>
<li class="toclevel-2"><a href="#Class_Disjointness"><span class="tocnumber">4.3</span> <span class="toctext">Class Disjointness</span></a></li>
<li class="toclevel-2"><a href="#Object_Properties"><span class="tocnumber">4.4</span> <span class="toctext">Object Properties</span></a></li>
<li class="toclevel-2"><a href="#Property_Hierarchies"><span class="tocnumber">4.5</span> <span class="toctext">Property Hierarchies</span></a></li>
<li class="toclevel-2"><a href="#Domain_and_Range_Restrictions"><span class="tocnumber">4.6</span> <span class="toctext">Domain and Range Restrictions</span></a></li>
<li class="toclevel-2"><a href="#Equality_and_Inequality_of_Individuals"><span class="tocnumber">4.7</span> <span class="toctext">Equality and Inequality of Individuals</span></a></li>
<li class="toclevel-2"><a href="#Datatypes"><span class="tocnumber">4.8</span> <span class="toctext">Datatypes</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Class_Relationships"><span class="tocnumber">5</span> <span class="toctext">Advanced Class Relationships</span></a>
<ul>
<li class="toclevel-2"><a href="#Complex_Classes"><span class="tocnumber">5.1</span> <span class="toctext">Complex Classes</span></a></li>
<li class="toclevel-2"><a href="#Property_Restrictions"><span class="tocnumber">5.2</span> <span class="toctext">Property Restrictions</span></a></li>
<li class="toclevel-2"><a href="#Property_Cardinality_Restrictions"><span class="tocnumber">5.3</span> <span class="toctext">Property Cardinality Restrictions</span></a></li>
<li class="toclevel-2"><a href="#Enumeration_of_Individuals"><span class="tocnumber">5.4</span> <span class="toctext">Enumeration of Individuals</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Use_of_Properties"><span class="tocnumber">6</span> <span class="toctext">Advanced Use of Properties</span></a>
<ul>
<li class="toclevel-2"><a href="#Property_Characteristics"><span class="tocnumber">6.1</span> <span class="toctext">Property Characteristics</span></a></li>
<li class="toclevel-2"><a href="#Property_Chains"><span class="tocnumber">6.2</span> <span class="toctext">Property Chains</span></a></li>
<li class="toclevel-2"><a href="#Keys"><span class="tocnumber">6.3</span> <span class="toctext">Keys</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Use_of_Datatypes"><span class="tocnumber">7</span> <span class="toctext">Advanced Use of Datatypes</span></a></li>
<li class="toclevel-1"><a href="#Document_Information_and_Annotations"><span class="tocnumber">8</span> <span class="toctext">Document Information and Annotations</span></a>
<ul>
<li class="toclevel-2"><a href="#Annotating_Axioms_and_Entities"><span class="tocnumber">8.1</span> <span class="toctext">Annotating Axioms and Entities</span></a></li>
<li class="toclevel-2"><a href="#Ontology_Management"><span class="tocnumber">8.2</span> <span class="toctext">Ontology Management</span></a></li>
<li class="toclevel-2"><a href="#Entity_Declarations"><span class="tocnumber">8.3</span> <span class="toctext">Entity Declarations</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#OWL_2_DL_and_OWL_2_Full"><span class="tocnumber">9</span> <span class="toctext">OWL 2 DL and OWL 2 Full</span></a></li>
<li class="toclevel-1"><a href="#OWL_2_Profiles"><span class="tocnumber">10</span> <span class="toctext">OWL 2 Profiles</span></a>
<ul>
<li class="toclevel-2"><a href="#OWL_2_EL"><span class="tocnumber">10.1</span> <span class="toctext">OWL 2 EL</span></a></li>
<li class="toclevel-2"><a href="#OWL_2_QL"><span class="tocnumber">10.2</span> <span class="toctext">OWL 2 QL</span></a></li>
<li class="toclevel-2"><a href="#OWL_2_RL"><span class="tocnumber">10.3</span> <span class="toctext">OWL 2 RL</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#OWL_Tools"><span class="tocnumber">11</span> <span class="toctext">OWL Tools</span></a></li>
<li class="toclevel-1"><a href="#What_To_Read_Next"><span class="tocnumber">12</span> <span class="toctext">What To Read Next</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_The_Complete_Sample_Ontology"><span class="tocnumber">13</span> <span class="toctext">Appendix: The Complete Sample Ontology</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">14</span> <span class="toctext">Appendix: Change Log (Informative)</span></a>
<ul>
<li class="toclevel-2"><a href="#Changes_Since_Recommendation"><span class="tocnumber">14.1</span> <span class="toctext">Changes Since Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Proposed_Recommendation"><span class="tocnumber">14.2</span> <span class="toctext">Changes Since Proposed Recommendation</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Last_Call"><span class="tocnumber">14.3</span> <span class="toctext">Changes Since Last Call</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgments"><span class="tocnumber">15</span> <span class="toctext">Acknowledgments</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">16</span> <span class="toctext">References</span></a></li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<p><br />
</p><p><br />
</p>
<a id="Introduction" name="Introduction"></a><h2> <span class="mw-headline">1  Introduction </span></h2>
<p>The W3C OWL 2 Web Ontology Language (OWL) is a Semantic Web language designed to represent rich and complex knowledge about things, groups of things, and relations between things. OWL is a computational logic-based language such that knowledge expressed in OWL can be reasoned with by computer programs either to verify the consistency of that knowledge or to make implicit knowledge explicit.
OWL documents, known as <span class="first term">ontologies</span>, can be published in the World Wide Web and may refer to or be referred from other OWL ontologies. OWL is part of the W3C's <a class="external text" href="http://www.w3.org/2001/sw/" rel="nofollow" title="http://www.w3.org/2001/sw/">Semantic Web</a> technology stack, which includes RDF [<cite><a href="#ref-rdf-concepts" title="">RDF Concepts</a></cite>] and SPARQL [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>].
</p><p>The key goal of the primer is to help develop insight into OWL, its strengths, and its weaknesses. 
The core of the primer is an introduction to most of the language features of OWL by way of a running example. Most of the examples in the primer are taken from a sample ontology (which is presented entirely in <a href="#Appendix:_The_Complete_Sample_Ontology" title="">an appendix</a>).  This sample ontology is designed to touch the key language features of OWL in an understandable way and not, in itself, to be an example of a good ontology. 
</p>
<a id="Guide_to_this_Document" name="Guide_to_this_Document"></a><h3> <span class="mw-headline">1.1 Guide to this Document</span></h3>
<p>This document is intended to provide an initial understanding about OWL 2. In particular it is supposed to be accessible for people yet unfamiliar with the topic. Therefore, we start with giving some high-level introduction on the nature of OWL 2 in <a href="#What_is_OWL_2.3F" title="">Section 2</a> before  <a href="#Modeling_Knowledge:_Basic_Notions" title="">Section 3</a> provides some very basic notions in knowledge representation and explains how they relate to terms used in OWL 2. Readers familiar with knowledge representation and reasoning might only skim through this section to get acquainted with the OWL 2 terminology. 
</p><p>Sections 4&ndash;8 describe most of the language features that OWL provides, starting from very basic ones and proceeding to the more sophisticated.  
<a href="#Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them" title="">Section 4</a> presents and discusses the elementary modeling features of OWL 2 before in <a href="#Advanced_Class_Relationships" title="">Section 5</a> complex classes are introduced. <a href="#Advanced_Use_of_Properties" title="">Section 6</a> addresses advanced modeling features for properties. <a href="#Advanced_Use_of_Datatypes" title="">Section 7</a> focuses on advanced modeling related to datatypes. <a href="#Document_Information_and_Annotations" title="">Section 8</a> concludes with extra-logical features used mainly for ontology management purposes.
</p><p>In <a href="#OWL_2_DL_and_OWL_2_Full" title="">Section 9</a> we address the differences between OWL 2 DL and OWL 2 Full, the two semantic views of OWL, while in <a href="#OWL_2_Profiles" title="">Section 10</a> we describe the three tractable sublanguages of OWL 2, called profiles. Tool support for OWL 2 is addressed in <a href="#OWL_Tools" title="">Section 11</a> and in <a href="#What_To_Read_Next" title="">Section 12</a> we give pointers on where to continue reading after our informal introduction to OWL 2.
</p><p>Finally,  <a href="#Appendix:_The_Complete_Sample_Ontology" title="">Section 13</a> lists the complete example ontology used in this document. 
</p><p>For a comprehensive listing of the OWL 2 language features, see the OWL 2 Quick Reference Guide [<cite><a href="#ref-owl-2-quick-reference" title="">OWL 2 Quick Guide</a></cite>] which provides links into the corresponding sections of the appropriate documents concerning syntax and examples.
</p><p>For readers already familiar with OWL 1, OWL 2 New Features and Rationale [<cite><a href="#ref-owl-2-new-features" title="">OWL 2 New Features and Rationale</a></cite>] provides a comprehensive overview of what has changed in OWL 2.
</p>
<a id="OWL_Syntaxes" name="OWL_Syntaxes"></a><h3> <span class="mw-headline">1.2 OWL Syntaxes</span></h3>
<p>OWL is a language to be used in the Semantic Web, so names in OWL are international resource identifiers (IRIs) 	[<cite><a href="#ref-rfc-3987" title="">RFC 3987</a></cite>]. As IRIs are long, we will often make use of abbreviation mechanisms for writing them in OWL. The way in which such abbreviations work is specific to each syntactic format that can be used to encode OWL ontologies, but the examples in this document can generally be understood without knowing these details. Appropriate declarations for namespaces and related mechanisms are given further below in <a href="#Ontology_Management" title="">Section 8.2.</a>
</p><p>There are various syntaxes available for OWL which serve various purposes. The Functional-Style syntax [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>] is designed to be easier for specification purposes and to provide a foundation for the implementation of OWL 2 tools such as APIs and reasoners.
The RDF/XML syntax for OWL is just RDF/XML, with a particular translation for the OWL constructs [<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>]. This is the only syntax that is mandatory to be supported by all OWL 2 tools. 
The Manchester syntax [<cite><a href="#ref-owl-2-manchester-syntax" title="">OWL 2 Manchester Syntax</a></cite>] is an OWL syntax that is designed to be easier for non-logicians to read.
The OWL XML syntax is an XML syntax for OWL defined by an XML schema [<cite><a href="#ref-owl-2-xml-serialization" title="">OWL 2 XML</a></cite>].
There are tools that can translate between the different syntaxes for OWL. In many syntactic forms, OWL language constructs are also represented by IRIs, and some declarations might be needed to use the abbreviated forms as in the examples. Again, necessary details are found in <a href="#Ontology_Management" title="">Section 8.2.</a>
</p><p>The examples and the sample ontology in the appendix can be viewed as any of the four different syntaxes, and we provide both RDF/XML [<cite><a href="#ref-rdf-syntax" title="">RDF Syntax</a></cite>] and Turtle [<cite><a href="#ref-turtle" title="">Turtle</a></cite>] serializations for the RDF-based syntax. You can control which syntaxes are shown throughout the document by using the buttons below.
</p><p>
</p>
<div class="syntaxmenu">
<p>The buttons below can be used to show or hide the available syntaxes.</p><form action=""><p>
<input id="hide-fs" onclick="display('fssyntax','none');      set_display_by_id('hide-fs', 'none'); set_display_by_id('show-fs', '');" type="button" value="Hide Functional-Style Syntax" />
<input id="show-fs" onclick="display('fssyntax','');      set_display_by_id('hide-fs', '');       set_display_by_id('show-fs', 'none');" style="display:none" type="button" value="Show Functional-Style Syntax" />
<input id="hide-rs" onclick="display('rdfxml', 'none');      set_display_by_id('hide-rs', 'none');       set_display_by_id('show-rs', '');" type="button" value="Hide RDF/XML Syntax" />
<input id="show-rs" onclick="display('rdfxml', '');      set_display_by_id('hide-rs', '');       set_display_by_id('show-rs', 'none');" style="display:none" type="button" value="Show RDF/XML Syntax" />
<input id="hide-ts" onclick="display('turtle', 'none');      set_display_by_id('hide-ts', 'none');       set_display_by_id('show-ts', '');" type="button" value="Hide Turtle Syntax" />
<input id="show-ts" onclick="display('turtle', '');      set_display_by_id('hide-ts', '');       set_display_by_id('show-ts', 'none');" style="display:none" type="button" value="Show Turtle Syntax" />
<input id="hide-ms" onclick="display('manchester', 'none');            set_display_by_id('hide-ms', 'none');             set_display_by_id('show-ms', '');" type="button" value="Hide Manchester Syntax" />
<input id="show-ms" onclick="display('manchester','');      set_display_by_id('hide-ms', '');       set_display_by_id('show-ms', 'none');" style="display:none" type="button" value="Show Manchester Syntax" />
<input id="hide-xs" onclick="display('owlxml', 'none');      set_display_by_id('hide-xs', 'none');       set_display_by_id('show-xs', '');" type="button" value="Hide OWL/XML Syntax" />
<input id="show-xs" onclick="display('owlxml', '');      set_display_by_id('hide-xs', '');       set_display_by_id('show-xs', 'none');" style="display:none" type="button" value="Show OWL/XML Syntax" />
</p></form>
</div>
<p>

</p>
<a id="What_is_OWL_2.3F" name="What_is_OWL_2.3F"></a><h2> <span class="mw-headline">2 What is OWL 2?</span></h2>
<p>OWL 2 is a language for expressing <i>ontologies</i>. The term <i>ontology</i> has a complex history both in and out of computer science, but we use it to mean a certain kind of computational artifact &ndash; i.e., something akin to a program, an XML schema, or a web page &ndash; generally presented as a document. An ontology is a set of precise descriptive statements about some part of the world (usually referred to as the <i>domain of interest</i> or the <i>subject matter</i> of the ontology). Precise descriptions satisfy several purposes: most notably, they prevent misunderstandings in human communication and they ensure that software behaves in a uniform, predictable way and works well with other software.
</p><p>In order to precisely describe a domain of interest, it is helpful to come up with a set of central terms &ndash; often called vocabulary &ndash; and fix their meaning. Besides a concise natural language definition, the meaning of a term can be characterized by stating how this term is interrelated to the other terms. A <i>terminology</i>, providing a vocabulary together with such interrelation information constitutes an essential part of a typical OWL 2 document. Besides this terminological knowledge, an ontology might also contain so called assertional knowledge that deals with concrete objects of the considered domain rather than general notions.
</p><p>OWL 2 is not a programming language: OWL 2 is <i>declarative</i>, i.e. it describes a state of affairs in a logical way. Appropriate tools (so-called reasoners) can then be used to infer further information about that state of affairs. How these inferences are realized algorithmically is not part of the OWL document but depends on the specific implementations. Still, the correct answer to any such question is predetermined by the formal semantics (which comes in two versions: the <i>Direct Semantics</i> [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] and the <i>RDF-Based Semantics</i> [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>]). Only implementations that comply with these semantics will be regarded as OWL 2 conformant (see [<cite><a href="#ref-owl-2-conformance" title="">OWL 2 Conformance</a></cite>]). Through its declarative nature, the activity of creating OWL 2 documents is conceptually different from programming. Still, as in both cases complex formal documents are created, certain notions from software engineering can be transferred to ontology engineering, such as methodological and collaborative aspects, modularization, patterns, etc.  
</p><p>OWL 2 is not a schema language for syntax conformance. Unlike XML, OWL 2 does not provide elaborate means to prescribe how a document should be structured syntactically. In particular, there is no way to enforce that a certain piece of information (like the social security number of a person) has to be syntactically present. This should be kept in mind as OWL has some features that a user might misinterpret this way. 
</p><p>OWL 2 is not a database framework. Admittedly, OWL 2 documents store information and so do databases. Moreover a certain analogy between assertional information and database content as well as terminological information and database schemata can be drawn. However, usually there are crucial differences in the underlying assumptions (technically: the used semantics). If some fact is not present in a database, it is usually considered false (the so-called <i>closed-world assumption</i>) whereas in the case of an OWL 2 document it may simply be missing (but possibly true), following the <i>open-world assumption</i>.  Moreover, database schemata often come with the prescriptive constraint semantics mentioned above. Still, technically, databases provide a viable backbone in many ontology-oriented systems.
</p>
<a id="Modeling_Knowledge:_Basic_Notions" name="Modeling_Knowledge:_Basic_Notions"></a><h2> <span class="mw-headline">3  Modeling Knowledge: Basic Notions </span></h2>
<p>OWL 2 is a knowledge representation language, designed to formulate, exchange and reason with knowledge about a domain of interest. Some fundamental notions should first be explained to understand how knowledge is represented in OWL 2. These basic notions are:
</p>
<ul><li> <b>Axioms:</b> the basic statements that an OWL ontology expresses
</li><li> <b>Entities:</b> elements used to refer to real-world objects
</li><li> <b>Expressions:</b> combinations of entities to form complex descriptions from basic ones
</li></ul>
<p><span id="a_Ontology"> </span>
While OWL 2 aims to capture knowledge, the kind of &ldquo;knowledge&rdquo; that can be represented by OWL does of course not reflect all aspects of human knowledge. OWL can be considered as a powerful general-purpose modeling language for certain parts of human knowledge. The results of the modeling processes are called <i>ontologies</i> &ndash; a terminology that also helps to avoid confusion since the term &ldquo;model&rdquo; is often used in a rather different sense in knowledge representation.
</p><p>Now, in order to formulate knowledge explicitly, it is useful to assume that it consists of elementary pieces that are often referred to as <i>statements</i> or <i>propositions</i>. Statements like &ldquo;it is raining&rdquo; or &ldquo;every man is mortal&rdquo; are typical examples for such basic propositions.
Indeed, every OWL&nbsp;2 ontology is essentially just a collection of such basic &ldquo;pieces of knowledge.&rdquo;  Statements that are made in an ontology are called <i>axioms</i> in OWL&nbsp;2, and the ontology asserts that its axioms are true. In general, OWL statements might be either true or false given a certain state of affairs. This distinguishes them from <i>entities</i> and <i>expressions</i> as described further below.
</p><p>When humans think, they draw consequences from their knowledge. An important feature of OWL is that it captures this aspect of human intelligence for the forms of knowledge that it can represent. But what does it mean, generally speaking, that a statement is a consequence of other statements? Essentially it means that this statement is true whenever the other statements are. In OWL terms: we say, a set of statements <i>A</i> <i>entails</i> a statement <i>a</i> if in any state of affairs wherein all statements from <i>A</i> are true, also <i>a</i> is true. Moreover, a set of statements may be <i>consistent</i> (that is, there is a possible state of affairs in which all the statements in the set are jointly true) or <i>inconsistent</i> (there is no such state of affairs). The formal semantics of OWL specifies, in essence, for which possible &ldquo;states of affairs&rdquo; a particular set of OWL statements is true.
</p><p>There are OWL tools &ndash; reasoners &ndash; that can automatically compute consequences. The way ontological axioms interact can be very subtle and difficult for people to understand. This is both a strength and a weakness of OWL&nbsp;2. It is a strength because OWL&nbsp;2 tools can discover information that a person would not have spotted. This allows knowledge engineers to model more directly and the system to provide useful feedback and critique of the modeling. It is a weakness because it is comparatively difficult for humans to immediately foresee the actual effect of various constructs in various combinations. Tool support ameliorates the situation but successful knowledge engineering often still requires some amount of training and experience.
</p><p>Having a closer look at statements in OWL, we see that they are rarely &ldquo;monolithic&rdquo; but more often have some internal structure that can be explicitly represented. They normally refer to objects of the world and describe them e.g. by putting them into categories (like &ldquo;Mary is female&rdquo;) or saying something about their relation (&ldquo;John and Mary are married&rdquo;). All atomic constituents of statements, be they objects (John, Mary), categories (female) or relations (married) are called <i>entities</i>. In OWL&nbsp;2, we denote objects as <i>individuals</i>, categories as <i>classes</i> and relations as <i>properties</i>. Properties in OWL 2 are further subdivided. <i>Object properties</i> relate objects to objects (like a person to their spouse), while <i>datatype properties</i> assign data values to objects (like an age to a person). <i>Annotation properties</i> are used to encode information about (parts of) the ontology itself (like the author and creation date of an axiom) instead of the domain of interest. 
</p><p>As a central feature of OWL, names of entities can be combined into <i>expressions</i> using so called <i>constructors</i>. As a basic example, the atomic classes &ldquo;female&rdquo; and &ldquo;professor&rdquo; could be combined conjunctively to describe the class of female professors. The latter would be described by an OWL class expression, that could be used in statements or in other expressions. In this sense, expressions can be seen as new entities which are defined by their structure. In OWL, the constructors for each sort of entity vary greatly. The expression language for classes is very rich and sophisticated, whereas the expression language for properties is much less so. These differences have historical as well as technical reasons.
</p>
<a id="Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them" name="Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them"></a><h2> <span class="mw-headline">4 Classes, Properties, and Individuals &ndash; And Basic Modeling With Them</span></h2>
<p>After these general considerations, we now engage in the details of modeling with OWL 2. In the subsequent sections, we introduce the essential modeling features that OWL 2 offers, provide examples and give some general comments on how to use them. We proceed from basic features, which are essentially available in any modeling language, to more advanced constructs.
</p><p>Thereby we will represent information about a particular family. Note that we do not
intend this example to be representative of the sorts of domains OWL should be used
for, or as a canonical example of good modeling with OWL, or a correct representation
of the rather complex, shifting, and culturally dependent domain of families. Instead,
we intend it to be a rather simple exhibition of various features of OWL.
</p>
<a id="Classes_and_Instances" name="Classes_and_Instances"></a><h3> <span class="mw-headline">4.1 Classes and Instances</span></h3>
<p><span id="a_ClassAssertion"> </span>
We start by introducing the persons we are talking about. This can be done as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(&nbsp;:Person&nbsp;:Mary ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;Person rdf:about="Mary"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Mary rdf:type&nbsp;:Person .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: Mary
   Types: Person
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
    &lt;Class IRI="Person"/&gt;
    &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><br />
This statement talks about an individual named Mary and states that this individual is a person. More technically, <i>being a person</i> is expressed by stating that Mary belongs to (or &ldquo;is a member of&rdquo; or, even more technically, &ldquo;is an instance of&rdquo;) the <i>class</i> of all persons.
In general classes are used to group individuals that have something in common in order to refer to them. Hence, classes essentially represent sets of individuals. In modeling, classes are often used to denote the set of objects comprised by a concept of human thinking, like the concept <i>person</i> or the concept <i>woman</i>.
Consequently, we can use the same type of statement to indicate that Mary is a woman by expressing that she is an instance of the class of women:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(&nbsp;:Woman&nbsp;:Mary ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;Woman rdf:about="Mary"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Mary rdf:type&nbsp;:Woman .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: Mary
   Types: Woman
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
    &lt;Class IRI="Woman"/&gt;
    &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p>Hereby it also becomes clear that class membership is not exclusive: as there may be diverse criteria to group individuals
(like gender, age, shoe size, etc.), one individual may well belong to several classes simultaneously.
</p>
<a id="Class_Hierarchies" name="Class_Hierarchies"></a><h3> <span class="mw-headline">4.2 Class Hierarchies</span></h3>
<p>In the previous section, we were talking about two classes: the class of all persons and that of all women.  To the human reader it is clear that these two classes are in a special relationship: Person is more general than Woman, meaning that whenever we know some individual to be a woman, that individual must be a person.  However, this correspondence cannot be derived from the labels &ldquo;Person&rdquo; and &ldquo;Woman&rdquo; but is part of the human background knowledge about the world and our usage of those terms.  Therefore, in order to enable a system to draw the desired conclusions, it has to be informed about this correspondence.  <span id="a_SubClassOf"> </span>In OWL 2, this is done by a so-called subclass axiom:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf(&nbsp;:Woman&nbsp;:Person )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Woman"&gt;
   &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Woman rdfs:subClassOf&nbsp;:Person .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Woman
   SubClassOf: Person
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Woman"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>The presence of this axiom in an ontology enables reasoners to infer for every individual which is specified as an instance of the class Woman, that it is an instance of the class Person as well.  As a rule of thumb, a subclass relationship between two classes A and B can be specified, if the phrase &ldquo;every A is a B&rdquo; makes sense and is correct.
</p><p>It is common in ontological modeling to use subclass statements not only for sporadically declaring such interdependencies, but to model whole <i>class hierarchies</i> by specifying the generalization relationships of all classes
in the domain of interest.  Suppose we also want to state that all mothers are women:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf(&nbsp;:Mother&nbsp;:Woman )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Mother"&gt;
   &lt;rdfs:subClassOf rdf:resource="Woman"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Mother rdfs:subClassOf&nbsp;:Woman .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Mother
   SubClassOf: Woman
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Mother"/&gt;
   &lt;Class IRI="Woman"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>Then a reasoner could not only derive for every single individual that is classified as mother,  that it is also a woman (and consequently a person), but also that Mother must be a subclass of Person &ndash; coinciding with our intuition.  Technically, this means that the subclass relationship between classes is <i>transitive</i>.  Besides this, it is also <i>reflexive</i>, meaning that every class is its own subclass &ndash; this is intuitive as well since clearly, every person is a person etc.
</p><p><span id="a_EquivalentClasses"> </span>
</p><p>Classes in our vocabulary may effectively refer to the same sets, and
OWL provides a mechanism by which they are considered to be
semantically equivalent. For example, we use the term Person and Human
interchangeably, meaning that every instance of the class Person is also
an instance of class Human, and vice versa. Two classes are considered equivalent if they contain exactly the same individuals. The following example states that the class Person is equivalent to the class Human.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(&nbsp;:Person&nbsp;:Human )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;owl:equivalentClass rdf:resource="Human"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Person owl:equivalentClass&nbsp;:Human .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Person
   EquivalentTo: Human
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Person"/&gt;
   &lt;Class IRI="Human"/&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>Stating that Person and Human are equivalent amounts exactly to the same as stating that both Person is a subclass of Human and Human is a subclass of Person.
</p>
<a id="Class_Disjointness" name="Class_Disjointness"></a><h3> <span class="mw-headline">4.3 Class Disjointness</span></h3>
<p><span id="a_DisjointClasses"> </span>
In Section 4.1, we stated that an individual can be an instance of several classes. However, in some cases membership in one class
specifically excludes membership in another. For example, if we consider the classes Man and Woman, we know that no individual can be an instance of both classes (for the sake of the example, we disregard biological borderline cases). This &ldquo;incompatibility relationship&rdquo; between classes is referred to as <i>(class) disjointness</i>. Again, the information that two classes are disjoint is part of our background knowledge and has to be explicitly stated for a reasoning system to make use of it. This is done as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DisjointClasses(&nbsp;:Woman&nbsp;:Man )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Woman"/&gt;
     &lt;owl:Class rdf:about="Man"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> []  rdf:type     owl:AllDisjointClasses&nbsp;;
     owl:members  (&nbsp;:Woman &nbsp;:Man ) . 
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> DisjointClasses: Woman, Man
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DisjointClasses&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Man"/&gt;
 &lt;/DisjointClasses&gt;
</pre>
</div>
<p>In practice, disjointness statements are often forgotten or neglected. The arguable reason for this could be that intuitively, classes are considered disjoint unless there is other evidence. By omitting disjointness statements, many potentially useful consequences can get lost. Note that in our example, the disjointness axiom is needed to deduce that Mary is not a man. Moreover, given the above axioms, a reasoner can infer the disjointness of the classes Mother and Man.
</p>
<a id="Object_Properties" name="Object_Properties"></a><h3> <span class="mw-headline">4.4 Object Properties</span></h3>
<p>In the preceding sections we were concerned with describing single individuals, their class memberships, and how classes can relate to each other based on their instances. But more often than not, an ontology is also meant to specify how the individuals relate to other individuals. These relationships are central when describing a family. <span id="a_ObjectPropertyAssertion"> </span>We start by indicating that Mary is John's wife.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:John&nbsp;:Mary )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;hasWife rdf:resource="Mary"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John&nbsp;:hasWife&nbsp;:Mary .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Facts: hasWife Mary
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ObjectPropertyAssertion&gt;
</pre>
</div>
<p>Hereby, the entities describing in which way the individuals are related &ndash; like hasWife in our case, are called <i>properties.</i>
</p><p>Note that the order in which the individuals are written is important. While &ldquo;Mary is John's wife&rdquo; might be true, &ldquo;John is Mary's wife&rdquo; certainly isn't. Indeed, this is a common source of modeling errors that can be avoided by using property names which allow only one unique intuitive reading.
In case of nouns (like &ldquo;wife&rdquo;), such unambiguous names might be constructions with &ldquo;of&rdquo; or with &ldquo;has&rdquo; (wifeOf or hasWife). For verbs (like &ldquo;to love&rdquo;) an inflected form (loves) or a passive version with &ldquo;by&rdquo; (lovedBy) would prevent unintended readings.
</p><p><span id="a_NegativeObjectPropertyAssertion"> </span>
We can also state that two individuals are <i>not</i> connected by a property. The following, for example, states that Mary is not Bill's wife.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> NegativeObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:Bill&nbsp;:Mary )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasWife"/&gt;
   &lt;owl:targetIndividual rdf:resource="Mary"/&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Bill&nbsp;;
     owl:assertionProperty &nbsp;:hasWife&nbsp;;
     owl:targetIndividual  &nbsp;:Mary .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: Bill
   Facts: not hasWife Mary
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;NegativeObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/NegativeObjectPropertyAssertion&gt;
</pre>
</div>
<p>Negative property assertions provide a unique opportunity to make
statements where we know something that is not true. This kind of
information is particularly important in OWL where the default stance is
that anything is possible until you say otherwise.
</p>
<a id="Property_Hierarchies" name="Property_Hierarchies"></a><h3> <span class="mw-headline">4.5 Property Hierarchies</span></h3>
<p><span id="a_topObjectProperty"> </span>
<span id="a_bottomObjectProperty"> </span>
<span id="a_topDataProperty"> </span>
<span id="a_bottomDataProperty"> </span>
</p><p><span id="a_SubObjectPropertyOf"> </span>
In Section 4.2 we argued that it is useful to specify that one class membership implies another one. Essentially the same situation can occur for properties: whenever B is known to be A's wife, it is also known to be A's spouse (note, that this is not true the other way round). OWL allows to specify this statement as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubObjectPropertyOf(&nbsp;:hasWife&nbsp;:hasSpouse )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
   &lt;rdfs:subPropertyOf rdf:resource="hasSpouse"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasWife rdfs:subPropertyOf&nbsp;:hasSpouse .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasWife
   SubPropertyOf: hasSpouse
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubObjectPropertyOf&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<p><span id="a_SubDataPropertyOf"></span><span id="a_SubAnnotationPropertyOf"></span>
<span id="a_EquivalentObjectProperties"></span><span id="a_EquivalentDataProperties"></span>
There is also a syntactic shortcut for property equivalence, which is similar to class equivalence.
</p>
<a id="Domain_and_Range_Restrictions" name="Domain_and_Range_Restrictions"></a><h3> <span class="mw-headline">4.6 Domain and Range Restrictions</span></h3>
<p><span id="a_ObjectPropertyDomain"> </span><span id="a_ObjectPropertyRange"> </span>
Frequently, the information that two individuals are interconnected by a certain property allows to draw further conclusions about the individuals themselves. In particular, one might infer class memberships. For instance, the statement that B is the wife of A obviously implies that B is a woman while A is a man. So in a way, the statement that two individuals are related via a certain property carries implicit additional information about these individuals. In our example, this additional information can be expressed via class memberships. OWL provides a way to state this correspondence: 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ObjectPropertyDomain(&nbsp;:hasWife&nbsp;:Man ) 
 ObjectPropertyRange(&nbsp;:hasWife&nbsp;:Woman ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
   &lt;rdfs:domain rdf:resource="Man"/&gt;
   &lt;rdfs:range rdf:resource="Woman"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasWife rdfs:domain&nbsp;:Man&nbsp;;
          rdfs:range &nbsp;:Woman .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasWife
   Domain: Man
   Range: Woman
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ObjectPropertyDomain&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;Class IRI="Man"/&gt;
 &lt;/ObjectPropertyDomain&gt;
 &lt;ObjectPropertyRange&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;Class IRI="Woman"/&gt;
 &lt;/ObjectPropertyRange&gt;
</pre>
</div>
<p>Having these two axioms in place and given e.g. the information that Sasha is related to Hillary via the property hasWife, a reasoner would be able to infer that Sasha is a man and Hillary a woman.
</p>
<a id="Equality_and_Inequality_of_Individuals" name="Equality_and_Inequality_of_Individuals"></a><h3> <span class="mw-headline">4.7 Equality and Inequality of Individuals</span></h3>
<p>Note that from the information given so far, it can be deduced that John and Mary are not the same individual as they are known to be instances of the disjoint classes Man and Woman, respectively. However, if we add information about another family member, say Bill, and indicate that he is a man, then there is nothing said so far that implies that John and Bill are not the same. OWL does not make the assumption that different names are names for different individuals. (This lack of a required &ldquo;unique names assumption&rdquo; is particularly well-suited to Semantic Web applications where names may be coined by different organizations at different times unknowingly referring to the same individual.) <span id="a_DifferentIndividuals"> </span>Hence, if we want to exclude the option of John and Bill being the same individual, this has to be explicitly specified as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DifferentIndividuals(&nbsp;:John&nbsp;:Bill )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;owl:differentFrom rdf:resource="Bill"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John owl:differentFrom&nbsp;:Bill .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John 
   DifferentFrom: Bill 
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DifferentIndividuals&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
 &lt;/DifferentIndividuals&gt;
</pre>
</div>
<p><span id="a_SameIndividual"> </span>
It is also possible to state that two names refer to (denote) the same individual. For example, we can say that James and Jim are the same individual.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SameIndividual(&nbsp;:James&nbsp;:Jim )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="James"&gt;
   &lt;owl:sameAs rdf:resource="Jim"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:James owl:sameAs&nbsp;:Jim.
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: James
   SameAs: Jim
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="James"/&gt;
   &lt;NamedIndividual IRI="Jim"/&gt;
 &lt;/SameIndividual&gt;
</pre>
</div>
<p>This would enable a reasoner to infer that any information given about the individual James also holds for the individual Jim.
</p>
<a id="Datatypes" name="Datatypes"></a><h3> <span class="mw-headline">4.8  Datatypes </span></h3>
<p>So far, we have seen how we can describe individuals via class memberships and via their relationships to other individuals. In many cases, however, individuals are to be described by data values. Think of a person's birth date, his age, his email address etc.  
For this purpose, OWL provides another kind of properties, so-called <span id="a_DataProperty"><i>Datatype properties</i></span>. These properties relate individuals to data values (instead of to other individuals), and many of the XML Schema datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>] can be used. <span id="a_DataPropertyAssertion"> </span>The following is an example using a datatype property. It states that John's age is 51.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DataPropertyAssertion(&nbsp;:hasAge&nbsp;:John "51"^^xsd:integer )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;Person rdf:about="John"&gt;
   &lt;hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;51&lt;/hasAge&gt;
 &lt;/Person&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John &nbsp;:hasAge  51 .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Facts: hasAge "51"^^xsd:integer
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DataPropertyAssertion&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;51&lt;/Literal&gt;
 &lt;/DataPropertyAssertion&gt;
</pre>
</div>
<p><span id="a_NegativeDataPropertyAssertion"> </span>
Likewise, we can state that Jack's age is <i>not</i> 53.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> NegativeDataPropertyAssertion(&nbsp;:hasAge&nbsp;:Jack "53"^^xsd:integer )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Jack"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasAge"/&gt;
   &lt;owl:targetValue rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;
     53
   &lt;/owl:targetValue&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Jack&nbsp;;
     owl:assertionProperty &nbsp;:hasAge&nbsp;;
     owl:targetValue        53 .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: Jack
   Facts: not hasAge "53"^^xsd:integer
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;NegativeDataPropertyAssertion&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;53&lt;/Literal&gt;
 &lt;/NegativeDataPropertyAssertion&gt;
</pre>
</div>
<p><span id="a_DataPropertyDomain"> </span><span id="a_DataPropertyRange"> </span>
Domain and range can also be stated for datatype properties as it is done for object properties. In that case, however, the range will be a datatype instead of a class. The following states that the hasAge property is only used to relate persons with non-negative integers. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DataPropertyDomain(&nbsp;:hasAge&nbsp;:Person ) 
 DataPropertyRange(&nbsp;:hasAge xsd:nonNegativeInteger ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
   &lt;rdfs:domain rdf:resource="Person"/&gt;
   &lt;rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"/&gt;
 &lt;/owl:DatatypeProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasAge  rdfs:domain &nbsp;:Person&nbsp;;
          rdfs:range   xsd:nonNegativeInteger .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> DataProperty: hasAge
   Domain: Person
   Range:  xsd:nonNegativeInteger
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DataPropertyDomain&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/DataPropertyDomain&gt;
 &lt;DataPropertyRange&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"/&gt;
 &lt;/DataPropertyRange&gt;
</pre>
</div>
<p>We would like to point out at this stage a common mistake which easily occurs when using property domains and ranges. In the example just given, which states that the hasAge property is only used to relate persons with non-negative integers, assume that we also specify the information that Felix is in the class Cat and that Felix hasAge 9. From the combined information, it would then be possible to deduce that Felix is also in the class Person, which is probably not intended. This is a commonly modeling error: note that a domain (or range) statement is not a constraint on the knowledge, but allows a reasoner to infer further knowledge. If we state &ndash; as in our example &ndash; that an age is only given for persons, then everything we give an age for automatically becomes a person.
</p>
<a id="Advanced_Class_Relationships" name="Advanced_Class_Relationships"></a><h2> <span class="mw-headline">5 Advanced Class Relationships</span></h2>
<p>In the previous sections we have dealt with classes as something &ldquo;opaque&rdquo; carrying a name. We used them to characterize  individuals, and related them to other classes via subclass or disjointness statements.
</p><p>We will now demonstrate how named classes, properties, and individuals can be used as building blocks to define new classes. 
</p>
<a id="Complex_Classes" name="Complex_Classes"></a><h3> <span class="mw-headline">5.1 Complex Classes</span></h3>
<p>By means of the language elements described so far, simple ontologies can be modeled. In order to express more complex knowledge, OWL provides logical class constructors. In particular, OWL provides language elements for logical and, or, and not. The corresponding OWL terms are borrowed from set theory: <i>(class) intersection</i>, <i>union</i> and <i>complement</i>. These constructors combine atomic classes &ndash; i.e. classes with names &ndash; to complex classes. 
</p><p><span id="a_ObjectIntersectionOf"> </span>
The <i>intersection</i> of two classes consists of exactly those individuals which are instances of both classes. The following example states that the class Mother consists of exactly those objects which are instances of both Woman and Parent:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Mother 
   ObjectIntersectionOf(&nbsp;:Woman&nbsp;:Parent )
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Mother"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Woman"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Mother  owl:equivalentClass  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Woman&nbsp;:Parent ) 
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Mother
   EquivalentTo: Woman and Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Mother"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>An example for an inference which can be drawn from this is that all instances of the class Mother are also in the class Parent. 
</p><p><span id="a_ObjectUnionOf"> </span>
The <i>union</i> of two classes contains every individual which is contained in at least one of these classes. Therefore we could characterize the class of all parents as the union of the classes Mother and Father:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Parent 
   ObjectUnionOf(&nbsp;:Mother&nbsp;:Father )
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:unionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Mother"/&gt;
         &lt;owl:Class rdf:about="Father"/&gt;
       &lt;/owl:unionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Parent  owl:equivalentClass  [
   rdf:type     owl:Class&nbsp;;
   owl:unionOf  (&nbsp;:Mother&nbsp;:Father )
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Parent
   EquivalentTo: Mother or Father
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectUnionOf&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="Father"/&gt;
   &lt;/ObjectUnionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_ObjectComplementOf"> </span>
The <i>complement</i> of a class corresponds to logical negation: it consists of exactly those objects which are not members of the class itself. The following definition of childless persons uses the class complement and also demonstrates that class constructors can be nested:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:ChildlessPerson 
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(&nbsp;:Parent )
   )
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="ChildlessPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf rdf:resource="Parent"/&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:ChildlessPerson  owl:equivalentClass  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person  
                         [ rdf:type          owl:Class&nbsp;;
                           owl:complementOf &nbsp;:Parent ] ) 
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: ChildlessPerson
   EquivalentTo: Person and not Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;ObjectComplementOf&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>All the above examples demonstrate the usage of class constructors in order to <i>define</i> new classes as combination of others. But, of course, it is also possible to use class constructors together with a subclass statement in order to indicate necessary, but not sufficient, conditions for a class. The following statement indicates that every Grandfather is both a man and a parent (whereas the converse is not necessarily true):
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf( 
  &nbsp;:Grandfather 
   ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Grandfather"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Man"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Grandfather  rdfs:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Grandfather
   SubClassOf: Man and Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Grandfather"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>In general, complex classes can be used in every place where named classes can occur, hence also in class assertions. This is demonstrated by the following example which asserts that Jack is a person but not a parent.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(&nbsp;:Parent )
   ) 
  &nbsp;:Jack
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="Jack"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf  rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf rdf:resource="Parent"/&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Jack  rdf:type  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person  
                         [ rdf:type          owl:Class&nbsp;;
                           owl:complementOf &nbsp;:Parent     ]
                       )
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: Jack
   Types: Person and not Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectIntersectionOf&gt;
    &lt;Class IRI="Person"/&gt;
    &lt;ObjectComplementOf&gt;
      &lt;Class IRI="Parent"/&gt;
    &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
   &lt;NamedIndividual IRI="Jack"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<a id="Property_Restrictions" name="Property_Restrictions"></a><h3> <span class="mw-headline">5.2 Property Restrictions</span></h3>
<p>Property restrictions provide another type of logic-based constructors for complex classes. As the name suggests, property restrictions use constructors involving properties.
</p><p><span id="a_ObjectSomeValuesFrom"> </span>
One property restriction called <i>existential quantification</i> defines a class as the set of all individuals that are connected via a particular property to another individual which is an instance of a certain class. This is best explained by an example, like the following which defines the class of parents as the class of individuals that are linked to a person by the hasChild property.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Parent 
   ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:Person )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Parent  owl:equivalentClass  [
   rdf:type            owl:Restriction&nbsp;;
   owl:onProperty     &nbsp;:hasChild&nbsp;;
   owl:someValuesFrom &nbsp;:Person
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Parent
   EquivalentTo: hasChild some Person
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectSomeValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/ObjectSomeValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>This means that there is an expectation that for every instance of
Parent, there exists at least one child, and that child is a member of
the class Person. This is useful to capture <i>incomplete</i>
knowledge<i>. For example, Sally tells us that Bob is a parent,</i>
and therefore we can infer that he has at least one child even if we don't know
their name. Natural language indicators for the usage of existential quantification are words like &ldquo;some,&rdquo; or &ldquo;one.&rdquo;
</p><p><span id="a_ObjectAllValuesFrom"> </span>
Another property restriction, called <i>universal quantification</i> is used to describe a class of individuals for which all related individuals must be instances of a given class. We can use the following statement to indicate that somebody is a happy person exactly if all their children are happy persons.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:HappyPerson 
   ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:Class rdf:about="HappyPerson"/&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:HappyPerson  rdf:type    owl:Class&nbsp;;
     owl:equivalentClass  [
       rdf:type           owl:Restriction&nbsp;;
       owl:onProperty    &nbsp;:hasChild&nbsp;;
       owl:allValuesFrom &nbsp;:Happy
     ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: HappyPerson
   EquivalentTo: hasChild only HappyPerson
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="HappyPerson"/&gt;
   &lt;ObjectAllValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Happy"/&gt;
   &lt;/ObjectAllValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>This example also shows that OWL statements are allowed to be in a certain way self-referential; the class HappyPerson is used on both sides of the equivalence statement.
</p><p>The usage of property restrictions may cause some conceptual confusion to &ldquo;modeling beginners.&rdquo; As a rule of thumb, when
translating a natural language statement into a logical axiom, existential quantification occurs far more frequently. Natural language indicators for the usage of universal quantification are words like &ldquo;only,&rdquo; &ldquo;exclusively,&rdquo; or &ldquo;nothing but.&rdquo;
</p><p>There is one particular misconception concerning the universal role restriction. As an example, consider the above happiness axiom. The intuitive reading suggests that in order to be happy, a person must have at least one happy child. Yet, this is not the case: any individual that is not a &ldquo;starting point&rdquo; of the property hasChild is a class member of any class defined by universal quantification over hasChild. Hence, by our above statement, every childless person would be qualified as happy. In order to formalize the aforementioned intended reading, the statement would have to read as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:HappyPerson 
   ObjectIntersectionOf(
     ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
     ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
   )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:Class rdf:about="HappyPerson"/&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
         &lt;/owl:Restriction&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:someValuesFrom rdf:resource="HappyPerson"/&gt;
         &lt;/owl:Restriction&gt;
        &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:HappyPerson  rdf:type    owl:Class&nbsp;;
     owl:equivalentClass  [
       rdf:type            owl:Class&nbsp;;
       owl:intersectionOf  ( [ rdf:type            owl:Restriction&nbsp;;
                               owl:onProperty     &nbsp;:hasChild&nbsp;;
                               owl:allValuesFrom  &nbsp;:Happy            ]
                             [ rdf:type            owl:Restriction&nbsp;;
                               owl:onProperty     &nbsp;:hasChild&nbsp;;
                               owl:someValuesFrom &nbsp;:Happy            ]
                           )
     ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: HappyPerson
   EquivalentTo: hasChild only HappyPerson and hasChild some HappyPerson
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="HappyPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="HappyPerson"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="HappyPerson"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>This example also illustrates how property restrictions can be nested with complex classes.
</p><p><span id="a_ObjectHasValue"> </span>
Property restrictions can also be used to describe classes of individuals that are related to one particular individual. For instance we could define the class of John's children:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses( 
  &nbsp;:JohnsChildren 
   ObjectHasValue(&nbsp;:hasParent&nbsp;:John )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="JohnsChildren"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasParent"/&gt;
       &lt;owl:hasValue rdf:resource="John"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:JohnsChildren  owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:hasParent&nbsp;;
   owl:hasValue   &nbsp;:John
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: JohnsChildren
   EquivalentTo: hasParent value John
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="JohnsChildren"/&gt;
   &lt;ObjectHasValue&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ObjectHasValue&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_ObjectHasSelf"> </span>
As a special case of individuals being interlinked by properties, an individual might be linked to itself. The following example shows how to represent the idea that all narcissists love themselves. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:NarcisticPerson 
   ObjectHasSelf(&nbsp;:loves ) 
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="NarcisticPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="loves"/&gt;
       &lt;owl:hasSelf rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;
         true
       &lt;/owl:hasSelf&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:NarcisticPerson owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:loves&nbsp;;
   owl:hasSelf     "true"^^xsd:boolean .
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: NarcisticPerson
   EquivalentTo: loves Self
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;ObjectHasSelf&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/ObjectHasSelf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<a id="Property_Cardinality_Restrictions" name="Property_Cardinality_Restrictions"></a><h3> <span class="mw-headline">5.3 Property Cardinality Restrictions</span></h3>
<p>Using universal quantification, we can say something about all of somebody's children, whereas existential quantification allows us to  refer to (at least) one of them. However, we might want to specify the number of individuals involved in the restriction. Indeed, we can construct classes depending on the number of children. <span id="a_ObjectMaxCardinalityQualified"> </span>The following example states that John has at most four children who are themselves parents:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(
   ObjectMaxCardinality( 4&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:maxQualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         4
       &lt;/owl:maxQualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                     owl:Restriction&nbsp;;
   owl:maxQualifiedCardinality  "4"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty              &nbsp;:hasChild&nbsp;;
   owl:onClass                 &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Types: hasChild max 4 Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectMaxCardinality cardinality="4"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectMaxCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p>Note that this statement allows John to have arbitrarily many further children who are not parents. 
</p><p><span id="a_ObjectMinCardinalityQualified"> </span>
Likewise, it is also possible to declare a minimum number by saying that John is an instance of the class of individuals having at least two children who are parents:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(
   ObjectMinCardinality( 2&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:minQualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         2
       &lt;/owl:minQualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                     owl:Restriction&nbsp;;
   owl:minQualifiedCardinality  "2"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty              &nbsp;:hasChild&nbsp;;
   owl:onClass                 &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Types: hasChild min 2 Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectMinCardinality cardinality="2"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectMinCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><span id="a_ObjectExactCardinalityQualified"> </span>
If we happen to know the exact number of John's children who are parents, this can be specified as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion( 
   ObjectExactCardinality( 3&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:qualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         3
       &lt;/owl:qualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                  owl:Restriction&nbsp;;
   owl:qualifiedCardinality  "3"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty           &nbsp;:hasChild&nbsp;;
   owl:onClass              &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Types: hasChild exactly 3 Parent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectExactCardinality cardinality="3"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectExactCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><span id="a_ObjectExactCardinality"> </span>
In a cardinality restriction, providing the class is optional; if we just want to talk about the number of all of John's children we can write the following:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ClassAssertion(
   ObjectExactCardinality( 5&nbsp;:hasChild ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:cardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         5
       &lt;/owl:cardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type         owl:Restriction&nbsp;;
   owl:cardinality  "5"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty  &nbsp;:hasChild
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
   Types: hasChild exactly 5
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectExactCardinality cardinality="5"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/ObjectExactCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<a id="Enumeration_of_Individuals" name="Enumeration_of_Individuals"></a><h3> <span class="mw-headline">5.4 Enumeration of Individuals</span></h3>
<p><span id="a_ObjectOneOf"> </span>
A very straightforward way to describe a class is just to enumerate all its instances. OWL provides this possibility, e.g. we can create a class of birthday guests:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:MyBirthdayGuests
   ObjectOneOf(&nbsp;:Bill&nbsp;:John&nbsp;:Mary)
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="MyBirthdayGuests"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:oneOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="Bill"/&gt;
         &lt;rdf:Description rdf:about="John"/&gt;
         &lt;rdf:Description rdf:about="Mary"/&gt;
       &lt;/owl:oneOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:MyBirthdayGuests  owl:equivalentClass  [
   rdf:type   owl:Class&nbsp;;
   owl:oneOf  (&nbsp;:Bill &nbsp;:John &nbsp;:Mary )
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: MyBirthdayGuests
   EquivalentTo: { Bill, John, Mary }
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="MyBirthdayGuests"/&gt;
   &lt;ObjectOneOf&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ObjectOneOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>Note that this axiom provides more information than simply asserting class membership of Bill, John, and Mary as described in Section 4.1. In addition to that, it also stipulates that Bill, John, and Mary are the <i>only</i> members of MyBirthdayGuests. Therefore, classes defined this way are sometimes referred to as <i>closed classes</i> or enumerated sets. If we now assert Jeff as an instance of MyBirthdayGuests, the consequence is that Jeff must be equal to one of the above three persons.
</p>
<a id="Advanced_Use_of_Properties" name="Advanced_Use_of_Properties"></a><h2> <span class="mw-headline">6 Advanced Use of Properties</span></h2>
<p>Until now we focused on classes and properties that were merely used as building blocks for class expressions. In the following, we will see what other modeling capabilities with properties OWL 2 offers. 
</p>
<a id="Property_Characteristics" name="Property_Characteristics"></a><h3> <span class="mw-headline">6.1 Property Characteristics</span></h3>
<p><span id="a_InverseObjectProperties"> </span>
Sometimes one property can be obtained by taking another property and changing its direction, i.e. inverting it. For example, the property hasParent can be defined as the inverse property of hasChild:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> InverseObjectProperties(&nbsp;:hasParent&nbsp;:hasChild ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasParent"&gt;
   &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasParent owl:inverseOf&nbsp;:hasChild .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasParent
   InverseOf: hasChild
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;InverseObjectProperties&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
 &lt;/InverseObjectProperties&gt;
</pre>
</div>
<p>This would for example allow to deduce for arbitrary individuals A and B, where A is linked to B by the hasChild property, that B and A are also interlinked by the hasParent property. <span id="a_ObjectInverseOf"> </span>However, we do not need to explicitly assign a name to the inverse of a property if we just want to use it, say, inside a class expression. Instead of using the new hasParent property for the definition of the class Orphan, we can directly refer to it as the hasChild-inverse:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Orphan
   ObjectAllValuesFrom(
     ObjectInverseOf(&nbsp;:hasChild )
    &nbsp;:Dead
   )
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Orphan"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty&gt;
         &lt;owl:ObjectProperty&gt;
           &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
         &lt;/owl:ObjectProperty&gt;
       &lt;/owl:onProperty&gt;
       &lt;owl:allValuesFrom rdf:resource="Dead"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Orphan  owl:equivalentClass  [
   rdf:type           owl:Restriction&nbsp;;
   owl:onProperty     [ owl:inverseOf &nbsp;:hasChild ]&nbsp;;
   owl:allValuesFrom &nbsp;:Dead 
 ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Orphan
   EquivalentTo: inverse hasChild only Dead
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Orphan"/&gt;
   &lt;ObjectAllValuesFrom&gt;
     &lt;ObjectInverseOf&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectInverseOf&gt;
     &lt;Class IRI="Dead"/&gt;
   &lt;/ObjectAllValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_SymmetricObjectProperty"> </span>
In some cases, a property and its inverse coincide, or in other words, the direction of a property doesn't matter. For instance the property hasSpouse relates A with B exactly if it relates B with A. For obvious reasons, a property with this characteristic is called <i>symmetric</i>, and it can be specified as follows
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SymmetricObjectProperty(&nbsp;:hasSpouse ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:SymmetricProperty rdf:about="hasSpouse"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasSpouse  rdf:type  owl:SymmetricProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasSpouse
   Characteristics: Symmetric
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SymmetricObjectProperty&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/SymmetricObjectProperty&gt;
</pre>
</div>
<p><span id="a_AsymmetricObjectProperty"> </span>
On the other hand, a property can also be <i>asymmetric</i> meaning that if it connects A with B it never connects B with A. Clearly (excluding paradoxical scenarios resulting from time travels), this is the case for the property hasChild and is expressed like this: 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> AsymmetricObjectProperty(&nbsp;:hasChild ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:AsymmetricProperty rdf:about="hasChild"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasChild  rdf:type  owl:AsymmetricProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasChild
   Characteristics: Asymmetric
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;AsymmetricObjectProperty&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
 &lt;/AsymmetricObjectProperty&gt;
</pre>
</div>
<p>Note that being asymmetric is a much stronger notion than being non-symmetric. Likewise, being symmetric is a much stronger notion than being non-asymmetric.
</p><p><span id="a_DisjointObjectProperties"> </span>
Previously, we considered subproperties in analogy to subclasses. It turns out that it also make sense to transfer the notion of class disjointness to properties: two properties are disjoint if there are no two individuals that are interlinked by both properties. Following common law, we can thus state that parent-child marriages cannot occur:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DisjointObjectProperties(&nbsp;:hasParent&nbsp;:hasSpouse )  
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="hasParent"&gt;
   &lt;owl:propertyDisjointWith rdf:resource="hasSpouse"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasParent  owl:propertyDisjointWith &nbsp;:hasSpouse .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> DisjointProperties: hasParent, hasSpouse
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DisjointObjectProperties&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/DisjointObjectProperties&gt;
</pre>
</div>
<p><span id="a_ReflexiveObjectProperty"> </span>
Properties can also be <i>reflexive</i>: such a property relates everything to itself. For the following example, note that everybody has himself as a relative.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> ReflexiveObjectProperty(&nbsp;:hasRelative )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:ReflexiveProperty rdf:about="hasRelative"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasRelative  rdf:type  owl:ReflexiveProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasRelative
   Characteristics: Reflexive
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;ReflexiveObjectProperty&gt;
   &lt;ObjectProperty IRI="hasRelative"/&gt;
 &lt;/ReflexiveObjectProperty&gt;
</pre>
</div>
<p>Note that this does not necessarily mean that every two individuals which are related by a reflexive property are identical. 
</p><p><span id="a_IrreflexiveObjectProperty"> </span>
Properties can furthermore be <i>irreflexive</i>, meaning that no individual can be related to itself by such a role. A typical example is the following which simply states that nobody can be his own parent.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> IrreflexiveObjectProperty(&nbsp;:parentOf )   
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:IrreflexiveProperty rdf:about="parentOf"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:parentOf  rdf:type  owl:IrreflexiveProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: parentOf
   Characteristics: Irreflexive
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;IrreflexiveObjectProperty&gt;
   &lt;ObjectProperty IRI="parentOf"/&gt;
 &lt;/IrreflexiveObjectProperty&gt;
</pre>
</div>
<p>Next, consider the hasHusband property. As every person can have only one husband (which we take for granted for the sake of the example), every individual can be linked by the hasHusband property to at most one other individual. <span id="a_FunctionalObjectProperty"> </span>This kind of properties are called <i>functional</i> and are described as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> FunctionalObjectProperty(&nbsp;:hasHusband ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:FunctionalProperty rdf:about="hasHusband"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasHusband  rdf:type  owl:FunctionalProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasHusband
   Characteristics: Functional
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;FunctionalObjectProperty&gt;
   &lt;ObjectProperty IRI="hasHusband"/&gt;
 &lt;/FunctionalObjectProperty&gt;
</pre>
</div>
<p>Note that this statement does not require every individual to have a husband, it just states that there can be no more than one. Moreover, if we additionally had a statement that Mary's husband is James and another that Mary's husband is Jim, it could be inferred that Jim and James must refer to the same individual.
</p><p><span id="a_InverseFunctionalObjectProperty"> </span>It is also possible to indicate that the inverse of a given property is functional:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> InverseFunctionalObjectProperty(&nbsp;:hasHusband ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:InverseFunctionalProperty rdf:about="hasHusband"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasHusband  rdf:type  owl:InverseFunctionalProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasHusband
   Characteristics: InverseFunctional
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;InverseFunctionalObjectProperty&gt;
   &lt;ObjectProperty IRI="hasHusband"/&gt;
 &lt;/InverseFunctionalObjectProperty&gt;
</pre>
</div>
<p>This indicates that an individual can be husband of at most one other individual. The example also indicates the difference between functionality and inverse functionality, as in a polygynous situation the former axiom is valid whereas the latter isn't.
</p><p><span id="a_TransitiveObjectProperty"> </span>
Now have a look at a property hasAncestor which is meant to link individuals A and B whenever A is a direct descendant of B. Clearly, the property hasParent is a &ldquo;special case&rdquo; of hasAncestor and can be defined as a subproperty thereof. Still, it would be nice to "automatically" include parents of parents (and parents of parents of parents). This can be done by defining hasAncestor as <i>transitive</i> property. A transitive property interlinks two individuals A and C whenever it interlinks A with B and B with C for some individual B.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> TransitiveObjectProperty(&nbsp;:hasAncestor )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:TransitiveProperty rdf:about="hasAncestor"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasAncestor  rdf:type  owl:TransitiveProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasAncestor
   Characteristics: Transitive
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;TransitiveObjectProperty&gt;
   &lt;ObjectProperty IRI="hasAncestor"/&gt;
 &lt;/TransitiveObjectProperty&gt;
</pre>
</div>
<a id="Property_Chains" name="Property_Chains"></a><h3> <span class="mw-headline">6.2 Property Chains</span></h3>
<p><span id="a_SubObjectPropertyOfChain"> </span>
While the last example from the previous section implied the presence of an hasAncestor property whenever there is a chain of hasParent properties, we might want to be a bit more specific and define, say, a hasGrandparent property instead. Technically, this means that we want hasGrandparent to connect all individuals that are linked by a chain of exactly two hasParent properties. In contrast to the previous hasAncestor example, we do not want hasParent to be a special case of hasGrandparent nor do we want hasGrandparent to refer to great-grandparents etc. We can express that every such chain has to be spanned by a hasGrandparent property as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasParent&nbsp;:hasParent ) 
  &nbsp;:hasGrandparent 
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="hasGrandparent"&gt;
       &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
               &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
               &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
       &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasGrandparent  owl:propertyChainAxiom  (&nbsp;:hasParent &nbsp;:hasParent ) .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> ObjectProperty: hasGrandparent
   SubPropertyChain: hasParent o hasParent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasGrandparent"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="Keys" name="Keys"></a><h3> <span class="mw-headline">6.3  Keys </span></h3>
<p><span id="a_HasKey"> </span>
In OWL 2 a collection of (data or object) properties can be assigned as a key to a class expression. This means that each named instance of the class expression is uniquely identified by the set of values which these properties attain in relation to the instance. 
</p><p>A simple example of this would be the identification of a person by her social security number.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> HasKey(&nbsp;:Person () (&nbsp;:hasSSN ) )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;owl:hasKey rdf:parseType="Collection"&gt;
     &lt;owl:DataProperty rdf:about="hasSSN"/&gt;
   &lt;/owl:hasKey&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Person owl:hasKey (&nbsp;:hasSSN ) .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Person
   HasKey: hasSSN
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;HasKey&gt;
   &lt;Class IRI="Person"/&gt;
   &lt;DataProperty IRI="hasSSN"/&gt;
 &lt;/HasKey&gt;
</pre>
</div>
<a id="Advanced_Use_of_Datatypes" name="Advanced_Use_of_Datatypes"></a><h2> <span class="mw-headline">7 Advanced Use of Datatypes</span></h2>
<p>In Section 4.8, we learned that individuals can be endowed with numerical information, essentially by connecting them to a data value via a datatype property &ndash; just like object properties link to other domain individuals. In fact, these parallels extend to the more advanced features of datatype usage. 
</p><p>First of all, data values are grouped into datatypes and we have seen in Section 4.8 how a range restriction on a datatype property can be used to indicate the kind of values this property can link to. Moreover, it is possible to express and define new datatypes by constraining or combining existing ones. 
<span id="a_DatatypeRestriction"> </span>
Datatypes can be restricted via so-called <i>facets</i>, borrowed from XML Schema Datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>]. In the following example, we define a new datatype for a person's age by constraining the datatype integer to values between (inclusively) 0 and 150. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:personAge
   DatatypeRestriction( xsd:integer           
     xsd:minInclusive "0"^^xsd:integer
     xsd:maxInclusive "150"^^xsd:integer
   )
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="personAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:onDatatype rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/&gt;
       &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
         &lt;rdf:Description&gt;
           &lt;xsd:minInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;0&lt;/xsd:minInclusive&gt;
         &lt;/rdf:Description&gt;
         &lt;rdf:Description&gt;
           &lt;xsd:maxInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;150&lt;/xsd:maxInclusive&gt; 
         &lt;/rdf:Description&gt;         
       &lt;/owl:withRestrictions&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:personAge  owl:equivalentClass
  [ rdf:type  rdfs:Datatype;
    owl:onDatatype  xsd:integer;
    owl:withRestrictions (
       [ xsd:minInclusive  "0"^^xsd:integer ]
       [ xsd:maxInclusive  "150"^^xsd:integer ] 
    )
  ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Datatype: personAge
   EquivalentTo: integer[&lt;= 0 , &gt;= 150]
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="personAge"/&gt;
    &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#integer"/&gt;
       &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#minInclusive"&gt;
         &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#maxInclusive"&gt;
         &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;150&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
    &lt;/DatatypeRestriction&gt;
  &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p><span id="a_DataComplementOf"> </span>
<span id="a_DataIntersectionOf"> </span>
<span id="a_DataUnionOf"> </span>
Likewise, datatypes can be combined just like classes by complement, intersection and union. Thereby, assuming we have already defined a datatype minorAge, we can define the datatype majorAge by excluding all data values of minorAge from personAge:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:majorAge
   DataIntersectionOf(
    &nbsp;:personAge 
     DataComplementOf(&nbsp;:minorAge ) 
   ) 
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="majorAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="personAge"/&gt;
         &lt;rdfs:Datatype&gt;
           &lt;owl:datatypeComplementOf rdf:resource="minorAge"/&gt; 
         &lt;/rdfs:Datatype&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt; 
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:majorAge  owl:equivalentClass
   [ rdf:type  rdfs:Datatype;
     owl:intersectionOf (
       &nbsp;:personAge
        [ rdf:type  rdfs:Datatype;
          owl:datatypeComplementOf &nbsp;:minorAge ] 
     )
   ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Datatype: majorAge
    EquivalentTo: personAge and not minorAge
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="majorAge"/&gt;
    &lt;DataIntersectionOf&gt;
       &lt;Datatype IRI="personAge"/&gt;
       &lt;DataComplementOf&gt;
         &lt;Datatype IRI="minorAge"/&gt;
       &lt;/DataComplementOf&gt;
    &lt;/DataIntersectionOf&gt;
  &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p><span id="a_DataOneOf"> </span>
Moreover, a new datatype can be generated by just enumerating the data values it contains. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:toddlerAge
   DataOneOf( "1"^^xsd:integer "2"^^xsd:integer ) 
 ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="toddlerAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:oneOf&gt;
         &lt;rdf:Description&gt;
           &lt;rdf:first rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;1&lt;/rdf:first&gt;
           &lt;rdf:rest&gt;
             &lt;rdf:Description&gt;
               &lt;rdf:first rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;2&lt;/rdf:first&gt;
               &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt;
             &lt;/rdf:Description&gt;
           &lt;/rdf:rest&gt;
         &lt;/rdf:Description&gt;
       &lt;/owl:oneOf&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:toddlerAge  owl:equivalentClass
   [ rdf:type rdfs:Datatype;
     owl:oneOf (  "1"^^xsd:integer  "2"^^xsd:integer )
   ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Datatype: toddlerAge
    EquivalentTo: { 1, 2 }
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="toddlerAge"/&gt;
    &lt;DataOneOf&gt;
      &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;1&lt;/Literal&gt; 
      &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;2&lt;/Literal&gt;
    &lt;/DataOneOf&gt;
 &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p>In Section 6.1, we saw ways of characterizing object properties. Some of those are also available for datatype properties. For example, we can express that every person has only one age by characterizing the hasAge datatype property as functional:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> FunctionalDataProperty(&nbsp;:hasAge ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:FunctionalProperty rdf:about="hasAge"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:hasAge  rdf:type  owl:FunctionalProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> DataProperty: hasAge
   Characteristics: Functional
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre>&lt;FunctionalDataProperty&gt;
  &lt;DataProperty IRI="hasAge"/&gt;
&lt;/FunctionalDataProperty&gt;
</pre>
</div>
<p>New classes can be defined by restrictions on datatype properties. The following example defines the class teenager as all individuals whose age is between 13 and 19 years.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf(
  &nbsp;:Teenager
   DataSomeValuesFrom(&nbsp;:hasAge
     DatatypeRestriction( xsd:integer
       xsd:minExclusive "12"^^xsd:integer
       xsd:maxInclusive "19"^^xsd:integer
     )
   )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre>&lt;owl:Class rdf:about="Teenager"&gt;
  &lt;rdfs:subClassOf&gt;
    &lt;owl:Restriction&gt;
      &lt;owl:onProperty rdf:resource="hasAge"/&gt;
      &lt;owl:someValuesFrom&gt;
        &lt;rdfs:Datatype&gt;
          &lt;owl:onDatatype rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/&gt;
          &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
            &lt;rdf:Description&gt;
              &lt;xsd:minExclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;12&lt;/xsd:minExclusive&gt;
            &lt;/rdf:Description&gt;
            &lt;rdf:Description&gt;
              &lt;xsd:maxInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;19&lt;/xsd:maxInclusive&gt;
            &lt;/rdf:Description&gt;
          &lt;/owl:withRestrictions&gt;
        &lt;/rdfs:Datatype&gt;
      &lt;/owl:someValuesFrom&gt;
    &lt;/owl:Restriction&gt;
  &lt;/rdfs:subClassOf&gt;
&lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>:Teenager  rdfs:subClassOf
       [ rdf:type             owl:Restriction&nbsp;;
         owl:onProperty      &nbsp;:hasAge&nbsp;;
         owl:someValuesFrom   
          [ rdf:type             rdfs:Datatype&nbsp;;
            owl:onDatatype       xsd:integer&nbsp;;
            owl:withRestrictions (  [ xsd:minExclusive     "12"^^xsd:integer ]
                                    [ xsd:maxInclusive     "19"^^xsd:integer ]
            )
          ]
       ] .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre>Class: Teenager
  SubClassOf: hasAge some integer[&lt; 12 , &gt;= 19]
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre>&lt;SubClassOf&gt;
  &lt;Class IRI="Teenager"/&gt;
  &lt;DataSomeValuesFrom&gt;
    &lt;DataProperty IRI="hasAge"/&gt;
    &lt;DatatypeRestriction&gt;
      &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#integer"/&gt;
      &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#minExclusive"&gt;
        &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;12&lt;/Literal&gt;
      &lt;/FacetRestriction&gt;
      &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#maxInclusive"&gt;
        &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;19&lt;/Literal&gt;
      &lt;/FacetRestriction&gt;
    &lt;/DatatypeRestriction&gt;
  &lt;/DataSomeValuesFrom&gt;
&lt;/SubClassOf&gt;
</pre>
</div>
<a id="Document_Information_and_Annotations" name="Document_Information_and_Annotations"></a><h2> <span class="mw-headline">8 Document Information and Annotations</span></h2>
<p>In the following, we describe features of OWL 2 which do not actually contribute to the &ldquo;logical&rdquo; knowledge specified in the ontology. Rather these are used to provide additional information about the ontology itself, axioms, or even single entities.
</p>
<a id="Annotating_Axioms_and_Entities" name="Annotating_Axioms_and_Entities"></a><h3> <span class="mw-headline">8.1 Annotating Axioms and Entities</span></h3>
<p><span id="a_Annotation"> </span>
In many cases, we want to furnish parts of our OWL ontology with information that actually does not describe the domain itself but talks about the description of the domain.  OWL provides <span id="Aannotation">annotations</span> for this purpose.  An OWL annotation simply associates property-value pairs with parts of an ontology, or the entire ontology itself.  Even annotations themselves can be annotated. Annotation information is not really part of the logical meaning of an ontology.
</p><p><span id="a_AnnotationAssertion"> </span>
So, for example, we could add information to one of the classes of our ontology, giving a natural language description of its meaning.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> AnnotationAssertion( rdfs:comment&nbsp;:Person "Represents the set of all people." )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;rdfs:comment&gt;Represents the set of all people.&lt;/rdfs:comment&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Person  rdfs:comment  "Represents the set of all people."^^xsd:string .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Person
   Annotations: rdfs:comment "Represents the set of all people."
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;AnnotationAssertion&gt;
   &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
   &lt;IRI&gt;Person&lt;/IRI&gt;                       
   &lt;Literal&gt;Represents the set of all people.&lt;/Literal&gt;
 &lt;/AnnotationAssertion&gt;
</pre>
</div>
<p>The following is an example of an axiom with an annotation.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf( 
   Annotation( rdfs:comment "States that every man is a person." )
  &nbsp;:Man 
  &nbsp;:Person 
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Man"&gt;
   &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
 &lt;/owl:Class&gt;
 &lt;owl:Axiom&gt;
   &lt;owl:annotatedSource rdf:resource="Man"/&gt;
   &lt;owl:annotatedProperty rdf:resource="&amp;rdfs;subClassOf"/&gt;
   &lt;owl:annotatedTarget rdf:resource="Person"/&gt;
   &lt;rdfs:comment&gt;States that every man is a person.&lt;/rdfs:comment&gt;
 &lt;/owl:Axiom&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Man rdfs:subClassOf&nbsp;:Person .
 []  rdf:type       owl:Axiom&nbsp;;
     owl:annotatedSource   &nbsp;:Man&nbsp;;
     owl:annotatedProperty  rdfs:subClassOf&nbsp;;
     owl:annotatedTarget   &nbsp;:Person&nbsp;;
     rdfs:comment     "States that every man is a person."^^xsd:string .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Man
   SubClassOf: Annotations: rdfs:comment "States that every man is a person." Person
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Annotation&gt;
       &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
       &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#string"&gt;"States that every man is a person."&lt;/Literal&gt;
   &lt;/Annotation&gt;
   &lt;Class IRI="Man"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>Often such annotations are used in tools to provide access to natural language text to be displayed in help interfaces.
</p>
<a id="Ontology_Management" name="Ontology_Management"></a><h3> <span class="mw-headline">8.2 Ontology Management</span></h3>
<p>In OWL, general information about a topic is almost always gathered into an <span id="Aontology">ontology</span> that is then used by various applications.  We can also provide a <span id="Aontologyname">name for OWL ontologies</span>, which is generally the place where the ontology document is located in the web. Particular information about a topic can also be placed in an ontology, if it is used by different applications.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> Ontology(&lt;http://example.com/owl/families&gt;
   ...
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:RDF ...&gt;
   &lt;owl:Ontology rdf:about="http://example.com/owl/families"/&gt;
   ...
 &lt;/rdf:RDF&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> &lt;http://example.com/owl/families&gt; rdf:type owl:Ontology .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Ontology: &lt;http://example.com/owl/families&gt;
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;Ontology ...
   ontologyIRI="http://example.com/owl/families"&gt;
   ...
 &lt;/Ontology&gt;
</pre>
</div>
<p>We place OWL ontologies into OWL documents, which are then placed into local filesystems or on the World Wide Web.  Aside from containing an OWL ontology, OWL documents also contain information about transforming the short names normally used in OWL ontologies (e.g., Person) into IRIs, 
by <span id="Anamespace">providing the expansion for prefixes</span>. The IRI is then the concatenation of the prefix expansion and the reference.
</p><p>In our example we have so far used a number of prefixes, including <span class="name">xsd</span> and the empty prefix. The former prefix has been used in compact names for XML Schema datatypes, whose IRIs are fixed by the XML Schema recommendation. We thus must use the standard expansion for <span class="name">xsd</span>, which is <span class="name">http://www.w3.org/2001/XMLSchema#</span>. The expansion we pick for the other prefix will affect the names of the classes, properties, and individuals in our ontology, as well as the name of the ontology itself. If we are going to put the ontology on the web, we should pick an expansion that is in some part of the web that we control, so that we are not using someone else's names by accident. (Here we use a made-up place that no one controls.) The two XML-based syntaxes need namespaces for built-in names and also can use XML entity references for namespaces. In general, it should be noted that the available abbreviation mechanisms and their specific syntax is different in each of the serializations of OWL, even in cases where similar keywords are used.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> Prefix(:=&lt;http://example.com/owl/families/&gt;)
 Prefix(otherOnt:=&lt;http://example.org/otherOntologies/families/&gt;)
 Prefix(xsd:=&lt;http://www.w3.org/2001/XMLSchema#&gt;)
 Prefix(owl:=&lt;http://www.w3.org/2002/07/owl#&gt;)
 
 Ontology(&lt;http://example.com/owl/families&gt;
    ...
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;!DOCTYPE rdf:RDF [
     &lt;!ENTITY owl "http://www.w3.org/2002/07/owl#" &gt;
     &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
     &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
     &lt;!ENTITY otherOnt "http://example.org/otherOntologies/families/" &gt;
 ]&gt;
 
 &lt;rdf:RDF xml:base="http://example.com/owl/families/"
     xmlns="http://example.com/owl/families/"
     xmlns:otherOnt="http://example.org/otherOntologies/families/"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:xml="http://www.w3.org/2001/XMLSchema#"&gt;
 
     &lt;owl:Ontology rdf:about="http://example.com/owl/families"/&gt;
 ...
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> @prefix&nbsp;: &lt;http://example.com/owl/families/&gt; .
 @prefix otherOnt: &lt;http://example.org/otherOntologies/families/&gt; .
 @prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
 @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
 @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
 @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Prefix:&nbsp;: &lt;http://example.com/owl/families/&gt;
 Prefix: xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
 Prefix: owl: &lt;http://www.w3.org/2002/07/owl#&gt;
 Prefix: otherOnt: &lt;http://example.org/otherOntologies/families/&gt;
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;!DOCTYPE Ontology [
    &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
 ]&gt;
 &lt;Ontology
   xml:base="http://example.com/owl/families/"
   ontologyIRI="http://example.com/owl/families"
   xmlns="http://www.w3.org/2002/07/owl#"&gt;
   &lt;Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/&gt;
 
  ...
 &lt;/Ontology&gt;
</pre>
</div>
<p><span id="a_imports"> </span>
It is also common in OWL to reuse general information that is stored in one ontology in other ontologies. Instead of requiring the copying of this information, OWL allows the import of the contents of entire ontologies in other ontologies, using import statements, as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> Import( &lt;http://example.org/otherOntologies/families.owl&gt; )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Ontology rdf:about="http://example.com/owl/families"&gt;
   &lt;owl:imports rdf:resource="http://example.org/otherOntologies/families.owl" /&gt;
 &lt;/owl:Ontology&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> &lt;http://example.com/owl/families&gt; owl:imports &lt;http://example.org/otherOntologies/families.owl&gt; .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Import: &lt;http://example.org/otherOntologies/families.owl&gt;
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;Prefix name="otherOnt" IRI="http://example.org/otherOntologies/families/"/&gt;
 &lt;Import&gt;http://example.org/otherOntologies/families.owl&lt;/Import&gt;
</pre>
</div>
<p><br />
As the Semantic Web and ontology construction is distributed, it is common for ontologies to use different names for the same concept, property, or individual. As we have seen, several constructs in OWL can be used to state that different names refer to the same <span id="Aclassequivalentnway">class</span>, <span id="Adatapropertyequivalentnway"><span id="Aobjectpropertyequivalentnway">property</span></span>, or <span id="Aindividualsamenway">individual</span>, so, for example, we could &ndash; instead of tediously renaming entities &ndash; tie the names used in our ontology to the names used in an imported ontology as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SameIndividual(&nbsp;:John otherOnt:JohnBrown )
 SameIndividual(&nbsp;:Mary otherOnt:MaryBrown )
 EquivalentClasses(&nbsp;:Adult otherOnt:Grownup )
 EquivalentObjectProperties(&nbsp;:hasChild otherOnt:child )
 EquivalentDataProperties(&nbsp;:hasAge otherOnt:age )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;owl:sameAs rdf:resource="&amp;otherOnt;JohnBrown"/&gt;
 &lt;/rdf:Description&gt;

 &lt;rdf:Description rdf:about="Mary"&gt;
   &lt;owl:sameAs rdf:resource="&amp;otherOnt;MaryBrown"/&gt;
 &lt;/rdf:Description&gt;

 &lt;owl:Class rdf:about="Adult"&gt;
   &lt;owl:equivalentClass rdf:resource="&amp;otherOnt;Grownup"/&gt;
 &lt;/owl:Class&gt;

 &lt;owl:ObjectProperty rdf:about="hasChild"&gt;
   &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;child"/&gt;
 &lt;/owl:ObjectProperty&gt;

 &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
   &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;age"/&gt;
 &lt;/owl:DatatypeProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Mary      owl:sameAs              otherOnt:MaryBrown .
&nbsp;:John      owl:sameAs              otherOnt:JohnBrown .
&nbsp;:Adult     owl:equivalentClass     otherOnt:Grownup .
&nbsp;:hasChild  owl:equivalentProperty  otherOnt:child .
&nbsp;:hasAge    owl:equivalentProperty  otherOnt:age .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> SameIndividual: John, otherOnt:JohnBrown 
 SameIndividual: Mary, otherOnt:MaryBrown
 EquivalentClasses: Adult, otherOnt:Grownup
 EquivalentProperties: hasChild, otherOnt:child
 EquivalentProperties: hasAge,   otherOnt:age
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual abbreviatedIRI="otherOnt:JohnBrown"/&gt;
 &lt;/SameIndividual&gt;

 &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;NamedIndividual abbreviatedIRI="otherOnt:MaryBrown"/&gt;
 &lt;/SameIndividual&gt;

 &lt;EquivalentClasses&gt;
   &lt;Class IRI="Adult"/&gt;
   &lt;Class abbreviatedIRI="otherOnt:Grownup"/&gt;
 &lt;/EquivalentClasses&gt;

 &lt;EquivalentObjectProperties&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;ObjectProperty abbreviatedIRI="otherOnt:child"/&gt;
 &lt;/EquivalentObjectProperties&gt;

 &lt;EquivalentDataProperties&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;DataProperty abbreviatedIRI="otherOnt:age"/&gt;
 &lt;/EquivalentDataProperties&gt;
</pre>
</div>
<a id="Entity_Declarations" name="Entity_Declarations"></a><h3> <span class="mw-headline">8.3 Entity Declarations</span></h3>
<p><span id="a_DeclarationClass"> </span><span id="a_DeclarationObjectProperty"> </span><span id="a_DeclarationDataProperty"> </span><span id="a_NamedIndividual"> </span>
</p><p>To help with managing ontologies, OWL has the notion of declarations. The basic idea is that each class, property, or individual is supposed to be declared in an ontology, and then it can be used in that ontology and ontologies that import that ontology.
</p><p>In the Manchester syntax, declarations are implicit. Constructs that provide information about a class, property, or individual implicitly declare that class, property, or individual if needed.  The other syntaxes have explicit declarations.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> Declaration( NamedIndividual(&nbsp;:John ) )
 Declaration( Class(&nbsp;:Person ) )
 Declaration( ObjectProperty(&nbsp;:hasWife ) )
 Declaration( DataProperty(&nbsp;:hasAge ) )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:NamedIndividual rdf:about="John"/&gt;
 &lt;owl:Class rdf:about="Person"/&gt;
 &lt;owl:ObjectProperty rdf:about="hasWife"/&gt;
 &lt;owl:DatatypeProperty rdf:about="hasAge"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:John    rdf:type owl:NamedIndividual .
&nbsp;:Person  rdf:type owl:Class .
&nbsp;:hasWife rdf:type owl:ObjectProperty .
&nbsp;:hasAge  rdf:type owl:DatatypeProperty .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Individual: John
 Class: Person
 ObjectProperty: hasWife
 DataProperty: hasAge
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;Declaration&gt;
     &lt;NamedIndividual IRI="John"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;Class IRI="Person"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
 &lt;/Declaration&gt;
</pre>
</div>
<p>However, an IRI may denote different entity-types (e.g. both an individual and a class) at the same time. This possibility, called &ldquo;punning,&rdquo; has been introduced to allow for a certain amount of metamodeling; we give an example of this in <a href="#OWL_2_DL_and_OWL_2_Full" title="">Section 9</a>. Still, OWL 2 does require some discipline in using and reusing names.  To allow a more readable syntax, and for other technical reasons, OWL 2 DL requires that a name is not used for more than one property type (object, datatype or annotation property) nor can an IRI denote both a class and a datatype.  Moreover, &ldquo;built-in&rdquo; names (such as those used by RDF and RDFS and various syntaxes of OWL) cannot be freely used in OWL.
</p>
<a id="OWL_2_DL_and_OWL_2_Full" name="OWL_2_DL_and_OWL_2_Full"></a><h2> <span class="mw-headline">9 OWL 2 DL and OWL 2 Full</span></h2>
<p>There are two alternative ways of assigning meaning to ontologies in OWL 2 called the Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] and the RDF-Based Semantics [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>]. The Direct Semantics can be applied to ontologies that are in the OWL 2 DL subset of OWL 2, which is defined in OWL 2 functional-style syntax document [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>]. Ontologies that are not in OWL 2 DL are often said to belong to <i>OWL 2 Full</i>, and can only be interpreted under RDF-Based Semantics. Informally, the term <i>OWL 2 DL</i> is often used to refer to OWL 2 ontologies interpreted using the Direct Semantics, but it is also possible to interpret OWL 2 DL ontologies under RDF-Based Semantics.
</p><p>The Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] provides a meaning for OWL 2 in a Description Logic [<cite><a href="#ref-description-logics" title="">Description Logics</a></cite>] style.  The RDF-Based Semantics [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>] is an extension of the semantics for RDFS [<cite><a href="#ref-rdf-semantics" title="">RDF Semantics</a></cite>] and is based on viewing OWL 2 ontologies as RDF graphs.
</p><p>When thinking about ontologies the differences between these two semantics are generally quite slight. Indeed, given an OWL 2 DL ontology, many inferences drawn using the Direct Semantics remain valid inferences under the RDF-Based Semantics &ndash; see the correspondence theorem in <a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/#Correspondence_Theorem" title="RDF-Based Semantics">Section 7.2</a> of the RDF-Based Semantics document [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>]. The two main differences are that under the Direct Semantics annotations have no formal meaning and under the RDF-Based Semantics there are some extra inferences that arise from the RDF view of the universe.
</p><p>Conceptually, we can think of the difference between OWL 2 DL (under Direct Semantics) and OWL 2 Full (under RDF-Based Semantics) in two ways:
</p>
<ul><li> One can see OWL 2 DL as a syntactically restricted version of OWL 2 Full where the restrictions are designed to make life easier for implementors. In fact, since OWL 2 Full (under the RDF-Based Semantics) is undecidable, OWL 2 DL (under the Direct Semantics) makes writing a reasoner that, in principle, can return all "yes or no" answers (subject to resource constraints) possible. As a consequence of its design, there are several production quality reasoners that cover the entire OWL 2 DL language under the Direct Semantics. There are no such reasoners for OWL 2 Full under the RDF-Based Semantics.
</li></ul>
<ul><li> One can see OWL 2 Full as the most straightforward extension of RDFS. As such, the RDF-Based Semantics for OWL 2 Full follows the RDFS semantics and general syntactic philosophy (i.e., everything is a triple and the language is fully reflective).
</li></ul>
<p>Of course, the two semantics have been designed together and thus have influenced each other. For example, one design goal of OWL 2 was to bring OWL 2 DL syntactically closer to OWL 2 Full (that is, to allow more RDF Graphs/OWL 2 Full ontologies to be legal OWL 2 DL ontologies). This led to the incorporation of so-called <span id="a_Punning"> </span><i>punning</i> into OWL 2, e.g., using the same IRI as a name for both a class and an individual. An example of such usage would be the following, which states that John is a father, and that father is a social role.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre>ClassAssertion(&nbsp;:Father&nbsp;:John ) 
ClassAssertion(&nbsp;:SocialRole&nbsp;:Father ) 
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre>&lt;Father rdf:about="John"/&gt;
&lt;SocialRole rdf:about="Father"/&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>:John rdf:type&nbsp;:Father .
:Father rdf:type&nbsp;:SocialRole .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre>Individual: John   
  Types: Father
Individual: Father 
  Types: SocialRole
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre>&lt;ClassAssertion&gt;
    &lt;Class IRI="Father"/&gt;
    &lt;NamedIndividual IRI="John"/&gt;
&lt;/ClassAssertion&gt;
&lt;ClassAssertion&gt;
    &lt;Class IRI="SocialRole"/&gt;
    &lt;NamedIndividual IRI="Father"/&gt;
&lt;/ClassAssertion&gt;
</pre>
</div>
<p>Note that in the first statement, Father is used as a class, while in the second it is used as an individual. In this sense, SocialRole acts as a metaclass for the class Father.
</p><p>In OWL 1, a document containing these two statements would be an OWL 1 Full document, but not an OWL 1 DL document. In OWL 2 DL, however, this is allowed. It must be noted, though, that the Direct Semantics of OWL 2 DL accommodates this by understanding the class Father and the individual Father as two different views on the same IRI, i.e. they are interpreted semantically as if they were distinct. In particular, if two individuals are equal, then the classes that they denote are equivalent under RDF-Based Semantics, whereas there is no such relationship between the classes under Direct Semantics. This is possibly the one difference between the two semantics that is most relevant in practice.
</p>
<a id="OWL_2_Profiles" name="OWL_2_Profiles"></a><h2> <span class="mw-headline">10 OWL 2 Profiles</span></h2>
<p>In addition to OWL 2 DL and OWL 2 Full, OWL 2 specifies three profiles. OWL 2, in general, is a very expressive language (both computationally and for users) and thus can be difficult to implement well and to work with. These additional profiles are designed to be approachable subsets of OWL 2 sufficient for a variety of applications. As with OWL 2 DL, computational considerations are a major requirement of these profiles (and they are all much easier to implement with robust scalability given existing technology), but there are many subsets of OWL 2 that have good computational properties. The selected OWL 2 profiles were identified as having substantial user communities already, although there were several others not included and one should expect more to emerge. The [<cite><a href="#ref-owl-2-profiles" title="">OWL 2 Profiles</a></cite>] document provides a clear template for specifying additional profiles.
</p><p>In order to guarantee scalable reasoning, the existing profiles share some limitations regarding their expressiveness. In general, they disallow negation and disjunction, as these constructs complicate reasoning and have proved to be only rarely needed for modeling. For example, in none of the profiles it is possible to specify that every person is either male or female.
Further specific modeling restrictions of the profiles will be dealt with in the sections on the individual profiles.
</p><p>We discuss each profile and its design rationale, and provide some guidance for users in selecting which profile to work with. Please be aware that this discussion is not comprehensive, nor can it be. Part of any decision has to be based on available tooling and how that fits in with the rest of your system or workflow. A more extended discussion and comparison of the profiles can be found in the literature [<cite><a href="#ref-owlprofilesintro" title="">OWL 2 Profiles Introduction</a></cite>].
</p><p>By and large, different profiles can be distinguished syntactically, and some of the profiles contain others. For example, OWL 2 DL can be seen as a syntactic fragment of OWL 2 Full and OWL 2 QL is a syntactic fragment of OWL 2 DL (and thus of OWL 2 Full). None of these profiles below is a subset of another. Ideally, one can use a reasoner (or other tool) that is conforming for a superprofile on the subprofile with no change in the results derived. In particular, every conforming OWL 2 DL reasoner is also a conforming reasoner for OWL 2 EL, OWL 2 RL, and OWL 2 QL (but may differ in performance since the OWL 2 DL reasoner is tuned for a more general set of cases). Each of the two semantics of OWL 2 (see <a href="#OWL_2_DL_and_OWL_2_Full" title="">Section 9</a>) can be used for any of the profiles, but it is most common to use Direct Semantics for OWL 2 EL and OWL 2 QL, and RDF-Based Semantics for OWL 2 RL.
</p>
<a id="OWL_2_EL" name="OWL_2_EL"></a><h3> <span class="mw-headline">10.1 OWL 2 EL</span></h3>
<p>Working with OWL 2 EL is fairly similar to working with OWL 2 DL: one can use class expressions on both sides of a subClassOf statement and even infer such relations. For many large, class-expression oriented ontologies, by only a little simplification one can get an OWL 2 EL ontology and preserve the bulk of the meaning of the original ontology.
</p><p>OWL 2 EL is designed with large biohealth ontologies in mind, such as SNOMED-CT, the NCI thesaurus, and Galen. Common characteristics of such ontologies include complex structural descriptions (e.g., defining certain body parts in terms of what parts they contain and are contained in or propagating diseases along part-subpart relations), huge numbers of classes, the heavy use of classification to manage the terminology, and the application of the resulting terminology to vast amounts of data. Thus, OWL 2 EL has a comparatively expressive class expression language and it has no restrictions on how they may be used in axioms. It also has fairly expressive property expressions, including property chains but excluding inverse.
</p><p>Sensible use of OWL 2 EL is obviously not restricted to the biohealth domain: as with the other profiles, OWL 2 EL is domain independent. However, OWL 2 EL shines when your domain and your application require recognition of structurally complex objects. Such domains include system configurations, product inventories, and many scientific domains.
</p><p>Besides negation and disjunction, OWL 2 EL also disallows universal quantification on properties. Therefore propositions like &ldquo;all children of a rich person are rich&rdquo; cannot be stated. Moreover, as all kinds of role inverses are not available, there is no way of specifying that, say, parentOf and childOf are inverses of each other.
</p><p>The EL acronym reflects the profile's basis in the so-called EL family of description logics [<cite><a href="#ref-ELpp" title="">EL++</a></cite>]; they are Languages providing mainly Existential quantification of variables.
</p><p>The following is an example which uses some of the typical modeling features available in OWL 2 EL.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf(
  &nbsp;:Father 
   ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
 )
 
 EquivalentClasses(
  &nbsp;:Parent 
   ObjectSomeValuesFrom(
    &nbsp;:hasChild 
    &nbsp;:Person
   )
 )
 
 EquivalentClasses( 
  &nbsp;:NarcisticPerson 
   ObjectHasSelf(&nbsp;:loves ) 
 )
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father 
  &nbsp;:YoungChild 
 )
 
 SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother ) 
  &nbsp;:hasUncle 
 )
 
 NegativeObjectPropertyAssertion( 
  &nbsp;:hasDaughter 
  &nbsp;:Bill 
  &nbsp;:Susan 
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="Father"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Man"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:about="hasChild"/&gt;
       &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:Class rdf:about="NarcisticPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="loves"/&gt;
       &lt;owl:hasSelf rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;
         true
       &lt;/owl:hasSelf&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;

 &lt;rdf:Description rdf:about="hasUncle"&gt;
   &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
     &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
     &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
   &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
 
 &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasDaughter"/&gt;
   &lt;owl:targetIndividual rdf:resource="Susan"/&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:Father  rdfs:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
 ] .
 
&nbsp;:Parent  owl:equivalentClass  [
   rdf:type            owl:Restriction&nbsp;;
   owl:onProperty     &nbsp;:hasChild&nbsp;;
   owl:someValuesFrom &nbsp;:Person
 ] .
 
&nbsp;:NarcisticPerson  owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:loves&nbsp;;
   owl:hasSelf     true
 ] .
 
 [] rdf:type     owl:AllDisjointClasses&nbsp;;
    owl:members  (&nbsp;:Mother &nbsp;:Father&nbsp;:YoungChild ) .
 
&nbsp;:hasUncle  owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .
 
 []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Bill&nbsp;;
     owl:assertionProperty &nbsp;:hasDaughter&nbsp;;
     owl:targetIndividual  &nbsp;:Susan .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: Father
   SubClassOf: Man and Parent
 
 Class: Parent
   EquivalentTo: hasChild some Person
 
 Class: NarcisticPerson
   EquivalentTo: loves Self
 
 DisjointClasses: Mother, Father, YoungChild
 
 ObjectProperty: hasUncle
   SubPropertyChain: hasFather o hasBrother
 
 Individual: Bill
   Facts: not hasDaughter Susan
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Father"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectSomeValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/ObjectSomeValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
 
 &lt;EquivalentClasses&gt;
   &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;ObjectHasSelf&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/ObjectHasSelf&gt;
 &lt;/EquivalentClasses&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasUncle"/&gt;
 &lt;/SubObjectPropertyOf&gt;
 
 &lt;NegativeObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;NamedIndividual IRI="Susan"/&gt;
 &lt;/NegativeObjectPropertyAssertion&gt;
</pre>
</div>
<a id="OWL_2_QL" name="OWL_2_QL"></a><h3> <span class="mw-headline">10.2 OWL 2 QL</span></h3>
<p>OWL 2 QL can be realized using standard relational database technology (e.g., SQL) simply by expanding queries in the light of class axioms. This means it can be tightly integrated with RDBMSs and benefit from their robust implementations and multi-user features. Furthermore, it can be implemented without having to &ldquo;touch the data,&rdquo; so really as a translational/preprocessing layer. Expressively, it can represent key features of Entity-relationship and UML diagrams (at least those with functional restrictions). Thus, it is suitable both for representing database schemas and for integrating them via query rewriting. As a result, it can also be used directly as a high level database schema language, though users may prefer a diagram based syntax.
</p><p>OWL 2 QL also captures many commonly used features in RDFS and small extensions thereof, such as inverse properties and subproperty hierarchies. OWL 2 QL restricts class axioms asymmetrically, that is, you can use constructs as the subclass that you cannot use as the superclass.
</p><p>Among other constructs, OWL 2 QL disallows existential quantification of roles to a class expression, e.g. it can be stated that every person has a parent but not that every person has a female parent. Moreover property chain axioms and equality are not supported. 
</p><p>The QL acronym reflects the fact that query answering in this profile can be implemented by rewriting queries into a standard relational Query Language [<cite><a href="#ref-DL-Lite" title="">DL-Lite</a></cite>].
</p><p>The following is an example which uses some of the typical modeling features available in OWL 2 QL. The first axiom states that every childless person is a person for which there does not exist anybody who has the first person as parent.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf( 
  &nbsp;:ChildlessPerson 
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(
       ObjectSomeValuesFrom(
         ObjectInverseOf(&nbsp;:hasParent )
         owl:Thing
       )
     )
   )
 ) 
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father
  &nbsp;:YoungChild 
 )
 
 DisjointObjectProperties( 
  &nbsp;:hasSon 
  &nbsp;:hasDaughter 
 )
 
 SubObjectPropertyOf( 
  &nbsp;:hasFather 
  &nbsp;:hasParent
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class rdf:about="ChildlessPerson"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf&gt;
             &lt;owl:Restriction&gt;
               &lt;owl:onProperty&gt;
                 &lt;owl:ObjectProperty&gt;
                   &lt;owl:inverseOf rdf:resource="hasParent"/&gt;
                 &lt;/owl:ObjectProperty&gt;
               &lt;/owl:onProperty&gt;
               &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
             &lt;/owl:Restriction&gt;
           &lt;/owl:complementOf&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;
 
 &lt;owl:ObjectProperty rdf:about="hasSon"&gt;
   &lt;owl:propertyDisjointWith rdf:resource="hasDaughter"/&gt;
 &lt;/owl:ObjectProperty&gt;
 
 &lt;owl:ObjectProperty rdf:about="hasFather"&gt;
   &lt;rdfs:subPropertyOf rdf:resource="hasParent"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>&nbsp;:ChildlessPerson  owl:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person 
                         [ owl:complementOf  [
                             rdf:type            owl:Restriction&nbsp;;
                             owl:onProperty      [ owl:inverseOf &nbsp;:hasParent ]&nbsp;;
                             owl:someValuesFrom  owl:Thing
                           ]
                         ]
                       )
 ] .
 
 []  rdf:type    owl:AllDisjointClasses&nbsp;;
     owl:members (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .
 
&nbsp;:hasSon  owl:propertyDisjointWith &nbsp;:hasDaughter.
 
&nbsp;:hasFather  rdfs:subPropertyOf &nbsp;:hasParent.
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: ChildlessPerson
   SubClassOf: Person and not (inverse hasParent some owl:Thing)
 
 DisjointClasses: Mother, Father, YoungChild
 
 DisjointProperties: hasSon, hasDaughter
 
 ObjectProperty: hasFather
   SubPropertyOf: hasParent
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;ObjectComplementOf&gt;
       &lt;ObjectSomeValuesFrom&gt;
         &lt;ObjectInverseOf&gt;
           &lt;ObjectProperty IRI="hasParent"/&gt;
         &lt;/ObjectInverseOf&gt;
         &lt;Class abbreviatedIRI="owl:Thing"/&gt;
       &lt;/ObjectSomeValuesFrom&gt;
     &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;DisjointObjectProperties&gt;
   &lt;ObjectProperty IRI="hasSon"/&gt;
   &lt;ObjectProperty IRI="hasDaughter"/&gt;
 &lt;/DisjointObjectProperties&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectProperty IRI="hasFather"/&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="OWL_2_RL" name="OWL_2_RL"></a><h3> <span class="mw-headline">10.3 OWL 2 RL</span></h3>
<p>The OWL 2 RL profile is aimed at applications that require scalable reasoning without sacrificing too much expressive power. It is designed to accommodate both OWL 2 applications that can trade the full expressivity of the language for efficiency, and RDF(S) applications that need some added expressivity from OWL 2. This is achieved by defining a syntactic subset of OWL 2 which is amenable to implementation using rule-based technologies, and presenting a partial axiomatization of the OWL 2 semantics in the form of first-order implications that can be used as the basis for such an implementation. 
</p><p>Suitable rule-based implementations of OWL 2 RL under RDF-Based Semantics can be used with arbitrary RDF graphs. As a consequence, OWL 2 RL is ideal for enriching RDF data, especially when the data must be massaged by additional rules. From a modeling perspective, however, this pushes us farther away from working with class expressions: OWL 2 RL ensures we cannot (easily) talk about unknown individuals in our superclass expressions (this restriction follows from the nature of rules). Compared with OWL 2 QL, OWL 2 RL works better when you have already massaged your data into RDF and are working with it as RDF.
</p><p>Among other constructs, OWL 2 RL disallows statements where the existence of an individual enforces the existence of another individual: for instance, the statement &ldquo;every person has a parent&rdquo; is not expressible in OWL RL. 
</p><p>OWL 2 RL restricts class axioms asymmetrically, that is, you can use constructs as the subclass that you cannot use as the superclass. 
</p><p>The RL acronym reflects the fact that reasoning in this profile can be implemented using a standard Rule Language [<cite><a href="#ref-dlp" title="">DLP</a></cite>].
</p><p>The following is an example which uses some of the typical modeling features available in OWL 2 RL. The first &ndash; somewhat contrived &ndash; axiom states that for each of Mary, Bill, and Meg who is female, the following holds: she is a parent with at most one child, and all her children (if she has any) are female.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> SubClassOf(
   ObjectIntersectionOf(
     ObjectOneOf(&nbsp;:Mary&nbsp;:Bill&nbsp;:Meg )
    &nbsp;:Female
   )
   ObjectIntersectionOf(
    &nbsp;:Parent
     ObjectMaxCardinality( 1&nbsp;:hasChild )
     ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:Female )
   )
 )
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father 
  &nbsp;:YoungChild 
 )
 
 SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother ) 
  &nbsp;:hasUncle 
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
     &lt;owl:Class&gt;
       &lt;owl:oneOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="Mary"/&gt;
         &lt;rdf:Description rdf:about="Bill"/&gt;
         &lt;rdf:Description rdf:about="Meg"/&gt;
       &lt;/owl:oneOf&gt;
     &lt;/owl:Class&gt;
     &lt;owl:Class rdf:about="Female"/&gt;
   &lt;/owl:intersectionOf&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:maxCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
             1
           &lt;/owl:maxCardinality&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;/owl:Restriction&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:allValuesFrom rdf:resource="Female"/&gt;
         &lt;/owl:Restriction&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;

 &lt;rdf:Description rdf:about="hasUncle"&gt;
   &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
     &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
     &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
   &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre> []  rdf:type            owl:Class&nbsp;;
     owl:intersectionOf  ( [ rdf:type   owl:Class&nbsp;;
                             owl:oneOf  (&nbsp;:Mary &nbsp;:Bill &nbsp;:Meg ) ]
                          &nbsp;:Female 
                         )&nbsp;;
     rdfs:subClassOf     [
       rdf:type            owl:Class&nbsp;;
       owl:intersectionOf  (&nbsp;:Parent  
                             [ rdf:type            owl:Restriction&nbsp;;
                               owl:maxCardinality  "1"^^xsd:nonNegativeInteger&nbsp;;
                               owl:onProperty     &nbsp;:hasChild ]
                             [ rdf:type           owl:Restriction&nbsp;;
                               owl:onProperty    &nbsp;:hasChild&nbsp;;
                               owl:allValuesFrom &nbsp;:Female ]
                           )
     ] .

 []  rdf:type     owl:AllDisjointClasses&nbsp;;
     owl:members  (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .
 
&nbsp;:hasUncle  owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre> Class: X
   SubClassOf: Parent and hasChild max 1 and hasChild only Female
 Class: X
   EquivalentTo: {Mary, Bill, Meg} and Female
 
 DisjointClasses: Mother, Father, YoungChild
 
 ObjectProperty: hasUncle
   SubPropertyChain: hasFather o hasBrother
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;ObjectOneOf&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
       &lt;NamedIndividual IRI="Bill"/&gt;
       &lt;NamedIndividual IRI="Meg"/&gt;
     &lt;/ObjectOneOf&gt;
     &lt;Class IRI="Female"/&gt;
   &lt;/ObjectIntersectionOf&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectMaxCardinality cardinality="1"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectMaxCardinality&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Female"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasUncle"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="OWL_Tools" name="OWL_Tools"></a><h2> <span class="mw-headline">11 OWL Tools</span></h2>
<p>In order to work with OWL ontologies, tool support is essential. Basically, there are two types of tools addressing the two main stages of the ontology lifecycle: <i>ontology editors</i> are used to create and edit ontologies, whereas <i>reasoners</i> are used to query ontologies for implicit knowledge, i.e., they determine whether a statement in question is a logical consequence of an ontology. 
</p><p>The currently most widely used OWL editor is <a class="external text" href="http://protege.stanford.edu/" rel="nofollow" title="http://protege.stanford.edu/">Prot&eacute;g&eacute;</a>, a free open-source editing framework developed at Stanford University. By virtue of its open plugin structure, it allows for the easy integration of special-purpose ontology editing components. Other editors include TopQuadrant's commercial <a class="external text" href="http://www.topquadrant.com/products/TB_Composer.html" rel="nofollow" title="http://www.topquadrant.com/products/TB_Composer.html">TopBraid Composer</a> and the open-source systems <a class="external text" href="http://code.google.com/p/swoop/" rel="nofollow" title="http://code.google.com/p/swoop/">SWOOP</a> and <a class="external text" href="http://www.neon-toolkit.org/" rel="nofollow" title="http://www.neon-toolkit.org/">NeOn-Toolkit</a>.
</p><p>There are several reasoners for OWL DL which differ somewhat in terms of coverage of the supported reasoning features. For some of these, OWL 2 conformance is currently planned and the corresponding implementations are in progress. The <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Test_Suite_Status" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Test_Suite_Status">Test Suite Status</a> document lists to which extent some of the reasoners mentioned below comply with the test cases. 
</p><p>For reasoning within OWL DL, the most prominent systems are <a class="external text" href="http://owl.cs.manchester.ac.uk/fact++/" rel="nofollow" title="http://owl.cs.manchester.ac.uk/fact++/">Fact++</a> by the University of Manchester, <a class="external text" href="http://hermit-reasoner.com/" rel="nofollow" title="http://hermit-reasoner.com/">Hermit</a> by Oxford University Computing Laboratory, <a class="external text" href="http://clarkparsia.com/pellet" rel="nofollow" title="http://clarkparsia.com/pellet">Pellet</a> by Clark &amp; Parsia, LLC, and <a class="external text" href="http://www.racer-systems.com/" rel="nofollow" title="http://www.racer-systems.com/">RacerPro</a> by Racer Systems.
</p><p>In addition to those general-purpose reasoners aiming at supporting all of OWL DL, there are reasoning systems tailored to the tractable profiles of OWL. <a class="external text" href="http://lat.inf.tu-dresden.de/systems/cel/" rel="nofollow" title="http://lat.inf.tu-dresden.de/systems/cel/">CEL</a> by Dresden University of Technology supports OWL EL. 
<a class="external text" href="http://www.dis.uniroma1.it/~quonto/" rel="nofollow" title="http://www.dis.uniroma1.it/~quonto/">QuOnto</a> by Sapienza Universit&agrave; di Roma supports OWL QL. <a class="external text" href="http://www.oracle.com/technology/tech/semantic_technologies/index.html" rel="nofollow" title="http://www.oracle.com/technology/tech/semantic_technologies/index.html">ORACLE 11g</a> supports OWL RL.
</p><p>The open-source <a class="external text" href="http://owlapi.sourceforge.net/" rel="nofollow" title="http://owlapi.sourceforge.net/">OWL API</a> plays a rather prominent role as the currently most important development tool around OWL. 
</p><p>It must be mentioned that by the time this document was created, several OWL tools were under development, hence the current overview should be seen as a snapshot of this development rather than an up-to-date overview. Extensive listings of OWL tools can be found at <a class="external text" href="http://semanticweb.org/wiki/Tools" rel="nofollow" title="http://semanticweb.org/wiki/Tools">semanticweb.org</a> and in the <a class="external text" href="http://esw.w3.org/topic/SemanticWebTools" rel="nofollow" title="http://esw.w3.org/topic/SemanticWebTools">ESW-Wiki</a>.
</p>
<a id="What_To_Read_Next" name="What_To_Read_Next"></a><h2> <span class="mw-headline">12 What To Read Next</span></h2>
<p>This short primer can only scratch the surface of OWL.
There are many longer and more involved tutorials on OWL and how to use
OWL tools that can be found by searching on the Web.
Reading one of these documents and using a tool to build an OWL ontology
is probably the best way to obtain a working knowledge about OWL. For learning 
more about the foundations of OWL, we recommend to consult first a textbook [<cite><a href="#ref-FOST" title="">FOST</a></cite>]
and then the original articles cited therein.
An extended introduction to the OWL 2 Profiles can be found in [<cite><a href="#ref-owlprofilesintro" title="">OWL 2 Profiles Introduction</a></cite>],
which is also available on the Web.
</p><p>This short primer is also not a normative definition of OWL.
The normative definition of the OWL syntax as well as informative
descriptions of the meaning of each OWL construct can be found in the
OWL 2 Structural Specification and Functional Syntax document 
[<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>].
</p><p>The OWL 2 Quick Reference Guide [<cite><a href="#ref-owl-2-quick-reference" title="">OWL 2 Quick Guide</a></cite>] comes handy as a reference when looking for information about a specific language feature.
</p><p>For those interested in more formal documents,
the formal meaning of OWL 2 can be found in the OWL 2 Semantics documents
[<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>].
</p><p>The mapping between OWL syntax and RDF triples can be found in 
the OWL 2 Mapping to RDF Graphs document 
[<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>].
</p>
<a id="Appendix:_The_Complete_Sample_Ontology" name="Appendix:_The_Complete_Sample_Ontology"></a><h2> <span class="mw-headline">13 Appendix: The Complete Sample Ontology</span></h2>
<p>Here we include the complete sample OWL ontology. Ontological axioms are ordered by top-level expressive features they use. Moreover, we follow a commonly-used ordering, with ontology and declaration information first, followed by information about properties, then classes and datatypes, then individuals.
</p><p><br />
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>Functional-Style Syntax</b></span></div>
<pre> Prefix(:=&lt;http://example.com/owl/families/&gt;)
 Prefix(otherOnt:=&lt;http://example.org/otherOntologies/families/&gt;)
 Prefix(xsd:=&lt;http://www.w3.org/2001/XMLSchema#&gt;)
 Prefix(owl:=&lt;http://www.w3.org/2002/07/owl#&gt;)
 Ontology(&lt;http://example.com/owl/families&gt;
   Import( &lt;http://example.org/otherOntologies/families.owl&gt; )
 
   Declaration( NamedIndividual(&nbsp;:John ) )
   Declaration( NamedIndividual(&nbsp;:Mary ) )
   Declaration( NamedIndividual(&nbsp;:Jim ) )
   Declaration( NamedIndividual(&nbsp;:James ) )
   Declaration( NamedIndividual(&nbsp;:Jack ) )
   Declaration( NamedIndividual(&nbsp;:Bill ) )
   Declaration( NamedIndividual(&nbsp;:Susan ) )
   Declaration( Class(&nbsp;:Person ) )
   AnnotationAssertion( rdfs:comment&nbsp;:Person "Represents the set of all people." )
   Declaration( Class(&nbsp;:Woman ) )
   Declaration( Class(&nbsp;:Parent ) )
   Declaration( Class(&nbsp;:Father ) )
   Declaration( Class(&nbsp;:Mother ) )
   Declaration( Class(&nbsp;:SocialRole ) )
   Declaration( Class(&nbsp;:Man ) )
   Declaration( Class(&nbsp;:Teenager ) )
   Declaration( Class(&nbsp;:ChildlessPerson ) )
   Declaration( Class(&nbsp;:Human ) )
   Declaration( Class(&nbsp;:Female ) )
   Declaration( Class(&nbsp;:HappyPerson ) )
   Declaration( Class(&nbsp;:JohnsChildren ) )
   Declaration( Class(&nbsp;:NarcisticPerson ) )
   Declaration( Class(&nbsp;:MyBirthdayGuests ) )
   Declaration( Class(&nbsp;:Dead ) )
   Declaration( Class(&nbsp;:Orphan ) )
   Declaration( Class(&nbsp;:Adult ) )
   Declaration( Class(&nbsp;:YoungChild ) )
   Declaration( ObjectProperty(&nbsp;:hasWife ) )
   Declaration( ObjectProperty(&nbsp;:hasChild ) )
   Declaration( ObjectProperty(&nbsp;:hasDaughter ) )
   Declaration( ObjectProperty(&nbsp;:loves ) )
   Declaration( ObjectProperty(&nbsp;:hasSpouse ) )
   Declaration( ObjectProperty(&nbsp;:hasGrandparent ) )
   Declaration( ObjectProperty(&nbsp;:hasParent ) )
   Declaration( ObjectProperty(&nbsp;:hasBrother ) )
   Declaration( ObjectProperty(&nbsp;:hasUncle ) )
   Declaration( ObjectProperty(&nbsp;:hasSon ) )
   Declaration( ObjectProperty(&nbsp;:hasAncestor ) )
   Declaration( ObjectProperty(&nbsp;:hasHusband ) )
   Declaration( DataProperty(&nbsp;:hasAge ) )
   Declaration( DataProperty(&nbsp;:hasSSN ) )
   Declaration( Datatype(&nbsp;:personAge ) )
   Declaration( Datatype(&nbsp;:minorAge ) )
   Declaration( Datatype(&nbsp;:majorAge ) )
   Declaration( Datatype(&nbsp;:toddlerAge ) )
 
   SubObjectPropertyOf(&nbsp;:hasWife&nbsp;:hasSpouse )
   SubObjectPropertyOf(
     ObjectPropertyChain(&nbsp;:hasParent&nbsp;:hasParent )
    &nbsp;:hasGrandparent
   )
   SubObjectPropertyOf(
     ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother )
    &nbsp;:hasUncle
   )
   SubObjectPropertyOf(
    &nbsp;:hasFather
    &nbsp;:hasParent
   )
 
   EquivalentObjectProperties(&nbsp;:hasChild otherOnt:child )
   InverseObjectProperties(&nbsp;:hasParent&nbsp;:hasChild )
   EquivalentDataProperties(&nbsp;:hasAge otherOnt:age )
   DisjointObjectProperties(&nbsp;:hasSon&nbsp;:hasDaughter )
   ObjectPropertyDomain(&nbsp;:hasWife&nbsp;:Man )
   ObjectPropertyRange(&nbsp;:hasWife&nbsp;:Woman )
   DataPropertyDomain(&nbsp;:hasAge&nbsp;:Person )
   DataPropertyRange(&nbsp;:hasAge xsd:nonNegativeInteger )
 
   SymmetricObjectProperty(&nbsp;:hasSpouse )
   AsymmetricObjectProperty(&nbsp;:hasChild )
   DisjointObjectProperties(&nbsp;:hasParent&nbsp;:hasSpouse )
   ReflexiveObjectProperty(&nbsp;:hasRelative )
   IrreflexiveObjectProperty(&nbsp;:parentOf )
   FunctionalObjectProperty(&nbsp;:hasHusband )
   InverseFunctionalObjectProperty(&nbsp;:hasHusband )
   TransitiveObjectProperty(&nbsp;:hasAncestor )
   FunctionalDataProperty(&nbsp;:hasAge )
 
   SubClassOf(&nbsp;:Woman&nbsp;:Person )
   SubClassOf(&nbsp;:Mother&nbsp;:Woman )
   SubClassOf(
    &nbsp;:Grandfather
     ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
   )
   SubClassOf(
    &nbsp;:Teenager
     DataSomeValuesFrom(&nbsp;:hasAge
       DatatypeRestriction( xsd:integer
         xsd:minExclusive "12"^^xsd:integer
         xsd:maxInclusive "19"^^xsd:integer
       )
     )
   )
   SubClassOf(
     Annotation( rdfs:comment "States that every man is a person." )
    &nbsp;:Man
    &nbsp;:Person
   )
   SubClassOf(
    &nbsp;:Father
     ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
   )
   SubClassOf(
    &nbsp;:ChildlessPerson
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(
         ObjectSomeValuesFrom(
           ObjectInverseOf(&nbsp;:hasParent )
           owl:Thing
         )
       )
     )
   )
   SubClassOf(
     ObjectIntersectionOf(
       ObjectOneOf(&nbsp;:Mary&nbsp;:Bill&nbsp;:Meg )
      &nbsp;:Female
     )
     ObjectIntersectionOf(
      &nbsp;:Parent
       ObjectMaxCardinality( 1&nbsp;:hasChild )
       ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:Female )
     )
   )
 
   EquivalentClasses(&nbsp;:Person&nbsp;:Human )
   EquivalentClasses(
    &nbsp;:Mother
     ObjectIntersectionOf(&nbsp;:Woman&nbsp;:Parent )
   )
   EquivalentClasses(
    &nbsp;:Parent
     ObjectUnionOf(&nbsp;:Mother&nbsp;:Father )
   )
   EquivalentClasses(
    &nbsp;:ChildlessPerson
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(&nbsp;:Parent )
     )
   )
   EquivalentClasses(
    &nbsp;:Parent 
     ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:Person )
   )
   EquivalentClasses(
    &nbsp;:HappyPerson
     ObjectIntersectionOf(
        ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
        ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
     )
   )
   EquivalentClasses(
    &nbsp;:JohnsChildren
     ObjectHasValue(&nbsp;:hasParent&nbsp;:John )
   )
   EquivalentClasses(
    &nbsp;:NarcisticPerson
     ObjectHasSelf(&nbsp;:loves )
   )
   EquivalentClasses(
    &nbsp;:MyBirthdayGuests
     ObjectOneOf(&nbsp;:Bill&nbsp;:John&nbsp;:Mary)
   )
   EquivalentClasses(
    &nbsp;:Orphan
     ObjectAllValuesFrom(
       ObjectInverseOf(&nbsp;:hasChild )
      &nbsp;:Dead
     )
   )
   EquivalentClasses(&nbsp;:Adult otherOnt:Grownup )
   EquivalentClasses(
    &nbsp;:Parent
     ObjectSomeValuesFrom(
      &nbsp;:hasChild
      &nbsp;:Person
     )
   )
 
   DisjointClasses(&nbsp;:Woman&nbsp;:Man )
   DisjointClasses(
    &nbsp;:Mother
    &nbsp;:Father
    &nbsp;:YoungChild
   )
   HasKey(&nbsp;:Person () (&nbsp;:hasSSN ) )
 
   DatatypeDefinition(
    &nbsp;:personAge
     DatatypeRestriction( xsd:integer
       xsd:minInclusive "0"^^xsd:integer
       xsd:maxInclusive "150"^^xsd:integer
     )
   )
   DatatypeDefinition(
    &nbsp;:minorAge
     DatatypeRestriction( xsd:integer
       xsd:minInclusive "0"^^xsd:integer
       xsd:maxInclusive "18"^^xsd:integer
     )
   )
   DatatypeDefinition(
    &nbsp;:majorAge
     DataIntersectionOf(
      &nbsp;:personAge
       DataComplementOf(&nbsp;:minorAge )
     )
   )
   DatatypeDefinition(
    &nbsp;:toddlerAge
     DataOneOf( "1"^^xsd:integer "2"^^xsd:integer ) 
   )
 
   ClassAssertion(&nbsp;:Person&nbsp;:Mary )
   ClassAssertion(&nbsp;:Woman&nbsp;:Mary )
   ClassAssertion(
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(&nbsp;:Parent )
     )
    &nbsp;:Jack
   )
   ClassAssertion(
     ObjectMaxCardinality( 4&nbsp;:hasChild&nbsp;:Parent )
    &nbsp;:John
   )
   ClassAssertion(
     ObjectMinCardinality( 2&nbsp;:hasChild&nbsp;:Parent )
    &nbsp;:John
   )
   ClassAssertion(
     ObjectExactCardinality( 3&nbsp;:hasChild&nbsp;:Parent ) 
    &nbsp;:John
   )
   ClassAssertion(
     ObjectExactCardinality( 5&nbsp;:hasChild )
    &nbsp;:John
   )
   ClassAssertion(&nbsp;:Father&nbsp;:John )
   ClassAssertion(&nbsp;:SocialRole&nbsp;:Father )
 
   ObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:John&nbsp;:Mary )
   NegativeObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:Bill&nbsp;:Mary )
   NegativeObjectPropertyAssertion(
    &nbsp;:hasDaughter
    &nbsp;:Bill
    &nbsp;:Susan
   )
   DataPropertyAssertion(&nbsp;:hasAge&nbsp;:John "51"^^xsd:integer )
   NegativeDataPropertyAssertion(&nbsp;:hasAge&nbsp;:Jack "53"^^xsd:integer )
 
   SameIndividual(&nbsp;:James&nbsp;:Jim )
   SameIndividual(&nbsp;:John otherOnt:JohnBrown )
   SameIndividual(&nbsp;:Mary otherOnt:MaryBrown )
   DifferentIndividuals(&nbsp;:John&nbsp;:Bill )
 )
</pre>
</div><div class="rdfxml"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML Syntax</b></span></div>
<pre>&lt;!DOCTYPE rdf:RDF [
    &lt;!ENTITY owl "http://www.w3.org/2002/07/owl#" &gt;
    &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
    &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
    &lt;!ENTITY otherOnt "http://example.org/otherOntologies/families/" &gt;
]&gt;
 
 &lt;rdf:RDF xml:base="http://example.com/owl/families/"
   xmlns="http://example.com/owl/families/"
   xmlns:otherOnt="http://example.org/otherOntologies/families/"
   xmlns:owl="http://www.w3.org/2002/07/owl#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema#"&gt;
 
   &lt;owl:Ontology rdf:about="http://example.com/owl/families"&gt;
     &lt;owl:imports rdf:resource="http://example.org/otherOntologies/families.owl" /&gt;
   &lt;/owl:Ontology&gt;
 
 
   &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
     &lt;rdfs:subPropertyOf rdf:resource="hasSpouse"/&gt;
     &lt;rdfs:domain rdf:resource="Man"/&gt;
     &lt;rdfs:range rdf:resource="Woman"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasParent"&gt;
     &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
     &lt;owl:propertyDisjointWith rdf:resource="hasSpouse"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasSon"&gt;
     &lt;owl:propertyDisjointWith rdf:resource="hasDaughter"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasFather"&gt;
     &lt;rdfs:subPropertyOf rdf:resource="hasParent"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:SymmetricProperty rdf:about="hasSpouse"/&gt;
   &lt;owl:AsymmetricProperty rdf:about="hasChild"/&gt;
   &lt;owl:ReflexiveProperty rdf:about="hasRelative"/&gt;
   &lt;owl:IrreflexiveProperty rdf:about="parentOf"/&gt;
   &lt;owl:FunctionalProperty rdf:about="hasHusband"/&gt;
   &lt;owl:InverseFunctionalProperty rdf:about="hasHusband"/&gt;
   &lt;owl:TransitiveProperty rdf:about="hasAncestor"/&gt;
 
   &lt;rdf:Description rdf:about="hasGrandparent"&gt;
     &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
       &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
       &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
     &lt;/owl:propertyChainAxiom&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="hasUncle"&gt;
     &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
       &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
       &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
     &lt;/owl:propertyChainAxiom&gt;
   &lt;/rdf:Description&gt;

   &lt;owl:ObjectProperty rdf:about="hasChild"&gt;
     &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;child"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
     &lt;rdfs:domain rdf:resource="Person"/&gt;
     &lt;rdfs:range rdf:resource="&amp;xsd;nonNegativeInteger"/&gt;
     &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;age"/&gt;
   &lt;/owl:DatatypeProperty&gt;
   &lt;owl:FunctionalProperty rdf:about="hasAge"/&gt;
 
   &lt;owl:Class rdf:about="Woman"&gt;
     &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Mother"&gt;
     &lt;rdfs:subClassOf rdf:resource="Woman"/&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Woman"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Person"&gt;
     &lt;rdfs:comment&gt;Represents the set of all people.&lt;/rdfs:comment&gt;
     &lt;owl:equivalentClass rdf:resource="Human"/&gt;
     &lt;owl:hasKey rdf:parseType="Collection"&gt;
       &lt;owl:DataProperty rdf:about="hasSSN"/&gt;
     &lt;/owl:hasKey&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Parent"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:unionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Mother"/&gt;
           &lt;owl:Class rdf:about="Father"/&gt;
         &lt;/owl:unionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="ChildlessPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf rdf:resource="Parent"/&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Grandfather"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Man"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="HappyPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
           &lt;/owl:Restriction&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:someValuesFrom rdf:resource="HappyPerson"/&gt;
           &lt;/owl:Restriction&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="JohnsChildren"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasParent"/&gt;
         &lt;owl:hasValue rdf:resource="John"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="NarcisticPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="loves"/&gt;
         &lt;owl:hasSelf rdf:datatype="&amp;xsd;boolean"&gt;
           true
         &lt;/owl:hasSelf&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="MyBirthdayGuests"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:oneOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="Bill"/&gt;
           &lt;rdf:Description rdf:about="John"/&gt;
           &lt;rdf:Description rdf:about="Mary"/&gt;
         &lt;/owl:oneOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Orphan"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty&gt;
           &lt;owl:ObjectProperty&gt;
             &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
           &lt;/owl:ObjectProperty&gt;
         &lt;/owl:onProperty&gt;
         &lt;owl:allValuesFrom rdf:resource="Dead"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Teenager"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasAge"/&gt;
         &lt;owl:someValuesFrom&gt;
           &lt;rdfs:Datatype&gt;
             &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
             &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
               &lt;rdf:Description&gt;
                 &lt;xsd:minExclusive rdf:datatype="&amp;xsd;integer"&gt;12&lt;/xsd:minExclusive&gt;
               &lt;/rdf:Description&gt;
               &lt;rdf:Description&gt;
                 &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;19&lt;/xsd:maxInclusive&gt;
               &lt;/rdf:Description&gt;
             &lt;/owl:withRestrictions&gt;
           &lt;/rdfs:Datatype&gt;
         &lt;/owl:someValuesFrom&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Man"&gt;
     &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
   &lt;/owl:Class&gt;
   &lt;owl:Axiom&gt;
     &lt;owl:annotatedSource rdf:resource="Man"/&gt;
     &lt;owl:annotatedProperty rdf:resource="&amp;rdfs;subClassOf"/&gt;
     &lt;owl:annotatedTarget rdf:resource="Person"/&gt;
     &lt;rdfs:comment&gt;States that every man is a person.&lt;/rdfs:comment&gt;
   &lt;/owl:Axiom&gt;
 
   &lt;owl:Class rdf:about="Adult"&gt;
     &lt;owl:equivalentClass rdf:resource="&amp;otherOnt;Grownup"/&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Father"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Man"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="ChildlessPerson"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf&gt;
               &lt;owl:Restriction&gt;
                 &lt;owl:onProperty&gt;
                   &lt;owl:ObjectProperty&gt;
                     &lt;owl:inverseOf rdf:resource="hasParent"/&gt;
                   &lt;/owl:ObjectProperty&gt;
                 &lt;/owl:onProperty&gt;
                 &lt;owl:someValuesFrom rdf:resource="&amp;owl;Thing"/&gt;
               &lt;/owl:Restriction&gt;
             &lt;/owl:complementOf&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class&gt;
     &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
       &lt;owl:Class&gt;
         &lt;owl:oneOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="Mary"/&gt;
           &lt;rdf:Description rdf:about="Bill"/&gt;
           &lt;rdf:Description rdf:about="Meg"/&gt;
         &lt;/owl:oneOf&gt;
       &lt;/owl:Class&gt;
       &lt;owl:Class rdf:about="Female"/&gt;
     &lt;/owl:intersectionOf&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:maxCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
               1
             &lt;/owl:maxCardinality&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;/owl:Restriction&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:allValuesFrom rdf:resource="Female"/&gt;
           &lt;/owl:Restriction&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:AllDisjointClasses&gt;
     &lt;owl:members rdf:parseType="Collection"&gt;
       &lt;owl:Class rdf:about="Woman"/&gt;
       &lt;owl:Class rdf:about="Man"/&gt;
     &lt;/owl:members&gt;
   &lt;/owl:AllDisjointClasses&gt;
 
   &lt;owl:AllDisjointClasses&gt;
     &lt;owl:members rdf:parseType="Collection"&gt;
       &lt;owl:Class rdf:about="Mother"/&gt;
       &lt;owl:Class rdf:about="Father"/&gt;
       &lt;owl:Class rdf:about="YoungChild"/&gt;
     &lt;/owl:members&gt;
   &lt;/owl:AllDisjointClasses&gt;
 
 
   &lt;rdf:Description rdf:about="personAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
         &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:minInclusive rdf:datatype="&amp;xsd;integer"&gt;0&lt;/xsd:minInclusive&gt;
           &lt;/rdf:Description&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;150&lt;/xsd:maxInclusive&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:withRestrictions&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;

   &lt;rdf:Description rdf:about="minorAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
         &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:minInclusive rdf:datatype="&amp;xsd;integer"&gt;0&lt;/xsd:minInclusive&gt;
           &lt;/rdf:Description&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;18&lt;/xsd:maxInclusive&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:withRestrictions&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="majorAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="personAge"/&gt;
           &lt;rdfs:Datatype&gt;
             &lt;owl:datatypeComplementOf rdf:resource="minorAge"/&gt;
           &lt;/rdfs:Datatype&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="toddlerAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:oneOf&gt;
           &lt;rdf:Description&gt;
             &lt;rdf:first rdf:datatype="&amp;xsd;integer"&gt;1&lt;/rdf:first&gt;
             &lt;rdf:rest&gt;
               &lt;rdf:Description&gt;
                 &lt;rdf:first rdf:datatype="&amp;xsd;integer"&gt;2&lt;/rdf:first&gt;
                 &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt;
               &lt;/rdf:Description&gt;
             &lt;/rdf:rest&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:oneOf&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
 
   &lt;Person rdf:about="Mary"&gt;
     &lt;rdf:type rdf:resource="Woman"/&gt;
     &lt;owl:sameAs rdf:resource="&amp;otherOnt;MaryBrown"/&gt;
   &lt;/Person&gt;
 
   &lt;owl:NamedIndividual rdf:about="James"&gt;
     &lt;owl:sameAs rdf:resource="Jim"/&gt;
   &lt;/owl:NamedIndividual&gt;
 
   &lt;rdf:Description rdf:about="Jack"&gt;
     &lt;rdf:type&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf  rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf rdf:resource="Parent"/&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdf:type&gt;
   &lt;/rdf:Description&gt;
 
   &lt;owl:NamedIndividual rdf:about="John"&gt;
     &lt;hasWife rdf:resource="Mary"/&gt;
     &lt;hasAge rdf:datatype="&amp;xsd;integer"&gt;51&lt;/hasAge&gt;
     &lt;owl:differentFrom rdf:resource="Bill"/&gt;
     &lt;owl:sameAs rdf:resource="&amp;otherOnt;JohnBrown"/&gt;
     &lt;rdf:type rdf:resource="Father"/&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:maxQualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           4
         &lt;/owl:maxQualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:minQualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           2
         &lt;/owl:minQualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:qualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           3
         &lt;/owl:qualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:cardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           5
         &lt;/owl:cardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
   &lt;/owl:NamedIndividual&gt;
 
   &lt;SocialRole rdf:about="Father"/&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasWife"/&gt;
     &lt;owl:targetIndividual rdf:resource="Mary"/&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Jack"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasAge"/&gt;
     &lt;owl:targetValue rdf:datatype="&amp;xsd;integer"&gt;53&lt;/owl:targetValue&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasDaughter"/&gt;
     &lt;owl:targetIndividual rdf:resource="Susan"/&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 &lt;/rdf:RDF&gt;
</pre>
</div><div class="turtle"><div class="exampleheader"><span class="exampleheader"><b>Turtle Syntax</b></span></div>
<pre>@prefix&nbsp;: &lt;http://example.com/owl/families/&gt; .
@prefix otherOnt: &lt;http://example.org/otherOntologies/families/&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

&lt;http://example.com/owl/families&gt; 
     rdf:type owl:Ontology&nbsp;;
     owl:imports &lt;http://example.org/otherOntologies/families.owl&gt; .

:hasSpouse    rdf:type  owl:SymmetricProperty .
:hasRelative  rdf:type  owl:ReflexiveProperty .
:parentOf     rdf:type  owl:IrreflexiveProperty .
:hasAncestor  rdf:type  owl:TransitiveProperty .

:hasHusband   rdf:type  owl:FunctionalProperty .
:hasHusband   rdf:type  owl:InverseFunctionalProperty .

:hasWife rdf:type           owl:ObjectProperty .
:hasWife rdfs:domain       &nbsp;:Man&nbsp;;
         rdfs:range        &nbsp;:Woman .
:hasWife rdfs:subPropertyOf&nbsp;:hasSpouse .

:hasSon     owl:propertyDisjointWith &nbsp;:hasDaughter.
:hasFather  rdfs:subPropertyOf       &nbsp;:hasParent.
 
:hasParent owl:inverseOf            &nbsp;:hasChild .
:hasParent owl:propertyDisjointWith &nbsp;:hasSpouse .

:hasGrandparent  owl:propertyChainAxiom  (&nbsp;:hasParent &nbsp;:hasParent ) .
:hasUncle        owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .

:hasAge  owl:equivalentProperty  otherOnt:age .
:hasAge  rdf:type                owl:DatatypeProperty .
:hasAge  rdf:type                owl:FunctionalProperty .
:hasAge  rdfs:domain            &nbsp;:Person&nbsp;;
         rdfs:range              xsd:nonNegativeInteger .

:hasChild  owl:equivalentProperty  otherOnt:child .
:hasChild  rdf:type                owl:AsymmetricProperty .

:Woman   rdfs:subClassOf&nbsp;:Person .

:Mother  rdfs:subClassOf&nbsp;:Woman .
:Mother  owl:equivalentClass  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Woman&nbsp;:Parent ) 
] .

:Person  rdf:type            owl:Class .
:Person  owl:equivalentClass&nbsp;:Human .
:Person  rdfs:comment        "Represents the set of all people."^^xsd:string .
:Person  owl:hasKey          (&nbsp;:hasSSN ) .
:hasSSN  rdf:type            owl:DataProperty .
:Parent  owl:equivalentClass [
  rdf:type     owl:Class&nbsp;;
  owl:unionOf  (&nbsp;:Mother&nbsp;:Father )
] .

:Parent  owl:equivalentClass  [
  rdf:type            owl:Restriction&nbsp;;
  owl:onProperty     &nbsp;:hasChild&nbsp;;
  owl:someValuesFrom &nbsp;:Person
] .

:Grandfather  rdfs:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
] .

:HappyPerson
    owl:equivalentClass  [
      rdf:type            owl:Class&nbsp;;
      owl:intersectionOf  ( [ rdf:type            owl:Restriction&nbsp;;
                              owl:onProperty     &nbsp;:hasChild&nbsp;;
                              owl:allValuesFrom  &nbsp;:HappyPerson      ]
                            [ rdf:type            owl:Restriction&nbsp;;
                              owl:onProperty     &nbsp;:hasChild&nbsp;;
                              owl:someValuesFrom &nbsp;:HappyPerson      ]
                          )
    ] .

:JohnsChildren  owl:equivalentClass  [
  rdf:type        owl:Restriction&nbsp;;
  owl:onProperty &nbsp;:hasParent&nbsp;;
  owl:hasValue   &nbsp;:John
] .

:NarcisticPerson owl:equivalentClass  [
  rdf:type        owl:Restriction&nbsp;;
  owl:onProperty &nbsp;:loves&nbsp;;
  owl:hasSelf     "true"^^xsd:boolean .
] .

:MyBirthdayGuests  owl:equivalentClass  [
  rdf:type   owl:Class&nbsp;;
  owl:oneOf  (&nbsp;:Bill &nbsp;:John &nbsp;:Mary )
] .
:Orphan  owl:equivalentClass  [
  rdf:type           owl:Restriction&nbsp;;
  owl:onProperty     [ owl:inverseOf &nbsp;:hasChild ]&nbsp;;
  owl:allValuesFrom &nbsp;:Dead 
] .

:Teenager  rdfs:subClassOf
      [ rdf:type             owl:Restriction&nbsp;;
        owl:onProperty      &nbsp;:hasAge&nbsp;;
        owl:someValuesFrom
         [ rdf:type             rdfs:Datatype&nbsp;;
           owl:onDatatype       xsd:integer&nbsp;;
           owl:withRestrictions (  [ xsd:minExclusive     "12"^^xsd:integer ]
                                   [ xsd:maxInclusive     "19"^^xsd:integer ]
           )
         ]
      ] .

:Man rdfs:subClassOf       &nbsp;:Person .
[]   rdf:type               owl:Axiom&nbsp;;
     owl:annotatedSource   &nbsp;:Man&nbsp;;
     owl:annotatedProperty  rdfs:subClassOf&nbsp;;
     owl:annotatedTarget   &nbsp;:Person&nbsp;;
     rdfs:comment           "States that every man is a person."^^xsd:string .

:Adult owl:equivalentClass otherOnt:Grownup .

:Father rdfs:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
] .

:ChildlessPerson      owl:equivalentClass  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person  [ owl:complementOf &nbsp;:Parent ] ) 
] .
:ChildlessPerson      owl:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person
                        [ owl:complementOf  [
                            rdf:type            owl:Restriction&nbsp;;
                            owl:onProperty      [ owl:inverseOf &nbsp;:hasParent ]&nbsp;;
                            owl:someValuesFrom  owl:Thing
                          ]
                        ]
                      )
] .

[]  rdf:type            owl:Class&nbsp;;
    owl:intersectionOf  ( [ rdf:type   owl:Class&nbsp;;
                            owl:oneOf  (&nbsp;:Mary &nbsp;:Bill &nbsp;:Meg ) ]
                         &nbsp;:Female 
                        )&nbsp;;
    rdfs:subClassOf     [
      rdf:type            owl:Class&nbsp;;
      owl:intersectionOf  (&nbsp;:Parent  
                            [ rdf:type            owl:Restriction&nbsp;;
                              owl:maxCardinality  "1"^^xsd:nonNegativeInteger&nbsp;;
                              owl:onProperty     &nbsp;:hasChild ]
                            [ rdf:type           owl:Restriction&nbsp;;
                              owl:onProperty    &nbsp;:hasChild&nbsp;;
                              owl:allValuesFrom &nbsp;:Female ]
                          )
    ] .

[] rdf:type     owl:AllDisjointClasses&nbsp;;
   owl:members  (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .

[] rdf:type     owl:AllDisjointClasses&nbsp;;
   owl:members  (&nbsp;:Woman &nbsp;:Man ) .

:personAge  owl:equivalentClass
 [ rdf:type       rdfs:Datatype;
   owl:onDatatype xsd:integer;
   owl:withRestrictions (
      [ xsd:minInclusive "0"^^xsd:integer ]
      [ xsd:maxInclusive "150"^^xsd:integer ] 
   )
 ] .
</pre>
<pre>:minorAge  owl:equivalentClass
 [ rdf:type       rdfs:Datatype;
   owl:onDatatype xsd:integer;
   owl:withRestrictions (
      [ xsd:minInclusive "0"^^xsd:integer ]
      [ xsd:maxInclusive "18"^^xsd:integer ] 
   )
 ] .
</pre>
<pre>:majorAge  owl:equivalentClass
  [ rdf:type           rdfs:Datatype;
    owl:intersectionOf (
      &nbsp;:personAge
       [ rdf:type rdfs:Datatype;
         owl:datatypeComplementOf&nbsp;:minorAge ] 
    )
  ] .

:toddlerAge  owl:equivalentClass
  [ rdf:type  rdfs:Datatype;
    owl:oneOf (  "1"^^xsd:integer  "2"^^xsd:integer )
  ] .

:Mary rdf:type  &nbsp;:Person .
:Mary rdf:type  &nbsp;:Woman .
:Mary owl:sameAs otherOnt:MaryBrown .

:James owl:sameAs&nbsp;:Jim .

:Jack  rdf:type          [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person  
                        [ rdf:type          owl:Class&nbsp;;
                          owl:complementOf &nbsp;:Parent     ]
                      )
] .

:John  owl:sameAs        otherOnt:JohnBrown .
:John  rdf:type          owl:NamedIndividual .
:John  rdf:type         &nbsp;:Father .
:John &nbsp;:hasWife         &nbsp;:Mary .
:John  owl:differentFrom&nbsp;:Bill .
:John &nbsp;:hasAge           51 .
:John  rdf:type  [
  rdf:type                     owl:Restriction&nbsp;;
  owl:maxQualifiedCardinality  "4"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty              &nbsp;:hasChild&nbsp;;
  owl:onClass                 &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type                     owl:Restriction&nbsp;;
  owl:minQualifiedCardinality  "2"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty              &nbsp;:hasChild&nbsp;;
  owl:onClass                 &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type                  owl:Restriction&nbsp;;
  owl:qualifiedCardinality  "3"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty           &nbsp;:hasChild&nbsp;;
  owl:onClass              &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type         owl:Restriction&nbsp;;
  owl:cardinality  "5"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty  &nbsp;:hasChild
] .

:Father rdf:type&nbsp;:SocialRole .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Bill&nbsp;;
    owl:assertionProperty &nbsp;:hasWife&nbsp;;
    owl:targetIndividual  &nbsp;:Mary .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Bill&nbsp;;
    owl:assertionProperty &nbsp;:hasDaughter&nbsp;;
    owl:targetIndividual  &nbsp;:Susan .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Jack&nbsp;;
    owl:assertionProperty &nbsp;:hasAge&nbsp;;
    owl:targetValue        53 .
</pre>
</div><div class="manchester"><div class="exampleheader"><span class="exampleheader"><b>Manchester Syntax</b></span></div>
<pre>Prefix:&nbsp;: &lt;http://example.com/owl/families/&gt;
Prefix: xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
Prefix: owl: &lt;http://www.w3.org/2002/07/owl#&gt;
Prefix: otherOnt: &lt;http://example.org/otherOntologies/families/&gt;
Ontology: &lt;http://example.com/owl/families&gt;
Import: &lt;http://example.org/otherOntologies/families.owl&gt;

ObjectProperty: hasWife
  SubPropertyOf: hasSpouse
  Domain:        Man
  Range:         Woman
ObjectProperty: hasParent
  InverseOf: hasChild
ObjectProperty: hasSpouse
  Characteristics: Symmetric
ObjectProperty: hasChild
  Characteristics: Asymmetric
ObjectProperty: hasRelative
  Characteristics: Reflexive
ObjectProperty: parentOf
  Characteristics: Irreflexive
ObjectProperty: hasHusband
  Characteristics: Functional
  Characteristics: InverseFunctional
ObjectProperty: hasAncestor
  Characteristics: Transitive
ObjectProperty: hasGrandparent
  SubPropertyChain: hasParent o hasParent
ObjectProperty: hasUncle
  SubPropertyChain: hasFather o hasBrother
ObjectProperty: hasFather
  SubPropertyOf: hasParent
ObjectProperty: hasBrother
ObjectProperty: hasDaughter
ObjectProperty: hasSon
ObjectProperty: loves

DisjointProperties: hasParent, hasSpouse
DisjointProperties: hasSon,    hasDaughter
EquivalentProperties: hasChild, otherOnt:child
EquivalentProperties: hasAge,   otherOnt:age

DataProperty: hasAge
  Domain: Person
  Range:  xsd:nonNegativeInteger
  Characteristics: Functional
DataProperty: hasSSN

Datatype: personAge
  EquivalentTo: integer[&lt;= 0 , &gt;= 150]
Datatype: minorAge
  EquivalentTo: integer[&lt;= 0 , &gt;= 18]
Datatype: majorAge
   EquivalentTo: personAge and not minorAge
Datatype: toddlerAge
   EquivalentTo: { 1, 2 }
Datatype: minorAge

Class: Woman
  SubClassOf: Person
Class: Mother
  SubClassOf:   Woman
  EquivalentTo: Woman and Parent
Class: Person
  Annotations:  rdfs:comment "Represents the set of all people."
  EquivalentTo: Human
  HasKey: hasSSN
Class: Parent
  EquivalentTo: hasChild some Person
  EquivalentTo: Mother or Father
Class: ChildlessPerson
  EquivalentTo: Person and not Parent
  SubClassOf:   Person and not (inverse hasParent some owl:Thing)
Class: Grandfather
  SubClassOf: Man and Parent
Class: HappyPerson
  EquivalentTo: hasChild only Happy and hasChild some Happy
Class: JohnsChildren
  EquivalentTo: hasParent value John
Class: NarcisticPerson
  EquivalentTo: loves Self
Class: Orphan
  EquivalentTo: inverse hasChild only Dead
Class: Teenager
 SubClassOf: hasAge some integer[&lt;= 13 , &gt;= 19]
Class: Man
  SubClassOf: Annotations: rdfs:comment "States that every man is a person." Person
Class: MyBirthdayGuests
  EquivalentTo: { Bill, John, Mary }
Class: Father
  SubClassOf: Man and Parent
Class: X
  SubClassOf:   Parent and hasChild max 1 and hasChild only Female
  EquivalentTo: {Mary, Bill, Meg} and Female
Class: Adult
Class: Dead
Class: Father
Class: Female
Class: Happy
Class: Human
Class: SocialRole
Class: YoungChild

DisjointClasses: Mother, Father, YoungChild
DisjointClasses: Woman, Man
EquivalentClasses: Adult, otherOnt:Grownup

Individual: Mary
  Types: Person
  Types: Woman
Individual: Jack
  Types: Person and not Parent
Individual: John
  Types: Father
  Types: hasChild max 4 Parent
  Types: hasChild min 2 Parent
  Types: hasChild exactly 3 Parent
  Types: hasChild exactly 5
  Facts: hasAge "51"^^xsd:integer
  Facts: hasWife Mary
  DifferentFrom: Bill 
Individual: Bill
  Facts: not hasWife     Mary
  Facts: not hasDaughter Susan
Individual: James 
  SameAs: Jim
Individual: Jack
  Facts: not hasAge "53"^^xsd:integer
Individual: Father
 Types: SocialRole
Individual: Meg
Individual: Susan
Individual: Jim
Individual: otherOnt:JohnBrown
Individual: otherOnt:MaryBrown

SameIndividual: John, otherOnt:JohnBrown 
SameIndividual: Mary, otherOnt:MaryBrown
</pre>
</div><div class="owlxml"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML Syntax</b></span></div>
<pre>&lt;!DOCTYPE Ontology [
   &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
   &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
]&gt;

 &lt;Ontology
   xml:base="http://example.com/owl/families/"
   ontologyIRI="http://example.com/owl/families"
   xmlns="http://www.w3.org/2002/07/owl#"&gt;
   &lt;Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/&gt;
   &lt;Prefix name="otherOnt" IRI="http://example.org/otherOntologies/families/"/&gt;
   &lt;Import&gt;http://example.org/otherOntologies/families.owl&lt;/Import&gt;

   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Jim"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="James"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Susan"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Meg"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/Declaration&gt;
   &lt;AnnotationAssertion&gt;
     &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
     &lt;IRI&gt;Person&lt;/IRI&gt;
     &lt;Literal&gt;Represents the set of all people.&lt;/Literal&gt;
   &lt;/AnnotationAssertion&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Father"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Mother"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="SocialRole"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Man"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Teenager"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Human"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Female"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="HappyPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="JohnsChildren"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="MyBirthdayGuests"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Dead"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Orphan"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Adult"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="YoungChild"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasGrandparent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasSon"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasAncestor"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;DataProperty IRI="hasSSN"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;Datatype IRI="personAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="minorAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="majorAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="toddlerAge"/&gt;
   &lt;/Declaration&gt;

   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="personAge"/&gt;
     &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="&amp;xsd;integer"/&gt;
       &lt;FacetRestriction facet="&amp;xsd;minInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;150&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
     &lt;/DatatypeRestriction&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="minorAge"/&gt;
     &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="&amp;xsd;integer"/&gt;
       &lt;FacetRestriction facet="&amp;xsd;minInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;18&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
     &lt;/DatatypeRestriction&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="majorAge"/&gt;
     &lt;DataIntersectionOf&gt;
       &lt;Datatype IRI="personAge"/&gt;
       &lt;DataComplementOf&gt;
         &lt;Datatype IRI="minorAge"/&gt;
       &lt;/DataComplementOf&gt;
     &lt;/DataIntersectionOf&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="toddlerAge"/&gt;
     &lt;DataOneOf&gt;
       &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;1&lt;/Literal&gt; 
       &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;2&lt;/Literal&gt;
     &lt;/DataOneOf&gt;
   &lt;/DatatypeDefinition&gt;
 
   &lt;SymmetricObjectProperty&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/SymmetricObjectProperty&gt;
   &lt;AsymmetricObjectProperty&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/AsymmetricObjectProperty&gt;
   &lt;DisjointObjectProperties&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/DisjointObjectProperties&gt;
   &lt;ReflexiveObjectProperty&gt;
     &lt;ObjectProperty IRI="hasRelative"/&gt;
   &lt;/ReflexiveObjectProperty&gt;
   &lt;IrreflexiveObjectProperty&gt;
     &lt;ObjectProperty IRI="parentOf"/&gt;
   &lt;/IrreflexiveObjectProperty&gt;
   &lt;FunctionalObjectProperty&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/FunctionalObjectProperty&gt;
   &lt;InverseFunctionalObjectProperty&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/InverseFunctionalObjectProperty&gt;
   &lt;TransitiveObjectProperty&gt;
     &lt;ObjectProperty IRI="hasAncestor"/&gt;
   &lt;/TransitiveObjectProperty&gt;

   &lt;ObjectPropertyDomain&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;Class IRI="Man"/&gt;
   &lt;/ObjectPropertyDomain&gt;
   &lt;ObjectPropertyRange&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/ObjectPropertyRange&gt;

   &lt;InverseObjectProperties&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/InverseObjectProperties&gt;

   &lt;DisjointObjectProperties&gt;
     &lt;ObjectProperty IRI="hasSon"/&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;/DisjointObjectProperties&gt;

   &lt;EquivalentObjectProperties&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;ObjectProperty abbreviatedIRI="otherOnt:child"/&gt;
   &lt;/EquivalentObjectProperties&gt;

   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasGrandparent"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasFather"/&gt;
       &lt;ObjectProperty IRI="hasBrother"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasFather"/&gt;
       &lt;ObjectProperty IRI="hasBrother"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/SubObjectPropertyOf&gt;

   &lt;HasKey&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;DataProperty IRI="hasSSN"/&gt;
   &lt;/HasKey&gt;

   &lt;DataPropertyDomain&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/DataPropertyDomain&gt;
   &lt;DataPropertyRange&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;Datatype IRI="&amp;xsd;nonNegativeInteger"/&gt;
   &lt;/DataPropertyRange&gt;
   &lt;FunctionalDataProperty&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
   &lt;/FunctionalDataProperty&gt;
   &lt;EquivalentDataProperties&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;DataProperty abbreviatedIRI="otherOnt:age"/&gt;
   &lt;/EquivalentDataProperties&gt;

   &lt;SubClassOf&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Grandfather"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Man"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Man"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;ObjectSomeValuesFrom&gt;
           &lt;ObjectInverseOf&gt;
             &lt;ObjectProperty IRI="hasParent"/&gt;
           &lt;/ObjectInverseOf&gt;
           &lt;Class abbreviatedIRI="owl:Thing"/&gt;
         &lt;/ObjectSomeValuesFrom&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;ObjectOneOf&gt;
         &lt;NamedIndividual IRI="Mary"/&gt;
         &lt;NamedIndividual IRI="Bill"/&gt;
         &lt;NamedIndividual IRI="Meg"/&gt;
       &lt;/ObjectOneOf&gt;
       &lt;Class IRI="Female"/&gt;
     &lt;/ObjectIntersectionOf&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Parent"/&gt;
       &lt;ObjectMaxCardinality cardinality="1"&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;/ObjectMaxCardinality&gt;
       &lt;ObjectAllValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="Female"/&gt;
       &lt;/ObjectAllValuesFrom&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Teenager"/&gt;
     &lt;DataSomeValuesFrom&gt;
       &lt;DataProperty IRI="hasAge"/&gt;
       &lt;DatatypeRestriction&gt;
         &lt;Datatype IRI="&amp;xsd;integer"/&gt;
         &lt;FacetRestriction facet="&amp;xsd;minExclusive"&gt;
           &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;12&lt;/Literal&gt;
         &lt;/FacetRestriction&gt;
         &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
           &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;19&lt;/Literal&gt;
         &lt;/FacetRestriction&gt;
       &lt;/DatatypeRestriction&gt;
     &lt;/DataSomeValuesFrom&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Annotation&gt;
       &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
       &lt;Literal datatypeIRI="&amp;xsd;string"&gt;"States that every man is a person."&lt;/Literal&gt;
     &lt;/Annotation&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/SubClassOf&gt;

   &lt;EquivalentClasses&gt;
     &lt;Class IRI="HappyPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;ObjectAllValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="HappyPerson"/&gt;
       &lt;/ObjectAllValuesFrom&gt;
       &lt;ObjectSomeValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="HappyPerson"/&gt;
       &lt;/ObjectSomeValuesFrom&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="JohnsChildren"/&gt;
     &lt;ObjectHasValue&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
       &lt;NamedIndividual IRI="John"/&gt;
     &lt;/ObjectHasValue&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="NarcisticPerson"/&gt;
     &lt;ObjectHasSelf&gt;
       &lt;ObjectProperty IRI="loves"/&gt;
     &lt;/ObjectHasSelf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Orphan"/&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectInverseOf&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;/ObjectInverseOf&gt;
       &lt;Class IRI="Dead"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="MyBirthdayGuests"/&gt;
     &lt;ObjectOneOf&gt;
       &lt;NamedIndividual IRI="Bill"/&gt;
       &lt;NamedIndividual IRI="John"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
     &lt;/ObjectOneOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Adult"/&gt;
     &lt;Class abbreviatedIRI="otherOnt:Grownup"/&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Person"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Person"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;Class IRI="Human"/&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectUnionOf&gt;
       &lt;Class IRI="Mother"/&gt;
       &lt;Class IRI="Father"/&gt;
     &lt;/ObjectUnionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;Class IRI="Parent"/&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;

   &lt;DisjointClasses&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;Class IRI="Man"/&gt;
   &lt;/DisjointClasses&gt;
   &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
   &lt;/DisjointClasses&gt;

   &lt;DifferentIndividuals&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;/DifferentIndividuals&gt;

   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="James"/&gt;
     &lt;NamedIndividual IRI="Jim"/&gt;
   &lt;/SameIndividual&gt;
   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual abbreviatedIRI="otherOnt:JohnBrown"/&gt;
   &lt;/SameIndividual&gt;
   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
     &lt;NamedIndividual abbreviatedIRI="otherOnt:MaryBrown"/&gt;
   &lt;/SameIndividual&gt;

   &lt;ObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ObjectPropertyAssertion&gt;

   &lt;DataPropertyAssertion&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;51&lt;/Literal&gt;
   &lt;/DataPropertyAssertion&gt;

   &lt;ClassAssertion&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;Class IRI="Parent"/&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;ClassAssertion&gt;
     &lt;ObjectMaxCardinality cardinality="4"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectMaxCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectMinCardinality cardinality="2"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectMinCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectExactCardinality cardinality="3"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectExactCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectExactCardinality cardinality="5"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectExactCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;ClassAssertion&gt;
     &lt;Class IRI="SocialRole"/&gt;
     &lt;NamedIndividual IRI="Father"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;NegativeObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/NegativeObjectPropertyAssertion&gt;
   &lt;NegativeDataPropertyAssertion&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
     &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;53&lt;/Literal&gt;
   &lt;/NegativeDataPropertyAssertion&gt;
   &lt;NegativeObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="Susan"/&gt;
   &lt;/NegativeObjectPropertyAssertion&gt;
 
 &lt;/Ontology&gt;

</pre>
</div>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">14  Appendix: Change Log (Informative) </span></h2>
<a id="Changes_Since_Recommendation" name="Changes_Since_Recommendation"></a><h3> <span class="mw-headline">14.1  Changes Since Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-primer-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-primer-20091027/">Recommendation of 27 October, 2009</a>.
</p>
<ul><li> With the publication of the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">Recommendation of 5 April 2012</a>, the elements of OWL 2 which are based on XSD 1.1 are now considered required, and the note detailing the optional dependency on the XSD 1.1 <a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">Candidate Recommendation of 30 April, 2009</a> has been removed from the "Status of this Document" section.
</li><li> Minor typographical errors were corrected as detailed on the <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Errata" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Errata">OWL 2 Errata</a> page.
</li></ul>
<a id="Changes_Since_Proposed_Recommendation" name="Changes_Since_Proposed_Recommendation"></a><h3> <span class="mw-headline">14.2  Changes Since Proposed Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/PR-owl2-primer-20090922/" rel="nofollow" title="http://www.w3.org/TR/2009/PR-owl2-primer-20090922/">Proposed Recommendation of 22 September, 2009</a>.
</p>
<ul><li> Several editorial clarifications and improvements were made.
</li></ul>
<a id="Changes_Since_Last_Call" name="Changes_Since_Last_Call"></a><h3> <span class="mw-headline">14.3  Changes Since Last Call </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/WD-owl2-primer-20090611/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-owl2-primer-20090611/">Last Call Working Draft of 11 June, 2009</a>.
</p>
<ul><li> Errors in some of the examples were fixed.
</li><li> The example ontology was fixed so as to be consistent and syntactically correct.
</li><li> A section on OWL 2 tools was added.
</li><li> Various links to other OWL 2 documents were added.
</li><li> A note was added pointing out that a property being asymmetric is a much stronger notion than its being non-symmetric, and that being symmetric is a much stronger notion than being non-asymmetric.
</li><li> A note on the origin of the profile names was added, and it was pointed out that none of the profiles is a subset of another.
</li><li> Post Last Call changes to the OWL 2 syntax were incorporated.
</li><li> Several editorial clarifications and improvements, minor corrections and fixes, and cosmetic changes were made.
</li></ul>
</div>
<a id="Acknowledgments" name="Acknowledgments"></a><h2> <span class="mw-headline">15  Acknowledgments </span></h2>
<p>The starting point for the development of OWL 2 was the <a class="external text" href="http://www.w3.org/Submission/2006/10/" rel="nofollow" title="http://www.w3.org/Submission/2006/10/">OWL1.1 member submission</a>, itself a result of user and developer feedback, and in particular of information gathered during the <a class="external text" href="http://www.webont.org/owled/" rel="nofollow" title="http://www.webont.org/owled/">OWL Experiences and Directions (OWLED) Workshop series</a>. The working group also considered <a class="external text" href="http://www.w3.org/2001/sw/WebOnt/webont-issues.html" rel="nofollow" title="http://www.w3.org/2001/sw/WebOnt/webont-issues.html">postponed issues</a> from the <a class="external text" href="http://www.w3.org/2004/OWL/" rel="nofollow" title="http://www.w3.org/2004/OWL/">WebOnt Working Group</a>.
</p><p>This document has been produced by the OWL Working Group (see below), and its contents reflect extensive discussions within the Working Group as a whole.
The editors extend special thanks to
Jie Bao (RPI),
Michel Dumontier (Carleton University),
Christine Goldbreich (Universit&eacute; de Versailles St-Quentin and LIRMM),
Henson Graves (Lockheed Martin),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Doug Lenat (Cycorp),
Deborah L. McGuinness (RPI),
Alan Rector (University of Manchester),
Alan Ruttenberg (Science Commons)
Uli Sattler (University of Manchester),
Michael Schneider (FZI), and
Mike Smith (Clark &amp; Parsia)
for their thorough reviews and helpful comments.
</p><p>The regular attendees at meetings of the OWL Working Group at the time of publication of this document were:
Jie Bao (RPI),
Diego Calvanese (Free University of Bozen-Bolzano),
Bernardo Cuenca Grau (Oxford University Computing Laboratory),
Martin Dzbor (Open University),
Achille Fokoue (IBM Corporation),
Christine Golbreich (Universit&eacute; de Versailles St-Quentin and LIRMM),
Sandro Hawke (W3C/MIT),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Ian Horrocks (Oxford University Computing Laboratory),
Elisa Kendall (Sandpiper Software),
Markus Kr&ouml;tzsch (FZI),
Carsten Lutz (Universit&auml;t Bremen),
Deborah L. McGuinness (RPI),
Boris Motik (Oxford University Computing Laboratory),
Jeff Pan (University of Aberdeen),
Bijan Parsia (University of Manchester),
Peter F. Patel-Schneider (Bell Labs Research, Alcatel-Lucent),
Sebastian Rudolph (FZI),
Alan Ruttenberg (Science Commons),
Uli Sattler (University of Manchester),
Michael Schneider (FZI),
Mike Smith (Clark &amp; Parsia),
Evan Wallace (NIST),
Zhe Wu (Oracle Corporation), and
Antoine Zimmermann (DERI Galway).
We would also like to thank past members of the working group:
Jeremy Carroll,
Jim Hendler, and
Vipul Kashyap.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">16  References </span></h2>
<dl><dt> <span id="ref-description-logics">[Description Logics]</span>
</dt><dd> <a class="external text" href="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254" rel="nofollow" title="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254"><cite>The Description Logic Handbook: Theory, Implementation, and Applications, second edition</cite></a>. Franz Baader, Diego Calvanese, Deborah L. McGuinness, Daniele Nardi, and Peter F. Patel-Schneider, eds. Cambridge University Press, 2007.  Also see the <a class="external text" href="http://dl.kr.org/" rel="nofollow" title="http://dl.kr.org/"><cite>Description Logics Home Page</cite></a>.
</dd><dt> <span id="ref-dlp">[DLP]</span>
</dt><dd> <cite><a class="external text" href="http://www2003.org/cdrom/papers/refereed/p117/p117-grosof.html" rel="nofollow" title="http://www2003.org/cdrom/papers/refereed/p117/p117-grosof.html">Description Logic Programs: Combining Logic Programs with Description Logic</a></cite>. Benjamin N. Grosof, Ian Horrocks, Raphael Volz, and Stefan Decker. in Proc. of the 12th Int. World Wide Web Conference (WWW 2003), Budapest, Hungary, 2003. pp.: 48&ndash;57
</dd><dt> <span id="ref-DL-Lite">[DL-Lite]</span>
</dt><dd> <cite><a class="external text" href="http://www.springerlink.com/content/n17338715966v81h/" rel="nofollow" title="http://www.springerlink.com/content/n17338715966v81h/">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</a></cite>. Diego Calvanese, Giuseppe de Giacomo, Domenico Lembo, Maurizio Lenzerini, Riccardo Rosati. J. of Automated Reasoning 39(3):385&ndash;429, 2007
</dd><dt> <span id="ref-ELpp">[EL++]</span>
</dt><dd> <cite><a class="external text" href="http://www.informatik.uni-bremen.de/~clu/papers/archive/ijcai05.pdf" rel="nofollow" title="http://www.informatik.uni-bremen.de/~clu/papers/archive/ijcai05.pdf">Pushing the EL Envelope</a></cite>. Franz Baader, Sebastian Brandt, and Carsten Lutz. In Proc. of the 19th Joint Int. Conf. on Artificial Intelligence (IJCAI 2005), 2005
</dd><dt> <span id="ref-FOST">[FOST]</span>
</dt><dd> <cite><a class="external text" href="http://www.semantic-web-book.org" rel="nofollow" title="http://www.semantic-web-book.org">Foundations of Semantic Web Technologies</a></cite>. Pascal Hitzler, Markus Kr&ouml;tzsch, and Sebastian Rudolph. Chapman &amp; Hall/CRC, 2009, ISBN: 9781420090505.
</dd><dt> <span id="ref-owl-2-conformance">[OWL 2 Conformance]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">OWL 2 Web Ontology Language: <span>Conformance (Second Edition)</span></a></cite> Michael Smith, Ian Horrocks, Markus Kr&ouml;tzsch, Birte Glimm, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-conformance/">http://www.w3.org/TR/owl2-conformance/</a>.</span></dd><dt> <span id="ref-owl-2-manchester-syntax">[OWL 2 Manchester Syntax]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/">OWL 2 Web Ontology Language: <span>Manchester Syntax (Second Edition)</span></a></cite> Matthew Horridge, Peter F. Patel-Schneider. W3C Working Group Note, 11 December 2012, <a href="http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/">http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-manchester-syntax/">http://www.w3.org/TR/owl2-manchester-syntax/</a>.</span></dd><dt> <span id="ref-owl-2-new-features">[OWL 2 New Features and Rationale]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/">OWL 2 Web Ontology Language: <span>New Features and Rationale (Second Edition)</span></a></cite> Christine Golbreich, Evan K. Wallace, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/">http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-new-features/">http://www.w3.org/TR/owl2-new-features/</a>.</span></dd><dt> <span id="ref-owl-2-profiles">[OWL 2 Profiles]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/">OWL 2 Web Ontology Language: <span>Profiles (Second Edition)</span></a></cite> Boris Motik, Bernardo Cuenca Grau, Ian Horrocks, Zhe Wu, Achille Fokoue, Carsten Lutz, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/">http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-profiles/">http://www.w3.org/TR/owl2-profiles/</a>.</span></dd><dt> <span id="ref-owlprofilesintro">[OWL 2 Profiles Introduction]</span>
</dt><dd> <cite>OWL 2 Profiles: An Introduction to Lightweight Ontology Languages</cite>. Markus Kr&ouml;tzsch. Reasoning Web 2012. Lecture Notes in Computer Science, vol. 7487, pp. 112&ndash;183, Springer 2012. To appear. Preprint available at <a class="external free" href="http://korrekt.org/page/OWL_2_Profiles" rel="nofollow" title="http://korrekt.org/page/OWL_2_Profiles">http://korrekt.org/page/OWL_2_Profiles</a>
</dd><dt> <span id="ref-owl-2-quick-reference">[OWL 2 Quick Reference Guide]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">OWL 2 Web Ontology Language: <span>Quick Reference Guide (Second Edition)</span></a></cite> Jie Bao, Elisa F. Kendall, Deborah L. McGuinness, Peter F. Patel-Schneider, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-quick-reference/">http://www.w3.org/TR/owl2-quick-reference/</a>.</span></dd><dt> <span id="ref-owl-2-rdf-semantics">[OWL 2 RDF-Based Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">OWL 2 Web Ontology Language: <span>RDF-Based Semantics (Second Edition)</span></a></cite> Michael Schneider, editor. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-rdf-based-semantics/">http://www.w3.org/TR/owl2-rdf-based-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-rdf-mapping">[OWL 2 RDF Mapping]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">OWL 2 Web Ontology Language: <span>Mapping to RDF Graphs (Second Edition)</span></a></cite> Peter F. Patel-Schneider, Boris Motik, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-mapping-to-rdf/">http://www.w3.org/TR/owl2-mapping-to-rdf/</a>.</span></dd><dt> <span id="ref-owl-2-direct-semantics">[OWL 2 Direct Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">OWL 2 Web Ontology Language: <span>Direct Semantics (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bernardo Cuenca Grau, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-direct-semantics/">http://www.w3.org/TR/owl2-direct-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-specification">[OWL 2 Specification]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">OWL 2 Web Ontology Language: <span>Structural Specification and Functional-Style Syntax (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>.</span></dd><dt> <span id="ref-owl-2-xml-serialization">[OWL 2 XML Serialization]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">OWL 2 Web Ontology Language: <span>XML Serialization (Second Edition)</span></a></cite> Boris Motik, Bijan Parsia, Peter F. Patel-Schneider, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-xml-serialization/">http://www.w3.org/TR/owl2-xml-serialization/</a>.</span></dd><dt> <span id="ref-pdstar">[pD*]</span>
</dt><dd> <cite><a class="external text" href="http://linkinghub.elsevier.com/retrieve/pii/S1570826805000144" rel="nofollow" title="http://linkinghub.elsevier.com/retrieve/pii/S1570826805000144">Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary</a></cite>. Herman J. ter Horst. J. of Web Semantics 3(2&ndash;3):79&ndash;115, 2005
</dd><dt> <span id="ref-rdf-concepts">[RDF Concepts]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a></cite>. Graham Klyne and Jeremy J. Carroll, eds. W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/.  Latest version available as http://www.w3.org/TR/rdf-concepts/.
</dd><dt> <span id="ref-rdf-semantics">[RDF Semantics]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF Semantics</a></cite>. Patrick Hayes, ed., W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-mt-20040210/.  Latest version available as http://www.w3.org/TR/rdf-mt/.
</dd><dt> <span id="ref-rdf-syntax">[RDF Syntax]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">RDF/XML Syntax Specification (Revised)</a></cite>. Dave Beckett, ed. W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/.  Latest version available as http://www.w3.org/TR/rdf-syntax-grammar/.
</dd><dt> <span id="ref-rfc-3987">[RFC 3987]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987: Internationalized Resource Identifiers (IRIs)</a></cite>. M. Duerst and M. Suignard. IETF, January 2005, http://www.ietf.org/rfc/rfc3987.txt
</dd><dt> <span id="ref-sparql">[SPARQL]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/" rel="nofollow" title="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for RDF</a></cite>. Eric Prud'hommeaux and Andy Seaborne, eds. W3C Recommendation, 15 January 2008, http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/.  Latest version available as http://www.w3.org/TR/rdf-sparql-query/.
</dd><dt> <span id="ref-turtle">[Turtle]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/turtle/" rel="nofollow" title="http://www.w3.org/TR/turtle/">Turtle: Terse RDF Triple Language</a></cite>. Eric Prud'hommeaux and Gavin Carothers.  W3C Last Call Working Draft, 10 July 2012, http://www.w3.org/TR/2012/WD-turtle-20120710/.  Latest version available at http://www.w3.org/TR/turtle/.
</dd><dt> <span id="ref-xml-schema-datatypes">[XML Schema Datatypes]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>. David Peterson, Shudi (Sandy) Gao, Ashok Malhotra, C. M. Sperberg-McQueen, and Henry S. Thompson, eds. (Version 1.1) and Paul V. Biron, and Ashok Malhotra, eds. (Version 1.0). W3C Recommendation, 5 April 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/</a>. Latest version available as <a class="external free" href="http://www.w3.org/TR/xmlschema11-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
</dd></dl>
<p><br />
<script type="text/javascript">primerOnLoad();</script>
</p>


</body>
</html>