<!-- http://www.w3.org/TR/xpath-full-text-10-use-cases/ -->
<?xml version="1.0" encoding="utf-8"?>
<!--XSLT Processor: SAXON 9.1.0.5 from Saxonica SAXON 9.1.0.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:xs="http://www.w3.org/2001/XMLSchema" lang="EN" xmlns=
"http://www.w3.org/1999/xhtml" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQuery and XPath Full Text 1.0 Use Cases</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
span.found       { background-color: #FFFFCC; 
                       
                             font-weight: bold; 
                           }
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-WG-NOTE.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery and XPath Full Text 1.0
Use Cases</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working Group
Note 25 January 2011</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/">
http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-full-text-10-use-cases/">http://www.w3.org/TR/xpath-full-text-10-use-cases/</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://www.w3.org/TR/2010/WD-xpath-full-text-10-use-cases-20100128/">
http://www.w3.org/TR/2010/WD-xpath-full-text-10-use-cases-20100128/</a></dd>
<dt>Editors:</dt>
<!--xmlspec, match="author"-->
<dd>Pat Case, Library of Congress</dd>
<!--xmlspec, match="author"-->
<dd>Sihem Amer-Yahia, AT&amp;T Labs - Research</dd>
</dl>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/xpath-full-text-10-use-cases.xml">
XML</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2011&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document specifies usage scenarios for full-text queries as
part of XQuery <a href="#xquery">[XQuery 1.0: An XML Query Language
(Second Edition)]</a> and XPath <a href="#xpath20">[XML Path
Language (XPath) 2.0 (Second Edition)]</a>.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end">Working
Group Note</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html">Process
Document</a>. It has been jointly developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
W3C <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a>,
each of which is part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>. The Working
Groups expect to eventually publish this document as a Working
Group Note.</p>
<p>This Use Cases document illustrates a number of use cases that
guided the development of the XQuery and XPath Full Text 1.0
specification.</p>
<p>This document incorporates changes made against the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> of 18 May 2007. Changes to this document
since the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> are detailed in <a href="#ChangeLog"><b>C
Change Log</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[FTUC]” in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>Publication as a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end">Working
Group Note</a> does not imply endorsement by the W3C Membership. At
the time of publication, work on this document was considered
complete and no further revisions are anticipated. It is a stable
document and may be used as reference material or cited from
another document. However, this document may be updated, replaced,
or made obsolete by other documents at any time.</p>
<p>This document was produced by groups operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XML Query Working Group and also maintains a
<a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also include
instructions for disclosing a patent. An individual who has actual
knowledge of a patent which the individual believes contains
<a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#FT_UC_Prelim">Full Text Use Cases:
Preliminaries</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#FT_UC_Display">Proper Display
of this Unicode Document</a><br />
&#160;&#160;&#160;&#160;1.2 <a href=
"#FT_UC_Intro">Introduction</a><br />
&#160;&#160;&#160;&#160;1.3 <a href=
"#FT_UC_Presentation">Presentation of Use Cases</a><br />
&#160;&#160;&#160;&#160;1.4 <a href="#FT_UC_Schema">Schema for
Sample Data</a><br />
&#160;&#160;&#160;&#160;1.5 <a href="#FT_UC_SampleData">Sample
Data</a><br />
2 <a href="#Element">Use Case "ELEMENT": Queries on XML Elements
with Simple Content</a><br />
&#160;&#160;&#160;&#160;2.1 <a href=
"#element-description">Description</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#element-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#element-queries-results-q1">Q1 Word Query in an Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#element-queries-results-q2">Q2 Phrase Query in an
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#element-queries-results-q3">Q3 Phrase Query on Chinese Characters
in an Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#element-results-q4">Q4 Query in Different Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
"#element-results-q5">Q5 Query in an Element Returning Different
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.6 <a href=
"#element-queries-results-q6">Q6 Starts-with Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.7 <a href=
"#element-queries-results-q7">Q7 Entire Element Content
Query</a><br />
3 <a href="#Across">Use Case "ACROSS": Queries Across XML Element
Boundaries</a><br />
&#160;&#160;&#160;&#160;3.1 <a href=
"#across-description">Description</a><br />
&#160;&#160;&#160;&#160;3.2 <a href=
"#across-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#across-queries-results-q1">Q1 Query Across Descendant Elements
(No Element Content)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#across-queries-results-q2">Q2 Query Across Descendant Elements
(Highlighting Tags)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#across-queries-results-q3">Q3 Query Across Descendant Elements
(Substantive Tags)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
"#across-queries-results-q4">Q4 Query Across Siblings</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.5 <a href=
"#across-queries-results-q5">Q5 Query in Different
Sub-Trees</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.6 <a href=
"#across-queries-results-q6">Q6 Query on Entire Document</a><br />
4 <a href="#Other">Use Case "OTHER": Queries on Attribute
Values</a><br />
&#160;&#160;&#160;&#160;4.1 <a href=
"#other-description">Description</a><br />
&#160;&#160;&#160;&#160;4.2 <a href=
"#other-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1 <a href=
"#other-queries-results-q1">Q1 Query on Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.2 <a href=
"#other-queries-results-q2">Q2 Query on Element and
Attribute</a><br />
5 <a href="#Wildcard">Use Case "WILDCARD": Character Wildcard
Queries</a><br />
&#160;&#160;&#160;&#160;5.1 <a href=
"#wildcard-description">Description</a><br />
&#160;&#160;&#160;&#160;5.2 <a href=
"#wildcard-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.1 <a href=
"#wildcard-queries-results-q1">Q1 One Character Suffix Wildcard
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.2 <a href=
"#wildcard-queries-results-q2">Q2 Zero or One Character Prefix
Wildcard Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.3 <a href=
"#wildcard-queries-results-q3">Q3 Zero or More Character Infix
Wildcard Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.4 <a href=
"#wildcard-queries-results-q4">Q4 One or More Character Suffix
Wildcard Query on Part of a Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.2.5 <a href=
"#wildcard-queries-results-q5">Q5 Specified Range of Characters
Suffix Wildcard Query</a><br />
6 <a href="#Stemming">Use Case "STEMMING": Word Stemming
Queries</a><br />
&#160;&#160;&#160;&#160;6.1 <a href=
"#stemming-description">Description</a><br />
&#160;&#160;&#160;&#160;6.2 <a href=
"#stemming-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.2.1 <a href=
"#stemming-queries-results-q1">Q1 Query Stemming on Word
Root</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.2.2 <a href=
"#stemming-queries-results-q2">Q2 Query Stemming on Multiple Word
Roots</a><br />
7 <a href="#Thesaurus">Use Case "THESAURUS": Queries Which Use
Thesauri, Dictionaries, and Taxonomies</a><br />
&#160;&#160;&#160;&#160;7.1 <a href=
"#thesaurus-description">Description</a><br />
&#160;&#160;&#160;&#160;7.2 <a href=
"#thesaurus-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.1 <a href=
"#thesaurus-queries-results-q1">Q1 Query on Synonyms Identified by
a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.2 <a href=
"#thesaurus-queries-results-q2">Q2 Query on Narrower Terms
Identified by a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.3 <a href=
"#thesaurus-queries-results-q3">Q3 Query on Broader Terms
Identified by a Thesaurus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.4 <a href=
"#thesaurus-queries-results-q4">Q4 Query on Word Which Sounds Like
Other Words</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.5 <a href=
"#thesaurus-queries-results-q5">Q5 Query on Word Spelled Similarly
to Other Words</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.6 <a href=
"#thesaurus-queries-results-q6">Q6 Query on Subordinate Terms
Identified by a Taxonomy</a><br />
8 <a href="#Stop-word">Use Case "STOP-WORD": Queries on Stop
Words</a><br />
&#160;&#160;&#160;&#160;8.1 <a href=
"#stop-word-description">Description</a><br />
&#160;&#160;&#160;&#160;8.2 <a href=
"#Stop-word-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.1 <a href=
"#stop-word-queries-results-q1">Q1 Query on Stop Word Treated as a
Stop Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2 <a href=
"#stop-word-queries-results-q2">Q2 Query on Stop Word Not Treated
as a Stop Word</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3 <a href=
"#stop-word-queries-results-q3">Q3 Query Excluding a Stop Word on a
Stop Word List</a><br />
9 <a href="#Character">Use Case "CHARACTER": Queries Specifying
Normalized Forms of Characters and Tokenized Words</a><br />
&#160;&#160;&#160;&#160;9.1 <a href=
"#character-description">Description</a><br />
&#160;&#160;&#160;&#160;9.2 <a href=
"#character-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.1 <a href=
"#character-queries-results-q1">Q1 Diacritics Sensitive
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.2 <a href=
"#character-queries-results-q2">Q2 Diacritics Insensitive
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.3 <a href=
"#character-queries-results-q3">Q3 Query on Word with Upper Case
Characters</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.4 <a href=
"#character-queries-results-q4">Q4 Query on Word with Upper Case
and Lower Case Characters</a><br />
10 <a href="#Logical">Use Case "LOGICAL": Queries with Logical
Expressions (Or, And, and Not Queries)</a><br />
&#160;&#160;&#160;&#160;10.1 <a href=
"#logical-description">Description</a><br />
&#160;&#160;&#160;&#160;10.2 <a href=
"#logical-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.1 <a href=
"#logical-queries-results-q1">Q1 Or Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.2 <a href=
"#logical-queries-results-q2">Q2 And Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.3 <a href=
"#logical-results-q3">Q3 And Query Ordered</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.4 <a href=
"#logical-queries-results-q4">Q4 Unary Not Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.5 <a href=
"#logical-queries-results-q5">Q5 And Not Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.6 <a href=
"#logical-queries-results-q6">Q6 And Not Query Where Second Operand
Is a Subset of the First Operand</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.7 <a href=
"#logical-queries-results-q7">Q7 Mild Not Query Where Second
Operand Is a Subset of the First Operand</a><br />
11 <a href="#Cardinality">Use Case "CARDINALITY": Queries in Same,
Any, Every Instance of an Element, and Occurrence Count
Query</a><br />
&#160;&#160;&#160;&#160;11.1 <a href=
"#cardinality-description">Description</a><br />
&#160;&#160;&#160;&#160;11.2 <a href=
"#cardinality-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.1 <a href=
"#cardinality-queries-results-q1">Q1 Query in Same Instance of an
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.2 <a href=
"#cardinality-queries-results-q2">Q2 Query in Any Instance of an
Element (Existential Quantification)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.3 <a href=
"#cardinality-queries-results-q3">Q3 Query in Every Instance of an
Element (Universal Quantification)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.4 <a href=
"#cardinality-queries-results-q4">Q4 Occurrence Count
Query</a><br />
12 <a href="#Proximity">Use Case "PROXIMITY": Queries on Proximity
Relationships Including Distance, Window, Sentence, and
Paragraph</a><br />
&#160;&#160;&#160;&#160;12.1 <a href=
"#proximity-description">Description</a><br />
&#160;&#160;&#160;&#160;12.2 <a href=
"#proximity-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.1 <a href=
"#proximity-queries-results-q1">Q1 Unordered Distance
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.2 <a href=
"#proximity-queries-results-q2">Q2 Ordered Distance Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.3 <a href=
"#proximity-queries-results-q3">Q3 Ordered Window Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.4 <a href=
"#proximity-queries-results-q4">Q4 Unordered Within a Sentence
Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.2.5 <a href=
"#proximity-queries-results-q5">Q5 Unordered Within a Paragraph
Query</a><br />
13 <a href="#Axes">Use Case "AXES": Queries Using Relative XPath
Axes</a><br />
&#160;&#160;&#160;&#160;13.1 <a href=
"#axes-description">Description</a><br />
&#160;&#160;&#160;&#160;13.2 <a href=
"#axes-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.1 <a href=
"#axes-queries-results-q1">Q1 Query on Element and Its
Children</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.2 <a href=
"#axes-queries-results-q2">Q2 Query on Element Returning Its First
Two Children</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.3 <a href=
"#axes-queries-results-q3">Q3 Query on Element and Its
Ancestors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.2.4 <a href=
"#axes-queries-results-q4">Q4 Query on Element and Its Right
Siblings</a><br />
14 <a href="#Ignore">Use Case "IGNORE": Queries Ignoring Descendant
Element Content</a><br />
&#160;&#160;&#160;&#160;14.1 <a href=
"#ignore-description">Description</a><br />
&#160;&#160;&#160;&#160;14.2 <a href=
"#ignore-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.1 <a href=
"#ignore-queries-results-q1">Q1 Distance Query Ignoring Content of
All Descendant Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.2 <a href=
"#ignore-queries-results-q2">Q2 Phrase Query Ignoring Content of
Descendant Element Specified by XPath Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.3 <a href=
"#ignore-queries-results-q3">Q3 Phrase Query Ignoring Content of
Descendant Element Specified by Full-Text Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.4 <a href=
"#ignore-queries-results-q4">Q4 Distance Query Ignoring Content of
Descendant Elements Level by Level</a><br />
15 <a href="#Full-Text-Composability">Use Case
"FULL-TEXT-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Itself</a><br />
&#160;&#160;&#160;&#160;15.1 <a href=
"#full-text-composability-description">Description</a><br />
&#160;&#160;&#160;&#160;15.2 <a href=
"#full-text-composability-queries-results">Queries and
Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.1 <a href=
"#full-text-composability-queries-results-q1">Q1 Query on Words and
Phrases in Two Languages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.2 <a href=
"#full-text-composability-queries-results-q2">Q2 Phrase and
Distance Query in an Instance of an Element With Stemming</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.3 <a href=
"#full-text-composability-queries-results-q3">Q3 Nested Distance
Query with Wildcards, Stemming, and Thesaurus Support</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.4 <a href=
"#full-text-composability-queries-results-q4">Q4 Window Query with
Wildcards and Stemming Ignoring Content of a Descendant
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.2.5 <a href=
"#full-text-composability-queries-results-q5">Q5 Query on Different
Elements in Different Sub-Trees with Conditional Return</a><br />
16 <a href="#XQuery-XPath-Composability">Use Case
"XQUERY-XPATH-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Other XQuery and XPath Functionalities</a><br />
&#160;&#160;&#160;&#160;16.1 <a href=
"#xquery-xpath-composability-description">Description</a><br />
&#160;&#160;&#160;&#160;16.2 <a href=
"#xquery-xpath-composability-queries-results">Queries and
Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.1 <a href=
"#xquery-xpath-composability-queries-results-q1">Q1 Full-Text Query
Constructing New Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.2 <a href=
"#xquery-xpath-composability-queries-results-q2">Q2 Full-Text Query
Returning Count of Descendant Element Occurrences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.3 <a href=
"#xquery-xpath-composability-queries-results-q3">Q3 Full-Text Query
with Conditional Return</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.4 <a href=
"#xquery-xpath-composability-queries-results-q4">Q4 Full-Text Query
with Numeric Value Comparison</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.5 <a href=
"#xquery-xpath-composability-queries-results-q5">Q5 Full-Text Query
with Character String Query</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.6 <a href=
"#xquery-xpath-composability-queries-results-q6">Q6 Full-Text Query
with Conditional Return of Boolean Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.7 <a href=
"#xquery-xpath-composability-queries-results-q7">Q7 Full-Text Query
with Date Comparison and Element Occurrence Count</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.8 <a href=
"#xquery-xpath-composability-queries-results-q8">Q8 Query with
XPath Expression Within Full-Text Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.2.9 <a href=
"#xquery-xpath-composability-queries-results-q9">Q9 Query Using an
XQuery Expression to Determine the Number of Words Allowed in a
Window</a><br />
17 <a href="#Score">Use Case "SCORE": All Queries May Be Written
with Score, Queries in this Section Must Be Written with
Score</a><br />
&#160;&#160;&#160;&#160;17.1 <a href=
"#score-description">Description</a><br />
&#160;&#160;&#160;&#160;17.2 <a href=
"#score-queries-results">Queries and Results</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.1 <a href=
"#score-queries-results-q1">Q1 Query Returning Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.2 <a href=
"#score-queries-results-q2">Q2 Query Returning Results with Top
Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.3 <a href=
"#score-queries-results-q3">Q3 Query Filtering on Scores</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.4 <a href=
"#score-queries-results-q4">Q4 Query Combining Score and XML
Structure with a Conditional Return</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.5 <a href=
"#score-queries-results-q5">Q5 Query Returning All Books Ordered by
Score</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;17.2.6 <a href=
"#score-queries-results-q6">Q6 Query with Weight
Declaration</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href=
"#Acknowledgements">Acknowledgements</a><br />
B <a href="#References">References</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;B.1 <a href="#primary">References
(Primary)</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#background">References
(Background)</a><br />
C <a href="#ChangeLog">Change Log</a> (Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="FT_UC_Prelim" id="FT_UC_Prelim"></a>1 Full Text Use
Cases: Preliminaries</h2>
<div class="div2">
<h3><a name="FT_UC_Display" id="FT_UC_Display"></a>1.1 Proper
Display of this Unicode Document</h3>
<p>(1) Use a current operating system and browser.</p>
<p>(2) If necessary, set the character encoding in the browser
manually to Unicode or UTF-8. Often this setting may be changed
from the View menu.</p>
<p>(3) If after setting the character encoding to Unicode, the
Chinese characters in the subject elements of the sample data still
do not display, it is likely that the browser cannot locate a font
that contains Chinese characters in Unicode encoding. It might be
necessary to add a Unicode font, preferably Arial Unicode MS.</p>
</div>
<div class="div2">
<h3><a name="FT_UC_Intro" id="FT_UC_Intro"></a>1.2
Introduction</h3>
<p>The use cases listed below were created by the <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a> and the
<a href="http://www.w3.org/Style/XSL/">XSL Working Group</a> to
illustrate important applications of full-text querying within an
XML query language. Each use case exercises a specific
functionality relevant to full-text querying. An XML Schema and
sample input data are provided. Each use case specifies a query
applied to the input data, a solution in XQuery, a solution in
XPath (when possible), and the expected results.</p>
<p>The document supplements the XML Query Use Cases which can be
found in the W3C XML Query Use Cases <a href=
"#xquery-use-cases">[XML Query Use Cases]</a>. Use cases for
character string querying are included in the XML Query Use Cases,
not in this document.</p>
<p>These use cases:</p>
<p>(1) Present some possible functions and features for tokenized
text support in XQuery and XPath.</p>
<p>(2) Illustrate simple and complex queries. The more complex
queries would normally only be constructed by programmers,
librarians, and other expert users. Sometimes they may be provided
for novice users via saved queries and graphical user interfaces.
Each query illustrates a single functionality. Queries may overlap
in their functionalities (e.g., phrases and ordered distance
queries allowing no intervening words). Overlapping and similar
functionalities are noted in the comments on query behavior.</p>
<p>(3) Draw from sample data which are almost entirely in English.
Use cases in other languages are solicited, especially where they
illustrate language-specific implementations of functions and
features. Among the most sought after are use cases for queries
using prefix and infix wildcards, proximity queries, and operators
and queries requiring functionality which may not have Western
language equivalents.</p>
<p>(4) Include queries which in most instances can be written with
pure Boolean full-text predicates or with scoring (e.g., scoring on
the number of occurrences of a word or phrase, scoring on how close
words are to one another within a distance query, scoring on how
similar a word is to the one being stemmed) <a href=
"#BYR99">[BYR99]</a> <a href="#HTK00">[HTK00]</a>. A few, those in
Section 17 (SCORE), cannot be written with Boolean full-text
predicates. Scoring methodologies will not be defined in this
recommendation. Scoring will be implementation-defined. Results are
provided in document order, except those in Section 17 (SCORE).
Results could be returned ordered differently, such as by relevance
(based on implementation-defined scoring) or explicitly by
element.</p>
<p>(5) Query element content. See Section 4 (OTHER) for explicit
queries on attribute values.</p>
<p>(6) Include queries which are case insensitive. When returning a
paragraph, the text is returned as it occurs in the data model.
This approach was chosen to keep the sample data short and the
expected results meaningful. It would have been equally valid to
return only the words queried. A case-sensitive query is found in
Section 9 (CHARACTER).</p>
<p>(7) Include queries which when they target XML elements are
understood, unless otherwise stated, to query text within any text
node descendant of the element.</p>
<p>(8) Include queries which return only elements and attributes
which meet all the conditions specified in the query. In
particular, pure Boolean full-text predicate queries return results
where the Boolean conditions in the query are satisfied, i.e., are
used to select what is being returned to users.</p>
<p>Query results may be returned in different ways. From a query
for books containing the word "usability", users might be
interested in returning, for each book containing the word
"usability", its number and its entire content. In another
situation for the same query, users might be interested in
returning, for each book containing the word "usability", its
number and only the elements and attributes in the content which
contain the word "usability". As in this second situation, the
queries in these use cases return only elements and attributes
which meet all the conditions specified in the query.</p>
<p>The Return clause may also include additional or different
elements and attributes if specified, and may construct new
elements.</p>
<p>(9) Include queries which provide some of the basic
functionality of fuzzy match querying (e.g., wildcards, stemming,
thesaurus support, proximity).</p>
<p>(10) Provide highlighting of found words and phrases in the
expected results of queries as an aid to users. The presence of
highlighting says nothing about whether highlighting will be a
feature of XQuery or XPath full-text querying.</p>
<p>(11) Display query solutions in XQuery and when possible in
XPath. Queries that may not be written in XPath include those that
contain element constructors and that cannot be written without
let, where, and order by clauses.</p>
<p>Examples of full-text querying functionalities for XML query
languages can be found in <a href="#FGR01">[FGR01]</a>, <a href=
"#HTK00">[HTK00]</a>, <a href="#MJK98">[MJK98]</a>, <a href=
"#SCH01">[SCH01]</a> and <a href="#TWE00">[TWE00]</a>.</p>
<p>To make the output more readable, the output of queries has been
formatted using whitespace which may not be returned by a query
processor. This whitespace should not be considered normative for
the correctness of results.</p>
</div>
<div class="div2">
<h3><a name="FT_UC_Presentation" id="FT_UC_Presentation"></a>1.3
Presentation of Use Cases</h3>
<p>The queries in these use cases are presented in the following
format:</p>
<p>Query number &#160;&#160;Query title</p>
<p>User statement of query</p>
<p>Statement of functionality illustrated by query</p>
<ul>
<li>
<p>Operands: Parts of words, words, phrases</p>
</li>
<li>
<p>Functionality: Operators, functions, collations, other
functionality</p>
</li>
<li>
<p>Data context: One XPath expression locating the data being
queried.</p>
</li>
<li>
<p>Query context: One or more XPath expressions locating the
elements and attributes to be queried. The context of elements and
attributes used in the Query context is relative to the Data
context defined above.</p>
</li>
<li>
<p>Return: One or more XPath expressions which are returned only if
the conditions specified in the query are met. Returned elements or
attributes may differ from those specified in the Query context.
Newly constructed elements might be returned. As in the Query
context, the context of elements and attributes in Return
statements is relative to the Data context defined above.</p>
</li>
<li>
<p>Comments: Comments on query behavior in general, and against the
sample data in particular, plus the rationale for including this
query in the use cases.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
Solutions illustrating XQuery Full Text syntax  
appear here. All queries may be written in XQuery.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however all the queries in the document may be written as scored 
queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
Solutions illustrating XPath Full Text syntax appear 
(when the query may be written in XPath) here.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however most of the queries in the document may be written as 
scored queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
Results are provided here.
                                
Found words and phrases are <span class=
"found">highlighted</span>. 
                                
For brevity, only the elements and attributes which meet 
the conditions specified in the query are displayed. Others are
replaced with ...s.

Results are provided in document order, except those 
in Section 17 (SCORE)
</pre></div>
</div>
<div class="div2">
<h3><a name="FT_UC_Schema" id="FT_UC_Schema"></a>1.4 Schema for
Sample Data</h3>
<p>The example queries in these use cases are based on a collection
with the following XML Schema:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
version="1.0"&gt;
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
schemaLocation = "http://www.w3.org/2001/xml.xsd"/&gt;
   &lt;xs:element name="books"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;A possible XML Schema for Sample Data 
         in XQuery and XPath Full Text Use Cases
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="book"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                     &lt;xs:element name="metadata" 
                     type="metadataType"/&gt;
                     &lt;xs:element name="content" 
                     type="contentType"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="number" type="xs:integer"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;
   &lt;xs:complexType name="anyXMLTextType" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;free text, contains any well-formed 
         XML&lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any processContents="skip" minOccurs="0" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="metadataType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="shortTitle" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="publicationInfo" 
         type="publicationInfoType"/&gt;
         &lt;xs:element name="price" minOccurs="0"&gt;
            &lt;xs:simpleType&gt;
               &lt;xs:restriction base="xs:float"&gt;
                  &lt;xs:minInclusive value="0"/&gt;
                  &lt;xs:maxInclusive value="10000"/&gt;
               &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="subjects" 
         maxOccurs="unbounded"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="subject" type="xs:string" 
               maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
               &lt;xs:attribute ref="xml:lang"/&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="publicationInfoType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="place" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="publisher" type="xs:string" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="dateIssued" type="xs:string"/&gt;
         &lt;xs:element name="dateRevised" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="contentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="part" type="partType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="introductionType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="p" maxOccurs="unbounded"&gt;
            &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" 
               maxOccurs="unbounded"&gt;
                  &lt;xs:element name="b"/&gt;
                  &lt;xs:element name="emph"/&gt;
                  &lt;xs:element name="i"/&gt;
               &lt;/xs:choice&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="partType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
             &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="title" type="titleType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="chapter" type="chapterType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xs:element name="component" 
         type="componentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="number" type="xs:string"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="chapterType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title" type="xs:string"/&gt;
         &lt;xs:element name="p" type="anyXMLTextType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="footnoteType" mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="citation" type="xs:string"
         minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="url" type="xs:anyURI"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="componentTitle" 
         type="componentTitleType"/&gt;
         &lt;xs:element name="subComponent" 
         type="subComponentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="titleType" mixed="true"&gt;
      &lt;xs:all minOccurs="0"&gt;
         &lt;xs:element name="date" type="xs:string"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:all&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentTitleType" 
   mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="componentDate" 
         type="xs:string" 
        minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"
                      use="optional"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element type="componentTitleType"/&gt;
        &lt;xs:element name="subsubComponent" 
        type="subSubComponentType" 
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subSubComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
           &lt;xs:complexType&gt;
              &lt;xs:simpleContent&gt;
                 &lt;xs:extension base="xs:string"&gt;
                    &lt;xs:attribute name="type" type="xs:string"/&gt;
                 &lt;/xs:extension&gt;
              &lt;/xs:simpleContent&gt;
           &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element name="componentTitle" 
        type="componentTitleType"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="FT_UC_SampleData" id="FT_UC_SampleData"></a>1.5 Sample
Data</h3>
<p>The data consists of a collection of three books. Two are
primarily instructive text. The third is a guide to a manuscript
collection. All contain metadata and full text.</p>
<p>The sample data binds to this URL:
"http://bstore1.example.com/full-text.xml".</p>
<div class="exampleInner">
<pre>
&lt;books&gt;
&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Montana Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;dateIssued&gt;2001&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;25.99&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;Web site usability&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;        
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;        
         &lt;subject&gt;Évaluation heuristique&lt;/subject&gt;
         &lt;subject&gt;Parcours cognitif&lt;/subject&gt;
         &lt;subject&gt;Ergonomie de site web&lt;/subject&gt;     
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;    
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;        
         &lt;subject&gt;启发式评价&lt;/subject&gt;
         &lt;subject&gt;认知推演&lt;/subject&gt;
         &lt;subject&gt;网站可用性&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to web sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            &lt;p&gt;Two expert review methods are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web 
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct Usability Tests 
      on Web Site Thereby Improving the Usability of Your 
      Web Site&lt;/title&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;         
         &lt;dateIssued&gt;2000&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2001&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;174.00&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;
         &lt;subject&gt;Guides et outils de recherche&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;
         &lt;subject&gt;指南和检索工具&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Morty Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;  
         &lt;place&gt;Washington, D.C.&lt;/place&gt;    
         &lt;publisher&gt;Ersatz Manuscript Library&lt;/publisher&gt;
         &lt;dateIssued&gt;1998&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;21.49&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Computers&lt;/subject&gt;
         &lt;subject&gt;Software evaluation&lt;/subject&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Manuscript collections&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Ordinateurs&lt;/subject&gt;
         &lt;subject&gt;Évaluation de logiciels&lt;/subject&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Collections de manuscrits&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;计算机&lt;/subject&gt;
         &lt;subject&gt;软件评价&lt;/subject&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;手稿专藏&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Software, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Human Computer Interaction 
              research, &lt;componentDate normalize="1945/1952"&gt;
              1945-1952&lt;/componentDate&gt;
              &lt;/componentTitle&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;Flow diagram, 
                 &lt;componentDate normalize="1950"&gt;1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;General, 
                 &lt;componentDate normalize="1947/1951"&gt;1947-1951
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;&lt;container type="box"&gt;2&lt;/container&gt;
                 &lt;componentTitle&gt;Eye Movement research,
                 &lt;componentDate normalize="1949/1950"&gt;1949-1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt; 
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;User profiling, 
                 &lt;componentDate normalize="1950/1959"&gt;1950s
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;Web User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, articles, book drafts, notes, 
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User Testing?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User Tests."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done Testing?"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User Testing"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: AIDS, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
&lt;/books&gt;
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="Element" id="Element"></a>2 Use Case "ELEMENT":
Queries on XML Elements with Simple Content</h2>
<div class="div2">
<h3><a name="element-description" id="element-description"></a>2.1
Description</h3>
<p>These use cases query words and phrases in XML elements with
simple content.</p>
<p>These use cases begin with the simplest queries possible. They
query a word or phrase in an element with simple content and no
descendants. One of these queries is on Chinese characters. Some
queries return additional or different elements than were queried.
A query queries and returns the full document. Others find a phrase
only when it starts an element and find a exact phrase when it is
the entire content of an element, allowing full-text variations,
such as case, diacritics, and wildcards.</p>
</div>
<div class="div2">
<h3><a name="element-queries-results" id=
"element-queries-results"></a>2.2 Queries and Results</h3>
<div class="div3">
<h4><a name="element-queries-results-q1" id=
"element-queries-results-q1"></a>2.2.1 Q1 Word Query in an
Element</h4>
<p>Find all book titles containing the word "usability".</p>
<p>This query finds a word in an element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This is the simplest query possible, a query on a word
in an element. This query does not employ wildcards, stemming, or
thesaurus support. While this query finds useful results in the
sample data, many queries such as one on the word "test" would not.
A query on the word "test" would return no results, missing the
word variants which exist in the sample data: "pretest", "tested",
"testers", "testimony", "testing", and "tests".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/title[. contains text "usability"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text "usability"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
and <span class="found">Usability</span> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
Web Site&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q2" id=
"element-queries-results-q2"></a>2.2.2 Q2 Phrase Query in an
Element</h4>
<p>Find all book subjects containing the phrase "usability
testing".</p>
<p>This query finds a phrase in an element.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This is a simple query on a phrase in an element. Like
an ordered distance query allowing no intervening words, the words
in this phrase query must be adjacent to each other and must appear
in the order specified. While this query finds useful results in
the sample data, many queries such as one on "software developer"
would not. A query on the phrase "software developer" would return
no results, missing "developer of software" which exists in the
sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. contains text 
   "usability testing"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. contains text 
"usability testing"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
                                                
&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;

&lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q3" id=
"element-queries-results-q3"></a>2.2.3 Q3 Phrase Query on Chinese
Characters in an Element</h4>
<p>Find all book subjects containing the phrase (n-gram) "网站".</p>
<p>This query finds a phrase (n-gram) in an element.</p>
<ul>
<li>
<p>Operands: "网站"</p>
</li>
<li>
<p>Functionality: phrase query, language qualifier</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This query finds a phrase (n-gram) consisting of two
Chinese characters. It assumes a specific language dependent
tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. contains text 
   "网站" using language "zh"]
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. contains text 
"网站" using language "zh"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;subject&gt;<span class="found">网站</span>建置&lt;/subject&gt;  
                                            
&lt;subject&gt;<span class="found">网站</span>可用性&lt;/subject&gt;

&lt;subject&gt;<span class="found">网站</span>建置&lt;/subject&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-results-q4" id="element-results-q4"></a>2.2.4
Q4 Query in Different Elements</h4>
<p>Find all books with "usability tests" in book or chapter
titles.</p>
<p>This query finds a phrase in different elements.</p>
<ul>
<li>
<p>Operands: "usability tests"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title,
./content/part/chapter/title</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query is an example of a query in two different
elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/(metadata|content/part/chapter)/title
where $title contains text "usability tests"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[(metadata|content/part/chapter)
/title contains text "usability tests"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct <span class=
"found">Usability Tests</span> 
      on Web Site Thereby Improving the Usability of 
      Your Web Site&lt;/title&gt; 
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span>
            <span class="found">Tests</span>&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      .... 
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-results-q5" id="element-results-q5"></a>2.2.5
Q5 Query in an Element Returning Different Elements</h4>
<p>Find all books with the phrase "usability testing" in some
subject.</p>
<p>This query finds a phrase in an element and returns different
elements from the same document.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: ./metadata/title, ./metadata/author</p>
</li>
<li>
<p>Comments: This query queries the <code>subject</code> element,
but does not return it. It returns two different elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book/metadata/subjects/subject contains text "usability testing"
return $book/metadata/(title|author)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/subjects/subject 
contains text "usability testing"]/metadata/(title|author)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt; 
&lt;author&gt;Millicent Marigold&lt;/author&gt;     
&lt;author&gt;Montana Marigold&lt;/author&gt; 
   
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
   
&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;author&gt;Millicent Marigold&lt;/author&gt;
&lt;author&gt;Morty Marigold&lt;/author&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q6" id=
"element-queries-results-q6"></a>2.2.6 Q6 Starts-with Query</h4>
<p>Find all book titles which start with "improving" followed
within 2 words by "usability".</p>
<p>This query finds an element which starts with specific
words.</p>
<ul>
<li>
<p>Operands: "improving" "usability"</p>
</li>
<li>
<p>Functionality: word queries, ordered distance (0 to 2
intervening words), starts-with functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: The starts-with functionality restricts the query to
the first words or phrase in an element. It is especially useful in
querying journal titles (e.g., <em>Journal of Psychology</em>) in
large library collections. This query does not find Book 2 which
contains the phrase "improving the usability" in the
<code>title</code> element, because the <code>title</code> element
does not start with "improving".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title 
where $title contains text "improving" ftand "usability" 
   ordered distance at most 2 words at start
return $title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text "improving" 
ftand "usability" ordered distance at most 2 words 
at start]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;<span class=
"found">Improving 
the Usability</span> of a Web Site Through Expert Reviews and 
Usability Testing&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="element-queries-results-q7" id=
"element-queries-results-q7"></a>2.2.7 Q7 Entire Element Content
Query</h4>
<p>Find all books with the entire title "improve the usability of a
web site through expert reviews and usability testing", allowing
any form of the word "improve".</p>
<p>This query finds the phrase when it is the entire content of an
element.</p>
<ul>
<li>
<p>Operands: "improve the usability of a web site through expert
reviews and usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), entire element content functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This query insists that the element contains the
entire phrase being queried, no more and no less. It allows
full-text variations, such as case, diacritics, and wildcards.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $exactTitle := $book/metadata/title
where $exactTitle contains text "improv.* the usability of a 
   web site through expert reviews and usability testing" 
   using wildcards entire content
return $exactTitle
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text 
"improv.* the usability of a web site through expert 
reviews and usability testing" using wildcards entire 
content]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;<span class=
"found">Improving 
the Usability of a Web Site Through Expert Reviews and 
Usability Testing</span>&lt;/title&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Across" id="Across"></a>3 Use Case "ACROSS": Queries
Across XML Element Boundaries</h2>
<div class="div2">
<h3><a name="across-description" id="across-description"></a>3.1
Description</h3>
<p>These use cases by default query across XML element
boundaries.</p>
<p>Boundaries include XML tags: Start-Tags, End-Tags, and
Empty-Element Tags. Descendant XML tags and attribute values are
removed from the string to be queried by tokenization before the
query. At the XQuery Data Model level tags are a syntactic
element.</p>
<p>Find queries in an element which do not query some or all of its
descendant elements in Section 14 (IGNORE).</p>
<p>Find queries on attribute values in Section 4 (OTHER).</p>
</div>
<div class="div2">
<h3><a name="across-queries-results" id=
"across-queries-results"></a>3.2 Queries and Results</h3>
<div class="div3">
<h4><a name="across-queries-results-q1" id=
"across-queries-results-q1"></a>3.2.1 Q1 Query Across Descendant
Elements (No Element Content)</h4>
<p>Find all book chapters containing the phrase "one of the best
known lists of heuristics is Ten Usability Heuristics".</p>
<p>This query crosses element boundaries.</p>
<ul>
<li>
<p>Operands: "one of the best known lists of heuristics is Ten
Usability Heuristics"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. The
<code>citation</code> element tags, including element names,
attribute names, and attribute values, have been removed by
tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter
where $chap contains text "one of the best known lists of 
   heuristics is Ten Usability Heuristics"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//chapter contains text "one of 
the best known lists of heuristics is Ten Usability 
Heuristics"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         ...
         &lt;chapter&gt; 
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt; 
            &lt;p&gt;Expert reviewers critique an interface to
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;<span class=
"found">One of the</span>
            <span class=
"found">best known lists of heuristics is</span> &lt;citation
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt; <span class=
"found">Ten Usability</span> 
            <span class=
"found">Heuristics</span> by Jacob Nielson&lt;/citation&gt;. Another
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q2" id=
"across-queries-results-q2"></a>3.2.2 Q2 Query Across Descendant
Elements (Highlighting Tags)</h4>
<p>Find all part introductions containing the word
"prototypes".</p>
<p>This query crosses element boundaries.</p>
<ul>
<li>
<p>Operands: "prototypes"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. The
<code>bold</code> element tags have been removed by
tokenization.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book/content/part/introduction
where $intro contains text "prototypes"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content/part/introduction contains text 
"prototypes"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;<span class=
"found">p</span>&lt;/b&gt;<span class="found">rototypes</span>
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;  
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q3" id=
"across-queries-results-q3"></a>3.2.3 Q3 Query Across Descendant
Elements (Substantive Tags)</h4>
<p>Find all book text with the word "tests".</p>
<p>This query finds a word in an element and its descendants.</p>
<ul>
<li>
<p>Operands: "tests"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. Element
tags, including element names, attribute names, and attribute
values, have been removed by tokenization, including
<code>part</code>, <code>chapter</code>, <code>title</code>,
<code>p</code>, <code>component</code>, <code>subComponent</code>,
<code>subsubComponent</code>, and <code>componentTitle</code>
tags.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "tests"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "tests"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
          ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt;   
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;
&lt;/book&gt;   

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;     
   &lt;content&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
           &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
           1996&lt;/componentDate&gt;
           &lt;/componentTitle&gt; 
           ...
           &lt;subsubComponent&gt;
           &lt;componentTitle&gt;"How to Evaluate Results from 
           User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
         &lt;/subComponent&gt;
         ...
      &lt;component&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q4" id=
"across-queries-results-q4"></a>3.2.4 Q4 Query Across Siblings</h4>
<p>Find all book text with the phrase "usability testing once the
problems".</p>
<p>This query finds a phrase which begins in one element and ends
in a sibling.</p>
<ul>
<li>
<p>Operands: "usability testing once the problems"</p>
</li>
<li>
<p>Functionality: phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. Element
tags, including element names, attribute names, and attribute
values, have been removed by tokenization, including
<code>title</code> and <code>p</code> tags.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "usability testing once the 
   problems"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "usability 
testing once the problems"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
            &lt;p&gt;<span class=
"found">Once the problems</span> identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q5" id=
"across-queries-results-q5"></a>3.2.5 Q5 Query in Different
Sub-Trees</h4>
<p>Find all books with word "identify" in book introductions or
part introductions.</p>
<p>This query finds a word in an element in different
sub-trees.</p>
<ul>
<li>
<p>Operands: "identify"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (0 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query looks for a word in multiple instances of
the <code>introduction</code> element which appear as children of
the <code>content</code> or <code>part</code> elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book/content/(introduction|part/introduction)   
where $intro [./p contains text "identif.*" using wildcards]
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content/(introduction|part/introduction) 
contains text "identif.*" using wildcards]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;  
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;                                          
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability testing are 
         methods of <span class=
"found">identifying</span> problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;    
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers <span class=
"found">identify</span> problems 
             and recommend changes to web sites based 
             on research in human computer interaction 
             and their experience in the field.&lt;/p&gt; 
             ...
         &lt;/introduction&gt;
         ...
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt; 
</pre></div>
</div>
<div class="div3">
<h4><a name="across-queries-results-q6" id=
"across-queries-results-q6"></a>3.2.6 Q6 Query on Entire
Document</h4>
<p>Find all books if any one contains the word "mouse".</p>
<p>This query finds a word in a document (anywhere in the
document), crossing all element boundaries.</p>
<ul>
<li>
<p>Operands: "mouse"</p>
</li>
<li>
<p>Functionality: word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query queries the root element and all its
descendants. Querying across element boundaries is similar to an
XQuery and XPath character string function converting the sub-tree
under an element into a string by removing all markup. Element
tags, including element names, attribute names, and attribute
values, have been removed by tokenization. This query looks for a
word inside an entire document and returns the entire document if
the word exists. It does not employ wildcards, stemming, or
thesaurus support. It is similar to search engine queries that
search a collection of documents and return a subset of the
searched collection.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")[. 
 contains text "mouse"]/books/book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")[. 
 contains text "mouse"]/books/book
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. <span class=
"found">Mouse</span> 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Other" id="Other"></a>4 Use Case "OTHER": Queries on
Attribute Values</h2>
<div class="div2">
<h3><a name="other-description" id="other-description"></a>4.1
Description</h3>
<p>Unlike all the other use cases in this document which query
element content implicitly, these use cases query XML attribute
values. Attribute values are not queried implicitly; they are
queried explicitly.</p>
</div>
<div class="div2">
<h3><a name="other-queries-results" id=
"other-queries-results"></a>4.2 Queries and Results</h3>
<div class="div3">
<h4><a name="other-queries-results-q1" id=
"other-queries-results-q1"></a>4.2.1 Q1 Query on Attribute</h4>
<p>Find all books with "improve" "web" "usability" in the short
title.</p>
<p>This query finds multiple words in an attribute allowing word
variants and allowing the words in any order with up to a specified
number of intervening words.</p>
<ul>
<li>
<p>Operands: "improve" "web" "usability"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
2 intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle</p>
</li>
<li>
<p>Return: ./metadata/title</p>
</li>
<li>
<p>Comments: This query illustrates full-text querying in an
attribute.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book/metadata/title/@shortTitle contains text "improve" 
   using stemming ftand "web" ftand "usability" distance 
   at most 2 words    
return $book/metadata/title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/title/@shortTitle contains text 
"improve" using stemming ftand "web" ftand "usability" 
distance at most 2 words]/metadata/title
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="<span class=
"found">Improving</span> <span class="found">Web</span> 
Site <span class=
"found">Usability</span>"&gt;Improving the Usability of a 
Web Site Through Expert Reviews and Usability 
Testing&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="other-queries-results-q2" id=
"other-queries-results-q2"></a>4.2.2 Q2 Query on Element and
Attribute</h4>
<p>Find all books with the phrase "manuscript guides" in the short
title and the phrase "user profiling" in a component title.</p>
<p>This query finds a phrase in an attribute and a phrase in an
element.</p>
<ul>
<li>
<p>Operands: "manuscript guides" "user profiling"</p>
</li>
<li>
<p>Functionality: phrase queries, stemming, <code>and</code>
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle,
./componentTitle</p>
</li>
<li>
<p>Return: ./metadata/title/@shortTitle/text()</p>
</li>
<li>
<p>Comments: This query combines querying in an element with
querying in an attribute.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $stitle := $book/metadata/title/@shortTitle    
let $ctitle := $book//componentTitle  
where $stitle contains text "manuscript guides"
   using stemming and $ctitle contains text "user profiling" 
   using stemming
return data($stitle)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
Usabilityguy <span class="found">Manuscript Guide</span>
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Wildcard" id="Wildcard"></a>5 Use Case "WILDCARD":
Character Wildcard Queries</h2>
<div class="div2">
<h3><a name="wildcard-description" id=
"wildcard-description"></a>5.1 Description</h3>
<p>These use cases illustrate queries which use wildcards to append
or insert a character or sequence of characters to a word or a part
of a word. Character wildcards may be prefix (appended before the
first character), infix (inserted into a word), or suffix (appended
after the last character).</p>
</div>
<div class="div2">
<h3><a name="wildcard-queries-results" id=
"wildcard-queries-results"></a>5.2 Queries and Results</h3>
<div class="div3">
<h4><a name="wildcard-queries-results-q1" id=
"wildcard-queries-results-q1"></a>5.2.1 Q1 One Character Suffix
Wildcard Query</h4>
<p>Find all books with the word "test" with a one character suffix
in the text.</p>
<p>This query finds a word with a one character suffix (one
character after the last character).</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds "tests", but not "pretest, "tested",
"testers", "testimony", and "testing" which also appear in the
sample data. There is no "test" in the sample data, but if there
was, this query would not have found it.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "test." using wildcards
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test." 
using wildcards]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;      

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt; 
             ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <span class=
"found">Tests</span>&lt;/title&gt;  
            ...  
         &lt;/chapter&gt;
         ...  
      &lt;/part&gt;      
      ...                                         
   &lt;/content&gt; 
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
     &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               ...
            &lt;/subComponent&gt;
            ...
         &lt;/component&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q2" id=
"wildcard-queries-results-q2"></a>5.2.2 Q2 Zero or One Character
Prefix Wildcard Query</h4>
<p>Find all books with the word "way" with no prefix or a one
character prefix in the text.</p>
<p>This query finds a word with no prefix or a one character prefix
(zero or one character before the first character).</p>
<ul>
<li>
<p>Operands: "way"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (prefix) (0 or
1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: There is no "way" in the sample data but if there was,
this query would have found it.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ".?way" using wildcards
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ".?way" 
using wildcards]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them <span class=
"found">away</span> from your site.&lt;/p&gt;
         ...                
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;     
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q3" id=
"wildcard-queries-results-q3"></a>5.2.3 Q3 Zero or More Character
Infix Wildcard Query</h4>
<p>Find all books with the words "serve" or "service" in the
text.</p>
<p>This query finds words with no infix character or any number of
infix characters (zero or more characters inserted in the middle of
a word).</p>
<ul>
<li>
<p>Operands: "serv", "e"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (infix) (0 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: concat(./@number, ", ", ./metadata/title)</p>
</li>
<li>
<p>Comments: This query finds the word "service" and would find the
word "serve" if it existed in the sample data. It does not find the
word "served" which exists in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "serv.*e" using wildcards
return (concat($book/@number, ", ", 
   $book/metadata/title))
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "serv.*e" using wildcards]
/concat(@number, ", " , metadata/title)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
1, Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q4" id=
"wildcard-queries-results-q4"></a>5.2.4 Q4 One or More Character
Suffix Wildcard Query on Part of a Word</h4>
<p>Find all books with the phrases "usability testing" or "user
testing" in the text.</p>
<p>This query finds a phrase allowing a suffix of one or more
characters (one or more characters after the last character) on a
part of one of the words.</p>
<ul>
<li>
<p>Operands: "us testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (1 or
more)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: concat(./@number, ", ", ./metadata/title)</p>
</li>
<li>
<p>Comments: This is a suffix query on a part of a word "us" which
is not one of the words or one of the roots of the words desired in
the results. The query on "us" will find "usability" and "user".
Where stemmed queries (Section 6 (STEMMING)) attempt to find
linguistic variants of a word or the root of a word, wildcards may
be applied to any part of a word and will find all character
combinations found.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "us.+ testing" using wildcards
return (concat($book/@number, ", ", 
   $book/metadata/title))
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "us.+ testing"
using wildcards]/concat(@number, ", ", metadata/title)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
1, Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing
2, Usability Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site
3, John Wesley Usabilityguy: A Register of His 
Papers
</pre></div>
</div>
<div class="div3">
<h4><a name="wildcard-queries-results-q5" id=
"wildcard-queries-results-q5"></a>5.2.5 Q5 Specified Range of
Characters Suffix Wildcard Query</h4>
<p>Find all books with the word "test" with a three to four
character suffix in the text.</p>
<p>This query finds a word with a number of characters within a
specified range in a suffix (specified range of characters after
the last character).</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, character wildcard (suffix) (3 to
4)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query allows any three or four character suffix.
It finds "testers" and "testing", but not "pretest" "tests" and
"tested" which also appear in the sample data. There is no "test"
in the sample data, but if there was, this query would not have
found it.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "test.{3,4}" using wildcards
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test.{3,4}"
using wildcards]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability <span class=
"found">testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability <span class=
"found">Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            <span class="found">testing</span>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
                                                
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability
         <span class=
"found">testing</span> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Take the following steps to plan usability
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the &gt;usability <span class=
"found">testing</span>. 
            &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two <span class=
"found">testers</span>, &lt;footnote&gt;Usability
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. <span class=
"found">Testers</span> should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of <span class=
"found">testing</span> and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User <span class=
"found">Testing</span>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"When Are You Done <span class="found">Testing</span>?"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User <span class="found">Testing</span>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Stemming" id="Stemming"></a>6 Use Case "STEMMING":
Word Stemming Queries</h2>
<div class="div2">
<h3><a name="stemming-description" id=
"stemming-description"></a>6.1 Description</h3>
<p>These use cases invoke a stemming algorithm (e.g., Porter) which
finds noun, verb, adjective, and adverb forms of a word or root of
a word in singular and plural.</p>
</div>
<div class="div2">
<h3><a name="stemming-queries-results" id=
"stemming-queries-results"></a>6.2 Queries and Results</h3>
<div class="div3">
<h4><a name="stemming-queries-results-q1" id=
"stemming-queries-results-q1"></a>6.2.1 Q1 Query Stemming on Word
Root</h4>
<p>Find all books with the word "test" in the text.</p>
<p>This query finds a word and its variants applying a stemming
algorithm.</p>
<ul>
<li>
<p>Operands: "test"</p>
</li>
<li>
<p>Functionality: word query, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Unlike the wildcard queries in Section 5 (WILDCARD)
which allow any suffix, this query will not return the word
"testimony" which occurs in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "test" using stemming
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test" 
using stemming]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability <span class=
"found">testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability <span class=
"found">Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <span class=
"found">tests</span> of the site with your unique 
            audience or audiences by conducting usability 
            <span class="found">testing</span>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;                                                   

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <span class=
"found">tests</span> on Web sites. Usability 
         <span class=
"found">testing</span> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <span class="found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability <span class=
"found">testing</span>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume <span class=
"found">testing</span>.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <span class=
"found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be <span class=
"found">tested</span> at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are <span class=
"found">testing</span> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of <span class=
"found">testing</span> and changes, until  
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;    

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User <span class=
"found">Testing</span>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <span class=
"found">Tests</span>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done <span class="found">Testing</span>?
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User <span class="found">Testing</span>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stemming-queries-results-q2" id=
"stemming-queries-results-q2"></a>6.2.2 Q2 Query Stemming on
Multiple Word Roots</h4>
<p>Find all books with the phrases "usability testing" or "users
testing" in the text.</p>
<p>This query finds phrases applying a stemming algorithm to
selected words within the phrases.</p>
<ul>
<li>
<p>Operands: "usability testing" "users testing"</p>
</li>
<li>
<p>Functionality: phrase queries, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query applies stemming to one word in a phrase.
Unlike the wildcard queries in Section 5 (WILDCARD) which allow any
suffix, a stemmed query on "us" will not find "user" and
"usability", because they do not share the same root. This query
uses an <code>ftor</code> query introduced in Section 10
(LOGICAL).</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text ("usability" using stemming ftand "testing" 
   phrase) ftor ("users" using stemming ftand "testing" phrase)
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("usability" using stemming
ftand "testing" phrase) ftor ("users" using stemming
ftand "testing" phrase)]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <span class=
"found">usability</span> 
            <span class="found">testing</span>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
    
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. <span class=
"found">Usability</span>
         <span class=
"found">testing</span> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Take the following steps to plan <span class=
"found">usability</span>
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the <span class=
"found">usability testing</span>. 
            &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;<span class=
"found">Usability</span>
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for <span class=
"found">User Testing</span>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;subsubComponent&gt;&lt;componentTitle&gt;"Do-It-
                  Yourself <span class="found">User Testing</span>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Thesaurus" id="Thesaurus"></a>7 Use Case "THESAURUS":
Queries Which Use Thesauri, Dictionaries, and Taxonomies</h2>
<div class="div2">
<h3><a name="thesaurus-description" id=
"thesaurus-description"></a>7.1 Description</h3>
<p>These use cases illustrate queries which return synonyms or
related words identified by thesauri, dictionaries, and
taxonomies.</p>
</div>
<div class="div2">
<h3><a name="thesaurus-queries-results" id=
"thesaurus-queries-results"></a>7.2 Queries and Results</h3>
<div class="div3">
<h4><a name="thesaurus-queries-results-q1" id=
"thesaurus-queries-results-q1"></a>7.2.1 Q1 Query on Synonyms
Identified by a Thesaurus</h4>
<p>Find all introductions which quote someone.</p>
<p>This query finds words and phrases using a thesaurus to return
synonyms.</p>
<ul>
<li>
<p>Operands: "quote"</p>
</li>
<li>
<p>Functionality: word query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//introduction</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses thesaurus support to identify synonyms
for the word "quote" via preferred and used for terms: "said",
"says", "stated", "states", "spoke", "speaks", "replied",
"replies", "reply", "remarks", "remarked", "responded", "response",
"reports", "reported", "quotes", "quoted", "according to",
"commented", "discussed", "expressed", and "told". These words and
phrases become additional operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book//introduction 
where $intro contains text "quote" using thesaurus at
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "synonyms"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//introduction contains text "quote" 
using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "synonyms"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold <span class=
"found">remarked</span> during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;      
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q2" id=
"thesaurus-queries-results-q2"></a>7.2.2 Q2 Query on Narrower Terms
Identified by a Thesaurus</h4>
<p>Find all books with text on improving "web site components".</p>
<p>This query finds words using a thesaurus to identify narrower
terms.</p>
<ul>
<li>
<p>Operands: "web site components"</p>
</li>
<li>
<p>Functionality: phrase query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query employs a thesaurus to identify web site
components via narrower terms: "layout", "terminology", "graphics",
"menus", and "navigation". These words become additional
operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web site components" 
   using thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "narrower term" at most 2 levels
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "web site components" 
using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "narrower term" at most 2 levels]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in <span class=
"found">layout</span>, 
         <span class="found">terminology</span>, and <span class=
"found">navigation</span> before they frustrate
         users and drive them away from your site.&lt;/p&gt; 
         ... 
      &lt;/introduction&gt;                   
      ... 
   &lt;/content&gt;  
&lt;/book&gt;   
      
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ... 
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt;   
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <span class=
"found">Web site components</span> which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;  
         &lt;/chapter&gt;
      &lt;/part&gt;       
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q3" id=
"thesaurus-queries-results-q3"></a>7.2.3 Q3 Query on Broader Terms
Identified by a Thesaurus</h4>
<p>Are there any "letters" or "holiday cards" in John Wesley
Usabilityguy's papers?</p>
<p>This query finds words and phrases using a thesaurus to identify
broader terms.</p>
<ul>
<li>
<p>Operands: "letters" "holiday cards"</p>
</li>
<li>
<p>Functionality: word query, phrase query, thesaurus support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query employs a thesaurus to identify the broader
term "correspondence". It becomes an additional operand.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $cont := $book/content 
where $cont contains text ("letters" ftor "holiday cards") 
   using thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "BT" exactly 1 levels
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("letters" 
ftor "holiday cards") using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "BT" exactly 1 levels]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <span class=
"found">correspondence</span>, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<span class=
"found">Correspondence</span>, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;            
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<span class=
"found">Correspondence</span>, articles, book drafts, notes,
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;    
         ...        
      &lt;/part&gt;
   &lt;/content&gt;    
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q4" id=
"thesaurus-queries-results-q4"></a>7.2.4 Q4 Query on Word Which
Sounds Like Other Words</h4>
<p>Find all books with words which sound like "Merrygould".</p>
<p>This query finds words using a dictionary of words which sound
like the word queried.</p>
<ul>
<li>
<p>Operands: "Merrygould"</p>
</li>
<li>
<p>Functionality: word query, sounds-like dictionary support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses sounds-like support to identify words
which sound like the word "Merrygould". It finds the word
"Marigold". Examples of how this query is implemented include
keeping a list of similar words (akin to a thesaurus) or using a
system based on phonetic similarity.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "Merrygould" 
   using thesaurus at 
   "http://bstore1.example.com/UsabilitySoundex.xml" 
   relationship "sounds like"]
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "Merrygould" 
using thesaurus at 
"http://bstore1.example.com/UsabilitySoundex.xml" 
relationship "sounds like"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent <span class=
"found">Marigold</span>&lt;/author&gt;
      &lt;author&gt;Montana <span class=
"found">Marigold</span>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         <span class=
"found">Marigold</span> remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;   
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent <span class=
"found">Marigold</span>&lt;/author&gt;
      &lt;author&gt;Morty <span class=
"found">Marigold</span>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q5" id=
"thesaurus-queries-results-q5"></a>7.2.5 Q5 Query on Word Spelled
Similarly to Other Words</h4>
<p>Find all books which contain words that are close in spelling to
"sucessfull".</p>
<p>This query finds words using a dictionary of words that are
spelled similarly.</p>
<ul>
<li>
<p>Operands: "sucessfull"</p>
</li>
<li>
<p>Functionality: word query, similarly spelled dictionary
support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses support for similarly spelled words to
identify words close in spelling to "sucessfull". It finds the word
"successful". Examples of how this query is implemented include
keeping a list of similar words (akin to a thesaurus) or using a
system based on spelling similarities.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "sucessfull" 
   using thesaurus at 
   "http://bstore1.example.com/spellcheck.xml" 
   relationship "misspelling of"]
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "sucessfull" 
using thesaurus at 
"http://bstore1.example.com/spellcheck.xml" 
relationship "misspelling of"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most <span class=
"found">successful</span> projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was <span class=
"found">successful</span> in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;  
&lt;/book&gt;    

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are <span class=
"found">successful</span> in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;   
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="thesaurus-queries-results-q6" id=
"thesaurus-queries-results-q6"></a>7.2.6 Q6 Query on Subordinate
Terms Identified by a Taxonomy</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" and "other infectious diseases" among the charities he
supported.</p>
<p>This query finds words using a taxonomy to identify subordinate
terms.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: word query, case sensitivity (limited to upper
case), taxonomy support</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context: ./content/part/component</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query uses a taxonomy to identify other
infectious diseases: "Hepatitis" and "Tuberculosis". These words
become additional operands.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book//component
where $comp contains text "AIDS" using uppercase 
   using thesaurus at 
   "http://bstore1.example.com/OurTaxonomy.xml" 
   relationship "disease in this category"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and .//component contains text 
"AIDS" using uppercase using thesaurus at 
"http://bstore1.example.com/OurTaxonomy.xml" 
relationship "disease in this category"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, <span class="found">Hepatitis</span>, 
               <span class=
"found">Tuberculosis</span>&lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;      
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Stop-word" id="Stop-word"></a>8 Use Case "STOP-WORD":
Queries on Stop Words</h2>
<div class="div2">
<h3><a name="stop-word-description" id=
"stop-word-description"></a>8.1 Description</h3>
<p>These use cases query a phrase, one word of which has been
identified as a stop word via a stop word list. The first treats
the stop word as a stop word. The second does not, making it
available again for querying. Another query calls a stop word list
then excludes a word on the list making that word available for
querying.</p>
<p>Words identified as stop words may be routinely eliminated from
queries, allowing any word to be substituted.</p>
</div>
<div class="div2">
<h3><a name="Stop-word-queries-results" id=
"Stop-word-queries-results"></a>8.2 Queries and Results</h3>
<div class="div3">
<h4><a name="stop-word-queries-results-q1" id=
"stop-word-queries-results-q1"></a>8.2.1 Q1 Query on Stop Word
Treated as a Stop Word</h4>
<p>Find all books with the phrase "planning then conducting" in the
text where "then" is treated as a stop word.</p>
<p>This query finds a phrase substituting any word for a word which
has been identified as a stop word via a stop word list.</p>
<ul>
<li>
<p>Operands: "planning then conducting"</p>
</li>
<li>
<p>Functionality: stop word (then), phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Once the stop word "then" has been identified via the
stop word list at http://bstore1.example.com/StopWordList.xml, this
query is reduced to a query on the phrase "planning" any word
"conducting", allowing any word as a substitute for the stop word.
It finds both "planning and conducting" and "planning then
conducting" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "planning then conducting" 
   using stop words 
   at "http://bstore1.example.com/StopWordList.xml"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "planning then 
conducting" using stop words at 
"http://bstore1.example.com/StopWordList.xml"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for <span class=
"found">planning and</span> 
         <span class=
"found">conducting</span> usability tests on Web sites. Usability  
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Planning then Conducting</span> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stop-word-queries-results-q2" id=
"stop-word-queries-results-q2"></a>8.2.2 Q2 Query on Stop Word Not
Treated as a Stop Word</h4>
<p>Find all books with the phrase "planning then conducting" in the
text where "then" is not treated as a stop word.</p>
<p>This query does not eliminate a word from the query even though
it has been identified as a stop word in the stop word list, making
it available again for querying.</p>
<ul>
<li>
<p>Operands: "planning then conducting"</p>
</li>
<li>
<p>Functionality: stop word (then), phrase query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Even though the word "then" has been identified as a
stop word, this query makes it available again for querying. It
finds only "planning then conducting" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "planning then conducting" 
   using no stop words
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "planning then 
conducting" using no stop words]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Planning then Conducting</span> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="stop-word-queries-results-q3" id=
"stop-word-queries-results-q3"></a>8.2.3 Q3 Query Excluding a Stop
Word on a Stop Word List</h4>
<p>Find books with the phrase "not been approved" in the text.</p>
<p>This query finds a phrase substituting any words for words which
have been identified as stop words via a stop word list, removing
the word "not" temporarily from the stop word list.</p>
<ul>
<li>
<p>Operands: "not been approved"</p>
</li>
<li>
<p>Functionality: phrase query, stop word list (not, been), the
stop word "not" is excluded from the list and used in the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: The stop words "not" and "been" are identified via a
stop word list, however the stop word "not" is removed temporarily
from the stop word list and used as an operand in the query. The
query becomes a query on the phrase "not" [any word] "approved",
allowing any word as a substitute for the stop word "been". It does
not return books with the word "approved" in the phrases "been
approved" and "approved travel orders" in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text 
   "not been approved" using stop words at
   "http://bstore1.example.com/StopWordList.xml" 
   except ("not")
return ($book/metadata/title, $cont)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "not been 
approved" using stop words at 
"http://bstore1.example.com/StopWordList.xml" 
except ("not")]/(metadata/title, content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site&lt;/title&gt;
&lt;content&gt;
   ...          
   &lt;p&gt;This book has <span class=
"found">not been approved</span> by the Web Site 
   Users Association&lt;/p&gt;
   ...     
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Character" id="Character"></a>9 Use Case "CHARACTER":
Queries Specifying Normalized Forms of Characters and Tokenized
Words</h2>
<div class="div2">
<h3><a name="character-description" id=
"character-description"></a>9.1 Description</h3>
<p>These use cases illustrate queries on words entered with
diacritics sometimes finding the same; other times finding words
with and without diacritics. They query words entered in upper case
sometimes finding the same; other times finding words in both upper
and lower case.</p>
</div>
<div class="div2">
<h3><a name="character-queries-results" id=
"character-queries-results"></a>9.2 Queries and Results</h3>
<div class="div3">
<h4><a name="character-queries-results-q1" id=
"character-queries-results-q1"></a>9.2.1 Q1 Diacritics Sensitive
Query</h4>
<p>Verify the existence of a "résumé" in the papers of John Wesley
Usabilityguy.</p>
<p>This query finds a word only if it contains the diacritics as
written in the query.</p>
<ul>
<li>
<p>Operands: "résumé"</p>
</li>
<li>
<p>Functionality: word query, functionality requiring presence of
diacritics as written in the query, character wildcard (suffix)
(1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The desired results include only the words "résumé"
and "résumés" with diacritics as written in the query, not the more
often used words "resume" (which is present in the sample data) and
"resumes".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "résumé.?" using wildcards 
   using diacritics sensitive
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "résumé.?" 
using wildcards using diacritics sensitive]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <span class=
"found">résumés</span> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q2" id=
"character-queries-results-q2"></a>9.2.2 Q2 Diacritics Insensitive
Query</h4>
<p>Verify the existence of a résumé in the papers of John Wesley
Usabilityguy.</p>
<p>This query finds a word whether diacritics are present or
not.</p>
<ul>
<li>
<p>Operands: "resume"</p>
</li>
<li>
<p>Functionality: word query, functionality finding words with and
without diacritics, character wildcard (suffix) (1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The desired results include either the words "résumé"
or "résumés" with diacritics or the words "resume" or "resumes"
without diacritics. Whether diacritics are written in the query or
not is not considered.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "resume.?" using wildcards 
   using diacritics insensitive
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "resume.?" 
using wildcards using diacritics insensitive]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;<span class=
"found">Resume</span> testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;  
      ... 
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <span class=
"found">résumés</span> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q3" id=
"character-queries-results-q3"></a>9.2.3 Q3 Query on Word with
Upper Case Characters</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" among the charities he supported.</p>
<p>This query finds a word in upper case characters.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: case sensitivity (limited to upper case), word
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query does not return the word "aids" with lower
case characters which exists in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book  
where $book[. contains text "AIDS" using uppercase] 
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "AIDS" using uppercase]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="character-queries-results-q4" id=
"character-queries-results-q4"></a>9.2.4 Q4 Query on Word with
Upper Case and Lower Case Characters</h4>
<p>Find out whether John Wesley Usabilityguy included research on
"AIDS" among the charities he supported.</p>
<p>This query finds a word with upper or lower case characters.</p>
<ul>
<li>
<p>Operands: "AIDS"</p>
</li>
<li>
<p>Functionality: word query, case insensitivity</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds the word "aids" with characters in
upper or lower case.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book  
where $book contains text "AIDS" using case insensitive
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "AIDS" using case 
insensitive]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding <span class=
"found">aids</span>&lt;/subject&gt;
      &lt;/subjects&gt;      
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <span class=
"found">AIDS</span>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Logical" id="Logical"></a>10 Use Case "LOGICAL":
Queries with Logical Expressions (Or, And, and Not Queries)</h2>
<div class="div2">
<h3><a name="logical-description" id="logical-description"></a>10.1
Description</h3>
<p>These use cases include queries containing logical expressions:
<code>or</code>, <code>and</code>, the unary <code>not</code>,
<code>and not</code>, and <code>mild not</code>.</p>
</div>
<div class="div2">
<h3><a name="logical-queries-results" id=
"logical-queries-results"></a>10.2 Queries and Results</h3>
<div class="div3">
<h4><a name="logical-queries-results-q1" id=
"logical-queries-results-q1"></a>10.2.1 Q1 Or Query</h4>
<p>Find all books with the words "web" or "software" in the
text.</p>
<p>This query finds any or all of the words.</p>
<ul>
<li>
<p>Operands: "web" "software"</p>
</li>
<li>
<p>Functionality: word query, <code>or</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comment: The <code>or</code> query finds any or all of words
queried.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web" ftor "software"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"web" ftor "software"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The usability of a <span class=
"found">Web</span> site is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web</span> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <span class=
"found">Web</span> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <span class=
"found">web</span> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <span class=
"found">Web</span> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <span class=
"found">software</span> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <span class=
"found">Web</span>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <span class=
"found">Web</span> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
        
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;     
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on <span class=
"found">Web</span> sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the <span class="found">Web</span> Site
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         ...
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the <span class=
"found">Web</span> site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <span class=
"found">Web</span> site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;    
   &lt;/content&gt;
&lt;/book&gt;        
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Software</span>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<span class=
"found">Web</span> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q2" id=
"logical-queries-results-q2"></a>10.2.2 Q2 And Query</h4>
<p>Find all books with the words "web" "software" in the text.</p>
<p>This query finds all of the words.</p>
<ul>
<li>
<p>Operands: "web" "software"</p>
</li>
<li>
<p>Functionality: word queries, <code>and</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The <code>and</code> query finds all the words.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web" ftand "software"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"web" ftand "software"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a <span class=
"found">Web</span> site is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web</span> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <span class=
"found">Web</span> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <span class=
"found">web</span> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <span class=
"found">Web</span> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <span class=
"found">software</span> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <span class=
"found">Web</span>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <span class=
"found">Web</span> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;   
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Software</span>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<span class=
"found">Web</span> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-results-q3" id="logical-results-q3"></a>10.2.3
Q3 And Query Ordered</h4>
<p>Find all book text containing the words "goal" "obstacles"
"task" in this order.</p>
<p>This query finds multiple words in the order queried.</p>
<ul>
<li>
<p>Operands: "goal" "obstacles" "task"</p>
</li>
<li>
<p>Functionality: ordered word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds multiple words in a specified order.
It is more permissive than a phrase query. It is comparable to an
ordered distance query where the number of intervening words is
zero or more.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "goal" ftand "obstacles" 
   ftand "task" ordered
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"goal" ftand "obstacles" ftand "task" ordered]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
   ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the <span class=
"found">goal</span> of 
            identifying any <span class=
"found">obstacles</span> to completing the 
            <span class=
"found">task</span> and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q4" id=
"logical-queries-results-q4"></a>10.2.4 Q4 Unary Not Query</h4>
<p>Find all books which do not belong in a collection on "usability
testing".</p>
<p>This query finds books which do not contain a phrase in an
element and its descendants.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), unary <code>not</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: Unlike the <code>and not</code> query below, the unary
<code>not</code> query requires only one operand. This query has
value for information architects and data managers who will use it
for checks such as this one: to find nonconforming data in a
document or a collection.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book 
where $book contains text ftnot "us.* testing" 
   using wildcards
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text ftnot "us.* testing" 
using wildcards]
</pre></div>
<p><em>Expected Result: No results returned.</em></p>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q5" id=
"logical-queries-results-q5"></a>10.2.5 Q5 And Not Query</h4>
<p>Find all books with the word "usability" and not the word "plan"
in the metadata.</p>
<p>This query finds a word only when another is not found in an
element or its descendants.</p>
<ul>
<li>
<p>Operands: "usability" "plan"</p>
</li>
<li>
<p>Functionality: word query, <code>and not</code> query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: The <code>and not</code> query is also called a but,
but not, without query. Unlike the unary <code>not</code> query
above,this query requires two operands. Book 2 which contains the
words "usability" and "plan" in the metadata is not returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $up := $book/metadata
where $up contains text "usability" ftand ftnot "plan"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[./metadata contains text "usability" 
ftand ftnot "plan"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;                             
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
      and <span class=
"found">Usability</span> Testing&lt;/title&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;     
      ...                       
      &lt;subjects xml:lang="en"&gt;
         ...  
         &lt;subject&gt;<span class=
"found">Usability</span> Testing&lt;/subject&gt;
         ... 
      &lt;/subjects&gt;  
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q6" id=
"logical-queries-results-q6"></a>10.2.6 Q6 And Not Query Where
Second Operand Is a Subset of the First Operand</h4>
<p>Find all books with listings for "résumés", "drafts", or
"correspondence", and not "book drafts" in the text.</p>
<p>This query finds books with multiple words and not a phrase
containing one of those words.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p>
</li>
<li>
<p>Functionality: word queries, <code>or</code> query, phrase
query, <code>and not</code> query, with diacritics as written in
the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query will not return a result the user wants
because that result also includes what the user does not want,
"book drafts".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("résumés" using diacritics sensitive 
   ftor "drafts" ftor "correspondence") ftand ftnot 
   "book drafts"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[./content contains text ("résumés" 
using diacritics sensitive ftor "drafts" ftor "correspondence") 
ftand ftnot "book drafts"]
</pre></div>
<p><em>Expected Result: No results returned.</em></p>
</div>
<div class="div3">
<h4><a name="logical-queries-results-q7" id=
"logical-queries-results-q7"></a>10.2.7 Q7 Mild Not Query Where
Second Operand Is a Subset of the First Operand</h4>
<p>Find all books with listings for "résumés", "drafts", or
"correspondence", and not "book drafts", in the metadata or
text.</p>
<p>This query finds books with multiple words and not a phrase
which contains one of the words, while not eliminating a result if
it contains the phrase as well as one of the words searched.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p>
</li>
<li>
<p>Functionality: word queries, <code>or</code> query, phrase
query, <code>mild not</code> query, with diacritics as written in
the query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query will return a result the user wants even
though it contains the phrase the user deprecated via the mild not,
"book drafts". The user will not lose results which contain what he
wants when that book also contains what he does not want. Books
containing instances of "book drafts" (a subset of "drafts") are
not automatically excluded. Instead the "book drafts" instances are
not considered when determing whether or not to include books in
the result set.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("résumés" using diacritics sensitive 
   ftor "drafts" ftor "correspondence") not in "book 
   drafts"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("résumés" 
using diacritics sensitive ftor "drafts" ftor "correspondence") 
not in "book drafts"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <span class=
"found">correspondence</span>, memoranda, journals, 
         speeches, article <span class=
"found">drafts</span>, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
         &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Cardinality" id="Cardinality"></a>11 Use Case
"CARDINALITY": Queries in Same, Any, Every Instance of an Element,
and Occurrence Count Query</h2>
<div class="div2">
<h3><a name="cardinality-description" id=
"cardinality-description"></a>11.1 Description</h3>
<p>These use cases illustrate instance queries and occurrence count
queries. They query words within the same, any, and every instance
of an element. Another query finds a phrase only if it occurs over
a specified number of times in a book.</p>
</div>
<div class="div2">
<h3><a name="cardinality-queries-results" id=
"cardinality-queries-results"></a>11.2 Queries and Results</h3>
<div class="div3">
<h4><a name="cardinality-queries-results-q1" id=
"cardinality-queries-results-q1"></a>11.2.1 Q1 Query in Same
Instance of an Element</h4>
<p>Find all books with the phrase "web site" and the word
"usability" in the same subject.</p>
<p>This query finds a word and a phrase in the same instance of an
element.</p>
<ul>
<li>
<p>Operands: "web site" "usability"</p>
</li>
<li>
<p>Functionality: phrase query, word query, <code>and</code>
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds a word and a phrase in an instance of
an element, not allowing one of the operands to be found in an
instance of the element and the other operand in a different
instance of the element. This query does not find Book 2 which has
"usability" and "web site" in different instances of the
<code>subject</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $subj := $book/metadata/subjects/subject
where $subj contains text "web site" ftand "usability"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/subjects/subject contains text 
"web site" ftand "usability"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> <span class=
"found">usability</span>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q2" id=
"cardinality-queries-results-q2"></a>11.2.2 Q2 Query in Any
Instance of an Element (Existential Quantification)</h4>
<p>Find all books with the phrase "web site" and the word
"usability" in any subject.</p>
<p>This query finds a word and a phrase in any instance of an
element across the siblings of the same element. The word and the
phrase may be in different elements.</p>
<ul>
<li>
<p>Operands: "web site" "usability"</p>
</li>
<li>
<p>Functionality: phrase query, word query, <code>and</code> query,
existential quantification</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds words and phrases in any instance of
an element, allowing one of the operands to be found in one sibling
and the other operand in a different sibling of the same element
name.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book                        
let $subj := $book/metadata/subjects/subject            
where (some $s1 in $subj satisfies $s1 contains text "web site")    
   and (some $s2 in $subj satisfies $s2 contains text "usability")
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[(some $s1 in ./metadata/subjects/subject satisfies 
$s1 contains text "web site") 
and (some $s2  in ./metadata/subjects/subject satisfies 
$s2 contains text "usability")]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<span class=
"found">Usability</span> testing&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> development&lt;/subject&gt;          
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> <span class=
"found">usability</span>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<span class=
"found">Usability</span> testing&lt;/subject&gt;
         &lt;subject&gt;<span class=
"found">Web site</span> development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q3" id=
"cardinality-queries-results-q3"></a>11.2.3 Q3 Query in Every
Instance of an Element (Universal Quantification)</h4>
<p>Find all books with the words "ersatz" and "publications" in
every publisher name.</p>
<p>This query finds two words in every instance of an element.</p>
<ul>
<li>
<p>Operands: "ersatz" "publications"</p>
</li>
<li>
<p>Functionality: word query, <code>and</code> query, universal
quantification</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/publicationInfo/publisher</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query does not return a book if at least one of
its publishers does not contain the words "ersatz" and
"publications". Book 1 is returned because it has an instance of
the <code>publisher</code> element which satisfies the full-text
conditions (contains both "Ersatz" and "Publications"). Book 2 is
not returned because even though it has a publisher that satisfies
the full-text conditions, it also has a publisher that does not
satisfy it. Book 3 is not returned because it has an instance of
the <code>publisher</code> element which does not satisfy the query
(contains "Ersatz" but not "Publications").</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where every $pub in $book//publisher satisfies 
   $pub contains text "ersatz" ftand "publications"
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[every $pub in .//publisher 
satisfies $pub contains text "ersatz" ftand "publications"]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
      &lt;publicationInfo&gt;   
         &lt;publisher&gt;<span class=
"found">Ersatz Publications</span>&lt;/publisher&gt;
      &lt;/publicationInfo&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="cardinality-queries-results-q4" id=
"cardinality-queries-results-q4"></a>11.2.4 Q4 Occurrence Count
Query</h4>
<p>Find all books which repeat the phrase "expert review methods"
in the text at least two times.</p>
<p>This query finds a phrase which is repeated a specified number
of times.</p>
<ul>
<li>
<p>Operands: "expert review methods"</p>
</li>
<li>
<p>Functionality: phrase query, at least functionality</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query excludes books with only minor (single
occurrence) references to "expert review methods".</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "expert review methods" 
   occurs at least 2 times
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "expert 
review methods" occurs at least 2 times]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...
            &lt;p&gt;Two <span class=
"found">expert review methods</span> are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;<span class=
"found">Expert review methods</span> should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Proximity" id="Proximity"></a>12 Use Case "PROXIMITY":
Queries on Proximity Relationships Including Distance, Window,
Sentence, and Paragraph</h2>
<div class="div2">
<h3><a name="proximity-description" id=
"proximity-description"></a>12.1 Description</h3>
<p>These use cases illustrate unordered and ordered distance
queries which find sequences of words allowing up to a specified
number of intervening words. They also include a query to find
words within a window, within a sentence, and within a
paragraph.</p>
</div>
<div class="div2">
<h3><a name="proximity-queries-results" id=
"proximity-queries-results"></a>12.2 Queries and Results</h3>
<div class="div3">
<h4><a name="proximity-queries-results-q1" id=
"proximity-queries-results-q1"></a>12.2.1 Q1 Unordered Distance
Query</h4>
<p>Find all books with information on "software developers".</p>
<p>This query finds multiple words in any order allowing up to a
specified number of intervening words.</p>
<ul>
<li>
<p>Operands: "software" "developer"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
3 intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query finds "developer of software", which occurs
in the sample data.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "software" ftand "developer" 
   using stemming distance at most 3 words
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "software" 
ftand "developer" using stemming distance at most 3 words]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a <span class=
"found">developer</span> of <span class="found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q2" id=
"proximity-queries-results-q2"></a>12.2.2 Q2 Ordered Distance
Query</h4>
<p>Find all books with information on "efficient task
completion".</p>
<p>This query finds multiple words in the order queried allowing up
to a specified number of intervening words.</p>
<ul>
<li>
<p>Operands: "efficient" "task" "completion"</p>
</li>
<li>
<p>Functionality: word queries, ordered distance (0 to 10
intervening words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query is more permissive than an phrase query on
"efficient task completion" which would return no results.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "efficient" ftand "task" ftand 
   "completion" ordered distance at most 10 words
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "efficient" 
ftand "task" ftand "completion" ordered
distance at most 10 words]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable <span class=
"found">efficient</span> and effective <span class=
"found">task</span>
         <span class=
"found">completion</span>, while propagating few errors.
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q3" id=
"proximity-queries-results-q3"></a>12.2.3 Q3 Ordered Window
Query</h4>
<p>Find all books about "users feeling well-served".</p>
<p>This query finds books with multiple words within an ordered
window of up to a specified number of words.</p>
<ul>
<li>
<p>Operands: "users" "feeling" "well served" "well-served"</p>
</li>
<li>
<p>Functionality: word queries, ordered window (0 to 15 words)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query opens a window on the first found word
(which because of the <code>ordered</code> operator must be the
first word queried) and counts a specified number of words from
that first word within which it may find the remaining word or
words, finding them in the order queried.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("users" ftand "feeling") 
   using stemming ftand "well served" ftor 
   "well-served" ordered window 15 words
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("users" ftand 
"feeling") using stemming ftand "well served" 
ftor "well-served" ordered window 15 words]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task
         completion, while propagating few errors.         
         Satisfaction with the site is also important. 
         The <span class=
"found">user</span> must not only be well-served, but must
         <span class="found">feel</span> <span class=
"found">well</span>-<span class="found">served</span>.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q4" id=
"proximity-queries-results-q4"></a>12.2.4 Q4 Unordered Within a
Sentence Query</h4>
<p>Find all books which discuss "questions asked during cognitive
walk-throughs".</p>
<p>This query finds books with multiple words in any order within a
sentence.</p>
<ul>
<li>
<p>Operands: "users" "would" "know" "step"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered sentence
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query expects an implementation-defined tokenized
sentence or a <code>sentence</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("users" ftand "would" ftand "know" 
   ftand "step" same sentence) using stemming
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("users" ftand "would" 
ftand "know" ftand "step" same sentence) using stemming]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;                                    
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "<span class=
"found">Would</span> a
            <span class="found">user</span> <span class=
"found">know</span> by looking at the screen how to
            complete the first <span class=
"found">step</span> of the task?" and "If            
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="proximity-queries-results-q5" id=
"proximity-queries-results-q5"></a>12.2.5 Q5 Unordered Within a
Paragraph Query</h4>
<p>Find all paragraphs which define what "Web site usability"
is.</p>
<p>This query finds books with multiple words and phrases in any
order within a paragraph.</p>
<ul>
<li>
<p>Operands: "usability" "web site" "efficiency" "satisfaction"</p>
</li>
<li>
<p>Functionality: word queries, phrase query, unordered paragraph
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query expects an implementation-defined tokenized
paragraph or a <code>paragraph</code> element. Depending on the
implementation, this query might return no result instead of the
Expected Result presented.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "usability" ftand "web site" 
   ftand "efficiency" ftand "satisfaction" same paragraph
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "usability" 
ftand "web site" ftand "efficiency" ftand "satisfaction" 
same paragraph]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The <span class=
"found">usability</span> of a <span class=
"found">Web site</span> is how well the 
         site supports the user in achieving specified 
         goals. A <span class=
"found">Web site</span> should facilitate learning, 
         and enable <span class=
"found">efficient</span> and effective task
         completion, while propagating few errors.         
         <span class=
"found">Satisfaction</span> with the site is also important.. 
         The user must not only be well-served, but must
         feel well-served.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;                                     
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Axes" id="Axes"></a>13 Use Case "AXES": Queries Using
Relative XPath Axes</h2>
<div class="div2">
<h3><a name="axes-description" id="axes-description"></a>13.1
Description</h3>
<p>These use cases illustrate queries traversing relative XPath
axes.</p>
</div>
<div class="div2">
<h3><a name="axes-queries-results" id=
"axes-queries-results"></a>13.2 Queries and Results</h3>
<div class="div3">
<h4><a name="axes-queries-results-q1" id=
"axes-queries-results-q1"></a>13.2.1 Q1 Query on Element and Its
Children</h4>
<p>Find all books with paragraphs containing the phrase "computer
workstation" and footnotes within those paragraphs containing the
word "comfortable".</p>
<p>This query finds a phrase in an element, then finds a word in a
child element.</p>
<ul>
<li>
<p>Operands: "computer workstation" "comfortable"</p>
</li>
<li>
<p>Functionality: phrase query, word query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//p, .//p/footnote</p>
</li>
<li>
<p>Return: ./metadata/title, .//p</p>
</li>
<li>
<p>Comments: This query combines phrase and word search in
different elements which have a parent-child relationship.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book//p
let $fn := $para/footnote
where $para contains text "computer workstation" 
   and $fn contains text "comfortable"
return ($book/metadata/title, $para)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//p contains text "computer workstation" 
and .//p/footnote contains text "comfortable"]/(metadata/title, 
.//p)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;      
&lt;p&gt;This is a basic handbook for planning and 
conducting usability tests on Web sites. Usability 
testing should be used in conjunction with other 
expert review methods.&lt;/p&gt;
&lt;p&gt;This book has not been approved by the Web Site 
Users Association.&lt;/p&gt;
&lt;p&gt;Take the following steps to plan usability 
testing. &lt;step number="1"&gt;Clarify and 
articulate the goal of the usability testing.
&lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
are critical for users to be able to complete 
successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
a script of questions or instructions which 
will prompt the user to attempt those 
tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
users and begin recruiting them.&lt;/step&gt; &lt;step 
number="5"&gt;Conduct a pretest on a few users.
&lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
on insights gleaned from the pretest.&lt;/step&gt; 
&lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
&lt;p&gt;Users can be tested at any <span class=
"found">computer</span> 
<span class="found"> workstation</span>
&lt;footnote&gt;They may be more 
<span class=
"found">comfortable</span> at their own workstation than in 
a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
&lt;p&gt;Give the user the script, then assure them 
that you are testing the Web site, not them. 
Users are asked to verbalize their thoughts as 
they complete the tasks. The event is recorded 
or someone takes notes. It is often preferable 
to have two testers, &lt;footnote&gt;Usability 
testing can be done at great expense or on a 
shoe string, using &lt;testingProcedure&gt;in-house 
expertise&lt;/testingProcedure&gt; or 
&lt;testingProcedure&gt;contracting with human 
computer interaction professionals
&lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
questions, another to take notes. Testers should 
offer no guidance or comments to the user. Mouse 
movements, typing, expressions, and the user's 
words should be recorded.&lt;/p&gt;
&lt;p&gt;Compile the results and review collectively. 
Make changes to the site to alleviate the problems 
found in Web site components which were propagating 
the largest number of or the most devastating errors. 
Begin new iterations of testing and changes, until 
users are successful in the accomplishing the 
tasks.&lt;/p&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q2" id=
"axes-queries-results-q2"></a>13.2.2 Q2 Query on Element Returning
Its First Two Children</h4>
<p>Find the first two steps in chapters on "conducting usability
tests."</p>
<p>This query finds words in an element, then returns its first two
children elements.</p>
<ul>
<li>
<p>Operands: "usability", "test"</p>
</li>
<li>
<p>Functionality: word queries, stemming</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p</p>
</li>
<li>
<p>Return: ./metadata/title ./content/part/chapter/p/step[1],
./content/part/chapter/p/step[2]</p>
</li>
<li>
<p>Comments: This query finds words in a <code>p</code> element and
uses XPath to return the first two children of the element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book//chapter/p
where $para contains text "usability" ftand "test" 
   using stemming
return ($book/metadata/title, $para/step[1], $para/step[2])
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//chapter/p contains text "usability" 
ftand "test" using stemming]/(metadata/title, 
.//chapter/p/step[1], .//chapter/p/step[2])
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;   
&lt;step number="1"&gt;Clarify and articulate 
the goal of the usability testing.&lt;/step&gt; 
&lt;step number="2"&gt;Identify tasks which 
are critical for users to be able to complete 
successfully.&lt;/step&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q3" id=
"axes-queries-results-q3"></a>13.2.3 Q3 Query on Element and Its
Ancestors</h4>
<p>Are there any "flow diagrams" of "human computer interaction"
scenarios in John Wesley Usabilityguy's papers?</p>
<p>This query finds a phrase in an element, then finds another
phrase in an ancestor element.</p>
<ul>
<li>
<p>Operands: "flow diagrams" "human computer interaction"</p>
</li>
<li>
<p>Functionality: phrase queries, character wildcard (suffix) (0 or
one)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p>
</li>
<li>
<p>Query context:
./content/part/component/(subComponent|subComponent/subsubComponent)/componentTitle</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query looks for a phrase in an element and a
different phrase in its ancestor elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book/content/part/component/
   (subComponent|subComponent/subsubComponent)/
   componentTitle
let $parentComp := $comp[ancestor::node()]
where $comp contains text "flow diagram.?" 
   using wildcards and $parentComp 
   contains text "human computer interaction"
return ($book/metadata/title, $book/content)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and content/part/component/
(subComponent|subComponent/subsubComponent)/ 
componentTitle contains text "flow diagram.?" using wildcards 
and ./ancestor::node()[.//componentTitle contains text "human computer 
interaction"]]/(metadata/title, content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
      &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
      1930-1974&lt;/date&gt;&lt;/title&gt;
        ...
        &lt;subComponent&gt;
           &lt;componentTitle&gt;<span class=
"found">Human Computer Interaction</span> 
           research, &lt;componentDate normalize="1945/1952"&gt;
           1945-1952&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
           &lt;subsubComponent&gt;
              &lt;componentTitle&gt;<span class=
"found">Flow diagram</span>, 
              &lt;componentDate normalize="1950"&gt;1950
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
           ...
         &lt;/subComponent&gt;
      &lt;/component&gt;
   &lt;/part&gt;
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="axes-queries-results-q4" id=
"axes-queries-results-q4"></a>13.2.4 Q4 Query on Element and Its
Right Siblings</h4>
<p>Find all book chapters with paragraphs on "usability testing"
followed by paragraphs on "information architecture".</p>
<p>This query finds a phrase in an element, then finds another
phrase in one of its right siblings.</p>
<ul>
<li>
<p>Operands: "usability testing" "information architecture"</p>
</li>
<li>
<p>Functionality: phrase queries</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query returns book chapters if they contain
paragraphs following each other as specified in the query.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chapters := $book//chapter
where $chapters[./p contains text "usability 
   testing" and ./p/following-sibling::p contains text 
   "information architecture"]
return ($book/metadata/title, $chapters)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews and 
Usability Testing&lt;/title&gt;
&lt;chapter&gt;
    &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
    &lt;p&gt;Expert reviewers critique an interface to 
    determine conformance with recognized 
    usability principles. &lt;footnote&gt;One of the 
    best known lists of heuristics is &lt;citation 
    url="http://www.useit.com/papers/heuristic
    /heuristic_list.html"&gt;Ten Usability 
    Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
    is &lt;citation url="http://usability.gov
    /guidelines/index.html"&gt; Research-Based Web 
    Design and Usability Guidelines&lt;/citation&gt;
    &lt;/footnote&gt;&lt;/p&gt; 
&lt;/chapter&gt;
&lt;chapter&gt;
    &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
    &lt;p&gt;Expert reviewers evaluate Web site 
    understandability and ease of learning while 
    performing specified tasks. They walk through 
    the site answering questions such as "Would a 
    user know by looking at the screen how to 
    complete the first step of the task?" and "If 
    the user completed the first step, would the 
    user know what to do next?," with the goal of 
    identifying any obstacles to completing the 
    task and assessing whether the user would 
    cognitively be aware that he was successful in 
    completing a step in the process.&lt;/p&gt;
&lt;/chapter&gt;
&lt;chapter&gt;
   &lt;p&gt;Once the problems identified by expert 
   reviews have been corrected, it is time to 
   conduct some tests of the site with your unique 
   audience or audiences by conducting <span class=
"found">usability</span>
   <span class="found">testing</span>.&lt;/p&gt;
   &lt;p&gt;Users are asked to complete tasks which 
   measure the success of the <span class=
"found">information</span> 
   <span class=
"found">architecture</span> and navigational elements of the 
   site.&lt;/p&gt;
   &lt;p&gt;Then changes are made to improve service to 
   users.&lt;/p&gt;
&lt;/chapter&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Ignore" id="Ignore"></a>14 Use Case "IGNORE": Queries
Ignoring Descendant Element Content</h2>
<div class="div2">
<h3><a name="ignore-description" id="ignore-description"></a>14.1
Description</h3>
<p>These phrase and proximity queries cross element boundaries
ignoring the content of descendant elements. One query ignores the
content of a complete sub-tree. Other queries ignore only the
content of specified descendant elements. The last query performs a
level-by-level ignore. It ignores the content of descendant
elements when querying the content of the parent element. Its
descendant elements are promoted and then their content is
queried.</p>
</div>
<div class="div2">
<h3><a name="ignore-queries-results" id=
"ignore-queries-results"></a>14.2 Queries and Results</h3>
<div class="div3">
<h4><a name="ignore-queries-results-q1" id=
"ignore-queries-results-q1"></a>14.2.1 Q1 Distance Query Ignoring
Content of All Descendant Elements</h4>
<p>Find advice on whether the observer should "correct" or provide
"guidance" to the user during usability "testing".</p>
<p>This query ignores the content of all descendant elements.</p>
<ul>
<li>
<p>Operands: "testing" "correct" "guidance"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, <code>or</code>
query, ordered distance query (0 to 60 intervening words), ignore
content of descendant elements</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//p</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query ignores the content of all the descendant
elements of the <code>p</code> element, so it ignores the
<code>footnote</code> and <code>testingProcedure</code> elements.
If the descendant elements were not ignored, the words searched
would be too distant from each other to have been returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
        /books/book
     where $book//p[. contains text "testing" ftand "guidance" ftor
        "correct" distance at most 60 words without content *]
     return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//p contains text "testing" 
ftand "guidance" ftor "correct" distance at 
most 60 words without content *]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...                                       
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are <span class=
"found">testing</span> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <span class=
"found">guidance</span> or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q2" id=
"ignore-queries-results-q2"></a>14.2.2 Q2 Phrase Query Ignoring
Content of Descendant Element Specified by XPath Expression</h4>
<p>Find all book chapters containing "users can be tested at any
computer workstation or in a lab" ignoring footnotes.</p>
<p>This query finds book chapters containing the phrase "users can
be tested at any computer workstation or in a lab" ignoring the
content of a descendant element explicitly specified by an XPath
expression.</p>
<ul>
<li>
<p>Operands: "users can be tested at any computer workstation or in
a lab"</p>
</li>
<li>
<p>Functionality: phrase query, ignore content of
<code>footnote</code> element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: ./metadata/title, ./content/part/chapter</p>
</li>
<li>
<p>Comments: This query ignores the content of a descendant
element, the <code>footnote</code> element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter[. contains text "users 
   can be tested at any computer workstation 
   or in a lab" without content .//footnote]
where $chap
return ($book/metadata/title, $chap)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter[. contains text
"users can be tested at any computer workstation or in a lab"
without content .//footnote
]/(ancestor::book/metadata/title, .)/.
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;<span class=
"found">Users can be tested at any computer</span>  
   <span class=
"found">workstation</span> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<span class=
"found">or in a lab</span>.&lt;/p&gt; 
   ...
&lt;/chapter&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q3" id=
"ignore-queries-results-q3"></a>14.2.3 Q3 Phrase Query Ignoring
Content of Descendant Element Specified by Full-Text Query</h4>
<p>Find all book chapters containing the phrase "at any computer
workstation or in a lab" ignoring footnotes on workstations.</p>
<p>This query ignores the content of a descendant element specified
by a full-text query.</p>
<ul>
<li>
<p>Operands: "at any computer workstation or in a lab",
"workstations"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (1),
ignore content of a descendant element found by a full-text
query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter</p>
</li>
<li>
<p>Return: ./metadata/title, ./content/part/chapter</p>
</li>
<li>
<p>Comments: This query ignores the content of a descendant element
identified dynamically by a full-text query.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $chapter in doc("http://bstore1.example.com/full-text.xml")
   /books/book//chapter
where $chapter contains text "at any computer 
   workstation or in a lab" without content 
   $chapter//footnote[. contains text "workstation.*" 
   using wildcards]
return ($chapter/ancestor::book/metadata/title, $chapter)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter[. contains text "at any computer 
workstation or in a lab" without content 
.//footnote[. contains text "workstation.*" 
using wildcards]]/(ancestor::book/metadata/title, .)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your Web 
Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;Users can be tested <span class=
"found">at any computer</span>
   <span class=
"found">workstation</span>&lt;footnote&gt;They may be more
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<span class=
"found">or in a lab</span>.&lt;/p&gt;   
   ...
&lt;/chapter&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="ignore-queries-results-q4" id=
"ignore-queries-results-q4"></a>14.2.4 Q4 Distance Query Ignoring
Content of Descendant Elements Level by Level</h4>
<p>Find all books with the word "workstation" near the word
"lab".</p>
<p>This query performs a level-by-level ignore. It ignores the
content of descendant elements when querying the content of the
parent element. Its descendant elements are promoted and then their
content is queried. It differs from the ignore queries above
because it queries the content of parent elements skipping over the
descendant elements, then instead of stopping there it queries the
content of descendent elements in isolation.</p>
<ul>
<li>
<p>Operands: "workstation" "lab"</p>
</li>
<li>
<p>Functionality: word queries, unordered distance (0 to 6
intervening words), level by level ignore (ignore the content of
descendant element when searching the parent element and promote
the descendant element and query it in isolation)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/p,
/content/part/chapter/p/footnote</p>
</li>
<li>
<p>Return: ./metadata/title, .//chapter/(p|p/footnote)</p>
</li>
<li>
<p>Comments: This query ignores the content of the descendant
element <code>footnote</code> when querying its parent element
<code>p</code> returning "workstation" and "lab" from "Users can be
tested at any computer workstation or in a lab". Then the
descendant element <code>footnote</code> is promoted and queried
separately returning "workstation" and "lab" from "They may be more
comfortable at their own workstation than in a lab". This query is
written using the standard ignore syntax ORing together parent and
descendant elements to be queried separately.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $matches := $book//chapter/(p|p/footnote)[
   . contains text
   "workstation" ftand "lab" distance at most 6 words
   without content ./footnote]
where $matches
return ($book/metadata/title, $matches)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter/(p|p/footnote)[. contains text 
"workstation" ftand "lab" distance at most 6 words 
without content //footnote[. 
contains text "workstation." using wildcards]]   
/(ancestor::book/metadata/title, .)/.
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
&lt;p&gt;Users can be tested at any computer 
   <span class=
"found">workstation</span> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt; or in a <span class=
"found">lab</span>.&lt;/p&gt;
&lt;footnote&gt;They may be more comfortable at their own 
   <span class="found">workstation</span> than in a <span class=
"found">lab</span>.&lt;/footnote&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Full-Text-Composability" id=
"Full-Text-Composability"></a>15 Use Case
"FULL-TEXT-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Itself</h2>
<div class="div2">
<h3><a name="full-text-composability-description" id=
"full-text-composability-description"></a>15.1 Description</h3>
<p>The use cases illustrate a multi-lingual query and queries which
use multiple full-text functionalities in conjunction with other
XQuery and XPath functionalities.</p>
</div>
<div class="div2">
<h3><a name="full-text-composability-queries-results" id=
"full-text-composability-queries-results"></a>15.2 Queries and
Results</h3>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q1" id=
"full-text-composability-queries-results-q1"></a>15.2.1 Q1 Query on
Words and Phrases in Two Languages</h4>
<p>Find all books with the subject "网站可用性", with an introduction
written by "Elina Rose", which mention the name of the usability
expert "Millicent Marigold".</p>
<p>This query finds words and a phrase in more than one
language.</p>
<ul>
<li>
<p>Operands: "网站可用性" "Elina" "Rose" "Millicent" "Marigold"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, <code>and</code>
query, unordered distance (0 to 3 intervening words), capacity to
enter, query, and return multiple languages</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject,
./content/introduction/author, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title,
./metadata/subjects/subject, ./content/introduction/author,
./content</p>
</li>
<li>
<p>Comments: This query accepts multiple languages as input and
returns multiple languages as output.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book//subject[. contains text "网站可用性" using language "zh"]
   and $book/content/introduction/author[. contains text 
   "Elina" ftand "Rose" distance at most 3 words]
   and $book/content[. contains text "Millicent" ftand "Marigold" 
   distance at most 3 words]
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book//subject, 
          $book/content/introduction/author, $book/content} 
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews 
   and Usability Testing&lt;/title&gt;
   &lt;subject&gt;<span class="found">网站可用性</span>&lt;/subject&gt;
   &lt;author&gt;<span class="found">Elina</span> <span class=
"found">Rose</span>&lt;/author&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;The most successful projects employ multiple methods 
         in multiple iterations. As <span class=
"found">Millicent</span> <span class=
"found">Marigold</span> remarked 
         during a recent conference, "Don't stop. Iterate, iterate, 
         then iterate again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;   
      ...      
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q2" id=
"full-text-composability-queries-results-q2"></a>15.2.2 Q2 Phrase
and Distance Query in an Instance of an Element With Stemming</h4>
<p>Find all paragraphs in books which discuss the role of "task
performing" in "expert reviewer" methods.</p>
<p>This query finds multiple words close to each other and a phrase
in one instance of an element.</p>
<ul>
<li>
<p>Operands: "task" "performing" "expert reviewer"</p>
</li>
<li>
<p>Functionality: word queries, stemming, phrase query, unordered
distance (0 to 3 intervening words between "task" and
"performing")</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content//p</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book/content//p
where $para contains text (("task" ftand "performing" 
   distance at most 3 words) ftand 
   "expert reviewer") using stemming
return ($book/metadata/title, $book/content)
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content//p contains text (("task" 
ftand "performing" distance at most 3 words) 
ftand "expert reviewer") using stemming]/
(metadata/title, content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...   
   &lt;part number="1"&gt;
      &lt;title&gt;Expert Reviews&lt;/title&gt;
      ...
      &lt;chapter&gt;
         &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
         &lt;p&gt;<span class=
"found">Expert reviewers</span> evaluate Web site 
         understandability and ease of learning while 
         <span class=
"found">performing</span> specified <span class=
"found">tasks</span>. They walk through 
         the site answering questions such as "Would a 
         user know by looking at the screen how to 
         complete the first step of the task?" and "If 
         the user completed the first step, would the 
         user know what to do next?," with the goal of 
         identifying any obstacles to completing the 
         task and assessing whether the user would 
         cognitively be aware that he was successful in 
         completing a step in the process.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...   
&lt;/content&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q3" id=
"full-text-composability-queries-results-q3"></a>15.2.3 Q3 Nested
Distance Query with Wildcards, Stemming, and Thesaurus Support</h4>
<p>Find all books on "usability testing" which "quote" "Millicent
Marigold" on the value of "iterating" multiple times.</p>
<p>This query finds multiple words in three nested levels of
distance queries. It uses wildcards, stemming, and thesaurus
support.</p>
<ul>
<li>
<p>Operands: "usability testing" "quote" "millicent" "marigold"
"iterating"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0-5),
word queries, thesaurus support, stemming, ordered distance (0 to 3
intervening words between "millicent" and "marigold"), unordered
distance (0 to 3 intervening words between ("millicent ...
marigold" and (one of the following from stemming: "quote",
"quoted", "quotes", "quotation", "quotations" or one of the
following from thesaurus support: "said", "says", "stated",
"states", "statement", "spoke", "speaks", "replied", "replies",
"reply", "remarks", "remarked", "responded", "response", "reports
", "reported", "quotes", "quoted", "according", "commented",
"discussed", "expressed", "told"), unordered distance (0 to 50
intervening words between ("millicent ... marigold" ... ("quote" or
any of its wildcard- or thesaurus-derived substitutes) and
("usability testing" and "iterating")).</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections. This query will return the result shown or no
results depending on whether the wildcard or thesaurus match option
was processed first. The processing order of these two match
options is implementation-defined.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $quote := $book/content
where $quote contains text (("millicent" 
   ftand "marigold" ordered distance at most 3 words)
   ftand "quote.{0,5}" using wildcards using thesaurus at  
   "http://bstore1.example.com/UsabilityThesaurus.xml"
   relationship "synonyms" distance at most 3 words)
   ftand "usability testing" ftand "iterating" using stemming 
   distance at most 50 words
return $book
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text (("millicent" 
ftand "marigold" ordered distance at most 3 words)
ftand "quote.{0,5}" using wildcards using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "synonyms" distance at most 3 words)
ftand "usability testing" ftand "iterating" using stemming 
distance at most 50 words]
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate 
         users and drive them away from your site.&lt;/p&gt;      
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As <span class=
"found">Millicent</span>
         <span class="found">Marigold</span> <span class=
"found">remarked</span> during a recent conference, 
         "Don't stop. <span class=
"found">Iterate</span>, <span class=
"found">iterate</span>, then <span class=
"found">iterate</span>          
         again."&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q4" id=
"full-text-composability-queries-results-q4"></a>15.2.4 Q4 Window
Query with Wildcards and Stemming Ignoring Content of a Descendant
Element</h4>
<p>Find advice on whether an observer in a "usability test" should
"correct" or provide "guidance" to the user in a book not authored
by Montana Marigold.</p>
<p>This query uses synonyms supplied by the user, uses the unary
<code>not</code>, nests a Boolean query and a phrase query within a
window query, and ignores the tags and content of a descendant
element.</p>
<ul>
<li>
<p>Operands: "usability testing" "correct" "comment" "guidance"
"help" "assistance" "montana" "marigold"</p>
</li>
<li>
<p>Functionality: phrase query, word queries, character wildcard
(suffix) (0 or more), synonyms for "correct" and "guidance"
provided by the user ("comment" or "assistance" or "help"),
stemming, <code>or</code> query ("correct" or "comment" or
"guidance" or "assistance" or "help"), <code>and</code> query
("montana" and "marigold"), unary <code>not</code> query (not
"montana" and "marigold"), unordered window (0 to 70 words within a
window of "usability testing" and ("correct" or "comment" or
"guidance" or "assistance" or "help"). Ignores content of
descendant elements.</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/author, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $au := $book/metadata/author
let $co := $book/content
where not( $au contains text ("montana" ftand "marigold"))
   and $co contains text ("correct" ftor "comment" 
   using stemming ftor "guidance" ftor "assistance" 
   ftor "help") ftand "usability test.*" using wildcards 
   window 80 words without content $co//footnote
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $co}
          &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;content&gt;
      ...                                       
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <span class=
"found">guidance</span> or <span class=
"found">comments</span> to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="full-text-composability-queries-results-q5" id=
"full-text-composability-queries-results-q5"></a>15.2.5 Q5 Query on
Different Elements in Different Sub-Trees with Conditional
Return</h4>
<p>For each book with a title containing the word "usability", a
book introduction containing the word "satisfaction", and a part
introduction containing the phrase "identify problems", return the
book title and the authors if it has authors. Return the book title
and publisher, if it has no authors.</p>
<p>This query finds words and a phrase in different elements in
different sub-trees. It also contains a conditional return.</p>
<ul>
<li>
<p>Operands: "usability" "satisfaction" "identify problems"</p>
</li>
<li>
<p>Functionality: word queries, phrase query, conditional query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/publicationInfo/publisher, ./content/introduction,
./content/part/introduction</p>
</li>
<li>
<p>Comments: This query combines functionalities introduced in
previous sections.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title
let $in := $book/content/introduction
let $pin := $book/content/part/introduction
where $title contains text "usability" and $in contains text 
   "satisfaction" and $pin contains text "identify 
   problems"
return &lt;book number="{$book/@number}"&gt;{ 
    ($title, 
         if (count($book/metadata/author) &gt; 0)
         then ($book/metadata/author, $in, $pin)
         else ($book/metadata/publicationInfo/publisher, $in, $pin))
     }
       &lt;/book&gt; 
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class=
"found">Usability</span> Testing&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;  
   &lt;author&gt;Montana Marigold&lt;/author&gt;     
   &lt;introduction&gt;
      ...
      &lt;p&gt;The usability of a Web site is how well the 
      site supports the user in achieving specified 
      goals. A Web site should facilitate learning, 
      and enable efficient and effective task 
      completion, while propagating few 
      errors. <span class=
"found">Satisfaction</span> with the site is also important. 
      The user must not only be well-served, but must 
      feel well-served.&lt;/p&gt;
      ...
  &lt;/introduction&gt;
  &lt;introduction&gt;
      &lt;p&gt;Expert reviewers <span class=
"found">identify problems</span> and recommend changes 
      to web sites based on research in human computer interaction 
      and their experience in the field.&lt;/p&gt;
      ...
  &lt;/introduction&gt; 
&lt;/book&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="XQuery-XPath-Composability" id=
"XQuery-XPath-Composability"></a>16 Use Case
"XQUERY-XPATH-COMPOSABILITY": Queries Illustrating Composability of
Full-Text with Other XQuery and XPath Functionalities</h2>
<div class="div2">
<h3><a name="xquery-xpath-composability-description" id=
"xquery-xpath-composability-description"></a>16.1 Description</h3>
<p>These queries combine full-text queries with other XQuery and
XPath functionalities.</p>
</div>
<div class="div2">
<h3><a name="xquery-xpath-composability-queries-results" id=
"xquery-xpath-composability-queries-results"></a>16.2 Queries and
Results</h3>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q1" id=
"xquery-xpath-composability-queries-results-q1"></a>16.2.1 Q1
Full-Text Query Constructing New Element</h4>
<p>For books with "usability" in the title create a flat list of
all title-author pairs, with each pair enclosed in a newly
constructed element.</p>
<p>This query finds a word in an element and returns the element
and another wrapped in a new element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, construction of new element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: result (constructed element), ./metadata/title,
./metadata/author</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book and building title-author pairs for those books returning
them wrapped in a newly constructed result element.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $var := $book/metadata/title
where $var contains text "usability"
return &lt;result&gt; 
          {$book/metadata/title, $book/metadata/author} 
           &lt;/result&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;result&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/result&gt;
   
&lt;result&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
&lt;/result&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q2" id=
"xquery-xpath-composability-queries-results-q2"></a>16.2.2 Q2
Full-Text Query Returning Count of Descendant Element
Occurrences</h4>
<p>Find all books with a chapter title on "usability tests". Return
book title, chapter title, and the number of steps in chapters.</p>
<p>This query finds words then returns among other elements a
constructed element reporting the number of occurrences of a
descendant element.</p>
<ul>
<li>
<p>Operands: "usability" "test"</p>
</li>
<li>
<p>Functionality: word queries, <code>and</code> query, stemming,
count, construction of new element, conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/part/chapter/title,
./content/part/chapter/p/step</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title,
./content/part/chapter/title, number-of-steps (constructed
element)</p>
</li>
<li>
<p>Comments: This query finds the word "usability" and stemmed
forms of the word "test" in the titles of book chapters. It returns
chapter titles along with an occurrence count of descendant
<code>step</code> elements. The query returns a number of steps
equal to 0 if the chapter is on usability testing but does not
specify any steps (e.g., there are not descendant <code>step</code>
elements).</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $ct := $book/content/part/chapter/title
where $ct contains text "usability" ftand "test" 
   using stemming
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title,
          for $title in $ct
          return 
             ($title, 
             &lt;number-of-steps&gt; 
                {count($title/..//step)}
             &lt;/number-of-steps&gt;)}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
 &lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span>
   <span class="found">Tests</span>&lt;/title&gt;
   &lt;number-of-steps&gt;7&lt;/number-of-steps&gt;
   &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q3" id=
"xquery-xpath-composability-queries-results-q3"></a>16.2.3 Q3
Full-Text Query with Conditional Return</h4>
<p>For each book with "usability" in the book title, return the
book title and a second element. Return the book title and a third
element if the second element does not exist.</p>
<p>This query finds a word and contains a conditional return.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, count, conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/publicationInfo/publisher</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book, then returns title-author pairs for those books when there
are <code>author</code> elements. If there are no
<code>author</code> elements, it returns <code>publisher</code>
elements.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/title contains text 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title,
             if (count($book/metadata//author) &gt; 0) 
             then $book/metadata//author 
             else $book/metadata//publisher}
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
   &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q4" id=
"xquery-xpath-composability-queries-results-q4"></a>16.2.4 Q4
Full-Text Query with Numeric Value Comparison</h4>
<p>For each book with "usability" in the book title, return its
book title and the round number of its suggested price if the price
exceeds $25.</p>
<p>This query finds a word and contains a conditional return based
on a function on a numeric value.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, round(), numeric value comparison,
conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./metadata/price</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/price</p>
</li>
<li>
<p>Comments: This query finds the word "usability" in the title of
a book, then returns the round number of its price if the price
exceeds a specified value.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[metadata/title contains text "usability"]
return &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,  
             if ($book/metadata/price &gt; 25)
             then &lt;price&gt;{concat("$", round($book/metadata/price))}&lt;/price&gt;
             else ()
           }   
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;price&gt;$26&lt;/price&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;price&gt;$174&lt;/price&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q5" id=
"xquery-xpath-composability-queries-results-q5"></a>16.2.5 Q5
Full-Text Query with Character String Query</h4>
<p>Find all introductions in books, published in "Washington,
D.C.", which include listings for "résumés", "drafts", and
"correspondence".</p>
<p>This query finds words and a character string.</p>
<ul>
<li>
<p>Operands: "résumés" "drafts" "correspondence" character string
"Washington, D.C."</p>
</li>
<li>
<p>Functionality: word query, with diacritics as written in the
query, <code>and</code> query, character string query</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content/introduction,
./metadata/publicationInfo/place</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./content//introduction</p>
</li>
<li>
<p>Comments: This query performs a full-text query when it needs to
find word variants in full text and performs a character string
query when word variants are not possible.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[.//publicationInfo/place/text() 
   = "Washington, D.C."]
let $intro := $book/content/introduction
where $intro contains text "résumés" using diacritics sensitive
   ftand "drafts" ftand "correspondence"
return &lt;book number="{$book/@number}"&gt; 
           {$book/metadata/title, $intro}
           &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of 
   His Papers&lt;/title&gt; 
   &lt;introduction&gt;
      &lt;p&gt;The papers of John Wesley Usabilityguy span the 
      years 1946-1999, with the bulk of the items
      concentrated in the period from 1985 to 1999. The 
      papers feature his career as a developer of software 
      applications and usability specialist. The collection 
      consists of <span class=
"found">correspondence</span>, memoranda, journals, 
      speeches, article <span class=
"found">drafts</span>, book drafts, notes, charts, 
      graphs, family papers, clippings, printed matter, 
      photographs, <span class=
"found">résumés</span> and other materials.&lt;/p&gt;
   &lt;/introduction&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q6" id=
"xquery-xpath-composability-queries-results-q6"></a>16.2.6 Q6
Full-Text Query with Conditional Return of Boolean Values</h4>
<p>For each book on "usability" return the book title and a new
<code>has-publishers</code> element with value <code>true</code> if
the book has more than 1 publisher. Return the title and a new
<code>has-publishers</code> element with value <code>false</code>
if the book does not have more than one publisher.</p>
<p>This query finds a word, then returns Boolean values based on
the number of occurrences of an element.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, construction of new Boolean values,
construction of new element, count, &gt;, conditional
expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, has-publishers (constructed
element)</p>
</li>
<li>
<p>Comments: This query finds "usability" in the title of a book,
then returns the title and Boolean values showing whether the book
has more than one publisher or not.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[metadata/title contains text 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title} 
          &lt;has-publishers&gt; 
             {if (count($book//publisher) &gt; 1) 
             then "true" else "false"}
          &lt;/has-publishers&gt;
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title&gt;Improving the <span class=
"found">Usability</span> of a Web Site Through 
   Expert Reviews and <span class=
"found">Usability</span> Testing&lt;/title&gt; 
   &lt;has-publishers&gt;false&lt;/has-publishers&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;<span class="found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;has-publishers&gt;true&lt;/has-publishers&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q7" id=
"xquery-xpath-composability-queries-results-q7"></a>16.2.7 Q7
Full-Text Query with Date Comparison and Element Occurrence
Count</h4>
<p>Find all books about conducting "usability tests" which have
more than one author and are published after "2000".</p>
<p>This query finds a phrase, counts the number of occurrences of
an element, runs a greater than comparison on dates, and combines
the results.</p>
<ul>
<li>
<p>Operands: "usability testing", "2000"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), count, &gt;</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/subjects/subject, ./metadata/author,
./metadata/publicationInfo/(dateIssued|dateRevised)</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author,
./metadata/subjects/subject</p>
</li>
<li>
<p>Comments: This is a full-text query on the phrase "usability
testing" using a wildcard on the word "test", restricted to the
<code>subject</code> element. The query counts the number of
<code>author</code> elements, and runs a greater than comparison on
dates.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/publicationInfo/
   (dateIssued|dateRevised) &gt; "2000-12-31" 
   and count(metadata/author) &gt; 1]
let $subj := $book//subject[
             . contains text "usability test.*" using wildcards]
where $subj
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book/metadata/author, $subj}
           &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
   &lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morty Marigold&lt;/author&gt;
   &lt;subject&gt;<span class=
"found">Usability testing</span>&lt;/subject&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q8" id=
"xquery-xpath-composability-queries-results-q8"></a>16.2.8 Q8 Query
with XPath Expression Within Full-Text Expression</h4>
<p>Find all books published after "2001" which share a subject with
the book with the short title "Usability Basics".</p>
<p>This query finds words using an XPath expression to identify the
words queried and looks for a publication date after the one
specified.</p>
<ul>
<li>
<p>Operands: "Usability Basics", "2001"</p>
</li>
<li>
<p>Functionality: phrase query, <code>and</code> query, date
comparisons, XPath expression to identify the words queried.</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title/@shortTitle,
./metadata/subjects/subject,
./metadata/publicationInfo/dateIssued|dateRevised</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, ./metadata/author</p>
</li>
<li>
<p>Comments: This query returns a book if its last date of
publication is after 2001 and one of its subjects is the same as a
subject of the book with the short title "Usability Basics". This
query uses an XPath expression to dynamically find the subjects of
books.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
let $books := doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $bookSubject := 
   $books/metadata[./title/@shortTitle 
   contains text "Usability Basics"]/subjects/subject
for $book in $books   
where $book/metadata/publicationInfo/
(dateIssued|dateRevised) &gt; 2001 and 
$book/metadata/subjects/subject contains text 
     {$bookSubject} any
return
        &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,
           $book/metadata/author}
        &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morley Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morty Marigold&lt;/author&gt; 
&lt;book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="xquery-xpath-composability-queries-results-q9" id=
"xquery-xpath-composability-queries-results-q9"></a>16.2.9 Q9 Query
Using an XQuery Expression to Determine the Number of Words Allowed
in a Window</h4>
<p>Find all books which discuss "successfully completing
tasks".</p>
<p>This query finds words within a window, allowing more words
within the window depending on the number of chapters in the
book.</p>
<ul>
<li>
<p>Operands: "successfully" "completing" "tasks"</p>
</li>
<li>
<p>Functionality: word query, stemming, unordered window of at most
(number of chapters in the book times 3) words</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query uses an XQuery expression to determine the
number of words in an unordered window. It allows more words in the
window when there are more chapters in the book. The query returns
"tasks which are critical for users to be able to complete
successfully" from Book 2, because there are three chapters in Book
2 which multiplied by four allows up to twelve words within the
window.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("successfully" 
   ftand "completing" ftand "tasks"
   window (count($cont/part/chapter) * 4) 
   words) using stemming
return ($book/metadata/title, $cont)
</pre></div>
<p><em>Solution in XPath</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("successfully" 
ftand "completing" ftand "tasks"
window (count(content/part/chapter) * 4) 
words) using stemming]/(metadata/title, content)
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then Conducting Usability
         Tests&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify <span class=
"found">tasks</span> which 
         are critical for users to be able to 
         <span class="found">complete</span><span class=
"found"> successfully</span>.&lt;/step&gt; 
         &lt;step number="3"&gt;Compile a script of questions or
         instructions which will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="Score" id="Score"></a>17 Use Case "SCORE": All Queries
May Be Written with Score, Queries in this Section Must Be Written
with Score</h2>
<div class="div2">
<h3><a name="score-description" id="score-description"></a>17.1
Description</h3>
<p>All the queries in these Use Cases may be written with or
without score. The Use Cases in this section are merely a small
subset that focuses on score.</p>
<p>These queries exploit score and can not be written as queries
with pure Boolean full-text predicates. Among these queries are a
query that computes and returns only scores, a query which returns
only results over a specified threshold, a query which filters by
score, a query which returns all the documents ordered, and a query
which uses weighting to impact scoring and sorting.</p>
<p>Scoring methodologies are not defined in this recommendation.
Scoring is implementation-defined.</p>
</div>
<div class="div2">
<h3><a name="score-queries-results" id=
"score-queries-results"></a>17.2 Queries and Results</h3>
<div class="div3">
<h4><a name="score-queries-results-q1" id=
"score-queries-results-q1"></a>17.2.1 Q1 Query Returning
Scores</h4>
<p>Find all books which mention "usability" in the title or the
text. Return book titles and scores.</p>
<p>This query performs a word query and returns scores, highest
scores first.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
returns score, construction of new element</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./metadata/title, ./content</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title, score (constructed
element)</p>
</li>
<li>
<p>Comments: This query is only possible as a scored query. Scores
are included between 0 and 1. The scoring methodology in this use
case is for illustrative purposes only. Scoring methodologies will
be implementation-defined. This query returns the same results as a
query with a pure Boolean full-text predicate. The difference is
that the results are scored and the results are returned displaying
the score and ranked by score.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
  /books/book
let score $s := ($book/metadata/title contains text 
   "usability" or $book/content contains text "usability") 
where $s &gt; 0  
order by $s descending 
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title}
          &lt;score&gt;{$s}&lt;/score&gt; 
       &lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt;
   &lt;score&gt;0.9&lt;/score&gt;
&lt;/book&gt;

&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
   &lt;score&gt;0.8&lt;/score&gt;
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;    
   &lt;score&gt;0.12&lt;/score&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q2" id=
"score-queries-results-q2"></a>17.2.2 Q2 Query Returning Results
with Top Scores</h4>
<p>Find the best two books on "usability".</p>
<p>This query performs a word query and returns only the results
with the two top scores.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
returns books with the top two scores, conditional expression</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title</p>
</li>
<li>
<p>Comments: This query returns results only for the two books with
the highest scores. This query is only possible as a scored query.
The scoring methodology in this use case is for illustrative
purposes only. Scoring methodologies will be
implementation-defined. This query returns the same results as a
query with a pure Boolean full-text predicate. The difference is
that the results are scored and through the introduction of a third
variable only the two results with the highest scores are
returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $result at $i in
     for $book score $s in 
        doc("http://bstore1.example.com/full-text.xml")
        /books/book[. contains text "usability"]
      order by $s ascending
      return $book
   where $i &lt;= 2
   return &lt;book number="{$result/@number}"&gt; 
      {$result/metadata/title}&lt;/book&gt;
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
   and <span class="found">Usability</span> Testing&lt;/title&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
   Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
   on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
   Web Site&lt;/title&gt; 
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q3" id=
"score-queries-results-q3"></a>17.2.3 Q3 Query Filtering on
Scores</h4>
<p>Find all books that focus on "usability".</p>
<p>This query performs a word query and filters on scores.</p>
<ul>
<li>
<p>Operands: "usability"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring,
filters on scores (accepts only those with score over 0.1)</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: ./@number, ./metadata/title</p>
</li>
<li>
<p>Comments: This query is only possible as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the same results as a query with a pure Boolean
full-text predicate. The difference is that the results are scored
and then filtered on the scores.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book score $s in 
   doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "usability"]
where $s &gt; 0.1
return $book/metadata/title
</pre></div>
<p><em>Solution in XPath:</em></p>
<div class="exampleInner">
<pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[(for $i score $s in .[. contains text "usability"]
return $s) &gt; 0.1]/metadata/title
</pre></div>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <span class=
"found">Usability</span> of a Web Site Through Expert Reviews 
and <span class="found">Usability</span> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<span class=
"found">Usability</span> 
Basics: How to Plan for and Conduct <span class=
"found">Usability</span> Tests 
on Web Site Thereby Improving the <span class=
"found">Usability</span> of Your 
Web Site&lt;/title&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q4" id=
"score-queries-results-q4"></a>17.2.4 Q4 Query Combining Score and
XML Structure with a Conditional Return</h4>
<p>Find all books with parts about "usability testing".</p>
<p>This query finds books which contain parts about usability
testing, returning entire books, but without <code>part</code>
elements identified as irrelevant via score.</p>
<ul>
<li>
<p>Operands: "usability testing"</p>
</li>
<li>
<p>Functionality: phrase query, character wildcard (suffix) (0 or
more), implementation-defined scoring, filters on scores (under
.05), conditional return</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .//part</p>
</li>
<li>
<p>Return: . without irrelevant .//part</p>
</li>
<li>
<p>Comments: This query is only meaningful as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the same results as a query with a pure Boolean
full-text predicate. The difference is that this query filters the
<code>part</code> elements. They are included or excluded from the
results depending on their score.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      local:filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part contains text "usability test.*" 
      using wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return local:filter($book, $irrelevantParts)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and <span class=
"found">usability testing</span> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<span class=
"found">Usability Testing</span>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <span class=
"found">usability</span> 
            <span class="found">testing</span>.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <span class=
"found">Usability</span> 
            <span class="found">Tests</span>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan <span class=
"found">usability</span>
            <span class=
"found">testing</span>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the <span class=
"found">usability testing</span>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <span class=
"found">Usability Tests</span>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;<span class=
"found">Usability</span> 
            <span class=
"found">testing</span> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q5" id=
"score-queries-results-q5"></a>17.2.5 Q5 Query Returning All Books
Ordered by Score</h4>
<p>Return all books, listing books with text on "software"
first.</p>
<p>This query performs a word query, returns all the documents in
the database, and orders them returning those with found word
first, those without last.</p>
<ul>
<li>
<p>Operands: "software"</p>
</li>
<li>
<p>Functionality: word query, implementation-defined scoring</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: .</p>
</li>
<li>
<p>Return: .</p>
</li>
<li>
<p>Comments: This query is only meaningful as a scored query. The
scoring methodology in this use case is for illustrative purposes
only. Scoring methodologies will be implementation-defined. This
query returns the more results than a parallel query with a pure
Boolean full-text predicate. In a parallel query with a pure
Boolean full-text predicate, the last result would have a Boolean
value of false and would not be returned. In this scored query the
last result receives a score and is returned.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let score $s := $book/content contains text "software"
order by $s descending
return $book
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;      
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...                                                                 
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and <span class=
"found">software</span> similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;   
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <span class=
"found">software</span> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;      
      ...
   &lt;content&gt;      
&lt;/book&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="score-queries-results-q6" id=
"score-queries-results-q6"></a>17.2.6 Q6 Query with Weight
Declaration</h4>
<p>Finds books which discuss "conducting usability tests" returning
those which mention "measuring success" first.</p>
<p>This query finds words using weighting on optional words to
impact the scoring and sorting.</p>
<ul>
<li>
<p>Operands: "conduct" "usability" "tests" "measuring"
"success"</p>
</li>
<li>
<p>Functionality: word queries, stemming, unordered distance (0 to
10 intervening words between "conduct" and "usability" and between
"usability" and "tests"), unordered distance (0 to 4 intervening
words between "measuring" and "success"), weight declaration</p>
</li>
<li>
<p>Data context:
doc("http://bstore1.example.com/full-text.xml")/books/book</p>
</li>
<li>
<p>Query context: ./content</p>
</li>
<li>
<p>Return: ./metadata/title, ./content</p>
</li>
<li>
<p>Comments: This query returns books on "conducting usability
tests", using a weight declaration to return books with mentions of
"measuring success" higher in the sort.</p>
</li>
</ul>
<p><em>Solution in XQuery:</em></p>
<div class="exampleInner">
<pre>
for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $booktext := $book/content [. contains text ("conduct"
   ftand "usability" ftand "tests" distance at most
   10 words) using stemming]
let score $s := $booktext contains text
   (("measuring" ftand "success" distance
   at most 4 words) weight {1.8}) using stemming  
where $booktext
order by $s descending
return ($book/metadata/title, $booktext)
</pre></div>
<p><em>Solution in XPath: None</em></p>
<p><em>Expected Result:</em></p>
<div class="exampleInner">
<pre>
&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Usability Testing&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by <span class=
"found">conducting usability</span> 
         <span class="found">testing</span>.&lt;/p&gt;
         &lt;p&gt;Users are asked to complete tasks which 
         <span class="found">measure</span> the <span class=
"found">success</span> of the information 
         architecture and navigational elements of the 
         site.&lt;/p&gt;
         &lt;p&gt;Then changes are made to improve service to 
         users.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;

&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      <span class=
"found">conducting usability tests</span> on Web sites. Usability 
      testing should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      &lt;p&gt;This book has not been approved by the Web Site 
      Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then <span class=
"found">Conducting Usability</span> 
         <span class="found">Tests</span>&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;<span class=
"found">Conducting Usability Tests</span>&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
         workstation &lt;footnote&gt;They may be more 
         comfortable at their own workstation than in 
         a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two testers, &lt;footnote&gt;Usability 
         testing can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. Testers should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      ...
   &lt;/part&gt;
&lt;/content&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="Acknowledgements" id="Acknowledgements"></a>A
Acknowledgements</h2>
<p>The editors thank the members of the Full Text Task Force of the
XML Query and XSL Working Groups, which produced the material in
this document. Special thanks to Stephen Buxton for contributing
the first version of the schema.</p>
<p>The editors thank the following staff at the Library of Congress
for providing and improving sample data and queries: Ardith
Bausenbach, Caroline Arms, Marla Banks, Susan David, Ray Denenberg,
Louis Drummond, Bohdan Kantor, Mary A. Lacy, Joe Pagano, Betsy
Reifsnyder, Belinda D. Urquiza, and Anne Washington.</p>
<p>Thanks also to Bohdan Kantor, Foster Zhang, François Yergeau,
and Michel Biezunski for assistance in translating the subjects in
the sample data into Chinese and French.</p>
<p>The editors also wish to thank the members of the W3C
Internationalization Working Group for their assistance.</p>
</div>
<div class="div1">
<h2><a name="References" id="References"></a>B References
(Non-Normative)</h2>
<div class="div2">
<h3><a name="primary" id="primary"></a>B.1 References
(Primary)</h3>
<p>The following references are some of the works considered by the
Working Groups in deriving its use cases.</p>
<dl>
<dt class="label"><span><a name="xpath-functions" id=
"xpath-functions"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-functions/"><cite>XQuery
1.0 and XPath 2.0 Functions and Operators (Second
Edition)</cite></a>, Ashok Malhotra, Jim Melton, and Norman Walsh,
Editors. World Wide Web Consortium, 14 December 2010. This version
is http://www.w3.org/TR/2010/REC-xpath-functions-20101214/. The
<a href="http://www.w3.org/TR/xpath-functions/">latest version</a>
is available at http://www.w3.org/TR/xpath-functions/.</div>
</dd>
<dt class="label"><span><a name="xml-infoset" id=
"xml-infoset"></a>XML Information Set (Second Edition)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-infoset/"><cite>XML
Information Set (Second Edition)</cite></a>, Richard Tobin and John
Cowan, Editors. World Wide Web Consortium, 04&#160;Feb&#160;2004.
This version is
http://www.w3.org/TR/2004/REC-xml-infoset-20040204/. The <a href=
"http://www.w3.org/TR/xml-infoset/">latest version</a> is available
at http://www.w3.org/TR/xml-infoset/.</div>
</dd>
<dt class="label"><span><a name="Maier98" id=
"Maier98"></a>Maier98</span></dt>
<dd>
<div><em><a href=
"http://www.w3.org/TandS/QL/QL98/pp/maier.html">Database Desiderata
for an XML Query Language</a>,</em> David Maier, 1998. In Query
Languages 98 (QL'98). This paper is at
http://www.w3.org/TandS/QL/QL98/pp/maier.html.</div>
</dd>
<dt class="label"><span><a name="xml" id="xml"></a>Extensible
Markup Language (XML) 1.0 (Fifth Edition)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml/"><cite>Extensible Markup
Language (XML) 1.0 (Fifth Edition)</cite></a>, Tim Bray, François
Yergeau, Jean Paoli, <em>et. al.</em>, Editors. World Wide Web
Consortium, 26&#160;Nov&#160;2008. This version is
http://www.w3.org/TR/2008/REC-xml-20081126/. The <a href=
"http://www.w3.org/TR/xml/">latest version</a> is available at
http://www.w3.org/TR/xml/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-0" id=
"xmlschema-0"></a>XML Schema Part 0: Primer Second
Edition</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-0/"><cite>XML Schema
Part 0: Primer Second Edition</cite></a>, Priscilla Walmsley and
David C. Fallside, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-0/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-0/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-1" id=
"xmlschema-1"></a>XML Schema Part 1: Structures Second
Edition</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema
Part 1: Structures Second Edition</cite></a>, David Beech, Henry S.
Thompson, Murray Maloney, and Noah Mendelsohn, Editors. World Wide
Web Consortium, 28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-2" id=
"xmlschema-2"></a>XML Schema Part 2: Datatypes Second
Edition</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a>, Ashok Malhotra and
Paul V. Biron, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-2/.</div>
</dd>
<dt class="label"><span><a name="xquery" id="xquery"></a>XQuery
1.0: An XML Query Language (Second Edition)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery/"><cite>XQuery 1.0: An
XML Query Language (Second Edition)</cite></a>, Don Chamberlin,
Anders Berglund, Scott Boag, <em>et. al.</em>, Editors. World Wide
Web Consortium, 14 December 2010. This version is
http://www.w3.org/TR/2010/REC-xquery-20101214/. The <a href=
"http://www.w3.org/TR/xquery/">latest version</a> is available at
http://www.w3.org/TR/xquery/.</div>
</dd>
<dt class="label"><span><a name="xquery-use-cases" id=
"xquery-use-cases"></a>XML Query Use Cases</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-use-cases/"><cite>XML
Query Use Cases</cite></a>, Jonathan Robie, Don Chamberlin, Peter
Fankhauser, <em>et. al.</em>, Editors. World Wide Web Consortium,
23 March 2007. This version is
http://www.w3.org/TR/2007/NOTE-xquery-use-cases-20070323/. The
<a href="http://www.w3.org/TR/xquery-use-cases/">latest version</a>
is available at http://www.w3.org/TR/xquery-use-cases/.</div>
</dd>
<dt class="label"><span><a name="xpath-full-text-10-requirements"
id="xpath-full-text-10-requirements"></a>XQuery and XPath Full Text
1.0 Requirements</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-full-text-10-requirements/"><cite>XQuery
and XPath Full Text 1.0 Requirements</cite></a>, Stephen Buxton,
Pat Case, and Michael Rys, Editors. World Wide Web Consortium,
25&#160;January&#160;2011. This version is
http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-requirements-20110125/.
The <a href=
"http://www.w3.org/TR/xpath-full-text-10-requirements/">latest
version</a> is available at
http://www.w3.org/TR/xpath-full-text-10-requirements/.</div>
</dd>
<dt class="label"><span><a name="xpath-full-text-10" id=
"xpath-full-text-10"></a>XQuery and XPath Full Text 1.0</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-full-text-10/"><cite>XQuery and XPath
Full Text 1.0</cite></a>, Pat Case, Mary Holstege, Michael Dyck,
<em>et. al.</em>, Editors. World Wide Web Consortium, 25 January
2011. This version is
http://www.w3.org/TR/2011/PR-xpath-full-text-10-20110125/. The
<a href="http://www.w3.org/TR/xpath-full-text-10/">latest
version</a> is available at
http://www.w3.org/TR/xpath-full-text-10/.</div>
</dd>
<dt class="label"><span><a name="xpath20" id="xpath20"></a>XML Path
Language (XPath) 2.0 (Second Edition)</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath20/"><cite>XML Path
Language (XPath) 2.0 (Second Edition)</cite></a>, Don Chamberlin,
Anders Berglund, Scott Boag, <em>et. al.</em>, Editors. World Wide
Web Consortium, 14 December 2010. This version is
http://www.w3.org/TR/2010/REC-xpath20-20101214/. The <a href=
"http://www.w3.org/TR/xpath20/">latest version</a> is available at
http://www.w3.org/TR/xpath20/.</div>
</dd>
<dt class="label"><span><a name="xslt20" id="xslt20"></a>XSL
Transformations (XSLT) Version 2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt20/"><cite>XSL
Transformations (XSLT) Version 2.0 (Second Edition)</cite></a>,
Michael Kay, Editor. World Wide Web Consortium, 23 January 2007.
This version is http://www.w3.org/TR/2007/REC-xslt20-20070123/. The
<a href="http://www.w3.org/TR/xslt20/">latest version</a> is
available at http://www.w3.org/TR/xslt20/.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="background" id="background"></a>B.2 References
(Background)</h3>
<dl>
<dt class="label"><span><a name="BYR99" id=
"BYR99"></a>BYR99</span></dt>
<dd>
<div><em>Modern Information Retrieval,</em> R.Baeza-Yates, B.
Ribeiro-Neto. Addison Wesley, 1999.</div>
</dd>
<dt class="label"><span><a name="FGR01" id=
"FGR01"></a>FGR01</span></dt>
<dd>
<div><em>XIRQL: An Extension of XQL for Information Retrieval,</em>
N. Fuhr, K. Grossjohann. Proceedings of SIGIR, 2001.</div>
</dd>
<dt class="label"><span><a name="HTK00" id=
"HTK00"></a>HTK00</span></dt>
<dd>
<div><em>Searching Text-Rich XML Documents with Relevance
Ranking,</em> Y. Hayashi, J. Tomita, G. Kikui. Proceedings of SIGIR
Workshop on XML and Information Retrieval, 2000.</div>
</dd>
<dt class="label"><span><a name="MJK98" id=
"MJK98"></a>MJK98</span></dt>
<dd>
<div><em>A Flexible Model for Retrieval of SGML Documents,</em> S.
Myaeng, D.-H. Jang, M.-S. Kim, Z.-C. Zhoo. Proceedings of SIGIR,
1998.</div>
</dd>
<dt class="label"><span><a name="SCH01" id=
"SCH01"></a>SCH01</span></dt>
<dd>
<div><em>Similarity Search in XML Data Using Cost-Based Query
Transformations,</em> T. Schlieder. Proceedings of SIGMOD WebDB
Workshop, 2001.</div>
</dd>
<dt class="label"><span><a name="TWE00" id=
"TWE00"></a>TWE00</span></dt>
<dd>
<div><em>Adding Relevance to XML,</em> A. Theobald and G. Weikum.
Proceedings of SIGMOD WebDB Workshop, 2000.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="ChangeLog" id="ChangeLog"></a>C Change Log
(Non-Normative)</h2>
<table border="0" summary="Change Log Table">
<tbody>
<tr>
<td>Pat Case</td>
<td>2008-07-10</td>
<td>Corrected 2.2.7 Q7 Entire Element Content Query</td>
<td>Added "with wildcards" to the XQuery and XPath solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-10</td>
<td>Corrected 4.2.1 Q1 Query on Attribute</td>
<td>Moved "with stemming" to after "improve" and added parentheses
around ("improve" with stemming ftand "web" ftand "usability") to
make the distance operator applicable to all 3 operands in the
XQuery and XPath solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-10</td>
<td>Corrected 5.2.1 Q1 One Character Suffix Wildcard Query</td>
<td>Capitalized the "S" in "Solution in XQuery".</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-10</td>
<td>Corrected 16.2.9 Q9 Query Using an XQuery Expression to
Determine the Number of Words Allowed in a Window</td>
<td>Changed the 2nd "for" to "let" in the XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-10</td>
<td>Corrected 17.2.4 Q4 Query Combining Score and XML Structure
with a Conditional Return</td>
<td>Added the "local" prefix to 2 filter functional calls in the
XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-14</td>
<td>Corrected 13.2.2 Q2 Query on Element Returning Its First Two
Children</td>
<td>Corrected the let statement to read: let $para :=
$book//chapter/p[. ftcontains "usability" ftand "test" with
stemming] in the XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-14</td>
<td>Corrected 13.2.4 Q4 Query on Element and Its Right
Siblings</td>
<td>Changed the expected results to title and chapters.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-14</td>
<td>Corrected 16.2.4 Q4 Full-Text Query with Numeric Value
Comparison</td>
<td>Removed duplicate books/book from the for clause in the XQuery
solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-14</td>
<td>Corrected 15.2.4 Q4 Window Query with Wildcards and Stemming
Ignoring Content of a Descendant Element</td>
<td>Removed count($au) &gt; 0 from and corrected window size to 0
in XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-14</td>
<td>Corrected 16.2.9 Q9 Query Using an XQuery Expression to
Determine the Number of Words Allowed in a Window</td>
<td>Changed the for statement to a let statement in the XQuery
solution. Also changed the ./contents/part/chapter paths in both
the XQuery and XPath solutions to eliminate the incorrect contents
(should be content) element.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-16</td>
<td>Corrected 11.2.2 Q2 Query in Any Instance of an Element
(Existential Quantification)</td>
<td>Corrected use of $s1 and $s2 variables in the XQuery and XPath
solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-16</td>
<td>Corrected 13.2.3 Q3 Query on Element and Its Ancestors</td>
<td>Camel-cased element names and corrected the paths defining the
variables in the XQuery and XPath solutions. Added a 2nd count
clause in the XQuery solution. Corrected the Query Context.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-16</td>
<td>Corrected 16.2.7 Q7 Full-Text Query with Date Comparison and
Element Occurrence Count</td>
<td>Added Book 3 to the expected results. Corrected the 2nd
author's first name in Book 1 expected results.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-07-17</td>
<td>Corrected 5.2.5 Q5 Specified Range of Characters Suffix
Wildcard Query</td>
<td>Removed a stray angle bracket from expected results.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-5</td>
<td>Corrected 5.2.3, 5.2.4, 5.2.5, and 6.2.2.</td>
<td>Corrected return statements and expected results in 5.2.3,
5.2.4, 5.2.5, and 6.2.2.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-11</td>
<td>Recorrected 4.2.1 Q1 Query on Attribute</td>
<td>Removed newly added parentheses around ("improve" with stemming
ftand "web" ftand "usability"), trying to use only significant
parentheses in the solutions.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-11</td>
<td>Corrected 3.2.6 Q6 Query on Entire Document</td>
<td>Corrected XQuery and XPath solutions to return all the book
elements if the word was found in any one of them.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-19</td>
<td>Removed count &gt; 0 from most use cases.</td>
<td>Removed count &gt; 0 from XQuery and XPath (if any) solutions
for use cases where it is no longer needed.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-19</td>
<td>Corrected 5.2.3, 5.2.4, 5.2.5, and 6.2.2 again.</td>
<td>Removed the fn: prefix from return statements in XQuery and
XPath solutions for use cases 5.2.3, 5.2.4, 5.2.5, and 6.2.2.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-19</td>
<td>Removed or moved parentheses.</td>
<td>Removed or moved parentheses.to reflect changes in processing
order for operators and match options in XQuery and XPath (if any)
solutions for use cases 4.2.1, 10.2.6, 10.2.7, 11.2.3, 12.2.3,
12.2.4, 14.2.1, 14.2.3, 15.2.2, 15.2.4, 16.2.2, 16.2.5, 16.2.7,
17.2.6</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-19</td>
<td>Simplified queries by using a union in XPath statements.</td>
<td>Used union in XPath statements in XQuery and XPath solutions
for use cases 2.2.4, 3.2.5, and 14.2.4.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-19</td>
<td>Changed text in Comments.</td>
<td>Changed the word "returns" to "finds" when it was more
appropriate in Comments.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-20</td>
<td>Removed / in $book//content.</td>
<td>In XQuery solutions replaced $book//content with the simpler
and more direct $book/content.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-08-20</td>
<td>Removed .// when unnecessary.</td>
<td>In XQuery and XPath solutions, replaced /books/book[.//content
... ] with /books/book[content ... ].</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-10-31</td>
<td>Corrected 3.2.5 Q5 Query in Different Sub-Trees.</td>
<td>Removed a stray "i" in 3.2.5 Q5 Query in Different
Sub-Trees.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-05</td>
<td>Corrected 9.2.1 Q1 Diacritics Sensitive Query and 9.2.2 Q2
Diacritics Insensitive Query</td>
<td>Added ? wildcard indicators after the period indicator in the
XQuery and XPath queries.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-10</td>
<td>5.2.3 Q3 Zero or More Character Infix Wildcard Query and 5.2.4
Q4 One or More Character Suffix Wildcard Query on Part of a
Word</td>
<td>Added second parentheses at the end of the XQuery return
statements for these queries.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>14.2.2 Q2 Phrase Query Ignoring Content of Descendant Element
Specified by XPath Expression</td>
<td>Removed extraneous ] from XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>14.2.4 Q4 Distance Query Ignoring Content of Descendant
Elements Level by Level</td>
<td>Added missing ) in XPath solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>16.2.9 Q9 Query Using an XQuery Expression to Determine the
Number of Words Allowed in a Window</td>
<td>Removed extraneous ) after with stemming in XPath
solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>12.2.5 Q5 Unordered Within a Paragraph Query</td>
<td>Added comment allowing no expected results.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>13.2.1 Q1 Query on Element and Its Children</td>
<td>Corrected expected results to include all p elements in Book
2.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>16.2.7 Q7 Full-Text Query with Date Comparison and Element
Occurrence Count</td>
<td>Corrected query to return existing results.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>15.2.2 Q2 Phrase and Distance Query in an Instance of an
Element with Stemming</td>
<td>Added parentheses before ftand.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2008-11-29</td>
<td>15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring
Content of a Descendant Element</td>
<td>Highlighted "comments"in expected results.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-01-15</td>
<td>17.2.2 Q2 Query Returning Results with Top Scores</td>
<td>Corrected syntax in query return statement adding {}s.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-01-15</td>
<td>13.2.4 Q4 Query on Element and Its Right Siblings</td>
<td>Corrected expected results to include all paragraphs.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-01-15</td>
<td>17.2.2 Q2 Query Returning Results with Top Scores</td>
<td>Corrected sort order to ascending.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-03-28</td>
<td>6.2.1 Q1 Query Stemming on Word Root</td>
<td>Removed highlighting on testers.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-03-28</td>
<td>6.2.2 Q2 Query Stemming on Multiple Word Roots</td>
<td>Changed the operand usable to usability and the operand use to
users.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-03-28</td>
<td>15.2.2 Q2 Phrase and Distance Query in an Instance of an
Element with Stemming</td>
<td>Changed the operand performance to performing and the operand
review to reviewer.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-03-28</td>
<td>15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and
Thesaurus Support</td>
<td>Changed the operand iterations to iterating.</td>
</tr>
<tr>
<td>Michael Dyck</td>
<td>2009-04-15</td>
<td>15.2.2 Q2 Phrase and Distance Query in an Instance of an
Element with Stemming</td>
<td>Fix typo: missing right-bracket</td>
</tr>
<tr>
<td>Michael Dyck</td>
<td>2009-04-15</td>
<td>15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and
Thesaurus Support</td>
<td>Fix syntax error: missing parens. Also, malformed wildcard
syntax.</td>
</tr>
<tr>
<td>Michael Dyck</td>
<td>2009-04-15</td>
<td>16.2.7 Q7 Full-Text Query with Date Comparison and Element
Occurrence Count</td>
<td>Fix syntax error: malformed WhereClause.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-04-16</td>
<td>15.2.5 Q5 Query on Different Elements in Different Sub-Trees
with Conditional Return</td>
<td>Corrected the return statement.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-04-16</td>
<td>16.2.9 Q9 Query Using an XQuery Expression to Determine the
Number of Words Allowed in a Window</td>
<td>Corrected query to return the desired result. Updated the
Comments to address the revised query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-05-20</td>
<td>17.2.6 Q6 Query with Weight Declaration</td>
<td>Moved a closing paren from after to before the weight
expression. Added 2nd set of parens.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-06-09</td>
<td>15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and
Thesaurus Support</td>
<td>Inserted comment noting that results depended on whether the
wildcard or thesaurus match option was processed first.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-09-11</td>
<td>Changed syntax for Match Options</td>
<td>Changed "language" to "using language", changed "with
wildcards" to "using wildcards", changed "with thesaurus at" to
"using thesaurus at", changed "with stemming" to "using stemming",
changed "with stop words" to "using stop words", changed "without
stop words" to "using no stop words", changed "case insensitive" to
"using case insensitive", changed "uppercase" to "using uppercase",
changed "diacritics sensitive" to "using diacritics sensitive",
changed "diacritics insensitive" to "using diacritics
insensitive".</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-09-22</td>
<td>Changed ftcontains to contains text</td>
<td>Changed ftcontains to contains text throughout the
document.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-10-13</td>
<td>9.2.4 Q4 Query on Word with Upper Case and Lower Case
Characters</td>
<td>Changed "case insensitive" to "using case insensitive" in the
XPath query.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-10-13</td>
<td>14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element
Specified by Full-Text Query</td>
<td>Corrected the XQuery query to match the test suite.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-11-10</td>
<td>Introduction Item 3</td>
<td>Corrected the the spelling of wildcard.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>2009-11-22</td>
<td>17.2.6 Query with weight declaration</td>
<td>Added curly braces around the weight.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>12-09-2009</td>
<td>14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element
Specified by Full-Text Query</td>
<td>Changed the path in the for clause in the XQuery and XPath
solutions to provide context for the ignore paths.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-12-2010</td>
<td>14.2.1 Q1 Distance Query Ignoring Content of All Descendant
Elements</td>
<td>Added a predicate to the let clause and got rid of unused
variable in the XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-12-2010</td>
<td>14.2.4 Q4 Distance Query Ignoring Content of Descendant
Elements Level by Level</td>
<td>Replaced the XQuery solution and added /. to the XPath
solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-12-2010</td>
<td>15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring
Content of a Descendant Element</td>
<td>Replaced the "." in the ignore path with the $co variable to
provide context, added parens around the ftor expressions, changed
the ftnot expression to use the XQuery not, restored the expected
result to Book 2.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-12-2010</td>
<td>17.2.6 Q6 Query with Weight Declaration</td>
<td>Added predicate to first let clause to return elements instead
of a Boolean, specified descending, made weight greater than 1,
added where $booktext clause.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-20-2010</td>
<td>17.2.1 Q1 Query Returning Scores</td>
<td>Removed comma in the return statement..</td>
</tr>
<tr>
<td>Pat Case</td>
<td>01-20-2010</td>
<td>14.2.2 Q2 Phrase Query Ignoring Content of Descendant Element
Specified by XPath Expression</td>
<td>Added a predicate to the let clause and a where clause in the
XQuery solution. Replaced the XPath solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>03-18-2010</td>
<td>14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element
Specified by Full-Text Query</td>
<td>Added an asterisk to the wildcard match options in the XQuery
and XPath solutions. Specified the variable in the ignore option in
the XQuery solution.</td>
</tr>
<tr>
<td>Pat Case</td>
<td>12-29-2010</td>
<td>7.2.2 Q2 Query on Narrower Terms Identified by a Thesaurus</td>
<td>Changed the thesaurus relationship from "narrower terms" to
"narrower term" in both solutions.</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
