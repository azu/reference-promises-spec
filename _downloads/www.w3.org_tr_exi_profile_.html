<!-- http://www.w3.org/TR/exi-profile/ -->

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Efficient XML Interchange (EXI) Profile for limiting usage of dynamic memory</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note       { margin-left: 2em; }
div.notice     { margin-left: 2em; font-weight: bold; font-size: larger; color: red }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

  
   tr.silver td { color: silver; font-style: italic }

   tr.bold td { font-weight: bold }
   
   td.xml { background-color: black; color: white; font-weight: bold; font-size: 100% }
   .schema-less { background-color: silver; font-style: italic }
   .schema-informed { background-color: gray; }
   
   td.footnote { font-size: 75% }

</style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css"></head><body><div class="head"><p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a></p>
<h1><a name="title" id="title"></a>Efficient XML Interchange (EXI) Profile for limiting usage of dynamic memory</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation 09 September 2014</h2><dl><dt>This version:</dt><dd>
            <a href="http://www.w3.org/TR/2014/REC-exi-profile-20140909/">http://www.w3.org/TR/2014/REC-exi-profile-20140909/</a>
        </dd><dt>Latest version:</dt><dd>
            <a href="http://www.w3.org/TR/exi-profile/">http://www.w3.org/TR/exi-profile/</a>
        </dd><dt>Previous version:</dt><dd>
            <a href="http://www.w3.org/TR/2014/PR-exi-profile-20140506/">http://www.w3.org/TR/2014/PR-exi-profile-20140506/</a>
        </dd><dt>Editors:</dt><dd>Youenn Fablet, Canon Research Centre France</dd><dd>Daniel Peintner, Siemens AG</dd></dl><p>Please refer to the <a href="http://www.w3.org/XML/EXI/exi-profile-1-errata"><strong>errata</strong></a> for this document, which may
      include normative corrections.</p><p>See also <a href="http://www.w3.org/TR/2014/REC-exi-20140909/,translations"><strong>translations</strong></a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;&copy;&nbsp;2014&nbsp;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This document describes a set of parameters that can be used to define profiles of the
               EXI 1.0 format suited to applications involving devices with dynamic memory constraints.
            </p></div><div>
<h2><a name="status" id="status"></a>Status of this Document</h2><p>
                <em>This section describes the status of this document at the time of its
                    publication. Other documents may supersede this document. A list of current W3C
                    publications and the latest revision of this technical report can be found in
                    the W3C technical reports index at <a href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.</em>
            </p><p>This is the W3C Recommendation of the <em>Efficient XML Interchange (EXI) Profile for limiting usage of dynamic memory</em> specification. 
                It has been produced by the <a href="http://www.w3.org/XML/EXI/">Efficient XML Interchange Working Group</a> as part of the W3C <a href="http://www.w3.org/XML/Activity">XML Activity</a>.  
            </p><p>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p><p>The list of changes since Candidate Recommendation is exhibited in the <a href="#changes">Change Log</a>.
                A <a href="http://services.w3.org/htmldiff?doc1=http://www.w3.org/TR/2013/CR-exi-profile-20130416/&amp;doc2=http://www.w3.org/TR/2014/REC-exi-profile-20140909/">diff-marked version</a> against the CR version of this document is also available.</p><p> The EXI Working Group has produced a <a href="http://www.w3.org/XML/EXI/#InteropTestingFramework">test suite</a> and an <a href="http://www.w3.org/XML/EXI/implementation-report-profile/">implementation report</a>. </p><p>Please report errors in this document to the public mailing list <a href="mailto:public-exi-comments@w3.org">public-exi-comments@w3.org</a> 
                mailing list (<a href="http://lists.w3.org/Archives/Public/public-exi-comments/">Archives</a>).
                When preparing comments to send in, please provide a separate email message for each distinct issue to the extent possible.
                It is inappropriate to send discussion email to this address.
                </p><p>The goals of the Efficient XML Interchange (EXI) Format are discussed in the <a href="http://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0</a> document.
                The EXI Profile is intended for low-resource or "ultra-constrained" devices. Such devices lack run-time memory allocation capabilities or at best have extremely limited dynamic memory resources.
                The authors of this document are the members of the Efficient XML Interchange Working Group.</p><p> This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38502/status#specs">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>. </p><p>This document is governed by the <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">14 October 2005 W3C Process Document</a>. </p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1. <a href="#introduction">Introduction</a><br>
2. <a href="#outline">Outline</a><br>
3. <a href="#grammarCapping">Grammar Capping</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#grammarLearningDisablingMechanism">Grammar Learning Disabling Mechanism</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#grammarLearningDisablingParameters">Grammar Learning Disabling Parameters</a><br>
4. <a href="#valueTableCapping">Local Value Capping</a><br>
5. <a href="#headerIntegration">Parameters representation</a><br>
6. <a href="#conformance">Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="#streamConformance">EXI Profile Stream Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#processorConformance">EXI Profile Processor Conformance</a><br>
</p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#references">References</a><br>
B <a href="#guidelines">Guidelines</a> (Non-Normative)<br>
C <a href="#headerConsiderations">Header Considerations</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href="#d0e537">General Considerations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href="#d0e549">Implementation Strategies</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.3 <a href="#exi-p-element-validation-issue">Element exi:p integration</a><br>
D <a href="#prefixWorkArounds">Prefix Workarounds</a> (Non-Normative)<br>
E <a href="#nameTableWorkArounds">Name Table Workarounds</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;E.1 <a href="#encoderNameTableWorkArounds">Name Table Encoder Workarounds</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;E.2 <a href="#decoderNameTableWorkArounds">Name Table Decoder Workarounds</a><br>
F <a href="#grammarRestrictionConsiderations">Grammar Restriction Considerations</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;F.1 <a href="#encoderGrammarRestrictionConsiderations">Grammar Restriction Encoder Considerations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;F.2 <a href="#decoderGrammarRestrictionConsiderations">Grammar Restriction Decoder Considerations</a><br>
G <a href="#very-restricted-devices-notes">Workaround for Even More Restricted Devices</a> (Non-Normative)<br>
H <a href="#changes">Specification Changes </a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;H.1 <a href="#d0e690">Changes from Candidate Recommendation</a><br>
</p></div><hr><div class="body"><div class="div1">
<h2><a name="introduction" id="introduction"></a>1. Introduction</h2><p>Many device classes and use-cases desire to use EXI as its exchange format.
            Due to various restrictions, some of those application areas are not capable or
            allowed to require arbitrary memory growth at runtime. Though EXI provides a
            number of format options that help to constrain runtime memory usage, there
            are aspects of memory use that are left open-ended in EXI format, the consequence
            of which are deemed to be generally of less severity. However, each
            EXI application needs to confront the need to cope (or purposefully not to cope)
            with those loose ends in order for low-resource devices to participate in the
            application natively.</p><p>There is a known practice used by some applications to address this issue by
            requiring to send schema-valid EXI documents consisting only of schema-declared
            elements to low-resource devices thereby not incurring any dynamic mutation of
            EXI grammars (see <a href="#very-restricted-devices-notes"><b>G Workaround for Even More Restricted Devices</b></a>). 
            It is a valuable practice that is applicable
            to a wide set of use cases involving low-resource devices.</p><p>However, certain evaluations of EXI in the context of such areas exposed use cases
            with additional requirements that are not practically attainable by such a practice alone
            while honoring the limited threshold of each device's memory usage.</p><p>This EXI profile document specifies rules to ensure that the memory restrictions are respected while keeping compatibility with the EXI 1.0 specification.
			
			Section <a href="#grammarCapping"><b>3. Grammar Capping</b></a> defines the mechanisms and parameters defined to limit the grammar learning.
			
			Section <a href="#valueTableCapping"><b>4. Local Value Capping</b></a> defines the mechanisms to simplify value indexing.
			
			Section <a href="#headerIntegration"><b>5. Parameters representation</b></a> defines how the parameters defined in the profile can be represented as part of the EXI header.

            </p><p>
            To keep EXI 1.0 compatibility, the EXI profile does not provide a specific mechanism to bound the memory used for name tables.
            The working group discussed strategies and rules that allow EXI processors to overcome this issue.
            The appendix section (<a href="#prefixWorkArounds"><b>D Prefix Workarounds</b></a>, <a href="#nameTableWorkArounds"><b>E Name Table Workarounds</b></a>) describes 
            some of these implementation strategies and best practice rules.
			</p></div><div class="div1">
<h2><a name="outline" id="outline"></a>2. Outline</h2><p>
                The arbitrary memory growth at runtime when processing EXI streams is due to indexing QNames and string values for
                frequent use (string tables growth) and adapting the processing strategy to unknown input in case of
                schema-less encoding or deviations from the schema (built-in element grammar generation and evolution).
                The EXI Profile provides mechanisms to restrict the growth of the string tables and the grammar evolution 
                in order to predictably limit the memory growth at runtime. Limiting the size of the string table
                and the grammar evolution bounds the memory growth for encoding unknown input such as schema deviations
                but may lead to less compact EXI streams.
            </p><p>
                Some mechanisms to lower the memory usage are already available in the EXI 1.0 specification and should be
                considered in conjunction with the EXI profile (see <a href="#guidelines"><b>B Guidelines</b></a>). For example the EXI
                specification provides a mechanism to limit the memory growth due to global value string tables by
                using the <a href="http://www.w3.org/TR/exi/#key-valuePartitionCapacityOption">valuePartitionCapacity</a>.
                The local value string table can only be disabled if the global
                value string table is also disabled by setting the valuePartitionCapacity to 0. The mechanism described in
                Section <a href="#valueTableCapping"><b>4. Local Value Capping</b></a> allows for disabling the local
                value table even if valuePartitionCapacity is greater than 0.
            </p><p>
                According to the EXI 1.0 specification, an EXI processor creates a new built-in element grammar for
                each unknown element it encounters. The EXI profile limits the number of built-in element grammars
                created at runtime by using schema informed complex ur-type grammars instead. Each built-in element
                grammar that is allowed to be created by the EXI profile processor can further evolve by insertion
                of new productions and hence leads to memory growth during runtime. For that reason, the EXI profile
                defines a mechanism to limit the number of dynamically inserted grammar productions in the built-in
                element grammars if such are allowed during processing.
            </p><p>
                The disabling of the local value table, the number of built-in element grammars created at runtime
                and the number of dynamically inserted grammar productions are all controlled by a set of Profile
                parameters described in Section <a href="#headerIntegration"><b>5. Parameters representation</b></a>.
            </p></div><div class="div1">
<h2><a name="grammarCapping" id="grammarCapping"></a>3. Grammar Capping</h2><p>
				To disable grammar learning, the xsi:type attribute may be used to switch from an evolving built-in element grammar to a non evolving schema-informed grammar.
				In particular, the xsd:anyType complex type can be used to represent arbitrary XML elements.
			</p><p>
				Note that the EXI profile can only limit grammar learning for schema-informed EXI streams but not for schema-less EXI streams.
				In the case where no schema is available, the "schemaId" element may be set to the empty value, so that all grammars derived from the built-in XML Schema types 
				become available through xsi:type grammar switching, in particular the grammar corresponding to the xsd:anyType complex type.
			</p><p>
                Several prefixes are used throughout this document to designate certain namespaces. The bindings shown below are assumed, however, any prefixes can be used in practice if they are properly bound to the namespaces.</p><table border="1"><tbody><tr><th>Prefix</th><th>Namespace Name</th></tr><tr><td>exi</td><td>http://www.w3.org/2009/exi</td></tr><tr><td>xsd</td><td> http://www.w3.org/2001/XMLSchema</td></tr><tr><td>xsi</td><td>http://www.w3.org/2001/XMLSchema-instance</td></tr></tbody></table><div class="div2">
<h3><a name="grammarLearningDisablingMechanism" id="grammarLearningDisablingMechanism"></a>3.1 Grammar Learning Disabling Mechanism</h3><p>
					For a given element E, the disabling of grammar learning E is done by inserting an xsi:type attribute event with the xsd:anyType value after the SE event of the element E.
					Note that NS events may appear between the corresponding SE event and the inserted xsi:type attribute.
					If an element E already has an xsi:type attribute and grammar learning is disabled for the grammar representing the element E,
					the xsi:type attribute value MUST refer to a known schema-informed grammar that can represent the given element.
				</p><p>If grammar learning is disabled for an element E in the case of a new built-in element grammar G, the following rule happens:
				</p><ul><li><p>An xsi:type attribute event, if not already present, is inserted with the xsd:anyType value after the SE event representing this element.
						The xsi:type attribute event MUST always be represented by the AT(*) production whose event code length is 2.
						
						</p></li><li><p>
                           For all elements following the element E in the EXI stream, that have the same QName as the element E and are represented by a built-in element grammar, 
                           an xsi:type attribute event, if not already present, is inserted with the xsd:anyType value after the corresponding SE event.
                           The xsi:type attribute event MUST always be represented by the AT(*) production whose event code length is 2.
                           </p></li></ul><p>A new grammar G for an element E is expected to be instantiated at the time the production of the element E SE event is evaluated. 
				Even in the case where no production will be inserted in grammar G, implementations MUST behave as if grammar G is instantiated.</p><p>In a case where this first mechanism is not active and grammar learning must be disabled, a second mechanism is made possible as described below.
				As the cost of this second mechanism is generally higher than the first mechanism, this second mechanism SHOULD only be used if the first mechanism cannot be used.
				That said, implementations are free to use any of the two mechanisms and hence also need to be prepared to deal with the associated effects
				(e.g., diverse EXI events and event code lengths).
				</p><p>  
				If grammar learning is disabled in the case of a production insertion in a given grammar, named G, the following rule happens:
					</p><ul><li><p>All events to be encoded that can be represented by top-level productions already inserted in the grammar G are represented by the corresponding top-level productions.
						    </p></li><li><p>All events of the given element E that remain to be represented are represented using productions whose event code length is 2.
							Note that in such a case, the EXI processor must ensure to increment the productions event code according the rules defined in section 8.4.3 of the EXI 1.0 specification
							but does not need to create and insert the top-level productions.
							In particular, the EXI processor may need to keep track whether a CH production is already inserted or not in the grammar G to keep the number of top-level productions consistent
							with the rules defined in section 8.4.3 of the EXI 1.0 specification.
							</p></li><li><p>
							For all elements following this element E in the EXI stream and represented by the grammar G, 
							an xsi:type attribute event MAY be inserted with the xsd:anyType value directly after the corresponding SE event.
							The xsi:type attribute event MUST always be represented by the AT(*) production whose event code length is 2.
							</p></li></ul><p>Once production insertion is disabled for a given grammar, 
				the grammar use is restricted so that only the productions already inserted and 
				the number of top level productions needs to be stored for that grammar.
				
				It should be noted that even if production insertion is disabled for a given grammar, 
				the productions inserted before production insertion is disabled for that grammar
				may be used throughout the whole document.
				
				Additional information, in particular with regards to implementation strategy,
				technical reasoning 
				and impact 
				is available in the appendix section <a href="#grammarRestrictionConsiderations"><b>F Grammar Restriction Considerations</b></a>.
				</p></div><div class="div2">
<h3><a name="grammarLearningDisablingParameters" id="grammarLearningDisablingParameters"></a>3.2 Grammar Learning Disabling Parameters</h3><p>
                To limit increasing memory consumption due to grammar learning, the EXI profile enables to limit the number of evolving built-in grammars and 
                the number of inserted productions. Two parameters are defined for that purpose:
                </p><p>
                    [<a name="maximumNumberOfBuiltInElementGrammars" id="maximumNumberOfBuiltInElementGrammars" title="maximumNumberOfBuiltInElementGrammars">Definition</a>:  
                        
                        The
                        <b>maximumNumberOfBuiltInElementGrammars</b> parameter is 
                         the maximum number of QNames for which built-in element grammars can be dynamically instantiated.
                    ]
                </p><p>
                    [<a name="maximumNumberOfBuiltInProductions" id="maximumNumberOfBuiltInProductions" title="maximumNumberOfBuiltInProductions">Definition</a>: 
                        
                        The
                            <b>maximumNumberOfBuiltInProductions</b> parameter is the maximum
                        number of top-level productions that can be dynamically inserted in built-in element grammars.
                        
                        ]
                    
                </p><p>Grammar learning is disabled for an element E for which a new built-in element grammar G must be created if  the following condition is true:
                </p><ul><li><p>The number of instantiated built-in element grammars 
                         is equal or greater than the <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> value.</p></li></ul><p>Grammar learning is disabled in the case of a production insertion if the following condition is true:
                </p><ul><li><p>The sum of the number of dynamically inserted top level productions of all
                            built-in element grammars is equal or greater than the
                                <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> value.
                         </p></li></ul><p> Note that only the productions of the first <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> instantiated grammars are counted, the sum of which being compared with 
                 the <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> value.
                 In particular, the AT(xsi:type) productions that would be inserted in grammars that would be instantiated after the <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> threshold are not counted.
                 This allows production insertion to happen even though no new grammar can be instantiated.
                </p><p>Note also that when the <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> value is reached,
                it may often be more compact to insert an AT(xsi:type) event with a xsd:anyType value on all elements for which a new built-in element grammar must be created.  
                </p><p>
                Whenever the parameters are set, the rules above MUST be properly applied.
                The parameters may be left unspecified in the case of an application that wants to define a finer-grained control on the application of the grammar learning disabling mechanism.
                In such a case, the EXI processor will not set the two parameters defined and should use an out-of-band mechanism to convey the precise grammar disabling strategy in use.
                It may for instance be beneficial to apply grammar learning for elements that occur frequently and that are regular while disabling grammar learning for elements that occur rarely.
                
                </p></div></div><div class="div1">
<h2><a name="valueTableCapping" id="valueTableCapping"></a>4. Local Value Capping</h2><p>
			Some classes of EXI processors may not afford the cost of building local value table representations.
			This profile defines a parameter that can disable the use of local value references.
			Global value indexing may be controlled using the options defined in the EXI 1.0 specification.
			</p><p>
				[<a name="localValuePartitions" id="localValuePartitions" title="localValuePartitions">Definition</a>:  The
					<b>localValuePartitions</b> parameter is a Boolean used to indicate whether
					local value partitions are used. ] The value "0" indicates that no local
				value partition is used while "1" represents the behavior of the EXI 1.0 specification.
			</p><p>When the value <a title="localValuePartitions" href="#localValuePartitions">localValuePartitions</a> is set to "0", 
			it is an error to represent a string value as a reference to an entry of a local value partition.</p><p>
		    Some processors may decide to have fine grained strategy on the local value tables building and usage.  
		    For instance, some processors may decide to use local value references based on the QName of the element.
		    In such a case, the <a title="localValuePartitions" href="#localValuePartitions">localValuePartitions</a> should not be set to any value and
		    the fine-grained strategy should be exchanged by an out-of-band mechanism.
                
		    </p></div><div class="div1">
<h2><a name="headerIntegration" id="headerIntegration"></a>5. Parameters representation</h2><p>
				The use of the EXI profile is advertised by encoding an exi:p XML element in the user-defined meta-data section of the EXI options of an EXI stream (see example below).                
                The content of the exi:p element indicates the value of the three parameters of the profile, encoded using a single decimal value.
				Each profile parameter is represented as follows:</p><ol class="enumar"><li><p>The <a title="localValuePartitions" href="#localValuePartitions">localValuePartitions</a> parameter is encoded as the sign of the decimal value:
						the parameter is equal to  0 if the decimal value is positive and 1 if the decimal value is negative.
						</p></li><li><p>The <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> parameter
							is represented by the first unsigned integer corresponding to integral portion of the decimal value: 
							the <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> parameter
							is unbounded if the unsigned integer value is 0; otherwise it is equal to the unsigned integer value - 1.</p></li><li><p>The <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> parameter
                            is represented by the second unsigned integer corresponding to the fractional portion in reverse order of the decimal value: 
                            the <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> parameter
                            is unbounded if the unsigned integer value is 0; otherwise it is equal to the unsigned integer value - 1.</p></li></ol><p>
	                An exi:p element is always represented using   the following lists of EXI events in a  EXI header option element:
	            </p><ul><li><p>A SE(exi:p) event, followed by an AT(xsi:type)="xsd:decimal" event, followed by a CH event, followed by an EE event (exi:p element with parameter values)</p></li></ul><p>Find below an example EXI options document with the most restrictive EXI profile parameters settings (all three parameters, namely <a title="localValuePartitions" href="#localValuePartitions">localValuePartitions</a>,
		        <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a>, and 
		     <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> are set to 0 (zero)).
		    </p><div class="exampleOuter">
<div class="exampleHeader"><a name="profileOptionsDocument" id="profileOptionsDocument"></a><i><span>Example 5-1. </span>EXI Profile document for most restrictive parameters settings</i></div><div class="exampleInner"><pre>&lt;exi:header xmlns:exi="http://www.w3.org/2009/exi" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;exi:lesscommon&gt;
        &lt;exi:uncommon&gt;
            &lt;exi:p xsi:type="xsd:decimal"&gt;
                1.1
            &lt;/exi:p&gt;
        &lt;/exi:uncommon&gt;
    &lt;/exi:lesscommon&gt;
&lt;/exi:header&gt;</pre></div></div><p>
		        Inserting an exi:p element within the metadata section is invalid according 
		        the EXI Options Document XML Schema defined in <a href="http://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0</a>.
		        Nonetheless, EXI processors are able to represent such an exi:p element.
		        As described in <a href="#exi-p-element-validation-issue"><b>C.3 Element exi:p integration</b></a>, losing schema validity was deemed acceptable 
		        given the desire to achieve a compact representation of EXI options elements.  
		    </p></div><div class="div1">
<h2><a name="conformance" id="conformance"></a>6. Conformance</h2><div class="div2">
<h3><a name="streamConformance" id="streamConformance"></a>6.1 EXI Profile Stream Conformance</h3><p>[<a name="conformantEXIProfileStream" id="conformantEXIProfileStream" title="conformant EXI profile stream">Definition</a>:  
                    
                    A <b>conformant EXI profile stream</b> consists of a sequence of octets that follows the
                    syntax of a conformant EXI stream that is defined in the document 
                    <a href="http://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0</a> and also
                    follows the additional rules defined in this document according to EXI profile parameters. 
                ] By definition a conformant EXI profile stream constitute also a conformant EXI stream.</p></div><div class="div2">
<h3><a name="processorConformance" id="processorConformance"></a>6.2 EXI Profile Processor Conformance</h3><p>The conformance of EXI Processors is defined separately for each of the two processor roles, 
                   EXI profile stream encoders and EXI profile stream decoders.
                   
                   The conformance of EXI profile stream encoders is
                   described in terms of the conformance of the EXI profile streams that they produce.
                   
                   The conformance of EXI profile stream decoders 
                   is based on the set of supported format features for processing conformant EXI profile streams.</p><p>[<a name="exiParameterSet" id="exiParameterSet" title="EXI parameter set">Definition</a>: 
                    The term <b>EXI parameter set</b> consists of specific values or range of values for
                    <a href="http://www.w3.org/TR/exi/#options"><cite>EXI options</cite></a> and EXI profile parameters.]
                    
                    An EXI parameter set constraints the EXI options and EXI profile parameters used to encode the body of the EXI stream.
                    An EXI parameter set can be defined for both, EXI profile stream encoders and EXI profile stream decoders.
                    
                    
                    
                </p><p>An EXI profile stream encoder is a <b>fully conforming EXI profile stream encoder</b> if and only if
                    it is capable of generating conformant EXI profile streams using <em>any</em> EXI parameter set,
                    given any input structured data it is made to work on.
                                        
                    On the other hand, a <b>fully conforming EXI profile stream decoder</b> MUST support
                    <em>any</em> EXI parameter set.
                    
                    A <b>partially conforming EXI profile stream encoder</b> and/or 
                    a <b>partially conforming EXI profile stream decoder</b>, in turn, MUST support at least <em>one</em> 
                    EXI parameter set.
                    
                    In practice, standard organizations and/or other communities
                    may specify and also label their appropriate EXI parameter set.
                </p><p>
                </p></div></div></div><div class="back"><div class="div1">
<h2><a name="references" id="references"></a>A References</h2><dl><dt class="label"><a name="exiSpec" id="exiSpec"></a>Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</dt><dd>
                    <a href="http://www.w3.org/TR/2014/REC-exi-20140211/"><cite>Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</cite></a>, John Schneider,
                    Takuki Kamiya, Daniel Peintner, Rumen Kyusakov,  Editors. World Wide Web Consortium. The latest version is
                    available at <a href="http://www.w3.org/TR/exi/">
                        http://www.w3.org/TR/exi/</a>.   (See http://www.w3.org/TR/2014/REC-exi-20140211/.)</dd></dl></div><div class="div1">
<h2><a name="guidelines" id="guidelines"></a>B Guidelines (Non-Normative)</h2><p>
                This document specifies means to ensure memory restrictions for various use-cases.
                Doing so guarantees support for a broad range of application fields.
                However, it is advised to use the most restrictive parameters settings when the
                recipients capabilities are not known.
            </p><p>The suggested profile parameter settings for unknown recipients are:</p><ol class="enumar"><li><p>Set <a title="maximumNumberOfBuiltInElementGrammars" href="#maximumNumberOfBuiltInElementGrammars">maximumNumberOfBuiltInElementGrammars</a> to 0 (zero).</p></li><li><p>Set <a title="maximumNumberOfBuiltInProductions" href="#maximumNumberOfBuiltInProductions">maximumNumberOfBuiltInProductions</a> to 0 (zero).</p></li><li><p>Set <a title="localValuePartitions" href="#localValuePartitions">localValuePartitions</a> to 0 (zero).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The localValuePartitions parameter does not have any effect
                        if either <a href="http://www.w3.org/TR/exi/#key-valueMaxLengthOption">valueMaxLength</a> 
                        and/or <a href="http://www.w3.org/TR/exi/#key-valuePartitionCapacityOption">valuePartitionCapacity</a> is set to 0 (zero).</p></div></li></ol><p>In regard to restricted device classes it may be sensible to also investigate into the right EXI1.0 options such as:</p><ol class="enumar"><li><p><a href="http://www.w3.org/TR/exi/#key-strictOption">strict</a></p></li><li><p><a href="http://www.w3.org/TR/exi/#key-preserveOption">preserve</a></p></li><li><p><a href="http://www.w3.org/TR/exi/#key-valueMaxLengthOption">valueMaxLength</a>
                    and <a href="http://www.w3.org/TR/exi/#key-valuePartitionCapacityOption">valuePartitionCapacity</a></p></li><li><p><a href="http://www.w3.org/TR/exi/#key-blockSizeOption">blockSize</a></p></li></ol><p>Note that if the recipients capabilities are known, these known capabilities should be used to 
                offer the best possible compression and processing performance.
            </p></div><div class="div1">
<h2><a name="headerConsiderations" id="headerConsiderations"></a>C Header Considerations (Non-Normative)</h2><div class="div2">
<h3><a name="d0e537" id="d0e537"></a>C.1 General Considerations</h3><p>
                    The processing of the EXI header may require memory allocation to handle grammar learning and value partition.
                    It is advised that the processing of the EXI header does not go over the memory requirements used for the EXI body processing.
                    In particular: </p><ol class="enumar"><li><p>Built-in grammar learning should be kept to a minimum, optimally not requiring the storage of an element grammar besides the scope of this element.</p></li><li><p>String partitions should not be needed to correctly parse the corresponding header.</p></li></ol></div><div class="div2">
<h3><a name="d0e549" id="d0e549"></a>C.2 Implementation Strategies</h3><p>Depending on the use-case various strategies are feasible to properly parse the EXI Options of the header. Note that a full EXI Options parser is not needed nor sensible in any case.
                </p><p>
                    For device classes that support only one (or a restricted set) set of EXI options it may be possible to follow the approach of bit matching. Bit matching means that the received header could be compared to a known option set that is supported. If the expected &#8220;bits&#8221; match the decoder is able to process the EXI body. If the bits don&#8217;t match the stream is encoded with unsupported options.
                </p><p>
                    A more sophisticated approach is to realize a partial EXI Options grammar parser. Let&#8217;s assume an EXI processor supporting profile parameters or strict encodings. One way to implement a partial parser could be as follows:
                </p><div class="exampleOuter">
<div class="exampleHeader"><a name="d0e558" id="d0e558"></a><i><span>Example C-1. </span>Partial EXI Options Parser</i></div><div class="exampleInner"><pre>
/* Pseudo Code */
int nbit = readNBit(1);
if( nbit != 0 ) {
    /* SE(*) in root element */
    return false;
}
/* header */
nbit = readNBit(2);
switch( nbit ) {
case 0:
    /* lessCommon */
    nbit = readNBit(2);
    /* 0: uncommon */
    /* 1: preserve */
    /* 2: blockSize  */
    /* 3: EE */
    If ( nbit == 0 ) {
        /* lessCommon */
        nbit = readNBit(3);
        /* 0: alignment */ 
        /* 1: selfContained */
        /* 2: valueMaxLength */
        /* ... */
        /* 5: any, e.g, profile */ 
        if ( nbit == 5 ) {
            /* userDefinedMetaData */
            /* uri hit for "http://www.w3.org/2009/exi": 5 in 3 bits */
            /* local-name miss for "p": 2 in 1 Byte and 112 in 1 Byte */
            /* ... */
        }
    } else {
        /* not supported */
        return false;
    }
    break;
case 1:
    /* common */
    return false;
case 2:
    /* strict, set EXI processor accordingly */
    break;
case 3:
    /* EE, EXI options finished */
    break;
default:
    /* invalid */
    return false;
}  
                    </pre></div></div><p>
                Depending on the application one of the presented approaches may be feasible. Moreover, other strategies or also a mix between strategies may be sensible.
            </p></div><div class="div2">
<h3><a name="exi-p-element-validation-issue" id="exi-p-element-validation-issue"></a>C.3 Element exi:p integration</h3><p>
                    Inserting an exi:p element as part of the user-defined metadata section of a EXI options element is invalid according to 
                    the XML Schema for EXI Options Document defined in <a href="http://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0</a>.
                    The exi:p element is matched against a ##other wildcard according the XML schema for EXI Options Document.
                    While the intent of the metadata section is to allow any possible content, 
                    the target namespace of the related wildcard cannot be '##any' due to XML schema specific rules.
                </p><p>
                    Using the EXI namespace to qualify the exi:p element is useful for several reasons:
                </p><ul><li><p>The namespace is already populated by every EXI processor which can parse EXI Options documents.</p></li><li><p>The namespace is reserved for the purpose of EXI applications.</p></li><li><p>The EXI format treats ##other wildcards as ##any wildcards.</p></li></ul><p>
                    These potential benefits, in particular the compactness of the exi:p element, are believed to outweight the exi:p element validation issue. 
                </p></div></div><div class="div1">
<h2><a name="prefixWorkArounds" id="prefixWorkArounds"></a>D Prefix Workarounds (Non-Normative)</h2><p>
                It is advised for users that want to preserve prefixes while capping memory requirements to properly set their namespace declarations so that:
                </p><ol class="enumar"><li><p>QName prefixes are encoded as 0 bit</p></li><li><p>Prefixes in NS events are always encoded literally</p></li></ol><p>
                In those conditions, an EXI processor does not need to build the prefix indexing tables.
                In addition, application layers that provide APIs such as SAX or StAX, often store namespace mapping information.
                In that case, prefixes can be unambiguously retrieved from their associated namespace URI from the application layer.
            </p></div><div class="div1">
<h2><a name="nameTableWorkArounds" id="nameTableWorkArounds"></a>E Name Table Workarounds (Non-Normative)</h2><p>Name tables cannot be restricted without breaking the compatibility with the EXI 1.0 specification.
			This section describes how an implementation may circumvent this issue by bringing the knowledge of the application to the EXI processor.
			</p><div class="div2">
<h3><a name="encoderNameTableWorkArounds" id="encoderNameTableWorkArounds"></a>E.1 Name Table Encoder Workarounds</h3><p>
				The application may declare to the EXI encoder all the QNames it is aware of.
				Amongst several possible optimizations, this allows the EXI encoder to pre-allocate statically the memory used to store all the possible QNames, 
				be they pre-populated using schema knowledge or not.
				In addition the string representation of these QNames may also be shared between the application and the EXI processor.
				</p><p>
				If all the QNames used by the application are declared to the EXI encoder,
				no name table entry will be dynamically inserted and no additional memory allocation may be needed for the name tables.
				
				The EXI encoder will assign indexes dynamically for names that are not pre-populated by the schema knowledge to keep the compatibility with the EXI 1.0 specification.
				It will also need to keep track of the number of entries that are indexed to compute the binary representation size of entry indexes.
				</p></div><div class="div2">
<h3><a name="decoderNameTableWorkArounds" id="decoderNameTableWorkArounds"></a>E.2 Name Table Decoder Workarounds</h3><p>
				The application may declare to the EXI decoder all the QNames it is interested in.
				This allows the EXI decoder to pre-allocate the memory used to store these QNames, be they pre-populated using schema knowledge or not.
				In addition the string representation of these QNames may also be shared between the application and the EXI processor.
				</p><p>
				When a litterally encoded URI or local name string happens in an EXI stream,
				the	EXI decoder may check whether it is of interest to the application.
				If so, the EXI processor will be able to assign dynamically to that string an index without allocating any new memory to store this name table entry.
				</p><p>
				When a URI or local name string happens in an EXI stream that was NOT declared of interest by the application, 
				the EXI processor may have a behavior specified by the application: adding it to the name tables as defined in the EXI 1.0 specification if there is enough memory,
				incrementing the corresponding name table counter but not storing the string and skipping the corresponding event, raising an error...
				</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Under the circumstance that local value string entries are not disabled the EXI processor needs
			        to store the number of local value partition entries.
			    </p></div></div></div><div class="div1">
<h2><a name="grammarRestrictionConsiderations" id="grammarRestrictionConsiderations"></a>F Grammar Restriction Considerations (Non-Normative)</h2><div class="div2">
<h3><a name="encoderGrammarRestrictionConsiderations" id="encoderGrammarRestrictionConsiderations"></a>F.1 Grammar Restriction Encoder Considerations</h3><p>
				For a given QName, EXI encoders will generally need to retain some information related to the state of the corresponding built-in element grammar.
				In particular, it may need to know the following information for each QName that has no associated schema-informed grammar:
				</p><ul><li><p>The number of top level productions of the grammar associated to that QName</p></li><li><p>Whether a xsi:type attribute must be inserted after an SE event of that QName</p></li><li><p>Whether an xsi:type event was already encoded using the grammar of that QName</p></li></ul><p>Note that in the case of no grammar learning at all, this information may be stored as a boolean, 
				representing whether that QName was already encoded as part of a SE event.
				</p><p>In the case of built-in element grammars for which one or more productions were inserted before the grammar learning is disabled 
                and for which a production should have been inserted after the grammar learning is disabled for a given element E,
                encoders must use second level productions to encode all remaining events of that given element E that cannot be represented using already inserted productions.

                It should be noted that every AT(*) or SE(*) second level production encoded will cause EXI decoders that are unaware of the EXI profile to insert a production in the corresponding grammar. 
                The production insertion number will grow with the number of attributes or start element events that cannot be represented using already inserted productions. 
                This number may be arbitrarly large.
                Encoders need to take that into account when encoding documents so that not-EXI profile decoders can still properly decode the documents.
                For instance, encoders may decide to use xsi:type based grammar switching to limit the size of such a grammar.
                </p></div><div class="div2">
<h3><a name="decoderGrammarRestrictionConsiderations" id="decoderGrammarRestrictionConsiderations"></a>F.2 Grammar Restriction Decoder Considerations</h3><p>
				Once grammar learning is disabled, the EXI decoder will not need to create any new built-in element grammar.
				For any such grammar, the EXI decoder can directly deduce the corresponding grammar state from the EXI stream
				given that the xsi:type attribute is always represented by the AT(*) production whose event code length is 2:
                </p><p>In bit-packed mode:</p><ul><li><p>If the first bit after the SE event of a QName is set to 0,
                    the corresponding grammar is a new built-in element grammar with no top-level production at all.</p></li><li><p>If the first bit after the SE event of a QName is set to 1,
                    the corresponding grammar is a built-in element grammar with one top level production, AT(xsi:type).</p></li></ul><p>In byte-aligned mode:</p><ul><li><p>The first byte after the SE event of a QName must be equal to 1.</p></li><li><p>If the second byte after the SE event is 1, the corresponding grammar is a built-in element grammar with one top level production, AT(xsi:type).</p></li><li><p>Otherwise, the second byte after the SE event is equal to 3 and the corresponding grammar is a new built-in element grammar with no top-level production at all.</p></li></ul><p>
				The second part of the encoded production is equal to 1 to refer to a AT(*) production. 
				When prefix preservation is on, the second part of the encoded production may be equal to 2 
				to refer to NS productions that may appear between SE and AT(xsi:type) events.
				</p><p>
				In the case of built-in element grammars for which one or more productions were inserted before the grammar learning is disabled
				and for which a production should have been inserted after the grammar learning is disabled,
				the EXI decoder may only need to store the number of top-level productions of this grammar in addition to the already inserted productions.
				It will also need to check whether the top-level productions already include a AT(xsi:type) production.
				The first part of the encoded production must be equal to the number of top-level productions.
				The second part of the encoded production must be equal to 1, so as to refer to a AT(*) production.
				</p><p>
				It is thought as good practice for an EXI profile decoder to strip from the infoset any xsi:type attribute with the xsd:anyType value that corresponds to the grammar learning disabling mechanism.
				</p></div></div><div class="div1">
<h2><a name="very-restricted-devices-notes" id="very-restricted-devices-notes"></a>G Workaround for Even More Restricted Devices (Non-Normative)</h2><p>
			In the case of very restricted devices, it is important to evaluate how useful data sent to these devices is.
			The fact that data can be decoded by these devices (using the EXI profile or not) 
			does not mean that these devices can actually process it.
			For example, a very simple thermostat may receive "temperature setpoint" data encoded
			using a standardized schema. Sending additional data (for example, weather forecast information) 
			encoded with or without a dedicated schema does not help the thermostat.
			It is good practice to refrain from sending to these devices data not defined in the schema.
			This leads to better use of resources (bandwidth and memory) and simpler implementations.
            </p><p>
			Such very restricted devices may collocate within a system
			with fully conformant EXI devices or EXI profile conformant devices. 
			A first option is to use schema-informed strict mode for the very
			restricted devices and schema-informed default mode with profile for the other devices.
			A second option is to use the schema-informed default mode for both sets of devices. 
			This reduces the overall complexity and lowers hardware requirements such as ROM/flash sizes.
			To cope with very restricted devices constraints, it may be prohibited to send data not defined 
			in the schema: this removes the need for these devices to support built-in grammars at all.
			</p></div><div class="div1">
<h2><a name="changes" id="changes"></a>H Specification Changes  (Non-Normative)</h2><div class="div2">
<h3><a name="d0e690" id="d0e690"></a>H.1 Changes from Candidate Recommendation</h3><ul><li><p>The parameter <a href="http://www.w3.org/TR/2013/CR-exi-profile-20130416/#emptyPelement">empty exi:p element</a> that has been considered to be at risk has been entirely removed.
                        An empty exi:p element was a syntactic shortcut to a particular exi:p element with a value equal to +1.1.
                    </p></li><li><p>Clarified that a built-in element grammar is said to be instantiated even if no production is actually inserted in it.</p></li><li><p>Clarified that, even though the insertion of a exi:p element within a EXI options element is schema invalid as per EXI header options schema, it can be represented in EXI strict mode and was found implementation-wise.</p></li><li><p>Updated the appendix F.2 to cope with NS events that may appear between SE and AT(xsi:type) events.</p></li></ul></div></div></div></body></html>
