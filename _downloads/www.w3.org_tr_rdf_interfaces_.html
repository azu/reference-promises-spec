<!-- http://www.w3.org/TR/rdf-interfaces/ -->
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML+RDFa 1.1//EN' 'http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd'>
<html dir="ltr" about="" property="dcterms:language" content="en" xmlns="http://www.w3.org/1999/xhtml" prefix='bibo: http://purl.org/ontology/bibo/'>
<head>
<title>RDF Interfaces</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />

<!--  
    === NOTA BENE ===
    For the three scripts below, if your spec resides on dev.w3 you can check them
    out in the same tree and use relative links so that they'll work offline,
     -->



<style type="text/css">
/*
    XXX this is not up to date with the needs of various other parts, it will require
        to be synched up with the latest developments
        It may be that this will be split up so that only the parts that are acually used
        by the document get to be included (e.g. WebIDL).
*/

/*****************************************************************
 * ReSpec 2 CSS
 * Robin Berjon, 2010-01-04
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}


/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID {
    font-weight:    bold;
    color:  #005a9c;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType {
    color:  #005a9c;
}
.idlAttrName {
    color:  #ff4500;
}
.idlAttrName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.attributes dd, .methods dd, .constants dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

/* --- EXAMPLES --- */
pre.example {
    border-top: 1px solid #ff4500;
    border-bottom: 1px solid #ff4500;
    padding:    1em;
    margin:     2em 0;
}

pre.example::before {
    content:    "Example";
    display:    block;
    width:      150px;
    background: #ff4500;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

/* --- EDITORIAL NOTES --- */
.issue {
    padding:    1em;
    border: 1px solid #f00;
    background: #ffc;
}

.issue::before {
    content:    "Issue";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #f00;
    background: #fff;
    padding:    3px 1em;
}

.note {
    padding:    1em;
    border: 2px solid #cff6d9;
    background: #e2fff0;
}

.note::before {
    content:    "Note";
    display:    block;
    width:  150px;
    margin: -1.5em 0 0.5em 0;
    font-weight:    bold;
    border: 1px solid #cff6d9;
    background: #fff;
    padding:    3px 1em;
}


/* --- SYNTAX HIGHLIGHTING --- */
/* Pretty printing styles. Used with prettify.js. */
.str { color: #080; }
.kwd { color: #008; }
.com { color: #800; }
.typ { color: #606; }
.lit { color: #066; }
.pun { color: #660; }
.pln { color: #000; }
.tag { color: #008; }
.atn { color: #606; }
.atv { color: #080; }
.dec { color: #606; }
/*pre.prettyprint { padding: 2px; border: 1px solid #888 }*/

/* Specify class=linenums on a pre to get line numbering */
ol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */
li.L0, li.L1, li.L2, li.L3, li.L5, li.L6, li.L7, li.L8 { list-style-type: none }
/* Alternate shading for lines */
li.L1, li.L3, li.L5, li.L7, li.L9 { background: #eee }

@media print {
  .str { color: #060; }
  .kwd { color: #006; font-weight: bold; }
  .com { color: #600; font-style: italic; }
  .typ { color: #404; font-weight: bold; }
  .lit { color: #044; }
  .pun { color: #440; }
  .pln { color: #000; }
  .tag { color: #006; font-weight: bold; }
  .atn { color: #404; }
  .atv { color: #060; }
}

/* --- OLD SYNTAX HIGHLIGHTING, REMOVE THIS WITH SHJS XXX --- */

pre.sh_sourceCode {
  background-color: white;
  color: black;
  font-style: normal;
  font-weight: normal;
}

pre.sh_sourceCode .sh_keyword { color: #005a9c; font-weight: bold; }           /* language keywords */
pre.sh_sourceCode .sh_type { color: #666; }                            /* basic types */
pre.sh_sourceCode .sh_usertype { color: teal; }                             /* user defined types */
pre.sh_sourceCode .sh_string { color: red; font-family: monospace; }        /* strings and chars */
pre.sh_sourceCode .sh_regexp { color: orange; font-family: monospace; }     /* regular expressions */
pre.sh_sourceCode .sh_specialchar { color: 	#ffc0cb; font-family: monospace; }  /* e.g., \n, \t, \\ */
pre.sh_sourceCode .sh_comment { color: #A52A2A; font-style: italic; }         /* comments */
pre.sh_sourceCode .sh_number { color: purple; }                             /* literal numbers */
pre.sh_sourceCode .sh_preproc { color: #00008B; font-weight: bold; }       /* e.g., #include, import */
pre.sh_sourceCode .sh_symbol { color: blue; }                            /* e.g., *, + */
pre.sh_sourceCode .sh_function { color: black; font-weight: bold; }         /* function calls and declarations */
pre.sh_sourceCode .sh_cbracket { color: red; }                              /* block brackets (e.g., {, }) */
pre.sh_sourceCode .sh_todo { font-weight: bold; background-color: #00FFFF; }   /* TODO and FIXME */

/* Predefined variables and functions (for instance glsl) */
pre.sh_sourceCode .sh_predef_var { color: #00008B; }
pre.sh_sourceCode .sh_predef_func { color: #00008B; font-weight: bold; }

/* for OOP */
pre.sh_sourceCode .sh_classname { color: teal; }

/* line numbers (not yet implemented) */
pre.sh_sourceCode .sh_linenum { display: none; }

/* Internet related */
pre.sh_sourceCode .sh_url { color: blue; text-decoration: underline; font-family: monospace; }

/* for ChangeLog and Log files */
pre.sh_sourceCode .sh_date { color: blue; font-weight: bold; }
pre.sh_sourceCode .sh_time, pre.sh_sourceCode .sh_file { color: #00008B; font-weight: bold; }
pre.sh_sourceCode .sh_ip, pre.sh_sourceCode .sh_name { color: #006400; }

/* for Prolog, Perl... */
pre.sh_sourceCode .sh_variable { color: #006400; }

/* for LaTeX */
pre.sh_sourceCode .sh_italics { color: #006400; font-style: italic; }
pre.sh_sourceCode .sh_bold { color: #006400; font-weight: bold; }
pre.sh_sourceCode .sh_underline { color: #006400; text-decoration: underline; }
pre.sh_sourceCode .sh_fixed { color: green; font-family: monospace; }
pre.sh_sourceCode .sh_argument { color: #006400; }
pre.sh_sourceCode .sh_optionalargument { color: purple; }
pre.sh_sourceCode .sh_math { color: orange; }
pre.sh_sourceCode .sh_bibtex { color: blue; }

/* for diffs */
pre.sh_sourceCode .sh_oldfile { color: orange; }
pre.sh_sourceCode .sh_newfile { color: #006400; }
pre.sh_sourceCode .sh_difflines { color: blue; }

/* for css */
pre.sh_sourceCode .sh_selector { color: purple; }
pre.sh_sourceCode .sh_property { color: blue; }
pre.sh_sourceCode .sh_value { color: #006400; font-style: italic; }

/* other */
pre.sh_sourceCode .sh_section { color: black; font-weight: bold; }
pre.sh_sourceCode .sh_paren { color: red; }
pre.sh_sourceCode .sh_attribute { color: #006400; }

</style><link href="http://www.w3.org/StyleSheets/TR/W3C-WG-NOTE" rel="stylesheet" type="text/css" charset="utf-8" /></head>
<body style="display: inherit; "><div class="head"><p><a href="http://www.w3.org/"><img width="72" height="48" src="http://www.w3.org/Icons/w3c_home" alt="W3C" /></a></p><h1 property="dcterms:title" class="title" id="title">RDF Interfaces</h1><h2 property="bibo:subtitle" id="subtitle">A set of basic primitives and a low-level API for working with RDF data</h2><h2 property="dcterms:issued" datatype="xsd:dateTime" content="2012-07-05T04:00:00+0000" id="w3c-note-05-july-2012"><acronym title="World Wide Web Consortium">W3C</acronym> Working Group Note 05 July 2012</h2><dl><dt>This version:</dt><dd><a href="http://www.w3.org/TR/2012/NOTE-rdf-interfaces-20120705/">http://www.w3.org/TR/2012/NOTE-rdf-interfaces-20120705/</a></dd><dt>Latest published version:</dt><dd><a href="http://www.w3.org/TR/rdf-interfaces/">http://www.w3.org/TR/rdf-interfaces/</a></dd><dt>Latest editor's draft:</dt><dd><a href="http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/">http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/</a></dd><dt>Previous version:</dt><dd><a rel="dcterms:replaces" href="http://www.w3.org/TR/2011/WD-rdf-interfaces-20110510/">http://www.w3.org/TR/2011/WD-rdf-interfaces-20110510/</a></dd><dt>Editors:</dt><dd rel="bibo:editor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Nathan Rixham" href="http://webr3.org/">Nathan Rixham</a>, Invited Expert</span>
</dd>
<dd rel="bibo:editor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Manu Sporny" href="http://digitalbazaar.com/">Manu Sporny</a>, <a rel="foaf:workplaceHomepage" href="http://digitalbazaar.com/">Digital Bazaar, Inc.</a></span>
</dd>
<dd rel="bibo:editor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Benjamin Adrian" href="http://www.dfki.uni-kl.de/~adrian/">Benjamin Adrian</a>, <a rel="foaf:workplaceHomepage" href="http://www.dfki.de/">German Research Center for Artificial Intelligence GmbH</a></span>
</dd>
<dt>Authors:</dt><dd rel="dcterms:contributor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Nathan Rixham" href="http://webr3.org/">Nathan Rixham</a>, Invited Expert</span>
</dd>
<dd rel="dcterms:contributor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Manu Sporny" href="http://digitalbazaar.com/">Manu Sporny</a>, <a rel="foaf:workplaceHomepage" href="http://digitalbazaar.com/">Digital Bazaar, Inc.</a></span>
</dd>
<dd rel="dcterms:contributor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Mark Birbeck" href="http://markbirbeck.com/">Mark Birbeck</a>, <a rel="foaf:workplaceHomepage" href="http://markbirbeck.com/">Sidewinder Labs</a></span>
</dd>
<dd rel="dcterms:contributor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Ivan Herman" href="http://www.w3.org/">Ivan Herman</a>, <a rel="foaf:workplaceHomepage" href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a></span>
</dd>
<dd rel="dcterms:contributor"><span typeof="foaf:Person"><a rel="foaf:homepage" property="foaf:name" content="Benjamin Adrian" href="http://www.dfki.uni-kl.de/~adrian/">Benjamin Adrian</a>, <a rel="foaf:workplaceHomepage" href="http://www.dfki.de/">German Research Center for Artificial Intelligence GmbH</a></span>
</dd>
</dl><p class="copyright"><a rel="license" href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2011-2012 <span rel="dcterms:publisher"><span typeof="foaf:Organization"><a rel="foaf:homepage" property="foaf:name" content="World Wide Web Consortium" href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup></span></span> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. <acronym title="World Wide Web Consortium">W3C</acronym> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr /></div>
<div id="abstract" class="introductory section" property="dcterms:abstract" datatype="" typeof="bibo:Chapter" about="#abstract"><h2>Abstract</h2>

  <p class="note">
This document is not finished. Due to the lack of time, the RDF Web Applications Working Group was unable to complete work on this document before
the end of their charter. At the time of publication of this
document, it was not known whether <acronym title="World Wide Web Consortium">W3C</acronym> will continue this work on the
Recommendation track in another Working Group. 
While a significant amount of design work went into this document, at present there are no known implementations of the specification. A number of design issues have not been completely resolved. Developers wishing to implement this API should be aware of incomplete nature of the specification.
  </p>

  <p>
  The RDF Interfaces Specification defines a set of standardized interfaces for working with RDF data in
  a programming environment. This specification outlines three distinct sets of interfaces:</p>
  <ul>
    <li>RDF Concept Interfaces, which represent the various RDF Concepts</li>
    <li>RDF Environment Interfaces, which provide the basic methods required to work with RDF data.</li>
    <li>RDF Data Interfaces, which are a set of modular interfaces covering common areas of functionality.</li>
  </ul>
</div><div id="sotd" class="introductory section" typeof="bibo:Chapter" about="#sotd"><h2>Status of This Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> technical reports index</a> at http://www.w3.org/TR/.</em></p>
<p>This document was published by the <a href="http://www.w3.org/2010/02/rdfa/">RDF Web Applications Working Group</a> as a Note. I
f you wish to make comments regarding this document, please send them to <a href="mailto:public-rdfa@w3.org">public-rdfa@w3.org</a> (<a href="mailto:public-rdfa-request@w3.org?subject=subscribe">subscribe</a>, <a href="http://lists.w3.org/Archives/Public/public-rdfa/">archives</a>). All feedback is welcome.</p><p>Publication as a Working Group Note does not imply endorsement by the <acronym title="World Wide Web Consortium">W3C</acronym> Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</p><p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>. <acronym title="World Wide Web Consortium">W3C</acronym> maintains a <a href="http://www.w3.org/2004/01/pp-impl/44350/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.</p></div><div id="toc" typeof="bibo:Chapter" about="#toc" class="section"><h2 class="introductory">Table of Contents</h2><ul class="toc"><li class="tocline"><a href="#introduction" class="tocxref"><span class="secno">1. </span>Introduction</a><ul class="toc"><li class="tocline"><a href="#conformance" class="tocxref"><span class="secno">1.1 </span>Conformance</a></li></ul></li><li class="tocline"><a href="#rdf-concept-interfaces" class="tocxref"><span class="secno">2. </span>RDF Concept Interfaces</a><ul class="toc"><li class="tocline"><a href="#overview" class="tocxref"><span class="secno">2.1 </span>Overview</a></li><li class="tocline"><a href="#data-structures" class="tocxref"><span class="secno">2.2 </span>Data Structures</a><ul class="toc"><li class="tocline"><a href="#triples" class="tocxref"><span class="secno">2.2.1 </span>Triples</a></li><li class="tocline"><a href="#graphs" class="tocxref"><span class="secno">2.2.2 </span>Graphs</a></li></ul></li><li class="tocline"><a href="#basic-node-types" class="tocxref"><span class="secno">2.3 </span>Basic Node Types</a><ul class="toc"><li class="tocline"><a href="#nodes" class="tocxref"><span class="secno">2.3.1 </span>Nodes</a></li><li class="tocline"><a href="#named-nodes" class="tocxref"><span class="secno">2.3.2 </span>Named Nodes</a></li><li class="tocline"><a href="#blank-nodes" class="tocxref"><span class="secno">2.3.3 </span>Blank Nodes</a></li><li class="tocline"><a href="#literals" class="tocxref"><span class="secno">2.3.4 </span>Literals</a></li></ul></li><li class="tocline"><a href="#additional-interfaces" class="tocxref"><span class="secno">2.4 </span>Additional Interfaces</a><ul class="toc"><li class="tocline"><a href="#triple-filters" class="tocxref"><span class="secno">2.4.1 </span>Triple Filters</a></li><li class="tocline"><a href="#triple-callbacks" class="tocxref"><span class="secno">2.4.2 </span>Triple Callbacks</a></li><li class="tocline"><a href="#triple-actions" class="tocxref"><span class="secno">2.4.3 </span>Triple Actions</a></li></ul></li></ul></li><li class="tocline"><a href="#rdf-environment-interfaces" class="tocxref"><span class="secno">3. </span>RDF Environment Interfaces</a><ul class="toc"><li class="tocline"><a href="#overview-1" class="tocxref"><span class="secno">3.1 </span>Overview</a></li><li class="tocline"><a href="#terms--prefixes-and-profiles" class="tocxref"><span class="secno">3.2 </span>Terms, Prefixes and Profiles</a><ul class="toc"><li class="tocline"><a href="#prefix-maps" class="tocxref"><span class="secno">3.2.1 </span>Prefix Maps</a></li><li class="tocline"><a href="#term-maps" class="tocxref"><span class="secno">3.2.2 </span>Term Maps</a></li><li class="tocline"><a href="#profiles" class="tocxref"><span class="secno">3.2.3 </span>Profiles</a></li></ul></li><li class="tocline"><a href="#high-level-api" class="tocxref"><span class="secno">3.3 </span>High level API</a><ul class="toc"><li class="tocline"><a href="#rdf-environment" class="tocxref"><span class="secno">3.3.1 </span>RDF Environment</a></li></ul></li></ul></li><li class="tocline"><a href="#rdf-data-interfaces" class="tocxref"><span class="secno">4. </span>RDF Data Interfaces</a><ul class="toc"><li class="tocline"><a href="#overview-2" class="tocxref"><span class="secno">4.1 </span>Overview</a></li><li class="tocline"><a href="#parsing-and-serializing-data" class="tocxref"><span class="secno">4.2 </span>Parsing and Serializing Data</a><ul class="toc"><li class="tocline"><a href="#data-parsers" class="tocxref"><span class="secno">4.2.1 </span>Data Parsers</a></li><li class="tocline"><a href="#data-serializers" class="tocxref"><span class="secno">4.2.2 </span>Data Serializers</a></li><li class="tocline"><a href="#additional-interfaces-1" class="tocxref"><span class="secno">4.2.3 </span>Additional Interfaces</a></li></ul></li></ul></li><li class="tocline"><a href="#acknowledgements" class="tocxref"><span class="secno">A. </span>Acknowledgements</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">B. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">B.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">B.2 </span>Informative references</a></li></ul></li></ul></div>



<div class="informative section" id="introduction" typeof="bibo:Chapter" about="#introduction">

<!-- OddPage -->
<h2><span class="secno">1. </span>Introduction</h2><p><em>This section is non-normative.</em></p>

<p>
This document is a detailed specification for the <em>RDF Interfaces</em>.
The document is primarily intended for the following audiences:</p>
<ul>
    <li>RDF Library writers.</li>
    <li>Advanced RDF users.</li>
    <li>RDF Interface extension developers.</li>
</ul>

<p class="issue">This is a preliminary specification and is therefore fairly
unstable. Implementers are warned that the interfaces in this document may
change on a frequent basis until the specification reaches <acronym title="World Wide Web Consortium">W3C</acronym> Last Call 
status.</p>

<p>If you are not familiar with RDF, you should read about the
Resource Description Framework (RDF) [<cite><a class="bibref" rel="biblioentry" href="#bib-RDF-CONCEPTS">RDF-CONCEPTS</a></cite>] before reading this document.</p>

<p>Readers who are not familiar with the Terse RDF Triple Language
[<cite><a class="bibref" rel="biblioentry" href="#bib-TURTLE">TURTLE</a></cite>] may want to read the specification in order to understand the
short-hand RDF notation used in some of the examples.</p>

<p>This document uses the <em>Web Interface Definition Language</em>
[<cite><a class="bibref" rel="biblioentry" href="#bib-WEBIDL">WEBIDL</a></cite>] to specify all language bindings. If you intend to implement
any part of the <em>RDF Interfaces</em> you should be familiar with the Web IDL
language [<cite><a class="bibref" rel="biblioentry" href="#bib-WEBIDL">WEBIDL</a></cite>].</p>

<p>Examples may contain references to existing vocabularies and use
abbreviations in CURIEs and source code. The following is a list of all
vocabularies and their abbreviations, as used in this document:</p>
<ul>
    <li>The <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">RDF</a>
    vocabulary (abbreviation: <code>rdf</code>, e.g., <code>rdf:type</code>)</li>
    <li>The <a href="http://www.w3.org/2001/XMLSchema#">XSD</a>
    vocabulary (abbreviation: <code>xsd</code>, e.g., <code>xsd:integer</code>)</li>
    <li>The <a href="http://www.w3.org/2000/01/rdf-schema#">RDF
    schema</a> vocabulary (abbreviation: <code>rdfs</code>, e.g., <code>rdfs:label</code>)</li>
    <li>The <a href="http://xmlns.com/foaf/spec/">Friend-Of-A-Friend</a>
    vocabulary (abbreviation: <code>foaf</code>, e.g., <code>foaf:name</code>)</li>
</ul>

<div id="conformance" typeof="bibo:Chapter" about="#conformance" class="section"><h3><span class="secno">1.1 </span>Conformance</h3><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p>
<p>The key words <em class="rfc2119" title="must">must</em>, <em class="rfc2119" title="must not">must not</em>, <em class="rfc2119" title="required">required</em>, <em class="rfc2119" title="should">should</em>, <em class="rfc2119" title="should not">should not</em>, <em class="rfc2119" title="recommended">recommended</em>, <em class="rfc2119" title="may">may</em>, and <em class="rfc2119" title="optional">optional</em> in this specification are to be interpreted as described in [<cite><a class="bibref" rel="biblioentry" href="#bib-RFC2119">RFC2119</a></cite>].</p>

<p>Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. In particular, the algorithms defined in this specification
are intended to be easy to follow, and not intended to be performant.</p>

<p>User agents may impose implementation-specific limits on
otherwise unconstrained inputs, e.g. to prevent denial of service
attacks, to guard against running out of memory, or to work around
platform-specific limitations.</p>

<p>Implementations that use ECMAScript or Java to implement the
Interfaces defined in this specification must implement them in a manner
consistent with the respective ECMAScript or Java Bindings defined in
the Web IDL specification, as this specification uses that
specification's terminology. [<cite><a class="bibref" rel="biblioentry" href="#bib-WEBIDL">WEBIDL</a></cite>]</p>

<p>Implementations that use any other language to implement the
Interfaces defined in this specification that do not have bindings
defined in the Web IDL specification should attempt to map the
Interfaces as closely as possible to the implementation language's
native mechanisms and datatypes. Developers are encouraged to work with
other developers who are providing the RDF Interfaces in the same
langauge to ensure that implementations are modular and easily
exchangable.</p>
</div>

</div>

<!--  end introduction  -->


<div id="rdf-concept-interfaces" typeof="bibo:Chapter" about="#rdf-concept-interfaces" class="section">

<!-- OddPage -->
<h2><span class="secno">2. </span>RDF Concept Interfaces</h2>
<p>The RDF Concept Interfaces in this specification provide a low
level API for working with RDF data.</p>

<p>The concepts described in this specification are more generalized than those 
defined by the RDF Data Model [<cite><a class="bibref" rel="biblioentry" href="#bib-RDF-CONCEPTS">RDF-CONCEPTS</a></cite>]. Whilst this may appear to be a mismatch,
the RDF specification is intended to define a notation for transmitting data on the Web,
however this specification defines a set of interfaces for working with that data, behind the public interface,
where more generalized notions of Triples are often required by libraries and modules.</p>

<div id="overview" typeof="bibo:Chapter" about="#overview" class="section">
<h3><span class="secno">2.1 </span>Overview</h3>
<p>The core interfaces for working with RDF defined by this specification are as follows:</p>
<dl>
    <dt>Graph</dt>
    <dd>A Graph holds a set of Triples.</dd>
    <dt>Triple</dt>
    <dd>
    <p>A Triple consists of three components:</p>
    <ul>
        <li>the <code>subject</code>, which is an <code>RDFNode</code></li>
        <li>the <code>predicate</code>, which is an <code>RDFNode</code></li>
        <li>the <code>object</code>, which is an <code>RDFNode</code></li>
    </ul>
    <p>Triples are the basic data structure utilized by RDF to express
    statements.</p>
    <p>Throughout documentation and examples, Triples are
    conventionally written in the order subject, predicate, object - for
    example:</p>
    <p><code>&lt;http://example.org/hp&gt; rdfs:label &quot;Harry
    Potter&quot; .</code></p>
    </dd>
    <dt>NamedNode</dt>
    <dd>
    <p>A node identified by an IRI. For example: <code>&lt;http://example.org/people#mark&gt;</code></p>
    <p>Note: IRIs are defined by International Resource Identifier
    [<cite><a class="bibref" rel="biblioentry" href="#bib-IRI">IRI</a></cite>] and are compatible with RDF URI references as defined by RDF
    Concepts [<cite><a class="bibref" rel="biblioentry" href="#bib-RDF-CONCEPTS">RDF-CONCEPTS</a></cite>].</p>
    </dd>
    <dt>BlankNode</dt>
    <dd>
    <p>A blank node is a reference to an unnamed resource (one for
    which an IRI is not known), and may be used in a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> as
    a unique reference to that unnamed resource.</p>
    <p>BlankNodes are typically stringified by prepending &quot;<code>_:</code>&quot;
    to a unique value, for instance <code>_:b142</code> or <code>_:me</code>,
    this stringified form is referred to as a &quot;blank node identifier&quot;.</p>
    <p>Note: Blank node identifiers are only guaranteed to be unique
    within a single instance of a single <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, the string
    form of a blank node identifier cannot be relied upon over time; that
    is to say, two graphs may hold different blank nodes which both
    stringify as &quot;_:b2&quot;, and the same blank node within the same graph may
    have the stringified identifier &quot;_:x23&quot; in one instance and &quot;_:ui9x&quot; in
    another.</p>
    </dd>
    <dt>Literal</dt>
    <dd>
    <p>A literal value, optionally combined with a language attribute
    and/or a datatype attribute.</p>
    <p>Literals are used for untyped string data, plain text in a
    natural language, or values which have a specific datatype. For
    example:</p>
    <ul>
        <li><code>&quot;Harry Potter and the Half-Blood Prince&quot;@en</code> is
        plain text expressed in the English language.</li>
        <li><code>&quot;7&quot;^^xsd:integer</code> is a value with a datatype of <code>xsd:integer</code>.</li>
    </ul>
    </dd>
</dl>
<p>In addition to the above, this specification provides an <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> interface,
which is implemented by those interfaces which can occupy a position in a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</p>

<p>Implementers may provide additional types and/or a deeper type or class hierarchy
so long as it includes these basic types.</p>

</div>

<div class="normative section" id="data-structures" typeof="bibo:Chapter" about="#data-structures">
<h3><span class="secno">2.2 </span>Data Structures</h3>

<div class="normative section" id="triples" typeof="bibo:Chapter" about="#triples">
<h4><span class="secno">2.2.1 </span>Triples</h4>
<p>The <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> interface represents an RDF Triple. The
   stringification of a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> results in an N-Triples
   representation as defined in [<cite><a class="bibref" rel="biblioentry" href="#bib-RDF-TESTCASES">RDF-TESTCASES</a></cite>].</p>
<p class="issue">Implementors should be aware that a UTF-8 version of N-Triples may be defined by the RDF WG,
  as such the definition/implementation of the <code>toString</code> method may change.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-Triple">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">Triple</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlAttrName"><a href="#widl-Triple-subject">subject</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlAttrName"><a href="#widl-Triple-predicate">predicate</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlAttrName"><a href="#widl-Triple-object">object</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>stringifier DOMString</a></span> <span class="idlMethName"><a href="#widl-Triple-toString-stringifier-DOMString">toString</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span>               <span class="idlMethName"><a href="#widl-Triple-equals-boolean-Triple-otherTriple">equals</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">otherTriple</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes" class="section"><h5 id="attributes">Attributes</h5><dl class="attributes"><dt id="widl-Triple-object"><code>object</code> of type <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span>, readonly</dt><dd>The object associated with the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</dd><dt id="widl-Triple-predicate"><code>predicate</code> of type <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span>, readonly</dt><dd>The predicate associated with the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</dd><dt id="widl-Triple-subject"><code>subject</code> of type <span class="idlAttrType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span>, readonly</dt><dd>The subject associated with the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</dd></dl></div><div typeof="bibo:Chapter" about="#methods" class="section"><h5 id="methods">Methods</h5><dl class="methods"><dt id="widl-Triple-equals-boolean-Triple-otherTriple"><code>equals</code></dt><dd>Returns <code>true</code> if <code>otherTriple</code> is equivalent to this triple.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">otherTriple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The Triple to test for equivalence with this Triple.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd><dt id="widl-Triple-toString-stringifier-DOMString"><code>toString</code></dt><dd>Converts this triple into a string in N-Triples notation.<div><em>No parameters.</em></div><div><em>Return type: </em><code><a>stringifier DOMString</a></code></div></dd></dl></div>

</div>

<div class="normative section" id="graphs" typeof="bibo:Chapter" about="#graphs">
<h4><span class="secno">2.2.2 </span>Graphs</h4>
<p>A <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> holds a set of one or more <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-Graph">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">Graph</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>unsigned long</a></span>          <span class="idlAttrName"><a href="#widl-Graph-length">length</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-add-Graph-Triple-triple">add</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-remove-Graph-Triple-triple">remove</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-removeMatches-Graph-any-subject-any-predicate-any-object">removeMatches</a></span> (<span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">subject</span></span>, <span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">predicate</span></span>, <span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">object</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">sequence&lt;<a href="#idl-def-Triple" class="idlType"><code>Triple</code></a>&gt;</span> <span class="idlMethName"><a href="#widl-Graph-toArray-sequence-Triple">toArray</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span>          <span class="idlMethName"><a href="#widl-Graph-some-boolean-TripleFilter-callback">some</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">callback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span>          <span class="idlMethName"><a href="#widl-Graph-every-boolean-TripleFilter-callback">every</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">callback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-filter-Graph-TripleFilter-filter">filter</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">filter</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>             <span class="idlMethName"><a href="#widl-Graph-forEach-void-TripleCallback-callback">forEach</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></span> <span class="idlParamName">callback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-match-Graph-any-subject-any-predicate-any-object-unsigned-long-limit">match</a></span> (<span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">subject</span></span>, <span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">predicate</span></span>, <span class="idlParam"><span class="idlParamType"><a>any</a>?</span> <span class="idlParamName">object</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>unsigned long</a></span> <span class="idlParamName">limit</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-merge-Graph-Graph-graph">merge</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-addAll-Graph-Graph-graph">addAll</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType">sequence&lt;<a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a>&gt;</span> <span class="idlAttrName"><a href="#widl-Graph-actions">actions</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>            <span class="idlMethName"><a href="#widl-Graph-addAction-Graph-TripleAction-action-boolean-run">addAction</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a></span> <span class="idlParamName">action</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">run</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-1" class="section"><h5 id="attributes-1">Attributes</h5><dl class="attributes"><dt id="widl-Graph-actions"><code>actions</code> of type <span class="idlAttrType">sequence&lt;<a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a>&gt;</span>, readonly</dt><dd>An array of actions to run when a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> is added
    to the graph, each new triple is passed to the <code>run</code> method
    of each <a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> in the array.</dd><dt id="widl-Graph-length"><code>length</code> of type <span class="idlAttrType"><a>unsigned long</a></span>, readonly</dt><dd>A non-negative integer that specifies the number of <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s
    in the set.</dd></dl></div><div typeof="bibo:Chapter" about="#methods-1" class="section"><h5 id="methods-1">Methods</h5><dl class="methods"><dt id="widl-Graph-add-Graph-Triple-triple"><code>add</code></dt><dd>Adds the specified <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> to the graph. This
    method returns the graph instance it was called on.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> to add. <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>s <em class="rfc2119" title="must not">must not</em>
        contain duplicate triples.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-addAction-Graph-TripleAction-action-boolean-run"><code>addAction</code></dt><dd>Adds a new <a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> to the array of actions,
    if the <code>run</code> argument is specified as <code>true</code> then
    each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> <em class="rfc2119" title="must">must</em> be passed to
    the <a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> before this method returns.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">action</td><td class="prmType"><code><a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> to add.</td></tr><tr><td class="prmName">run</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">A boolean flag specifying whether all triples in the graph
        should immediately be tried by the action.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-addAll-Graph-Graph-graph"><code>addAll</code></dt><dd>
    <p>Imports the <code>graph</code> in to this graph. This method
    returns the graph instance it was called on.</p>
    <p>This method differes from <code>Graph.merge</code> in that it adds all triples from <code>graph</code> to the current instance, rather than combining the two graphs to create a new instance.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> to import in to this graph, the import
        must not produce any duplicates.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-every-boolean-TripleFilter-callback"><code>every</code></dt><dd>
    <p>Universal quantification method, tests whether every <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
    in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> passes the test implemented by the provided <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a>.</p>
    <p>This method will return boolean <code>false</code> when the
    first <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> is found that does <em>not</em> pass the
    test.</p>
    <p>Note: this method is aligned with <code>Array.prototype.every()</code>
    in ECMAScript-262.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">callback</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to test each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> against.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd><dt id="widl-Graph-filter-Graph-TripleFilter-filter"><code>filter</code></dt><dd>
    <p>Creates a new <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> with all the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s
    which pass the test implemented by the provided <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a>.</p>
    <p>Note: this method is aligned with <code>Array.prototype.filter()</code>
    in ECMAScript-262.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">filter</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to test each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> against.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-forEach-void-TripleCallback-callback"><code>forEach</code></dt><dd>
    <p>Executes the provided <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> once on each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
    in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>.</p>
    <p>Note: this method is aligned with <code>Array.prototype.forEach()</code>
    in ECMAScript-262.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">callback</td><td class="prmType"><code><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> to execute for each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.
        </td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-Graph-match-Graph-any-subject-any-predicate-any-object-unsigned-long-limit"><code>match</code></dt><dd>
    <p>This method returns a new <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> which is comprised of all those triples in the current instance
    which match the given arguments, that is, for each triple in this graph, it is included in the output graph, if:</p>
    <ul>
      <li>calling <code>triple.subject.equals</code> with the specified <code>subject</code> as an argument returns <code>true</code>, or the <code>subject</code> argument is <code>null</code>, AND</li>
      <li>calling <code>triple.predicate.equals</code> with the specified <code>predicate</code> as an argument returns <code>true</code>, or the <code>predicate</code> argument is <code>null</code>, AND</li>
      <li>calling <code>triple.object.equals</code> with the specified <code>object</code> as an argument returns <code>true</code>, or the <code>object</code> argument is <code>null</code></li>
    </ul>
    <p>This method implements AND functionality, so only triples matching all of the given non-null arguments will be included in the result.</p>
    <p>Note, this method always returns a new Graph, even if that Graph contains no Triples.</p>
    <p>Note, Graphs represent Sets of Triples, the order is arbitrary, so this method may result in differing results when called repeatedly with a limit.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">subject</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The subject value to match against, may be <code>null</code>.</td></tr><tr><td class="prmName">predicate</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The predicate value to match against, may be <code>null</code>.</td></tr><tr><td class="prmName">object</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The object value to match against, may be <code>null</code>.</td></tr><tr><td class="prmName">limit</td><td class="prmType"><code><a>unsigned long</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional limit to the amount of triples returned, if 0 is passed or the argument is set to null then all matching triples will be contained in the resulting graph.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-merge-Graph-Graph-graph"><code>merge</code></dt><dd>Returns a new <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> which is a concatenation of
    this graph and the graph given as an argument.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> to concatenate with this graph, the
        resulting <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> must not contain any duplicates.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-remove-Graph-Triple-triple"><code>remove</code></dt><dd>Removes the specified <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> from the graph. This
    method returns the graph instance it was called on.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> to remove.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-removeMatches-Graph-any-subject-any-predicate-any-object"><code>removeMatches</code></dt><dd>
    <p>This method removes those triples in the current instance which match the given arguments,
     that is, for each triple in this graph, it is removed, if:</p>
    <ul>
      <li>calling <code>triple.subject.equals</code> with the specified <code>subject</code> as an argument returns <code>true</code>, or the <code>subject</code> argument is <code>null</code>, AND</li>
      <li>calling <code>triple.predicate.equals</code> with the specified <code>predicate</code> as an argument returns <code>true</code>, or the <code>predicate</code> argument is <code>null</code>, AND</li>
      <li>calling <code>triple.object.equals</code> with the specified <code>object</code> as an argument returns <code>true</code>, or the <code>object</code> argument is <code>null</code></li>
    </ul>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">subject</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The subject value to match against, may be <code>null</code>.</td></tr><tr><td class="prmName">predicate</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The predicate value to match against, may be <code>null</code>.</td></tr><tr><td class="prmName">object</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The object value to match against, may be <code>null</code>.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-Graph-some-boolean-TripleFilter-callback"><code>some</code></dt><dd>
    <p>Existential quantification method, tests whether some <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
    in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> passes the test implemented by the provided <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a>.</p>
    <p>This method will return boolean <code>true</code> when the first
    <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> is found that passes the test.</p>
    <p>Note: this method is aligned with <code>Array.prototype.some()</code>
    in ECMAScript-262.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">callback</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to test each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        in the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> against.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd><dt id="widl-Graph-toArray-sequence-Triple"><code>toArray</code></dt><dd>
    <p>Returns the set of <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s within the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
    as a host language native sequence, for example an <code>Array</code>
    in ECMAScript-262.</p>
    <p>Note: a <code>sequence</code> in [<cite><a class="bibref" rel="biblioentry" href="#bib-WEBIDL">WEBIDL</a></cite>] is passed by <em>value</em>,
    not by <em>reference</em>.</p>
    <p>Note: the order of the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s within the returned
    sequence is arbitrary, since a Graph is an unordered set.</p>
    <div><em>No parameters.</em></div><div><em>Return type: </em><code>sequence&lt;<a href="#idl-def-Triple" class="idlType"><code>Triple</code></a>&gt;</code></div></dd></dl></div>

</div>

</div>

<div class="normative section" id="basic-node-types" typeof="bibo:Chapter" about="#basic-node-types">
<h3><span class="secno">2.3 </span>Basic Node Types</h3>

<div class="normative section" id="nodes" typeof="bibo:Chapter" about="#nodes">
<h4><span class="secno">2.3.1 </span>Nodes</h4>
<p><a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> is the base class of <a class="tref idlType" title="NamedNode" href="#idl-def-NamedNode"><code>NamedNode</code></a>,
<a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>, and <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a>.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-RDFNode">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">RDFNode</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>any</a></span>       <span class="idlAttrName"><a href="#widl-RDFNode-nominalValue">nominalValue</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a></span> <span class="idlAttrName"><a href="#widl-RDFNode-interfaceName">interfaceName</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span> <span class="idlMethName"><a href="#widl-RDFNode-toString-DOMString">toString</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>any</a></span>       <span class="idlMethName"><a href="#widl-RDFNode-valueOf-any">valueOf</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span> <span class="idlMethName"><a href="#widl-RDFNode-toNT-DOMString">toNT</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span>   <span class="idlMethName"><a href="#widl-RDFNode-equals-boolean-any-tocompare">equals</a></span> (<span class="idlParam"><span class="idlParamType"><a>any</a></span> <span class="idlParamName">tocompare</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-2" class="section"><h5 id="attributes-2">Attributes</h5><dl class="attributes"><dt id="widl-RDFNode-interfaceName"><code>interfaceName</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly</dt><dd>
    <p>Provides access to the string name of the current interface,
    normally one of <code>&quot;NamedNode&quot;</code>, <code>&quot;BlankNode&quot;</code> or <code>&quot;Literal&quot;</code>.</p>
    <p>This method serves to disambiguate instances of <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> which
    are otherwise identical, such as <a class="tref idlType" title="NamedNode" href="#idl-def-NamedNode"><code>NamedNode</code></a> and <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>.</p>
    </dd><dt id="widl-RDFNode-nominalValue"><code>nominalValue</code> of type <span class="idlAttrType"><a>any</a></span>, readonly</dt><dd>
    <p>The <code>nominalValue</code> of an <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> is refined by
    each interface which extends <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a>.</p>
    </dd></dl></div><div typeof="bibo:Chapter" about="#methods-2" class="section"><h5 id="methods-2">Methods</h5><dl class="methods"><dt id="widl-RDFNode-equals-boolean-any-tocompare"><code>equals</code></dt><dd>
    <p>If <code>tocompare</code> is an instance of <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> then this method
       returns true if an only if all attributes on the two interfaces are equivalent.</p>
    <p>If <code>tocompare</code> is NOT an instance of <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a>
       then the it <em class="rfc2119" title="must">must</em> be compared against the result of calling <code>toValue</code> on this node.</p>
    <p class="note">You cannot simply test two RDF Nodes for equivalence using
       general language constructs such as <code>==</code>.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">tocompare</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The value to test for equivalence with this node.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd><dt id="widl-RDFNode-toNT-DOMString"><code>toNT</code></dt><dd>
    <p>Returns the N-Triples representation of the <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a>
    as defined by [<cite><a class="bibref" rel="biblioentry" href="#bib-RDF-TESTCASES">RDF-TESTCASES</a></cite>].</p>
    <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>DOMString</a></code></div></dd><dt id="widl-RDFNode-toString-DOMString"><code>toString</code></dt><dd>
    <p>The stringification of an <a class="tref idlType" title="RDFNode" href="#idl-def-RDFNode"><code>RDFNode</code></a> is defined as
    follows, if the <code>interfaceName</code> is</p>
    <ul>
        <li><code>NamedNode</code> then return the stringified <code>nominalValue</code>.</li>
        <li><code>BlankNode</code> then prepend <code>&quot;_:&quot;</code> to the
        stringified <code>value</code> and return the result.</li>
        <li><code>Literal</code> then return the stringified <code>nominalValue</code>.</li>
    </ul>
    <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>DOMString</a></code></div></dd><dt id="widl-RDFNode-valueOf-any"><code>valueOf</code></dt><dd>
    <p>This method provides access to the implementations host environment native value
    for this RDFNode, if the <code>interfaceName</code> is</p>
    <ul>
        <li><a class="tref idlType" title="NamedNode" href="#idl-def-NamedNode"><code>NamedNode</code></a> or <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a> then return the stringified <code>nominalValue</code>.</li>
        <li><a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> then return the language native value for this node where supported, or
        the stringified <code>nominalValue</code> if the datatype of the Literal is unknown or the value is out
        of the range supported. See the definition of <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> for further guidance.
        </li>
    </ul>
    <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>any</a></code></div></dd></dl></div>
</div>


<div class="normative section" id="named-nodes" typeof="bibo:Chapter" about="#named-nodes">
<h4><span class="secno">2.3.2 </span>Named Nodes</h4>
<p>A node identified by an IRI. IRIs are defined by International
Resource Identifier [<cite><a class="bibref" rel="biblioentry" href="#bib-IRI">IRI</a></cite>].</p>
<pre class="idl"><span class="idlInterface" id="idl-def-NamedNode">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">NamedNode</span> : <span class="idlSuperclass"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>any</a></span> <span class="idlAttrName"><a href="#widl-NamedNode-nominalValue">nominalValue</a></span>;</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-3" class="section"><h5 id="attributes-3">Attributes</h5><dl class="attributes"><dt id="widl-NamedNode-nominalValue"><code>nominalValue</code> of type <span class="idlAttrType"><a>any</a></span>, readonly</dt><dd>The IRI identifier of the node.</dd></dl></div>
</div>

<div class="normative section" id="blank-nodes" typeof="bibo:Chapter" about="#blank-nodes">
<h4><span class="secno">2.3.3 </span>Blank Nodes</h4>
<p>A <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a> is a reference to an unnamed resource
(one for which an IRI is not known), and may be used in a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
as a unique reference to that unnamed resource.</p>
<p><a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>s are stringified by prepending &quot;<code>_:</code>&quot;
to a unique value, for instance <code>_:b142</code> or <code>_:me</code>,
this stringified form is referred to as a &quot;blank node identifier&quot;.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-BlankNode">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">BlankNode</span> : <span class="idlSuperclass"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>any</a></span> <span class="idlAttrName"><a href="#widl-BlankNode-nominalValue">nominalValue</a></span>;</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-4" class="section"><h5 id="attributes-4">Attributes</h5><dl class="attributes"><dt id="widl-BlankNode-nominalValue"><code>nominalValue</code> of type <span class="idlAttrType"><a>any</a></span>, readonly</dt><dd>
    <p>The temporary identifier of the <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>, the
    nominalValue may be of any type, so long as it is unique and can be
    stringified, for instance a <code>number</code> or a <code>string</code>.</p>
    <p>The nominalValue <em class="rfc2119" title="must not">must not</em> be relied upon in any way between two
    separate processing runs of the same document, or two instances of <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
    containing &quot;the same&quot; triples.
    </p></dd></dl></div>
<p class="note">Developers and authors must not assume that the
nominalValue of a <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a> will remain the same between two
processing runs. <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a> nominalValues are only valid for the
most recent processing run on the document. <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>s
nominalValues will often be generated differently by different processors.</p>

<p class="note">Implementers <em class="rfc2119" title="must">must</em> ensure that <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a> nominalValues are unique
within the current environment, two <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>s are considered equal if, and only if,
their nominalValues are strictly equal.</p>
</div>
<div class="normative section" id="literals" typeof="bibo:Chapter" about="#literals">
<h4><span class="secno">2.3.4 </span>Literals</h4>
<p>Literals represent values such as numbers, dates and strings in
RDF data. A <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> is comprised of three attributes:</p>
<ul>
  <li>a lexical representation of the <code>nominalValue</code></li>
  <li>an optional <code>language</code> represented by a string token</li>
  <li>an optional <code>datatype</code> specified by a <a class="tref idlType" title="NamedNode" href="#idl-def-NamedNode"><code>NamedNode</code></a></li>
</ul>

<p>Literals representing plain text in a natural language may have a
<code>language</code> attribute specified by a text string token, as
specified in [<cite><a class="bibref" rel="biblioentry" href="#bib-BCP47">BCP47</a></cite>], normalized to lowercase (e.g., <code>'en'</code>, <code>'fr'</code>, <code>'en-gb'</code>).
They may also have a datatype attribute such as <code>xsd:string</code>.</p>

  <p class="issue">The RDF Working Group is currently looking at the handling of &quot;Plain Literals&quot;,
  with regards to datatypes, further guidance may result in changes to this specification.</p>

<p>Literals representing values with a specific datatype, such as
the integer 72, may have a <code>datatype</code> attribute specified in
the form of a <a class="tref idlType" title="NamedNode" href="#idl-def-NamedNode"><code>NamedNode</code></a> (e.g., <code>&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>).</p>

<p>
Literals often represent values for which the host environment of an RDF Interface implementation
has a corresponding native value, this value can be accessed by the <code>valueOf</code>
method of the <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> interface.</p>
<p>Implementations <em class="rfc2119" title="must">must</em> provide native value type conversion, via the <code>valueOf</code> method,
for the following <a href="http://www.w3.org/2001/XMLSchema-datatypes">XML Schema datatypes</a>:</p>
<ul>
    <li>xsd:string</li>
    <li>xsd:boolean</li>
    <li>xsd:dateTime</li>
    <li>xsd:date</li>
    <li>xsd:time</li>
    <li>xsd:int</li>
    <li>xsd:double</li>
    <li>xsd:float</li>
    <li>xsd:decimal</li>
    <li>xsd:positiveInteger</li>
    <li>xsd:integer</li>
    <li>xsd:nonPositiveInteger</li>
    <li>xsd:negativeInteger</li>
    <li>xsd:long</li>
    <li>xsd:int</li>
    <li>xsd:short</li>
    <li>xsd:byte</li>
    <li>xsd:nonNegativeInteger</li>
    <li>xsd:unsignedLong</li>
    <li>xsd:unsignedInt</li>
    <li>xsd:unsignedShort</li>
    <li>xsd:unsignedByte</li>
</ul>


<!-- p class="note">If the datatype of the Literal is <code>rdf:PlainLiteral</code>
and the language is not known, then the <code>language</code> MUST be
set to an empty string value <code>""</code> and the <code>toNT()</code>
method MUST return the Literals string value concatenated with <code>@</code>
- for example <code>"Hello@"^^rdf:PlainLiteral</code>.</p  -->


<p class="note">When a Literal contains both a datatype and a language, and the serialization
or stringification does not support a lexical representation of both attributes,
language <em class="rfc2119" title="should">should</em> take precedence.</p>

<p class="note">RDF specifies that Literal equality is based on the lexical representation
of values rather than the value space, for this reason the Literals 
<code>&quot;100&quot;^^xsd:double</code> and <code>&quot;1e2&quot;^^xsd:double</code> are not considered equal.</p>

<pre class="idl"><span class="idlInterface" id="idl-def-Literal">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">Literal</span> : <span class="idlSuperclass"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a></span>  <span class="idlAttrName"><a href="#widl-Literal-nominalValue">nominalValue</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a>?</span> <span class="idlAttrName"><a href="#widl-Literal-language">language</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a>?</span> <span class="idlAttrName"><a href="#widl-Literal-datatype">datatype</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>any</a></span> <span class="idlMethName"><a href="#widl-Literal-valueOf-any">valueOf</a></span> ();</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-5" class="section"><h5 id="attributes-5">Attributes</h5><dl class="attributes"><dt id="widl-Literal-datatype"><code>datatype</code> of type <span class="idlAttrType"><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a></span>, readonly, nullable</dt><dd>An optional datatype identified by a NamedNode.</dd><dt id="widl-Literal-language"><code>language</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly, nullable</dt><dd>An optional language string as defined in [<cite><a class="bibref" rel="biblioentry" href="#bib-BCP47">BCP47</a></cite>], normalized to lowercase.</dd><dt id="widl-Literal-nominalValue"><code>nominalValue</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly</dt><dd>The lexical representation of the Literals value.</dd></dl></div><div typeof="bibo:Chapter" about="#methods-3" class="section"><h5 id="methods-3">Methods</h5><dl class="methods"><dt id="widl-Literal-valueOf-any"><code>valueOf</code></dt><dd>
      <p>This method provides access to a corresponding host environment specific native value, where one exists.</p>
      <p>If the datatype identifier of the <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> is not known by the implementation, or the value is outside
         of the range handled by the corresponding native type, then <code>valueOf</code> <em class="rfc2119" title="must">must</em> return
         the <code>DOMString</code> lexical representation of the <code>nominalValue</code>.</p>
    <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>any</a></code></div></dd></dl></div>
<p>The chart below provides a datatype map for the XSD datatypes which must be supported.</p>
<h5 id="datatype-map">Datatype Map:</h5>
<table>
    <tbody><tr>
        <th>Specified Datatype</th>
        <th>IDL</th>
        <th>ECMAScript</th>
    </tr>
    <tr>
        <td>xsd:string</td>
        <td>DOMString</td>
        <td>string</td>
    </tr>
    <tr>
        <td>xsd:boolean</td>
        <td>boolean</td>
        <td>boolean</td>
    </tr>
    <tr>
        <td>xsd:dateTime</td>
        <td>-</td>
        <td>Date</td>
    </tr>
    <tr>
        <td>xsd:date</td>
        <td>-</td>
        <td>Date</td>
    </tr>
    <tr>
        <td>xsd:time</td>
        <td>-</td>
        <td>Date</td>
    </tr>
    <tr>
        <td>xsd:int</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:double</td>
        <td>double</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:float</td>
        <td>float</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:decimal</td>
        <td>double</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:positiveInteger</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:integer</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:nonPositiveInteger</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:negativeInteger</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:long</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:int</td>
        <td>long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:short</td>
        <td>short</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:byte</td>
        <td>short</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:nonNegativeInteger</td>
        <td>unsigned long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:unsignedLong</td>
        <td>unsigned long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:unsignedInt</td>
        <td>unsigned long</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:unsignedShort</td>
        <td>unsigned short</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:unsignedByte</td>
        <td>unsigned short</td>
        <td>number</td>
    </tr>
    <tr>
        <td>xsd:positiveInteger</td>
        <td>unsigned long</td>
        <td>number</td>
    </tr>
</tbody></table>
<p class="note">Implementations <em class="rfc2119" title="must">must</em> convert <code>xsd:boolean</code>
values to native <code>boolean</code>s rather than Boolean Objects to
limit unexpected behaviour.</p>
</div>

</div>

<div id="additional-interfaces" typeof="bibo:Chapter" about="#additional-interfaces" class="section">
<h3><span class="secno">2.4 </span>Additional Interfaces</h3>
<div class="normative section" id="triple-filters" typeof="bibo:Chapter" about="#triple-filters">
<h4><span class="secno">2.4.1 </span>Triple Filters</h4>
<p>The <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> is a callable interface which is
used to implement <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> tests, a response of <code>true</code>
means that the test has been passed.</p>
<p>When used with the <code>filter</code> method of the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
interface a response of <code>true</code> indicates the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
should be included in the output set.</p>

<pre class="idl"><span class="idlInterface" id="idl-def-TripleFilter">[<span class="extAttr">NoInterfaceObject, Callback</span>]
interface <span class="idlInterfaceID">TripleFilter</span> {
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span> <span class="idlMethName"><a href="#widl-TripleFilter-test-boolean-Triple-triple">test</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-4" class="section"><h5 id="methods-4">Methods</h5><dl class="methods"><dt id="widl-TripleFilter-test-boolean-Triple-triple"><code>test</code></dt><dd>A callable function that returns true if the input <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
    passes the test this function implements.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The triple to test against the filter.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd></dl></div>

<div typeof="bibo:Chapter" about="#example-filters" class="section">
<h5 id="example-filters">Example Filters</h5>
<p>The following shows an example set of common TripleFilters
exposed on a <code>filter</code> attribute of <a class="tref idlType" title="RDFEnvironment" href="#idl-def-RDFEnvironment"><code>RDFEnvironment</code></a>:</p>
<pre class="example"><span style="color: olivedrab">// basic filters</span>
rdf.filters = {
  s: function(s) { return function(t) { return t.subject.equals(s); }; },
  p: function(p) { return function(t) { return t.predicate.equals(p); }; },
  o: function(o) { return function(t) { return t.object.equals(o); }; },
  sp: function(s,p) { return function(t) { return t.subject.equals(s) &amp;&amp; t.predicate.equals(p); }; },
  so: function(s,o) { return function(t) { return t.subject.equals(s) &amp;&amp; t.object.equals(o); }; },
  po: function(p,o) { return function(t) { return t.predicate.equals(p) &amp;&amp; t.object.equals(o); }; },
  spo: function(s,p,o) { return function(t) { return t.subject.equals(s) &amp;&amp; t.predicate.equals(p) &amp;&amp; t.object.equals(o); }; },
  describes: function(v) { return function(t) { return t.subject.equals(v) || t.object.equals(v); }; },
  type: function(o) {
    var type = rdf.resolve(&quot;rdf:type&quot;); 
    return function(t) { return t.predicate.equals(type) &amp;&amp; t.object.equals(o); };
  }
};

<span style="color: olivedrab">// example basic usage - find all triples with an subject or object of &quot;http://example.org/bob#me&quot;</span>
var results = graph.filter( rdf.filters.describes(&quot;http://example.org/bob#me&quot;) );

<span style="color: olivedrab">// example advanced usage</span>
<span style="color: olivedrab">// find the descriptions of all foaf:People in a graph and display a summary of them.</span>
var displayPerson = function(graph) {
  <span style="color: olivedrab">// code to display the description of a person</span>
};
<span style="color: olivedrab">// filter the graph to find all subjects with an &quot;rdf:type&quot; of &quot;foaf:Person&quot;</span>
var filter = rdf.filters.type( rdf.resolve(&quot;foaf:Person&quot;);
results = graph.filter( filter );
results.forEach( function(t) {
  <span style="color: olivedrab">// iterate over the results, creating a filtered graph for each subject found</span>
  <span style="color: olivedrab">// and pass that graph to a display function</span>
  displayPerson( graph.filter( rdf.filters.s(t.subject) );
});</pre>
</div>
</div>
<div class="normative section" id="triple-callbacks" typeof="bibo:Chapter" about="#triple-callbacks">
<h4><span class="secno">2.4.2 </span>Triple Callbacks</h4>
<p>The <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> is a callable interface which is
used to implement a function which can be called on a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</p>
<p>This interface is typically used with the <code>forEach</code>
method of the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> interface.</p>

<pre class="idl"><span class="idlInterface" id="idl-def-TripleCallback">[<span class="extAttr">NoInterfaceObject, Callback</span>]
interface <span class="idlInterfaceID">TripleCallback</span> {
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-TripleCallback-run-void-Triple-triple-Graph-graph">run</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-5" class="section"><h5 id="methods-5">Methods</h5><dl class="methods"><dt id="widl-TripleCallback-run-void-Triple-triple-Graph-graph"><code>run</code></dt><dd>A callable function which can be executed on a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The triple to be used.</td></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The graph which contains the triple.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></div>
</div>

<div class="normative section" id="triple-actions" typeof="bibo:Chapter" about="#triple-actions">
<h4><span class="secno">2.4.3 </span>Triple Actions</h4>
<p><a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> is an interface which combines the
functionality of <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> and <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a>,
given a <code>test</code> and an <code>action</code>, the <code>run</code>
method will execute the <code>action</code> if, and only if, it passes the <code>test</code>.</p>

<pre class="idl"><span class="idlInterface" id="idl-def-TripleAction">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">TripleAction</span> {
<span class="idlAttribute">    attribute <span class="idlAttrType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span>   <span class="idlAttrName"><a href="#widl-TripleAction-test">test</a></span>;</span>
<span class="idlAttribute">    attribute <span class="idlAttrType"><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></span> <span class="idlAttrName"><a href="#widl-TripleAction-action">action</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-TripleAction-run-void-Triple-triple-Graph-graph">run</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-6" class="section"><h5 id="attributes-6">Attributes</h5><dl class="attributes"><dt id="widl-TripleAction-action"><code>action</code> of type <span class="idlAttrType"><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></span></dt><dd>The action to call on triple which successfully pass the <code>test</code>.
    </dd><dt id="widl-TripleAction-test"><code>test</code> of type <span class="idlAttrType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span></dt><dd>An instance of <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> used to test whether
    the <code>action</code> should be executed on a specific <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</dd></dl></div><div typeof="bibo:Chapter" about="#methods-6" class="section"><h5 id="methods-6">Methods</h5><dl class="methods"><dt id="widl-TripleAction-run-void-Triple-triple-Graph-graph"><code>run</code></dt><dd>This method will run the specified <code>action</code> on the
    specified <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> if it passes the <code>test</code>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The triple to be tried.</td></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The graph which contains the triple.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></div>
</div>

</div>
</div>
<div class="normative section" id="rdf-environment-interfaces" typeof="bibo:Chapter" about="#rdf-environment-interfaces">

<!-- OddPage -->
<h2><span class="secno">3. </span>RDF Environment Interfaces</h2>

<div class="normative section" id="overview-1" typeof="bibo:Chapter" about="#overview-1">
<h3><span class="secno">3.1 </span>Overview</h3>
<p>The RDF Environment Interfaces provide all basic functionality
needed to work with RDF data in a programming environment, and within
specific contexts, for instance within a Parser, Serializer or Data Store.</p>

</div>

<div id="terms--prefixes-and-profiles" typeof="bibo:Chapter" about="#terms--prefixes-and-profiles" class="section">
<h3><span class="secno">3.2 </span>Terms, Prefixes and Profiles</h3>
<p>Within a programming context, and within various RDF
serializations, it is increasingly important to be able to simplify
access to properties and refer to full IRIs by using CURIEs or Terms.</p>
<p>In order to accomplish this a Profile of Prefix and Term mappings
is needed.</p>
<p>This specification includes the definition of three Interfaces
which serve to address these needs:</p>
<ul>
    <li><a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a> - which is a map of prefixes to IRIs,
    and provides methods to turn one in to the other.</li>
    <li><a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a> - which is a map of simple string terms to IRIs, and
    provides methods to turn one in to the other.</li>
    <li><a class="tref idlType" title="Profile" href="#idl-def-Profile"><code>Profile</code></a> - which contains a PrefixMap and a
    TermMap, and provides an easy to use context for negotiating between
    CURIEs, Terms and IRIs.</li>
</ul>

<div id="prefix-maps" typeof="bibo:Chapter" about="#prefix-maps" class="section">
<h4><span class="secno">3.2.1 </span>Prefix Maps</h4>
<pre class="idl"><span class="idlInterface" id="idl-def-PrefixMap">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">PrefixMap</span> {
<span class="idlMethod">    <span class="idlMethType"><a>omittable getter DOMString</a></span> <span class="idlMethName"><a href="#widl-PrefixMap-get-omittable-getter-DOMString-DOMString-prefix">get</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">prefix</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>omittable setter void</a></span>      <span class="idlMethName"><a href="#widl-PrefixMap-set-omittable-setter-void-DOMString-prefix-DOMString-iri">set</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">prefix</span></span>, <span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>omittable deleter void</a></span>     <span class="idlMethName"><a href="#widl-PrefixMap-remove-omittable-deleter-void-DOMString-prefix">remove</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">prefix</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span>                  <span class="idlMethName"><a href="#widl-PrefixMap-resolve-DOMString-DOMString-curie">resolve</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">curie</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span>                  <span class="idlMethName"><a href="#widl-PrefixMap-shrink-DOMString-DOMString-iri">shrink</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                       <span class="idlMethName"><a href="#widl-PrefixMap-setDefault-void-DOMString-iri">setDefault</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></span>                  <span class="idlMethName"><a href="#widl-PrefixMap-addAll-PrefixMap-PrefixMap-prefixes-boolean-override">addAll</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></span> <span class="idlParamName">prefixes</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">override</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-7" class="section"><h5 id="methods-7">Methods</h5><dl class="methods"><dt id="widl-PrefixMap-addAll-PrefixMap-PrefixMap-prefixes-boolean-override"><code>addAll</code></dt><dd>
    <p>This method returns the instance on which it was called.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">prefixes</td><td class="prmType"><code><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a> to import.</td></tr><tr><td class="prmName">override</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> then conflicting prefixes will be
        overridden by those specified on the <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a> being
        imported, by default imported prefixes augment the existing set.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></code></div></dd><dt id="widl-PrefixMap-get-omittable-getter-DOMString-DOMString-prefix"><code>get</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">prefix</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The prefix <em class="rfc2119" title="must">must</em> not contain any whitespace</td></tr></table><div><em>Return type: </em><code><a>omittable getter DOMString</a></code></div></dd><dt id="widl-PrefixMap-remove-omittable-deleter-void-DOMString-prefix"><code>remove</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">prefix</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The prefix <em class="rfc2119" title="must">must</em> contain any whitespace</td></tr></table><div><em>Return type: </em><code><a>omittable deleter void</a></code></div></dd><dt id="widl-PrefixMap-resolve-DOMString-DOMString-curie"><code>resolve</code></dt><dd>
    <p>Given a valid CURIE for which a prefix is known (for example <code>&quot;rdfs:label&quot;</code>),
      this method will return the resulting IRI (for example <code>&quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</code>)</p>
    <p>If the prefix is not known then this method will return null.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">curie</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The CURIE to resolve.</td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd><dt id="widl-PrefixMap-set-omittable-setter-void-DOMString-prefix-DOMString-iri"><code>set</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">prefix</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The prefix <em class="rfc2119" title="must">must</em> not contain any whitespace</td></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">An IRI, as defined by [<cite><a class="bibref" rel="biblioentry" href="#bib-IRI">IRI</a></cite>]</td></tr></table><div><em>Return type: </em><code><a>omittable setter void</a></code></div></dd><dt id="widl-PrefixMap-setDefault-void-DOMString-iri"><code>setDefault</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The iri to be used when resolving CURIEs without a prefix,
        for example <code>&quot;:this&quot;</code>.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-PrefixMap-shrink-DOMString-DOMString-iri"><code>shrink</code></dt><dd>Given an IRI for which a prefix is known (for example <code>&quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</code>)
    this method returns a CURIE (for example <code>&quot;rdfs:label&quot;</code>), if
    no prefix is known the original IRI is returned.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to shrink to a CURIE</td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd></dl></div>

<h3 id="example">Example</h3>
<p>This example illustrates how <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a> can be used
to resolve known CURIEs to IRIs, shrink IRIs in to CURIEs, and how to
specify and use a default prefix.</p>
<pre class="example"><span style="color: olivedrab">// create a new prefix mapping for the prefix &quot;rdfs&quot;</span>
prefixes.rdfs = &quot;http://www.w3.org/2000/01/rdf-schema#&quot;;

<span style="color: olivedrab">// resolve a known CURIE</span>
prefixes.resolve(&quot;rdfs:label&quot;); <span style="color: olivedrab">// &quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</span>

<span style="color: olivedrab">// shrink an IRI for a known CURIE in to a CURIE</span>
prefixes.shrink(&quot;http://www.w3.org/2000/01/rdf-schema#label&quot;); <span style="color: olivedrab">// &quot;rdfs:label&quot;</span>

<span style="color: olivedrab">// attempt to resolve a CURIE with an empty prefix</span>
prefixes.resolve(&quot;:me&quot;);  <span style="color: olivedrab">// &quot;:me&quot;</span>

<span style="color: olivedrab">// set the default prefix and attempt to resolve a CURIE with an empty prefix</span>
prefixes.setDefault(&quot;http://example.org/bob#&quot;);
prefixes.resolve(&quot;:me&quot;);  <span style="color: olivedrab">// &quot;http://example.org/bob#me&quot;</span></pre>

</div>

<div id="term-maps" typeof="bibo:Chapter" about="#term-maps" class="section">
<h4><span class="secno">3.2.2 </span>Term Maps</h4>
<pre class="idl"><span class="idlInterface" id="idl-def-TermMap">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">TermMap</span> {
<span class="idlMethod">    <span class="idlMethType"><a>omittable getter DOMString</a></span> <span class="idlMethName"><a href="#widl-TermMap-get-omittable-getter-DOMString-DOMString-term">get</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">term</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>omittable setter void</a></span>      <span class="idlMethName"><a href="#widl-TermMap-set-omittable-setter-void-DOMString-term-DOMString-iri">set</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">term</span></span>, <span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>omittable deleter void</a></span>     <span class="idlMethName"><a href="#widl-TermMap-remove-omittable-deleter-void-DOMString-term">remove</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">term</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span>                  <span class="idlMethName"><a href="#widl-TermMap-resolve-DOMString-DOMString-term">resolve</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">term</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span>                  <span class="idlMethName"><a href="#widl-TermMap-shrink-DOMString-DOMString-iri">shrink</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                       <span class="idlMethName"><a href="#widl-TermMap-setDefault-void-DOMString-iri">setDefault</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>TermmMap</a></span>                   <span class="idlMethName"><a href="#widl-TermMap-addAll-TermmMap-TermMap-terms-boolean-override">addAll</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></span> <span class="idlParamName">terms</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">override</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-8" class="section"><h5 id="methods-8">Methods</h5><dl class="methods"><dt id="widl-TermMap-addAll-TermmMap-TermMap-terms-boolean-override"><code>addAll</code></dt><dd>
    <p>This method returns the instance on which it was called.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">terms</td><td class="prmType"><code><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a> to import.</td></tr><tr><td class="prmName">override</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> then conflicting terms will be
        overridden by those specified on the <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a> being
        imported, by default imported terms augment the existing set.</td></tr></table><div><em>Return type: </em><code><a>TermmMap</a></code></div></dd><dt id="widl-TermMap-get-omittable-getter-DOMString-DOMString-term"><code>get</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">term</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The term <em class="rfc2119" title="must">must</em> not contain any whitespace or the <code>:</code> (single-colon) character</td></tr></table><div><em>Return type: </em><code><a>omittable getter DOMString</a></code></div></dd><dt id="widl-TermMap-remove-omittable-deleter-void-DOMString-term"><code>remove</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">term</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The term <em class="rfc2119" title="must">must</em> not contain any whitespace or the <code>:</code> (single-colon) character</td></tr></table><div><em>Return type: </em><code><a>omittable deleter void</a></code></div></dd><dt id="widl-TermMap-resolve-DOMString-DOMString-term"><code>resolve</code></dt><dd>
    <p>Given a valid term for which an IRI is known (for example <code>&quot;label&quot;</code>),
    this method will return the resulting IRI (for example <code>&quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</code>).</p>
    <p>If no term is known and a <code>default</code> has been set, the
    IRI is obtained by concatenating the <code>term</code> and the <code>default</code>
    iri.</p>
    <p>If no term is known and no <code>default</code> is set, then
    this method returns null.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">term</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The term to resolve.</td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd><dt id="widl-TermMap-set-omittable-setter-void-DOMString-term-DOMString-iri"><code>set</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">term</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The term <em class="rfc2119" title="must">must</em> not contain any whitespace or the <code>:</code> (single-colon) character</td></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">An IRI, as defined by [<cite><a class="bibref" rel="biblioentry" href="#bib-IRI">IRI</a></cite>]</td></tr></table><div><em>Return type: </em><code><a>omittable setter void</a></code></div></dd><dt id="widl-TermMap-setDefault-void-DOMString-iri"><code>setDefault</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The default iri to be used when an term cannot be resolved, the
        resulting IRI is obtained by concatenating this <code>iri</code> with
        the <code>term</code> being resolved.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-TermMap-shrink-DOMString-DOMString-iri"><code>shrink</code></dt><dd>Given an IRI for which an term is known (for example <code>&quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</code>)
    this method returns a term (for example <code>&quot;label&quot;</code>), if no
    term is known the original IRI is returned.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to shrink to an term</td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd></dl></div>

<h3 id="example-1">Example</h3>
<p>This example illustrates how <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a> can be used to
resolve known terms to IRIs, shrink IRIs for known terms in to terms,
and how to specify and use a default vocabulary for unknown terms.</p>
<pre class="example"><span style="color: olivedrab">// create a new term mapping for the term &quot;member&quot; </span>
terms.member = &quot;http://www.w3.org/ns/org#member&quot;;

<span style="color: olivedrab">// resolve a known term to an IRI</span>
terms.resolve(&quot;member&quot;); <span style="color: olivedrab">// &quot;http://www.w3.org/ns/org#member&quot;</span>

<span style="color: olivedrab">// shrink an IRI for a known term to a term</span>
terms.shrink(&quot;http://www.w3.org/ns/org#member&quot;); <span style="color: olivedrab">// &quot;member&quot;</span>

<span style="color: olivedrab">// attempt to resolve an unknown term</span>
terms.resolve(&quot;label&quot;); <span style="color: olivedrab">// null</span>

<span style="color: olivedrab">// set the default term vocabulary and then attempt to resolve an unknown term</span>
terms.setDefault(&quot;http://www.w3.org/2000/01/rdf-schema#&quot;);
terms.resolve(&quot;label&quot;); <span style="color: olivedrab">// &quot;http://www.w3.org/2000/01/rdf-schema#label&quot;</span></pre>

</div>

<div id="profiles" typeof="bibo:Chapter" about="#profiles" class="section">
<h4><span class="secno">3.2.3 </span>Profiles</h4>
<p>Profiles provide an easy to use context for negotiating between
CURIEs, Terms and IRIs.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-Profile">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">Profile</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></span> <span class="idlAttrName"><a href="#widl-Profile-prefixes">prefixes</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></span>   <span class="idlAttrName"><a href="#widl-Profile-terms">terms</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>DOMString</a></span> <span class="idlMethName"><a href="#widl-Profile-resolve-DOMString-DOMString-toresolve">resolve</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">toresolve</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>      <span class="idlMethName"><a href="#widl-Profile-setDefaultVocabulary-void-DOMString-iri">setDefaultVocabulary</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>      <span class="idlMethName"><a href="#widl-Profile-setDefaultPrefix-void-DOMString-iri">setDefaultPrefix</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>      <span class="idlMethName"><a href="#widl-Profile-setTerm-void-DOMString-term-DOMString-iri">setTerm</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">term</span></span>, <span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>      <span class="idlMethName"><a href="#widl-Profile-setPrefix-void-DOMString-prefix-DOMString-iri">setPrefix</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">prefix</span></span>, <span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">iri</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></span>   <span class="idlMethName"><a href="#widl-Profile-importProfile-Profile-Profile-profile-boolean-override">importProfile</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></span> <span class="idlParamName">profile</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">override</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-7" class="section"><h5 id="attributes-7">Attributes</h5><dl class="attributes"><dt id="widl-Profile-prefixes"><code>prefixes</code> of type <span class="idlAttrType"><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></span>, readonly</dt><dd>An instance of <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a></dd><dt id="widl-Profile-terms"><code>terms</code> of type <span class="idlAttrType"><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></span>, readonly</dt><dd>An instance of <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a></dd></dl></div><div typeof="bibo:Chapter" about="#methods-9" class="section"><h5 id="methods-9">Methods</h5><dl class="methods"><dt id="widl-Profile-importProfile-Profile-Profile-profile-boolean-override"><code>importProfile</code></dt><dd>
    <p>This method functions the same as calling <code>prefixes.addAll(profile.prefixes,
    override)</code> and <code>terms.addAll(profile.terms, override)</code>, and
    allows easy updating and merging of different profiles, such as those
    exposed by parsers.
    </p><p>This method returns the instance on which it was called.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">profile</td><td class="prmType"><code><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="Profile" href="#idl-def-Profile"><code>Profile</code></a> to import.</td></tr><tr><td class="prmName">override</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> then conflicting terms and prefixes will
        be overridden by those specified on the <a class="tref idlType" title="Profile" href="#idl-def-Profile"><code>Profile</code></a> being
        imported, by default imported terms and prefixes augment the existing
        set.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></code></div></dd><dt id="widl-Profile-resolve-DOMString-DOMString-toresolve"><code>resolve</code></dt><dd>
    <p>Given an Term or CURIE this method will return an IRI, or null if it cannot be resolved.</p>
    <p>If <code>toresolve</code> contains a <code>:</code> (colon) then this method returns the result of calling <code>prefixes.resolve(toresolve)</code></p>
    <p>otherwise this method returns the result of calling <code>terms.resolve(toresolve)</code></p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">toresolve</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">A string Term or CURIE.</td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd><dt id="widl-Profile-setDefaultPrefix-void-DOMString-iri"><code>setDefaultPrefix</code></dt><dd>This method sets the default prefix for use when resolving
    CURIEs without a prefix, for example <code>&quot;:me&quot;</code>, it is
    identical to calling the <code>setDefault</code> method on <code>prefixes</code>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to use as the default prefix.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-Profile-setDefaultVocabulary-void-DOMString-iri"><code>setDefaultVocabulary</code></dt><dd>This method sets the default vocabulary for use when resolving
    unknown terms, it is identical to calling the <code>setDefault</code>
    method on <code>terms</code>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to use as the default vocabulary.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-Profile-setPrefix-void-DOMString-prefix-DOMString-iri"><code>setPrefix</code></dt><dd>This method associates an IRI with a prefix, it is identical
    to calling the <code>set</code> method on <code>prefixes</code>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">prefix</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The prefix to set, <em class="rfc2119" title="must">must</em> not contain any whitespace.</td></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to associate with the prefix.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-Profile-setTerm-void-DOMString-term-DOMString-iri"><code>setTerm</code></dt><dd>This method associates an IRI with a term, it is identical to
    calling the <code>set</code> method on <code>term</code>.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">term</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The term to set, <em class="rfc2119" title="must">must</em> not contain any whitespace or the <code>:</code> (single-colon) character</td></tr><tr><td class="prmName">iri</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The IRI to associate with the term.</td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></div>

</div>
</div>

<div id="high-level-api" typeof="bibo:Chapter" about="#high-level-api" class="section">
<h3><span class="secno">3.3 </span>High level API</h3>
<p>The RDF Interfaces are primarily intended to enable interoperability
between RDF libraries and extensions, and for usage by advanced users.
Implementations are encouraged to provide their own sets of abstracted
interfaces and methods tailored to the use-cases they are addressing.</p>
<p>Implementors are encouraged to share implementations of various
interfaces defined in this specification, offering specialized or highly
optimized implementations of interfaces, for instance rigourously tested
parsers and serializers for specific RDF serializations, or highly
optimized Graph interfaces.</p>
<p>Methods to instantiate the basic interfaces required to work with
RDF data in a programming environment, are all exposed by a single
interface, as described in the following section.</p>
<div id="rdf-environment" typeof="bibo:Chapter" about="#rdf-environment" class="section">
<h4><span class="secno">3.3.1 </span>RDF Environment</h4>
<p>The RDF Environment is an interface which exposes a high level
API for working with RDF in a programming environment.</p>
<p>The RDF Environment interface extends <a class="tref idlType" title="Profile" href="#idl-def-Profile"><code>Profile</code></a> and
provides the default context for working with CURIEs, Terms and IRIs,
implementations are encouraged to offer rich prefix maps by default, and
<em class="rfc2119" title="must">must</em> instantiate the environment with the following prefixes defined:</p>
<table>
    <tbody><tr>
        <th>Prefix</th>
        <th>IRI</th>
    </tr>
    <tr>
        <td>owl</td>
        <td>http://www.w3.org/2002/07/owl#</td>
    </tr>
    <tr>
        <td>rdf</td>
        <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
    </tr>
    <tr>
        <td>rdfs</td>
        <td>http://www.w3.org/2000/01/rdf-schema#</td>
    </tr>
    <tr>
        <td>rdfa</td>
        <td>http://www.w3.org/ns/rdfa#</td>
    </tr>
    <tr>
        <td>xhv</td>
        <td>http://www.w3.org/1999/xhtml/vocab#</td>
    </tr>
    <tr>
        <td>xml</td>
        <td>http://www.w3.org/XML/1998/namespace</td>
    </tr>
    <tr>
        <td>xsd</td>
        <td>http://www.w3.org/2001/XMLSchema#</td>
    </tr>
</tbody></table>
<p>This interface also exposes all methods required to create
instances of TermMaps, PrefixMaps, Profiles and all the Concept
Interfaces.</p>
<p>Implementations of the RDFEnvironment <em class="rfc2119" title="must">must</em> expose all the methods defined on
this interface, as defined by this specification.</p>
<p>Future RDF Interface extensions and modules <em class="rfc2119" title="may">may</em> supplement this
interface with methods and attributes which expose the functionality
they define, in a manner consistent with this API.</p>

<pre class="idl"><span class="idlInterface" id="idl-def-RDFEnvironment">interface <span class="idlInterfaceID">RDFEnvironment</span> : <span class="idlSuperclass"><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></span> {
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-BlankNode" class="idlType"><code>BlankNode</code></a></span>    <span class="idlMethName"><a href="#widl-RDFEnvironment-createBlankNode-BlankNode">createBlankNode</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a></span>    <span class="idlMethName"><a href="#widl-RDFEnvironment-createNamedNode-NamedNode-DOMString-value">createNamedNode</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">value</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Literal" class="idlType"><code>Literal</code></a></span>      <span class="idlMethName"><a href="#widl-RDFEnvironment-createLiteral-Literal-DOMString-value-DOMString-language-NamedNode-datatype">createLiteral</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">value</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>DOMString</a>?</span> <span class="idlParamName">language</span></span>, <span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a>?</span> <span class="idlParamName">datatype</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span>       <span class="idlMethName"><a href="#widl-RDFEnvironment-createTriple-Triple-RDFNode-subject-RDFNode-predicate-RDFNode-object">createTriple</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlParamName">subject</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlParamName">predicate</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></span> <span class="idlParamName">object</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>        <span class="idlMethName"><a href="#widl-RDFEnvironment-createGraph-Graph---Triple-triples">createGraph</a></span> (<span class="idlParam">optional <span class="idlParamType"><a>[]Triple</a></span> <span class="idlParamName">triples</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a></span> <span class="idlMethName"><a href="#widl-RDFEnvironment-createAction-TripleAction-TripleFilter-test-TripleCallback-action">createAction</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">test</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></span> <span class="idlParamName">action</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></span>      <span class="idlMethName"><a href="#widl-RDFEnvironment-createProfile-Profile-boolean-empty">createProfile</a></span> (<span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">empty</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></span>      <span class="idlMethName"><a href="#widl-RDFEnvironment-createTermMap-TermMap-boolean-empty">createTermMap</a></span> (<span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">empty</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></span>    <span class="idlMethName"><a href="#widl-RDFEnvironment-createPrefixMap-PrefixMap-boolean-empty">createPrefixMap</a></span> (<span class="idlParam">optional <span class="idlParamType"><a>boolean</a></span> <span class="idlParamName">empty</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-10" class="section"><h5 id="methods-10">Methods</h5><dl class="methods"><dt id="widl-RDFEnvironment-createAction-TripleAction-TripleFilter-test-TripleCallback-action"><code>createAction</code></dt><dd>Creates a <a class="tref idlType" title="TripleAction" href="#idl-def-TripleAction"><code>TripleAction</code></a> given a <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a>
    test and a <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> action.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">test</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to <code>test</code> the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        against.</td></tr><tr><td class="prmName">action</td><td class="prmType"><code><a href="#idl-def-TripleCallback" class="idlType"><code>TripleCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The action to run should the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> being tried
        pass the <code>test</code>.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-TripleAction" class="idlType"><code>TripleAction</code></a></code></div></dd><dt id="widl-RDFEnvironment-createBlankNode-BlankNode"><code>createBlankNode</code></dt><dd>Creates a new <a class="tref idlType" title="BlankNode" href="#idl-def-BlankNode"><code>BlankNode</code></a>.<div><em>No parameters.</em></div><div><em>Return type: </em><code><a href="#idl-def-BlankNode" class="idlType"><code>BlankNode</code></a></code></div></dd><dt id="widl-RDFEnvironment-createGraph-Graph---Triple-triples"><code>createGraph</code></dt><dd>Creates a new <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, an optional array of <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s
    to include within the graph may be specified, this allows easy
    transition between native arrays and <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>s and is the
    counterpart for the <code>toArray</code> method of the <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
    interface.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triples</td><td class="prmType"><code><a>[]Triple</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional array of <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>s to be added to the
        <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> as it is created.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></div></dd><dt id="widl-RDFEnvironment-createLiteral-Literal-DOMString-value-DOMString-language-NamedNode-datatype"><code>createLiteral</code></dt><dd>Creates a <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a> given a value, an optional
    language and/or an optional datatype.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">value</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">
        <p>The value to be represented by the <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a>, the <code>value</code>
        <em class="rfc2119" title="must">must</em> be a lexical representation of the value.</p>
        </td></tr><tr><td class="prmName">language</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptTrue">✔</td><td class="prmDesc">The language that is associated with the <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a>
        encoded according to the rules outlined in [<cite><a class="bibref" rel="biblioentry" href="#bib-BCP47">BCP47</a></cite>].</td></tr><tr><td class="prmName">datatype</td><td class="prmType"><code><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a></code></td><td class="prmNullTrue">✔</td><td class="prmOptTrue">✔</td><td class="prmDesc">The datatype of the <a class="tref idlType" title="Literal" href="#idl-def-Literal"><code>Literal</code></a>.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Literal" class="idlType"><code>Literal</code></a></code></div></dd><dt id="widl-RDFEnvironment-createNamedNode-NamedNode-DOMString-value"><code>createNamedNode</code></dt><dd>Creates a NamedNode identified by the given IRI.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">value</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">An IRI, CURIE or TERM.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-NamedNode" class="idlType"><code>NamedNode</code></a></code></div></dd><dt id="widl-RDFEnvironment-createPrefixMap-PrefixMap-boolean-empty"><code>createPrefixMap</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">empty</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> is specified then an empty <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a>
        will be returned, by default the <a class="tref idlType" title="PrefixMap" href="#idl-def-PrefixMap"><code>PrefixMap</code></a> returned will
        be populated with prefixes replicating those of the current RDF
        environment.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-PrefixMap" class="idlType"><code>PrefixMap</code></a></code></div></dd><dt id="widl-RDFEnvironment-createProfile-Profile-boolean-empty"><code>createProfile</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">empty</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> is specified then a profile with an
        empty TermMap and PrefixMap will be returned, by default the <a class="tref idlType" title="Profile" href="#idl-def-Profile"><code>Profile</code></a>
        returned will contain populated term and prefix maps replicating those
        of the current RDF environment.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Profile" class="idlType"><code>Profile</code></a></code></div></dd><dt id="widl-RDFEnvironment-createTermMap-TermMap-boolean-empty"><code>createTermMap</code></dt><dd>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">empty</td><td class="prmType"><code><a>boolean</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">If <code>true</code> is specified then an empty <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a>
        will be returned, by default the <a class="tref idlType" title="TermMap" href="#idl-def-TermMap"><code>TermMap</code></a> returned will be
        populated with terms replicating those of the current RDF environment.
        </td></tr></table><div><em>Return type: </em><code><a href="#idl-def-TermMap" class="idlType"><code>TermMap</code></a></code></div></dd><dt id="widl-RDFEnvironment-createTriple-Triple-RDFNode-subject-RDFNode-predicate-RDFNode-object"><code>createTriple</code></dt><dd>Creates a <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> given a subject, predicate and
    object. If any incoming value does not match the requirements listed
    below, a Null value <em class="rfc2119" title="must">must</em> be returned by this method.
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">subject</td><td class="prmType"><code><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The subject value of the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</td></tr><tr><td class="prmName">predicate</td><td class="prmType"><code><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The predicate value of the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</td></tr><tr><td class="prmName">object</td><td class="prmType"><code><a href="#idl-def-RDFNode" class="idlType"><code>RDFNode</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The object value of the <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>.</td></tr></table><div><em>Return type: </em><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></div></dd></dl></div>

</div>
</div>

</div>
<div id="rdf-data-interfaces" typeof="bibo:Chapter" about="#rdf-data-interfaces" class="section">

<!-- OddPage -->
<h2><span class="secno">4. </span>RDF Data Interfaces</h2>
<div id="overview-2" typeof="bibo:Chapter" about="#overview-2" class="section">
<h3><span class="secno">4.1 </span>Overview</h3>
<p>The RDF Data Interfaces are modular, standalone interfaces which
can be implemented by RDF Libraries and API extensions to enable
interoperability.</p>
<p>Developers and Specification authors are encouraged to use these
interfaces when defining functionality within one of the realms covered
by these interfaces.</p>
<p>Parser and Serializer implementors <em class="rfc2119" title="should">should</em> provide relevant parse,
process or serialize methods on the RDF Environment interface for their
implementations. For example a Turtle parser <em class="rfc2119" title="should">should</em> augment
RDFEnvironment with <code>parseTurtle</code> and <code>processTurtle</code>
methods which accept a String <code>toparse</code> argument, whilst an
RDFa parser <em class="rfc2119" title="should">should</em> augment RDFEnvironment with a <code>parseRDFa</code>
method which accepts a <code>Document</code> argument.</p>
</div>
<div class="normative section" id="parsing-and-serializing-data" typeof="bibo:Chapter" about="#parsing-and-serializing-data">
<h3><span class="secno">4.2 </span>Parsing and Serializing Data</h3>

<div class="normative section" about="#data-parsers" id="data-parsers" typeof="bibo:Chapter">
<h4><span class="secno">4.2.1 </span>Data Parsers</h4>
<p>The <a class="tref idlType" title="DataParser" href="#idl-def-DataParser"><code>DataParser</code></a> is a generic RDF document parser
which can be used to either parse the triples serialized within an RDF
document in to a <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, or to process an RDF document by
passing each triple found to a <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> for
processing.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-DataParser">[<span class="extAttr">NoInterfaceObject, Constructor, Constructor(in RDFEnvironment rdf)</span>]
interface <span class="idlInterfaceID">DataParser</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlAttrName"><a href="#widl-DataParser-processorGraph">processorGraph</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span> <span class="idlMethName"><a href="#widl-DataParser-parse-boolean-any-toparse-ParserCallback-callback-DOMString-base-TripleFilter-filter-Graph-graph">parse</a></span> (<span class="idlParam"><span class="idlParamType"><a>any</a></span> <span class="idlParamName">toparse</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-ParserCallback" class="idlType"><code>ParserCallback</code></a>?</span> <span class="idlParamName">callback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">base</span></span>, <span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">filter</span></span>, <span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>boolean</a></span> <span class="idlMethName"><a href="#widl-DataParser-process-boolean-any-toparse-ProcessorCallback-callback-DOMString-base-TripleFilter-filter">process</a></span> (<span class="idlParam"><span class="idlParamType"><a>any</a></span> <span class="idlParamName">toparse</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-ProcessorCallback" class="idlType"><code>ProcessorCallback</code></a></span> <span class="idlParamName">callback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">base</span></span>, <span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></span> <span class="idlParamName">filter</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#attributes-8" class="section"><h5 id="attributes-8">Attributes</h5><dl class="attributes"><dt id="widl-DataParser-processorGraph"><code>processorGraph</code> of type <span class="idlAttrType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span>, readonly</dt><dd>An optional <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> produced by RDF Parsers
    containing additional parsing information and errors.</dd></dl></div><div typeof="bibo:Chapter" about="#methods-11" class="section"><h5 id="methods-11">Methods</h5><dl class="methods"><dt id="widl-DataParser-parse-boolean-any-toparse-ParserCallback-callback-DOMString-base-TripleFilter-filter-Graph-graph"><code>parse</code></dt><dd>
    <p>Parses the triples serialized within an input RDF document in to
    a <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, then executes a given <a class="tref idlType" title="ParserCallback" href="#idl-def-ParserCallback"><code>ParserCallback</code></a>
    on the populated <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>.</p>
    <p>If a <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> is passed to the parser, then
    each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> found in the document will only be added to
    the output <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> if it passes the test implemented by the
    <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a>.</p>
    <p>By default a new <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> is provided, however users
    may optionally specify a <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> to which the parsed triples
    will be added. This allows users to provide a custom or persistent <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
    implementation, or to automatically merge the triples from several
    documents in to a single <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>.</p>
    <p>A boolean response is given indicating if the parse was
    successful or not.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">toparse</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The document to parse, the type of argument required may
        further be constrained by implementations of this interface, for
        instance an RDFa parser may require an instance of <code>Document</code>,
        whilst a <code>Turtle</code> parser may require a <code>String</code>.</td></tr><tr><td class="prmName">callback</td><td class="prmType"><code><a href="#idl-def-ParserCallback" class="idlType"><code>ParserCallback</code></a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="ParserCallback" href="#idl-def-ParserCallback"><code>ParserCallback</code></a> to execute once the parse has
        completed, the <a class="tref idlType" title="ParserCallback" href="#idl-def-ParserCallback"><code>ParserCallback</code></a> will be passed a single
        argument which is the propulated <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>.</td></tr><tr><td class="prmName">base</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional base to be used by the parser when resolving
        relative IRI references.</td></tr><tr><td class="prmName">filter</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to test each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        against before adding to the output <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, only those
        triples successfully passing the test will be added to the output
        graph.</td></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> to add the parsed triples to,
        if no <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> is provided then a new, empty, <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
        will be used.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd><dt id="widl-DataParser-process-boolean-any-toparse-ProcessorCallback-callback-DOMString-base-TripleFilter-filter"><code>process</code></dt><dd>
    <p>Parses the triples serialized within an input RDF document and
    passes each (non filtered) <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> found to a <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a>,
    this interface allows RDF documents to be processed by SAX-like parsers
    whilst maintaining a minimal memory footprint.</p>
    <p>If a <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> is passed to the parser, then
    each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> found in the document will only be passed to
    the <a class="tref idlType" title="TripleCallback" href="#idl-def-TripleCallback"><code>TripleCallback</code></a> if it passes the test implmented by the
    filter.</p>
    
    <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">toparse</td><td class="prmType"><code><a>any</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The document to parse, the type of argument required may
        further be constrained by implementations of this interface, for
        instance an RDFa parser may require an instance of <code>Document</code>,
        whilst a <code>Turtle</code> parser may require a <code>String</code>.</td></tr><tr><td class="prmName">callback</td><td class="prmType"><code><a href="#idl-def-ProcessorCallback" class="idlType"><code>ProcessorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc">The <a class="tref idlType" title="ProcessorCallback" href="#idl-def-ProcessorCallback"><code>ProcessorCallback</code></a> to execute on each
        (non-filtered) <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a> found by the parser.</td></tr><tr><td class="prmName">base</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional base to be used by the parser when resolving
        relative IRI references.</td></tr><tr><td class="prmName">filter</td><td class="prmType"><code><a href="#idl-def-TripleFilter" class="idlType"><code>TripleFilter</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc">An optional <a class="tref idlType" title="TripleFilter" href="#idl-def-TripleFilter"><code>TripleFilter</code></a> to test each <a class="tref idlType" title="Triple" href="#idl-def-Triple"><code>Triple</code></a>
        against before adding to the output <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>, only those
        triples successfully passing the test will be added to the output
        graph.</td></tr></table><div><em>Return type: </em><code><a>boolean</a></code></div></dd></dl></div>

<div typeof="bibo:Chapter" about="#examples" class="section">
<h5 id="examples">Examples</h5>
<p>Example of basic and advanced DataParser.parse usage:</p>
<pre class="example"><span style="color: olivedrab">// basic usage</span>
turtle.parse(doc, function(graph) {
  <span style="color: olivedrab">// work with graph here ..</span>
});

<span style="color: olivedrab">// advanced usage, retrieve a graph containing only those triples</span>
<span style="color: olivedrab">// with a subject of &quot;&lt;http://example.org/bob#me&gt;&quot;</span>
var filter = function(t) { <span style="color: olivedrab">// create a filter</span>
  return t.subject.equals( &quot;http://example.org/bob#me&quot; );
};
var parsercb = function(graph) {
  <span style="color: olivedrab">// work with graph here</span>
};
turtle.parse(doc, parsercb, &quot;http://example.org/bob&quot;, filter);</pre>

<p>Example of basic and advanced DataParser.process usage:</p>
<pre class="example"><span style="color: olivedrab">// basic usage</span>
turtle.process(doc, function(t) {
  <span style="color: olivedrab">// work with triples here ..</span>
});

<span style="color: olivedrab">// advanced usage, process only those triples with a predicate of rdf:type</span>
var filter = function(t) { <span style="color: olivedrab">// create a filter</span>
  return t.predicate.equals( rdf.resolve(&quot;rdf:type&quot;) );
};
var processor = function(t) {
  <span style="color: olivedrab">// work with triples here</span>
};
turtle.process(doc, processor, &quot;http://example.org/bob&quot;, filter);</pre>
</div>
</div>

<div class="normative section" id="data-serializers" typeof="bibo:Chapter" about="#data-serializers">
<h4><span class="secno">4.2.2 </span>Data Serializers</h4>
<p>The <a class="tref idlType" title="DataSerializer" href="#idl-def-DataSerializer"><code>DataSerializer</code></a> is a generic interface
implemented by <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a> serializers.</p>
<p>Implementations of this interface may further constrain the
return type, for instance an RDFa serializer may return an instance of <code>Document</code>,
whilst a <code>Turtle</code> serializer may return a <code>String</code>.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-DataSerializer">[<span class="extAttr">NoInterfaceObject, Constructor, Constructor(in RDFEnvironment rdf)</span>]
interface <span class="idlInterfaceID">DataSerializer</span> {
<span class="idlMethod">    <span class="idlMethType"><a>any</a></span> <span class="idlMethName"><a href="#widl-DataSerializer-serialize-any-Graph-graph">serialize</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-12" class="section"><h5 id="methods-12">Methods</h5><dl class="methods"><dt id="widl-DataSerializer-serialize-any-Graph-graph"><code>serialize</code></dt><dd>A method, which when called will serialize the given <a class="tref idlType" title="Graph" href="#idl-def-Graph"><code>Graph</code></a>
    and return the resulting serialization.<table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>any</a></code></div></dd></dl></div>
</div>

<div class="normative section" id="additional-interfaces-1" typeof="bibo:Chapter" about="#additional-interfaces-1">
<h4><span class="secno">4.2.3 </span>Additional Interfaces</h4>
<p>The <a class="tref idlType" title="ParserCallback" href="#idl-def-ParserCallback"><code>ParserCallback</code></a> interface is used by the <code>parse</code>
method of the <a class="tref idlType" title="DataParser" href="#idl-def-DataParser"><code>DataParser</code></a> interface.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-ParserCallback">[<span class="extAttr">NoInterfaceObject Callback</span>]
interface <span class="idlInterfaceID">ParserCallback</span> {
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-ParserCallback-run-void-Graph-graph">run</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></span> <span class="idlParamName">graph</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-13" class="section"><h5 id="methods-13">Methods</h5><dl class="methods"><dt id="widl-ParserCallback-run-void-Graph-graph"><code>run</code></dt><dd>A function to be executed on a Graph produced by a parse
    operation on an RDF Document.<table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">graph</td><td class="prmType"><code><a href="#idl-def-Graph" class="idlType"><code>Graph</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></div>

<p>The <a class="tref idlType" title="ProcessorCallback" href="#idl-def-ProcessorCallback"><code>ProcessorCallback</code></a> interface is used by the <code>process</code>
method of the <a class="tref idlType" title="DataParser" href="#idl-def-DataParser"><code>DataParser</code></a> interface.</p>
<pre class="idl"><span class="idlInterface" id="idl-def-ProcessorCallback">[<span class="extAttr">NoInterfaceObject Callback</span>]
interface <span class="idlInterfaceID">ProcessorCallback</span> {
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-ProcessorCallback-run-void-Triple-triple">run</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></span> <span class="idlParamName">triple</span></span>);</span>
};</span>
</pre><div typeof="bibo:Chapter" about="#methods-14" class="section"><h5 id="methods-14">Methods</h5><dl class="methods"><dt id="widl-ProcessorCallback-run-void-Triple-triple"><code>run</code></dt><dd>A function to be executed on a Triple produced by a process
    operation on an RDF Document.<table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">triple</td><td class="prmType"><code><a href="#idl-def-Triple" class="idlType"><code>Triple</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></div>

</div>

</div>

</div>

<div class="appendix section" id="acknowledgements" typeof="bibo:Chapter" about="#acknowledgements">

<!-- OddPage -->
<h2><span class="secno">A. </span>Acknowledgements</h2>
<p>At the time of publication, the members of the RDF Web Application Working Group
were:</p>
<ul>
<li>Ben Adida, Mozilla</li>
<li>Benjamin Adrian, German Research Center for Artificial Intelligence (DFKI) Gmbh</li>
<li>Mark Birbeck, webBackplane.com (Invited Expert)</li>
<li>Markus Gylling, DAISY Consortium</li>
<li>Ivan Herman, <acronym title="World Wide Web Consortium">W3C</acronym></li>
<li>Toby Inkster (Invited Expert)</li>
<li>Shane McCarron, Applied Testing and Technology, Inc. (Invited Expert)</li>
<li>Knud Möller, DERI Galway at the National University of Ireland</li>
<li>John O'Donovan, British Broadcasting Corporation</li>
<li>Steven Pemberton, Centre for Mathematics and Computer Science (CWI)</li>
<li>Nathan Rixham (Invited Expert)</li>
<li>Manu Sporny, Digital Bazaar (Chair, Invited Expert)</li>
<li>Thomas Steiner, Google</li>
<li>Ted Thibodeau, OpenLink Software</li>
<li>Robert Weir, IBM Corporation</li>
</ul>
</div>

<!-- 
<h1>IDL Definitions</h1>
<p>
This document contains the Web IDL definitions of the RDFa DOM
API: <a href="rdfa_dom_api.idl">rdfa_dom_api.idl</a></p>
</section>
<section class="appendix informative">
<h1>ECMAScript API Interface Example</h1>
<p>
This document contains a ECMAScript interface implementation for the RDFa 
API:<a href="rdfa_dom_api.js">rdfa_dom_api.js</a></p>
 -->



<div id="references" class="appendix section" typeof="bibo:Chapter" about="#references">
<!-- OddPage -->
<h2><span class="secno">B. </span>References</h2><div id="normative-references" typeof="bibo:Chapter" about="#normative-references" class="section"><h3><span class="secno">B.1 </span>Normative references</h3><dl class="bibliography" about=""><dt id="bib-BCP47">[BCP47]</dt><dd rel="dcterms:requires">A. Phillips, M. Davis. <a href="http://tools.ietf.org/rfc/bcp/bcp47.txt"><cite>Tags for Identifying Languages</cite></a> September 2009. IETF Best Current Practice. URL: <a href="http://tools.ietf.org/rfc/bcp/bcp47.txt">http://tools.ietf.org/rfc/bcp/bcp47.txt</a>
</dd><dt id="bib-IRI">[IRI]</dt><dd rel="dcterms:requires">M. Duerst, M. Suignard. <a href="http://www.ietf.org/rfc/rfc3987.txt"><cite>Internationalized Resource Identifiers (IRI).</cite></a> January 2005. Internet RFC 3987. URL: <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3987.txt</a> 
</dd><dt id="bib-RDF-CONCEPTS">[RDF-CONCEPTS]</dt><dd rel="dcterms:requires">Graham Klyne; Jeremy J. Carroll. <a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210"><cite>Resource Description Framework (RDF): Concepts and Abstract Syntax.</cite></a> 10 February 2004. W3C Recommendation. URL: <a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210">http://www.w3.org/TR/2004/REC-rdf-concepts-20040210</a> 
</dd><dt id="bib-RDF-TESTCASES">[RDF-TESTCASES]</dt><dd rel="dcterms:requires">Jan Grant; Dave Beckett. <a href="http://www.w3.org/TR/2004/REC-rdf-testcases-20040210"><cite>RDF Test Cases.</cite></a> 10 February 2004. W3C Recommendation. URL: <a href="http://www.w3.org/TR/2004/REC-rdf-testcases-20040210">http://www.w3.org/TR/2004/REC-rdf-testcases-20040210</a> 
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd rel="dcterms:requires">S. Bradner. <a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>Key words for use in RFCs to Indicate Requirement Levels.</cite></a> March 1997. Internet RFC 2119.  URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a> 
</dd><dt id="bib-WEBIDL">[WEBIDL]</dt><dd rel="dcterms:requires">Cameron McCormack. <a href="http://www.w3.org/TR/2011/WD-WebIDL-20110927/"><cite>Web IDL.</cite></a> 27 September 2011. W3C Working Draft. (Work in progress.) URL: <a href="http://www.w3.org/TR/2011/WD-WebIDL-20110927/">http://www.w3.org/TR/2011/WD-WebIDL-20110927/</a> 
</dd></dl></div><div id="informative-references" typeof="bibo:Chapter" about="#informative-references" class="section"><h3><span class="secno">B.2 </span>Informative references</h3><dl class="bibliography" about=""><dt id="bib-TURTLE">[TURTLE]</dt><dd rel="dcterms:references">David Beckett, Tim Berners-Lee. <a href="http://www.w3.org/TeamSubmission/turtle/"><cite>Turtle: Terse RDF Triple Language.</cite></a> January 2008. W3C Team Submission. URL: <a href="http://www.w3.org/TeamSubmission/turtle/">http://www.w3.org/TeamSubmission/turtle/</a> 
</dd></dl></div></div></body></html>
